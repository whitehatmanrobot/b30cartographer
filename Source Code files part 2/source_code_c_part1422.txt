face:
//
public:
    virtual BOOL Succeeded() const { return SUCCEEDED(m_hrInterface); }
    virtual HRESULT QueryResult() const { return m_hrInterface; }
    virtual HRESULT ChangeProxyBlanket(
        LPCOLESTR lpszUserName, 
        LPCOLESTR lpszPassword
        );

//
// Conversion Operators
//
public:
    operator BOOL() const { return Succeeded(); }
    operator HRESULT() const { return m_hrInterface; }

protected:
    virtual HRESULT ApplyProxyBlanket() = 0;
    HRESULT Create(
        int   cInterfaces,       
        const IID rgIID[],      
        const GUID rgCLSID[],    
        int * pnInterface,          OPTIONAL
        IUnknown ** ppInterface 
        );

protected:
    CComAuthInfo m_auth;
    HRESULT    m_hrInterface;
};


class _EXPORT CMetaInterface : public CIISInterface
/*++

Class description:

    Metabase interface class.

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Regenerate          : Recreate the interface

--*/
{
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CMetaInterface();

//
// Constructor/Destructor
//
protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to indicate the local computer name
    //
    CMetaInterface(
        CComAuthInfo * pServer
        );

    //
    // Construct from existing interface
    //
    CMetaInterface(
        CMetaInterface * pInterface
        );

public:
    //
    // Rebuild the interface
    //
    HRESULT Regenerate();

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a metadata object in this server. This function initializes the
    // metadata object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IADMW Interface -- all methods defines as inline at the end of this file.
//
protected:
    HRESULT OpenKey(
        METADATA_HANDLE hkBase,
        LPCTSTR lpszMDPath,
        DWORD dwFlags,
        METADATA_HANDLE * phMDNewHandle
        );

    HRESULT CloseKey(
        METADATA_HANDLE hKey
        );

    HRESULT SetLastChangeTime( 
        METADATA_HANDLE hMDHandle,
        LPCTSTR pszMDPath,
        FILETIME * pftMDLastChangeTime,
        BOOL bLocalTime
        );
        
    HRESULT GetLastChangeTime( 
        METADATA_HANDLE hMDHandle,
        LPCTSTR lpszMDPath,
        FILETIME * pftMDLastChangeTime,
        BOOL bLocalTime
        );

    HRESULT AddKey( 
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath
        );

    HRESULT DeleteKey(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath
        );

    HRESULT DeleteChildKeys(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath
        );

    HRESULT EnumKeys(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        LPTSTR lpszMDName,
        DWORD dwIndex
        );

    HRESULT CopyKey(
        METADATA_HANDLE hSourceKey,
        LPCTSTR lpszMDSourcePath,
        METADATA_HANDLE hDestKey,
        LPCTSTR lpszMDDestPath,
        BOOL fOverwrite,
        BOOL fCopy
        );

    HRESULT RenameKey(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        LPCTSTR lpszNewName
        );

    HRESULT GetData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        METADATA_RECORD * pmdRecord,
        DWORD * pdwRequiredDataLen
        );

    HRESULT SetData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        METADATA_RECORD * pmdRecord
        );

    HRESULT DeleteData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        DWORD dwMDIdentifier,
        DWORD dwMDDataType
        );

    HRESULT EnumData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        METADATA_RECORD * pmdRecord,
        DWORD dwIndex,
        DWORD * pdwRequiredDataLen
        );

    HRESULT GetAllData(
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        DWORD dwMDAttributes,
        DWORD dwMDUserType,
        DWORD dwMDDataType,
        DWORD * pdwMDNumDataEntries,
        DWORD * pdwMDDataSetNumber,
        DWORD dwMDBufferSize,
        LPBYTE pbMDBuffer,
        DWORD * pdwRequiredBufferSize
        );

    HRESULT DeleteAllData( 
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        DWORD dwMDUserType,
        DWORD dwMDDataType
        );

    HRESULT CopyData( 
        METADATA_HANDLE hMDSourceKey,
        LPCTSTR lpszMDSourcePath,
        METADATA_HANDLE hMDDestKey,
        LPCTSTR lpszMDDestPath,
        DWORD dwMDAttributes,
        DWORD dwMDUserType,
        DWORD dwMDDataType,
        BOOL fCopy
        );

    HRESULT GetDataPaths( 
        METADATA_HANDLE hKey,
        LPCTSTR lpszMDPath,
        DWORD dwMDIdentifier,
        DWORD dwMDDataType,
        DWORD dwMDBufferSize,
        LPTSTR lpszBuffer,
        DWORD * pdwMDRequiredBufferSize
        );

    HRESULT Backup( 
        LPCTSTR lpszBackupLocation,
        DWORD dwMDVersion,
        DWORD dwMDFlags
        );

    HRESULT Restore(    
        LPCTSTR lpszBackupLocation,
        DWORD dwMDVersion,
        DWORD dwMDFlags
        );

    HRESULT EnumBackups(
        LPTSTR lpszBackupLocation,
        DWORD * pdwMDVersion,
        FILETIME * pftMDBackupTime,
        DWORD dwIndex
        );

    HRESULT DeleteBackup(
        LPCTSTR lpszBackupLocation,
        DWORD dwMDVersion
        );

protected:
    IMSAdminBase * m_pInterface; 

private:
    int  m_iTimeOutValue;         
};



class _EXPORT CMetaKey : public CMetaInterface
/*++

Class Description:

    Metabase key wrapper class

Public Interface:

    CMetaKey                    : Constructor
    ~CMetaKey                   : Destructor

    Succeeded                   : TRUE if key opened successfully.
    QueryResult                 : Get the HRESULT status

    QueryValue                  : Various overloaded methods to get values
    SetValue                    : Various overloaded methods to set values
    DeleteValue                 : Delete a value
    Open                        : Open key
    ReOpen                      : Re key that was opened before
    Close                       : Close key
    ConvertToParentPath         : Change path to parent path

    operator METADATA_HANDLE    : Cast to a metadata handle
    operator LPCTSTR            : Cast to the metabase path
    operator BOOL               : Cast to TRUE if the key is open, FALSE if not

    GetHandle                   : Obtain metadata handle
    IsOpen                      : TRUE if a key is open
    QueryMetaPath               : Get the relative metabase path
    QueryFlags                  : Get the open permissions

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Null constructor that only creates the interface.
    // A key constructed this way may read from META_ROOT_HANDLE.
    // This is not true of other constructors.
    //
    CMetaKey(
        CComAuthInfo * pServer
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        CMetaInterface * pInterface
        );

    //
    // Fully defined constructor that opens a key
    //
    CMetaKey(
        CComAuthInfo * pServer,
        LPCTSTR lpszMDPath,
        DWORD   dwFlags        = METADATA_PERMISSION_READ,
        METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // As above, using an existing interface
    //
    CMetaKey(
        CMetaInterface * pInterface,
        LPCTSTR lpszMDPath,
        DWORD   dwFlags        = METADATA_PERMISSION_READ,
        METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Copy constructor, might or might not own the key
    //
    CMetaKey(
        BOOL fOwnKey,
        CMetaKey * pKey
        );

    //
    // Destructor -- closes key.
    //
    virtual ~CMetaKey();

//
// Interface
//
public:
    //
    // Fetch a DWORD
    //
    HRESULT QueryValue(
        DWORD dwID, 
        DWORD & dwValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a boolean
    //
    HRESULT QueryValue(
        DWORD dwID, 
        BOOL & fValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string
    //
    HRESULT QueryValue(
        DWORD dwID, 
        CString & strValue, 
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a BSTR
    //
    HRESULT QueryValue(
        DWORD dwID, 
        CComBSTR & strValue, 
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch a string list
    //
    HRESULT QueryValue(
        DWORD dwID, 
        CStringListEx & strlValue, 
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Fetch binary blob
    //
    HRESULT QueryValue(
        DWORD dwID, 
        CBlob & blValue, 
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL,
        DWORD * pdwAttributes        = NULL
        );

    //
    // Store a DWORD
    //
    HRESULT SetValue(
        DWORD dwID,
        DWORD dwValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BOOL
    //
    HRESULT SetValue(
        DWORD dwID,
        BOOL fValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a string
    //
    HRESULT SetValue(
        DWORD dwID,
        CString & strValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );

    //
    // Store a BSTR
    //
    HRESULT SetValue(
        DWORD dwID,
        CComBSTR & strValue,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );


    //
    // Store a stringlist
    //
    HRESULT SetValue(
        DWORD dwID,
        CStringListEx & strlValue,
        BOOL * pfInheritanceOverride  = NULL,
        LPCTSTR lpszMDPath            = NULL
        );

    //
    // Store a binary blob
    //
    HRESULT SetValue(
        DWORD dwID,
        CBlob & blValue,
        BOOL * pfInheritanceOverride  = NULL,
        LPCTSTR lpszMDPath            = NULL
        );

    //
    // Delete Value:
    //
    HRESULT DeleteValue(
        DWORD   dwID,
        LPCTSTR lpszMDPath = NULL
        );

    //
    // Check for path existance
    //
    HRESULT DoesPathExist(
        LPCTSTR lpszMDPath
        );

    //
    // Create current path (which we attempted to open, and got
    // a path not found error on).
    //
    HRESULT CreatePathFromFailedOpen();

    //
    // Check for descendant overrides
    //
    HRESULT CheckDescendants(
        DWORD   dwID,
        CComAuthInfo * pServer,
        LPCTSTR lpszMDPath       = NULL
        );

    //
    // Open key
    //
    HRESULT Open(
        DWORD   dwFlags,
        LPCTSTR lpszMDPath       = NULL,
        METADATA_HANDLE hkBase   = METADATA_MASTER_ROOT_HANDLE 
        );

    //
    // Re-open previously opened key
    //
    HRESULT ReOpen(
        DWORD   dwFlags
        );

    //
    // As above using the same permissions as before
    //
    HRESULT ReOpen();

    //
    // Open the parent object
    // 
    HRESULT ConvertToParentPath(
        BOOL fImmediate
        );

    //
    // Close key, set it to NULL, but doesn't destroy the interface
    //
    HRESULT Close();

    //
    // Add key
    //
    HRESULT AddKey(
        LPCTSTR lpszMDPath
        );

    //
    // Delete key off currently open key
    //
    HRESULT DeleteKey(
        LPCTSTR lpszMDPath
        );

    //
    // Rename key off currently open key
    //
    HRESULT RenameKey(
        LPCTSTR lpszMDPath,
        LPCTSTR lpszNewName
        );

    //
    // Get list of descendant nodes that override
    // a specific value
    //
    HRESULT GetDataPaths( 
        CStringListEx & strlNodes,
        DWORD dwMDIdentifier,
        DWORD dwMDDataType,
        LPCTSTR lpszMDPath = NULL
        );


//
// Access
//
public:
    METADATA_HANDLE GetHandle() const { return m_hKey; }
    METADATA_HANDLE GetBase() const   { return m_hBase; }
    LPCTSTR QueryMetaPath() const     { return m_strMetaPath; }
    DWORD QueryFlags() const          { return m_dwFlags; }
    BOOL IsOpen() const               { return m_hKey != NULL; }
    BOOL IsHomeDirectoryPath() const ;

//
// Conversion operators
//
public:
    operator METADATA_HANDLE() const  { return GetHandle(); }
    operator LPCTSTR() const          { return QueryMetaPath(); }
    operator BOOL() const             { return IsOpen(); }

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Protected members
//
protected:
    //
    // Get data
    //
    HRESULT GetPropertyValue(
        DWORD dwID,
        DWORD & dwSize,
        void *& pvData,
        DWORD * pdwDataType           = NULL,
        BOOL * pfInheritanceOverride     = NULL,
        LPCTSTR lpszMDPath               = NULL,
        DWORD * pdwAttributes            = NULL
        );

    //
    // Store data
    //
    HRESULT SetPropertyValue(
        DWORD dwID,
        DWORD dwSize,
        void * pvData,
        BOOL * pfInheritanceOverride = NULL,
        LPCTSTR lpszMDPath           = NULL
        );

    //
    // Get All Data off the open key
    //
    HRESULT GetAllData(
        DWORD dwMDAttributes,
        DWORD dwMDUserType,
        DWORD dwMDDataType,
        DWORD * pdwMDNumEntries,
        DWORD * pdwMDDataLen,
        PBYTE * ppbMDData,
        LPCTSTR lpszMDPath  = NULL
        );

//
// Property Table Methods
//
protected:
    //
    // Metabase table entry definition
    //
    typedef struct tagMDFIELDDEF
    {
        DWORD dwMDIdentifier;
        DWORD dwMDAttributes;
        DWORD dwMDUserType;
        DWORD dwMDDataType;
        UINT  uStringID;
    } MDFIELDDEF;

    static const MDFIELDDEF s_rgMetaTable[];

//
// CODEWORK: Ideally, these should be protected, but are used
//           by idlg.
//
public:
    static BOOL GetMDFieldDef(
        DWORD dwID,
        DWORD & dwMDIdentifier,
        DWORD & dwMDAttributes,
        DWORD & dwMDUserType,
        DWORD & dwMDDataType
        );

    //
    // Map metabase ID value to table index
    //
    static int MapMDIDToTableIndex(
        DWORD dwID
        );

//
// Allow limited access to the table
//
public:
    static BOOL IsPropertyInheritable(
        DWORD dwID
        );

    static BOOL GetPropertyDescription(
        DWORD dwID, 
        CString & strName
        );

protected:
    BOOL    m_fAllowRootOperations;
    BOOL    m_fOwnKey;
    DWORD   m_cbInitialBufferSize;    
    DWORD   m_dwFlags;
    HRESULT m_hrKey;
    CString m_strMetaPath;
    METADATA_HANDLE m_hKey;
    METADATA_HANDLE m_hBase;
};



class _EXPORT CWamInterface : public CIISInterface
/*++

Class description:

    WAM interface class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    SupportsPooledProc  : Check to see if pooled out of proc is supported.

--*/
{
//
// App Protection States:
//
public:
    enum
    {
        //
        // Note: order must match MD_APP_ISOLATED values
        //
        APP_INPROC,
        APP_OUTOFPROC,
        APP_POOLEDPROC,
    };

//
// Constructor/Destructor
//
public:
    //
    // Destructor destroys the interface
    //
    virtual ~CWamInterface();

protected:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWamInterface(
        CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CWamInterface(
        CWamInterface * pInterface
        );

//
// Access
//
public:
    BOOL SupportsPooledProc() const { return m_fSupportsPooledProc; }

protected:
    virtual HRESULT ApplyProxyBlanket();

    //
    // Create a wam object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// IWAM Interface
//
protected:
    HRESULT AppCreate( 
        LPCTSTR szMDPath,
        DWORD dwAppProtection
        );
    
    HRESULT AppDelete( 
        LPCTSTR szMDPath,
        BOOL fRecursive
        );
    
    HRESULT AppUnLoad( 
        LPCTSTR szMDPath,
        BOOL fRecursive
        );
    
    HRESULT AppGetStatus( 
        LPCTSTR szMDPath,
        DWORD * pdwAppStatus
        );
    
    HRESULT AppDeleteRecoverable( 
        LPCTSTR szMDPath,
        BOOL fRecursive
        );
    
    HRESULT AppRecover( 
        LPCTSTR szMDPath,
        BOOL fRecursive
        );

protected:
    IWamAdmin * m_pInterface; 

private:
    BOOL m_fSupportsPooledProc;
};



class _EXPORT CMetaBack : public CMetaInterface, public CWamInterface
/*++

Class Description:

    Metabase backup/restore class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    Reset               : Enum first existing backup
    Next                : Enum next existing backup
    Backup              : Create new backup
    Delete              : Delete existing backup
    Restore             : Restore from existing backup

--*/
{
public:
    //
    // Construct and create the interfaces.  Use NULL to create
    // on the local computer.
    //
    CMetaBack(
        CComAuthInfo * pServer
        );

//
// Virtual Interface
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    //
    // Reset counter
    //
    void Reset() { m_dwIndex = 0L; }

    HRESULT Next(
        DWORD * pdwVersion,
        LPTSTR lpszLocation,
        FILETIME * pftBackupTime
        );

    HRESULT Backup(
        LPCTSTR lpszLocation
        );

    HRESULT Delete(
        LPCTSTR lpszLocation,
        DWORD dwVersion
        );

    HRESULT Restore(
        LPCTSTR lpszLocation,
        DWORD dwVersion
        );

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    static const LPCTSTR s_szMasterAppRoot;

private:
    DWORD m_dwIndex;
};



class _EXPORT CMetaEnumerator : public CMetaKey
/*++

Class Description:

    Metabase key enumerator

Public Interface:

    CMetaEnumerator     : Constructor
    
    Reset               : Reset the enumerator
    Next                : Get next key

--*/
{
public:
    //
    // Constructor creates a new interface and opens a key
    //
    CMetaEnumerator(
        CComAuthInfo * pServer,
        LPCTSTR lpszMDPath     = NULL,
        METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an existing interface and opens
    // a new key
    //
    CMetaEnumerator(
        CMetaInterface * pInterface,
        LPCTSTR lpszMDPath     = NULL,
        METADATA_HANDLE hkBase = METADATA_MASTER_ROOT_HANDLE
        );

    //
    // Constructor which uses an open key
    //
    CMetaEnumerator(
        BOOL fOwnKey,
        CMetaKey * pKey
        );

//
// Interface:
//
public:
    //
    // Reset counter
    //
    void Reset(DWORD counter = 0L) { m_dwIndex = counter; }
    DWORD GetIndex() { return m_dwIndex; }
    // Index stack operators, used for recursive enums
    void Push()
    {
       m_stack.push(m_dwIndex);
    }
    void Pop()
    {
       ASSERT(!m_stack.empty());
       m_dwIndex = m_stack.top();
       m_stack.pop();
    }

    //
    // Get next key as string.
    //
    HRESULT Next(
        CString & strKey,
        LPCTSTR lpszMDPath = NULL
        );

    //
    // Get next key as a DWORD (numeric keys only)
    //
    HRESULT Next(
        DWORD & dwKey,
        CString & strKey,
        LPCTSTR lpszMDPath = NULL
        );

private:
    DWORD m_dwIndex;
    std::stack<DWORD> m_stack;
};



class _EXPORT CIISApplication : public CWamInterface, public CMetaKey
/*++

Class Description:

    IIS Application class

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

Public Interface:

    RefreshState        : Refresh application state
    QueryAppState       : Return current application state
    IsEnabledApplication: Return TRUE if appplication is enabled. 
    Create              : Create app
    Delete              : Delete app
    Unload              : Unload app
    DeleteRecoverable   : Delete w. recovery allowed
    Recover             : Recover
    WriteFriendlyName   : Write friendly name to metabase

--*/
{
//
// Constructor/Destructor
//
public:
    CIISApplication(
        CComAuthInfo * pServer,
        LPCTSTR lpszMetapath
        );

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const;
    virtual HRESULT QueryResult() const;

//
// Interface
//
public:
    DWORD   QueryAppState() const { return m_dwAppState; }
    LPCTSTR QueryWamPath() const { return m_strWamPath; }
    BOOL    IsEnabledApplication() const;
    HRESULT RefreshAppState();
    HRESULT Create(LPCTSTR lpszName, DWORD dwAppProtection);
    HRESULT Delete(BOOL fRecursive = FALSE);
    HRESULT Unload(BOOL fRecursive = FALSE);
    HRESULT DeleteRecoverable(BOOL fRecursive = FALSE);
    HRESULT Recover(BOOL fRecursive = FALSE);
    HRESULT WriteFriendlyName(LPCTSTR lpszName);

public:
    BOOL IsInproc() const { return m_dwProcessProtection == APP_INPROC; }
    BOOL IsOutOfProc() const { return m_dwProcessProtection == APP_OUTOFPROC; }
    BOOL IsPooledProc() const { return m_dwProcessProtection == APP_POOLEDPROC; }

public:
    DWORD   m_dwProcessProtection;
    CString m_strFriendlyName;
    CString m_strAppRoot;

protected:
    void CommonConstruct();

private:
    DWORD   m_dwAppState;
    CString m_strWamPath;
    HRESULT m_hrApp;
};



class _EXPORT CIISSvcControl : public CIISInterface
/*++

Class description:

    IIS Service control

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CIISSvcControl(
        CComAuthInfo * pServer
        );

    //
    // Construct from existing interface.  
    //
    CIISSvcControl(
        CIISSvcControl * pInterface
        );

    //
    // Destructor destroys the interface
    //
    virtual ~CIISSvcControl();

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
    //
    // Stop services
    //
    HRESULT Stop(
        DWORD dwTimeoutMsecs,
        BOOL fForce
        );

    //
    // Start services
    //
    HRESULT Start(
        DWORD dwTimeoutMsecs
        );

    //
    // Reboot
    //
    HRESULT Reboot(
        DWORD dwTimeouMsecs,
        BOOL fForceAppsClosed
        );

    //
    // Status
    //
    HRESULT Status(
        DWORD dwBufferSize,
        LPBYTE pbBuffer,
        DWORD * MDRequiredBufferSize,
        DWORD * pdwNumServices
        );

    //
    // Kill
    //
    HRESULT Kill();

protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    IIisServiceControl * m_pInterface; 
};


#ifdef KEVLAR
class _EXPORT CWebCluster : public CIISInterface
/*++

Class description:

    IWebCluster warpper

Virtual Interface:

    Succeeded           : Return TRUE if item constructed successfully
    QueryResult         : Return construction error code

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Fully defined constructor that creates the interface.
    // Use NULL to create the interface on the local computer
    //
    CWebCluster(
        CComAuthInfo * pServer
        );

    //
    // Destructor destroys the interface
    //
    virtual ~CWebCluster();

protected:
    //
    // Create an object in this server. This function initializes the
    // object with DCOM.
    //
    HRESULT Create();

    //
    // Make sure the interface has been created
    //
    BOOL HasInterface() const { return m_pInterface != NULL; }

//
// Interface
//
public:
#if (0) // dantra: 8/17/99 legacy code, not supported by new IWebCluster interfaces
    HRESULT GetParameter( 
        LONG lParamId,
        BSTR bstrParamInfo,
        VARIANT * lpvarParam
        );
    
    HRESULT SetParameter( 
        LONG lParam,
        BSTR bstrParamInfo,
        VARIANT * lpvarResults
        );
#endif
protected:
    virtual HRESULT ApplyProxyBlanket();

protected:
    IWebCluster * m_pInterface; 
};
#endif


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void 
CComAuthInfo::StorePassword(LPCOLESTR lpszPassword)
{
    m_bstrPassword = lpszPassword;
}

inline /* virtual */ HRESULT 
CIISInterface::ChangeProxyBlanket(
    LPCOLESTR lpszUserName, 
    LPCOLESTR lpszPassword
    )
{
    m_auth.SetImpersonation(lpszUserName, lpszPassword);
    return ApplyProxyBlanket();
}

inline /*static */ LPCTSTR 
CMetabasePath::GetMachinePath(
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder
    )
{
    return TruncatePath(iMachine, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR 
CMetabasePath::GetServicePath(
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder
    )
{
    return TruncatePath(iService, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR 
CMetabasePath::GetInstancePath(
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder
    )
{
    return TruncatePath(iInstance, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* static */ LPCTSTR 
CMetabasePath::GetRootPath(
    LPCTSTR lpszMDPath,
    CString & strNewPath,
    CString * pstrRemainder
    )
{
    return TruncatePath(iRootDirectory, lpszMDPath, strNewPath, pstrRemainder);
}

inline /* virtual */ HRESULT 
CMetaInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

inline HRESULT 
CMetaInterface::OpenKey(
    METADATA_HANDLE hkBase,
    LPCTSTR lpszMDPath,
    DWORD dwFlags,
    METADATA_HANDLE * phMDNewHandle
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->OpenKey(
        hkBase,
        lpszMDPath,
        dwFlags,
        m_iTimeOutValue,
        phMDNewHandle
        );
}

inline HRESULT 
CMetaInterface::CloseKey(
    METADATA_HANDLE hKey
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CloseKey(hKey);
}

inline HRESULT 
CMetaInterface::SetLastChangeTime( 
    METADATA_HANDLE hMDHandle,
    LPCTSTR pszMDPath,
    FILETIME * pftMDLastChangeTime,
    BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetLastChangeTime(
        hMDHandle,
        pszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}
        
inline HRESULT 
CMetaInterface::GetLastChangeTime( 
     METADATA_HANDLE hMDHandle,
     LPCTSTR lpszMDPath,
    FILETIME * pftMDLastChangeTime,
     BOOL bLocalTime
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetLastChangeTime(
        hMDHandle,
        lpszMDPath,
        pftMDLastChangeTime,
        bLocalTime
        );
}

inline HRESULT 
CMetaInterface::AddKey( 
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AddKey(hKey, lpszMDPath);
}

inline HRESULT 
CMetaInterface::DeleteKey(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteKey(hKey, lpszMDPath);
}

inline HRESULT 
CMetaInterface::DeleteChildKeys(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteChildKeys(hKey, lpszMDPath);
}

inline HRESULT 
CMetaInterface::EnumKeys(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    LPTSTR lpszMDName,
    DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumKeys(hKey, lpszMDPath, lpszMDName, dwIndex);
}        

inline HRESULT 
CMetaInterface::CopyKey(
    METADATA_HANDLE hSourceKey,
    LPCTSTR lpszMDSourcePath,
    METADATA_HANDLE hDestKey,
    LPCTSTR lpszMDDestPath,
    BOOL fOverwrite,
    BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CopyKey(
        hSourceKey,
        lpszMDSourcePath,
        hDestKey,
        lpszMDDestPath,
        fOverwrite,
        fCopy
        );        
}

inline HRESULT 
CMetaInterface::RenameKey(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    LPCTSTR lpszNewName
    )
{   
    ASSERT_PTR(m_pInterface);     
    return m_pInterface->RenameKey(hKey, lpszMDPath, lpszNewName);
}

inline HRESULT 
CMetaInterface::GetData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    METADATA_RECORD * pmdRecord,
    DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetData(
        hKey,
        lpszMDPath,
        pmdRecord,
        pdwRequiredDataLen
        );
}

inline HRESULT 
CMetaInterface::SetData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    METADATA_RECORD * pmdRecord
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetData(
        hKey,
        lpszMDPath,
        pmdRecord
        );
}

inline HRESULT 
CMetaInterface::DeleteData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    DWORD dwMDIdentifier,
    DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteData(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType
        );
}

inline HRESULT 
CMetaInterface::EnumData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    METADATA_RECORD * pmdRecord,
    DWORD dwIndex,
    DWORD * pdwRequiredDataLen
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumData(
        hKey,
        lpszMDPath,
        pmdRecord,
        dwIndex,
        pdwRequiredDataLen
        );
}

inline HRESULT 
CMetaInterface::GetAllData(
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    DWORD dwMDAttributes,
    DWORD dwMDUserType,
    DWORD dwMDDataType,
    DWORD * pdwMDNumDataEntries,
    DWORD * pdwMDDataSetNumber,
    DWORD dwMDBufferSize,
    LPBYTE pbMDBuffer,
    DWORD * pdwRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetAllData(
        hKey,
        lpszMDPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        pdwMDNumDataEntries,
        pdwMDDataSetNumber,
        dwMDBufferSize,
        pbMDBuffer,
        pdwRequiredBufferSize
        );
}    

inline HRESULT 
CMetaInterface::DeleteAllData( 
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    DWORD dwMDUserType,
    DWORD dwMDDataType
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteAllData(
        hKey, 
        lpszMDPath, 
        dwMDUserType, 
        dwMDDataType
        );
}

inline HRESULT 
CMetaInterface::CopyData( 
    METADATA_HANDLE hMDSourceKey,
    LPCTSTR lpszMDSourcePath,
    METADATA_HANDLE hMDDestKey,
    LPCTSTR lpszMDDestPath,
    DWORD dwMDAttributes,
    DWORD dwMDUserType,
    DWORD dwMDDataType,
    BOOL fCopy
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->CopyData(
        hMDSourceKey,
        lpszMDSourcePath,
        hMDDestKey,
        lpszMDDestPath,
        dwMDAttributes,
        dwMDUserType,
        dwMDDataType,
        fCopy
        );
}

inline HRESULT 
CMetaInterface::GetDataPaths( 
    METADATA_HANDLE hKey,
    LPCTSTR lpszMDPath,
    DWORD dwMDIdentifier,
    DWORD dwMDDataType,
    DWORD dwMDBufferSize,
    LPTSTR lpszBuffer,
    DWORD * pdwMDRequiredBufferSize
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetDataPaths(
        hKey,
        lpszMDPath,
        dwMDIdentifier,
        dwMDDataType,
        dwMDBufferSize,
        lpszBuffer,
        pdwMDRequiredBufferSize
        );
}

inline HRESULT 
CMetaInterface::Backup( 
    LPCTSTR lpszBackupLocation,
    DWORD dwMDVersion,
    DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Backup(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT 
CMetaInterface::Restore(    
    LPCTSTR lpszBackupLocation,
    DWORD dwMDVersion,
    DWORD dwMDFlags
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Restore(lpszBackupLocation, dwMDVersion, dwMDFlags);
}

inline HRESULT 
CMetaInterface::EnumBackups(
    LPTSTR lpszBackupLocation,
    DWORD * pdwMDVersion,
    FILETIME * pftMDBackupTime,
     DWORD dwIndex
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->EnumBackups(
        lpszBackupLocation,
        pdwMDVersion,
        pftMDBackupTime,
        dwIndex
        );    
}

inline HRESULT 
CMetaInterface::DeleteBackup(
    LPCTSTR lpszBackupLocation,
    DWORD dwMDVersion
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->DeleteBackup(lpszBackupLocation, dwMDVersion);
}        

inline HRESULT 
CMetaKey::AddKey(
    LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::AddKey(m_hKey, lpszMDPath);    
}

inline HRESULT 
CMetaKey::DeleteKey(
    LPCTSTR lpszMDPath
    )
{
    return CMetaInterface::DeleteKey(m_hKey, lpszMDPath);    
}

inline HRESULT 
CMetaKey::RenameKey(
    LPCTSTR lpszMDPath,
    LPCTSTR lpszNewName
    )
{
    return CMetaInterface::RenameKey(m_hKey, lpszMDPath, lpszNewName);    
}

inline HRESULT 
CMetaKey::ReOpen()
{
    return Open(m_dwFlags, m_strMetaPath, m_hBase);
}

inline HRESULT 
CMetaKey::ReOpen(DWORD dwFlags)
{
    return Open(dwFlags, m_strMetaPath, m_hBase);
}

inline BOOL 
CMetaKey::IsHomeDirectoryPath() const
{ 
    return CMetabasePath::IsHomeDirectoryPath(m_strMetaPath); 
}

inline HRESULT 
CMetaKey::QueryValue(
    DWORD dwID, 
    BOOL & fValue,
    BOOL * pfInheritanceOverride,
    LPCTSTR lpszMDPath,
    DWORD * pdwAttributes        
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::QueryValue(
        dwID, 
        (DWORD &)fValue, 
        pfInheritanceOverride, 
        lpszMDPath,
        pdwAttributes
        );
}

inline HRESULT 
CMetaKey::SetValue(
    DWORD dwID,
    DWORD dwValue,
    BOOL * pfInheritanceOverride,    OPTIONAL
    LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID, 
        sizeof(dwValue), 
        &dwValue, 
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT 
CMetaKey::SetValue(
    DWORD dwID,
    BOOL fValue,
    BOOL * pfInheritanceOverride,
    LPCTSTR lpszMDPath
    )
{
    ASSERT(sizeof(DWORD) == sizeof(BOOL));
    return CMetaKey::SetValue(
        dwID,
        (DWORD)fValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT 
CMetaKey::SetValue(
    DWORD dwID,
    CString & strValue,
    BOOL * pfInheritanceOverride,    OPTIONAL
    LPCTSTR lpszMDPath               OPTIONAL
    )
{
    return SetPropertyValue(
        dwID,
        (strValue.GetLength() + 1) * sizeof(TCHAR),
        (void *)(LPCTSTR)strValue,
        pfInheritanceOverride,
        lpszMDPath
        );
}

inline HRESULT 
CWamInterface::AppDelete( 
    LPCTSTR szMDPath,
    BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppDelete(szMDPath, fRecursive);
}

inline HRESULT 
CWamInterface::AppUnLoad( 
    LPCTSTR szMDPath,
    BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppUnLoad(szMDPath, fRecursive);
}

inline HRESULT 
CWamInterface::AppGetStatus( 
    LPCTSTR szMDPath,
    DWORD * pdwAppStatus
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppGetStatus(szMDPath, pdwAppStatus);
}

inline HRESULT 
CWamInterface::AppDeleteRecoverable( 
    LPCTSTR szMDPath,
    BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppDeleteRecoverable(szMDPath, fRecursive);
}

inline HRESULT 
CWamInterface::AppRecover( 
    LPCTSTR szMDPath,
    BOOL fRecursive
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->AppRecover(szMDPath, fRecursive);
}

inline /* virtual */ HRESULT 
CWamInterface::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

inline /* virtual */ HRESULT 
CMetaBack::ApplyProxyBlanket()
{
    HRESULT hr = CMetaInterface::ApplyProxyBlanket();
    return SUCCEEDED(hr) ? CWamInterface::ApplyProxyBlanket() : hr;
}

inline HRESULT 
CMetaBack::Next(
    DWORD * pdwVersion,
    LPTSTR lpszLocation,
    FILETIME * pftBackupTime
    )
{
    return EnumBackups(
        lpszLocation,
        pdwVersion,
        pftBackupTime,
        m_dwIndex++
        );
}

inline HRESULT 
CMetaBack::Backup(
    LPCTSTR lpszLocation
    )
{
    return CMetaInterface::Backup(
        lpszLocation, 
        MD_BACKUP_NEXT_VERSION, 
        MD_BACKUP_SAVE_FIRST
        );
}

inline HRESULT 
CMetaBack::Delete(
    LPCTSTR lpszLocation,
    DWORD dwVersion
    )
{
    return DeleteBackup(lpszLocation, dwVersion);
}

inline BOOL 
CIISApplication::IsEnabledApplication() const
{
    return m_dwAppState == APPSTATUS_STOPPED 
        || m_dwAppState == APPSTATUS_RUNNING;
}

inline HRESULT 
CIISApplication::Delete(
    BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDelete(m_strWamPath, fRecursive);
}

inline HRESULT 
CIISApplication::Unload(
    BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppUnLoad(m_strWamPath, fRecursive);
}

inline HRESULT 
CIISApplication::DeleteRecoverable(
    BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppDeleteRecoverable(m_strWamPath, fRecursive);
}

inline HRESULT 
CIISApplication::Recover(
    BOOL fRecursive
    )
{
    ASSERT(!m_strWamPath.IsEmpty());
    return AppRecover(m_strWamPath, fRecursive);
}

inline HRESULT 
CIISSvcControl::Stop(
    DWORD dwTimeoutMsecs,
    BOOL fForce
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Stop(dwTimeoutMsecs, (DWORD)fForce);
}

inline HRESULT 
CIISSvcControl::Start(
    DWORD dwTimeoutMsecs
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Start(dwTimeoutMsecs);
}

inline HRESULT 
CIISSvcControl::Reboot(
    DWORD dwTimeouMsecs,
    BOOL fForceAppsClosed
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Reboot(dwTimeouMsecs, (DWORD)fForceAppsClosed);
}

inline HRESULT 
CIISSvcControl::Status(
    DWORD dwBufferSize,
    LPBYTE pbBuffer,
    DWORD * MDRequiredBufferSize,
    DWORD * pdwNumServices
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Status(
        dwBufferSize, 
        pbBuffer,
        MDRequiredBufferSize,
        pdwNumServices
        );
}

inline HRESULT 
CIISSvcControl::Kill()
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->Kill();
}

inline /* virtual */ HRESULT 
CIISSvcControl::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}

#ifdef KEVLAR
inline HRESULT 
CWebCluster::Create()
{
    return CIISInterface::Create(
        1,
        &IID_IWebCluster, 
        &CLSID_WebCluster, 
        NULL, 
        (IUnknown **)&m_pInterface
        );
}

inline /* virtual */ HRESULT 
CWebCluster::ApplyProxyBlanket()
{
    return m_auth.ApplyProxyBlanket(m_pInterface);
}
#if (0)  // dantra: 8/17/99 - legacy
inline HRESULT 
CWebCluster::GetParameter( 
    LONG lParamId,
    BSTR bstrParamInfo,
    VARIANT * lpvarParam
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->GetParameter(lParamId, bstrParamInfo, lpvarParam);
}
    
inline HRESULT 
CWebCluster::SetParameter( 
    LONG lParam,
    BSTR bstrParamInfo,
    VARIANT * lpvarResults
    )
{
    ASSERT_PTR(m_pInterface);
    return m_pInterface->SetParameter(lParam, bstrParamInfo, lpvarResults);
}

#endif // 0
#endif // KEVLAR

#endif // _MDKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iisuihelper.rc
//
#define IDS_PROJNAME                    100
#define IDS_APP_TITLE                   101
#define IDS_NO_MESSAGE                  102
#define IDR_AUTHINFO                    103
#define IDC_LIST_CHILD_NODES            11042
#define IDC_BUTTON_SELECT_ALL           11043
#define IDC_STATIC_PROMPT               11044
#define IDD_INHERITANCE                 15012
#define IDS_INHERITANCE_NO_NAME         20112
#define IDS_INHERITANCE_PROMPT          20113
#define IDS_FMT_SECURITY                20127
#define IDS_MD_CONNECTION_TIMEOUT       20200
#define IDS_MD_MAX_CONNECTIONS          20201
#define IDS_MD_SERVER_COMMENT           20202
#define IDS_MD_SERVER_SIZE              20203
#define IDS_MD_SERVER_LISTEN_BACKLOG    20204
#define IDS_MD_SERVER_LISTEN_TIMEOUT    20205
#define IDS_MD_APP_FRIENDLY_NAME        20207
#define IDS_MD_APP_ROOT                 20208
#define IDS_MD_APP_ISOLATED             20209
#define IDS_MD_VR_PATH                  20210
#define IDS_MD_VR_USERNAME              20211
#define IDS_MD_VR_PASSWORD              20212
#define IDS_MD_EXIT_MESSAGE             20213
#define IDS_MD_GREETING_MESSAGE         20214
#define IDS_MD_MAX_CLIENTS_MESSAGE      20215
#define IDS_MD_MSDOS_DIR_OUTPUT         20216
#define IDS_MD_ALLOW_ANONYMOUS          20217
#define IDS_MD_ANONYMOUS_ONLY           20218
#define IDS_MD_LOG_ANONYMOUS            20219
#define IDS_MD_LOG_NONANONYMOUS         20220
#define IDS_MD_AUTHORIZATION            20221
#define IDS_MD_REALM                    20222
#define IDS_MD_HTTP_EXPIRES             20223
#define IDS_MD_HTTP_PICS                20224
#define IDS_MD_HTTP_CUSTOM              20225
#define IDS_MD_DIRECTORY_BROWSING       20226
#define IDS_MD_DEFAULT_LOAD_FILE        20227
#define IDS_MD_CONTENT_NEGOTIATION      20228
#define IDS_MD_CUSTOM_ERROR             20229
#define IDS_MD_FOOTER_DOCUMENT          20230
#define IDS_MD_FOOTER_ENABLED           20231
#define IDS_MD_HTTP_REDIRECT            20232
#define IDS_MD_DEFAULT_LOGON_DOMAIN     20233
#define IDS_MD_LOGON_METHOD             20234
#define IDS_MD_SCRIPT_MAPS              20235
#define IDS_MD_MIME_MAP                 20236
#define IDS_MD_ACCESS_PERM              20237
#define IDS_MD_HEADER_DOCUMENT          20238
#define IDS_MD_HEADER_ENABLED           20239
#define IDS_MD_IP_SEC                   20240
#define IDS_MD_ANONYMOUS_USER_NAME      20241
#define IDS_MD_ANONYMOUS_PWD            20242
#define IDS_MD_ANONYMOUS_USE_SUBAUTH    20243
#define IDS_MD_DONT_LOG                 20244
#define IDS_MD_ADMIN_ACL                20245
#define IDS_MD_SSI_EXEC_DISABLED        20246
#define IDS_MD_SSL_ACCESS_PERM          20247
#define IDS_MD_NTAUTHENTICATION_PROVIDERS 20248
#define IDS_MD_SCRIPT_TIMEOUT           20249
#define IDS_MD_CACHE_EXTENSIONS         20250
#define IDS_MD_CREATE_PROCESS_AS_USER   20251
#define IDS_MD_CREATE_PROC_NEW_CONSOLE  20252
#define IDS_MD_POOL_IDC_TIMEOUT         20253
#define IDS_MD_ALLOW_KEEPALIVES         20254
#define IDS_MD_IS_CONTENT_INDEXED       20255
#define IDS_ASP_BUFFERINGON             20256
#define IDS_ASP_LOGERRORREQUESTS        20257
#define IDS_ASP_SCRIPTERRORSSENTTOBROWSER 20258
#define IDS_ASP_SCRIPTERRORMESSAGE      20259
#define IDS_ASP_SCRIPTFILECACHESIZE     20260
#define IDS_ASP_SCRIPTENGINECACHEMAX    20261
#define IDS_ASP_SCRIPTTIMEOUT           20262
#define IDS_ASP_SESSIONTIMEOUT          20263
#define IDS_ASP_ENABLEPARENTPATHS       20264
#define IDS_ASP_ALLOWSESSIONSTATE       20265
#define IDS_ASP_SCRIPTLANGUAGE          20266
#define IDS_ASP_EXCEPTIONCATCHENABLE    20267
#define IDS_ASP_ENABLESERVERDEBUG       20268
#define IDS_ASP_ENABLECLIENTDEBUG       20269
#define IDS_MD_LOG_PLUGIN_ORDER         20270
#define IDS_MD_LOGEXT_FIELD_MASK        20271
#define IDS_MD_LOG_TYPE                 20272
#define IDS_MD_LOGFILE_DIRECTORY        20273
#define IDS_MD_LOGFILE_PERIOD           20274
#define IDS_MD_LOGFILE_TRUNCATE_SIZE    20275
#define IDS_MD_LOGSQL_DATA_SOURCES      20276
#define IDS_MD_LOGSQL_TABLE_NAME        20277
#define IDS_MD_LOGSQL_USER_NAME         20278
#define IDS_MD_LOGSQL_PASSWORD          20279
#define IDS_MD_CPU_LIMITS_ENABLED       20280
#define IDS_MD_CPU_LIMIT_LOGEVENT       20281
#define IDS_MD_CPU_LIMIT_PRIORITY       20282
#define IDS_MD_CPU_LIMIT_PAUSE          20283
#define IDS_MD_CPU_LIMIT_PROCSTOP       20284
#define IDS_MD_LOGFILE_LOCALTIME_ROLLOVER 20285
#define IDS_MD_CPU_LOGGING_MASK         20286
#define ID_HELP                         0xE146

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H)
#define _STDAFX_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#define _WTL_NO_CSTRING

#include <atlcom.h>
#include <atlwin.h>
#include <atlapp.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <map>
#include <list>
#include <stack>
#include <memory>
#include <shlwapi.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(_STDAFX_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\iiscstring.h ===
//
//    IISCString.h
//
//////////////////////////////////////////////////////////////////////////////

#if !defined(IISCSTRING_H)
#define IISCSTRING_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//////////////////////////////////////////////////////////////////////////////
#pragma warning(disable:4786) // Disable warning for names > 256
#pragma warning(disable:4275) // Disable warning for non dll-interface class used as a base class

#include <string>
#include <cstring>
#include "common.h"

//////////////////////////////////////////////////////////////////////////////

namespace IIS
{
   class _EXPORT CString : public std::basic_string<TCHAR>
   {
   public:
      // Constructors
      CString();
      CString(const CString& strInput);
      CString(const std::basic_string<TCHAR>& strInput);
      CString(TCHAR ch, int nRepeat = 1);
#ifdef _UNICODE
	   CString(LPCSTR lpsz);
#endif
#ifndef _UNICODE
	   CString(LPCWSTR lpsz);
#endif
      CString(LPCTSTR p);
	   CString(LPCTSTR lpch, int nLength);
	   CString(const unsigned char * psz);
      CString(const CComBSTR& bstr);

      ~CString();

      int GetLength() const;
      bool IsEmpty() const;
      void Empty();
      TCHAR GetAt(int nIndex) const;
	   TCHAR operator[](int nIndex) const;
      void SetAt(int nIndex, TCHAR ch);
	   operator LPCTSTR() const;           // as a C string

	   const CString& operator=(const CString& stringSrc);
	   const CString& operator=(TCHAR ch);
      const CString& operator=(LPCTSTR p);
#ifdef _UNICODE
	   const CString& operator=(char ch);
	   const CString& operator=(LPCSTR lpsz);
	   const CString& operator=(const unsigned char* psz);
#endif
#ifndef _UNICODE
	   const CString& operator=(WCHAR ch);
	   const CString& operator=(LPCWSTR lpsz);
#endif

	   // string concatenation
	   const CString& operator+=(const CString& string);
	   const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
   	const CString& operator+=(char ch);
#endif
	   const CString& operator+=(LPCTSTR lpsz);

	   friend CString __stdcall operator+(const CString& string1, const CString& string2);
	   friend CString __stdcall operator+(const CString& string, TCHAR ch);
	   friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
   	friend CString __stdcall operator+(const CString& string, char ch);
	   friend CString __stdcall operator+(char ch, const CString& string);
#endif
	   friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	   friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	   int Compare(LPCTSTR lpsz) const;         // straight character
	   int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	   int Collate(LPCTSTR lpsz) const;         // NLS aware

	   // simple sub-string extraction
	   CString Mid(int nFirst, int nCount) const;
	   CString Mid(int nFirst) const;
	   CString Left(int nCount) const;
	   CString Right(int nCount) const;

	   CString SpanIncluding(LPCTSTR lpszCharSet) const;
	   CString SpanExcluding(LPCTSTR lpszCharSet) const;

	   // upper/lower/reverse conversion
	   void MakeUpper();
	   void MakeLower();
	   void MakeReverse();

	   // trimming whitespace (either side)
	   void TrimRight();
	   void TrimLeft();

	   // advanced manipulation
	   // replace occurrences of chOld with chNew
	   int Replace(TCHAR chOld, TCHAR chNew);
	   // replace occurrences of substring lpszOld with lpszNew;
	   // empty lpszNew removes instances of lpszOld
	   int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	   // remove occurrences of chRemove
	   int Remove(TCHAR chRemove);
	   // insert character at zero-based index; concatenates
	   // if index is past end of string
	   int Insert(int nIndex, TCHAR ch);
	   // insert substring at zero-based index; concatenates
	   // if index is past end of string
	   int Insert(int nIndex, LPCTSTR pstr);
	   // delete nCount characters starting at zero-based index
	   int Delete(int nIndex, int nCount = 1);

	   // searching (return starting index, or -1 if not found)
	   // look for a single character match
	   int Find(TCHAR ch) const;               // like "C" strchr
	   int ReverseFind(TCHAR ch) const;
	   int FindOneOf(LPCTSTR lpszCharSet) const;

	   // look for a specific sub-string
	   int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	   // Concatentation for non strings
//	   const CString& Append(int n)
//	   {
//		   TCHAR szBuffer[10];
//		   wsprintf(szBuffer,_T("%d"),n);
//		   ConcatInPlace(SafeStrlen(szBuffer), szBuffer);
//		   return *this;
//	   }

   	// simple formatting
      void __cdecl FormatV(LPCTSTR lpszFormat, va_list argList);
	   void __cdecl Format(LPCTSTR lpszFormat, ...);
	   void __cdecl Format(HINSTANCE hInst, UINT nFormatID, ...);

	   // formatting for localization (uses FormatMessage API)
	   BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	   BOOL __cdecl FormatMessage(HINSTANCE hInst, UINT nFormatID, ...);

	   // Windows support
	   BOOL LoadString(HINSTANCE hInstance, UINT nID);
#ifndef _UNICODE
   	// ANSI <-> OEM support (convert string in place)
	   void AnsiToOem();
	   void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	   // OLE BSTR support (use for OLE automation)
	   BSTR AllocSysString() const;
	   BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

   };

   //////////////////////////////////////////////////////////////////////////////
inline bool operator==(const CString& s1, const CString& s2)
	{ return s1.compare(s2) == 0; }
inline bool operator==(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) == 0; }
inline bool operator==(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) == 0; }

inline bool operator!=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) != 0; }
inline bool operator!=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) != 0; }
inline bool operator!=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) != 0; }

inline bool operator<(const CString& s1, const CString& s2)
	{ return s1.compare(s2) < 0; }
inline bool operator<(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) < 0; }
inline bool operator<(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) > 0; }

inline bool operator>(const CString& s1, const CString& s2)
	{ return s1.compare(s2) > 0; }
inline bool operator>(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) > 0; }
inline bool operator>(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) < 0; }

inline bool operator<=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) <= 0; }
inline bool operator<=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) <= 0; }
inline bool operator<=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) >= 0; }

inline bool operator>=(const CString& s1, const CString& s2)
	{ return s1.compare(s2) >= 0; }
inline bool operator>=(const CString& s1, const TCHAR * s2)
	{ return s1.compare(s2) >= 0; }
inline bool operator>=(const TCHAR * s1, const CString& s2)
	{ return s2.compare(s1) <= 0; }

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
   CString s = string1;
   s += string2;
   return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL);
	CString s = string;
	s += lpsz;
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL);
	CString s = lpsz;;
	s += string;
	return s;
}

inline CString __stdcall operator+(const CString& string, TCHAR c)
{
	CString s = string;
	s += c;
	return s;
}

inline CString __stdcall operator+(TCHAR c, const CString& string)
{
	CString s;
	s += c;
   s += string;
	return s;
}

}; // namespace IIS

#pragma warning(default:4786) // Enable warning for names > 256
#pragma warning(default:4275) 

#endif // !defined(IISCSTRING_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\dummy\fscfg\main.cpp ===
#include <stdio.h>
#include <windows.h>
#include "resource.h"

//
// Standard Win32 DLL Entry point
//
BOOL WINAPI DllMain(IN HANDLE DllHandle,IN DWORD  Reason,IN LPVOID Reserved)
{
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\dummy\w3scfg\main.cpp ===
#include <stdio.h>
#include <windows.h>
#include "resource.h"

//
// Standard Win32 DLL Entry point
//
BOOL WINAPI DllMain(IN HANDLE DllHandle,IN DWORD  Reason,IN LPVOID Reserved)
{
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\utcls.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.cpp

   Abstract:

        Internet Properties base classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
//#include "idlg.h"

#include "mmc.h"

extern "C"
{
    #include <lm.h>
}

#define SZ_REG_KEY_BASE  _T("Software\\Microsoft\\%s")


BOOL
IsServerLocal(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to see if the given name refers to the local machine

Arguments:

    LPCTSTR lpszServer   : Server name

Return Value:

    TRUE if the given name refers to the local computer, FALSE otherwise

Note:

    Doesn't work if the server is an ip address

--*/
{
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName);

    //
    // CODEWORK(?): we're not checking for all the ip addresses
    //              on the local box or full dns names.
    //
    //              Try GetComputerNameEx when we're building with NT5 
    //              settings.
    //
    return (!lstrcmpi(_T("localhost"), PURE_COMPUTER_NAME(lpszServer))
         || !lstrcmp( _T("127.0.0.1"), PURE_COMPUTER_NAME(lpszServer)))
         || (GetComputerName(szComputerName, &dwSize) 
             && !lstrcmpi(szComputerName, PURE_COMPUTER_NAME(lpszServer)));
}



BOOL
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    )
/*++

Routine Description:

    Get the system flags for the path in question

Arguments:

    LPCTSTR lpszPath            : Path
    DWORD * pdwSystemFlags      : Returns system flags

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT_WRITE_PTR(pdwSystemFlags);

    TRACE("Getting system flags for %s\n", lpszPath);

    DWORD dwMaxComponentLength;
    TCHAR szRoot[MAX_PATH + 1];
    TCHAR szFileSystem[MAX_PATH + 1];

    //
    // Generating root path
    //
    if (PathIsUNC(lpszPath))
    {
        //
        // Root path of a UNC path is \\foo\bar\
        //
        ASSERT(lstrlen(lpszPath) < MAX_PATH);

        int cSlashes = 0;
        LPCTSTR lpszSrc = lpszPath;
        LPTSTR lpszDst = szRoot;

        while (cSlashes < 4 && *lpszSrc)
        {
            if ((*lpszDst++ = *lpszSrc++) == '\\')
            {
                ++cSlashes;
            }
        }    

        if (!*lpszSrc)
        {
            *lpszDst++ = '\\';
        }

        *lpszDst = '\0';
    }
    else
    {
        ::wsprintf(szRoot, _T("%c:\\"), *lpszPath);
    }

    TRACE("Root path is %s\n", szRoot);
    
    return ::GetVolumeInformation(
        szRoot,
        NULL,
        0,
        NULL,
        &dwMaxComponentLength,
        pdwSystemFlags,
        szFileSystem,
        sizeof(szFileSystem) / sizeof(TCHAR)
        );
}



LPCTSTR
GenerateRegistryKey(
    OUT CString & strBuffer,
    IN  LPCTSTR lpszSubKey OPTIONAL
    )
/*++

Routine Description:

    Generate a registry key name based on the current app, and a
    provided subkey (optional)

Arguments:

    CString & strBuffer : Buffer to create registry key name into.
    LPCTSTR lpszSubKey  : Subkey name or NULL

Return Value:

    Pointer to the registry key value 

--*/
{
    try
    {
        //
        // Use the app name as the primary registry name
        //
       CString app_name;
       app_name.LoadString(_Module.GetResourceInstance(), IDS_APP_TITLE);
       strBuffer.Format(SZ_REG_KEY_BASE, app_name);

        if (lpszSubKey)
        {
            strBuffer += _T("\\");
            strBuffer += lpszSubKey;
        }

        TRACE("Registry key is %s\n", strBuffer);
    }
    catch(std::bad_alloc)
    {
        TRACEEOLID("!!!exception building regkey");
        return NULL;
    }

    return strBuffer;
}


static int
CountCharsToDoubleNull(
    IN LPCTSTR lp
    )
/*++

Routine Description:

    Count TCHARS up to and including the double NULL.

Arguments:

    LPCTSTR lp       : TCHAR Stream

Return Value:

    Number of chars up to and including the double NULL

--*/
{
    int cChars = 0;

    for(;;)
    {
        ++cChars;

        if (lp[0] == _T('\0') && lp[1] == _T('\0'))
        {
            return ++cChars;
        }

        ++lp;
    }
}

CStringListEx::CStringListEx() : std::list<CString> ()
{
}

CStringListEx::~CStringListEx()
{
}

void
CStringListEx::PushBack(LPCTSTR str)
{
   push_back(str);
}

void
CStringListEx::Clear()
{
   clear();
}

DWORD
CStringListEx::ConvertFromDoubleNullList(LPCTSTR lpstrSrc, int cChars)
/*++

Routine Description:

    Convert a double null terminate list of null terminated strings to a more
    manageable CStringList

Arguments:

    LPCTSTR lpstrSrc       : Source list of strings
    int cChars             : Number of characters in double NULL list. if
                             -1, autodetermine length

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (lpstrSrc == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (cChars < 0)
    {
        //
        // Calculate our own size.  This might be off if multiple
        // blank linkes (0) appear in the multi_sz, so the character
        // size is definitely preferable
        //
        cChars = CountCharsToDoubleNull(lpstrSrc);
    }

    try
    {
        clear();

        if (cChars == 2 && *lpstrSrc == _T('\0'))
        {
            //
            // Special case: MULTI_SZ containing only
            // a double NULL are in fact blank entirely.
            //
            // N.B. IMHO this is a metabase bug -- RonaldM
            //
            --cChars;
        }

        //
        // Grab strings until only the final NULL remains
        //
        while (cChars > 1)
        {
            CString strTmp = lpstrSrc;
            push_back(strTmp);
            lpstrSrc += (strTmp.GetLength() + 1);
            cChars -= (strTmp.GetLength() + 1);
        }
    }
    catch(std::bad_alloc)
    {
        TRACEEOLID("!!! exception building stringlist");
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



DWORD
CStringListEx::ConvertToDoubleNullList(
    OUT DWORD & cchDest,
    OUT LPTSTR & lpstrDest
    )
/*++

Routine Description:

    Flatten the string list into a double null terminated list
    of null terminated strings.

Arguments:

    CStringList & strlSrc : Source string list
    DWORD & cchDest       : Size in characters of the resultant array
                            (including terminating NULLs)
    LPTSTR & lpstrDest    : Allocated flat array.

Return Value:

    ERROR_SUCCESS           if the list was converted properly
    ERROR_INVALID_PARAMETER if the list was empty
    ERROR_NOT_ENOUGH_MEMORY if there was a mem exception

--*/
{
    cchDest = 0;
    lpstrDest = NULL;
    BOOL fNullPad = FALSE;

    //
    // Compute total size in characters
    //
    CStringListEx::iterator it = begin();

    while (it != end())
    {
        CString & str = (*it++);

//        TRACEEOLID(str);

        cchDest += str.GetLength() + 1;
    }

    if (!cchDest)
    {
        //
        // Special case: A totally empty MULTI_SZ
        // in fact consists of 2 (final) NULLS, instead
        // of 1 (final) NULL.  This is required by the
        // metabase, but should be a bug.  See note
        // at reversal function above.
        //
        ++cchDest;
        fNullPad = TRUE;
    }

    //
    // Remember final NULL
    //
    cchDest += 1;

    lpstrDest = new TCHAR[cchDest];
    if (lpstrDest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPTSTR pch = lpstrDest;
    it = begin();
    while (it != end())
    {
        CString & str = (*it++);

        lstrcpy(pch, (LPCTSTR)str);
        pch += str.GetLength();
        *pch++ = _T('\0');
    }

    *pch++ = _T('\0');

    if (fNullPad)
    {
        *pch++ = _T('\0');
    }

    return ERROR_SUCCESS;
}






//
// CBlob Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CBlob::CBlob() 
/*++

Routine Description:

    NULL constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : m_pbItem(NULL), 
      m_dwSize(0L)
{
}



CBlob::CBlob(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy
    )
/*++

Routine Description:

    Constructor

Arguments:

    DWORD dwSize        : Size of memory block
    PBYTE pbItem        : Pointer to memory block
    BOOL fMakeCopy      : If TRUE, makes a copy of the memory block.
                          If FALSE, takes ownership of the pointer.

Return Value:

    N/A

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(dwSize, pbItem, fMakeCopy);
}



CBlob::CBlob(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Copy constructor

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    N/A

Notes:

    This contructor makes a copy of the memory block in question.

--*/
    : m_pbItem(NULL),
      m_dwSize(0L)
{
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);
}



void
CBlob::SetValue(
    IN DWORD dwSize,
    IN PBYTE pbItem,
    IN BOOL fMakeCopy OPTIONAL
    )
/*++

Routine Description:

    Assign the value to this binary object.  If fMakeCopy is FALSE,
    the blob will take ownership of the pointer, otherwise a copy
    will be made.

Arguments:

    DWORD dwSize        : Size in bytes
    PBYTE pbItem        : Byte streadm
    BOOL fMakeCopy      : If true, make a copy, else assign pointer

Return Value:

    None

--*/
{
    ASSERT_READ_PTR2(pbItem, dwSize);

    if (!IsEmpty())
    {
        TRACEEOLID("Assigning value to non-empty blob.  Cleaning up");
        CleanUp();
    }

    if (dwSize > 0L)
    {
        //
        // Make private copy
        //
        m_dwSize = dwSize;

        if (fMakeCopy)
        {
            m_pbItem = new BYTE[m_dwSize];
            if (NULL != m_pbItem)
               CopyMemory(m_pbItem, pbItem, dwSize);
        }
        else
        {
            m_pbItem = pbItem;
        }
    }
}



void 
CBlob::CleanUp()
/*++

Routine Description:

    Delete data pointer, and reset pointer and size.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_pbItem)
    {
        delete [] m_pbItem;
    }

    m_pbItem = NULL;
    m_dwSize = 0L;
}



CBlob & 
CBlob::operator =(
    IN const CBlob & blob
    )
/*++

Routine Description:

    Assign values from another CBlob. 

Arguments:

    const CBlob & blob      : Source blob

Return Value:

    Reference to this object

--*/
{
    //
    // Make copy of data
    //
    SetValue(blob.GetSize(), blob.m_pbItem, TRUE);

    return *this;
}



BOOL 
CBlob::operator ==(
    IN const CBlob & blob
    ) const
/*++

Routine Description:
    
    Compare two binary large objects.  In order to match, the objects
    must be the same size, and byte identical.

Arguments:

    const CBlob & blob      : Blob to compare against.

Return Value:

    TRUE if the objects match, FALSE otherwise.

--*/
{
    if (GetSize() != blob.GetSize())
    {
        return FALSE;
    }

    return memcmp(m_pbItem, blob.m_pbItem, GetSize()) == 0;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\dummy\w3scfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\dummy\fscfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_STRING1                     1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\guid.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

        guid.cpp

   Abstract:

        Initialization as required by initguid

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include <stdafx.h>

#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\common2\utcls.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        utcls.h

   Abstract:

        Some utility functions and classes.

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _UTCLS_H_
#define _UTCLS_H_

#pragma warning(disable : 4275)

//
// CDialog parameters
//
#define USE_DEFAULT_CAPTION (0)

//
// Determine if the given server name refers to the local machine
//
BOOL _EXPORT
IsServerLocal(
    IN LPCTSTR lpszServer       
    );

//
// Get volume information system flags for the given path
//
BOOL _EXPORT
GetVolumeInformationSystemFlags(
    IN  LPCTSTR lpszPath,
    OUT DWORD * pdwSystemFlags
    );

//
// Build registry key name
//
LPCTSTR _EXPORT GenerateRegistryKey(
    OUT CString & strBuffer,    
    IN  LPCTSTR lpszSubKey = NULL
    );


class _EXPORT CStringListEx : public std::list<CString>
{
public:
   CStringListEx();
   ~CStringListEx();

   void PushBack(LPCTSTR str);
   void Clear();

   DWORD ConvertFromDoubleNullList(LPCTSTR lpstrSrc, int cChars = -1);
   DWORD ConvertToDoubleNullList(DWORD & cchDest, LPTSTR & lpstrDest);
};


class _EXPORT CBlob
/*++

Class Description:

    Binary large object class, which owns its pointer

Public Interface:

    CBlob           : Constructors
    ~CBlob          : Destructor

    SetValue        : Assign the value
    GetSize         : Get the byte size
    GetData         : Get pointer to the byte stream

--*/
{
//
// Constructors/Destructor
//
public:
    //
    // Initialize empty blob
    //
    CBlob();

    //
    // Initialize with binary data
    //
    CBlob(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // Copy constructor
    //
    CBlob(IN const CBlob & blob);

    //
    // Destructor destroys the pointer
    //    
    ~CBlob();

//
// Operators
//
public:
    CBlob & operator =(const CBlob & blob);
    BOOL operator ==(const CBlob & blob) const;
    BOOL operator !=(const CBlob & blob) const { return !operator ==(blob); }

//
// Access
//
public: 
    //
    // Clean up internal data
    //
    void CleanUp();

    //
    // Set the current value of the blob
    //
    void SetValue(
        IN DWORD dwSize,
        IN PBYTE pbItem,
        IN BOOL fMakeCopy = TRUE
        );

    //
    // TRUE if the blob is currently empty
    //
    BOOL IsEmpty() const { return m_dwSize == 0L; }

    //
    // Return the size of the blob in bytes
    //
    DWORD GetSize() const { return m_dwSize; }

    //
    // Get a pointer to the byte stream
    //
    PBYTE GetData();

private:
    DWORD m_dwSize;
    PBYTE m_pbItem;
};

// Blob for use in CryptoAPI functions
//
class CCryptBlob
{
public:
	CCryptBlob()
	{
		m_blob.cbData = 0;
		m_blob.pbData = NULL;
	}
	virtual ~CCryptBlob()
	{
	}
	DWORD GetSize() {return m_blob.cbData;}
	BYTE * GetData() {return m_blob.pbData;}
	void Set(DWORD cb, BYTE * pb)
	{
		Destroy();
		m_blob.cbData = cb;
		m_blob.pbData = pb;
	}
	BOOL Resize(DWORD cb)
   {
      BOOL res = TRUE;
      BYTE * p = m_blob.pbData;
      if (NULL != (m_blob.pbData = Realloc(m_blob.pbData, cb)))
      {
         m_blob.cbData = cb;
      }
      else
      {
         m_blob.pbData = p;
         res = FALSE;
      }
      return res;
   }
	operator CRYPT_DATA_BLOB *()
	{
		return &m_blob;
	}

protected:
	void Destroy()
	{
		if (m_blob.pbData != NULL)
			Free(m_blob.pbData);
	}
	virtual BYTE * Realloc(BYTE * pb, DWORD cb) = 0;
	virtual void Free(BYTE * pb) = 0;
	CRYPT_DATA_BLOB m_blob;
};

class CCryptBlobIMalloc : public CCryptBlob
{
public:
	virtual ~CCryptBlobIMalloc()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)CoTaskMemRealloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		CoTaskMemFree(pb);
	}
};

class CCryptBlobLocal : public CCryptBlob
{
public:
	virtual ~CCryptBlobLocal()
	{
		CCryptBlob::Destroy();
	}

protected:
	virtual BYTE * Realloc(BYTE * pb, DWORD cb)
	{
		return (BYTE *)realloc(pb, cb);
	}
	virtual void Free(BYTE * pb)
	{
		free(pb);
	}
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CBlob::~CBlob()
{
    CleanUp();
}

inline PBYTE CBlob::GetData()
{
    return m_pbItem;
}





#endif // _UTCLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\cnfrmpsd.cpp ===
// CnfrmPsD.cpp : implementation file
//

#include "stdafx.h"
#include "logui.h"
#include "CnfrmPsD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

CConfirmPassDlg::CConfirmPassDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfirmPassDlg::IDD, pParent)
    {
    //{{AFX_DATA_INIT(CConfirmPassDlg)
	m_sz_password_new = _T("");
	//}}AFX_DATA_INIT
    }

void CConfirmPassDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConfirmPassDlg)
	DDX_Text(pDX, IDC_ODBC_CONFIRM_PASSWORD, m_sz_password_new);
	//}}AFX_DATA_MAP
    }

BEGIN_MESSAGE_MAP(CConfirmPassDlg, CDialog)
    //{{AFX_MSG_MAP(CConfirmPassDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg message handlers

void CConfirmPassDlg::OnOK() 
    {
    UpdateData( TRUE );

    // confirm it
    if ( m_sz_password_new != m_szOrigPass )
        {
        AfxMessageBox( IDS_PASS_CONFIRM_FAIL );
        return;
        }

    CDialog::OnOK();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\dcomperm.h ===
DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    );

DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    );

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    );

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    );

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    );

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    );

DWORD
GetCurrentUserSID (
    PSID *Sid
    );

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    );

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    );

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    );

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\dcomperm.cpp ===
#include "stdafx.h"

#include <conio.h>
#include "dcomperm.h"

#define _WIN32_DCOM
#include <objbase.h>

DWORD
CopyACL (
    PACL OldACL,
    PACL NewACL
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    LPVOID                ace;
    ACE_HEADER            *aceHeader;
    ULONG                 i;

    GetAclInformation (OldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (aclSizeInfo), AclSizeInformation);

    //
    // Copy all of the ACEs to the new ACL
    //

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        //
        // Get the ACE and header info
        //

        if (!GetAce (OldACL, i, &ace))
            return GetLastError();

        aceHeader = (ACE_HEADER *) ace;

        //
        // Add the ACE to the new list
        //

        if (!AddAce (NewACL, ACL_REVISION, 0xffffffff, ace, aceHeader->AceSize))
            return GetLastError();
    }

    return ERROR_SUCCESS;
}

DWORD
AddAccessDeniedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;
    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_DENIED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        delete [] newACL;
        goto cleanup;
    }

    if (!AddAccessDeniedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        delete [] newACL;
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        delete [] newACL;
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
AddAccessAllowedACEToACL (
    PACL *Acl,
    DWORD PermissionMask,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION  aclSizeInfo;
    int                   aclSize;
    DWORD                 returnValue = ERROR_SUCCESS;
    PSID                  principalSID;
    PACL                  oldACL, newACL;
    BOOL                  bWellKnownSID = FALSE;

    oldACL = *Acl;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    aclSize = aclSizeInfo.AclBytesInUse +
              sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
              GetLengthSid (principalSID) - sizeof (DWORD);

    newACL = (PACL) new BYTE [aclSize];

    if (!InitializeAcl (newACL, aclSize, ACL_REVISION))
    {
        returnValue = GetLastError();
        delete [] newACL;
        goto cleanup;
    }

    returnValue = CopyACL (oldACL, newACL);
    if (returnValue != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if (!AddAccessAllowedAce (newACL, ACL_REVISION2, PermissionMask, principalSID))
    {
        returnValue = GetLastError();
        goto cleanup;
    }

    *Acl = newACL;

cleanup:
    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
RemovePrincipalFromACL (
    PACL Acl,
    LPTSTR Principal
    )
{
    ACL_SIZE_INFORMATION    aclSizeInfo;
    ULONG                   i;
    LPVOID                  ace;
    ACCESS_ALLOWED_ACE      *accessAllowedAce;
    ACCESS_DENIED_ACE       *accessDeniedAce;
    SYSTEM_AUDIT_ACE        *systemAuditAce;
    PSID                    principalSID;
    DWORD                   returnValue = ERROR_SUCCESS;
    ACE_HEADER              *aceHeader;
    BOOL                    bWellKnownSID = FALSE;

    returnValue = GetPrincipalSID (Principal, &principalSID, &bWellKnownSID);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    GetAclInformation (Acl, (LPVOID) &aclSizeInfo, (DWORD) sizeof (ACL_SIZE_INFORMATION), AclSizeInformation);

    for (i = 0; i < aclSizeInfo.AceCount; i++)
    {
        if (!GetAce (Acl, i, &ace))
        {
            returnValue = GetLastError();
            break;
        }

        aceHeader = (ACE_HEADER *) ace;

        if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
        {
            accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessAllowedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
        {
            accessDeniedAce = (ACCESS_DENIED_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &accessDeniedAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        } else

        if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
        {
            systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;

            if (EqualSid (principalSID, (PSID) &systemAuditAce->SidStart))
            {
                DeleteAce (Acl, i);
                break;
            }
        }
    }

    if (principalSID) {
        if (bWellKnownSID)
            FreeSid (principalSID);
        else
            free (principalSID);
    }

    return returnValue;
}

DWORD
GetCurrentUserSID (
    PSID *Sid
    )
{
    DWORD dwReturn = ERROR_SUCCESS;
    TOKEN_USER  *tokenUser = NULL;
    HANDLE      tokenHandle = NULL;
    DWORD       tokenSize;
    DWORD       sidLength;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
    {
        GetTokenInformation (tokenHandle, TokenUser, tokenUser, 0, &tokenSize);

        tokenUser = (TOKEN_USER *) malloc (tokenSize);

        if (tokenUser == NULL) {
            dwReturn = E_OUTOFMEMORY;
        }
        else if (GetTokenInformation (tokenHandle, TokenUser, tokenUser, tokenSize, &tokenSize))
        {
            sidLength = GetLengthSid (tokenUser->User.Sid);
            *Sid = (PSID) malloc (sidLength);
        
            if (*Sid == NULL) {
                dwReturn = E_OUTOFMEMORY;
            }
            else {
                memcpy (*Sid, tokenUser->User.Sid, sidLength);
                CloseHandle (tokenHandle);
            }
        } else
            dwReturn = GetLastError();

        if (tokenUser)
            free(tokenUser);

    } else
        dwReturn = GetLastError();

    return dwReturn;
}

DWORD
GetPrincipalSID (
    LPTSTR Principal,
    PSID *Sid,
    BOOL *pbWellKnownSID
    )
{
    CString csPrincipal = Principal;
    SID_IDENTIFIER_AUTHORITY SidIdentifierNTAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID_IDENTIFIER_AUTHORITY pSidIdentifierAuthority;
    BYTE Count;
    DWORD dwRID[8];

    *pbWellKnownSID = TRUE;
    memset(&(dwRID[0]), 0, 8 * sizeof(DWORD));
    csPrincipal.MakeLower();
    if ( csPrincipal.Find(_T("administrators")) != -1 ) {
        // Administrators group
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 2;
        dwRID[0] = SECURITY_BUILTIN_DOMAIN_RID;
        dwRID[1] = DOMAIN_ALIAS_RID_ADMINS;
    } else if (csPrincipal.Find(_T("system")) != -1) {
        // SYSTEM
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_LOCAL_SYSTEM_RID;
    } else if (csPrincipal.Find(_T("interactive")) != -1) {
        // INTERACTIVE
        pSidIdentifierAuthority = &SidIdentifierNTAuthority;
        Count = 1;
        dwRID[0] = SECURITY_INTERACTIVE_RID;
    } else if (csPrincipal.Find(_T("everyone")) != -1) {
        // Everyone
        pSidIdentifierAuthority = &SidIdentifierWORLDAuthority;
        Count = 1;
        dwRID[0] = SECURITY_WORLD_RID;
    } else {
        *pbWellKnownSID = FALSE;
    }

    if (*pbWellKnownSID) {
        if ( !AllocateAndInitializeSid(pSidIdentifierAuthority, 
                                    (BYTE)Count, 
		                            dwRID[0], 
		                            dwRID[1], 
		                            dwRID[2], 
		                            dwRID[3], 
		                            dwRID[4], 
		                            dwRID[5], 
		                            dwRID[6], 
		                            dwRID[7], 
                                    Sid) )
        return GetLastError();
    } else {
        // get regular account sid
        DWORD        sidSize;
        TCHAR        refDomain [256];
        DWORD        refDomainSize;
        DWORD        returnValue;
        SID_NAME_USE snu;

        sidSize = 0;
        refDomainSize = 255;

        LookupAccountName (NULL,
                           Principal,
                           *Sid,
                           &sidSize,
                           refDomain,
                           &refDomainSize,
                           &snu);

        returnValue = GetLastError();
        if (returnValue != ERROR_INSUFFICIENT_BUFFER)
            return returnValue;

        *Sid = (PSID) malloc (sidSize);
        refDomainSize = 255;

        if (!LookupAccountName (NULL,
                                Principal,
                                *Sid,
                                &sidSize,
                                refDomain,
                                &refDomainSize,
                                &snu))
        {
            return GetLastError();
        }
    }

    return ERROR_SUCCESS;
}

DWORD
CreateNewSD (
    SECURITY_DESCRIPTOR **SD
    )
{
    PACL    dacl;
    DWORD   sidLength;
    PSID    sid = NULL;
    PSID    groupSID = NULL;
    PSID    ownerSID = NULL;
    DWORD   returnValue;

    *SD = NULL;

    returnValue = GetCurrentUserSID (&sid);
    if (returnValue != ERROR_SUCCESS) {
        if (sid)
            free(sid);
        return returnValue;
    }

    sidLength = GetLengthSid (sid);

    *SD = (SECURITY_DESCRIPTOR *) malloc (
        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) +
        (2 * sidLength) +
        sizeof (SECURITY_DESCRIPTOR));

    groupSID = (SID *) (*SD + 1);
    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength);
    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength);

    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!InitializeAcl (dacl,
                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength,
                        ACL_REVISION2))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!AddAccessAllowedAce (dacl,
                              ACL_REVISION2,
                              COM_RIGHTS_EXECUTE,
                              sid))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (groupSID, sid, sidLength);
    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    memcpy (ownerSID, sid, sidLength);
    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE))
    {
        free (*SD);
        free (sid);
        return GetLastError();
    }

    if (sid)
        free(sid);
    return ERROR_SUCCESS;
}


DWORD
MakeSDAbsolute (
    PSECURITY_DESCRIPTOR OldSD,
    PSECURITY_DESCRIPTOR *NewSD
    )
{
    PSECURITY_DESCRIPTOR  sd = NULL;
    DWORD                 descriptorSize;
    DWORD                 daclSize;
    DWORD                 saclSize;
    DWORD                 ownerSIDSize;
    DWORD                 groupSIDSize;
    PACL                  dacl = NULL;
    PACL                  sacl = NULL;
    PSID                  ownerSID = NULL;
    PSID                  groupSID = NULL;
    BOOL                  present;
    BOOL                  systemDefault;

    //
    // Get SACL
    //

    if (!GetSecurityDescriptorSacl (OldSD, &present, &sacl, &systemDefault))
        return GetLastError();

    if (sacl && present)
    {
        saclSize = sacl->AclSize;
    } else saclSize = 0;

    //
    // Get DACL
    //

    if (!GetSecurityDescriptorDacl (OldSD, &present, &dacl, &systemDefault))
        return GetLastError();

    if (dacl && present)
    {
        daclSize = dacl->AclSize;
    } else daclSize = 0;

    //
    // Get Owner
    //

    if (!GetSecurityDescriptorOwner (OldSD, &ownerSID, &systemDefault))
        return GetLastError();

    ownerSIDSize = GetLengthSid (ownerSID);

    //
    // Get Group
    //

    if (!GetSecurityDescriptorGroup (OldSD, &groupSID, &systemDefault))
        return GetLastError();

    groupSIDSize = GetLengthSid (groupSID);

    //
    // Do the conversion
    //

    descriptorSize = 0;

    MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                    &saclSize, ownerSID, &ownerSIDSize, groupSID,
                    &groupSIDSize);

    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH];
    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION))
        return GetLastError();

    if (!MakeAbsoluteSD (OldSD, sd, &descriptorSize, dacl, &daclSize, sacl,
                         &saclSize, ownerSID, &ownerSIDSize, groupSID,
                         &groupSIDSize))
        return GetLastError();

    *NewSD = sd;
    return ERROR_SUCCESS;
}

DWORD
SetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR *SD
    )
{
    DWORD   returnValue;
    DWORD   disposition;
    HKEY    registryKey;

    //
    // Create new key or open existing key
    //

    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, _T(""), 0, KEY_ALL_ACCESS, NULL, &registryKey, &disposition);
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    //
    // Write the security descriptor
    //

    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD));
    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
GetNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    SECURITY_DESCRIPTOR **SD,
    BOOL *NewSD
    )
{
    DWORD               returnValue;
    HKEY                registryKey;
    DWORD               valueType;
    DWORD               valueSize;

    *NewSD = FALSE;

    //
    // Get the security descriptor from the named value. If it doesn't
    // exist, create a fresh one.
    //

    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &registryKey);

    if (returnValue != ERROR_SUCCESS)
    {
        if (returnValue == ERROR_FILE_NOT_FOUND)
        {
            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
            return ERROR_SUCCESS;
        } else
            return returnValue;
    }

    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, NULL, &valueSize);

    if (returnValue && returnValue != ERROR_INSUFFICIENT_BUFFER)
    {
        *SD = NULL;
        returnValue = CreateNewSD (SD);
        if (returnValue != ERROR_SUCCESS) {
            if (*SD)
                free(*SD);
            return returnValue;
        }

        *NewSD = TRUE;
    } else
    {
        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize);

        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &valueType, (LPBYTE) *SD, &valueSize);
        if (returnValue)
        {
            if (*SD)
                free (*SD);

            *SD = NULL;
            returnValue = CreateNewSD (SD);
            if (returnValue != ERROR_SUCCESS) {
                if (*SD)
                    free(*SD);
                return returnValue;
            }

            *NewSD = TRUE;
        }
    }

    RegCloseKey (registryKey);

    return ERROR_SUCCESS;
}

DWORD
AddPrincipalToNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal,
    BOOL Permit
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;


    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
    }

    //
    // Add the Principal that the caller wants added
    //

    if (Permit)
        returnValue = AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, Principal); 
    else
        returnValue = AddAccessDeniedACEToACL (&dacl, GENERIC_ALL, Principal);

    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute) 
        free (sdAbsolute);

    return returnValue;
}

DWORD
RemovePrincipalFromNamedValueSD (
    HKEY RootKey,
    LPTSTR KeyName,
    LPTSTR ValueName,
    LPTSTR Principal
    )
{
    DWORD               returnValue = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR *sd = NULL;
    SECURITY_DESCRIPTOR *sdSelfRelative = NULL;
    SECURITY_DESCRIPTOR *sdAbsolute = NULL;
    DWORD               secDescSize;
    BOOL                present;
    BOOL                defaultDACL;
    PACL                dacl = NULL;
    BOOL                newSD = FALSE;
    BOOL                fFreeAbsolute = TRUE;

    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &sd, &newSD);

    //
    // Get security descriptor from registry or create a new one
    //

    if (returnValue != ERROR_SUCCESS)
        return returnValue;

    if (!GetSecurityDescriptorDacl (sd, &present, &dacl, &defaultDACL)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // If the security descriptor is new, add the required Principals to it
    //

    if (newSD)
    {
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("SYSTEM"));
        AddAccessAllowedACEToACL (&dacl, COM_RIGHTS_EXECUTE, _T("INTERACTIVE"));
    }

    //
    // Remove the Principal that the caller wants removed
    //

    returnValue = RemovePrincipalFromACL (dacl, Principal);
    if (returnValue != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Make the security descriptor absolute if it isn't new
    //

    if (!newSD) {
        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &sdAbsolute); 
        fFreeAbsolute = TRUE;
    } else {
        sdAbsolute = sd;
        fFreeAbsolute = FALSE;
    }

    //
    // Set the discretionary ACL on the security descriptor
    //

    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Make the security descriptor self-relative so that we can
    // store it in the registry
    //

    secDescSize = 0;
    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize);
    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize);
    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &secDescSize)) {
        returnValue = GetLastError();
        goto Cleanup;
    }

    //
    // Store the security descriptor in the registry
    //

    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative);

Cleanup:
    if (sd)
        free (sd);
    if (sdSelfRelative)
        free (sdSelfRelative);
    if (fFreeAbsolute && sdAbsolute)
        free (sdAbsolute);

    return returnValue;
}

DWORD
ChangeAppIDAccessACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("AccessPermission"), Principal);

     return err;
}

DWORD
ChangeAppIDLaunchACL (
    LPTSTR AppID,
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256];
    DWORD   err;

    if (AppID [0] == _T('{'))
        _stprintf (keyName, _T("APPID\\%s"), AppID); 
    else
        _stprintf (keyName, _T("APPID\\{%s}"), AppID);

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_CLASSES_ROOT, keyName, _T("LaunchPermission"), Principal);

    return err;
}

DWORD
ChangeDCOMAccessACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultAccessPermission"), Principal);
    
    return err;
}

DWORD
ChangeDCOMLaunchACL (
    LPTSTR Principal,
    BOOL SetPrincipal,
    BOOL Permit
    )
{
    TCHAR   keyName [256] = _T("Software\\Microsoft\\OLE");
    DWORD   err;

    if (SetPrincipal)
    {
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
        err = AddPrincipalToNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal, Permit);
    } else
        err = RemovePrincipalFromNamedValueSD (HKEY_LOCAL_MACHINE, keyName, _T("DefaultLaunchPermission"), Principal);
    
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\extndppg.cpp ===
// ExtndPpg.cpp : Implementation of the CExtndPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "ExtndPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CExtndPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CExtndPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CExtndPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CExtndPropPage, "LOGUI.ExtndPropPage.1",
	0x68871e4a, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::CExtndPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CExtndPropPage

BOOL CExtndPropPage::CExtndPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_EXTND_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::CExtndPropPage - Constructor

CExtndPropPage::CExtndPropPage() :
	COlePropertyPage(IDD, IDS_EXTND_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CExtndPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage::DoDataExchange - Moves data between page and properties

void CExtndPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CExtndPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CExtndPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\extndppg.h ===
// ExtndPpg.h : Declaration of the CExtndPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CExtndPropPage : See ExtndPpg.cpp.cpp for implementation.

class CExtndPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CExtndPropPage)
	DECLARE_OLECREATE_EX(CExtndPropPage)

// Constructor
public:
	CExtndPropPage();

// Dialog Data
	//{{AFX_DATA(CExtndPropPage)
	enum { IDD = IDD_PROPPAGE_EXTND };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CExtndPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\cnfrmpsd.h ===
// CnfrmPsD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg dialog

class CConfirmPassDlg : public CDialog
{
// Construction
public:
	CConfirmPassDlg(CWnd* pParent = NULL);   // standard constructor

    // the original password that we are confirming
    CString m_szOrigPass;

// Dialog Data
	//{{AFX_DATA(CConfirmPassDlg)
	enum { IDD = IDD_CONFIRM_ODBC_PASSWORD };
	CString	m_sz_password_new;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfirmPassDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfirmPassDlg)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\helpmap.h ===
// helpmaps for the logui project - handmade

#define HIDD_LOGUI_GENERIC                      0x50200
#define HIDD_LOGUI_EXTENDED						0x50201
#define HIDD_LOGUI_ODBC							0x50202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logadvpg.h ===
#if !defined(AFX_LOGADVCPG_H__1821FE96_9846_11D1_8B99_080009DCC2FA__INCLUDED_)
#define AFX_LOGADVCPG_H__1821FE96_9846_11D1_8B99_080009DCC2FA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// LogAdvPg.h : header file
//



/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced dialog

class CLogAdvanced : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogAdvanced)

// Construction
public:
	CLogAdvanced();

	typedef struct _CONFIG_INFORMATION_
	{
	    DWORD   dwPropertyID;
	    DWORD   dwPropertyMask;
	    bool    fItemModified;
		int		iOrder;

	}   CONFIG_INFORMATION, *PCONFIG_INFORMATION;

    //
    // metabase target
    //

    CString     m_szServer;
    CString     m_szMeta;
    CString     m_szServiceName;

    IMSAdminBase* m_pMB;

// Dialog Data
	//{{AFX_DATA(CLogAdvanced)
	enum { IDD = IDD_LOG_ADVANCED };
	CTreeCtrl	m_wndTreeCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogAdvanced)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogAdvanced)
	virtual BOOL OnInitDialog();
	afx_msg void OnClickTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnKeydownTree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    CImageList  m_cImageList;
    bool        m_fTreeModified;
    
    int         m_cModifiedProperties;
    DWORD       *m_pModifiedPropIDs[2];

    void CreateTreeFromMB();
    void CreateSubTree(CWrapMetaBase& mbWrap, LPTSTR szPath, HTREEITEM hTreeRoot);

    void ProcessClick( HTREEITEM htiItemClicked);

    void ProcessProperties(bool fSave);
    void SetSubTreeProperties(CWrapMetaBase * pMBWrap, HTREEITEM hTreeRoot, BOOL fParentState, BOOL fInitialize);
    void SaveSubTreeProperties(CWrapMetaBase& mbWrap, HTREEITEM hTreeRoot);

    void InsertModifiedFieldInArray(DWORD dwPropID, DWORD dwPropValue);
    bool GetModifiedFieldFromArray(DWORD dwPropID, DWORD * pdwPropValue);
    
    bool IsPresentServiceSupported(LPTSTR szSupportedServices);

    void DeleteSubTreeConfig(HTREEITEM hTreeRoot);

    void DoHelp();

	int LocalizeUIString(LPCTSTR szOrig, LPTSTR szLocalized);

	std::map<CString, int> m_mapLogUI;
	std::map<int, int> m_mapLogUIOrder;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGADVCPG_H__1821FE96_9846_11D1_8B99_080009DCC2FA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logadvpg.cpp ===
// LogAdvPg.cpp : implementation file
//

#include "stdafx.h"
#include "logui.h"
#include "wrapmb.h"
#include <iiscnfg.h>
#include <metatool.h>

#include "LogAdvPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Possible Item States
//

#define TVIS_GCEMPTY        0 
#define TVIS_GCNOCHECK      1 
#define TVIS_GCCHECK        2
#define TVIS_GCTRINOCHECK   3
#define TVIS_GCTRICHECK     4

#define STATEIMAGEMASKTOINDEX(i) ((i) >> 12)

static int CALLBACK LogUICompareProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	// lParamSort contains a pointer to the tree control

	CLogAdvanced::PCONFIG_INFORMATION pCnfgInfo1 = (CLogAdvanced::PCONFIG_INFORMATION) lParam1;
	CLogAdvanced::PCONFIG_INFORMATION pCnfgInfo2 = (CLogAdvanced::PCONFIG_INFORMATION) lParam2;

	CTreeCtrl* pTreeCtrl = (CTreeCtrl*) lParamSort;

	if (pCnfgInfo1->iOrder < pCnfgInfo2->iOrder)
		return(-1);
	else if (pCnfgInfo1->iOrder > pCnfgInfo2->iOrder)
		return(1);
	else	
		return(0);
}

/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced property page

IMPLEMENT_DYNCREATE(CLogAdvanced, CPropertyPage)

CLogAdvanced::CLogAdvanced() : CPropertyPage(CLogAdvanced::IDD)
{
	//{{AFX_DATA_INIT(CLogAdvanced)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_mapLogUIOrder[IDS_DATE] = 1;
    m_mapLogUIOrder[IDS_TIME] = 2;
    m_mapLogUIOrder[IDS_EXTENDED] = 3;
    m_mapLogUIOrder[IDS_PROCESS_ACCT] = 4;

    m_mapLogUIOrder[IDS_CLIENT] = 1;
    m_mapLogUIOrder[IDS_USER] = 2;
    m_mapLogUIOrder[IDS_SERVICE_NAME_T] = 3;
    m_mapLogUIOrder[IDS_SERVER_NAME_T] = 4;
    m_mapLogUIOrder[IDS_SERVER_IP] = 5;
    m_mapLogUIOrder[IDS_SERVER_PORT] = 6;
    m_mapLogUIOrder[IDS_METHOD] = 7;
    m_mapLogUIOrder[IDS_URI_STEM] = 8;
    m_mapLogUIOrder[IDS_URI_QUERY] = 9;
    m_mapLogUIOrder[IDS_PROTOCOL] = 10;
    m_mapLogUIOrder[IDS_WIN32] = 11;               
    m_mapLogUIOrder[IDS_BYTES_SENT_T] = 12;
    m_mapLogUIOrder[IDS_BYTES_RECEIVED] = 13;
    m_mapLogUIOrder[IDS_TIME_TAKEN] = 14;
    m_mapLogUIOrder[IDS_PROTOCOL_VER] = 15;
    m_mapLogUIOrder[IDS_HOST] = 16;
    m_mapLogUIOrder[IDS_USER_AGENT] = 17;
    m_mapLogUIOrder[IDS_COOKIE_T] = 18;
    m_mapLogUIOrder[IDS_REFERER] = 19;

    m_mapLogUIOrder[IDS_PROCESS_EVENT] = 1;
    m_mapLogUIOrder[IDS_PROCESS_TYPE] = 2;
    m_mapLogUIOrder[IDS_TOTAL_USER_TIME] = 3;
    m_mapLogUIOrder[IDS_TOTAL_KERNEL_TIME] = 4;
    m_mapLogUIOrder[IDS_TOTAL_PAGE_FAULTS] = 5;
    m_mapLogUIOrder[IDS_TOTAL_PROCESSES] = 6;
    m_mapLogUIOrder[IDS_ACTIVE_PROCESSES] = 7;
    m_mapLogUIOrder[IDS_TOTAL_TERM_PROCS] = 8;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLogAdvanced)
	DDX_Control(pDX, IDC_PROP_TREE, m_wndTreeCtrl);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CLogAdvanced, CPropertyPage)
	//{{AFX_MSG_MAP(CLogAdvanced)
	ON_NOTIFY(NM_CLICK, IDC_PROP_TREE, OnClickTree)
	ON_NOTIFY(TVN_KEYDOWN, IDC_PROP_TREE, OnKeydownTree)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogAdvanced message handlers

BOOL CLogAdvanced::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    HIMAGELIST hImage = ImageList_LoadImage(AfxGetResourceHandle(),
        MAKEINTRESOURCE(IDB_CHECKBOX), 16, 5, RGB(255,0,0), IMAGE_BITMAP, LR_DEFAULTCOLOR);
    if (hImage != NULL)
    {
        m_wndTreeCtrl.SetImageList(CImageList::FromHandle(hImage), TVSIL_STATE);
    }

    TCHAR	szTemp[256];
    HINSTANCE hWinPtr = (HINSTANCE)GetWindowLongPtr(m_wndTreeCtrl, GWLP_HINSTANCE);

    // initialize ordering scheme
    ::LoadString(hWinPtr, IDS_DATE, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_DATE;
    ::LoadString(hWinPtr, IDS_TIME, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_TIME;
    ::LoadString(hWinPtr, IDS_EXTENDED, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_EXTENDED;
    ::LoadString(hWinPtr, IDS_CLIENT, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_CLIENT;
    ::LoadString(hWinPtr, IDS_USER, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_USER;
    ::LoadString(hWinPtr, IDS_SERVICE_NAME_T, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_SERVICE_NAME_T;
    ::LoadString(hWinPtr, IDS_SERVER_NAME_T, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_SERVER_NAME_T;
    ::LoadString(hWinPtr, IDS_SERVER_IP, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_SERVER_IP;
    ::LoadString(hWinPtr, IDS_SERVER_PORT, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_SERVER_PORT;
    ::LoadString(hWinPtr, IDS_METHOD, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_METHOD;
    ::LoadString(hWinPtr, IDS_URI_STEM, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_URI_STEM;
    ::LoadString(hWinPtr, IDS_URI_QUERY, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_URI_QUERY;
    ::LoadString(hWinPtr, IDS_PROTOCOL, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_PROTOCOL;
    ::LoadString(hWinPtr, IDS_WIN32, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_WIN32;
    ::LoadString(hWinPtr, IDS_BYTES_SENT_T, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_BYTES_SENT_T;
    ::LoadString(hWinPtr, IDS_BYTES_RECEIVED, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_BYTES_RECEIVED;
    ::LoadString(hWinPtr, IDS_TIME_TAKEN, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_TIME_TAKEN;
    ::LoadString(hWinPtr, IDS_PROTOCOL_VER, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_PROTOCOL_VER;
    ::LoadString(hWinPtr, IDS_HOST, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_HOST;
    ::LoadString(hWinPtr, IDS_USER_AGENT, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_USER_AGENT;
    ::LoadString(hWinPtr, IDS_COOKIE_T, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_COOKIE_T;
    ::LoadString(hWinPtr, IDS_REFERER, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_REFERER;
    ::LoadString(hWinPtr, IDS_PROCESS_ACCT, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_PROCESS_ACCT;
    ::LoadString(hWinPtr, IDS_PROCESS_EVENT, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_PROCESS_EVENT;
    ::LoadString(hWinPtr, IDS_PROCESS_TYPE, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_PROCESS_TYPE;
    ::LoadString(hWinPtr, IDS_TOTAL_USER_TIME, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_TOTAL_USER_TIME;
    ::LoadString(hWinPtr, IDS_TOTAL_KERNEL_TIME, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_TOTAL_KERNEL_TIME;
    ::LoadString(hWinPtr, IDS_TOTAL_PAGE_FAULTS, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_TOTAL_PAGE_FAULTS;
    ::LoadString(hWinPtr, IDS_TOTAL_PROCESSES, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_TOTAL_PROCESSES;
    ::LoadString(hWinPtr, IDS_ACTIVE_PROCESSES, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_ACTIVE_PROCESSES;
    ::LoadString(hWinPtr, IDS_TOTAL_TERM_PROCS, szTemp, 256);
    m_mapLogUI[szTemp] = IDS_TOTAL_TERM_PROCS;

    CreateTreeFromMB();
    ProcessProperties(false);
	
    //
    // set up the modified property list array
    //
    
    m_fTreeModified = false;
    m_cModifiedProperties = 0;
    
    int cProperties = m_wndTreeCtrl.GetCount();

    m_pModifiedPropIDs[0] = new DWORD[cProperties];
    m_pModifiedPropIDs[1] = new DWORD[cProperties];

    SetModified(FALSE);

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnClickTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
    DWORD dwpos;
    TV_HITTESTINFO tvhti;
    HTREEITEM  htiItemClicked;
    POINT point;

    //
    // Find out where the cursor was
    //

    dwpos = GetMessagePos();
    point.x = LOWORD(dwpos);
    point.y = HIWORD(dwpos);

    ::MapWindowPoints(HWND_DESKTOP, m_wndTreeCtrl.m_hWnd, &point, 1);

    tvhti.pt = point;
    htiItemClicked = m_wndTreeCtrl.HitTest(&tvhti);

    //
    // If the state image was clicked, lets get the state from the item and toggle it.
    //

    if (tvhti.flags & TVHT_ONITEMSTATEICON)
    {
        ProcessClick(htiItemClicked);
    }

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnKeydownTree(NMHDR* pNMHDR, LRESULT* pResult) 
{
    TV_KEYDOWN* pTVKeyDown = (TV_KEYDOWN*)pNMHDR;
    
    if ( 0x20 != pTVKeyDown->wVKey)
    {
        // User didn't press the space key. Continue default action

        *pResult = 0;
        return;
    }
    
    ProcessClick(m_wndTreeCtrl.GetSelectedItem());

    //
    // Stop any more processing
    //
    
    *pResult = 1;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::ProcessClick( HTREEITEM htiItemClicked)
{
    TV_ITEM                 tvi;
    UINT                    state;
    HTREEITEM               htiChild;
    PCONFIG_INFORMATION     pCnfg;
    
    if(htiItemClicked)
    {

        //
        // Flip the state of the clicked item if the item is enabled
        //

        tvi.hItem       = htiItemClicked;
        tvi.mask        = TVIF_STATE;
        tvi.stateMask   = TVIS_STATEIMAGEMASK;

        m_wndTreeCtrl.GetItem(&tvi); 

        state = STATEIMAGEMASKTOINDEX(tvi.state);
        pCnfg = (PCONFIG_INFORMATION)(tvi.lParam);

        htiChild = m_wndTreeCtrl.GetNextItem(htiItemClicked, TVGN_CHILD);


        if ( TVIS_GCNOCHECK == state )
        {
            tvi.state = INDEXTOSTATEIMAGEMASK (TVIS_GCCHECK) ;
            pCnfg->fItemModified = true;
            
            m_wndTreeCtrl.SetItem(&tvi);
    
            m_fTreeModified = true;
            SetModified();

            // Reset properties for child nodes

            if (htiChild)
            {
                SetSubTreeProperties(NULL, htiChild, TRUE, FALSE);
            }
        }
        else if ( TVIS_GCCHECK == state )
        {
            tvi.state = INDEXTOSTATEIMAGEMASK (TVIS_GCNOCHECK) ;
            pCnfg->fItemModified = true;
            
            m_wndTreeCtrl.SetItem(&tvi);

            m_fTreeModified = true;
            SetModified();

            // Reset properties for child nodes

            if (htiChild)
            {
                SetSubTreeProperties(NULL, htiChild, FALSE, FALSE);
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::ProcessProperties(bool fSave)
{
    CWrapMetaBase   mbWrap;
    HTREEITEM       hRoot;


    if ( NULL == (hRoot = m_wndTreeCtrl.GetRootItem()))
    {
        return;
    }

    // Initialize MB wrapper

    if ( !mbWrap.FInit(m_pMB) ) 
    {
        return;
    }
    
    if (fSave && m_fTreeModified && (mbWrap.Open(m_szMeta, METADATA_PERMISSION_READ|METADATA_PERMISSION_WRITE)))
    {
        m_cModifiedProperties = 0;
        
        SaveSubTreeProperties(mbWrap, hRoot);

        mbWrap.Close();

        //
        // Now we need to throw an inheritance dialog for each of these modified properties
        //

        for(int i=0; i < m_cModifiedProperties; i++)
        {
            //
            // Set the value and check inheritance.
            //

            SetMetaDword(m_pMB, m_szServer, m_szMeta, _T(""), m_pModifiedPropIDs[0][i],
                                IIS_MD_UT_SERVER, m_pModifiedPropIDs[1][i], TRUE);
        }

        m_fTreeModified = false;
    }
    else if ( mbWrap.Open(m_szMeta, METADATA_PERMISSION_READ) )
    {
        SetSubTreeProperties(&mbWrap, hRoot, TRUE, TRUE);
        mbWrap.Close();
    }
}

/////////////////////////////////////////////////////////////////////////////


void CLogAdvanced::SetSubTreeProperties(CWrapMetaBase * pMBWrap, HTREEITEM hTreeRoot, 
                                        BOOL fParentState, BOOL fInitialize)
{
    HTREEITEM           hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;
    UINT                iState;
    DWORD               dwProperty = 0;
    
    if (NULL == hTreeRoot)
    {
        return;
    }

    pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));
    
    if ( NULL != pCnfg)
    {
        if (fInitialize)
        {
            //
            // Read property state from Metabase.
            //
            if (pMBWrap->GetDword(_T(""), pCnfg->dwPropertyID, IIS_MD_UT_SERVER, &dwProperty))
            {
                dwProperty &= pCnfg->dwPropertyMask;
            }
        }
        else
        {
            //
            // we are not initializing, so use the value from the tree
            //

            iState = STATEIMAGEMASKTOINDEX(m_wndTreeCtrl.GetItemState(hTreeRoot, TVIS_STATEIMAGEMASK));

            if ( (TVIS_GCCHECK == iState) || (TVIS_GCTRICHECK == iState))
            {
                dwProperty = TRUE;
            }
            else
            {
                dwProperty = FALSE;
            }
        }

        //
        // Choose the new state depending on parent state
        //

        if (fParentState)
        {
            iState = ( 0 == dwProperty) ?   INDEXTOSTATEIMAGEMASK(TVIS_GCNOCHECK) :
                                            INDEXTOSTATEIMAGEMASK(TVIS_GCCHECK);
        }
        else
        {
            iState = ( 0 == dwProperty) ?   INDEXTOSTATEIMAGEMASK(TVIS_GCTRINOCHECK) :
                                            INDEXTOSTATEIMAGEMASK(TVIS_GCTRICHECK);
        }

        m_wndTreeCtrl.SetItemState(hTreeRoot, iState, TVIS_STATEIMAGEMASK);
    }
    else
    {
        //
        // Tree node with no checkbox (hence no config info)
        //

        dwProperty = TRUE;
        m_wndTreeCtrl.SetItemState(hTreeRoot, INDEXTOSTATEIMAGEMASK(TVIS_GCEMPTY), TVIS_STATEIMAGEMASK);
    }
    
    //
    // Recurse through children and siblings
    //

    if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
    {
        if ( dwProperty && fParentState)
        {
            SetSubTreeProperties(pMBWrap, hTreeChild, TRUE, fInitialize);
        }
        else
        {
            SetSubTreeProperties(pMBWrap, hTreeChild, FALSE, fInitialize);
        }
    }


    if ( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
    {
        SetSubTreeProperties(pMBWrap, hTreeSibling, fParentState, fInitialize);
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::SaveSubTreeProperties(CWrapMetaBase& mbWrap, HTREEITEM hTreeRoot)
{
    HTREEITEM           hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;
    
    if (NULL == hTreeRoot)
    {
        return;
    }

    pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));

    if ((NULL != pCnfg) && ( pCnfg->fItemModified))
    {
        //
        // There is configuration Information. Write to Metabase.
        //

        UINT NewState = STATEIMAGEMASKTOINDEX(m_wndTreeCtrl.GetItemState(hTreeRoot, TVIS_STATEIMAGEMASK));

        if ( (TVIS_GCNOCHECK <= NewState) && (TVIS_GCTRICHECK >= NewState) )
        {
            //
            // Get the property, reset the bit mask & write it back
            //

            DWORD   dwProperty = 0;

            //
            // Get modified value from array if it exists
            //

            if ( !GetModifiedFieldFromArray(pCnfg->dwPropertyID, &dwProperty))
            {
                mbWrap.GetDword(_T(""), pCnfg->dwPropertyID, IIS_MD_UT_SERVER, &dwProperty);
            }
            
            //
            // 0 the appropriate bit & then set it depending on the item state
            //
            
            dwProperty &= ~(pCnfg->dwPropertyMask);

            if ((TVIS_GCCHECK == NewState) || (TVIS_GCTRICHECK == NewState))
            {
                dwProperty |= pCnfg->dwPropertyMask;
            }

            // mbWrap.SetDword(_T(""), pCnfg->dwPropertyID, IIS_MD_UT_SERVER, dwProperty);

            InsertModifiedFieldInArray(pCnfg->dwPropertyID, dwProperty);
        }
    }
    
    //
    // Recurse through children and siblings
    //

    if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
    {
        SaveSubTreeProperties(mbWrap, hTreeChild);
    }

    if( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
    {
        SaveSubTreeProperties(mbWrap, hTreeSibling);
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DeleteSubTreeConfig(HTREEITEM hTreeRoot)
{
    HTREEITEM           hTreeChild, hTreeSibling;
    PCONFIG_INFORMATION pCnfg;


    if (NULL == hTreeRoot)
    {
        return;
    }

    if ( NULL != (hTreeChild = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_CHILD)))
    {
        DeleteSubTreeConfig(hTreeChild);
    }

    if ( NULL != (hTreeSibling = m_wndTreeCtrl.GetNextItem(hTreeRoot, TVGN_NEXT)))
    {
        DeleteSubTreeConfig(hTreeSibling);
    }

    pCnfg = (PCONFIG_INFORMATION)(m_wndTreeCtrl.GetItemData(hTreeRoot));
    
    if (pCnfg)
    {
        delete pCnfg;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::CreateTreeFromMB()
{
    TCHAR           szLoggingUIPath[] = _T("/LM/Logging/Custom Logging");
    CWrapMetaBase   mbWrap;

    // Initialize MB wrapper

    if ( !mbWrap.FInit(m_pMB) ) 
    {
        return;
    }

    //
    // open the logging UI path & create the UI tree
    //

    if ( mbWrap.Open(szLoggingUIPath, METADATA_PERMISSION_READ ) )
    {
        CreateSubTree(mbWrap, _T(""), NULL);
    }

    mbWrap.Close();
    m_wndTreeCtrl.EnsureVisible(m_wndTreeCtrl.GetRootItem());
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::CreateSubTree(CWrapMetaBase& mbWrap, LPTSTR szPath, HTREEITEM hTreeRoot)
{
    int     index = 0;
    TCHAR   szChildName[256];
	TCHAR	szLocalizedChildName[256];
    TCHAR   szW3CHeader[256]    = _T("");
    TCHAR   szNewPath[256]      = _T("");

    TV_ITEM             tvi;
    TV_INSERTSTRUCT     tvins;
    HTREEITEM           hChild = NULL;

    PCONFIG_INFORMATION pCnfgInfo;

    // Prepare the item for insertion

    tvi.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_STATE;
    tvi.state          = INDEXTOSTATEIMAGEMASK(TVIS_GCEMPTY) ;
    tvi.stateMask      = TVIS_STATEIMAGEMASK;

    tvins.hParent      = hTreeRoot;
    tvins.hInsertAfter = TVI_LAST;

    while( mbWrap.EnumObjects(szPath, szChildName, sizeof(szChildName), index) )
    {
        DWORD   size;
        DWORD   dwPropertyID, dwPropertyMask;

        //
        // Create the new path.
        //

        lstrcpy(szNewPath, szPath);
        lstrcat(szNewPath,_T("\\"));
        lstrcat(szNewPath, szChildName);

        //
        // Check if these properties are available to the requesting service
        //

        TCHAR   szSupportedServices[256] = _T("");

        size = 256;
            
        if ( (! mbWrap.GetMultiSZString(szNewPath, 
                                        MD_LOGCUSTOM_SERVICES_STRING, 
                                        IIS_MD_UT_SERVER, 
                                        szSupportedServices, 
                                        sizeof(szSupportedServices))) ||
             (! IsPresentServiceSupported(szSupportedServices))
           )
        {
            //
            // This property is not supported by this service. Skip the node
            //

            index++;
            continue;
        }

        //
        // Copy configuration information into internal structures & 
        // insert it into tree control for future use.
        //

        //
        // Don't zero out the child name. In case we are unable to retrieve the localized
        // name from the MetaBase, just use the name used in the path.
        //

        mbWrap.GetString(szNewPath, MD_LOGCUSTOM_PROPERTY_NAME, IIS_MD_UT_SERVER, 
                         szChildName, sizeof(szChildName), 0);   // name not inheritable

        szW3CHeader[0] = 0;
        size = 256;
        
        mbWrap.GetString(szNewPath, MD_LOGCUSTOM_PROPERTY_HEADER, IIS_MD_UT_SERVER, 
                        szW3CHeader, sizeof(szChildName), 0);   // header not inheritable

        pCnfgInfo = new CONFIG_INFORMATION;

        // if we fail memory alloc, then simply break the loop

        if (pCnfgInfo == NULL) {
            break;
        }

        if ( mbWrap.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_ID, IIS_MD_UT_SERVER, 
                                &dwPropertyID) &&
             mbWrap.GetDword( szNewPath, MD_LOGCUSTOM_PROPERTY_MASK, IIS_MD_UT_SERVER, 
                                &dwPropertyMask)
            )
        {
            pCnfgInfo->dwPropertyID     = dwPropertyID;
            pCnfgInfo->dwPropertyMask   = dwPropertyMask;
        }
	   	else
	   	{
	   		pCnfgInfo->dwPropertyID 	= NULL;
			pCnfgInfo->dwPropertyMask 	= NULL;
	   	}

            pCnfgInfo->fItemModified    = false;

        //
        // Append the W3C Header to the name and add this node to the Tree Control.
        //

        if ( 0 != szW3CHeader[0])
        {
            lstrcat(szChildName,_T("  ( ") );
            lstrcat(szChildName,szW3CHeader);
            lstrcat(szChildName,_T(" )") );
        }

        int iOrder = LocalizeUIString(szChildName, szLocalizedChildName);
		tvi.pszText = szLocalizedChildName;

        pCnfgInfo->iOrder	= iOrder;
        tvi.lParam  		= (LPARAM)pCnfgInfo;

        tvins.item  = tvi;
        hChild      = m_wndTreeCtrl.InsertItem((LPTV_INSERTSTRUCT) &tvins);

        //
        // Enumerate children
        //

        CreateSubTree(mbWrap, szNewPath, hChild);
        
        index++;
    }

    if (0 != index) 
    {
        m_wndTreeCtrl.Expand(hTreeRoot, TVE_EXPAND);
    }

	// Now sort the tree from subtree root down
	TVSORTCB tvs;
	tvs.hParent = hTreeRoot;
	tvs.lpfnCompare = LogUICompareProc;
	tvs.lParam = (LPARAM) &m_wndTreeCtrl;
	m_wndTreeCtrl.SortChildrenCB(&tvs);
}

/////////////////////////////////////////////////////////////////////////////

int CLogAdvanced::LocalizeUIString(LPCTSTR szOrig, LPTSTR szLocalized)
{
	int iStringID = m_mapLogUI[szOrig];

	if (iStringID < 1) 
	{
		lstrcpy(szLocalized, szOrig);
		// need to return a number greater than the number of properties in the tree
		// 10000 seems reasonable
		return(10000);  
	}

	else
	{
		::LoadString((HINSTANCE)GetWindowLongPtr(m_wndTreeCtrl, GWLP_HINSTANCE), iStringID, szLocalized, 256);
		return(m_mapLogUIOrder[iStringID]);
		
	}
}

/////////////////////////////////////////////////////////////////////////////

bool CLogAdvanced::IsPresentServiceSupported(LPTSTR szSupportedServices)
{
    while ( szSupportedServices[0] != 0) 
    {
        if ( 0 == lstrcmpi(m_szServiceName, szSupportedServices) )
        {
            return true;
        }

        szSupportedServices += lstrlen(szSupportedServices)+1;
    }

    return false;
}

/////////////////////////////////////////////////////////////////////////////

BOOL CLogAdvanced::OnApply() 
{
    //
    // Save the state of the tree into the metabase
    //

    ProcessProperties(true);
	
    return CPropertyPage::OnApply();
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::DoHelp()
{
    WinHelp( HIDD_LOGUI_EXTENDED );
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::InsertModifiedFieldInArray(DWORD dwPropID, DWORD dwPropValue)
{
    int     index;
    bool    fFound = false;
    
    if (m_pModifiedPropIDs[0])
    {
        //
        // Search if this property ID pre-exists in the array
        //
        
        for(index = 0; index < m_cModifiedProperties; index++)
        {
            if (dwPropID == m_pModifiedPropIDs[0][index])
            {
                fFound = true;   
                break;
            }   
        }

        if (fFound)
        {
            m_pModifiedPropIDs[1][index] = dwPropValue;
        }
        else
        {
            m_pModifiedPropIDs[0][m_cModifiedProperties] = dwPropID;
            m_pModifiedPropIDs[1][m_cModifiedProperties]= dwPropValue;
            m_cModifiedProperties++;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

bool CLogAdvanced::GetModifiedFieldFromArray(DWORD dwPropID, DWORD * pdwPropValue)
{
    int     index;
    bool    fFound = false;
    
    if (m_pModifiedPropIDs[0])
    {
        //
        // Search if this property ID pre-exists in the array
        //
        
        for(index = 0; index < m_cModifiedProperties; index++)
        {
            if (dwPropID == m_pModifiedPropIDs[0][index])
            {
                fFound = true;   
                break;
            }   
        }

        if (fFound)
        {
            *pdwPropValue = m_pModifiedPropIDs[1][index];
        }
    }

    return fFound;
}

/////////////////////////////////////////////////////////////////////////////

void CLogAdvanced::OnDestroy() 
{
	CPropertyPage::OnDestroy();

    //
    // Delete all the CONFIG_INFORMATION structures
    //
    CImageList * pImage = m_wndTreeCtrl.SetImageList(CImageList::FromHandle(NULL), TVSIL_STATE);
    if (pImage != NULL && pImage->m_hImageList != NULL)
    {
        ImageList_Destroy(pImage->m_hImageList);
    }
    DeleteSubTreeConfig(m_wndTreeCtrl.GetRootItem());

    delete [] m_pModifiedPropIDs[0];
    delete [] m_pModifiedPropIDs[1];
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logextpg.cpp ===
// LogExtPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "logui.h"
#include "LogExtPg.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>
#include <logconst.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogExtended property page

IMPLEMENT_DYNCREATE(CLogExtended, CPropertyPage)

CLogExtended::CLogExtended() : CPropertyPage(CLogExtended::IDD),
        m_fInitialized( FALSE )
    {
    //{{AFX_DATA_INIT(CLogExtended)
    m_bool_bytesreceived = FALSE;
    m_bool_bytessent = FALSE;
    m_bool_clientip = FALSE;
    m_bool_cookie = FALSE;
    m_bool_date = FALSE;
    m_bool_httpstatus = FALSE;
    m_bool_referer = FALSE;
    m_bool_serverip = FALSE;
    m_bool_servername = FALSE;
    m_bool_servicename = FALSE;
    m_bool_time = FALSE;
    m_bool_timetaken = FALSE;
    m_bool_uriquery = FALSE;
    m_bool_uristem = FALSE;
    m_bool_useragent = FALSE;
    m_bool_username = FALSE;
    m_bool_win32status = FALSE;
    m_bool_method = FALSE;
	m_bool_serverport = FALSE;
	m_bool_version = FALSE;
	//}}AFX_DATA_INIT
    }

CLogExtended::~CLogExtended()
    {
    }

void CLogExtended::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogExtended)
    DDX_Check(pDX, IDC_CHK_BYTESRECEIVED, m_bool_bytesreceived);
    DDX_Check(pDX, IDC_CHK_BYTESSENT, m_bool_bytessent);
    DDX_Check(pDX, IDC_CHK_CLIENTIP, m_bool_clientip);
    DDX_Check(pDX, IDC_CHK_COOKIE, m_bool_cookie);
    DDX_Check(pDX, IDC_CHK_DATE, m_bool_date);
    DDX_Check(pDX, IDC_CHK_HTTPSTATUS, m_bool_httpstatus);
    DDX_Check(pDX, IDC_CHK_REFERER, m_bool_referer);
    DDX_Check(pDX, IDC_CHK_SERVERIP, m_bool_serverip);
    DDX_Check(pDX, IDC_CHK_SERVERNAME, m_bool_servername);
    DDX_Check(pDX, IDC_CHK_SERVICENAME, m_bool_servicename);
    DDX_Check(pDX, IDC_CHK_TIME, m_bool_time);
    DDX_Check(pDX, IDC_CHK_TIMETAKEN, m_bool_timetaken);
    DDX_Check(pDX, IDC_CHK_URI_QUERY, m_bool_uriquery);
    DDX_Check(pDX, IDC_CHK_URISTEM, m_bool_uristem);
    DDX_Check(pDX, IDC_CHK_USERAGENT, m_bool_useragent);
    DDX_Check(pDX, IDC_CHK_USERNAME, m_bool_username);
    DDX_Check(pDX, IDC_CHK_WIN32STATUS, m_bool_win32status);
    DDX_Check(pDX, IDC_METHOD, m_bool_method);
	DDX_Check(pDX, IDC_CHK_SERVERPORT, m_bool_serverport);
	DDX_Check(pDX, IDC_CHK_VERSION, m_bool_version);
	//}}AFX_DATA_MAP
    }


//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CLogExtended, CPropertyPage)
    //{{AFX_MSG_MAP(CLogExtended)
	ON_BN_CLICKED(IDC_CHK_BYTESRECEIVED, OnChkBytesreceived)
	ON_BN_CLICKED(IDC_CHK_BYTESSENT, OnChkBytessent)
	ON_BN_CLICKED(IDC_CHK_CLIENTIP, OnChkClientip)
	ON_BN_CLICKED(IDC_CHK_COOKIE, OnChkCookie)
	ON_BN_CLICKED(IDC_CHK_DATE, OnChkDate)
	ON_BN_CLICKED(IDC_CHK_HTTPSTATUS, OnChkHttpstatus)
	ON_BN_CLICKED(IDC_CHK_REFERER, OnChkReferer)
	ON_BN_CLICKED(IDC_CHK_SERVERIP, OnChkServerip)
	ON_BN_CLICKED(IDC_CHK_SERVERNAME, OnChkServername)
	ON_BN_CLICKED(IDC_CHK_SERVICENAME, OnChkServicename)
	ON_BN_CLICKED(IDC_CHK_TIME, OnChkTime)
	ON_BN_CLICKED(IDC_CHK_TIMETAKEN, OnChkTimetaken)
	ON_BN_CLICKED(IDC_CHK_URI_QUERY, OnChkUriQuery)
	ON_BN_CLICKED(IDC_CHK_URISTEM, OnChkUristem)
	ON_BN_CLICKED(IDC_CHK_USERAGENT, OnChkUseragent)
	ON_BN_CLICKED(IDC_CHK_USERNAME, OnChkUsername)
	ON_BN_CLICKED(IDC_CHK_WIN32STATUS, OnChkWin32status)
	ON_BN_CLICKED(IDC_METHOD, OnMethod)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CLogExtended::DoHelp()
    {
    WinHelp( HIDD_LOGUI_EXTENDED );
    }

//--------------------------------------------------------------------------
void CLogExtended::Init()
    {
    DWORD   dwFlags;
    BOOL    fGotIt = FALSE;

    // we will be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;

    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_READ ) )
        {
        // start with the logging period
        fGotIt = mbWrap.GetDword( _T(""), MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, &dwFlags, METADATA_INHERIT );
        // close the metabase
        mbWrap.Close();
        }

    // if we didn't get it, use the default values
    if ( !fGotIt )
        dwFlags = DEFAULT_EXTLOG_FIELDS;

    // seperate out all the fields
    UpdateData( TRUE );

    if ( dwFlags & EXTLOG_BYTES_RECV )  m_bool_bytesreceived =  TRUE;
    if ( dwFlags & EXTLOG_BYTES_SENT )  m_bool_bytessent =      TRUE;
    if ( dwFlags & EXTLOG_CLIENT_IP )   m_bool_clientip =       TRUE;
    if ( dwFlags & EXTLOG_COOKIE )      m_bool_cookie =         TRUE;
    if ( dwFlags & EXTLOG_DATE )        m_bool_date =           TRUE;
    if ( dwFlags & EXTLOG_HTTP_STATUS ) m_bool_httpstatus =     TRUE;
    if ( dwFlags & EXTLOG_REFERER )     m_bool_referer =        TRUE;
    if ( dwFlags & EXTLOG_SERVER_IP )   m_bool_serverip =       TRUE;
    if ( dwFlags & EXTLOG_SERVER_PORT )   m_bool_serverport =   TRUE;
    if ( dwFlags & EXTLOG_COMPUTER_NAME ) m_bool_servername =   TRUE;
    if ( dwFlags & EXTLOG_SITE_NAME )   m_bool_servicename =    TRUE;
    if ( dwFlags & EXTLOG_TIME )        m_bool_time =           TRUE;
    if ( dwFlags & EXTLOG_TIME_TAKEN )  m_bool_timetaken =      TRUE;
    if ( dwFlags & EXTLOG_URI_QUERY )   m_bool_uriquery =       TRUE;
    if ( dwFlags & EXTLOG_URI_STEM )    m_bool_uristem =        TRUE;
    if ( dwFlags & EXTLOG_USER_AGENT )  m_bool_useragent =      TRUE;
    if ( dwFlags & EXTLOG_USERNAME )    m_bool_username =       TRUE;
    if ( dwFlags & EXTLOG_WIN32_STATUS ) m_bool_win32status =   TRUE;
    if ( dwFlags & EXTLOG_METHOD )      m_bool_method =         TRUE;
    if ( dwFlags & EXTLOG_PROTOCOL_VERSION ) m_bool_version =   TRUE;

    // set the data back
    UpdateData( FALSE );
    }

/////////////////////////////////////////////////////////////////////////////
// CLogExtended message handlers

//--------------------------------------------------------------------------
BOOL CLogExtended::OnSetActive()
    {
    // if we haven't been initialized yet, do so
    if ( !m_fInitialized )
        {
        Init();
        m_fInitialized = TRUE;
        }

    return CPropertyPage::OnSetActive();
    }

//--------------------------------------------------------------------------
BOOL CLogExtended::OnApply()
    {
    DWORD   dwFlags = 0;
    BOOL    f;

    // prepare the extended logging flag
    if ( m_bool_bytesreceived ) dwFlags |= EXTLOG_BYTES_RECV;
    if ( m_bool_bytessent )     dwFlags |= EXTLOG_BYTES_SENT;
    if ( m_bool_clientip )      dwFlags |= EXTLOG_CLIENT_IP;
    if ( m_bool_cookie )        dwFlags |= EXTLOG_COOKIE;
    if ( m_bool_date )          dwFlags |= EXTLOG_DATE;
    if ( m_bool_httpstatus )    dwFlags |= EXTLOG_HTTP_STATUS;
    if ( m_bool_referer )       dwFlags |= EXTLOG_REFERER;
    if ( m_bool_serverport )    dwFlags |= EXTLOG_SERVER_PORT;
    if ( m_bool_serverip )      dwFlags |= EXTLOG_SERVER_IP;
    if ( m_bool_servername )    dwFlags |= EXTLOG_COMPUTER_NAME;
    if ( m_bool_servicename )   dwFlags |= EXTLOG_SITE_NAME;
    if ( m_bool_time )          dwFlags |= EXTLOG_TIME;
    if ( m_bool_timetaken )     dwFlags |= EXTLOG_TIME_TAKEN;
    if ( m_bool_uriquery )      dwFlags |= EXTLOG_URI_QUERY;
    if ( m_bool_uristem )       dwFlags |= EXTLOG_URI_STEM;
    if ( m_bool_useragent )     dwFlags |= EXTLOG_USER_AGENT;
    if ( m_bool_username )      dwFlags |= EXTLOG_USERNAME;
    if ( m_bool_win32status )   dwFlags |= EXTLOG_WIN32_STATUS;
    if ( m_bool_method )        dwFlags |= EXTLOG_METHOD;
    if ( m_bool_version )       dwFlags |= EXTLOG_PROTOCOL_VERSION;

    // set the extended logging logging field mask
    f = SetMetaDword( m_pMB, m_szServer, m_szMeta, _T(""), MD_LOGEXT_FIELD_MASK,
                IIS_MD_UT_SERVER, dwFlags, TRUE );

    SetModified( FALSE );
    return CPropertyPage::OnApply();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkBytesreceived()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkBytessent()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkClientip()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkCookie()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkDate()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkHttpstatus()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkReferer()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkServerip()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkServername()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkServicename()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkTime()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkTimetaken()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkUriQuery()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkUristem()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkUseragent()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkUsername()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnChkWin32status()
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogExtended::OnMethod()
    {
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logextpg.h ===
// LogExtended.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogExtended dialog

class CLogExtended : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogExtended)

// Construction
public:
	CLogExtended();
	~CLogExtended();
    
    // metabase target
    CString     m_szServer;
    CString     m_szMeta;
    IMSAdminBase* m_pMB;

// Dialog Data
	//{{AFX_DATA(CLogExtended)
	enum { IDD = IDD_LOG_EXTENDED };
	BOOL	m_bool_bytesreceived;
	BOOL	m_bool_bytessent;
	BOOL	m_bool_clientip;
	BOOL	m_bool_cookie;
	BOOL	m_bool_date;
	BOOL	m_bool_httpstatus;
	BOOL	m_bool_referer;
	BOOL	m_bool_serverip;
	BOOL	m_bool_servername;
	BOOL	m_bool_servicename;
	BOOL	m_bool_time;
	BOOL	m_bool_timetaken;
	BOOL	m_bool_uriquery;
	BOOL	m_bool_uristem;
	BOOL	m_bool_useragent;
	BOOL	m_bool_username;
	BOOL	m_bool_win32status;
	BOOL	m_bool_method;
	BOOL	m_bool_serverport;
	BOOL	m_bool_version;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogExtended)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogExtended)
	afx_msg void OnChkBytesreceived();
	afx_msg void OnChkBytessent();
	afx_msg void OnChkClientip();
	afx_msg void OnChkCookie();
	afx_msg void OnChkDate();
	afx_msg void OnChkHttpstatus();
	afx_msg void OnChkReferer();
	afx_msg void OnChkServerip();
	afx_msg void OnChkServername();
	afx_msg void OnChkServicename();
	afx_msg void OnChkTime();
	afx_msg void OnChkTimetaken();
	afx_msg void OnChkUriQuery();
	afx_msg void OnChkUristem();
	afx_msg void OnChkUseragent();
	afx_msg void OnChkUsername();
	afx_msg void OnChkWin32status();
	afx_msg void OnMethod();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    void Init();

    // initialized flag
    BOOL    m_fInitialized;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logodbc.h ===
// LogODBC.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogODBC dialog

class CLogODBC : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogODBC)

// Construction
public:
	CLogODBC();
	~CLogODBC();

    // metabase target
    CString     m_szServer;
    CString     m_szMeta;
    IMSAdminBase* m_pMB;

// Dialog Data
	//{{AFX_DATA(CLogODBC)
	enum { IDD = IDD_LOG_ODBC };
	CEdit	m_cedit_password;
	CString	m_sz_datasource;
	CString	m_sz_password;
	CString	m_sz_table;
	CString	m_sz_username;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogODBC)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogODBC)
	afx_msg void OnChangeOdbcDatasource();
	afx_msg void OnChangeOdbcPassword();
	afx_msg void OnChangeOdbcTable();
	afx_msg void OnChangeOdbcUsername();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    void Init();

    // initialized flag
    BOOL    m_fInitialized;

    CString m_szOrigPass;
    BOOL    m_bPassTyped;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logodbc.cpp ===
// LogODBC.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "logui.h"
#include "LogODBC.h"
#include "CnfrmPsD.h"

#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogODBC property page

IMPLEMENT_DYNCREATE(CLogODBC, CPropertyPage)

//--------------------------------------------------------------------------
CLogODBC::CLogODBC() : CPropertyPage(CLogODBC::IDD),
        m_fInitialized( FALSE )
    {
    //{{AFX_DATA_INIT(CLogODBC)
    m_sz_datasource = _T("");
    m_sz_password = _T("");
    m_sz_table = _T("");
    m_sz_username = _T("");
    //}}AFX_DATA_INIT

    m_szOrigPass.Empty();
    m_bPassTyped = FALSE;
    }

//--------------------------------------------------------------------------
CLogODBC::~CLogODBC()
    {
    }

//--------------------------------------------------------------------------
void CLogODBC::DoDataExchange(CDataExchange* pDX)
    {
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogODBC)
	DDX_Control(pDX, IDC_ODBC_PASSWORD, m_cedit_password);
    DDX_Text(pDX, IDC_ODBC_DATASOURCE, m_sz_datasource);
    DDX_Text(pDX, IDC_ODBC_PASSWORD, m_sz_password);
    DDX_Text(pDX, IDC_ODBC_TABLE, m_sz_table);
    DDX_Text(pDX, IDC_ODBC_USERNAME, m_sz_username);
	//}}AFX_DATA_MAP
    }

//--------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CLogODBC, CPropertyPage)
    //{{AFX_MSG_MAP(CLogODBC)
    ON_EN_CHANGE(IDC_ODBC_DATASOURCE, OnChangeOdbcDatasource)
    ON_EN_CHANGE(IDC_ODBC_PASSWORD, OnChangeOdbcPassword)
	ON_EN_CHANGE(IDC_ODBC_TABLE, OnChangeOdbcTable)
	ON_EN_CHANGE(IDC_ODBC_USERNAME, OnChangeOdbcUsername)
	//}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CLogODBC::DoHelp()
    {
    WinHelp( HIDD_LOGUI_ODBC );
    }

//--------------------------------------------------------------------------
void CLogODBC::Init()
    {
    UpdateData( TRUE );
    DWORD   dw;
    LPCTSTR  pstr;

    // we will just be pulling stuff out of the metabase here
    // prepare the metabase wrapper
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(m_pMB) ) return;

    // open the target
    if ( mbWrap.Open( m_szMeta, METADATA_PERMISSION_READ ) )
        {
        // datasources
        pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGSQL_DATA_SOURCES, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_datasource = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // password
        pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGSQL_PASSWORD, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_password = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );

            m_szOrigPass = m_sz_password;
            if ( !m_sz_password.IsEmpty() )
                m_sz_password.LoadString( IDS_SHOWN_PASSWORD );
            }

        // table name
        pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGSQL_TABLE_NAME, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_table = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // user name
        pstr = (LPCTSTR)mbWrap.GetData( _T(""), MD_LOGSQL_USER_NAME, IIS_MD_UT_SERVER, STRING_METADATA, &dw, METADATA_INHERIT );
        if ( pstr )
            {
            m_sz_username = pstr;
            // free it
            mbWrap.FreeWrapData( (PVOID)pstr );
            }

        // close the metabase
        mbWrap.Close();
        }

    // put the data into place
    UpdateData( FALSE );
    }

/////////////////////////////////////////////////////////////////////////////
// CLogODBC message handlers


//--------------------------------------------------------------------------
BOOL CLogODBC::OnApply() 
    {
    BOOL    f;
    UpdateData( TRUE );

    // confirm the password
    if ( m_bPassTyped )
        {
        CConfirmPassDlg dlgPass;
        dlgPass.m_szOrigPass = m_sz_password;
        if ( dlgPass.DoModal() != IDOK )
            {
            m_cedit_password.SetFocus();
            m_cedit_password.SetSel(0, -1);
            return FALSE;
            }
        }


    // prepare and open the metabase object
    CWrapMetaBase   mb;
    if ( !mb.FInit(m_pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mb, m_szMeta, 
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // prepare for the inheritence checks
        CCheckInheritList   listInherit;

        f = SetMBString(&mb, &listInherit, _T(""), MD_LOGSQL_DATA_SOURCES,
                    IIS_MD_UT_SERVER, m_sz_datasource, FALSE);
    
        if ( m_bPassTyped )
            {
            f = SetMBString(&mb, &listInherit, _T(""), MD_LOGSQL_PASSWORD,
                        IIS_MD_UT_SERVER, m_sz_password, TRUE);
            }

        f = SetMBString(&mb, &listInherit, _T(""), MD_LOGSQL_TABLE_NAME,
                    IIS_MD_UT_SERVER, m_sz_table, FALSE);
        f = SetMBString(&mb, &listInherit, _T(""), MD_LOGSQL_USER_NAME,
                    IIS_MD_UT_SERVER, m_sz_username, FALSE);

        // close the metabase
        mb.Close();

        // do all the inheritence checks
        listInherit.CheckInheritence( m_szServer, m_szMeta );
        }


     

    // clear the modified flag
    SetModified( FALSE );

    // reset the internal password-typed flag
    m_szOrigPass = m_sz_password;
    m_bPassTyped = FALSE;

    
    return CPropertyPage::OnApply();
    }

//--------------------------------------------------------------------------
BOOL CLogODBC::OnSetActive() 
    {
    if ( !m_fInitialized )
        {
        Init();
        m_fInitialized = TRUE;
        }
    return CPropertyPage::OnSetActive();
    }

//--------------------------------------------------------------------------
void CLogODBC::OnChangeOdbcDatasource() 
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogODBC::OnChangeOdbcPassword() 
    {
    m_bPassTyped = TRUE;
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogODBC::OnChangeOdbcTable() 
    {
    SetModified();
    }

//--------------------------------------------------------------------------
void CLogODBC::OnChangeOdbcUsername() 
    {
    SetModified();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\loggenpg.h ===
// LogGenPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogGeneral dialog

class CLogGeneral : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogGeneral)

// Construction
public:
	CLogGeneral();
	~CLogGeneral();

   int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);

    CComboBox*  m_pComboLog;

    // metabase target
    CString     m_szServer;
    CString     m_szMeta;
    IMSAdminBase* m_pMB;

    // editing local machine
    BOOL        m_fLocalMachine;
    BOOL        m_fShowLocalTimeCheckBox;

    // the two-letter file prefix
    CString szPrefix;
    // the longer file size prefix
    CString szSizePrefix;

// Dialog Data
	//{{AFX_DATA(CLogGeneral)
	enum { IDD = IDD_LOG_GENERAL };
	CButton	m_wndPeriod;
	CButton	m_wndUseLocalTime;
	CButton	m_cbttn_browse;
	CEdit	m_cedit_directory;
	CEdit	m_cedit_size;
	CSpinButtonCtrl	m_cspin_spin;
	CStatic	m_cstatic_units;
	CString	m_sz_directory;
	CString	m_sz_filesample;
	BOOL	m_fUseLocalTime;
	int		m_int_period;
	//}}AFX_DATA
//    CILong  m_dword_filesize;
	DWORD	m_dword_filesize;



// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogGeneral)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CLogGeneral)
	afx_msg void OnBrowse();
	afx_msg void OnLogDaily();
	afx_msg void OnLogMonthly();
	afx_msg void OnLogWhensize();
	afx_msg void OnLogWeekly();
	afx_msg void OnChangeLogDirectory();
	afx_msg void OnChangeLogSize();
	afx_msg void OnLogUnlimited();
	afx_msg void OnLogHourly();
	afx_msg void OnUseLocalTime();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void DoHelp();

    // update the sample file stirng
    virtual void UpdateSampleFileString();
    HRESULT GetServiceVersion();

    void    Init();
    void    UpdateDependants();

private:
    // initialized flag
    BOOL    m_fInitialized;
    BOOL    m_fIsModified;
    LPTSTR  m_pPathTemp;
	CString m_NetHood;
    DWORD m_dwVersionMajor, m_dwVersionMinor;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logtools.cpp ===
// common tools used by the various logging uis

#include "stdafx.h"
#include "logui.h"
#include "logtools.h"





//---------------------------------------------------------------
// Given the class ID of a server, it goes into the registry and
// sets the Apartment Model flag for that object.
// The strings used here are non-localized. They are also specific
// to this routine.
BOOL FSetObjectApartmentModel( REFCLSID clsid )
{
    LPOLESTR    pszwSid;
    LONG        err;
    HKEY        hKey;

    // transform the clsid into a string
    StringFromCLSID(
        clsid, //CLSID to be converted 
        &pszwSid //Address of output variable that receives a pointer to the resulting string 
        );

    // put it in a cstring
    CString szSid = pszwSid;

    // free the ole string
    CoTaskMemFree( pszwSid );

    // build the registry path
    CString szRegPath = _T("CLSID\\");
    szRegPath += szSid;
    szRegPath += _T("\\InProcServer32");

    // prep the apartment name
    CString szApartment = _T("Apartment");

    // open the registry key
    err = RegOpenKey(
            HKEY_CLASSES_ROOT,  // handle of open key  
            (LPCTSTR)szRegPath, // address of name of subkey to open  
            &hKey               // address of handle of open key  
            );
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // set the apartment threading value
    err = RegSetValueEx(
            hKey, // handle of key to set value for  
            _T("ThreadingModel"), // address of value to set  
            0, // reserved  
            REG_SZ, // flag for value type  
            (PBYTE)(LPCTSTR)szApartment, // address of value data  
            (szApartment.GetLength() + 1) * sizeof(TCHAR)  // size of value data  
            ); 
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // close the registry key
    RegCloseKey( hKey );

    return TRUE;
}




//---------------------------------------------------------------
// tests a machine name to see if it is the local machine it is
// talking about
BOOL FIsLocalMachine( LPCTSTR psz )
	{
    CString szLocal;
    DWORD   cch = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    fAnswer;

    // get the actual name of the local machine
    fAnswer = GetComputerName(szLocal.GetBuffer(cch), &cch);
    szLocal.ReleaseBuffer();
    if ( !fAnswer )
        return FALSE;

    // compare and return
    fAnswer = (szLocal.CompareNoCase( psz ) == 0);
    return fAnswer;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logtools.h ===
BOOL FSetObjectApartmentModel( REFCLSID clsid );
BOOL FIsLocalMachine( LPCTSTR psz );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\loggenpg.cpp ===
// LogGenPg.cpp : implementation file
//

#include "stdafx.h"
#include <iadmw.h>
#include "logui.h"
#include "LogGenPg.h"
#include "wrapmb.h"
#include "metatool.h"
#include <iiscnfg.h>
#include <idlg.h>

#include <shlobj.h>
#include <shlwapi.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define     SIZE_MBYTE          1048576
#define     MAX_LOGFILE_SIZE    4000

#define MD_LOGFILE_PERIOD_UNLIMITED  MD_LOGFILE_PERIOD_HOURLY + 1

//
// Support functions to map & unmap the weird logfile ordering to the UI ordering
//

/////////////////////////////////////////////////////////////////////////////

int MapLogFileTypeToUIIndex(int iLogFileType)
{
    int iUIIndex;

    switch (iLogFileType)
    {
    case MD_LOGFILE_PERIOD_HOURLY:      iUIIndex = 0; break;
    case MD_LOGFILE_PERIOD_DAILY:       iUIIndex = 1; break;
    case MD_LOGFILE_PERIOD_WEEKLY:      iUIIndex = 2; break;
    case MD_LOGFILE_PERIOD_MONTHLY:     iUIIndex = 3; break;
    case MD_LOGFILE_PERIOD_UNLIMITED:   iUIIndex = 4; break;
    case MD_LOGFILE_PERIOD_NONE:        iUIIndex = 5; break;
    }
    return iUIIndex;
}

/////////////////////////////////////////////////////////////////////////////

int MapUIIndexToLogFileType(int iUIIndex)
{
    int iLogFileType;

    switch (iUIIndex)
    {
    case 0: iLogFileType = MD_LOGFILE_PERIOD_HOURLY; break;
    case 1: iLogFileType = MD_LOGFILE_PERIOD_DAILY; break;
    case 2: iLogFileType = MD_LOGFILE_PERIOD_WEEKLY; break;
    case 3: iLogFileType = MD_LOGFILE_PERIOD_MONTHLY; break;
    case 4: iLogFileType = MD_LOGFILE_PERIOD_UNLIMITED; break;
    case 5: iLogFileType = MD_LOGFILE_PERIOD_NONE; break;
    }
    return iLogFileType;
}


/////////////////////////////////////////////////////////////////////////////
// CLogGeneral property page

IMPLEMENT_DYNCREATE(CLogGeneral, CPropertyPage)

//--------------------------------------------------------------------------
CLogGeneral::CLogGeneral() : CPropertyPage(CLogGeneral::IDD),
    m_fInitialized( FALSE ),
    m_pComboLog( NULL ),
    m_fLocalMachine( FALSE )
{
    //{{AFX_DATA_INIT(CLogGeneral)
    m_sz_directory = _T("");
    m_sz_filesample = _T("");
    m_fShowLocalTimeCheckBox = FALSE;
    m_int_period = -1;
    //}}AFX_DATA_INIT

    m_dwVersionMajor = 5;
    m_dwVersionMinor = 1;
    m_fIsModified = FALSE;
}

//--------------------------------------------------------------------------
CLogGeneral::~CLogGeneral()
{
}

//--------------------------------------------------------------------------
void CLogGeneral::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogGeneral)
    DDX_Control(pDX, IDC_LOG_HOURLY, m_wndPeriod);
    DDX_Control(pDX, IDC_USE_LOCAL_TIME, m_wndUseLocalTime);
    DDX_Control(pDX, IDC_LOG_BROWSE, m_cbttn_browse);
    DDX_Control(pDX, IDC_LOG_DIRECTORY, m_cedit_directory);
    DDX_Control(pDX, IDC_LOG_SIZE, m_cedit_size);
    DDX_Control(pDX, IDC_SPIN, m_cspin_spin);
    DDX_Control(pDX, IDC_LOG_SIZE_UNITS, m_cstatic_units);
    DDX_Text(pDX, IDC_LOG_DIRECTORY, m_sz_directory);
    DDV_MaxChars(pDX, m_sz_directory, MAX_PATH);
    DDX_Text(pDX, IDC_LOG_FILE_SAMPLE, m_sz_filesample);
    DDX_Check(pDX, IDC_USE_LOCAL_TIME, m_fUseLocalTime);
    // DDX_Radio(pDX, IDC_LOG_HOURLY, m_int_period);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_LOG_SIZE, m_dword_filesize);
    DDV_MinMaxLong(pDX, m_dword_filesize, 0, MAX_LOGFILE_SIZE);

    //
    // Do the map & unmap between UI Index & Log File Type
    //

    if (pDX->m_bSaveAndValidate)
    {
        DDX_Radio(pDX, IDC_LOG_HOURLY, m_int_period);
        m_int_period = MapUIIndexToLogFileType(m_int_period);
    }
    else
    {
        int iUIIndex = MapLogFileTypeToUIIndex(m_int_period);
        DDX_Radio(pDX, IDC_LOG_HOURLY, iUIIndex);
    }
}


BEGIN_MESSAGE_MAP(CLogGeneral, CPropertyPage)
    //{{AFX_MSG_MAP(CLogGeneral)
    ON_BN_CLICKED(IDC_LOG_BROWSE, OnBrowse)
    ON_BN_CLICKED(IDC_LOG_DAILY, OnLogDaily)
    ON_BN_CLICKED(IDC_LOG_MONTHLY, OnLogMonthly)
    ON_BN_CLICKED(IDC_LOG_WHENSIZE, OnLogWhensize)
    ON_BN_CLICKED(IDC_LOG_WEEKLY, OnLogWeekly)
    ON_EN_CHANGE(IDC_LOG_DIRECTORY, OnChangeLogDirectory)
    ON_EN_CHANGE(IDC_LOG_SIZE, OnChangeLogSize)
    ON_BN_CLICKED(IDC_LOG_UNLIMITED, OnLogUnlimited)
    ON_BN_CLICKED(IDC_LOG_HOURLY, OnLogHourly)
    ON_BN_CLICKED(IDC_USE_LOCAL_TIME, OnUseLocalTime)
    //}}AFX_MSG_MAP
    ON_COMMAND(ID_HELP_FINDER,  DoHelp)
    ON_COMMAND(ID_HELP,         DoHelp)
    ON_COMMAND(ID_CONTEXT_HELP, DoHelp)
    ON_COMMAND(ID_DEFAULT_HELP, DoHelp)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
void CLogGeneral::DoHelp()
{
    WinHelp( HIDD_LOGUI_GENERIC );
}

HRESULT
CLogGeneral::GetServiceVersion()
{
    CError err;
    CString info_path;
    if (NULL != CMetabasePath::GetServiceInfoPath(m_szMeta, info_path))
    {
        CComAuthInfo auth;
        CMetaKey mk(&auth, info_path, METADATA_PERMISSION_READ);
        err = mk.QueryResult();
        if (err.Succeeded())
        {
            err = mk.QueryValue(MD_SERVER_VERSION_MAJOR, m_dwVersionMajor);
            if (err.Succeeded())
            {
                err = mk.QueryValue(MD_SERVER_VERSION_MINOR, m_dwVersionMinor);
            }
        }
    }
    else
    {
        err = E_FAIL;
    }
    return err;
}

//--------------------------------------------------------------------------
void CLogGeneral::Init()
{
    CError err = GetServiceVersion();
    if (err.Succeeded())
    {
        CComAuthInfo auth;
        CMetaKey mk(&auth, m_szMeta, METADATA_PERMISSION_READ);
	    do
	    {
		    err = mk.QueryResult();
		    BREAK_ON_ERR_FAILURE(err);

		    err = mk.QueryValue(MD_LOGFILE_PERIOD, m_int_period);
		    BREAK_ON_ERR_FAILURE(err);
		    err = mk.QueryValue(MD_LOGFILE_TRUNCATE_SIZE, m_dword_filesize);
		    BREAK_ON_ERR_FAILURE(err);
		    m_dword_filesize /= SIZE_MBYTE;
		    if ( (m_dword_filesize > MAX_LOGFILE_SIZE) && (m_int_period == MD_LOGFILE_PERIOD_NONE) )
		    {
			    m_int_period = MD_LOGFILE_PERIOD_UNLIMITED;
			    m_dword_filesize = 512;
		    }
		    err = mk.QueryValue(MD_LOGFILE_DIRECTORY, m_sz_directory);
		    BREAK_ON_ERR_FAILURE(err);
		    if (m_fShowLocalTimeCheckBox)
		    {
			    m_wndUseLocalTime.ShowWindow(SW_SHOW);
			    if ((MD_LOGFILE_PERIOD_NONE == m_int_period) || (MD_LOGFILE_PERIOD_UNLIMITED == m_int_period))
			    {
				    m_wndUseLocalTime.EnableWindow(FALSE);
			    }
			    err = mk.QueryValue(MD_LOGFILE_LOCALTIME_ROLLOVER, m_fUseLocalTime);
			    if (err.Failed())
			    {
				    err.Reset();
			    }
		    }
		    UpdateData( FALSE );
		    UpdateDependants();
		    UpdateSampleFileString();
		    m_cbttn_browse.EnableWindow(m_fLocalMachine);
			m_cspin_spin.SetRange32(0, MAX_LOGFILE_SIZE);
			m_cspin_spin.SetPos(m_dword_filesize);
	    } while (FALSE);
    }
#if defined(_DEBUG) || DBG
	err.MessageBoxOnFailure();
#endif
}

//--------------------------------------------------------------------------
void CLogGeneral::UpdateDependants() 
{
    UpdateData();

    BOOL fEnable = (m_int_period == MD_LOGFILE_PERIOD_MAXSIZE);
    m_cspin_spin.EnableWindow(fEnable);
    m_cstatic_units.EnableWindow(fEnable);
    m_cedit_size.EnableWindow(fEnable);
}
    
//--------------------------------------------------------------------------
// update the sample file stirng
void CLogGeneral::UpdateSampleFileString()
    {
    CString szSample;

    UpdateData( TRUE );


    // ok first we have to generate a string to show what sub-node the logging stuff
    // is going to go into. This would be of the general form of the name of the server
    // followed by the virtual node of the server. Example: LM/W3SVC/1 would
    // become "W3SVC1/example" Unfortunately, all we have to build this thing out of
    // is the target metabase path. So we strip off the preceding LM/. Then we find the
    // next / character and take the number that follows it. If we are editing the 
    // master root properties then there will be no slash/number at the end at which point
    // we can just append a capital X character to signifiy this. The MMC is currently set
    // up to only show the logging properties if we are editing the master props or a virtual
    // server, so we shouldn't have to worry about stuff after the virtual server number

    // get rid of the preceding LM/ (Always three characters)
    m_sz_filesample = m_szMeta.Right( m_szMeta.GetLength() - 3 );

    // Find the location of the '/' character
    INT     iSlash = m_sz_filesample.Find( _T('/') );

    // if there was no last slash, then append the X, otherwise append the number
    if ( iSlash < 0 )
        {
        m_sz_filesample += _T('X');
        }
    else
        {
        m_sz_filesample = m_sz_filesample.Left(iSlash) +
                    m_sz_filesample.Right( m_sz_filesample.GetLength() - (iSlash+1) );
        }

    // add a final path type slash to signify that it is a partial path
    m_sz_filesample += _T('\\');

    // build the sample string
    switch( m_int_period )
        {
        case MD_LOGFILE_PERIOD_MAXSIZE:
            m_sz_filesample += szSizePrefix;
            szSample.LoadString( IDS_LOG_SIZE_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_DAILY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_DAILY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_WEEKLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_WEEKLY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_MONTHLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_MONTHLY_FILESAMPLE );
            break;
        case MD_LOGFILE_PERIOD_HOURLY:
            m_sz_filesample += szPrefix;
            szSample.LoadString( IDS_LOG_HOURLY_FILE_SAMPLE );
            break;
        case MD_LOGFILE_PERIOD_UNLIMITED:
            m_sz_filesample += szSizePrefix;
            szSample.LoadString( IDS_LOG_UNLIMITED_FILESAMPLE );
            break;
        };

    // add the two together
    m_sz_filesample += szSample;

    // update the display
    UpdateData( FALSE );
    }

/////////////////////////////////////////////////////////////////////////////
// CLogGeneral message handlers

//--------------------------------------------------------------------------
BOOL CLogGeneral::OnSetActive() 
{
    // if this is the first time, inititalize the dialog
    if (!m_fInitialized)
    {
        Init();
        m_fInitialized = TRUE;
    }
    return CPropertyPage::OnSetActive();
}

//--------------------------------------------------------------------------
BOOL CLogGeneral::OnApply() 
{
    if (m_fIsModified)
    {
		UpdateData();
		if (!PathIsValid(m_sz_directory))
		{
			AfxMessageBox(IDS_NEED_DIRECTORY);
			return FALSE;
		}
        if (m_fLocalMachine)
        {
		    CString expanded;
		    ExpandEnvironmentStrings(m_sz_directory, expanded.GetBuffer(MAX_PATH), MAX_PATH);
		    if (PathIsNetworkPath(expanded))
		    {
                if (m_dwVersionMajor < 6)
                {
			        AfxMessageBox(IDS_REMOTE_NOT_SUPPORTED);
			        return FALSE;
                }
                goto Verified;
		    }
		    if (PathIsRelative(expanded))
		    {
			    AfxMessageBox(IDS_NO_RELATIVE_PATH);
			    return FALSE;
		    }
		    if (!PathIsDirectory(expanded))
		    {
			    AfxMessageBox(IDS_NOT_DIR_EXIST);
			    return FALSE;
		    }
        }
Verified:
		CComAuthInfo auth;
		CError err;
		CList<DWORD, DWORD> mdlist;
		do
		{
			CMetaKey mk(&auth, m_szMeta, METADATA_PERMISSION_WRITE);
			err = mk.QueryResult();
			BREAK_ON_ERR_FAILURE(err);
			err = mk.SetValue(MD_LOGFILE_PERIOD, 
					m_int_period == MD_LOGFILE_PERIOD_UNLIMITED ? MD_LOGFILE_PERIOD_NONE : m_int_period);
			BREAK_ON_ERR_FAILURE(err);
			mdlist.AddTail(MD_LOGFILE_PERIOD);
			err = mk.SetValue(MD_LOGFILE_TRUNCATE_SIZE, 
					m_int_period == MD_LOGFILE_PERIOD_UNLIMITED ? 0xFFFFFFFF : m_dword_filesize * SIZE_MBYTE);
			BREAK_ON_ERR_FAILURE(err);
			mdlist.AddTail(MD_LOGFILE_TRUNCATE_SIZE);
			err = mk.SetValue(MD_LOGFILE_DIRECTORY, m_sz_directory);
			BREAK_ON_ERR_FAILURE(err);
			mdlist.AddTail(MD_LOGFILE_DIRECTORY);
			if (m_fShowLocalTimeCheckBox)
			{
				err = mk.SetValue(MD_LOGFILE_LOCALTIME_ROLLOVER, m_fUseLocalTime);
				BREAK_ON_ERR_FAILURE(err);
				mdlist.AddTail(MD_LOGFILE_LOCALTIME_ROLLOVER);
			}
		} while(FALSE);
		// Check inheritance
		if (!mdlist.IsEmpty())
		{
			POSITION pos = mdlist.GetHeadPosition();
			while (pos)
			{
				DWORD id = mdlist.GetNext(pos);
				{
					CInheritanceDlg dlg(id, TRUE, &auth, m_szMeta);
					if (!dlg.IsEmpty())
					{
						dlg.DoModal();
					}
				}
			}
		}
	}
    return CPropertyPage::OnApply();
}

//--------------------------------------------------------------------------

static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CLogGeneral * pThis = (CLogGeneral *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CLogGeneral::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   BOOL bNetwork;
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      bNetwork = ::PathIsNetworkPath(m_pPathTemp);
      if (m_dwVersionMajor >= 6 && bNetwork)
         return 0;
      if (m_fLocalMachine && !bNetwork)
      {
          while (!::PathIsDirectory(m_pPathTemp))
          {
             if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
             {
                return 0;
             }
             DWORD attr = GetFileAttributes(m_pPathTemp);
             if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
                break;
          }
          ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      }
      break;
   case BFFM_SELCHANGED:
   {
      LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
      TCHAR path[MAX_PATH];
      if (SHGetPathFromIDList(pidl, path))
      {
		 LPTSTR pPrefix = NULL;
	     if (m_dwVersionMajor >= 6 && PathCommonPrefix(m_NetHood, path, pPrefix))
		 {
			::SendMessage(hwnd, BFFM_ENABLEOK, 0, FALSE);
		 }
         if (m_dwVersionMajor < 6)
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
	  else
	  {
         ::SendMessage(hwnd, BFFM_ENABLEOK, 0, FALSE);
	  }
   }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}


void CLogGeneral::OnBrowse()
{
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_cedit_directory.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      int csidl = m_dwVersionMajor >= 6 ? CSIDL_DESKTOP : CSIDL_DRIVES;
      if (SUCCEEDED(SHGetFolderLocation(NULL, csidl, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = NULL;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE;
         if (m_dwVersionMajor < 6)
         {
            bi.ulFlags |= BIF_RETURNONLYFSDIRS;
         }
         else
         {
             bi.ulFlags |= BIF_SHAREABLE;
         }
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

		 // Get NetHood folder location
		 SHGetFolderPath(NULL, CSIDL_NETHOOD, NULL, SHGFP_TYPE_CURRENT, m_NetHood.GetBuffer(MAX_PATH));
		 m_NetHood.ReleaseBuffer();

         pidList = SHBrowseForFolder(&bi);
         if (pidList != NULL && SHGetPathFromIDList(pidList, buf))
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_cedit_directory.SetWindowText(str);
   }
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogDaily() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogMonthly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogWhensize() 
{
    m_wndUseLocalTime.EnableWindow(FALSE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogUnlimited() 
{
    m_wndUseLocalTime.EnableWindow(FALSE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogWeekly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnLogHourly() 
{
    m_wndUseLocalTime.EnableWindow(TRUE);
    UpdateDependants();
    UpdateSampleFileString();
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnChangeLogDirectory() 
{
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnChangeLogSize() 
{
    SetModified();
    m_fIsModified = TRUE;
}

//--------------------------------------------------------------------------
void CLogGeneral::OnUseLocalTime() 
{
    SetModified();
    m_fIsModified = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logui.cpp ===
// logui.cpp : Implementation of CLoguiApp and DLL registration.

#include "stdafx.h"
#include "logui.h"

#include "wrapmb.h"
#include <iiscnfg.h>
#include <iiscnfgp.h>
#include <inetinfo.h>

#include "initguid.h"
#include <logtype.h>
#include <ilogobj.hxx>

#include "uincsa.h"
#include "uiextnd.h"
#include "uimsft.h"
#include "uiodbc.h"

#include "dcomperm.h"

//_tlid


// the global factory objects
CFacNcsaLogUI       facNcsa;
CFacMsftLogUI       facMsft;
CFacOdbcLogUI       facOdbc;
CFacExtndLogUI      facExtnd;


const GUID CDECL BASED_CODE _tlid =
		{ 0x31dcab8a, 0xbb3e, 0x11d0, { 0x92, 0x99, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;

// the key type strings for the metabaes keys
#define SZ_LOGGING_MAIN_TYPE    _T("IIsLogModules")
#define SZ_LOGGING_TYPE         _T("IIsLogModule")

BOOL _cdecl RegisterInMetabase( PWCHAR pszMachine );

int SetInfoAdminACL( CWrapMetaBase* pMB, LPCTSTR szSubKeyPath );

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CLoguiApp NEAR theApp;

HINSTANCE	g_hInstance = NULL;



//---------------------------------------------------------------
void CLoguiApp::PrepHelp( OLECHAR* pocMetabasePath )
    {
    // figure out the correct help file to use
    CString szMetaPath = pocMetabasePath;
    szMetaPath.MakeLower();

    // default to the w3 help
    UINT    iHelp = IDS_HELPLOC_W3SVCHELP;

    // test for ftp
    if ( szMetaPath.Find(_T("msftpsvc")) >= 0 )
        iHelp = IDS_HELPLOC_FTPHELP;

    // finally, we need to redirect the winhelp file location to something more desirable
    CString sz;
    CString szHelpLocation;
    sz.LoadString( iHelp );

    // expand the path
    ExpandEnvironmentStrings(
        sz,	                                        // pointer to string with environment variables 
        szHelpLocation.GetBuffer(MAX_PATH + 1),   // pointer to string with expanded environment variables  
        MAX_PATH                                    // maximum characters in expanded string 
       );
    szHelpLocation.ReleaseBuffer();

    // free the existing path, and copy in the new one
    if ( m_pszHelpFilePath )
        free((void*)m_pszHelpFilePath);
    m_pszHelpFilePath = _tcsdup(szHelpLocation);
    }


////////////////////////////////////////////////////////////////////////////
// CLoguiApp::InitInstance - DLL initialization

BOOL CLoguiApp::InitInstance()
    {
    g_hInstance = m_hInstance;
	BOOL bInit = COleControlModule::InitInstance();

   InitCommonDll();

	if (bInit)
	    {
        CString sz;
        // set the name of the application correctly
        sz.LoadString( IDS_LOGUI_ERR_TITLE );
        // Never free this string because now MF...kingC
		// uses it internally BEFORE call to this function
        //free((void*)m_pszAppName);
        m_pszAppName = _tcsdup(sz);
	    }

	return bInit;
    }

////////////////////////////////////////////////////////////////////////////
// CLoguiApp::ExitInstance - DLL termination

int CLoguiApp::ExitInstance()
    {
    return COleControlModule::ExitInstance();
    }


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

    // intialize the metabase /logging tree
    if ( !RegisterInMetabase( NULL ) )
        return GetLastError();

	return NOERROR;
    }


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
    {
	AFX_MANAGE_STATE(_afxModuleAddrThis);

//	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
//		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
    }


//-------------------------------------------------------------------------
// add all the base logging info to the /LM portion of the tree Also, add in
// the ftp and w3 service logging load strings
BOOL _cdecl RegisterInMetabase( PWCHAR pszMachine )
    {
    CString         sz;
    BOOL            f;
    DWORD           dw;
    BOOL            fODBCW3 = FALSE;
    BOOL            fODBCFTP = FALSE;
    DWORD           fAnswer = FALSE;
    CString         szAvail;
    CWrapMetaBase   mbWrap;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prep the metabase - during install we always target the local machine
    IMSAdminBase * pMB = NULL;
    if (!FInitMetabaseWrapperEx( pszMachine, &pMB ))
        {
        goto CLEANUP_RES;
        }
    if ( !mbWrap.FInit(pMB) )
        {
        goto CLEANUP_RES;
        }

    // first, we will add the basic tree to the metabase
    // start with the bottom item
    // open the target
    if ( !mbWrap.Open( _T("/lm"), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
        {
        goto CLEANUP_RES;
        }

    // test to see if we can do odbc logging
    if ( mbWrap.GetDword( _T("/w3svc/Info"), MD_SERVER_CAPABILITIES, IIS_MD_UT_SERVER, &dw ) )
        fODBCW3 = (dw & IIS_CAP1_ODBC_LOGGING) > 0;
    if ( mbWrap.GetDword( _T("/MSFTPSVC/Info"), MD_SERVER_CAPABILITIES, IIS_MD_UT_SERVER, &dw ) )
        fODBCFTP = (dw & IIS_CAP1_ODBC_LOGGING) > 0;

    // we shouldn't tie up the /lm object, so close it and open logging
    mbWrap.Close();

    // open the logging object
    if ( !mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_WRITE ) )
        {
        // the logging node doesn't exist. Create it
        if ( !mbWrap.Open( _T("/lm"), METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
            goto CLEANUP_RES;

        // add the logging object
        if ( mbWrap.AddObject(_T("logging")) )
            {
            // add the ACL to the node
            SetInfoAdminACL( &mbWrap, _T("logging") );
            }

        // we shouldn't tie up the /lm object, so close it and open logging
        mbWrap.Close();            

        // open the logging object
        if ( !mbWrap.Open( _T("/lm/logging"), METADATA_PERMISSION_WRITE ) )
            goto CLEANUP_RES;
        }

    // set the logging key type
    mbWrap.SetString( _T(""), MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_MAIN_TYPE, 0 );

    // add ncsa first
    sz.LoadString( IDS_MTITLE_NCSA );
    if ( mbWrap.AddObject( sz ) )
        {
        // set the key type
        mbWrap.SetString( sz, MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_TYPE, 0 );
        // add the logging module's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, NCSALOG_CLSID );
        // add the logging ui's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, NCSALOGUI_CLSID );
        }

    // add odbc logging
    sz.LoadString( IDS_MTITLE_ODBC );
    if ( (fODBCW3 || fODBCFTP) && mbWrap.AddObject( sz ) )
        {
        // set the key type
        mbWrap.SetString( sz, MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_TYPE, 0 );
        // add the logging module's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, ODBCLOG_CLSID );
        // add the logging ui's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, ODBCLOGUI_CLSID );
        }

    // add microsoft logging
    sz.LoadString( IDS_MTITLE_MSFT );
    if ( mbWrap.AddObject( sz ) )
        {
        // set the key type
        mbWrap.SetString( sz, MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_TYPE, 0 );
        // add the logging module's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, ASCLOG_CLSID );
        // add the logging ui's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, ASCLOGUI_CLSID );
        }

    // add extended logging
    sz.LoadString( IDS_MTITLE_XTND );
    if ( mbWrap.AddObject( sz ) )
        {
        // set the key type
        mbWrap.SetString( sz, MD_KEY_TYPE, IIS_MD_UT_SERVER, SZ_LOGGING_TYPE, 0 );
        // add the logging module's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, EXTLOG_CLSID );
        // add the logging ui's guid string
        f = mbWrap.SetString( sz, MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, EXTLOGUI_CLSID );
        }

    // close the wrapper
    mbWrap.Close();

    // prepare the available logging extensions string
    // start with w3svc
    sz.LoadString( IDS_MTITLE_NCSA );
    szAvail = sz;
    sz.LoadString( IDS_MTITLE_MSFT );
    szAvail += _T(',') + sz;
    sz.LoadString( IDS_MTITLE_XTND );
    szAvail += _T(',') + sz;
    if ( fODBCW3 )
        {
        sz.LoadString( IDS_MTITLE_ODBC );
        szAvail += _T(',') + sz;
        }
    // save the string
    if ( mbWrap.Open( _T("/lm/w3svc/Info"), METADATA_PERMISSION_WRITE ) )
        {
        f = mbWrap.SetString( _T(""), MD_LOG_PLUGINS_AVAILABLE, IIS_MD_UT_SERVER, szAvail );
        // close the wrapper
        mbWrap.Close();
        }

    // now ftp - no ncsa
    sz.LoadString( IDS_MTITLE_MSFT );
    szAvail = sz;
    sz.LoadString( IDS_MTITLE_XTND );
    szAvail += _T(',') + sz;
    if ( fODBCFTP )
        {
        sz.LoadString( IDS_MTITLE_ODBC );
        szAvail += _T(',') + sz;
        }
    // save the string
    if ( mbWrap.Open( _T("/lm/msftpsvc/Info"), METADATA_PERMISSION_WRITE ) )
        {
        f = mbWrap.SetString( _T(""), MD_LOG_PLUGINS_AVAILABLE, IIS_MD_UT_SERVER, szAvail );
        // close the wrapper
        mbWrap.Close();
        }

    // close the metabase wrappings
    FCloseMetabaseWrapperEx(&pMB);
    fAnswer = TRUE;

CLEANUP_RES:

    // we want to be able to recover a meaningful error, so get it and set it again after
    // restoring the resource handle
    DWORD   err = GetLastError();

	// restore the resources
    if ( hOldRes )
	    AfxSetResourceHandle( hOldRes );

    // reset the error code
    SetLastError( err );

    // return the error - hopefully success
    return fAnswer;
    }


//-------------------------------------------------------------------------
int SetInfoAdminACL( CWrapMetaBase* pMB, LPCTSTR szSubKeyPath )
{
    int retCode=-1;
    BOOL b = FALSE;
    DWORD dwLength = 0;

    PSECURITY_DESCRIPTOR pSD = NULL;
    PSECURITY_DESCRIPTOR outpSD = NULL;
    DWORD cboutpSD = 0;
    PACL pACLNew = NULL;
    DWORD cbACL = 0;
    PSID pAdminsSID = NULL, pEveryoneSID = NULL;
    BOOL bWellKnownSID = FALSE;

    // Initialize a new security descriptor
    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
    if (NULL == pSD)
       goto Cleanup;
    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

    // Get Local Admins Sid
    GetPrincipalSID (_T("Administrators"), &pAdminsSID, &bWellKnownSID);

    // Get everyone Sid
    GetPrincipalSID (_T("Everyone"), &pEveryoneSID, &bWellKnownSID);

    // Initialize a new ACL, which only contains 2 aaace
    cbACL = sizeof(ACL) + 
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminsSID) - sizeof(DWORD)) + 
        (sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pEveryoneSID) - sizeof(DWORD)) ;
    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if (NULL == pACLNew)
       goto Cleanup;
    InitializeAcl(pACLNew, cbACL, ACL_REVISION);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        (MD_ACR_READ |
        MD_ACR_WRITE |
        MD_ACR_RESTRICTED_WRITE |
        MD_ACR_UNSECURE_PROPS_READ |
        MD_ACR_ENUM_KEYS |
        MD_ACR_WRITE_DAC),
        pAdminsSID);

    AddAccessAllowedAce(
        pACLNew,
        ACL_REVISION,
        (MD_ACR_READ | MD_ACR_ENUM_KEYS),
        pEveryoneSID);

    // Add the ACL to the security descriptor
    b = SetSecurityDescriptorDacl(pSD, TRUE, pACLNew, FALSE);
    b = SetSecurityDescriptorOwner(pSD, pAdminsSID, TRUE);
    b = SetSecurityDescriptorGroup(pSD, pAdminsSID, TRUE);

    // Security descriptor blob must be self relative
    if (!MakeSelfRelativeSD(pSD, outpSD, &cboutpSD))
       goto Cleanup;
    outpSD = (PSECURITY_DESCRIPTOR)GlobalAlloc(GPTR, cboutpSD);
    if (NULL == outpSD)
       goto Cleanup;
    if (!MakeSelfRelativeSD( pSD, outpSD, &cboutpSD ))
       goto Cleanup;

    // below this modify pSD to outpSD

    // Apply the new security descriptor to the file
    dwLength = GetSecurityDescriptorLength(outpSD);


    // set the acl into the metabase at the given location
    b = pMB->SetData( szSubKeyPath, MD_ADMIN_ACL, IIS_MD_UT_SERVER, BINARY_METADATA,
                    (LPBYTE)outpSD, dwLength,
                    METADATA_INHERIT | METADATA_REFERENCE | METADATA_SECURE );

   retCode = 0;

Cleanup:
  // both of Administrators and Everyone are well-known SIDs, use FreeSid() to free them.
  if (outpSD)
     GlobalFree(outpSD);
  if (pAdminsSID)
    FreeSid(pAdminsSID);
  if (pEveryoneSID)
    FreeSid(pEveryoneSID);
  if (pSD)
    LocalFree((HLOCAL) pSD);
  if (pACLNew)
    LocalFree((HLOCAL) pACLNew);

  return (retCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\logui.h ===
// logui.h : main header file for LOGUI.DLL

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#define _COMIMPORT

#include "resource.h"       // main symbols
#include <common.h>       // common properties symbols
#include "helpmap.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CLoguiApp : See logui.cpp for implementation.

class CLoguiApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
    void PrepHelp( OLECHAR* pocMetabasePath );
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;


//    ..\wrapmb\obj\*\wrapmb.lib \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\metatool.h ===
class CCheckInheritList;

BOOL OpenAndCreate( CWrapMetaBase* pmb, LPCTSTR pszTarget, DWORD perm, BOOL fCreate );

BOOL SetMetaDword(IMSAdminBase* pIMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue, BOOL fCheckInheritence);
BOOL SetMetaString(IMSAdminBase* pIMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fCheckInheritence, BOOL fSecure);
BOOL SetMetaData(IMSAdminBase* pIMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fCheckInheritence, BOOL fSecure );
BOOL SetMetaMultiSz(IMSAdminBase* pIMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz, BOOL fCheckInheritence );


BOOL SetMBDword(CWrapMetaBase* pMB,
                CCheckInheritList* pInheritList,
                LPCTSTR pszSub,
                DWORD idData,
                DWORD iType,
                DWORD dwValue);

BOOL SetMBString(CWrapMetaBase* pMB,
                CCheckInheritList* pInheritList,
                LPCTSTR pszSub,
                DWORD idData,
                DWORD iType,
                CString sz,
                BOOL fSecure);

BOOL SetMBData(CWrapMetaBase* pMB,
                CCheckInheritList* pInheritList,
                LPCTSTR pszSub,
                DWORD idData,
                DWORD iType,
                DWORD iDataType,
                PVOID pData,
                DWORD cbData,
                BOOL fSecure );

BOOL SetMBMultiSz(CWrapMetaBase* pMB,
                CCheckInheritList* pInheritList,
                LPCTSTR pszSub,
                DWORD idData,
                DWORD iType,
                PVOID pData,
                DWORD cchmsz );




//-------------------------------------------------------------
class CCheckInheritList : public CObject
    {
public:
    // do the check on all the members of the check array
    void CheckInheritence( LPCTSTR pszServer, LPCTSTR pszInheritRoot );

    // add an item to check
    INT Add( DWORD dwMDIdentifier, DWORD dwMDDataType, DWORD dwMDUserType, DWORD dwMDAttributes );

protected:
    //--------------------------
    typedef struct _INHERIT_CHECK_ITEM
    {
        DWORD   dwMDIdentifier;
        DWORD   dwMDDataType;
        DWORD   dwMDUserType;
        DWORD   dwMDAttributes;

    }   INHERIT_CHECK_ITEM, *PINHERIT_CHECK_ITEM;

    // the array of items
    CArray< INHERIT_CHECK_ITEM, INHERIT_CHECK_ITEM>    rgbItems;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\msftppg.cpp ===
// MsftPpg.cpp : Implementation of the CMsftPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "MsftPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CMsftPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMsftPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CMsftPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CMsftPropPage, "LOGUI.MsftPropPage.1",
	0x68871e52, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::CMsftPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CMsftPropPage

BOOL CMsftPropPage::CMsftPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_MSFT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::CMsftPropPage - Constructor

CMsftPropPage::CMsftPropPage() :
	COlePropertyPage(IDD, IDS_MSFT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CMsftPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage::DoDataExchange - Moves data between page and properties

void CMsftPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CMsftPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CMsftPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\metatool.cpp ===
// metatool.cpp : implementation file
//

// some common tools used for "smart" writing to the metabase

#include "stdafx.h"

#define _COMIMPORT
#include <common.h>
#include <idlg.h>
#include <resource.h>
#include "wrapmb.h"
#include "metatool.h"


//----------------------------------------------------------------
// open the metabase with an option to create the directory if it doesn't
// exist. It would be nice to move this into wrapmb, but that is too big
// a change for now. Maybe we can do that later.
BOOL OpenAndCreate( CWrapMetaBase* pmb, LPCTSTR pszTarget, DWORD perm, BOOL fCreate )
    {
    BOOL    f;
    CString szTarget = pszTarget;

    // start by just trying to open it. easy easy.
    if ( pmb->Open(szTarget, perm) )
        return TRUE;

    // if requested, try to create the key if it doesn't exist
    if ( fCreate )
        {
        // find the nearest openable parent directory and open it
        CString szPartial;
        CString szBase = szTarget;
        do
            {
            szBase = szBase.Left( szBase.ReverseFind(_T('/')) );
            szPartial = szTarget.Right( szTarget.GetLength() - szBase.GetLength() - 1 );
            f = pmb->Open( szBase, METADATA_PERMISSION_WRITE | perm );
            } while (!f && !szBase.IsEmpty());

        // if all that failed, fail
        if ( !f ) return FALSE;

        // create the key that we really want
        f = pmb->AddObject( szPartial );
        pmb->Close();

        // if all that failed, fail
        if ( !f ) return FALSE;

        // try again
        if ( pmb->Open(szTarget, perm) )
            return TRUE;
        }

    // total washout
    return FALSE;
    }

//----------------------------------------------------------------
// starting at the root, check for values set on sub-keys that may need to be overridden
// and propmt the user for what to do
void CheckInheritence( LPCTSTR pszServer, LPCTSTR pszInheritRoot, 
                       DWORD dwMDIdentifier, 
                       DWORD dwMDDataType, 
                       DWORD dwMDUserType = IIS_MD_UT_SERVER, 
                       DWORD dwMDAttributes = METADATA_INHERIT)
    {

    //
    // Build a generic title in case this property is custom
    //

    CString strTitle;
    strTitle.Format(IDS_GENERIC_INHERITANCE_TITLE, dwMDIdentifier);

    CComAuthInfo auth(pszServer);
    CInheritanceDlg dlgInherit(
                            TRUE,       // Look in table first
                            dwMDIdentifier,
                            dwMDAttributes,
                            dwMDUserType,
                            dwMDDataType,   
                            strTitle,
                            FROM_WRITE_PROPERTY,
                            &auth,
                            pszInheritRoot
                    );

    // if it worked, then run the dialog
    if ( !dlgInherit.IsEmpty() )
        dlgInherit.DoModal();
   }

// notice that the dwords and generic blobs are handled seperately even though
// we count route the dwords through the blob mechanisms. This is done for two
// reasone. 1) Handling dwords is much more efficient than handling blobs.
// and 2) Most of the values are dwords.

//----------------------------------------------------------------
// opens the metabase, writes out the value, then uses the inheritence
// checking functionality from the iisui.dll to check for the inherited
// properties and propt the user for what to do
BOOL SetMetaDword(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue, BOOL fCheckInheritence)
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   dword;

    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mbWrap, pszMetaRoot, 
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // attempt to get the current value - no inheritence
        if ( mbWrap.GetDword(pszSub, idData, iType, &dword, 0) )
            {
            // set the changed flag
            fChanged = (dwValue != dword);
            }

        // save it out, if it changed or is not there
        if ( fChanged )
            fAnswer = mbWrap.SetDword( pszSub, idData, iType, dwValue );

        // close the metabase
        mbWrap.Close();
        }
    else
        fChanged = FALSE;
  
    // set up and run the inheritence checking dialog
    if ( fCheckInheritence && fChanged )
        {
        CString szInheritRoot = pszMetaRoot;
        szInheritRoot += pszSub;
        CheckInheritence( pszServer, szInheritRoot, idData, DWORD_METADATA, iType);
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
// assumes that the metabase is actually open to the parent of the one we are interested
// and that the real target name is passed into szSub
BOOL SetMetaData(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fCheckInheritence, BOOL fSecure )
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   cbTestData;
    DWORD   flags = METADATA_INHERIT;

    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit(pMB) ) return FALSE;

      // open the target
    if ( OpenAndCreate( &mbWrap, pszMetaRoot,
            METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ, TRUE ) )
        {
        // attempt to get the current value - no inheritence
        PVOID pTestData = mbWrap.GetData( pszSub, idData, iType,
                            iDataType, &cbTestData, 0 );
        if ( pTestData )
            {
            // set the changed flag
            if ( cbData == cbTestData )
                {
                fChanged = (memcmp(pData, pTestData, cbData) != 0);
                }            
            mbWrap.FreeWrapData( pTestData );
            }

        // set security if requested
        if ( fSecure )
            flags |= METADATA_SECURE;

        // save it out, if it changed or is not there
        if ( fChanged )
            fAnswer = mbWrap.SetData( pszSub, idData, iType, iDataType, pData, cbData, flags );

        // close the metabase
        mbWrap.Close();
        }
    else
        fChanged = FALSE;

    // set up and run the inheritence checking dialog
    if ( fCheckInheritence && fChanged )
        {
        CString szInheritRoot = pszMetaRoot;
        szInheritRoot += pszSub;
        CheckInheritence( pszServer, szInheritRoot, idData , iDataType, iType);
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
BOOL SetMetaString(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fCheckInheritence, BOOL fSecure)
    {
    return SetMetaData(pMB, pszServer, pszMetaRoot, pszSub, idData,
            iType, STRING_METADATA, (LPTSTR)(LPCTSTR)sz,
            (sz.GetLength()+1)*sizeof(TCHAR), fCheckInheritence, fSecure );
    }

//----------------------------------------------------------------
BOOL SetMetaMultiSz(IMSAdminBase* pMB, LPCTSTR pszServer, LPCTSTR pszMetaRoot, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz, BOOL fCheckInheritence )
    {
    return SetMetaData(pMB, pszServer, pszMetaRoot, pszSub, idData,
            iType, MULTISZ_METADATA, pData, cchmsz*2, fCheckInheritence, FALSE );
    }










//----------------------------------------------------------------
BOOL SetMBData(CWrapMetaBase* pMB, CCheckInheritList* pInheritList, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD iDataType, PVOID pData, DWORD cbData, BOOL fSecure )
    {
    BOOL    fAnswer = FALSE;
    BOOL    fChanged = TRUE;
    DWORD   cbTestData;
    DWORD   flags = METADATA_INHERIT;

    // attempt to get the current value - no inheritence
    PVOID pTestData = pMB->GetData( pszSub, idData, iType,
                        iDataType, &cbTestData, 0 );
    if ( pTestData )
        {
        // set the changed flag
        if ( cbData == cbTestData )
            {
            fChanged = (memcmp(pData, pTestData, cbData) != 0);
            }            
        pMB->FreeWrapData( pTestData );
        }

    // set security if requested
    if ( fSecure )
        flags |= METADATA_SECURE;

    // save it out, if it changed or is not there
    if ( fChanged )
        {
        fAnswer = pMB->SetData( pszSub, idData, iType, iDataType, pData, cbData, flags );
        }
        
    // add it to the change list
    if ( pInheritList && fChanged && fAnswer )
        {
        // prep the inheritence check record
        pInheritList->Add( idData, iDataType, iType, flags );
        }
    
    return fAnswer;
    }

//----------------------------------------------------------------
BOOL SetMBDword(CWrapMetaBase* pMB, CCheckInheritList* pInheritList, LPCTSTR pszSub, DWORD idData, DWORD iType, DWORD dwValue)
    {
    return SetMBData(pMB, pInheritList, pszSub, idData,
            iType, DWORD_METADATA, &dwValue,
           sizeof(DWORD), FALSE );
    }

//----------------------------------------------------------------
BOOL SetMBString(CWrapMetaBase* pMB, CCheckInheritList* pInheritList, LPCTSTR pszSub, DWORD idData, DWORD iType, CString sz, BOOL fSecure)
    {
    return SetMBData(pMB, pInheritList, pszSub, idData,
            iType, STRING_METADATA, (LPTSTR)(LPCTSTR)sz,
            (sz.GetLength()+1)*sizeof(TCHAR), fSecure );
    }

//----------------------------------------------------------------
BOOL SetMBMultiSz(CWrapMetaBase* pMB, CCheckInheritList* pInheritList, LPCTSTR pszSub, DWORD idData, DWORD iType, PVOID pData, DWORD cchmsz )
    {
    return SetMBData(pMB, pInheritList, pszSub, idData,
            iType, MULTISZ_METADATA, pData, cchmsz*2, FALSE );
    }






//-------------------------------------------------------------
void CCheckInheritList::CheckInheritence( LPCTSTR pszServer, LPCTSTR pszInheritRoot )
    {
    // get the number of items to check
    DWORD   cItems = (DWORD)rgbItems.GetSize();

    // loop through the items, checking each
    for ( DWORD iItem = 0; iItem < cItems; iItem++ )
        {
        // check the inheritence on the item
        ::CheckInheritence( pszServer, pszInheritRoot, 
                           rgbItems[iItem].dwMDIdentifier, 
                           rgbItems[iItem].dwMDDataType, 
                           rgbItems[iItem].dwMDUserType, 
                           rgbItems[iItem].dwMDAttributes );
        
        }
    }

//-------------------------------------------------------------
INT CCheckInheritList::Add( DWORD dwMDIdentifier, DWORD dwMDDataType, DWORD dwMDUserType, DWORD dwMDAttributes )
    {
    INHERIT_CHECK_ITEM  item;
    item.dwMDIdentifier = dwMDIdentifier;
    item.dwMDDataType = dwMDDataType;
    item.dwMDUserType = dwMDUserType;
    item.dwMDAttributes = dwMDAttributes;
    return (INT)rgbItems.Add( item );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\ncsappg.cpp ===
// NcsaPpg.cpp : Implementation of the CNcsaPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "NcsaPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CNcsaPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CNcsaPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CNcsaPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CNcsaPropPage, "LOGUI.NcsaPropPage.1",
	0x68871e46, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::CNcsaPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CNcsaPropPage

BOOL CNcsaPropPage::CNcsaPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_NCSA_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::CNcsaPropPage - Constructor

CNcsaPropPage::CNcsaPropPage() :
	COlePropertyPage(IDD, IDS_NCSA_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CNcsaPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage::DoDataExchange - Moves data between page and properties

void CNcsaPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CNcsaPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\ncsappg.h ===
// NcsaPpg.h : Declaration of the CNcsaPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CNcsaPropPage : See NcsaPpg.cpp.cpp for implementation.

class CNcsaPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CNcsaPropPage)
	DECLARE_OLECREATE_EX(CNcsaPropPage)

// Constructor
public:
	CNcsaPropPage();

// Dialog Data
	//{{AFX_DATA(CNcsaPropPage)
	enum { IDD = IDD_PROPPAGE_NCSA };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CNcsaPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\msftppg.h ===
// MsftPpg.h : Declaration of the CMsftPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// CMsftPropPage : See MsftPpg.cpp.cpp for implementation.

class CMsftPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CMsftPropPage)
	DECLARE_OLECREATE_EX(CMsftPropPage)

// Constructor
public:
	CMsftPropPage();

// Dialog Data
	//{{AFX_DATA(CMsftPropPage)
	enum { IDD = IDD_PROPPAGE_MSFT };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CMsftPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\odbcppg.cpp ===
// OdbcPpg.cpp : Implementation of the COdbcPropPage property page class.

#include "stdafx.h"
#include "logui.h"
#include "OdbcPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(COdbcPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(COdbcPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(COdbcPropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(COdbcPropPage, "LOGUI.OdbcPropPage.1",
	0x68871e4e, 0xba87, 0x11d0, 0x92, 0x99, 0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b)


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::COdbcPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for COdbcPropPage

BOOL COdbcPropPage::COdbcPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_ODBC_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::COdbcPropPage - Constructor

COdbcPropPage::COdbcPropPage() :
	COlePropertyPage(IDD, IDS_ODBC_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(COdbcPropPage)
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage::DoDataExchange - Moves data between page and properties

void COdbcPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(COdbcPropPage)
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// COdbcPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\uiextnd.h ===
#ifndef _EXTNDLOGUI_H_
#define _EXTNDLOGUI_H_


class CFacExtndLogUI : COleObjectFactory
    {
    public:
        CFacExtndLogUI();
        virtual BOOL UpdateRegistry( BOOL bRegister );
    };



class CExtndCreator : public CCmdTarget
    {
    DECLARE_DYNCREATE(CExtndCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
    };


class CImpExtndLogUI : public ILogUIPlugin
    {

    public:
        CImpExtndLogUI();
        ~CImpExtndLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath );

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    protected:
    private:
    ULONG m_dwRefCount;
    };  // CImpLogUI




#endif  // _EXTNDLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\uiextnd.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "wrapmb.h"
#include "logui.h"
#include "uiextnd.h"
#include "LogGenPg.h"
#include "LogExtPg.h"
#include "LogAdvPg.h"
#include "logtools.h"

//#include <inetprop.h>

#define OLE_NAME    _T("Extended_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc =
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;

extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacExtndLogUI::CFacExtndLogUI() :
        COleObjectFactory( CLSID_EXTLOGUI, RUNTIME_CLASS(CExtndCreator), TRUE, OLE_NAME )
    {
    }

//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit"),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\protocol\\StdFileEditing\\server\0") _T("%3"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacExtndLogUI::UpdateRegistry( BOOL bRegister )
    {
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_EXTLOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if (AfxOleRegisterServerClass(
				CLSID_EXTLOGUI,
				OLE_NAME,
				_T("LogUI extnd"),
				_T("LogUI extnd"),
				OAT_SERVER,
				(LPCTSTR *)rglpszServerRegister,
				(LPCTSTR *)rglpszServerOverwriteDLL
				)
			)
        {
            return FSetObjectApartmentModel( CLSID_EXTLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
    }


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(CExtndCreator, CCmdTarget)
LPUNKNOWN CExtndCreator::GetInterfaceHook(const void* piid)
    {
    return new CImpExtndLogUI;
    }

//====================== the action

//---------------------------------------------------------------
CImpExtndLogUI::CImpExtndLogUI():
        m_dwRefCount(0)
    {
//    guid = IID_LOGGINGUI;
    AfxOleLockApp();
    }

//---------------------------------------------------------------
CImpExtndLogUI::~CImpExtndLogUI()
    {
    AfxOleUnlockApp();
    }


//---------------------------------------------------------------
HRESULT CImpExtndLogUI::OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath )
    {
//    AFX_MANAGE_STATE(_afxModuleAddrThis);
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    // prepare the metabase wrapper
    IMSAdminBase * pMB;
    if ( !FInitMetabaseWrapperEx( pocMachineName, &pMB ) )
        return 0xFFFFFFFF;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    // Things could (potentially maybe) throw here, so better protect it.
    try
    {
        // declare the property sheet
        CPropertySheet  propsheet( IDS_SHEET_EXTND_TITLE );
        
        // declare the property pages
        CLogGeneral         pageLogGeneral;
        CLogAdvanced        pageLogAdvanced;
        CLogExtended        pageLogExtended;

        // prepare the common pages
        pageLogGeneral.m_pMB        = pMB;
        pageLogGeneral.m_szMeta     = pocMetabasePath;
        pageLogGeneral.m_szServer   = pocMachineName;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_EXTND_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_EXTND_PREFIX );

        // make the use local time checkbox visible
        pageLogGeneral.m_fShowLocalTimeCheckBox = TRUE;

        // set the local flag
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine( pocMachineName );

        // add the pages to the sheet and run
        propsheet.AddPage( &pageLogGeneral );

        // turn on help
        propsheet.m_psh.dwFlags         |= PSH_HASHELP;
        pageLogGeneral.m_psp.dwFlags    |= PSP_HASHELP;

        //
        // Extract the service name from the metabase path
        //

        // For /LM/W3SVC/1 scenario

        CString m_szServiceName(pocMetabasePath+3);
        
        m_szServiceName = m_szServiceName.Left( m_szServiceName.ReverseFind('/'));

        // For /LM/W3SVC scenario

        if (m_szServiceName.IsEmpty())
        {
            m_szServiceName = pocMetabasePath+3;
        }

        DWORD version;
		BOOL res;
		{
			CComAuthInfo auth(pocMachineName);
			CMetabasePath path(TRUE, m_szServiceName, SZ_MBN_INFO);
			CMetaKey mk(&auth, path);
			mk.QueryValue(MD_SERVER_VERSION_MAJOR, version);
			res = mk.Succeeded();
		}        
        if (res && (version > 4))
        {
            pageLogAdvanced.m_pMB           = pMB;
            pageLogAdvanced.m_szMeta        = pocMetabasePath;
            pageLogAdvanced.m_szServer      = pocMachineName;
            pageLogAdvanced.m_szServiceName = m_szServiceName;

            // add the pages to the sheet and run
            propsheet.AddPage( &pageLogAdvanced );

            // turn on help
            pageLogAdvanced.m_psp.dwFlags   |= PSP_HASHELP;
        }
        else
        {          
            pageLogExtended.m_pMB       = pMB;
            pageLogExtended.m_szMeta    = pocMetabasePath;
            pageLogExtended.m_szServer  = pocMachineName;

            // add the pages to the sheet and run
            propsheet.AddPage( &pageLogExtended );

            // turn on help
            pageLogExtended.m_psp.dwFlags   |= PSP_HASHELP;
        }

        propsheet.DoModal();
    }
    catch ( CException e )
    {
    }

    // close the metabase wrappings
    FCloseMetabaseWrapperEx(&pMB);

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
    }

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpExtndLogUI::QueryInterface(REFIID riid, void **ppObject)
    {
    if (riid==IID_IUnknown || riid==IID_LOGGINGUI || riid==CLSID_EXTLOGUI)
        {
        *ppObject = (ILogUIPlugin*) this;
        }
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NO_ERROR;
    }

//---------------------------------------------------------------
ULONG CImpExtndLogUI::AddRef()
    {
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
    }

//---------------------------------------------------------------
ULONG CImpExtndLogUI::Release()
    {
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

//#define INITGUID

#ifndef _UNICODE
#define _UNICODE
#endif

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
#include <afxdb.h>			// MFC database classes
#include <afxdao.h>			// MFC DAO database classes
#endif //_UNICODE

#include <afxcmn.h>			// MFC support for Windows Common Controls
#include <afxtempl.h>
#include <atlbase.h>

#include <aclapi.h>
#include <map>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\uimsft.h ===
#ifndef _MSFTLOGUI_H_
#define _MSFTLOGUI_H_


class CFacMsftLogUI : COleObjectFactory
    {
    public:
        CFacMsftLogUI();
//        virtual CCmdTarget* OnCreateObject( );
        virtual BOOL UpdateRegistry( BOOL bRegister );
    };



class CMsftCreator : public CCmdTarget
    {
    DECLARE_DYNCREATE(CMsftCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
    };


class CImpMsftLogUI : public ILogUIPlugin
    {

    public:
        CImpMsftLogUI();
        ~CImpMsftLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath );

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    protected:
    private:
    ULONG m_dwRefCount;
    };  // CImpMsftLogUI




#endif  // _MSFTLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by logui.rc
//
#define IDS_NCSA                        1
#define IDB_NCSA                        1
#define IDS_NCSA_PPG                    2
#define IDB_EXTND                       2
#define IDS_EXTND                       3
#define IDB_ODBC                        3
#define IDS_EXTND_PPG                   4
#define IDB_MSFT                        4
#define IDS_ODBC                        5
#define IDS_ODBC_PPG                    6
#define IDS_MSFT                        7
#define IDS_MSFT_PPG                    8
#define IDS_NCSA_PPG_CAPTION            100
#define IDD_PROPPAGE_NCSA               100
#define IDS_EXTND_PPG_CAPTION           101
#define IDD_PROPPAGE_EXTND              101
#define IDS_ODBC_PPG_CAPTION            102
#define IDD_PROPPAGE_ODBC               102
#define IDS_MSFT_PPG_CAPTION            103
#define IDD_PROPPAGE_MSFT               103
#define IDS_LOG_SHEETTITLE              104
#define IDS_LOG_INVALID_DIR             105
#define IDS_LOG_DAILY_FILESAMPLE        106
#define IDS_LOG_WEEKLY_FILESAMPLE       107
#define IDS_LOG_MONTHLY_FILESAMPLE      108
#define IDS_LOG_NCSA_PREFIX             109
#define IDS_GENERIC_INHERITANCE_TITLE   110
#define IDS_LOG_EXTND_PREFIX            111
#define IDS_LOG_MSFT_PREFIX             112
#define IDS_LOG_SIZE_FILESAMPLE         113
#define IDS_LOG_SIZE_NCSA_PREFIX        114
#define IDS_LOG_SIZE_EXTND_PREFIX       115
#define IDS_LOG_SIZE_MSFT_PREFIX        116
#define IDS_LOG_SIZE_NCSA_PREFIX4       117
#define IDS_MTITLE_NCSA                 118
#define IDS_MTITLE_ODBC                 119
#define IDS_MTITLE_MSFT                 120
#define IDS_MTITLE_XTND                 121
#define IDS_SHEET_NCSA_TITLE            122
#define IDS_SHEET_ODBC_TITLE            123
#define IDS_SHEET_MSFT_TITLE            124
#define IDS_SHEET_EXTND_TITLE           125
#define IDS_HELPLOC_W3SVCHELP           126
#define IDS_HELPLOC_FTPHELP             127
#define IDS_NEED_DIRECTORY              128
#define IDS_LOGUI_ERR_TITLE             129
#define IDS_SHOWN_PASSWORD              130
#define IDS_PASS_CONFIRM_FAIL           131
#define IDS_LOG_UNLIMITED_FILESAMPLE    132
#define IDS_LOG_HOURLY_FILE_SAMPLE      133
#define IDS_UNC_NOT_SUPPORTED           134
#define IDS_REMOTE_NOT_SUPPORTED        134
#define IDS_DATE		                135
#define IDS_TIME                        136
#define IDS_EXTENDED                    137
#define IDS_CLIENT                      138
#define IDS_USER                        139
#define IDS_SERVICE_NAME_T              140
#define IDS_SERVER_NAME_T               141
#define IDS_SERVER_IP                   142
#define IDS_SERVER_PORT                 143
#define IDS_METHOD                      144
#define IDS_URI_STEM                    145
#define IDS_URI_QUERY                   146
#define IDS_PROTOCOL                    147
#define IDS_WIN32                       148
#define IDS_BYTES_SENT_T                149
#define IDS_BYTES_RECEIVED              150
#define IDS_TIME_TAKEN                  151
#define IDS_PROTOCOL_VER                152
#define IDS_HOST                        153
#define IDS_USER_AGENT                  154
#define IDS_COOKIE_T                    155
#define IDS_REFERER                     156
#define IDS_PROCESS_ACCT                157
#define IDS_PROCESS_EVENT               158
#define IDS_PROCESS_TYPE                159
#define IDS_TOTAL_USER_TIME             160
#define IDS_TOTAL_KERNEL_TIME           161
#define IDS_TOTAL_PAGE_FAULTS           162
#define IDS_TOTAL_PROCESSES             163
#define IDS_ACTIVE_PROCESSES            164
#define IDS_TOTAL_TERM_PROCS            165
#define IDS_NO_RELATIVE_PATH			166
#define IDS_NOT_DIR_EXIST				167
#define IDD_GEN_LOG                     201
#define IDC_RADIO1                      201
#define IDD_LOG_GENERAL                 201
#define IDC_LOG_UNLIMITED               201
#define IDC_LOG_DAILY                   202
#define IDD_LOG_EXTENDED                203
#define IDC_LOG_WEEKLY                  204
#define IDD_LOG_ODBC                    205
#define IDC_LOG_MONTHLY                 206
#define IDD_ODBC_CONFIRM_PASSWORD       207
#define IDC_LOG_HOURLY                  208
#define IDD_CONFIRM_ODBC_PASSWORD       209
#define IDD_LOG_ADVANCED                210
#define IDB_CHECKBOX                    211
#define IDC_LOG_WHENSIZE                212
#define IDC_SPIN                        213
#define IDC_CHK_DATE                    214
#define IDC_LOG_SIZE                    215
#define IDC_CHK_TIME                    216
#define IDC_LOG_DIRECTORY               217
#define IDC_CHK_CLIENTIP                218
#define IDC_LOG_BROWSE                  219
#define IDC_CHK_USERNAME                220
#define IDC_LOG_SIZE_UNITS              221
#define IDC_CHK_SERVICENAME             222
#define IDC_LOG_FILE_SAMPLE             223
#define IDC_CHK_SERVERNAME              224
#define IDC_CHK_SERVERIP                225
#define IDC_METHOD                      226
#define IDC_CHK_URISTEM                 227
#define IDC_CHK_URI_QUERY               228
#define IDC_CHK_HTTPSTATUS              229
#define IDC_CHK_WIN32STATUS             230
#define IDC_CHK_BYTESSENT               231
#define IDC_CHK_BYTESRECEIVED           232
#define IDC_CHK_TIMETAKEN               233
#define IDC_CHK_USERAGENT               234
#define IDC_CHK_COOKIE                  235
#define IDC_CHK_REFERER                 236
#define IDC_ODBC_DATASOURCE             237
#define IDC_ODBC_TABLE                  238
#define IDC_ODBC_USERNAME               239
#define IDC_ODBC_PASSWORD               240
#define IDC_CHK_SERVERPORT              241
#define IDC_CHK_VERSION                 242
#define IDC_PROP_TREE                   243
#define IDC_USE_LOCAL_TIME              244
#define IDC_ODBC_CONFIRM_PASSWORD       1032

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        245
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         245
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\odbcppg.h ===
// OdbcPpg.h : Declaration of the COdbcPropPage property page class.

////////////////////////////////////////////////////////////////////////////
// COdbcPropPage : See OdbcPpg.cpp.cpp for implementation.

class COdbcPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(COdbcPropPage)
	DECLARE_OLECREATE_EX(COdbcPropPage)

// Constructor
public:
	COdbcPropPage();

// Dialog Data
	//{{AFX_DATA(COdbcPropPage)
	enum { IDD = IDD_PROPPAGE_ODBC };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(COdbcPropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\uimsft.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uimsft.h"
#include "LogGenPg.h"
#include "wrapmb.h"
#include "logtools.h"

#define OLE_NAME    _T("Msft_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc =
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;

extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacMsftLogUI::CFacMsftLogUI() :
        COleObjectFactory( CLSID_ASCLOGUI, RUNTIME_CLASS(CMsftCreator), TRUE, OLE_NAME )
    {
    }

//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit"),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\protocol\\StdFileEditing\\server\0") _T("%3"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL

};

BOOL CFacMsftLogUI::UpdateRegistry( BOOL bRegister )
    {
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_ASCLOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if ( AfxOleRegisterServerClass(
            CLSID_ASCLOGUI,
            OLE_NAME,
            _T("LogUI msft"),
            _T("LogUI msft"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_ASCLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
    }


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(CMsftCreator, CCmdTarget)
LPUNKNOWN CMsftCreator::GetInterfaceHook(const void* piid)
    {
    return new CImpMsftLogUI;
    }

//====================== the action

//---------------------------------------------------------------
CImpMsftLogUI::CImpMsftLogUI():
        m_dwRefCount(0)
    {
    AfxOleLockApp();
    }

//---------------------------------------------------------------
CImpMsftLogUI::~CImpMsftLogUI()
    {
    AfxOleUnlockApp();
    }


//---------------------------------------------------------------
HRESULT CImpMsftLogUI::OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath )
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    // prepare the metabase wrapper
    IMSAdminBase* pMB;
    if ( !FInitMetabaseWrapperEx( pocMachineName, &pMB ) )
        return 0xFFFFFFFF;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    // prepare the property sheet for action
    CLogGeneral         pageLogGeneral;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_SHEET_MSFT_TITLE );

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // prepare the pages
        pageLogGeneral.m_pMB = pMB;
        pageLogGeneral.m_szMeta = pocMetabasePath;
        pageLogGeneral.m_szServer = pocMachineName;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_MSFT_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_MSFT_PREFIX );

        // set the local flag
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine( pocMachineName );

        // add the pages to the sheet and run
        propsheet.AddPage( &pageLogGeneral );

        // turn on help
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapperEx(&pMB);

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
    }

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpMsftLogUI::QueryInterface(REFIID riid, void **ppObject)
    {
    if (riid==IID_IUnknown || riid==IID_LOGGINGUI || riid==CLSID_ASCLOGUI)
        {
        *ppObject = (ILogUIPlugin*) this;
        }
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NO_ERROR;
    }

//---------------------------------------------------------------
ULONG CImpMsftLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//---------------------------------------------------------------
ULONG CImpMsftLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\uincsa.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uincsa.h"
#include "LogGenPg.h"
#include "wrapmb.h"
#include "logtools.h"

#define OLE_NAME    _T("NCSA_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc =
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;

extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacNcsaLogUI::CFacNcsaLogUI() :
        COleObjectFactory( CLSID_NCSALOGUI, RUNTIME_CLASS(CNcsaCreator), TRUE, OLE_NAME )
    {
    }

//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit"),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL,
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\protocol\\StdFileEditing\\server\0") _T("%3"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacNcsaLogUI::UpdateRegistry( BOOL bRegister )
    {
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_NCSALOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if ( AfxOleRegisterServerClass(
            CLSID_NCSALOGUI,
            OLE_NAME,
            _T("LogUI ncsa"),
            _T("LogUI ncsa"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_NCSALOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
    }


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(CNcsaCreator, CCmdTarget)
LPUNKNOWN CNcsaCreator::GetInterfaceHook(const void* piid)
    {
    return new CImpNcsaLogUI;
    }

//====================== the action

//---------------------------------------------------------------
CImpNcsaLogUI::CImpNcsaLogUI():
        m_dwRefCount(0)
    {
    AfxOleLockApp();
    }

//---------------------------------------------------------------
CImpNcsaLogUI::~CImpNcsaLogUI()
    {
    AfxOleUnlockApp();
    }

//---------------------------------------------------------------
HRESULT CImpNcsaLogUI::OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath )
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    // prepare the metabase wrapper
    IMSAdminBase * pMB;
    if ( !FInitMetabaseWrapperEx( pocMachineName, &pMB ) )
        return 0xFFFFFFFF;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    // prepare the property sheet for action
    CLogGeneral         pageLogGeneral;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_SHEET_NCSA_TITLE );

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // prepare the pages
        pageLogGeneral.m_pMB = pMB;

        pageLogGeneral.m_szMeta = pocMetabasePath;
        pageLogGeneral.m_szServer = pocMachineName;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_NCSA_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_NCSA_PREFIX );

        // set the local flag
        pageLogGeneral.m_fLocalMachine = FIsLocalMachine( pocMachineName );

        // add the pages to the sheet and run
        propsheet.AddPage( &pageLogGeneral );

        // turn on help
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapperEx(&pMB);

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
    }

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpNcsaLogUI::QueryInterface(REFIID riid, void **ppObject)
    {
    if (riid==IID_IUnknown || riid==IID_LOGGINGUI || riid==CLSID_NCSALOGUI)
        {
        *ppObject = (ILogUIPlugin*) this;
        }
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NO_ERROR;
    }

//---------------------------------------------------------------
ULONG CImpNcsaLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//---------------------------------------------------------------
ULONG CImpNcsaLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\uiodbc.h ===
#ifndef _ODBCLOGUI_H_
#define _ODBCLOGUI_H_


class CFacOdbcLogUI : COleObjectFactory
    {
    public:
        CFacOdbcLogUI();
//        virtual CCmdTarget* OnCreateObject( );
        virtual BOOL UpdateRegistry( BOOL bRegister );
    };



class COdbcCreator : public CCmdTarget
    {
    DECLARE_DYNCREATE(COdbcCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
    };


class CImpOdbcLogUI : public ILogUIPlugin
    {

    public:
        CImpOdbcLogUI();
        ~CImpOdbcLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath );

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    protected:
    private:
    ULONG m_dwRefCount;
    };  // CImpOdbcLogUI




#endif  // _ODBCLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\uincsa.h ===
#ifndef _NCSLOGUI_H_
#define _NCSLOGUI_H_


class CFacNcsaLogUI : COleObjectFactory
    {
    public:
        CFacNcsaLogUI();
//        virtual CCmdTarget* OnCreateObject( );
        virtual BOOL UpdateRegistry( BOOL bRegister );
    };



class CNcsaCreator : public CCmdTarget
    {
    DECLARE_DYNCREATE(CNcsaCreator)
    virtual LPUNKNOWN GetInterfaceHook(const void* piid);
    };


class CImpNcsaLogUI : public ILogUIPlugin
    {

    public:
        CImpNcsaLogUI();
        ~CImpNcsaLogUI();

    virtual HRESULT STDMETHODCALLTYPE OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath );

    HRESULT _stdcall
    QueryInterface(REFIID riid, void **ppObject);

    ULONG _stdcall
    AddRef();

    ULONG _stdcall
    Release();

    protected:
    private:
    ULONG m_dwRefCount;
    };  // CImpNcsaLogUI




#endif  // _NCSLOGUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\logui\uiodbc.cpp ===
#include "stdafx.h"
#include <iadmw.h>
#include <inetcom.h>
#include <logtype.h>
#include <ilogobj.hxx>
#include "logui.h"
#include "uiOdbc.h"

#include "LogGenPg.h"
#include "LogODBC.h"
#include "wrapmb.h"
#include "logtools.h"

#define OLE_NAME    _T("Odbc_Logging_UI")

static const DWORD BASED_CODE _dwOleMisc =
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE;

extern HINSTANCE	g_hInstance;

//====================== the required methods
//---------------------------------------------------------------
CFacOdbcLogUI::CFacOdbcLogUI() :
        COleObjectFactory( CLSID_ODBCLOGUI, RUNTIME_CLASS(COdbcCreator), TRUE, OLE_NAME )
    {
    }


//---------------------------------------------------------------
static const LPCTSTR rglpszServerRegister[] = 
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\NotInsertable\0") _T(""),
	_T("%2\\protocol\\StdFileEditing\\verb\\0\0") _T("&Edit"),
	_T("CLSID\\%1\0") _T("%5"),
	_T("CLSID\\%1\\Verb\\0\0") _T("&Edit,0,2"),
	_T("CLSID\\%1\\NotInsertable\0") _T(""),
	_T("CLSID\\%1\\AuxUserType\\2\0") _T("%4"),
	_T("CLSID\\%1\\AuxUserType\\3\0") _T("%6"),
        _T("CLSID\\%1\\MiscStatus\0") _T("32"),
        NULL
};

static const LPCTSTR rglpszServerOverwriteDLL[] =
{
	_T("%2\\CLSID\0") _T("%1"),
	_T("%2\\protocol\\StdFileEditing\\server\0") _T("%3"),
	_T("CLSID\\%1\\ProgID\0") _T("%2"),
	_T("CLSID\\%1\\InProcServer32\0") _T("%3"),
        _T("CLSID\\%1\\DefaultIcon\0") _T("%3,%7"),
        NULL
};

BOOL CFacOdbcLogUI::UpdateRegistry( BOOL bRegister )
    {
	if (bRegister)
/*
		return AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			CLSID_ODBCLOGUI,
			OLE_NAME,
			0,
			0,
			afxRegApartmentThreading,
			_dwOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);
*/
        if ( AfxOleRegisterServerClass(
            CLSID_ODBCLOGUI,
            OLE_NAME,
            _T("LogUI odbc"),
            _T("LogUI odbc"),
			OAT_SERVER,
			(LPCTSTR *)rglpszServerRegister,
			(LPCTSTR *)rglpszServerOverwriteDLL
			) )
        {
            return FSetObjectApartmentModel( CLSID_ODBCLOGUI );
        }
	else
		return AfxOleUnregisterClass(m_clsid, OLE_NAME);

    return FALSE;
    }


//---------------------------------------------------------------
IMPLEMENT_DYNCREATE(COdbcCreator, CCmdTarget)
LPUNKNOWN COdbcCreator::GetInterfaceHook(const void* piid)
    {
 //   if ( *piid == IID_ILogPlugin )
        return new CImpOdbcLogUI;
 //   else
 //       return NULL;
    }

//====================== the action

//---------------------------------------------------------------
CImpOdbcLogUI::CImpOdbcLogUI():
        m_dwRefCount(0)
    {
//    guid = IID_LOGGINGUI;
    AfxOleLockApp();
    }

CImpOdbcLogUI::~CImpOdbcLogUI()
    {
    AfxOleUnlockApp();
    }


//---------------------------------------------------------------
HRESULT CImpOdbcLogUI::OnProperties( IN OLECHAR* pocMachineName, IN OLECHAR* pocMetabasePath )
    {
    AFX_MANAGE_STATE(_afxModuleAddrThis);

    // prepare the metabase wrapper
    IMSAdminBase * pMB;
    if ( !FInitMetabaseWrapperEx( pocMachineName, &pMB ) )
        return 0xFFFFFFFF;

	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

    // prepare the help
    ((CLoguiApp*)AfxGetApp())->PrepHelp( pocMetabasePath );

    // prepare the property sheet for action
    CLogGeneral         pageLogGeneral;
    CLogODBC            pageLogODBC;

    // declare the property sheet
    CPropertySheet  propsheet( IDS_SHEET_ODBC_TITLE );

    // Things could (potentially maybe) throw here, so better protect it.
    try
        {
        // prepare the pages
        pageLogODBC.m_pMB = pMB;
        pageLogGeneral.m_pMB = pMB;

        pageLogODBC.m_szMeta = pocMetabasePath;
        pageLogODBC.m_szServer = pocMachineName;
        pageLogGeneral.m_szServer = pocMachineName;
        pageLogGeneral.m_szMeta = pocMetabasePath;
        pageLogGeneral.szPrefix.LoadString( IDS_LOG_EXTND_PREFIX );
        pageLogGeneral.szSizePrefix.LoadString( IDS_LOG_SIZE_EXTND_PREFIX );

        // add the pages to the sheet and run
//        propsheet.AddPage( &pageLogGeneral );     // don't need general for ODBC
        propsheet.AddPage( &pageLogODBC );

        // turn on help
        propsheet.m_psh.dwFlags |= PSH_HASHELP;
	    pageLogGeneral.m_psp.dwFlags |= PSP_HASHELP;
	    pageLogODBC.m_psp.dwFlags |= PSP_HASHELP;

        propsheet.DoModal();
        }
    catch ( CException e )
        {
        }

    // close the metabase wrappings
    FCloseMetabaseWrapperEx(&pMB);

    // restore the resources
	AfxSetResourceHandle( hOldRes );

    return NO_ERROR;
    }

//====================== the required methods
//---------------------------------------------------------------
HRESULT CImpOdbcLogUI::QueryInterface(REFIID riid, void **ppObject)
    {
    if (riid==IID_IUnknown || riid==IID_LOGGINGUI || riid==CLSID_ODBCLOGUI)
        {
        *ppObject = (ILogUIPlugin*) this;
        }
    else
        {
        return E_NOINTERFACE;
        }
    AddRef();
    return NO_ERROR;
    }

//---------------------------------------------------------------
ULONG CImpOdbcLogUI::AddRef()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

//---------------------------------------------------------------
ULONG CImpOdbcLogUI::Release()
{
    DWORD dwRefCount;
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    if (dwRefCount == 0) {
        delete this;
    }
    return dwRefCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\sitecreator\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG
#include <crtdbg.h>
#include <windows.h>
# define SC_TRACE                   Trace
# define SC_TRACE0(psz)             Trace(L"%s", psz)
# define SC_TRACE1(psz, p1)         Trace(psz, p1)
# define SC_TRACE2(psz, p1, p2)     Trace(psz, p1, p2)
# define SC_TRACE3(psz, p1, p2, p3) Trace(psz, p1, p2, p3)
# define SC_ASSERT(bCond)           if(bCond == false) Assert(__FILE__, __LINE__, #bCond)
#else /* !DBG */
  /* These macros should all compile away to nothing */
# define SC_TRACE
# define SC_TRACE0(psz)
# define SC_TRACE1(psz, p1)
# define SC_TRACE2(psz, p1, p2)
# define SC_TRACE3(psz, p1, p2, p3)
# define SC_ASSERT(bCond)
#endif /* !DBG*/

#if DBG

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCWSTR pszFormat,
    ...);

void __cdecl
Assert(
    LPCSTR pszFile,
    DWORD  dwLine,
    LPCSTR pszCond);

#endif /* DBG */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\sitecreator\safecs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.h
//
// Contents:    CSafeAutoCriticalSection, protects CriticalSection against AV via try,catch
//
//------------------------------------------------------------------------
#ifndef _SAFECS_H_
#define _SAFECS_H_

class CSafeAutoCriticalSection
{
public:


    CSafeAutoCriticalSection();
    ~CSafeAutoCriticalSection();

    DWORD Lock();
    DWORD  Unlock();

    BOOL IsInitialized() { return (STATE_INITIALIZED == m_lState);}

private:

    enum
    {
        STATE_UNINITIALIZED = 0,
        STATE_INITIALIZED   = 1
    };

    CRITICAL_SECTION    m_cs;
    LONG                m_lState;
	DWORD               m_dwError;

};

class CSafeLock 
{
public:
	CSafeLock (CSafeAutoCriticalSection* val);
	CSafeLock (CSafeAutoCriticalSection& val);

	~CSafeLock ();

	DWORD Lock ();
	DWORD Unlock ();
private:

private:
	BOOL m_locked;
	CSafeAutoCriticalSection* m_pSem;
};

#endif // _SAFECS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\sitecreator\debug.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "debug.h"

#if DBG

void __cdecl
Trace(
    LPCWSTR ptszFormat,
    ...)
{
    WCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    vswprintf(tszBuff, ptszFormat, args);
    va_end(args);
    OutputDebugString(tszBuff);
}

void __cdecl
Assert(
    LPCSTR  pszFile,
    DWORD   dwLine,
    LPCSTR  pszCond)
{
    CHAR pszBuf[2048];

    _snprintf( 
        pszBuf, 
        2048, 
        "%s, Line %u, Assertion failed: %s\n",
        pszFile,
        dwLine,
        pszCond);

    pszBuf[2047] = L'\0';

    OutputDebugStringA(pszBuf);
    DebugBreak();
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\sitecreator\unicode.h ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// unicode.h
//
// Header file that forcibly turns on a unicode compile
//

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#undef MBCS
#undef _MBCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\sitecreator\sitecreator.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    SiteCreator.cpp

Abstract:

    Implementation of:
        CSiteCreator

    The public methods are thread-safe.

Author:

    Mohit Srivastava            21-Mar-2001

Revision History:

--*/

#include "sitecreator.h"
#include <iiscnfg.h>
#include <hashfn.h>
#include <limits.h>
#include "debug.h"

//
// consts
//

static const DWORD  DW_MAX_SITEID        = INT_MAX;
static const DWORD  DW_TIMEOUT           = 30000;

//
// Number of ERROR_PATH_BUSY's before we give up
//
static const DWORD  DW_NUM_TRIES         = 1;   

static LPCWSTR      WSZ_SLASH_ROOT       = L"/root/";
static ULONG        CCH_SLASH_ROOT       = wcslen(WSZ_SLASH_ROOT);

#define             WSZ_PATH_W3SVC       L"/LM/w3svc/"
#define             WSZ_PATH_MSFTPSVC    L"/LM/msftpsvc/"

#define             WSZ_IISWEBSERVER     L"IIsWebServer"
#define             WSZ_IISWEBVIRTUALDIR L"IIsWebVirtualDir"
#define             WSZ_IISFTPSERVER     L"IIsFtpServer"
#define             WSZ_IISFTPVIRTUALDIR L"IIsFtpVirtualDir"

//
// W3Svc
//
TService TServiceData::W3Svc =
{
    SC_W3SVC,
    WSZ_PATH_W3SVC,
    sizeof(WSZ_PATH_W3SVC)/sizeof(WCHAR)-1,
    WSZ_IISWEBSERVER,
    sizeof(WSZ_IISWEBSERVER)/sizeof(WCHAR)-1,
    WSZ_IISWEBVIRTUALDIR,
    sizeof(WSZ_IISWEBVIRTUALDIR)/sizeof(WCHAR)-1
};

//
// MSFtpSvc
//
TService TServiceData::MSFtpSvc =
{
    SC_MSFTPSVC,
    WSZ_PATH_MSFTPSVC,
    sizeof(WSZ_PATH_MSFTPSVC)/sizeof(WCHAR)-1,
    WSZ_IISFTPSERVER,
    sizeof(WSZ_IISFTPSERVER)/sizeof(WCHAR)-1,
    WSZ_IISFTPVIRTUALDIR,
    sizeof(WSZ_IISFTPVIRTUALDIR)/sizeof(WCHAR)-1
};

//
// Collection of supported services
//
TService* TServiceData::apService[] =
{
    &W3Svc,
    &MSFtpSvc,
    NULL
};

//
// public
//

CSiteCreator::CSiteCreator()
{
    m_bInit        = false;
}

CSiteCreator::CSiteCreator(
    IMSAdminBase* pIABase)
{
    SC_ASSERT(pIABase != NULL);
    m_spIABase = pIABase;
    m_bInit    = true;
}

CSiteCreator::~CSiteCreator()
{
}

HRESULT
CSiteCreator::CreateNewSite2(
    /* [in]  */ eSC_SUPPORTED_SERVICES  eServiceId,
    /* [in]  */ LPCWSTR                 wszServerComment,
    /* [in]  */ LPCWSTR                 mszServerBindings,
    /* [in]  */ LPCWSTR                 wszPathOfRootVirtualDir,
    /* [in]  */ IIISApplicationAdmin*   pIApplAdmin,
    /* [out] */ PDWORD                  pdwSiteId,
    /* [in]  */ PDWORD                  pdwRequestedSiteId)
{
    if( wszServerComment        == NULL ||
        mszServerBindings       == NULL ||
        wszPathOfRootVirtualDir == NULL ||
        pdwSiteId               == NULL ||
        (m_bInit && m_spIABase == NULL) ) // means you used constructor incorrectly
    {
        return E_INVALIDARG;
    }

    HRESULT hr = InternalCreateNewSite(
        eServiceId,
        wszServerComment,
        mszServerBindings,
        wszPathOfRootVirtualDir,
        pIApplAdmin,
        pdwSiteId,
        pdwRequestedSiteId);

    return hr;
}

HRESULT
CSiteCreator::CreateNewSite(
    /* [in]  */ eSC_SUPPORTED_SERVICES  eServiceId,
    /* [in]  */ LPCWSTR                 wszServerComment,
    /* [out] */ PDWORD                  pdwSiteId,
    /* [in]  */ PDWORD                  pdwRequestedSiteId)
{
    if( wszServerComment        == NULL ||
        pdwSiteId               == NULL ||
        (m_bInit && m_spIABase == NULL) ) // means you used constructor incorrectly
    {
        return E_INVALIDARG;
    }
    return InternalCreateNewSite(
        eServiceId, wszServerComment, NULL, NULL, NULL, pdwSiteId, pdwRequestedSiteId);
}

//
// private
//

HRESULT
CSiteCreator::InternalCreateNewSite(
    eSC_SUPPORTED_SERVICES    i_eServiceId,
    LPCWSTR                   i_wszServerComment,
    LPCWSTR                   i_mszServerBindings,
    LPCWSTR                   i_wszPathOfRootVirtualDir,
    IIISApplicationAdmin*     i_pIApplAdmin,
    PDWORD                    o_pdwSiteId,
    PDWORD                    i_pdwRequestedSiteId)
{
    SC_ASSERT(o_pdwSiteId);

    HRESULT         hr          = S_OK;
    METADATA_HANDLE hW3Svc      = 0;
    bool            bOpenHandle = false;
    DWORD           dwSiteId    = 0;
    WCHAR           wszSiteId[20] = {0};

    //
    // Lookup the service
    //
    TService* pService = NULL;
    for(pService = TServiceData::apService[0]; pService != NULL; pService++)
    {
        if(pService->eId == i_eServiceId)
        {
            break;
        }
    }
    if(pService == NULL)
    {
        return E_INVALIDARG;
    }

    hr = InternalCreateNode(
        pService,
        (i_wszServerComment == NULL) ? L"" : i_wszServerComment,
        &hW3Svc,
        &dwSiteId,
        i_pdwRequestedSiteId);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // We now have an open metadata handle that must be closed.
    //
    bOpenHandle = true;

    //
    // w3svc/n/KeyType="IIsWebServer"
    //
    hr = InternalSetData(
        hW3Svc,
        _ultow(dwSiteId, wszSiteId, 10),
        MD_KEY_TYPE,
        (LPBYTE)pService->wszServerKeyType,
        (pService->cchServerKeyType + 1) * sizeof(WCHAR),
        METADATA_NO_ATTRIBUTES,
        STRING_METADATA,
        IIS_MD_UT_SERVER);
    if(FAILED(hr))
    {
        goto exit;
    }

    //
    // w3svc/n/ServerComment=i_wszServerComment
    //
    if(i_wszServerComment != NULL)
    {
        hr = InternalSetData(
            hW3Svc,
            wszSiteId,
            MD_SERVER_COMMENT,
            (LPBYTE)i_wszServerComment,
            (wcslen(i_wszServerComment) + 1) * sizeof(WCHAR),
            METADATA_INHERIT,
            STRING_METADATA,
            IIS_MD_UT_SERVER);
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // w3svc/n/ServerBindings=i_mszServerBindings
    //
    if(i_mszServerBindings != NULL)
    {
        ULONG cEntriesCur = 0;
        ULONG cEntries    = 0;
        do
        {
            cEntriesCur  = wcslen(i_mszServerBindings + cEntries) + 1;
            cEntries    += cEntriesCur;
        }
        while(cEntriesCur > 1);

        if(cEntries > 1)
        {
            hr = InternalSetData(
                hW3Svc,
                wszSiteId,
                MD_SERVER_BINDINGS,
                (LPBYTE)i_mszServerBindings,
                cEntries * sizeof(WCHAR),
                METADATA_INHERIT,
                MULTISZ_METADATA,
                IIS_MD_UT_SERVER);
            if(FAILED(hr))
            {
                goto exit;
            }
        }
    }

    //
    // Create w3svc/n/root and associated properties only if i_wszPathOfRootVirtualDir
    // was specified.
    //
    if(i_wszPathOfRootVirtualDir != NULL)
    {
        //
        // w3svc/n/root
        //
        SC_ASSERT((sizeof(wszSiteId)/sizeof(WCHAR) + CCH_SLASH_ROOT + 1) <= 30);
        WCHAR wszVdirPath[30];
        wcscpy(wszVdirPath, wszSiteId);
        wcscat(wszVdirPath, WSZ_SLASH_ROOT);
        hr = m_spIABase->AddKey(
            hW3Svc,
            wszVdirPath);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // w3svc/n/root/KeyType="IIsWebVirtualDir"
        //
        hr = InternalSetData(
            hW3Svc,
            wszVdirPath,
            MD_KEY_TYPE,
            (LPBYTE)pService->wszServerVDirKeyType,
            (pService->cchServerVDirKeyType + 1) * sizeof(WCHAR),
            METADATA_NO_ATTRIBUTES,
            STRING_METADATA,
            IIS_MD_UT_SERVER);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // w3svc/n/root/Path=wszPathOfRootVirtualDir
        //
        hr = InternalSetData(
            hW3Svc,
            wszVdirPath,
            MD_VR_PATH,
            (LPBYTE)i_wszPathOfRootVirtualDir,
            (wcslen(i_wszPathOfRootVirtualDir) + 1) * sizeof(WCHAR),
            METADATA_INHERIT,
            STRING_METADATA,
            IIS_MD_UT_FILE);
        if(FAILED(hr))
        {
            goto exit;
        }

        //
        // w3svc/n/root/AppRoot="/LM/w3svc/n/root/"
        //
        if(i_eServiceId == SC_W3SVC && i_pIApplAdmin != NULL)
        {
            SC_ASSERT((pService->cchMDPath + sizeof(wszVdirPath)/sizeof(WCHAR) + 1) <= 50);
            WCHAR wszAppRoot[50];
            wcscpy(wszAppRoot, pService->wszMDPath);
            wcscat(wszAppRoot, wszVdirPath);

            m_spIABase->CloseKey(hW3Svc);
            bOpenHandle = false;

            hr = i_pIApplAdmin->CreateApplication(wszAppRoot, 2, L"DefaultAppPool", FALSE);
            if(FAILED(hr))
            {
                // DBGPRINTF((DBG_CONTEXT, "[%s] CreateAppl failed, hr=0x%x\n", __FUNCTION__, hr));
                goto exit;
            }
        }
    }

    //
    // Set out parameters if everything succeeded
    //
    *o_pdwSiteId = dwSiteId;

exit:
    if(bOpenHandle)
    {
        m_spIABase->CloseKey(hW3Svc);
        bOpenHandle = false;
    }
    return hr;
}

HRESULT 
CSiteCreator::InternalSetData(
    METADATA_HANDLE  i_hMD,
    LPCWSTR          i_wszPath,
    DWORD            i_dwIdentifier,
    LPBYTE           i_pData,
    DWORD            i_dwNrBytes,
    DWORD            i_dwAttributes,
    DWORD            i_dwDataType,
    DWORD            i_dwUserType
)
{
    HRESULT hr = S_OK;

    METADATA_RECORD mr;
    memset(&mr, 0, sizeof(METADATA_RECORD));

    mr.dwMDIdentifier = i_dwIdentifier;
    mr.pbMDData       = i_pData;
    mr.dwMDDataLen    = i_dwNrBytes;
    mr.dwMDAttributes = i_dwAttributes;
    mr.dwMDDataType   = i_dwDataType;
    mr.dwMDUserType   = i_dwUserType;

    hr = m_spIABase->SetData(
        i_hMD,
        i_wszPath,
        &mr);

    return hr;
}

HRESULT
CSiteCreator::InternalCreateNode(
    TService*        i_pService,
    LPCWSTR          i_wszServerComment,
    PMETADATA_HANDLE o_phService,
    PDWORD           o_pdwSiteId,
    const PDWORD     i_pdwRequestedSiteId)
{
    HRESULT hr = InternalInitIfNecessary();
    if(FAILED(hr))
    {
        return hr;
    }

    SC_ASSERT(i_pService         != NULL);
    SC_ASSERT(i_wszServerComment != NULL);
    SC_ASSERT(o_phService        != NULL);
    SC_ASSERT(o_pdwSiteId        != NULL);

    *o_pdwSiteId = 0;
    *o_phService   = 0;

    DWORD           idx           = 0;  // current index of for loop
    DWORD           dwStart       = -1; // starting index
    METADATA_HANDLE hService      = 0;
    WCHAR           wszSiteId[20] = {0};

    for(ULONG i = 0; i < DW_NUM_TRIES; i++)
    {
        hr = m_spIABase->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            i_pService->wszMDPath,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            DW_TIMEOUT,
            &hService);
        if( hr == HRESULT_FROM_WIN32(ERROR_PATH_BUSY) )
        {
            continue;
        }
        else if( FAILED(hr) )
        {
            return hr;
        }
        else
        {
            break;
        }
    }
    if(FAILED(hr))
    {
        return hr;
    }

    if(i_pdwRequestedSiteId == NULL)
    {
        dwStart = ( HashFn::HashStringNoCase(i_wszServerComment) % DW_MAX_SITEID ) + 1;
        SC_ASSERT(dwStart != 0);
        SC_ASSERT(dwStart <= DW_MAX_SITEID);

        DWORD dwNrSitesTried = 0;
        for(idx = dwStart; 
            dwNrSitesTried < DW_MAX_SITEID; 
            dwNrSitesTried++, idx = (idx % DW_MAX_SITEID) + 1)
        {
            SC_ASSERT(idx != 0);               // 0 is not a valid site id
            SC_ASSERT(idx <= DW_MAX_SITEID);
            hr = m_spIABase->AddKey(
                hService,
                _ultow(idx, wszSiteId, 10));
            if( hr == HRESULT_FROM_WIN32(ERROR_DUP_NAME) ||
                hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) )
            {
                continue;
            }
            else if(SUCCEEDED(hr))
            {
                break;
            }
            else
            {
                goto exit;
            }
        }
        if(FAILED(hr))
        {
            //
            // Tried everything, still failed!
            //
            goto exit;
        }
    }
    else
    {
        idx = *i_pdwRequestedSiteId;
        hr  = m_spIABase->AddKey(
            hService, 
            _ultow(idx, wszSiteId, 10));
        if(FAILED(hr))
        {
            goto exit;
        }
    }

    //
    // Set out parameters if everything succeeded
    //
    *o_pdwSiteId   = idx;
    *o_phService   = hService;

exit:
    if(FAILED(hr))
    {
        m_spIABase->CloseKey(
            hService);
    }
    return hr;
}

HRESULT
CSiteCreator::InternalInitIfNecessary()
{
    HRESULT   hr = S_OK;
    CSafeLock csSafe(m_SafeCritSec);

    if(m_bInit)
    {
        return hr;
    }

    hr = csSafe.Lock();
    hr = HRESULT_FROM_WIN32(hr);
    if(FAILED(hr))
    {
        return hr;
    }

    if(!m_bInit)
    {
        hr = CoCreateInstance(
            CLSID_MSAdminBase,
            NULL,
            CLSCTX_ALL,
            IID_IMSAdminBase,
            (void**)&m_spIABase);
        if(FAILED(hr))
        {
            m_bInit = false;
        }
        else
        {
            m_bInit = true;
        }
    }

    csSafe.Unlock();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\sitecreator\sitecreator.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    SiteCreator.h

Abstract:

    Definition of:
        CSiteCreator

    The public methods are thread-safe.

Author:

    Mohit Srivastava            21-Mar-2001

Revision History:

--*/

#ifndef __sitecreator_h__
#define __sitecreator_h__

#if _MSC_VER > 1000
#pragma once
#endif 

#include <windows.h>
#include <atlbase.h>
#include <iadmw.h>
#include <iwamreg.h>
#include "SafeCS.h"

typedef /* [v1_enum] */ 
enum tag_SC_SUPPORTED_SERVICES
{
    SC_W3SVC    = 1,
    SC_MSFTPSVC = 2
} eSC_SUPPORTED_SERVICES;

struct TService
{
    eSC_SUPPORTED_SERVICES   eId;
    LPCWSTR                  wszMDPath;
    ULONG                    cchMDPath;
    LPCWSTR                  wszServerKeyType;
    ULONG                    cchServerKeyType;
    LPCWSTR                  wszServerVDirKeyType;
    ULONG                    cchServerVDirKeyType;
};

struct TServiceData
{
    static TService  W3Svc;
    static TService  MSFtpSvc;

    static TService* apService[];
};

//
// CSiteCreator
//
class CSiteCreator
{
public:
    CSiteCreator();

    CSiteCreator(
        IMSAdminBase* pIABase);

    virtual ~CSiteCreator();

    HRESULT STDMETHODCALLTYPE CreateNewSite(
        /* [in]  */ eSC_SUPPORTED_SERVICES  eServiceId,
        /* [in]  */ LPCWSTR                 wszServerComment,
        /* [out] */ PDWORD                  pdwSiteId,
        /* [in]  */ PDWORD                  pdwRequestedSiteId=NULL);

    HRESULT STDMETHODCALLTYPE CreateNewSite2(
        /* [in]  */ eSC_SUPPORTED_SERVICES  eServiceId,
        /* [in]  */ LPCWSTR                 wszServerComment,
        /* [in]  */ LPCWSTR                 mszServerBindings,
        /* [in]  */ LPCWSTR                 wszPathOfRootVirtualDir,
        /* [in]  */ IIISApplicationAdmin*   pIApplAdmin,
        /* [out] */ PDWORD                  pdwSiteId,
        /* [in]  */ PDWORD                  pdwRequestedSiteId=NULL);

private:
    HRESULT InternalInitIfNecessary();

    HRESULT InternalCreateNewSite(
        eSC_SUPPORTED_SERVICES    i_eServiceId,
        LPCWSTR                   i_wszServerComment,
        LPCWSTR                   i_mszServerBindings,
        LPCWSTR                   i_wszPathOfRootVirtualDir,
        IIISApplicationAdmin*     i_pIApplAdmin,
        PDWORD                    o_pdwSiteId,
        PDWORD                    i_pdwRequestedSiteId=NULL);

    HRESULT InternalSetData(
        METADATA_HANDLE  i_hMD,
        LPCWSTR          i_wszPath,
        DWORD            i_dwIdentifier,
        LPBYTE           i_pData,
        DWORD            i_dwNrBytes,
        DWORD            i_dwAttributes,
        DWORD            i_dwDataType,
        DWORD            i_dwUserType
        );

    HRESULT InternalCreateNode(
        TService*        i_pService,
        LPCWSTR          i_wszServerComment,
        PMETADATA_HANDLE o_phService,
        PDWORD           o_pdwSiteId,
        const PDWORD     i_pdwRequestedSiteId=NULL);

    CSafeAutoCriticalSection m_SafeCritSec;
    CComPtr<IMSAdminBase>    m_spIABase;
    bool                     m_bInit;
};

#endif // __sitecreator_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\sitecreator\safecs.cpp ===
#include <unicode.h>
#include <windows.h>
#include "SafeCS.h"


//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        SafeCS.cpp
//
// Contents:    CSafeAutoCriticalSection implementation
//              CSafeLock implementation
//
//------------------------------------------------------------------------

//+--------------------------------------------------------------------------
//
//  Class:      CSafeAutoCriticalSection
//
//  Purpose:    Wrapper for initializing critical-sections.
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- initializes the critical section
//				Detructor		- uninitializes the critical section 
//
//  Notes:		This provides a convenient way to ensure that you're
//              you wrap InitializeCriticalSection and 
//              UnInitializeCriticalSection in try catches which is useful 
//              in low-mem conditions
//
//---------------------------------------------------------------------------

//+-------------------------------------------------------------------------- 
// Default constructor - Initializes the critical section and sets the state 
// flag to initialized
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::CSafeAutoCriticalSection()
{
    m_lState = STATE_UNINITIALIZED;
	m_dwError = ERROR_SUCCESS;

    __try
    {
	    LONG  lPreviousState;

        // try to set state flag
        lPreviousState = InterlockedCompareExchange(&m_lState,
                                                    STATE_INITIALIZED,
                                                    STATE_UNINITIALIZED);

        // if this critical section was not initialized
        if(STATE_UNINITIALIZED == lPreviousState)
        {
			//
			// Note we can call InitializeCriticalSectionAndSpinCount here
			// and thereby eliminate the need for a try catch in 
			// EnterCriticalSection. But the docs say that 
			// InitializeCriticalSectionAndSpinCount is valid on NT4.0 SP3
			// onwards and we need to run on plain NT4.0 - hence we call
			// InitializeCriticalSection
			//

			InitializeCriticalSection(&m_cs);
        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_dwError = _exception_code();
    }

    // failed to initialize - need to reset
    if(ERROR_SUCCESS != m_dwError)
    {
        m_lState = STATE_UNINITIALIZED;
    }

}

//+-------------------------------------------------------------------------- 
// Destructor
//+-------------------------------------------------------------------------- 

CSafeAutoCriticalSection::~CSafeAutoCriticalSection()
{
    LONG                lPreviousState;

    // try to reset the the state to uninitialized
    lPreviousState = InterlockedCompareExchange(&m_lState,
                                                STATE_UNINITIALIZED,
                                                STATE_INITIALIZED);

    // if the object was initialized delete the critical section
    if(STATE_INITIALIZED == lPreviousState)
    {
        DeleteCriticalSection(&m_cs);
    }
}

//+-------------------------------------------------------------------------- 
// Enters critical section, if needed initializes critical section
// before entering
//
// Returns 
//	DWORD -	ERROR_SUCCESS if everything is fine
//			ERROR_OUTOFMEMORY if failed to create or enter critical section
//+-------------------------------------------------------------------------- 

DWORD CSafeAutoCriticalSection::Lock()
{
    DWORD dwError = ERROR_SUCCESS;

    if(!IsInitialized())
    {
        return m_dwError;
    }

    __try
    {
        EnterCriticalSection(&m_cs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
	    dwError = _exception_code();
    }

    return dwError;
}

//+-------------------------------------------------------------------------- 
// Leaves critical section
//+-------------------------------------------------------------------------- 
DWORD CSafeAutoCriticalSection::Unlock()
{
    if(!IsInitialized())
    {
        return m_dwError;
    }

    LeaveCriticalSection(&m_cs);

    return ERROR_SUCCESS;

}

//+--------------------------------------------------------------------------
//
//  Class:      CSafeLock
//
//  Purpose:    Auto-unlocking critical-section services
//
//  Interface:  Lock			- locks the critical section
//				Unlock			- unlocks the critical section
//				Constructor		- locks the critical section (unless told 
//								  otherwise)
//				Detructor		- unlocks the critical section if its locked
//
//  Notes:		This provides a convenient way to ensure that you're
//              unlocking a CSemExclusive, which is useful if your routine
//              can be left via several returns and/or via exceptions....
//
//---------------------------------------------------------------------------

CSafeLock::CSafeLock(CSafeAutoCriticalSection* val) : 
m_pSem(val),
m_locked(FALSE)
{
}

CSafeLock::CSafeLock(CSafeAutoCriticalSection& val) : 
m_pSem(&val),
m_locked(FALSE)
{
}

CSafeLock::~CSafeLock() 
{	
	if (m_locked) 
	{
		m_pSem->Unlock(); 
	}
}

DWORD CSafeLock::Lock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(!m_locked) 
	{ 
		dwError = m_pSem->Lock(); 

		if(ERROR_SUCCESS == dwError)
		{
			m_locked = TRUE; 
		}
	}

	return dwError;
}


DWORD CSafeLock::Unlock() 
{
	DWORD dwError = ERROR_SUCCESS;

	if(m_locked) 
	{ 
		dwError = m_pSem->Unlock(); 
		m_locked = FALSE; 
	}

	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\add_app_pool.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_app_pool.cpp

   Abstract:
        Add new IIS Application Pool node

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        12/26/2000      sergeia     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "resource.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "add_app_pool.h"
#include "shts.h"
#include "app_pool_sheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW


CAddAppPoolDlg::CAddAppPoolDlg(
    CAppPoolsContainer * pCont,
    CPoolList * pools,
    CWnd * pParent)
    : CDialog(CAddAppPoolDlg::IDD, pParent),
    m_pCont(pCont),
    m_pool_list(pools),
    m_fUseTemplate(FALSE)       // current default
{
}

CAddAppPoolDlg::~CAddAppPoolDlg()
{
}

void 
CAddAppPoolDlg::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddAppPoolDlg)
    DDX_Control(pDX, IDC_EDIT_POOL_NAME, m_edit_PoolName);
    DDX_Text(pDX, IDC_EDIT_POOL_NAME, m_strPoolName);
    DDX_Control(pDX, IDC_EDIT_POOL_ID, m_edit_PoolId);
    DDX_Text(pDX, IDC_EDIT_POOL_ID, m_strPoolId);
    DDX_Control(pDX, IDC_USE_TEMPLATE, m_button_UseTemplate);
    DDX_Control(pDX, IDC_USE_POOL, m_button_UsePool);
    DDX_Control(pDX, IDC_TEMPLATES, m_combo_Template);
    DDX_CBIndex(pDX, IDC_TEMPLATES, m_TemplateIdx);
    DDX_Control(pDX, IDC_POOLS, m_combo_Pool);
    DDX_CBIndex(pDX, IDC_POOLS, m_PoolIdx);
    //}}AFX_DATA_MAP
    if (pDX->m_bSaveAndValidate)
    {
        // check that pool id is unique
    }
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CAddAppPoolDlg, CDialog)
    //{{AFX_MSG_MAP(CAddAppPoolDlg)
    ON_BN_CLICKED(IDC_USE_TEMPLATE, OnButtonUseTemplate)
    ON_BN_CLICKED(IDC_USE_POOL, OnButtonUsePool)
    ON_EN_CHANGE(IDC_EDIT_POOL_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_POOL_ID, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_TEMPLATES, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_POOLS, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void
CAddAppPoolDlg::OnItemChanged()
{
    SetControlStates();
}

void
CAddAppPoolDlg::OnButtonUseTemplate()
{
    m_fUseTemplate = TRUE;
}

void
CAddAppPoolDlg::OnButtonUsePool()
{
    m_fUseTemplate = FALSE;
}

void
CAddAppPoolDlg::SetControlStates()
{
    m_button_UseTemplate.SetCheck(m_fUseTemplate);
    m_button_UsePool.SetCheck(!m_fUseTemplate);
    m_combo_Pool.EnableWindow(!m_fUseTemplate);
    m_combo_Template.EnableWindow(m_fUseTemplate);
    UpdateData();
    BOOL fGoodData = 
        !m_strPoolName.IsEmpty() 
        && !m_strPoolId.IsEmpty()
        && IsUniqueId(m_strPoolId);
    GetDlgItem(IDOK)->EnableWindow(fGoodData);
}

BOOL 
CAddAppPoolDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();

    // Temporaly disable template relevant controls
    m_button_UseTemplate.EnableWindow(FALSE);
    m_combo_Template.EnableWindow(FALSE);

    CString def_pool;
    if (SUCCEEDED(m_pCont->QueryDefaultPoolId(def_pool)))
    {
        m_combo_Pool.SelectString(-1, def_pool);
    }
    POSITION pos = m_pool_list->GetHeadPosition();
    int sel_idx = CB_ERR;
    while (pos != NULL)
    {
        CAppPoolNode * pPool = m_pool_list->GetNext(pos);
        int i = m_combo_Pool.AddString(pPool->QueryDisplayName());
        if (def_pool.CompareNoCase(pPool->GetNodeName()) == 0)
        {
            sel_idx = i;
        }
        if (i != CB_ERR)
        {
            m_combo_Pool.SetItemDataPtr(i, pPool);
        }
    }
    if (sel_idx != CB_ERR)
    {
        m_combo_Pool.SetCurSel(sel_idx);
        CAppPoolNode * pPool = (CAppPoolNode *)m_combo_Pool.GetItemDataPtr(sel_idx);
        m_strPoolId = pPool->GetNodeName();
        MakeUniquePoolId(m_strPoolId);
        m_strPoolName = pPool->QueryDisplayName();
        MakeUniquePoolName(m_strPoolName);

        UpdateData(FALSE);
    }

    SetControlStates();

    return TRUE;
}

BOOL
CAddAppPoolDlg::IsUniqueId(CString& id) 
{
    BOOL bRes = TRUE;
    POSITION pos = m_pool_list->GetHeadPosition();
    while (pos != NULL)
    {
        CAppPoolNode * pPool = m_pool_list->GetNext(pos);
        if (id.CompareNoCase(pPool->GetNodeName()) == 0)
        {
            bRes = FALSE;
            break;
        }
    }
    return bRes;
}

void
CAddAppPoolDlg::MakeUniquePoolId(CString& id)
{
    TCHAR fmt[] = _T("%s-%d");
    CString unique;
    for (int n = 1; n < 100; n++)
    {
        unique.Format(fmt, id, n);
        if (IsUniqueId(unique))
            break;
    }
    id = unique;
}

void
CAddAppPoolDlg::MakeUniquePoolName(CString& name)
{
    TCHAR fmt[] = _T("%s %d");
    CString unique;
    for (int n = 1; n < 100; n++)
    {
        unique.Format(fmt, name, n);
        if (CB_ERR == m_combo_Pool.FindStringExact(-1, unique))
            break;
    }
    name = unique;
}
///////////////////////////////////////////////////////////////

HRESULT
CIISMBNode::AddAppPool(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      CAppPoolsContainer * pCont,
      CString& name
      )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    HRESULT hr = S_OK;

    IConsoleNameSpace2 * pConsole 
           = (IConsoleNameSpace2 *)GetOwner()->GetConsoleNameSpace();
    ASSERT(pConsole != NULL);
    HSCOPEITEM hChild = NULL, hCurrent;
    LONG_PTR cookie;
    hr = pConsole->Expand(pCont->QueryScopeItem());
    if (SUCCEEDED(hr))
    {
        pConsole->GetChildItem(pCont->QueryScopeItem(), &hChild, &cookie);
        CAppPoolNode * pPool;
        CPoolList pool_list;
        while (SUCCEEDED(hr) && hChild != NULL)
        {
            pPool = (CAppPoolNode *)cookie;
            ASSERT(pPool != NULL);
            pool_list.AddTail(pPool);
            hCurrent = hChild;
            hr = pConsole->GetNextItem(hCurrent, &hChild, &cookie);
        }
        CAddAppPoolDlg dlg(pCont, &pool_list, GetMainWindow());
        if (dlg.DoModal() == IDOK)
        {
            CComBSTR cont_path;
            pCont->BuildMetaPath(cont_path);
            CMetabasePath path(FALSE, cont_path, dlg.m_strPoolId);
            CIISAppPool pool(QueryAuthInfo(), path);
            if (SUCCEEDED(hr = pool.QueryResult()))
            {
                hr = pool.Create();
                if (SUCCEEDED(hr))
                {
                   name = dlg.m_strPoolId;
                   POSITION pos = pool_list.FindIndex(dlg.m_PoolIdx);
                   CMetabasePath model_path(FALSE, cont_path, 
                            pool_list.GetAt(pos)->GetNodeName());
                   CAppPoolProps model(QueryAuthInfo(), model_path);
                   if (SUCCEEDED(hr = model.LoadData()))
                   {
                       CAppPoolProps new_pool(QueryAuthInfo(), path);
                       // BUGBUG: Try to use base object CopyData() instead
                       new_pool.InitFromModel(model);
                       new_pool.m_strFriendlyName = dlg.m_strPoolName;
                       hr = new_pool.WriteDirtyProps();
                    }
                }
            }
        }
        else
        {
            hr = CError::HResult(ERROR_CANCELLED);
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\anondlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        anondlg.cpp

   Abstract:

        WWW Anonymous account dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "inetmgrapp.h"
//#include "supdlgs.h"
#include "anondlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CAnonymousDlg::CAnonymousDlg(
    IN CString & strServerName,
    IN CString & strUserName,
    IN CString & strPassword,
    IN BOOL & fPasswordSync,
    IN CWnd * pParent  OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    CString & strUserName       : User name
    CString & strPassword       : Password
    BOOL & fPasswordSync        : TRUE for password sync
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CAnonymousDlg::IDD, pParent),
      m_strServerName(strServerName),
      m_strUserName(strUserName),
      m_strPassword(strPassword),
      m_fPasswordSync(fPasswordSync),
      m_fPasswordSyncChanged(FALSE),
      m_fUserNameChanged(FALSE),
      m_fPasswordSyncMsgShown(FALSE)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CAnonymousDlg)
    m_strUserName = _T("");
    m_fPasswordSync = FALSE;
    //}}AFX_DATA_INIT

    m_strPassword = _T("");

#endif // 0

}


void 
CAnonymousDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAnonymousDlg)
    DDX_Check(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_fPasswordSync);
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_STATIC_USERNAME, m_static_Username);
    DDX_Control(pDX, IDC_STATIC_PASSWORD, m_static_Password);
    DDX_Control(pDX, IDC_STATIC_ANONYMOUS_LOGON, m_group_AnonymousLogon);
    DDX_Control(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_chk_PasswordSync);
    DDX_Control(pDX, IDC_BUTTON_CHECK_PASSWORD, m_button_CheckPassword);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
    DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_strUserName.TrimLeft();
    while (*m_strUserName == '\\')
    {
        m_strUserName = m_strUserName.Mid(2);
    }

    //
    // Display the remote password sync message if
    // password sync is on, the account is not local,
    // password sync has changed or username has changed
    // and the message hasn't already be shown.
    //
    if (pDX->m_bSaveAndValidate && m_fPasswordSync 
        && !IsLocalAccount(m_strUserName)
        && (m_fPasswordSyncChanged || m_fUserNameChanged)
        && !m_fPasswordSyncMsgShown
        )
    {
        if (::AfxMessageBox(
            IDS_WRN_PWSYNC, 
            MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION
            ) != IDYES)
        {
            pDX->Fail();
        }

        //
        // Don't show it again
        //
        m_fPasswordSyncMsgShown = TRUE;
    }

    if (!m_fPasswordSync || !pDX->m_bSaveAndValidate)
    {
        DDX_Password(
            pDX, 
            IDC_EDIT_PASSWORD, 
            m_strPassword, 
            g_lpszDummyPassword
            );
    }

    if (!m_fPasswordSync)
    {
        DDV_MaxChars(pDX, m_strPassword, PWLEN);
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CAnonymousDlg, CDialog)
    //{{AFX_MSG_MAP(CAnonymousDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, OnCheckEnablePwSynchronization)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_BASIC_DOMAIN, OnItemChanged)

END_MESSAGE_MAP()



void
CAnonymousDlg::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_Password.EnableWindow(!m_fPasswordSync);
    m_edit_Password.EnableWindow(!m_fPasswordSync);
    m_button_CheckPassword.EnableWindow(!m_fPasswordSync);
}


//
// Message Handlers
// 
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


BOOL 
CAnonymousDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    SetControlStates();
    
    return TRUE;  
}


void
CAnonymousDlg::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CAnonymousDlg::OnButtonBrowseUsers()
/*++

Routine Description:

    User browse dialog pressed, bring up
    the user browser

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(m_strServerName, this, str))
    {
        //
        // If the name is non-local (determined by having
        // a slash in the name, password sync is disabled,
        // and a password should be entered.
        //
        m_edit_UserName.SetWindowText(str);
        if (!(m_fPasswordSync = IsLocalAccount(str)))
        {
            m_edit_Password.SetWindowText(_T(""));
            m_edit_Password.SetFocus();
        }

        m_chk_PasswordSync.SetCheck(m_fPasswordSync);
        OnItemChanged();
    }
}


void 
CAnonymousDlg::OnButtonCheckPassword() 
/*++

Routine Description:

    Check password button has been pressed.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(CComAuthInfo::VerifyUserPassword(m_strUserName, m_strPassword));
    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}



void
CAnonymousDlg::OnCheckEnablePwSynchronization()
/*++

Routine Description:

    Handler for 'enable password synchronization' checkbox press

Arguments:

    None

Return Value:

    None

--*/
{
    m_fPasswordSyncChanged = TRUE;
    m_fPasswordSync = !m_fPasswordSync;
    OnItemChanged();
    SetControlStates();
    if (!m_fPasswordSync )
    {
        m_edit_Password.SetSel(0,-1);
        m_edit_Password.SetFocus();
    }
}




void 
CAnonymousDlg::OnChangeEditUsername() 
/*++

Routine description:

    Handler for 'username' edit box change messages

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUserNameChanged = TRUE;
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\app_pool_sheet.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_pool_sheet.cpp

   Abstract:
        Application Pools Property Sheet and Pages

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/16/2000         sergeia           Initial creation

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "iisobj.h"
#include "app_pool_sheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#define TIMESPAN_MIN          (int)1
#define TIMESPAN_MAX          (int)(4000000)
#define REQUESTS_MIN          (int)1
#define REQUESTS_MAX          (int)(4000000)
#define MEMORY_MIN            (int)1
#define MEMORY_MAX            (int)(4000000)
#define TIMEOUT_MIN           (int)1
#define TIMEOUT_MAX           (int)(4000000)
#define QUEUESIZE_MIN         (int)0
#define QUEUESIZE_MAX         (int)(4000000)
#define REFRESH_TIME_MIN      (int)1
#define REFRESH_TIME_MAX      (int)(4000000)
#define MAXPROCESSES_MIN      (int)1
#define MAXPROCESSES_MAX      (int)(4000000)
#define PING_INTERVAL_MIN     (int)1
#define PING_INTERVAL_MAX     (int)(4000000)
#define CRASHES_COUNT_MIN     (int)1
#define CRASHES_COUNT_MAX     (int)(4000000)
#define CHECK_INTERVAL_MIN    (int)1
#define CHECK_INTERVAL_MAX    (int)(4000000)
#define STARTUP_LIMIT_MIN     (int)1
#define STARTUP_LIMIT_MAX     (int)(4000000)
#define SHUTDOWN_LIMIT_MIN    (int)1
#define SHUTDOWN_LIMIT_MAX    (int)(4000000)
#define CPU_LIMIT_MIN         (int)0
#define CPU_LIMIT_MAX         (int)100
#define CPU_RESET_TIME_MIN    (int)0
#define CPU_RESET_TIME_MAX    (int)60

#define IDENT_TYPE_LOCALSYSTEM      0
#define IDENT_TYPE_LOCALSERVICE     1
#define IDENT_TYPE_NETWORKSERVICE   2
#define IDENT_TYPE_CONFIGURABLE     3

#define PERIODIC_RESTART_TIME_DEF      60
#define PERIODIC_RESTART_REQ_DEF       10000
#define MEMORY_DEF                     1            // In MB
#define IDLE_TIMEOUT_DEF               10
#define QUEUE_SIZE_DEF                 3000
#define CPU_USE_DEF                    10000
#define CPU_RESET_TIME_DEF             5
#define ACTION_INDEX_DEF               IDENT_TYPE_NETWORKSERVICE
#define MAX_PROCESSES_DEF              1
#define PING_INTERVAL_DEF              120
#define CRASHES_COUNT_DEF              5
#define CHECK_INTERVAL_DEF             10
#define STARTUP_LIMIT_DEF              30
#define SHUTDOWN_LIMIT_DEF             60

/////////////////////////////////////////////////////////////////////////////
// CAppPoolProps implementation

CAppPoolProps::CAppPoolProps(
   CComAuthInfo * pAuthInfo, LPCTSTR meta_path
   )
   : CMetaProperties(pAuthInfo, meta_path)
{
   InitDefaults();
}

CAppPoolProps::CAppPoolProps(
   CMetaInterface * pInterface, LPCTSTR meta_path
   )
   : CMetaProperties(pInterface, meta_path)
{
   InitDefaults();
}

CAppPoolProps::CAppPoolProps(
   CMetaKey * pKey, LPCTSTR meta_path
   )
   : CMetaProperties(pKey, meta_path)
{
   InitDefaults();
}

void
CAppPoolProps::ParseFields()
{
   BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
     HANDLE_META_RECORD(MD_APPPOOL_FRIENDLY_NAME,                    m_strFriendlyName)
     HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_TIME,            m_dwPeriodicRestartTime)
     HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_SCHEDULE,        m_RestartSchedule)
     HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT,   m_dwRestartRequestCount)
     HANDLE_META_RECORD(MD_APPPOOL_PERIODIC_RESTART_MEMORY,          m_dwPeriodicRestartMemory)

     HANDLE_META_RECORD(MD_APPPOOL_IDLE_TIMEOUT,                     m_dwIdleTimeout)
     HANDLE_META_RECORD(MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH,          m_dwQueueSize)
     HANDLE_META_RECORD(MD_CPU_RESET_INTERVAL,                       m_dwRefreshTime)
     HANDLE_META_RECORD(MD_APPPOOL_MAX_PROCESS_COUNT,                m_dwMaxProcesses)
     HANDLE_META_RECORD(MD_CPU_LIMIT,                                m_dwMaxCPU_Use)
     HANDLE_META_RECORD(MD_CPU_ACTION,                               m_ActionIndex)

     HANDLE_META_RECORD(MD_APPPOOL_PINGING_ENABLED,                  m_fDoEnablePing)
     HANDLE_META_RECORD(MD_APPPOOL_PING_INTERVAL,                    m_dwPingInterval)
     HANDLE_META_RECORD(MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED,    m_fDoEnableRapidFail)
     HANDLE_META_RECORD(MD_RAPID_FAIL_PROTECTION_MAX_CRASHES,        m_dwCrashesCount)
     HANDLE_META_RECORD(MD_RAPID_FAIL_PROTECTION_INTERVAL,           m_dwCheckInterval)
     HANDLE_META_RECORD(MD_APPPOOL_STARTUP_TIMELIMIT,                m_dwStartupLimit)
     HANDLE_META_RECORD(MD_APPPOOL_SHUTDOWN_TIMELIMIT,               m_dwShutdownLimit)

     HANDLE_META_RECORD(MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING,   m_fDoEnableDebug)
     HANDLE_META_RECORD(MD_APPPOOL_ORPHAN_ACTION,                    m_DebuggerFileName)

     HANDLE_META_RECORD(MD_APPPOOL_IDENTITY_TYPE,                    m_dwIdentType)
     HANDLE_META_RECORD(MD_WAM_USER_NAME,                            m_strUserName)
     HANDLE_META_RECORD(MD_WAM_PWD,                                  m_strUserPass)
   END_PARSE_META_RECORDS
}

/* virtual */
HRESULT
CAppPoolProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    BEGIN_META_WRITE()
       META_WRITE(MD_APPPOOL_FRIENDLY_NAME,                    m_strFriendlyName)
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_TIME,            m_dwPeriodicRestartTime)
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_SCHEDULE,        m_RestartSchedule)
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT,   m_dwRestartRequestCount)
       META_WRITE(MD_APPPOOL_PERIODIC_RESTART_MEMORY,          m_dwPeriodicRestartMemory)

       META_WRITE(MD_APPPOOL_IDLE_TIMEOUT,                     m_dwIdleTimeout)
       META_WRITE(MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH,          m_dwQueueSize)
       META_WRITE(MD_CPU_RESET_INTERVAL,                       m_dwRefreshTime)
       META_WRITE(MD_APPPOOL_MAX_PROCESS_COUNT,                m_dwMaxProcesses)
       META_WRITE(MD_CPU_LIMIT,                                m_dwMaxCPU_Use)
       META_WRITE(MD_CPU_ACTION,                               m_ActionIndex)

       META_WRITE(MD_APPPOOL_PINGING_ENABLED,                  m_fDoEnablePing)
       META_WRITE(MD_APPPOOL_PING_INTERVAL,                    m_dwPingInterval)
       META_WRITE(MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED,    m_fDoEnableRapidFail)
	   META_WRITE(MD_RAPID_FAIL_PROTECTION_MAX_CRASHES,        m_dwCrashesCount)
       META_WRITE(MD_RAPID_FAIL_PROTECTION_INTERVAL,           m_dwCheckInterval)
       META_WRITE(MD_APPPOOL_STARTUP_TIMELIMIT,                m_dwStartupLimit)
       META_WRITE(MD_APPPOOL_SHUTDOWN_TIMELIMIT,               m_dwShutdownLimit)
       META_WRITE(MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING,   m_fDoEnableDebug)
       META_WRITE(MD_APPPOOL_ORPHAN_ACTION,                    m_DebuggerFileName)
       META_WRITE(MD_APPPOOL_IDENTITY_TYPE,                    m_dwIdentType)
       META_WRITE(MD_WAM_USER_NAME,                            m_strUserName)
       META_WRITE(MD_WAM_PWD,                                  m_strUserPass)
    END_META_WRITE(err);

    return err;
}

void
CAppPoolProps::InitDefaults()
{
   m_dwPeriodicRestartTime    = PERIODIC_RESTART_TIME_DEF;
   m_dwRestartRequestCount    = PERIODIC_RESTART_REQ_DEF;
   m_dwPeriodicRestartMemory  = 0;       //???
   m_dwIdleTimeout            = IDLE_TIMEOUT_DEF;
   m_dwQueueSize              = QUEUE_SIZE_DEF;
   m_dwMaxCPU_Use             = CPU_USE_DEF;
   m_dwRefreshTime            = CPU_RESET_TIME_DEF;
   m_ActionIndex              = ACTION_INDEX_DEF;
   m_dwMaxProcesses           = MAX_PROCESSES_DEF;
   m_fDoEnablePing            = TRUE;
   m_dwPingInterval           = PING_INTERVAL_DEF;
   m_fDoEnableRapidFail       = TRUE;
   m_dwCrashesCount           = CRASHES_COUNT_DEF;
   m_dwCheckInterval          = CHECK_INTERVAL_DEF;
   m_dwStartupLimit           = STARTUP_LIMIT_DEF;
   m_dwShutdownLimit          = SHUTDOWN_LIMIT_DEF;
   m_fDoEnableDebug           = FALSE;
   m_dwIdentType              = IDENT_TYPE_LOCALSYSTEM;
}

void
CAppPoolProps::InitFromModel(CAppPoolProps& model)
{
   m_dwPeriodicRestartTime = model.m_dwPeriodicRestartTime;
   m_dwRestartRequestCount = model.m_dwRestartRequestCount;
   m_dwPeriodicRestartMemory = model.m_dwPeriodicRestartMemory;
   m_RestartSchedule = model.m_RestartSchedule;
   m_dwIdleTimeout = model.m_dwIdleTimeout;
   m_dwQueueSize = model.m_dwQueueSize;
   m_dwMaxCPU_Use = model.m_dwMaxCPU_Use;
   m_dwRefreshTime = model.m_dwRefreshTime;
   m_ActionIndex = model.m_ActionIndex;
   m_dwMaxProcesses = model.m_dwMaxProcesses;
   m_fDoEnablePing = model.m_fDoEnablePing;
   m_dwPingInterval = model.m_dwPingInterval;
   m_fDoEnableRapidFail = model.m_fDoEnableRapidFail;
   m_dwCrashesCount = model.m_dwCrashesCount;
   m_dwCheckInterval = model.m_dwCheckInterval;
   m_dwStartupLimit = model.m_dwStartupLimit;
   m_dwShutdownLimit = model.m_dwShutdownLimit;
   m_fDoEnableDebug = model.m_fDoEnableDebug;
   m_DebuggerFileName = model.m_DebuggerFileName;
   m_dwIdentType = model.m_dwIdentType;
   m_strUserName = model.m_strUserName;
   m_strUserPass = model.m_strUserPass;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CAppPoolSheet, CInetPropertySheet)

CAppPoolSheet::CAppPoolSheet(
      CComAuthInfo * pAuthInfo,
      LPCTSTR lpszMetaPath,
      CWnd * pParentWnd,
      LPARAM lParam,
      LONG_PTR handle,
      UINT iSelectPage
      )
      : CInetPropertySheet(
         pAuthInfo, lpszMetaPath, pParentWnd, lParam, handle, iSelectPage),
      m_pprops(NULL)
{
   CString last;
   CMetabasePath::GetLastNodeName(lpszMetaPath, last);
   SetIsMasterInstance(last.CompareNoCase(SZ_MBN_APP_POOLS) == 0);
}

CAppPoolSheet::~CAppPoolSheet()
{
   FreeConfigurationParameters();
}

HRESULT
CAppPoolSheet::LoadConfigurationParameters()
{
   //
   // Load base properties
   //
   CError err;

   if (m_pprops == NULL)
   {
      //
      // First call -- load values
      //
      m_pprops = new CAppPoolProps(QueryAuthInfo(), QueryMetaPath());
      if (!m_pprops)
      {
         TRACEEOLID("LoadConfigurationParameters: OOM");
         err = ERROR_NOT_ENOUGH_MEMORY;
         return err;
      }
      err = m_pprops->LoadData();
      if (IsMasterInstance())
      {
         CAppPoolsContainer * pObject = (CAppPoolsContainer *)GetParameter();
         m_pprops->m_strFriendlyName = pObject->QueryDisplayName();
      }
   }
   
   return err;
}

void
CAppPoolSheet::FreeConfigurationParameters()
{
   CInetPropertySheet::FreeConfigurationParameters();
   delete m_pprops;
}

BEGIN_MESSAGE_MAP(CAppPoolSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CAppPoolSheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolGeneral, CInetPropertyPage)

CAppPoolGeneral::CAppPoolGeneral(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolGeneral::IDD, pSheet)
{
}

CAppPoolGeneral::~CAppPoolGeneral()
{
}

/* virtual */
HRESULT
CAppPoolGeneral::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_strFriendlyName);
      FETCH_INST_DATA_FROM_SHEET(m_strTemplateName);
   END_META_INST_READ(err)

   if (IsMasterInstance())
   {
      m_fUseTemplate = FALSE;
   }
   else
   {
      m_fUseTemplate = !m_strTemplateName.IsEmpty();
   }

   return S_OK;
}

/* virtual */
HRESULT
CAppPoolGeneral::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   if (m_fUseTemplate)
   {
      m_Templates.GetLBText(m_TemplateIndex, m_strTemplateName);
   }
   else
   {
      m_strTemplateName.Empty();
   }
   BEGIN_META_INST_WRITE(CAppPoolSheet)
      STORE_INST_DATA_ON_SHEET(m_strTemplateName)
      if (!IsMasterInstance())
      {
         STORE_INST_DATA_ON_SHEET(m_strFriendlyName)
      }
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolGeneral::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolGeneral)
   DDX_Control(pDX, IDC_FRIENDLY_NAME, m_edit_FriendlyName);
   DDX_Text(pDX, IDC_FRIENDLY_NAME, m_strFriendlyName);
   DDX_Control(pDX, IDC_USE_TEMPLATE, m_btn_UseTemplate);
   DDX_Control(pDX, IDC_USE_CUSTOM, m_btn_UseCustom);
   DDX_Control(pDX, IDC_TEMPLATE_LIST, m_Templates);
   DDX_CBIndex(pDX, IDC_TEMPLATE_LIST, m_TemplateIndex);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppPoolGeneral, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolGeneral)
    ON_BN_CLICKED(IDC_USE_TEMPLATE, OnUseTemplate)
    ON_BN_CLICKED(IDC_USE_CUSTOM, OnUseCustom)
    ON_EN_CHANGE(IDC_FRIENDLY_NAME, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_TEMPLATE_LIST, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolGeneral::OnInitDialog()
{
   CInetPropertyPage::OnInitDialog();

   m_edit_FriendlyName.EnableWindow(!IsMasterInstance());
   m_btn_UseTemplate.EnableWindow(!IsMasterInstance());
   m_Templates.EnableWindow(m_fUseTemplate);
   if (m_fUseTemplate)
   {
      int idx = m_Templates.FindStringExact(-1, m_strTemplateName);
      if (CB_ERR != idx)
      {
         m_Templates.SetCurSel(idx);
      }
      else
      {
         ASSERT(FALSE);    // TODO: should we switch off the flag?
      }
   }
   m_btn_UseTemplate.SetCheck(m_fUseTemplate);
   m_btn_UseCustom.SetCheck(!m_fUseTemplate);

   return TRUE;
}

void
CAppPoolGeneral::OnUseTemplate()
{
   m_fUseTemplate = m_btn_UseTemplate.GetCheck();
   m_btn_UseTemplate.SetCheck(m_fUseTemplate);
   m_btn_UseCustom.SetCheck(!m_fUseTemplate);
   SetModified(TRUE);
}

void
CAppPoolGeneral::OnUseCustom()
{
   m_fUseTemplate = m_btn_UseCustom.GetCheck();
   m_btn_UseTemplate.SetCheck(m_fUseTemplate);
   m_btn_UseCustom.SetCheck(m_fUseTemplate);
   SetModified(TRUE);
}

void
CAppPoolGeneral::OnItemChanged()
{
   SetModified(TRUE);
}

//////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolRecycle, CInetPropertyPage)

CAppPoolRecycle::CAppPoolRecycle(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolRecycle::IDD, pSheet),
    m_fDoRestartOnTime(FALSE),
    m_fDoRestartOnCount(FALSE),
    m_fDoRestartOnSchedule(FALSE),
    m_fDoRestartOnMemory(FALSE)
{
   m_dwPeriodicRestartMemory = 0;
}

CAppPoolRecycle::~CAppPoolRecycle()
{
}

/* virtual */
HRESULT
CAppPoolRecycle::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_dwPeriodicRestartTime);
      FETCH_INST_DATA_FROM_SHEET(m_dwRestartRequestCount);
      FETCH_INST_DATA_FROM_SHEET(m_RestartSchedule);
      FETCH_INST_DATA_FROM_SHEET(m_dwPeriodicRestartMemory);
   END_META_INST_READ(err)

   m_fDoRestartOnTime = m_dwPeriodicRestartTime != 0;
   if (!m_fDoRestartOnTime)
   {
       m_dwPeriodicRestartTime = PERIODIC_RESTART_TIME_DEF;
   }
   m_fDoRestartOnCount = m_dwRestartRequestCount != 0;
   if (!m_fDoRestartOnCount)
   {
       m_dwRestartRequestCount = PERIODIC_RESTART_REQ_DEF;
   }
   m_fDoRestartOnSchedule = m_RestartSchedule.GetCount() > 0;
   m_fDoRestartOnMemory = m_dwPeriodicRestartMemory != 0;
   if (!m_fDoRestartOnMemory)
   {
       m_dwPeriodicRestartMemoryDisplay = MEMORY_DEF;
   }
   else
   {
       m_dwPeriodicRestartMemoryDisplay = m_dwPeriodicRestartMemory / 1024;
   }

   return err;
}

/* virtual */
HRESULT
CAppPoolRecycle::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   int count = m_lst_Schedule.GetCount();
   TCHAR buf[32];
   SYSTEMTIME tm;
   ::GetSystemTime(&tm);
   m_RestartSchedule.RemoveAll();
   if (m_fDoRestartOnSchedule)
   {
      for (int i = 0; i < count; i++)
      {
         DWORD data = (DWORD)m_lst_Schedule.GetItemData(i);
         tm.wMinute = LOWORD(data);
         tm.wHour = HIWORD(data);
         ::GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
               TIME_NOSECONDS | TIME_FORCE24HOURFORMAT,
               &tm, _T("hh':'mm"), buf, 32);
         m_RestartSchedule.AddTail(buf);
      }
   }
   DWORD d;
   CStringListEx list;
   BEGIN_META_INST_WRITE(CAppPoolSheet)
      d = m_dwPeriodicRestartTime; 
      if (!m_fDoRestartOnTime) 
         m_dwPeriodicRestartTime = 0;
      STORE_INST_DATA_ON_SHEET(m_dwPeriodicRestartTime)
      m_dwPeriodicRestartTime = d;
      d = m_dwRestartRequestCount;
      if (!m_fDoRestartOnCount)
         m_dwRestartRequestCount = 0;
      STORE_INST_DATA_ON_SHEET(m_dwRestartRequestCount)
      m_dwRestartRequestCount = d;
      list = m_RestartSchedule;
      if (!m_fDoRestartOnSchedule)
         m_RestartSchedule.RemoveAll();
      STORE_INST_DATA_ON_SHEET(m_RestartSchedule)
      m_RestartSchedule = list;
      m_dwPeriodicRestartMemory = m_dwPeriodicRestartMemoryDisplay * 1024;
      if (!m_fDoRestartOnMemory)
         m_dwPeriodicRestartMemory = 0;
      STORE_INST_DATA_ON_SHEET(m_dwPeriodicRestartMemory)
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolRecycle::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolRecycle)
   DDX_Check(pDX, IDC_RECYCLE_TIMESPAN, m_fDoRestartOnTime);
   DDX_Control(pDX, IDC_RECYCLE_TIMESPAN, m_bnt_DoRestartOnTime);
   DDX_Text(pDX, IDC_TIMESPAN, m_dwPeriodicRestartTime);
   DDV_MinMaxInt(pDX, m_dwPeriodicRestartTime, TIMESPAN_MIN, TIMESPAN_MAX);
   DDX_Control(pDX, IDC_TIMESPAN, m_Timespan);
   DDX_Control(pDX, IDC_TIMESPAN_SPIN, m_TimespanSpin);
   DDX_Check(pDX, IDC_RECYCLE_REQUESTS, m_fDoRestartOnCount);
   DDX_Control(pDX, IDC_RECYCLE_REQUESTS, m_btn_DoRestartOnCount);
   DDX_Text(pDX, IDC_REQUEST_LIMIT, m_dwRestartRequestCount);
   DDV_MinMaxInt(pDX, m_dwRestartRequestCount, REQUESTS_MIN, REQUESTS_MAX);
   DDX_Control(pDX, IDC_REQUEST_LIMIT, m_Requests);
   DDX_Control(pDX, IDC_REQUESTS_SPIN, m_RequestsSpin);
   DDX_Check(pDX, IDC_RECYCLE_TIMER, m_fDoRestartOnSchedule);
   DDX_Control(pDX, IDC_RECYCLE_TIMER, m_btn_DoRestartOnSchedule);
   DDX_Control(pDX, IDC_TIMES_LIST, m_lst_Schedule);
   DDX_Control(pDX, IDC_ADD_TIME, m_btn_Add);
   DDX_Control(pDX, IDC_DELETE_TIME, m_btn_Remove);
   DDX_Control(pDX, IDC_CHANGE_TIME, m_btn_Edit);
   DDX_Check(pDX, IDC_RECYCLE_MEMORY, m_fDoRestartOnMemory);
   DDX_Control(pDX, IDC_RECYCLE_MEMORY, m_btn_DoRestartOnMemory);
   DDX_Text(pDX, IDC_MEMORY_LIMIT, m_dwPeriodicRestartMemoryDisplay);
   DDV_MinMaxInt(pDX, m_dwPeriodicRestartMemoryDisplay, MEMORY_MIN, MEMORY_MAX);
   DDX_Control(pDX, IDC_MEMORY_LIMIT, m_MemoryLimit);
   DDX_Control(pDX, IDC_MEMORY_SPIN, m_MemoryLimitSpin);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppPoolRecycle, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolRecycle)
    ON_WM_COMPAREITEM()
    ON_WM_MEASUREITEM()
    ON_WM_DRAWITEM()
    ON_BN_CLICKED(IDC_RECYCLE_TIMESPAN, OnDoRestartOnTime)
    ON_BN_CLICKED(IDC_RECYCLE_REQUESTS, OnDoRestartOnCount)
    ON_BN_CLICKED(IDC_RECYCLE_TIMER, OnDoRestartOnSchedule)
    ON_BN_CLICKED(IDC_RECYCLE_MEMORY, OnDoRestartOnMemory)
    ON_BN_CLICKED(IDC_ADD_TIME, OnAddTime)
    ON_BN_CLICKED(IDC_DELETE_TIME, OnDeleteTime)
    ON_BN_CLICKED(IDC_CHANGE_TIME, OnChangeTime)
    ON_EN_CHANGE(IDC_TIMESPAN, OnItemChanged)
    ON_EN_CHANGE(IDC_REQUEST_LIMIT, OnItemChanged)
    ON_EN_CHANGE(IDC_MEMORY_LIMIT, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolRecycle::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();

   m_Timespan.EnableWindow(m_fDoRestartOnTime);
   m_TimespanSpin.EnableWindow(m_fDoRestartOnTime);
   m_TimespanSpin.SetRange32(TIMESPAN_MIN,TIMESPAN_MAX);
   m_TimespanSpin.SetPos(m_dwPeriodicRestartTime);
   m_TimespanSpin.SetAccel(3, toAcc);
//   SETUP_EDIT_SPIN(m_fDoRestartOnTime, m_Timespan, m_TimespanSpin, 
//      TIMESPAN_MIN, TIMESPAN_MAX, m_dwPeriodicRestartTime);
   SETUP_EDIT_SPIN(m_fDoRestartOnCount, m_Requests, m_RequestsSpin, 
      REQUESTS_MIN, REQUESTS_MAX, m_dwRestartRequestCount);
   SETUP_EDIT_SPIN(m_fDoRestartOnMemory, m_MemoryLimit, m_MemoryLimitSpin, 
      MEMORY_MIN, MEMORY_MAX, m_dwPeriodicRestartMemoryDisplay);

   POSITION pos = m_RestartSchedule.GetHeadPosition();
   while (pos != NULL)
   {
      CString& str = m_RestartSchedule.GetNext(pos);
      int n = str.Find(_T(':'));
      int len = str.GetLength();
      WORD h = (WORD)StrToInt(str.Left(n));
      WORD m = (WORD)StrToInt(str.Right(len - n - 1));
      m_lst_Schedule.AddString((LPCTSTR)UIntToPtr(MAKELONG(m, h)));
   }
   m_lst_Schedule.SetCurSel(0);

   SetControlsState();

   return TRUE;
}

void
CAppPoolRecycle::SetControlsState()
{
   m_Timespan.EnableWindow(m_fDoRestartOnTime);
   m_TimespanSpin.EnableWindow(m_fDoRestartOnTime);

   m_Requests.EnableWindow(m_fDoRestartOnCount);
   m_RequestsSpin.EnableWindow(m_fDoRestartOnCount);

   m_MemoryLimit.EnableWindow(m_fDoRestartOnMemory);
   m_MemoryLimitSpin.EnableWindow(m_fDoRestartOnMemory);

   m_lst_Schedule.EnableWindow(m_fDoRestartOnSchedule);
   m_btn_Add.EnableWindow(m_fDoRestartOnSchedule);
   int idx = m_lst_Schedule.GetCurSel();
   m_btn_Remove.EnableWindow(m_fDoRestartOnSchedule && idx != LB_ERR);
   m_btn_Edit.EnableWindow(m_fDoRestartOnSchedule && idx != LB_ERR);
}

void
CAppPoolRecycle::OnItemChanged()
{
    SetModified(TRUE);
}

int
CAppPoolRecycle::OnCompareItem(UINT nID, LPCOMPAREITEMSTRUCT cmpi)
{
   if (nID == IDC_TIMES_LIST)
   {
      ASSERT(cmpi->CtlType == ODT_LISTBOX);
      if (cmpi->itemData1 > cmpi->itemData2)
         return 1;
      else if (cmpi->itemData1 == cmpi->itemData2)
         return 0;
      else
         return -1;
   }
   ASSERT(FALSE);
   return 0;
}

void
CAppPoolRecycle::OnMeasureItem(UINT nID, LPMEASUREITEMSTRUCT mi)
{
   if (nID == IDC_TIMES_LIST)
   {
      HWND hwnd = ::GetDlgItem(m_hWnd, IDC_TIMES_LIST);
      HDC hdc = ::GetDC(hwnd);
      HFONT hFont = (HFONT)SendDlgItemMessage(IDC_TIMES_LIST, WM_GETFONT, 0, 0);
      HFONT hf = (HFONT)::SelectObject(hdc, hFont);
      TEXTMETRIC tm;
      ::GetTextMetrics(hdc, &tm);
      ::SelectObject(hdc, hf);
      ::ReleaseDC(hwnd, hdc);
      RECT rc;
      ::GetClientRect(hwnd, &rc);
      mi->itemHeight = tm.tmHeight;
      mi->itemWidth = rc.right - rc.left;
   }
}

void
CAppPoolRecycle::OnDrawItem(UINT nID, LPDRAWITEMSTRUCT di)
{
   if (nID == IDC_TIMES_LIST && di->itemID != -1)
   {
      SYSTEMTIME tm;
      ::GetSystemTime(&tm);
      tm.wMinute = LOWORD(di->itemData);
      tm.wHour = HIWORD(di->itemData);
      TCHAR buf[32];
      TCHAR fmt[] = _T("HH:mm");
      ::GetTimeFormat(NULL /*LOCALE_SYSTEM_DEFAULT*/, TIME_NOSECONDS, &tm, fmt, buf, 32);

      HBRUSH hBrush;
	   COLORREF prevText;
	   COLORREF prevBk;
      switch (di->itemAction) 
      { 
      case ODA_SELECT: 
      case ODA_DRAWENTIRE: 
         if (di->itemState & ODS_SELECTED) 
         {
            hBrush = ::CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
            prevText = ::SetTextColor(di->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            prevBk = ::SetBkColor(di->hDC, GetSysColor(COLOR_HIGHLIGHT));
         }
         else
         {
            hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
            prevText = ::SetTextColor(di->hDC, GetSysColor(COLOR_WINDOWTEXT));
            prevBk = ::SetBkColor(di->hDC, GetSysColor(COLOR_WINDOW));
         }
         ::FillRect(di->hDC, &di->rcItem, hBrush);
         ::DrawText(di->hDC, buf, -1, &di->rcItem, DT_LEFT | DT_VCENTER | DT_EXTERNALLEADING);
         ::SetTextColor(di->hDC, prevText);
         ::SetTextColor(di->hDC, prevBk);
         ::DeleteObject(hBrush);
         break; 
       
      case ODA_FOCUS: 
         break; 
      } 
   }
}

void
CAppPoolRecycle::OnDoRestartOnTime()
{
   m_fDoRestartOnTime = !m_fDoRestartOnTime;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolRecycle::OnDoRestartOnCount()
{
   m_fDoRestartOnCount = !m_fDoRestartOnCount;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolRecycle::OnDoRestartOnSchedule()
{
   m_fDoRestartOnSchedule = !m_fDoRestartOnSchedule;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolRecycle::OnDoRestartOnMemory()
{
   m_fDoRestartOnMemory = !m_fDoRestartOnMemory;
   SetControlsState();
   SetModified(TRUE);
}

class CTimePickerDlg : public CDialog
{
   DECLARE_DYNCREATE(CTimePickerDlg)

public:
   CTimePickerDlg()
      : CDialog(CTimePickerDlg::IDD),
      m_TopLeft(0, 0)
   {
   }
   ~CTimePickerDlg()
   {
   }
   void SetTime(CTime& tm)
   {
      m_time = tm;
   }
   CTime& GetTime()
   {
      return m_time;
   }
   void SetPos(const CPoint& pt)
   {
      m_TopLeft = pt;
   }

//
// Dialog Data
//
protected:
   //{{AFX_DATA(CTimePickerDlg)
   enum {IDD = IDD_TIME_PICKER};
   CDateTimeCtrl m_Timer;
   CTime m_time;
   //}}AFX_DATA
   CPoint m_TopLeft;

   //{{AFX_MSG(CTimePickerDlg)
   BOOL OnInitDialog();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

protected:
    //{{AFX_VIRTUAL(CTimePickerDlg)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
};

void
CTimePickerDlg::DoDataExchange(CDataExchange * pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolRecycle)
   DDX_DateTimeCtrl(pDX, IDC_TIME_PICKER, m_time);
   DDX_Control(pDX, IDC_TIME_PICKER, m_Timer);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CTimePickerDlg, CDialog)
    //{{AFX_MSG_MAP(CTimePickerDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

IMPLEMENT_DYNCREATE(CTimePickerDlg, CDialog)

BOOL
CTimePickerDlg::OnInitDialog()
{
   CDialog::OnInitDialog();

   m_Timer.SetFormat(_T("HH:mm"));
   m_Timer.SetTime(&m_time);
   SetWindowPos(NULL, m_TopLeft.x, m_TopLeft.y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);

   return TRUE;
}

void
CAppPoolRecycle::OnAddTime()
{
   CTimePickerDlg dlg;
   RECT rc;
   m_btn_Add.GetWindowRect(&rc);
   dlg.SetPos(CPoint(rc.left, rc.bottom));
   dlg.SetTime(CTime::GetCurrentTime());
   if (dlg.DoModal() == IDOK)
   {
      int idx;
      CTime tm = dlg.GetTime();
      LONG_PTR l = (LONG_PTR)MAKELONG(tm.GetMinute(), tm.GetHour());
      if ((idx = m_lst_Schedule.FindString(-1, (LPCTSTR)l)) == LB_ERR)
      {
         idx = m_lst_Schedule.AddString((LPCTSTR)l);
         m_lst_Schedule.SetCurSel(idx);
         m_btn_Edit.EnableWindow(idx != LB_ERR);
         m_btn_Remove.EnableWindow(idx != LB_ERR);
      }
      else
         m_lst_Schedule.SetCurSel(idx);
      SetModified(TRUE);
   }
}

void
CAppPoolRecycle::OnChangeTime()
{
   CTimePickerDlg dlg;
   RECT rc;
   m_btn_Edit.GetWindowRect(&rc);
   dlg.SetPos(CPoint(rc.left, rc.bottom));
   int idx = m_lst_Schedule.GetCurSel();
   LONG l = (LONG)m_lst_Schedule.GetItemData(idx);
   // Looks like we have to init the struct properly
   SYSTEMTIME tm;
   ::GetSystemTime(&tm);
   tm.wMinute = LOWORD(l);
   tm.wHour = HIWORD(l);
   tm.wSecond = 0;
   dlg.SetTime(CTime(tm));
   if (dlg.DoModal() == IDOK)
   {
      CTime t = dlg.GetTime();
      LONG_PTR ll = (LONG_PTR)MAKELONG(t.GetMinute(), t.GetHour());
      m_lst_Schedule.SetItemData(idx, ll);
      m_lst_Schedule.GetItemRect(idx, &rc);
      m_lst_Schedule.InvalidateRect(&rc, TRUE);
      SetModified(TRUE);
   }
}

void
CAppPoolRecycle::OnDeleteTime()
{
   int idx = m_lst_Schedule.GetCurSel();
   int count;
   if (idx != LB_ERR)
   {
      m_lst_Schedule.DeleteString(idx);
      SetModified(TRUE);
      if ((count = m_lst_Schedule.GetCount()) == 0)
      {
         m_btn_Remove.EnableWindow(FALSE);
         m_btn_Edit.EnableWindow(FALSE);
      }
      else
      {
         m_lst_Schedule.SetCurSel(idx == count ? --idx : idx);
      }
   }
}

//////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolPerf, CInetPropertyPage)

CAppPoolPerf::CAppPoolPerf(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolPerf::IDD, pSheet),
    m_fDoIdleShutdown(FALSE),
    m_dwIdleTimeout(IDLE_TIMEOUT_DEF),
    m_fDoLimitQueue(FALSE),
    m_dwQueueSize(QUEUE_SIZE_DEF),
    m_fDoEnableCPUAccount(FALSE),
    m_dwMaxCPU_Use(CPU_USE_DEF),
    m_dwRefreshTime(CPU_RESET_TIME_DEF),
    m_ActionIndex(ACTION_INDEX_DEF),
    m_dwMaxProcesses(MAX_PROCESSES_DEF)
{
}

CAppPoolPerf::~CAppPoolPerf()
{
}

/* virtual */
HRESULT
CAppPoolPerf::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_dwIdleTimeout);
      FETCH_INST_DATA_FROM_SHEET(m_dwQueueSize);
      FETCH_INST_DATA_FROM_SHEET(m_dwMaxCPU_Use);
      FETCH_INST_DATA_FROM_SHEET(m_dwRefreshTime);
      FETCH_INST_DATA_FROM_SHEET(m_dwMaxProcesses);
      FETCH_INST_DATA_FROM_SHEET(m_ActionIndex);
   END_META_INST_READ(err)

   m_dwMaxCPU_UseVisual = m_dwMaxCPU_Use / 1000;

   m_fDoIdleShutdown = m_dwIdleTimeout != 0;
   if (!m_fDoIdleShutdown)
   {
       m_dwIdleTimeout = IDLE_TIMEOUT_DEF;
   }
   m_fDoLimitQueue = m_dwQueueSize != 0;
   if (!m_fDoLimitQueue)
   {
       m_dwQueueSize = QUEUE_SIZE_DEF;
   }
   m_fDoEnableCPUAccount = m_dwRefreshTime > 0;
   if (!m_fDoEnableCPUAccount)
   {
       m_dwMaxCPU_UseVisual = CPU_USE_DEF;
       m_dwRefreshTime = CPU_RESET_TIME_DEF;
       m_ActionIndex = ACTION_INDEX_DEF;
   }

   return err;
}

/* virtual */
HRESULT
CAppPoolPerf::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   m_dwMaxCPU_Use = m_dwMaxCPU_UseVisual * 1000;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      if (!m_fDoIdleShutdown) 
         m_dwIdleTimeout = 0;
      if (!m_fDoLimitQueue)
         m_dwQueueSize = 0;
      if (!m_fDoEnableCPUAccount)
      {
         m_dwRefreshTime = 0;
         m_dwMaxCPU_Use = 0;
//         m_ActionIndex = -1;
      }
      STORE_INST_DATA_ON_SHEET(m_dwQueueSize)
      STORE_INST_DATA_ON_SHEET(m_dwIdleTimeout)
      STORE_INST_DATA_ON_SHEET(m_dwRefreshTime)
      STORE_INST_DATA_ON_SHEET(m_dwMaxCPU_Use)
      STORE_INST_DATA_ON_SHEET(m_ActionIndex)
      STORE_INST_DATA_ON_SHEET(m_dwMaxProcesses)
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolPerf::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolRecycle)
   DDX_Check(pDX, IDC_PERF_IDLE_TIMEOUT, m_fDoIdleShutdown);
   DDX_Control(pDX, IDC_PERF_IDLE_TIMEOUT, m_bnt_DoIdleShutdown);
   DDX_Text(pDX, IDC_IDLETIME, m_dwIdleTimeout);
   DDV_MinMaxInt(pDX, m_dwIdleTimeout, TIMEOUT_MIN, TIMEOUT_MAX);
   DDX_Control(pDX, IDC_IDLETIME, m_IdleTimeout);
   DDX_Control(pDX, IDC_IDLETIME_SPIN, m_IdleTimeoutSpin);

   DDX_Check(pDX, IDC_LIMIT_QUEUE, m_fDoLimitQueue);
   DDX_Control(pDX, IDC_LIMIT_QUEUE, m_btn_DoLimitQueue);
   DDX_Text(pDX, IDC_QUEUESIZE, m_dwQueueSize);
   DDV_MinMaxInt(pDX, m_dwQueueSize, QUEUESIZE_MIN, QUEUESIZE_MAX); 
   DDX_Control(pDX, IDC_QUEUESIZE, m_QueueSize);
   DDX_Control(pDX, IDC_QUEUESIZE_SPIN, m_QueueSizeSpin);

   DDX_Check(pDX, IDC_ENABLE_CPU_ACCOUNTING, m_fDoEnableCPUAccount);
   DDX_Control(pDX, IDC_ENABLE_CPU_ACCOUNTING, m_btn_DoEnableCPUAccount);
   DDX_Text(pDX, IDC_CPU_USE, m_dwMaxCPU_UseVisual);
   DDV_MinMaxInt(pDX, m_dwMaxCPU_UseVisual, CPU_LIMIT_MIN, CPU_LIMIT_MAX); 
   DDX_Control(pDX, IDC_CPU_USE, m_MaxCPU_Use);
   DDX_Control(pDX, IDC_CPU_USE_SPIN, m_MaxCPU_UseSpin);
   DDX_Text(pDX, IDC_REFRESHTIME, m_dwRefreshTime);
   DDV_MinMaxInt(pDX, m_dwRefreshTime, CPU_RESET_TIME_MIN, CPU_RESET_TIME_MAX);
   DDX_Control(pDX, IDC_REFRESHTIME, m_RefreshTime);
   DDX_Control(pDX, IDC_REFRESHTIME_SPIN, m_RefreshTimeSpin);
   DDX_Control(pDX, IDC_EXCEED_ACTION, m_Action);
   DDX_CBIndex(pDX, IDC_EXCEED_ACTION, m_ActionIndex);

   DDX_Text(pDX, IDC_MAXPROCESSES, m_dwMaxProcesses);
   DDV_MinMaxInt(pDX, m_dwMaxProcesses, MAXPROCESSES_MIN, MAXPROCESSES_MAX);
   DDX_Control(pDX, IDC_MAXPROCESSES, m_MaxProcesses);
   DDX_Control(pDX, IDC_MAXPROCESSES_SPIN, m_MaxProcessesSpin);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppPoolPerf, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolRecycle)
    ON_BN_CLICKED(IDC_PERF_IDLE_TIMEOUT, OnDoIdleShutdown)
    ON_BN_CLICKED(IDC_LIMIT_QUEUE, OnDoLimitQueue)
    ON_BN_CLICKED(IDC_ENABLE_CPU_ACCOUNTING, OnDoEnableCPUAccount)
    ON_EN_CHANGE(IDC_IDLETIME, OnItemChanged)
    ON_EN_CHANGE(IDC_QUEUESIZE, OnItemChanged)
    ON_EN_CHANGE(IDC_CPU_USE, OnItemChanged)
    ON_EN_CHANGE(IDC_REFRESHTIME, OnItemChanged)
    ON_EN_CHANGE(IDC_MAXPROCESSES, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_EXCEED_ACTION, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolPerf::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();

   SETUP_EDIT_SPIN(m_fDoIdleShutdown, m_IdleTimeout, m_IdleTimeoutSpin, 
      TIMEOUT_MIN, TIMEOUT_MAX, m_dwIdleTimeout);
   SETUP_EDIT_SPIN(m_fDoLimitQueue, m_QueueSize, m_QueueSizeSpin, 
      QUEUESIZE_MIN, QUEUESIZE_MAX, m_dwQueueSize);
   m_dwMaxCPU_UseVisual = m_dwMaxCPU_Use / 1000;
   SETUP_EDIT_SPIN(m_fDoEnableCPUAccount, m_MaxCPU_Use, m_MaxCPU_UseSpin, 
      CPU_LIMIT_MIN, CPU_LIMIT_MAX, m_dwMaxCPU_UseVisual);
   SETUP_EDIT_SPIN(m_fDoEnableCPUAccount, m_RefreshTime, m_RefreshTimeSpin, 
      REFRESH_TIME_MIN, REFRESH_TIME_MAX, m_dwRefreshTime);
   SETUP_SPIN(m_MaxProcessesSpin, 
      MAXPROCESSES_MIN, MAXPROCESSES_MAX, m_dwMaxProcesses);

   CString str;
   str.LoadString(IDS_NO_ACTION);
   m_Action.AddString(str);
//   str.LoadString(IDS_THROTTLE_BACK);
//   m_Action.AddString(str);
   str.LoadString(IDS_TURN_ON_TRACING);
   m_Action.AddString(str);
   str.LoadString(IDS_SHUTDOWN);
   m_Action.AddString(str);
   if (m_ActionIndex < 0 || m_ActionIndex > 3)
       m_ActionIndex = ACTION_INDEX_DEF; 
   m_Action.SetCurSel(m_ActionIndex);

   SetControlsState();

   return TRUE;
}

void
CAppPoolPerf::OnDoIdleShutdown()
{
   m_fDoIdleShutdown = !m_fDoIdleShutdown;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolPerf::OnDoLimitQueue()
{
   m_fDoLimitQueue = !m_fDoLimitQueue;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolPerf::OnDoEnableCPUAccount()
{
   m_fDoEnableCPUAccount = !m_fDoEnableCPUAccount;
   SetControlsState();
   SetModified(TRUE);
}

void
CAppPoolPerf::OnItemChanged()
{
    SetModified(TRUE);
}

void
CAppPoolPerf::SetControlsState()
{
   m_bnt_DoIdleShutdown.SetCheck(m_fDoIdleShutdown);
   m_IdleTimeout.EnableWindow(m_fDoIdleShutdown);
   m_IdleTimeoutSpin.EnableWindow(m_fDoIdleShutdown);

   m_btn_DoLimitQueue.SetCheck(m_fDoLimitQueue);
   m_QueueSize.EnableWindow(m_fDoLimitQueue);
   m_QueueSizeSpin.EnableWindow(m_fDoLimitQueue);

   m_btn_DoEnableCPUAccount.SetCheck(m_fDoEnableCPUAccount);
   m_MaxCPU_Use.EnableWindow(m_fDoEnableCPUAccount);
   m_MaxCPU_UseSpin.EnableWindow(m_fDoEnableCPUAccount);
   m_RefreshTime.EnableWindow(m_fDoEnableCPUAccount);
   m_RefreshTimeSpin.EnableWindow(m_fDoEnableCPUAccount);
   m_Action.EnableWindow(m_fDoEnableCPUAccount);
}

/////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolHealth, CInetPropertyPage)

CAppPoolHealth::CAppPoolHealth(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolHealth::IDD, pSheet),
    m_fDoEnablePing(FALSE),
    m_dwPingInterval(PING_INTERVAL_DEF),
    m_fDoEnableRapidFail(FALSE),
    m_dwCrashesCount(CRASHES_COUNT_DEF),
    m_dwCheckInterval(CHECK_INTERVAL_DEF),
    m_dwStartupLimit(STARTUP_LIMIT_DEF),
    m_dwShutdownLimit(SHUTDOWN_LIMIT_DEF)
{
}

CAppPoolHealth::~CAppPoolHealth()
{
}

/* virtual */
HRESULT
CAppPoolHealth::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_fDoEnablePing);
      FETCH_INST_DATA_FROM_SHEET(m_dwPingInterval);
      FETCH_INST_DATA_FROM_SHEET(m_fDoEnableRapidFail);
      FETCH_INST_DATA_FROM_SHEET(m_dwCrashesCount);
      FETCH_INST_DATA_FROM_SHEET(m_dwCheckInterval);
      FETCH_INST_DATA_FROM_SHEET(m_dwStartupLimit);
      FETCH_INST_DATA_FROM_SHEET(m_dwShutdownLimit);
   END_META_INST_READ(err)

   return err;
}

/* virtual */
HRESULT
CAppPoolHealth::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      STORE_INST_DATA_ON_SHEET(m_fDoEnablePing);
      STORE_INST_DATA_ON_SHEET(m_dwPingInterval);
      STORE_INST_DATA_ON_SHEET(m_fDoEnableRapidFail);
      STORE_INST_DATA_ON_SHEET(m_dwCrashesCount);
      STORE_INST_DATA_ON_SHEET(m_dwCheckInterval);
      STORE_INST_DATA_ON_SHEET(m_dwStartupLimit);
      STORE_INST_DATA_ON_SHEET(m_dwShutdownLimit);
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolHealth::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolHealth)
   DDX_Check(pDX, IDC_ENABLE_PING, m_fDoEnablePing);
   DDX_Control(pDX, IDC_ENABLE_PING, m_bnt_DoEnablePing);
   DDX_Text(pDX, IDC_PINGINTERVAL, m_dwPingInterval);
   DDV_MinMaxInt(pDX, m_dwPingInterval, PING_INTERVAL_MIN, PING_INTERVAL_MAX);
   DDX_Control(pDX, IDC_PINGINTERVAL, m_PingInterval);
   DDX_Control(pDX, IDC_PINGINTERVAL_SPIN, m_PingIntervalSpin);

   DDX_Check(pDX, IDC_ENABLE_RAPID_FAIL, m_fDoEnableRapidFail);
   DDX_Control(pDX, IDC_ENABLE_RAPID_FAIL, m_btn_DoEnableRapidFail);
   DDX_Text(pDX, IDC_CRASHES_COUNT, m_dwCrashesCount);
   DDV_MinMaxInt(pDX, m_dwCrashesCount, CRASHES_COUNT_MIN, CRASHES_COUNT_MAX);
   DDX_Control(pDX, IDC_CRASHES_COUNT, m_CrashesCount);
   DDX_Control(pDX, IDC_CRASHES_COUNT_SPIN, m_CrashesCountSpin);
   DDX_Text(pDX, IDC_CHECK_TIME, m_dwCheckInterval);
   DDV_MinMaxInt(pDX, m_dwCheckInterval, CHECK_INTERVAL_MIN, CHECK_INTERVAL_MAX);
   DDX_Control(pDX, IDC_CHECK_TIME, m_CheckInterval);
   DDX_Control(pDX, IDC_CHECK_TIME_SPIN, m_CheckIntervalSpin);

   DDX_Text(pDX, IDC_STARTUP_LIMIT, m_dwStartupLimit);
   DDV_MinMaxInt(pDX, m_dwStartupLimit, STARTUP_LIMIT_MIN, STARTUP_LIMIT_MAX);
   DDX_Control(pDX, IDC_STARTUP_LIMIT, m_StartupLimit);
   DDX_Control(pDX, IDC_STARTUP_LIMIT_SPIN, m_StartupLimitSpin);

   DDX_Text(pDX, IDC_SHUTDOWN_LIMIT, m_dwShutdownLimit);
   DDV_MinMaxInt(pDX, m_dwShutdownLimit, SHUTDOWN_LIMIT_MIN, SHUTDOWN_LIMIT_MAX);
   DDX_Control(pDX, IDC_SHUTDOWN_LIMIT, m_ShutdownLimit);
   DDX_Control(pDX, IDC_SHUTDOWN_LIMIT_SPIN, m_ShutdownLimitSpin);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppPoolHealth, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolHealth)
    ON_BN_CLICKED(IDC_ENABLE_PING, OnDoEnablePinging)
    ON_BN_CLICKED(IDC_ENABLE_RAPID_FAIL, OnDoEnableRapidFail)
    ON_EN_CHANGE(IDC_PINGINTERVAL, OnItemChanged)
    ON_EN_CHANGE(IDC_CRASHES_COUNT, OnItemChanged)
    ON_EN_CHANGE(IDC_CHECK_TIME, OnItemChanged)
    ON_EN_CHANGE(IDC_STARTUP_LIMIT, OnItemChanged)
    ON_EN_CHANGE(IDC_SHUTDOWN_LIMIT, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolHealth::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();

   SETUP_EDIT_SPIN(m_fDoEnablePing, m_PingInterval, m_PingIntervalSpin, 
      PING_INTERVAL_MIN, PING_INTERVAL_MAX, m_dwPingInterval);
   SETUP_EDIT_SPIN(m_fDoEnableRapidFail, m_CrashesCount, m_CrashesCountSpin, 
      CRASHES_COUNT_MIN, CRASHES_COUNT_MAX, m_dwCrashesCount);
   SETUP_EDIT_SPIN(m_fDoEnableRapidFail, m_CheckInterval, m_CheckIntervalSpin, 
      CHECK_INTERVAL_MIN, CHECK_INTERVAL_MAX, m_dwCheckInterval);
   SETUP_SPIN(m_StartupLimitSpin, 
      STARTUP_LIMIT_MIN, STARTUP_LIMIT_MAX, m_dwStartupLimit);
   SETUP_SPIN(m_ShutdownLimitSpin, 
      SHUTDOWN_LIMIT_MIN, SHUTDOWN_LIMIT_MAX, m_dwShutdownLimit);

   return TRUE;
}

void
CAppPoolHealth::OnDoEnablePinging()
{
   m_fDoEnablePing = !m_fDoEnablePing;
   m_bnt_DoEnablePing.SetCheck(m_fDoEnablePing);
   m_PingInterval.EnableWindow(m_fDoEnablePing);
   m_PingIntervalSpin.EnableWindow(m_fDoEnablePing);
   SetModified(TRUE);
}

void
CAppPoolHealth::OnDoEnableRapidFail()
{
   m_fDoEnableRapidFail = !m_fDoEnableRapidFail;
   m_btn_DoEnableRapidFail.SetCheck(m_fDoEnableRapidFail);
   m_CrashesCount.EnableWindow(m_fDoEnableRapidFail);
   m_CrashesCountSpin.EnableWindow(m_fDoEnableRapidFail);
   m_CheckInterval.EnableWindow(m_fDoEnableRapidFail);
   m_CheckIntervalSpin.EnableWindow(m_fDoEnableRapidFail);
   SetModified(TRUE);
}

void
CAppPoolHealth::OnItemChanged()
{
   SetModified(TRUE);
}

///////////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolDebug, CInetPropertyPage)

CAppPoolDebug::CAppPoolDebug(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolDebug::IDD, pSheet),
    m_fDoEnableDebug(TRUE)
{
}

CAppPoolDebug::~CAppPoolDebug()
{
}

/* virtual */
HRESULT
CAppPoolDebug::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_fDoEnableDebug);
      FETCH_INST_DATA_FROM_SHEET(m_DebuggerFileName);
   END_META_INST_READ(err)

   return err;
}

/* virtual */
HRESULT
CAppPoolDebug::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      STORE_INST_DATA_ON_SHEET(m_fDoEnableDebug);
      STORE_INST_DATA_ON_SHEET(m_DebuggerFileName);
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolDebug::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolHealth)
   DDX_Check(pDX, IDC_ENABLE_DEBUG, m_fDoEnableDebug);
   DDX_Control(pDX, IDC_ENABLE_DEBUG, m_bnt_DoEnableDebug);
   DDX_Text(pDX, IDC_FILE_NAME, m_DebuggerFileName);
   DDX_Control(pDX, IDC_FILE_NAME, m_FileName);
   DDX_Control(pDX, IDC_BROWSE, m_Browse);
   //}}AFX_DATA_MAP
   if (pDX->m_bSaveAndValidate)
   {
       CError err;
       if (!PathIsValid(m_DebuggerFileName))
       {
          ::AfxMessageBox(IDS_ERR_BAD_PATH);
          pDX->PrepareEditCtrl(IDC_FILE_NAME);
          pDX->Fail();
       }
       else if (GetSheet()->IsLocal())
       {
           if (!PathFileExists(m_DebuggerFileName))
           {
              err = ERROR_FILE_NOT_FOUND;
           }
       }
   }
}

BEGIN_MESSAGE_MAP(CAppPoolDebug, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolHealth)
    ON_BN_CLICKED(IDC_ENABLE_DEBUG, OnDoEnableDebug)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_FILE_NAME, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolDebug::OnInitDialog()
{
   CInetPropertyPage::OnInitDialog();

   if (m_DebuggerFileName.IsEmpty())
      m_fDoEnableDebug = FALSE;

   SetControlState();

   return TRUE;
}

void
CAppPoolDebug::SetControlState()
{
   m_bnt_DoEnableDebug.SetCheck(m_fDoEnableDebug);
   m_FileName.EnableWindow(m_fDoEnableDebug);
   m_Browse.EnableWindow(m_fDoEnableDebug);
}

void
CAppPoolDebug::OnItemChanged()
{
   SetModified(TRUE);
}

void
CAppPoolDebug::OnDoEnableDebug()
{
   m_fDoEnableDebug = !m_fDoEnableDebug;
   m_bnt_DoEnableDebug.SetCheck(m_fDoEnableDebug);
   m_FileName.EnableWindow(m_fDoEnableDebug);
   m_Browse.EnableWindow(m_fDoEnableDebug);
   SetModified(TRUE);
}

void
CAppPoolDebug::OnBrowse()
{
    CString mask((LPCTSTR)IDS_DEBUG_EXEC_MASK);

    //
    // CODEWORK: Derive a class from CFileDialog that allows
    // the setting of the initial path
    //

    //CString strPath;
    //m_edit_Executable.GetWindowText(strPath);

    CFileDialog dlgBrowse(
        TRUE, 
        NULL, 
        NULL, 
        OFN_HIDEREADONLY, 
        mask, 
        this
        );
    // Disable hook to get Windows 2000 style dialog
	dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

    if (dlgBrowse.DoModal() == IDOK)
    {
        m_FileName.SetWindowText(dlgBrowse.GetPathName());
    }

    OnItemChanged();
}

/////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CAppPoolIdent, CInetPropertyPage)

CAppPoolIdent::CAppPoolIdent(CInetPropertySheet * pSheet)
    : CInetPropertyPage(CAppPoolIdent::IDD, pSheet),
    m_fPredefined(FALSE)
{
}

CAppPoolIdent::~CAppPoolIdent()
{
}

/* virtual */
HRESULT
CAppPoolIdent::FetchLoadedValues()
{
   CError err;

   BEGIN_META_INST_READ(CAppPoolSheet)
      FETCH_INST_DATA_FROM_SHEET(m_dwIdentType);
      FETCH_INST_DATA_FROM_SHEET(m_strUserName);
      FETCH_INST_DATA_FROM_SHEET(m_strUserPass);
   END_META_INST_READ(err)

   m_fPredefined = m_dwIdentType != IDENT_TYPE_CONFIGURABLE;
   switch (m_dwIdentType)
   {
   case IDENT_TYPE_LOCALSYSTEM:
      m_PredefIndex = 0;
      break;
   case IDENT_TYPE_LOCALSERVICE:
      m_PredefIndex = 1;
      break;
   case IDENT_TYPE_NETWORKSERVICE:
      m_PredefIndex = 2;
      break;
   default:
      m_PredefIndex = -1;
      break;
   }

   return err;
}

/* virtual */
HRESULT
CAppPoolIdent::SaveInfo()
{
   ASSERT(IsDirty());
   CError err;

   BEGIN_META_INST_WRITE(CAppPoolSheet)
      if (m_fPredefined)
      {
         m_dwIdentType = m_PredefIndex;
      }
      else
      {
         m_dwIdentType = IDENT_TYPE_CONFIGURABLE;
         STORE_INST_DATA_ON_SHEET(m_strUserName);
         STORE_INST_DATA_ON_SHEET(m_strUserPass);
      }
      STORE_INST_DATA_ON_SHEET(m_dwIdentType);
   END_META_INST_WRITE(err)

   return err;
}

void
CAppPoolIdent::SetControlState()
{
   m_bnt_Predefined.SetCheck(m_fPredefined);
   m_bnt_Configurable.SetCheck(!m_fPredefined);
   m_PredefList.EnableWindow(m_fPredefined);
   m_UserName.EnableWindow(!m_fPredefined);
   m_UserPass.EnableWindow(!m_fPredefined);
   m_Browse.EnableWindow(!m_fPredefined);
}

void
CAppPoolIdent::DoDataExchange(CDataExchange * pDX)
{
   CInetPropertyPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppPoolIdent)
   DDX_Control(pDX, IDC_PREDEFINED, m_bnt_Predefined);
   DDX_Control(pDX, IDC_CONFIGURABLE, m_bnt_Configurable);
   DDX_CBIndex(pDX, IDC_SYSTEM_ACCOUNTS, m_PredefIndex);
   DDX_Control(pDX, IDC_SYSTEM_ACCOUNTS, m_PredefList);
   DDX_Text(pDX, IDC_USER_NAME, m_strUserName);
   DDX_Control(pDX, IDC_USER_NAME, m_UserName);
   DDX_Control(pDX, IDC_BROWSE, m_Browse);
   DDX_Text(pDX, IDC_USER_PASS, m_strUserPass);
   DDX_Control(pDX, IDC_USER_PASS, m_UserPass);
   //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAppPoolIdent, CInetPropertyPage)
    //{{AFX_MSG_MAP(CAppPoolIdent)
    ON_BN_CLICKED(IDC_PREDEFINED, OnPredefined)
    ON_BN_CLICKED(IDC_CONFIGURABLE, OnPredefined)
    ON_BN_CLICKED(IDC_BROWSE, OnBrowse)
    ON_EN_CHANGE(IDC_USER_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_USER_PASS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_SYSTEM_ACCOUNTS, OnItemChanged)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL
CAppPoolIdent::OnInitDialog()
{
   CInetPropertyPage::OnInitDialog();

   CString buf;
   buf.LoadString(IDS_LOCALSYSTEM);
   m_PredefList.AddString(buf);
   buf.LoadString(IDS_LOCALSERVICE);
   m_PredefList.AddString(buf);
   buf.LoadString(IDS_NETSERVICE);
   m_PredefList.AddString(buf);
   if (!m_fPredefined)
   {
       m_PredefIndex = 0;
   }
   m_PredefList.SetCurSel(m_PredefIndex);

   SetControlState();

   return TRUE;
}

void
CAppPoolIdent::OnPredefined()
{
   m_fPredefined = !m_fPredefined;
   SetControlState();
   SetModified(TRUE);
}

void
CAppPoolIdent::OnBrowse()
{
   // User browser like in other places
   CString user;
   if (GetIUsrAccount(user))
   {
      if (user.CompareNoCase(m_strUserName) != 0)
      {
         m_strUserPass.Empty();
      }
      m_strUserName = user;
      UpdateData(FALSE);
   }
}

void
CAppPoolIdent::OnItemChanged()
{
   SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\app_pool_sheet.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_pool_sheet.h

   Abstract:
        Application Pool Property Sheet

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef _APP_POOL_SHEET_H
#define _APP_POOL_SHEET_H

class CAppPoolProps : public CMetaProperties
{
public:
   CAppPoolProps(CComAuthInfo * pAuthInfo, LPCTSTR meta_path);
   CAppPoolProps(CMetaInterface * pInterface, LPCTSTR meta_path);
   CAppPoolProps(CMetaKey * pInterface, LPCTSTR meta_path);

   virtual HRESULT WriteDirtyProps();
   void InitFromModel(CAppPoolProps& model);

protected:
   virtual void ParseFields();
   void InitDefaults();

public:
   MP_CString m_strFriendlyName;
   MP_CString m_strTemplateName;
   MP_DWORD m_dwPeriodicRestartTime;
   MP_DWORD m_dwRestartRequestCount;
   MP_DWORD m_dwPeriodicRestartMemory;       //???
   MP_CStringListEx m_RestartSchedule;
   MP_DWORD m_dwIdleTimeout;
   MP_DWORD m_dwQueueSize;
   MP_DWORD m_dwMaxCPU_Use;
   MP_DWORD m_dwRefreshTime;
   MP_DWORD m_ActionIndex;
   MP_DWORD m_dwMaxProcesses;
   MP_BOOL m_fDoEnablePing;
   MP_DWORD m_dwPingInterval;
   MP_BOOL m_fDoEnableRapidFail;
   MP_DWORD m_dwCrashesCount;
   MP_DWORD m_dwCheckInterval;
   MP_DWORD m_dwStartupLimit;
   MP_DWORD m_dwShutdownLimit;
   MP_BOOL  m_fDoEnableDebug;
   MP_CString m_DebuggerFileName;
   MP_DWORD m_dwIdentType;
   MP_CString m_strUserName;
   MP_CString m_strUserPass;
};


class CAppPoolSheet : public CInetPropertySheet
{
   DECLARE_DYNAMIC(CAppPoolSheet)

public:
   CAppPoolSheet(
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMetaPath,
        CWnd * pParentWnd  = NULL,
        LPARAM lParam = 0L,
        LONG_PTR handle = 0L,
        UINT iSelectPage = 0
        );

   virtual ~CAppPoolSheet();

public:
   // The following methods have predefined names to be compatible with
   // BEGIN_META_INST_READ and other macros.
   HRESULT QueryInstanceResult() const;
   CAppPoolProps & GetInstanceProperties() { return *m_pprops; }

   virtual HRESULT LoadConfigurationParameters();
   virtual void FreeConfigurationParameters();

   //{{AFX_MSG(CAppPoolSheet)
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

private:
   BOOL m_fUseTemplate;
   CAppPoolProps * m_pprops;
};


class CAppPoolGeneral : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolGeneral)

public:
   CAppPoolGeneral(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolGeneral();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolGeneral)
    enum { IDD = IDD_APP_POOL_GENERAL };
    CString m_strFriendlyName;
    CEdit m_edit_FriendlyName;
    CButton m_btn_UseTemplate;
    CButton m_btn_UseCustom;
    CComboBox m_Templates;
    int m_TemplateIndex;
    //}}AFX_DATA
    BOOL m_fUseTemplate;
    CString m_strTemplateName;

    //{{AFX_MSG(CAppPoolGeneral)
    virtual BOOL OnInitDialog();
    afx_msg void OnUseTemplate();
    afx_msg void OnUseCustom();
    afx_msg void OnItemChanged();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolGeneral)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

};

class CAppPoolRecycle : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolRecycle)

public:
   CAppPoolRecycle(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolRecycle();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolRecycle)
    enum { IDD = IDD_APP_POOL_RECYCLE };
    BOOL m_fDoRestartOnTime;
    CButton m_bnt_DoRestartOnTime;
    DWORD m_dwPeriodicRestartTime;
    CEdit m_Timespan;
    CSpinButtonCtrl m_TimespanSpin;
    BOOL m_fDoRestartOnCount;
    CButton m_btn_DoRestartOnCount;
    DWORD m_dwRestartRequestCount;
    CEdit m_Requests;
    CSpinButtonCtrl m_RequestsSpin;
    BOOL m_fDoRestartOnSchedule;
    CButton m_btn_DoRestartOnSchedule;
    CListBox m_lst_Schedule;
    CButton m_btn_Add;
    CButton m_btn_Remove;
    CButton m_btn_Edit;
    BOOL m_fDoRestartOnMemory;
    CButton m_btn_DoRestartOnMemory;
    DWORD m_dwPeriodicRestartMemoryDisplay;
    CEdit m_MemoryLimit;
    CSpinButtonCtrl m_MemoryLimitSpin;
    //}}AFX_DATA
    CStringListEx m_RestartSchedule;
    DWORD m_dwPeriodicRestartMemory;

    //{{AFX_MSG(CAppPoolRecycle)
    virtual BOOL OnInitDialog();
    afx_msg int OnCompareItem(UINT nID, LPCOMPAREITEMSTRUCT cmpi);
    afx_msg void OnMeasureItem(UINT nID, LPMEASUREITEMSTRUCT mi);
    afx_msg void OnDrawItem(UINT nID, LPDRAWITEMSTRUCT di);
    afx_msg void OnDoRestartOnTime();
    afx_msg void OnDoRestartOnCount();
    afx_msg void OnDoRestartOnSchedule();
    afx_msg void OnDoRestartOnMemory();
    afx_msg void OnAddTime();
    afx_msg void OnDeleteTime();
    afx_msg void OnChangeTime();
    afx_msg void OnItemChanged();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolRecycle)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
    void SetControlsState();
};

class CAppPoolPerf : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolPerf)

public:
   CAppPoolPerf(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolPerf();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolPerf)
    enum { IDD = IDD_APP_POOL_PERF };
    BOOL m_fDoIdleShutdown;
    CButton m_bnt_DoIdleShutdown;
    DWORD m_dwIdleTimeout;
    CEdit m_IdleTimeout;
    CSpinButtonCtrl m_IdleTimeoutSpin;
    
    BOOL m_fDoLimitQueue;
    CButton m_btn_DoLimitQueue;
    DWORD m_dwQueueSize;
    CEdit m_QueueSize;
    CSpinButtonCtrl m_QueueSizeSpin;

    BOOL m_fDoEnableCPUAccount;
    CButton m_btn_DoEnableCPUAccount;
    DWORD m_dwMaxCPU_UseVisual;
    CEdit m_MaxCPU_Use;
    CSpinButtonCtrl m_MaxCPU_UseSpin;
    DWORD m_dwRefreshTime;
    CEdit m_RefreshTime;
    CSpinButtonCtrl m_RefreshTimeSpin;
    int m_ActionIndex;
    CComboBox m_Action;
    DWORD m_dwMaxProcesses;
    CEdit m_MaxProcesses;
    CSpinButtonCtrl m_MaxProcessesSpin;
    //}}AFX_DATA

    //{{AFX_MSG(CAppPoolPerf)
    virtual BOOL OnInitDialog();
    afx_msg void OnDoIdleShutdown();
    afx_msg void OnDoLimitQueue();
    afx_msg void OnDoEnableCPUAccount();
    afx_msg void OnItemChanged();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
    DWORD m_dwMaxCPU_Use;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
    void SetControlsState();

};


class CAppPoolHealth : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolHealth)

public:
   CAppPoolHealth(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolHealth();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolHealth)
    enum { IDD = IDD_APP_POOL_HEALTH };
    BOOL m_fDoEnablePing;
    CButton m_bnt_DoEnablePing;
    DWORD m_dwPingInterval;
    CEdit m_PingInterval;
    CSpinButtonCtrl m_PingIntervalSpin;
    
    BOOL m_fDoEnableRapidFail;
    CButton m_btn_DoEnableRapidFail;
    DWORD m_dwCrashesCount;
    CEdit m_CrashesCount;
    CSpinButtonCtrl m_CrashesCountSpin;
    DWORD m_dwCheckInterval;
    CEdit m_CheckInterval;
    CSpinButtonCtrl m_CheckIntervalSpin;

    DWORD m_dwStartupLimit;
    CEdit m_StartupLimit;
    CSpinButtonCtrl m_StartupLimitSpin;
    DWORD m_dwShutdownLimit;
    CEdit m_ShutdownLimit;
    CSpinButtonCtrl m_ShutdownLimitSpin;
    //}}AFX_DATA

    //{{AFX_MSG(CAppPoolPerf)
    virtual BOOL OnInitDialog();
    afx_msg void OnDoEnablePinging();
    afx_msg void OnDoEnableRapidFail();
    afx_msg void OnItemChanged();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

};

class CAppPoolDebug : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolDebug)

public:
   CAppPoolDebug(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolDebug();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolDebug)
    enum { IDD = IDD_APP_POOL_DEBUG };
    BOOL m_fDoEnableDebug;
    CButton m_bnt_DoEnableDebug;
    CString m_DebuggerFileName;
    CEdit m_FileName;
    CButton m_Browse;
    //}}AFX_DATA

    //{{AFX_MSG(CAppPoolPerf)
    virtual BOOL OnInitDialog();
    afx_msg void OnDoEnableDebug();
    afx_msg void OnBrowse();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    afx_msg void OnItemChanged();
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();
    void SetControlState();

};

class CAppPoolIdent : public CInetPropertyPage
{
   DECLARE_DYNCREATE(CAppPoolIdent)

public:
   CAppPoolIdent(CInetPropertySheet * pSheet = NULL);
   virtual ~CAppPoolIdent();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAppPoolIdent)
    enum { IDD = IDD_APP_POOL_IDENT };
    CButton m_bnt_Predefined;
    CButton m_bnt_Configurable;
    CComboBox m_PredefList;
    int m_PredefIndex;
    CString m_strUserName;
    CString m_strUserPass;
    CEdit m_UserName;
    CEdit m_UserPass;
    CButton m_Browse;
    //}}AFX_DATA
    BOOL m_fPredefined;
    DWORD m_dwIdentType;

    //{{AFX_MSG(CAppPoolPerf)
    virtual BOOL OnInitDialog();
    afx_msg void OnPredefined();
    afx_msg void OnBrowse();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CAppPoolPerf)
    virtual void DoDataExchange(CDataExchange * pDX);
    afx_msg void OnItemChanged();
    //}}AFX_VIRTUAL
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    void SetControlState();
};

//
// BUGBUG: Returns S_OK if object not present
//
inline HRESULT CAppPoolSheet::QueryInstanceResult() const 
{ 
    return m_pprops ? m_pprops->QueryResult() : S_OK;
}

#endif //_APP_POOL_SHEET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\add_app_pool.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_app_pool.h

   Abstract:
        Add new IIS Application Pool node classes

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        12/26/2000      sergeia     Initial creation

--*/
#ifndef _ADD_APP_POOL_H
#define _ADD_APP_POOL_H

class CAddAppPoolDlg : public CDialog
{
public:
    CAddAppPoolDlg(
        CAppPoolsContainer * pCont, 
        CPoolList * pools,
        CWnd * pParent = NULL);
    ~CAddAppPoolDlg();

public:
    //{{AFX_DATA(CAddAppPoolDlg)
    enum { IDD = IDD_ADD_APP_POOL };
    CEdit m_edit_PoolName;
    CString m_strPoolName;
    CEdit m_edit_PoolId;
    CString m_strPoolId;
    CButton m_button_UseTemplate;
    CButton m_button_UsePool;
    CComboBox m_combo_Template;
    CComboBox m_combo_Pool;
    int m_TemplateIdx;
    int m_PoolIdx;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddAppPoolDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddAppPoolDlg)
    afx_msg void OnButtonUseTemplate();
    afx_msg void OnButtonUsePool();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

    BOOL IsUniqueId(CString& id);
    void MakeUniquePoolId(CString& str);
    void MakeUniquePoolName(CString& str);

private:
    BOOL m_fUseTemplate;
    CAppPoolsContainer * m_pCont;
    CPoolList * m_pool_list;
};

#endif //_ADD_APP_POOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\anondlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        anondlg.h

   Abstract:

        WWW Anonymous account dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _ANONDLG_H_
#define _ANONDLG_H_




class CAnonymousDlg : public CDialog
/*++

Class Description:

    Anonymous authentication dialog

Public Interface:

    CAnonymousDlg       : Constructor

    GetUserName         : Get user name entered
    GetPassword         : Get password entered
    GetPasswordSync     : Get password sync entered

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CAnonymousDlg(
        IN CString & strServerName,
        IN CString & strUserName,
        IN CString & strPassword,
        IN BOOL & fPasswordSync,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    CString & GetUserName()  { return m_strUserName; }
    CString & GetPassword()  { return m_strPassword; }
    BOOL & GetPasswordSync() { return m_fPasswordSync; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAnonymousDlg)
    enum { IDD = IDD_ANONYMOUS };
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CStatic m_static_Username;
    CStatic m_static_Password;
    CButton m_button_CheckPassword;
    CButton m_group_AnonymousLogon;
    CButton m_chk_PasswordSync;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAnonymousDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CAnonymousDlg)
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnCheckEnablePwSynchronization();
    afx_msg void OnChangeEditUsername();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    void SetControlStates();

private:
    BOOL m_fPasswordSyncChanged;
    BOOL m_fPasswordSyncMsgShown;
    BOOL m_fUserNameChanged;
    BOOL m_fPasswordSync;
    CString m_strUserName;
    CString m_strPassword;
    CString & m_strServerName;
};



#endif // _ANONDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\authent.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        authent.cpp

   Abstract:
        WWW Authentication Dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "inetmgrapp.h"
#include "supdlgs.h"
#include "certmap.h"
#include "authent.h"
#define INITGUID
#include <initguid.h>
#include <dsclient.h>
#include <wincrui.h>
#include <Dsgetdc.h>
#include <Lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define HIDD_DOMAINACCTS		0x50334

CAuthenticationDlg::CAuthenticationDlg(
    IN LPCTSTR lpstrServerName, 
    IN DWORD   dwInstance,      
    IN CString & strBasicDomain,
    IN CString & strRealm,
    IN DWORD & dwAuthFlags,
    IN DWORD & dwAccessPermissions,
    IN CString & strUserName,
    IN CString & strPassword,
    IN BOOL & fPasswordSync,
    IN BOOL fAdminAccess,
    IN BOOL fHasDigest,
    IN CWnd * pParent           OPTIONAL
    )
/*++

Routine Description:

    Authentication dialog constructor

Arguments:

    LPCTSTR lpstrServerName     : Server name
    DWORD   dwInstance          : Instance number
    CString & strBasicDomain    : Basic domain name
    DWORD & dwAuthFlags         : Authorization flags
    DWORD & dwAccessPermissions : Access permissions
    CString & strUserName       : Anonymous user name
    CString & strPassword       : Anonymous user pwd
    BOOL & fPasswordSync        : Password sync setting
    BOOL fAdminAccess           : TRUE if user has admin access
    BOOL fHasDigest             : TRUE if machine supports digest auth.
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CAuthenticationDlg::IDD, pParent),
      m_strServerName(lpstrServerName),
      m_strBasicDomain(strBasicDomain),
      m_strRealm(strRealm),
      m_strUserName(strUserName),
      m_strPassword(strPassword),
      m_dwInstance(dwInstance),
      m_dwAuthFlags(dwAuthFlags),
      m_dwAccessPermissions(dwAccessPermissions),
      m_fAdminAccess(fAdminAccess),
      m_fHasDigest(fHasDigest),
      m_fPasswordSync(fPasswordSync),
      m_fPasswordSyncChanged(FALSE),
      m_fUserNameChanged(FALSE),
      m_fPasswordSyncMsgShown(FALSE),
      m_fChanged(FALSE),
      m_fInDomain(TRUE)
{
#if 0 // Class Wizard happy

    //{{AFX_DATA_INIT(CAuthenticationDlg)
    m_fClearText = FALSE;
    m_fDigest = FALSE;
    m_fChallengeResponse = FALSE;
    m_fAnonymous = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

    m_fClearText = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_BASIC);
    m_fDigest = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_MD5);
    m_fChallengeResponse = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_NT);
    m_fAnonymous = IS_FLAG_SET(m_dwAuthFlags, MD_AUTH_ANONYMOUS);
}


void 
CAuthenticationDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
{
	if (pDX->m_bSaveAndValidate && !m_fChanged)
    {
       return;
    }
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAuthenticationDlg)
    DDX_Control(pDX, IDC_CHECK_ANONYMOUS, m_check_Anonymous);
    DDX_Check(pDX, IDC_CHECK_ANONYMOUS, m_fAnonymous);
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Check(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_fPasswordSync);
    DDX_Control(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_chk_PasswordSync);
    DDX_Check(pDX, IDC_CHECK_CLEAR_TEXT, m_fClearText);
    DDX_Check(pDX, IDC_CHECK_DIGEST, m_fDigest);
    DDX_Check(pDX, IDC_CHECK_NT_CHALLENGE_RESPONSE, m_fChallengeResponse);
    DDX_Control(pDX, IDC_CHECK_NT_CHALLENGE_RESPONSE, m_check_ChallengeResponse);
    DDX_Control(pDX, IDC_CHECK_DIGEST, m_check_Digest);
    DDX_Control(pDX, IDC_CHECK_CLEAR_TEXT, m_check_ClearText);
    DDX_Control(pDX, IDC_BASDOM, m_edit_BasicDomain);
    DDX_Control(pDX, IDC_BASDOM_SELECT, m_btn_SelectDomain);
    DDX_Control(pDX, IDC_REALM, m_edit_Realm);
    DDX_Control(pDX, IDC_REALM_SELECT, m_btn_SelectRealm);
    //}}AFX_DATA_MAP
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
    DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);
    DDX_Text(pDX, IDC_BASDOM, m_strBasicDomain);
    DDX_Text(pDX, IDC_REALM, m_strRealm);
    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_strUserName.TrimLeft();
    while (*m_strUserName == '\\')
    {
        m_strUserName = m_strUserName.Mid(2);
    }

    //
    // Display the remote password sync message if
    // password sync is on, the account is not local,
    // password sync has changed or username has changed
    // and the message hasn't already be shown.
    //
	if (pDX->m_bSaveAndValidate)
	{
		BOOL bLocal;
		CString user, domain;
		CError err = CredUIParseUserName(
				m_strUserName, 
				user.GetBuffer(CRED_MAX_USERNAME_LENGTH), CRED_MAX_USERNAME_LENGTH,
				domain.GetBuffer(MAX_PATH), MAX_PATH);
		user.ReleaseBuffer();
		domain.ReleaseBuffer();
		bLocal = domain.IsEmpty() || domain.CompareNoCase(m_strServerName) == 0;
		if (m_fPasswordSync 
			&& !bLocal
			&& (m_fPasswordSyncChanged || m_fUserNameChanged)
			&& !m_fPasswordSyncMsgShown
			)
		{
			if (::AfxMessageBox(IDS_WRN_PWSYNC, MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION ) != IDYES)
			{
				pDX->Fail();
			}

			//
			// Don't show it again
			//
			m_fPasswordSyncMsgShown = TRUE;
		}
		// Convert to standard domain\user format
		if (!bLocal)
		{
			m_strUserName = domain;
			m_strUserName += _T('\\');
			m_strUserName += user;
		}
	}
	if (!m_fPasswordSync || !pDX->m_bSaveAndValidate)
	{
		DDX_Password(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
	}
	if (!m_fPasswordSync)
	{
		DDV_MaxChars(pDX, m_strPassword, PWLEN);
	}
	if (pDX->m_bSaveAndValidate)
	{
		m_fChanged = FALSE;
	}
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CAuthenticationDlg, CDialog)
    //{{AFX_MSG_MAP(CAuthenticationDlg)
    ON_BN_CLICKED(IDC_CHECK_ANONYMOUS, OnCheckAnonymous)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, OnCheckEnablePwSynchronization)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_CHECK_CLEAR_TEXT, OnCheckClearText)
    ON_BN_CLICKED(IDC_CHECK_DIGEST, OnCheckDigest)
    ON_BN_CLICKED(IDC_CHECK_NT_CHALLENGE_RESPONSE, OnItemChanged)
    ON_BN_CLICKED(IDC_BASDOM_SELECT, OnButtonSelectDomain)
    ON_BN_CLICKED(IDC_REALM_SELECT, OnButtonSelectRealm)
    //}}AFX_MSG_MAP
//    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME, OnItemChanged)
    ON_EN_CHANGE(IDC_BASDOM, OnItemChanged)
    ON_EN_CHANGE(IDC_REALM, OnItemChanged)
END_MESSAGE_MAP()

void
CAuthenticationDlg::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE and BN_CLICKED messages map to this function

--*/
{
   m_fChanged = TRUE;
   SetControlStates();
}

void
CAuthenticationDlg::SetControlStates()
/*++

Routine Description:
    Set control states depending on current data in the dialog

--*/
{
   m_edit_UserName.EnableWindow(m_fAnonymous);
   m_chk_PasswordSync.EnableWindow(m_fAnonymous);
   m_edit_Password.EnableWindow(!m_fPasswordSync && m_fAnonymous);
   m_edit_BasicDomain.EnableWindow(m_fClearText);
   m_btn_SelectDomain.EnableWindow(m_fClearText && m_fInDomain);
   m_edit_Realm.EnableWindow(m_fDigest || m_fClearText);
   m_btn_SelectRealm.EnableWindow((m_fDigest || m_fClearText) && m_fInDomain);
   GetDlgItem(IDC_BUTTON_BROWSE_USERS)->EnableWindow(m_fAnonymous);
}

BOOL 
CAuthenticationDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();
    
    SetControlStates();  

    //
    // Ensure compatibility with downlevel
    //
    m_check_Digest.EnableWindow(m_fHasDigest);

    // Check if computer is joined to domain
    COMPUTER_NAME_FORMAT fmt = ComputerNamePhysicalDnsDomain;
    TCHAR buf[MAX_PATH];
    DWORD n = MAX_PATH;
    m_fInDomain = (GetComputerNameEx(fmt, buf, &n) && n > 0);
    m_btn_SelectDomain.EnableWindow(m_fInDomain);
    m_btn_SelectRealm.EnableWindow(m_fInDomain);

    return TRUE;  
}

void 
CAuthenticationDlg::OnButtonBrowseUsers()
{
    CString str;

    if (GetIUsrAccount(m_strServerName, this, str))
    {
        //
        // If the name is non-local (determined by having
        // a slash in the name, password sync is disabled,
        // and a password should be entered.
        //
        m_edit_UserName.SetWindowText(str);
	    CString user, domain;
		CError err = CredUIParseUserName(str, 
			  user.GetBuffer(CRED_MAX_USERNAME_LENGTH), CRED_MAX_USERNAME_LENGTH,
			  domain.GetBuffer(MAX_PATH), MAX_PATH);
		user.ReleaseBuffer();
		domain.ReleaseBuffer();
		m_fPasswordSync = 
			  domain.IsEmpty() || domain.CompareNoCase(m_strServerName) == 0;
        if (!m_fPasswordSync)
        {
            m_edit_Password.SetWindowText(_T(""));
            m_edit_Password.SetFocus();
        }

        m_chk_PasswordSync.SetCheck(m_fPasswordSync);
        OnItemChanged();
    }
}

//GUID _CLSID_DsDomainTreeBrowser = {0x1698790a, 0xe2b4, 0x11d0, {0xb0, 0xb1, 0x00, 0xc0, 0x4f, 0xd8, 0xdc, 0xa6}};
//GUID _IID_IDsBrowseDomainTree = {0x7cabcf1e, 0x78f5, 0x11d2, {0x96, 0xc, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86}};

void CAuthenticationDlg::OnButtonSelectDomain()
{
    HRESULT hr = BrowseDomain(m_strBasicDomain);
    if (SUCCEEDED(hr))
    {
        UpdateData(FALSE);
    }
}

void CAuthenticationDlg::OnButtonSelectRealm()
{
    HRESULT hr = BrowseDomain(m_strRealm);
    if (SUCCEEDED(hr))
    {
        UpdateData(FALSE);
    }
}

HRESULT
CAuthenticationDlg::BrowseDomain(CString& domain)
{
   CString prev = domain;
   CComPtr<IDsBrowseDomainTree> spDsDomains;

   CError err = ::CoCreateInstance(CLSID_DsDomainTreeBrowser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsBrowseDomainTree,
                          reinterpret_cast<void **>(&spDsDomains));
   if (err.Succeeded())
   {
      err = spDsDomains->SetComputer(m_strServerName, NULL, NULL); // use default credential
      if (err.Succeeded())
      {
         LPTSTR pDomainPath = NULL;
         err = spDsDomains->BrowseTo(m_hWnd, &pDomainPath, 
            /*DBDTF_RETURNINOUTBOUND |*/ DBDTF_RETURNEXTERNAL | DBDTF_RETURNMIXEDDOMAINS);
         if (err.Succeeded() && pDomainPath != NULL)
         {
            domain = pDomainPath;
            if (domain.CompareNoCase(prev) != 0)
            {
               OnItemChanged();
            }
            CoTaskMemFree(pDomainPath);
         }
// When user click on Cancel in this browser, it returns 80070001 (Incorrect function). 
// I am not quite sure what does it mean. We are filtering out the case when domain browser doesn't
// work at all (in workgroup), so here we could safely skip error processing.
//         else
//         {
//            err.MessageBox();
//         }
      }
   }
   return err;
}

void
CAuthenticationDlg::OnCheckEnablePwSynchronization()
{
    m_fPasswordSyncChanged = TRUE;
    m_fPasswordSync = !m_fPasswordSync;
    OnItemChanged();
    SetControlStates();
    if (!m_fPasswordSync )
    {
        m_edit_Password.SetSel(0,-1);
        m_edit_Password.SetFocus();
    }
}

void 
CAuthenticationDlg::OnChangeEditUsername() 
{
    m_fUserNameChanged = TRUE;
    OnItemChanged();
}

void 
CAuthenticationDlg::OnCheckClearText() 
{
    if (m_check_ClearText.GetCheck() == 1)
    {
        CClearTxtDlg dlg;
        if (dlg.DoModal() != IDOK)
        {
            m_check_ClearText.SetCheck(0);
            return;
        }
    }

    m_fClearText = !m_fClearText;
    OnItemChanged();
    SetControlStates();
}



void 
CAuthenticationDlg::OnCheckDigest() 
{
    ASSERT(m_fHasDigest);

    if (m_check_Digest.GetCheck() == 1)
    {
		CString cap, msg;
		msg.LoadString(IDS_WRN_DIGEST);
		cap.LoadString(IDS_ROOT_NODE);
		if (IDNO == IisMessageBox(m_hWnd, IDS_WRN_DIGEST, MB_YESNO|MB_ICONQUESTION|MB_DEFBUTTON2, HIDD_DOMAINACCTS))
        {
            m_check_Digest.SetCheck(0);
            return;
        }
    }

    m_fDigest = !m_fDigest;
    OnItemChanged();
    SetControlStates();
}



void 
CAuthenticationDlg::OnCheckAnonymous() 
{
    m_fAnonymous = !m_fAnonymous;
    OnItemChanged();
    SetControlStates();
}

void 
CAuthenticationDlg::OnOK() 
{
    if (UpdateData(TRUE))
    {
        SET_FLAG_IF(m_fClearText, m_dwAuthFlags, MD_AUTH_BASIC);
        SET_FLAG_IF(m_fChallengeResponse, m_dwAuthFlags, MD_AUTH_NT);
        SET_FLAG_IF(m_fAnonymous, m_dwAuthFlags, MD_AUTH_ANONYMOUS);
        SET_FLAG_IF(m_fDigest, m_dwAuthFlags, MD_AUTH_MD5);

        //
        // Provide warning if no authentication is selected
        //
        if (!m_dwAuthFlags 
         && !m_dwAccessPermissions 
         && !NoYesMessageBox(IDS_WRN_NO_AUTH)
           )
        {
            //
            // Don't dismiss the dialog
            //
            return;
        }

        CDialog::OnOK();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\app_pools.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        app_pools.cpp

   Abstract:
        IIS Application Pools nodes

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/03/2000      sergeia     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "shts.h"
#include "app_pool_sheet.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

CAppPoolsContainer::CAppPoolsContainer(
      CIISMachine * pOwner,
      CIISService * pService
      )
    : CIISMBNode(pOwner, SZ_MBN_APP_POOLS),
      m_pWebService(pService)
{
   VERIFY(m_bstrDisplayName.LoadString(IDS_APP_POOLS));
}

CAppPoolsContainer::~CAppPoolsContainer()
{
}

/* static */ int 
CAppPoolsContainer::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_SERVICE_DESCRIPTION,
    IDS_RESULT_SERVICE_STATE,
};
    

/* static */ int 
CAppPoolsContainer::_rgnWidths[COL_TOTAL] =
{
    180,
    70,
};

/* virtual */ 
HRESULT 
CAppPoolsContainer::EnumerateScopePane(HSCOPEITEM hParent)
{
    CError  err;
    CMetaEnumerator * pme = NULL;
    CString strPool;

    err = CreateEnumerator(pme);
        
    while (err.Succeeded())
    {
        CAppPoolNode * pPool;

        err = pme->Next(strPool);

        if (err.Succeeded())
        {
            TRACEEOLID("Enumerating node: " << strPool);
            CString key_type;
            CMetabasePath path(FALSE, pme->QueryMetaPath(), strPool);
            CMetaKey mk(pme, path);
            mk.QueryValue(MD_KEY_TYPE, key_type);
            if (mk.Succeeded() && 0 == key_type.CompareNoCase(_T("IIsApplicationPool")))
            {
                if (NULL == (pPool = new CAppPoolNode(m_pOwner, this, strPool)))
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                err = pPool->AddToScopePane(hParent);
            }
        }
    }

    SAFE_DELETE(pme);

    if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
    {
        err.Reset();
    }

    if (err.Failed())
    {
        DisplayError(err);
    }

    SetInterfaceError(err);

    return err;
}

HRESULT
CAppPoolsContainer::EnumerateAppPools(CPoolList * pList)
{
    CError  err;
    CMetaEnumerator * pme = NULL;
    CString strPool;

    err = CreateEnumerator(pme);
        
    while (err.Succeeded())
    {
        err = pme->Next(strPool);
        if (err.Succeeded())
        {
            CString key_type;
            CMetabasePath path(FALSE, pme->QueryMetaPath(), strPool);
            CMetaKey mk(pme, path);
            mk.QueryValue(MD_KEY_TYPE, key_type);
            if (mk.Succeeded() && 0 == key_type.CompareNoCase(_T("IIsApplicationPool")))
            {
                CAppPoolNode * pPool;
                if (NULL == (pPool = new CAppPoolNode(m_pOwner, this, strPool)))
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                pList->AddTail(pPool);
            }
        }
    }
    SAFE_DELETE(pme);

    if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
    {
        err.Reset();
    }

    return err;
}

/* virtual */
void 
CAppPoolsContainer::InitializeChildHeaders(
    IN LPHEADERCTRL lpHeader
    )
/*++

Routine Description:

    Build result view for immediate descendant type

Arguments:

    LPHEADERCTRL lpHeader      : Header control

Return Value:

    None

--*/
{
   CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
}

/* virtual */
HRESULT
CAppPoolsContainer::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
   AFX_MANAGE_STATE(::AfxGetStaticModuleState());

   CError  err;
   CComBSTR path;

   err = BuildMetaPath(path);
   if (err.Failed())
      return err;

   CAppPoolSheet * pSheet = new CAppPoolSheet(
      QueryAuthInfo(), path, GetMainWindow(), (LPARAM)this, handle
      );
   
   if (pSheet != NULL)
   {
      pSheet->SetModeless();
//      err = AddMMCPage(lpProvider, new CAppPoolGeneral(pSheet));
      err = AddMMCPage(lpProvider, new CAppPoolRecycle(pSheet));
      err = AddMMCPage(lpProvider, new CAppPoolPerf(pSheet));
      err = AddMMCPage(lpProvider, new CAppPoolHealth(pSheet));
      err = AddMMCPage(lpProvider, new CAppPoolDebug(pSheet));
      err = AddMMCPage(lpProvider, new CAppPoolIdent(pSheet));
   }

   return err;
}

/* virtual */
HRESULT
CAppPoolsContainer::BuildMetaPath(
    OUT CComBSTR & bstrPath
    ) const
/*++

Routine Description:

    Recursively build up the metabase path from the current node
    and its parents. We cannot use CIISMBNode method because AppPools
    is located under w3svc, but rendered after machine.

Arguments:

    CComBSTR & bstrPath     : Returns metabase path

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    ASSERT(m_pWebService != NULL);
    hr = m_pWebService->BuildMetaPath(bstrPath);

    if (SUCCEEDED(hr))
    {
        bstrPath.Append(_cszSeparator);
        bstrPath.Append(QueryNodeName());
        return hr;
    }

    //
    // No service node
    //
    ASSERT_MSG("No WebService pointer");
    return E_UNEXPECTED;
}

HRESULT
CAppPoolsContainer::QueryDefaultPoolId(CString& id)
//
// Returns pool id which is set on master node for web service
//
{
    CError err;
    CComBSTR path;
    CString service;

    BuildMetaPath(path);
    CMetabasePath::GetServicePath(path, service);
    CMetaKey mk(QueryAuthInfo(), service, METADATA_PERMISSION_READ);
    err = mk.QueryResult();
    if (err.Succeeded())
    {
        err = mk.QueryValue(MD_APP_APPPOOL_ID, id);
    }

    return err;
}

/* virtual */
HRESULT
CAppPoolsContainer::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    if (SUCCEEDED(hr))
    {
        ASSERT(pInsertionAllowed != NULL);
        if (IsAdministrator() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
        {
           AddMenuSeparator(lpContextMenuCallback);
           AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_APP_POOL);
        }
    }

    return hr;
}

HRESULT
CAppPoolsContainer::Command(
    long lCommandID,
    CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type
    )
{
    HRESULT hr = S_OK;
    CString name;

    switch (lCommandID)
    {
    case IDM_NEW_APP_POOL:
        if (    SUCCEEDED(hr = AddAppPool(pObj, type, this, name))
            && !name.IsEmpty()
            )
        {
           hr = InsertNewPool(name);
        }
        break;

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    return hr;
}

HRESULT
CAppPoolsContainer::InsertNewPool(CString& id)
{
    CError err;
    // Now we should insert and select this new site
    CAppPoolNode * pPool = new CAppPoolNode(m_pOwner, this, id);
    if (pPool != NULL)
    {
        err = pPool->RefreshData();
        if (err.Succeeded())
        {
           // If item is not expanded we will get error and no effect
           if (!IsExpanded())
           {
               SelectScopeItem();
               IConsoleNameSpace2 * pConsole 
                       = (IConsoleNameSpace2 *)GetConsoleNameSpace();
               pConsole->Expand(QueryScopeItem());
           }
           err = pPool->AddToScopePaneSorted(QueryScopeItem(), FALSE);
           if (err.Succeeded())
           {
               VERIFY(SUCCEEDED(pPool->SelectScopeItem()));
           }
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    return err;
}

////////////////////////////////////////////////////////////////////////////////
// CAppPoolNode implementation
//
// App Pool Result View definition
//
/* static */ int 
CAppPoolNode::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_SERVICE_DESCRIPTION,
    IDS_RESULT_PATH,
};
    

/* static */ int 
CAppPoolNode::_rgnWidths[COL_TOTAL] =
{
    180,
    200,
};

CAppPoolNode::CAppPoolNode(
      CIISMachine * pOwner,
      CAppPoolsContainer * pContainer,
      LPCTSTR name
      )
    : CIISMBNode(pOwner, name),
      m_pContainer(pContainer)
{
}

CAppPoolNode::~CAppPoolNode()
{
}

#if 0
// This is too expensive
BOOL
CAppPoolNode::IsDeletable() const
{
   // We could delete node if it is empty and it is not default app pool
   BOOL bRes = TRUE;

   CComBSTR path;
   CStringListEx apps;
   BuildMetaPath(path);
   CIISMBNode * that = (CIISMBNode *)this;
   CIISAppPool pool(that->QueryAuthInfo(), (LPCTSTR)path);
   HRESULT hr = pool.EnumerateApplications(apps);
   bRes = (SUCCEEDED(hr) && apps.GetCount() == 0);
   if (bRes)
   {
      CString buf;
      hr = m_pContainer->QueryDefaultPoolId(buf);
      bRes = buf.CompareNoCase(QueryNodeName()) != 0;
   }
   return bRes;
}
#endif

HRESULT
CAppPoolNode::DeleteNode(IResultData * pResult)
{
   CError err;
   CComBSTR path;
   BuildMetaPath(path);
   CIISAppPool pool(QueryAuthInfo(), (LPCTSTR)path);

   err = pool.Delete(GetNodeName());

   if (err.Succeeded())
   {
      err = RemoveScopeItem();
   }
   if (err.Win32Error() == ERROR_NOT_EMPTY)
   {
	   CString msg;
	   msg.LoadString(IDS_ERR_NONEMPTY_APPPOOL);
	   AfxMessageBox(msg);
   }
   else
   {
	  err.MessageBoxOnFailure();
   }

   return err;
}

/* virtual */
HRESULT
CAppPoolNode::BuildMetaPath(CComBSTR & bstrPath) const
{
    HRESULT hr = S_OK;
    ASSERT(m_pContainer != NULL);
    hr = m_pContainer->BuildMetaPath(bstrPath);

    if (SUCCEEDED(hr))
    {
        bstrPath.Append(_cszSeparator);
        bstrPath.Append(QueryNodeName());
        return hr;
    }

    //
    // No service node
    //
    ASSERT_MSG("No pointer to container");
    return E_UNEXPECTED;
}

/* virtual */
LPOLESTR 
CAppPoolNode::GetResultPaneColInfo(
    IN int nCol
    )
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    switch(nCol)
    {
    case COL_DESCRIPTION:
        return QueryDisplayName();

    case COL_STATE:
        return OLESTR("");
    }

    ASSERT_MSG("Bad column number");

    return OLESTR("");
}

/* virtual */
int      
CAppPoolNode::QueryImage() const
/*++

Routine Description:

    Return bitmap index for the site

Arguments:

    None

Return Value:

    Bitmap index

--*/
{ 
    return iFolder;
}

/* virtual */
LPOLESTR 
CAppPoolNode::QueryDisplayName()
/*++

Routine Description:

    Return primary display name of this site.
    
Arguments:

    None

Return Value:

    The display name

--*/
{
    if (m_strDisplayName.IsEmpty())
    {
       CComBSTR path;
       BuildMetaPath(path);
       CMetaKey mk(QueryInterface(), path);
       if (mk.Succeeded())
       {
          mk.QueryValue(MD_APPPOOL_FRIENDLY_NAME, m_strDisplayName);
       }
    }        
    return (LPTSTR)(LPCTSTR)m_strDisplayName;
}

/*virtual*/
HRESULT
CAppPoolNode::RenameItem(LPOLESTR new_name)
{
   CComBSTR path;
   CError err;
   if (new_name != NULL && lstrlen(new_name) > 0)
   {
      BuildMetaPath(path);

      CMetaKey mk(QueryInterface(), path, METADATA_PERMISSION_WRITE);

      CError err(mk.QueryResult());
      if (err.Succeeded())
      {
         err = mk.SetValue(MD_APPPOOL_FRIENDLY_NAME, CString(new_name));
         if (err.Succeeded())
         {
            m_strDisplayName = new_name;
         }
      }
   }
   return err;
}

/* virtual */
HRESULT
CAppPoolNode::RefreshData()
/*++

Routine Description:

    Refresh relevant configuration data required for display.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
//    CWaitCursor wait;
    CComBSTR path;
    CMetaKey * pKey = NULL;

    do
    {
        ASSERT_PTR(_lpConsoleNameSpace);
        err = BuildMetaPath(path);
        if (err.Failed())
        {
            break;
        }

        BOOL fContinue = TRUE;

        while (fContinue)
        {
            fContinue = FALSE;
            if (NULL == (pKey = new CMetaKey(QueryInterface(), path)))
            {
                TRACEEOLID("RefreshData: Out Of Memory");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            err = pKey->QueryResult();

            if (IsLostInterface(err))
            {
                SAFE_DELETE(pKey);
                fContinue = OnLostInterface(err);
            }
        }

        if (err.Failed())
        {
            break;
        }

        CAppPoolProps pool(pKey, _T(""));

        err = pool.LoadData();
        if (err.Failed())
        {
            break;
        }
        // Assign the data

    }
    while(FALSE);

    SAFE_DELETE(pKey);

    return err;
}

/* virtual */
int 
CAppPoolNode::CompareResultPaneItem(
    IN CIISObject * pObject, 
    IN int nCol
    )
/*++

Routine Description:

    Compare two CIISObjects on sort item criteria

Arguments:

    CIISObject * pObject : Object to compare against
    int nCol             : Column number to sort on

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    if (nCol == 0)
    {
        return CompareScopeItem(pObject);
    }

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Both are CAppPoolNode objects
    //
    CAppPoolNode * pPool = (CAppPoolNode *)pObject;

    switch(nCol)
    {
    case COL_DESCRIPTION:
    case COL_STATE:
    default:
        //
        // Lexical sort
        //
        return ::lstrcmpi(
            GetResultPaneColInfo(nCol), 
            pObject->GetResultPaneColInfo(nCol)
            );
    }
}

/* virtual */
void 
CAppPoolNode::InitializeChildHeaders(
    IN LPHEADERCTRL lpHeader
    )
/*++

Routine Description:

    Build result view for immediate descendant type

Arguments:

    LPHEADERCTRL lpHeader      : Header control

Return Value:

    None

--*/
{
   CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
}

/* virtual */
HRESULT 
CAppPoolNode::EnumerateScopePane(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    CComBSTR path;
    BuildMetaPath(path);
    CIISAppPool pool(QueryAuthInfo(), path);

    if (pool.Succeeded())
    {
        CStringListEx apps;

        hr = pool.EnumerateApplications(apps);
        if (SUCCEEDED(hr) && apps.GetCount() > 0)
        {
            POSITION pos = apps.GetHeadPosition();
            while ( pos != NULL)
            {
                CString app = apps.GetNext(pos);
                DWORD i = CMetabasePath::GetInstanceNumber(app);
                if (i > 0)
                {
                    CString name;
                    CMetabasePath::CleanMetaPath(app);
                    CMetabasePath::GetLastNodeName(app, name);
                    CApplicationNode * app_node = new CApplicationNode(
                        GetOwner(), app, name);
                    if (app_node != NULL)
                    {
                        app_node->AddToScopePane(m_hScopeItem, TRUE, TRUE, FALSE);
                    }
                    else
                        hr = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
    }

    return hr;
}

/* virtual */
HRESULT
CAppPoolNode::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
   AFX_MANAGE_STATE(::AfxGetStaticModuleState());

   CComBSTR path;

   CError err(BuildMetaPath(path));

   if (err.Succeeded())
   {
      CAppPoolSheet * pSheet = new CAppPoolSheet(
            QueryAuthInfo(), path, GetMainWindow(), (LPARAM)this, handle
            );
   
      if (pSheet != NULL)
      {
         pSheet->SetModeless();
//         err = AddMMCPage(lpProvider, new CAppPoolGeneral(pSheet));
         err = AddMMCPage(lpProvider, new CAppPoolRecycle(pSheet));
         err = AddMMCPage(lpProvider, new CAppPoolPerf(pSheet));
         err = AddMMCPage(lpProvider, new CAppPoolHealth(pSheet));
         err = AddMMCPage(lpProvider, new CAppPoolDebug(pSheet));
         err = AddMMCPage(lpProvider, new CAppPoolIdent(pSheet));
      }
   }

   err.MessageBoxOnFailure();

   return err;
}

/* virtual */
HRESULT
CAppPoolNode::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    if (SUCCEEDED(hr))
    {
        ASSERT(pInsertionAllowed != NULL);
        if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
        {
           AddMenuSeparator(lpContextMenuCallback);
           AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_APP_POOL);
        }
    }

    return hr;
}

/* virtual */
HRESULT
CAppPoolNode::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    CString name;

    switch (lCommandID)
    {
    case IDM_NEW_APP_POOL:
        if (    SUCCEEDED(hr = AddAppPool(pObj, type, m_pContainer, name))
            && !name.IsEmpty()
            )
        {
           hr = m_pContainer->InsertNewPool(name);
        }
        break;

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////

LPOLESTR 
CApplicationNode::QueryDisplayName()
/*++

Routine Description:

    Return primary display name of this site.
    
Arguments:

    None

Return Value:

    The display name

--*/
{
    if (m_strDisplayName.IsEmpty())
    {
        CMetaKey mk(QueryInterface(), m_meta_path);
        if (mk.Succeeded())
        {
            mk.QueryValue(MD_APP_FRIENDLY_NAME, m_strDisplayName);
            if (m_strDisplayName.IsEmpty())
            {
               m_strDisplayName = QueryNodeName();
            }
        }
    }
    return (LPTSTR)(LPCTSTR)m_strDisplayName;
}


HRESULT
CApplicationNode::BuildMetaPath(CComBSTR& path) const
{
    path = m_meta_path;
    return S_OK;
}

LPOLESTR 
CApplicationNode::GetResultPaneColInfo(
    IN int nCol
    )
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    switch(nCol)
    {
    case COL_ALIAS:
        return QueryDisplayName();

    case COL_PATH:
        {
        CString buf;
        return (LPTSTR)(LPCTSTR)FriendlyAppRoot(m_meta_path, buf);
        }
    }

    ASSERT_MSG("Bad column number");

    return OLESTR("");
}

LPCTSTR
CApplicationNode::FriendlyAppRoot(
    LPCTSTR lpAppRoot, 
    CString & strFriendly
    )
/*++

Routine Description:

    Convert the metabase app root path to a friendly display name
    format.

Arguments:

    LPCTSTR lpAppRoot           : App root
    CString & strFriendly       : Output friendly app root format

Return Value:

    Reference to the output string

Notes:

    App root must have been cleaned from WAM format prior
    to calling this function (see first ASSERT below)

--*/
{
    if (lpAppRoot != NULL && *lpAppRoot != 0)
    {
        //
        // Make sure we cleaned up WAM format
        //
        ASSERT(*lpAppRoot != _T('/'));
        strFriendly.Empty();

        CInstanceProps prop(QueryAuthInfo(), lpAppRoot);
        HRESULT hr = prop.LoadData();

        if (SUCCEEDED(hr))
        {
            CString root, tail;
            strFriendly.Format(_T("<%s>"), prop.GetDisplayText(root));
            CMetabasePath::GetRootPath(lpAppRoot, root, &tail);
            if (!tail.IsEmpty())
            {
                //
                // Add rest of dir path
                //
                strFriendly += _T("/");
                strFriendly += tail;
            }

            //
            // Now change forward slashes in the path to backward slashes
            //
//            CvtPathToDosStyle(strFriendly);

            return strFriendly;
        }
    }    
    //
    // Bogus
    //    
    VERIFY(strFriendly.LoadString(IDS_APPROOT_UNKNOWN));

    return strFriendly;
}
//////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\certmap.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "certmap.h"

// Dispatch interfaces referenced by this interface
#include "Font.h"

/////////////////////////////////////////////////////////////////////////////
// CCertmap

IMPLEMENT_DYNCREATE(CCertmap, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCertmap properties

COleFont CCertmap::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CCertmap::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

BOOL CCertmap::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CCertmap::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

short CCertmap::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CCertmap::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

CString CCertmap::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CCertmap::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CCertmap operations

void CCertmap::SetServerInstance(LPCTSTR szServerInstance)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szServerInstance);
}

void CCertmap::SetMachineName(LPCTSTR szMachineName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\authent.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        authent.cpp

   Abstract:

        WWW Authentication Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



class CAuthenticationDlg : public CDialog
/*++

Class Description:

    Authentication dialog

Public Interface:

    CAuthenticationDlg  : Constructor

--*/
{
//
// Construction
//
public:
    CAuthenticationDlg(
        IN LPCTSTR lpstrServerName, // For API name only
        IN DWORD   dwInstance,      // For use in ocx only
        IN CString & strBasicDomain,
        IN CString & strRealm,
        IN DWORD & dwAuthFlags,
        IN DWORD & dwAccessPermissions,
        IN CString & strUserName,
        IN CString & strPassword,
        IN BOOL & fPasswordSync,
        IN BOOL fAdminAccess,
        IN BOOL fHasDigest,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAuthenticationDlg)
    enum { IDD = IDD_AUTHENTICATION };
    CButton m_check_Anonymous;
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CButton m_chk_PasswordSync;
    BOOL    m_fClearText;
    BOOL    m_fDigest;
    BOOL    m_fChallengeResponse;
    BOOL    m_fAnonymous;
    CButton m_check_ChallengeResponse;
    CButton m_check_ClearText;
    CButton m_check_Digest;
//    CButton m_button_EditAnonymous;
//    CButton m_button_Edit;
    CEdit   m_edit_BasicDomain;
    CButton m_btn_SelectDomain;
    CEdit   m_edit_Realm;
    CButton m_btn_SelectRealm;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAuthenticationDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CAuthenticationDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnCheckEnablePwSynchronization();
    afx_msg void OnChangeEditUsername();
    virtual void OnOK();
    afx_msg void OnCheckClearText();
    afx_msg void OnCheckAnonymous();
    afx_msg void OnCheckDigest();
    afx_msg void OnButtonSelectDomain();
    afx_msg void OnButtonSelectRealm();
    //}}AFX_MSG
    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    HRESULT BrowseDomain(CString& domain);

private:
    BOOL & m_fPasswordSync;
    BOOL m_fPasswordSyncChanged;
    BOOL m_fPasswordSyncMsgShown;
    BOOL m_fAdminAccess;
    BOOL m_fHasDigest;
	BOOL m_fChanged;
    BOOL m_fInDomain;
    DWORD & m_dwAuthFlags;
    DWORD & m_dwAccessPermissions;
    DWORD m_dwInstance;
    CString & m_strBasicDomain;
    CString & m_strRealm;
    CString & m_strUserName;
    BOOL m_fUserNameChanged;
    CString & m_strPassword;
    CString m_strServerName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\certauth.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

#ifndef __CERTAUTH_H_
#define __CERTAUTH_H_

// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CCertAuth wrapper class

class CCertAuth : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertAuth)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0x996ff6f, 0xb6a1, 0x11d0, { 0x92, 0x92, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    short GetBorderStyle();
    void SetBorderStyle(short);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetMachineName(LPCTSTR szMachineName);
    void SetServerInstance(LPCTSTR szServerInstance);
    void DoClick(long dwButtonNumber);
    void AboutBox();
};

#endif // __CERTAUTH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\certwiz.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "certwiz.h"

/////////////////////////////////////////////////////////////////////////////
// CCertWiz

IMPLEMENT_DYNCREATE(CCertWiz, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCertWiz properties

/////////////////////////////////////////////////////////////////////////////
// CCertWiz operations

void CCertWiz::SetMachineName(LPCTSTR MachineName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         MachineName);
}

void CCertWiz::SetServerInstance(LPCTSTR InstanceName)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         InstanceName);
}

void CCertWiz::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\certwiz.h ===
#if !defined(AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_)
#define AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CCertWiz wrapper class

class CCertWiz : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertWiz)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xd4be8632, 0xc85, 0x11d2, { 0x91, 0xb1, 0x0, 0xc0, 0x4f, 0x8c, 0x87, 0x61 } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
    void SetMachineName(LPCTSTR MachineName);
    void SetServerInstance(LPCTSTR InstanceName);
    void DoClick();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CERTWIZ_H__34F689DE_3DDC_11D2_9BB6_0000F87A800C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\certmap.h ===
#ifndef __CERTMAP_H__
#define __CERTMAP_H__

// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CCertmap wrapper class

class CCertmap : public CWnd
{
protected:
    DECLARE_DYNCREATE(CCertmap)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xbbd8f29b, 0x6f61, 0x11d0, { 0xa2, 0x6e, 0x8, 0x0, 0x2b, 0x2c, 0x6f, 0x32 } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    short GetBorderStyle();
    void SetBorderStyle(short);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetServerInstance(LPCTSTR szServerInstance);
    void SetMachineName(LPCTSTR szMachineName);
};

#endif // __CERTMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\connects.cpp ===
/*++

   Copyright    (c)    1994-2001   Microsoft Corporation

   Module  Name :
        connects.cpp

   Abstract:
        "Connect to a single server" dialog

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonoc (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "connects.h"
#include "objpick.h"



#define MAX_SERVERNAME_LEN (255)

const LPCTSTR g_cszInetSTPBasePath_ = _T("Software\\Microsoft\\InetStp");
const LPCTSTR g_cszMajorVersion_	   = _T("MajorVersion");


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


extern CInetmgrApp theApp;

//
// CLoginDlg Dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CLoginDlg::CLoginDlg(
    IN int nType,               
    IN CIISMachine * pMachine,
    IN CWnd * pParent           OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    int nType               : Type of dialog to bring up:

                              LDLG_ACCESS_DENIED    - Access Denied dlg
                              LDLG_ENTER_PASS       - Enter password dlg
                              LDLG_IMPERSONATION    - Impersonation dlg

    CIISMachine * pMachine  : Machine object
    CWnd * pParent          : Parent window
    
Return Value:

--*/
    : CDialog(CLoginDlg::IDD, pParent),
      m_nType(nType),
      m_strOriginalUserName(),
      m_strUserName(),
      m_strPassword(),
      m_pMachine(pMachine)
{
#if 0 // Keep Classwizard happy

    //{{AFX_DATA_INIT(CLoginDlg)
    m_strPassword = _T("");
    m_strUserName = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    ASSERT_PTR(m_pMachine);
}



void 
CLoginDlg::DoDataExchange(
    IN OUT CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:
    
    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CLoginDlg)
    DDX_Text(pDX, IDC_EDIT_USER_NAME, m_strUserName);
    DDX_Text(pDX, IDC_EDIT_PASSWORD2, m_strPassword);
    DDV_MaxChars(pDX, m_strPassword, PWLEN);
    DDX_Control(pDX, IDC_EDIT_USER_NAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD2, m_edit_Password);
    DDX_Control(pDX, IDC_STATIC_PROMPT2, m_static_Prompt);
    DDX_Control(pDX, IDOK, m_button_Ok);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CLoginDlg, CDialog)
    //{{AFX_MSG_MAP(CLoginDlg)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_USER_NAME, SetControlStates)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CLoginDlg::SetControlStates()
/*++

Routine Description:

    Set UI control enabled/disabled states

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(m_edit_UserName.GetWindowTextLength() > 0);
}



BOOL 
CLoginDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    CString str;

    switch(m_nType)
    {
    case LDLG_ENTER_PASS:
        //
        // Change text for the "Enter Password" dialog
        //
        VERIFY(str.LoadString(IDS_ENTER_PASSWORD));
        SetWindowText(str);

        str.Format(IDS_RESOLVE_PASSWORD, m_pMachine->QueryServerName());
        m_static_Prompt.SetWindowText(str);

        //
        // Fall through
        //

    case LDLG_ACCESS_DENIED:
        //
        // This is the default text on the dialog
        //
        m_strUserName = m_strOriginalUserName = m_pMachine->QueryUserName();

        if (!m_strUserName.IsEmpty())
        {
            m_edit_UserName.SetWindowText(m_strUserName);
            m_edit_Password.SetFocus();
        }
        else
        {
            m_edit_UserName.SetFocus();
        }
        break;

    case LDLG_IMPERSONATION:
        VERIFY(str.LoadString(IDS_IMPERSONATION));
        SetWindowText(str);
       
        str.Format(IDS_IMPERSONATION_PROMPT, m_pMachine->QueryServerName());
        m_static_Prompt.SetWindowText(str);
        m_edit_UserName.SetFocus();
        break;

    default:
        ASSERT_MSG("Invalid dialog type");
    }

    SetControlStates();
    
    return FALSE;  
}



void 
CLoginDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Attempt to connect to the machine specified.  If 
    machiname is ok, dismiss the dialog.  Otherwise put up an error message
    and stay active.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT_PTR(m_pMachine);

    if (UpdateData(TRUE))
    {
        CError err(m_pMachine->Impersonate(m_strUserName, m_strPassword));

        if (err.Failed())
        {
            //
            // Not a proper impersonation created.  Keep the dialog
            // open to make corrections. 
            //
            m_pMachine->DisplayError(err);

            m_edit_Password.SetSel(0, -1);
            m_edit_Password.SetFocus();
            return;
        }
    }
    
    EndDialog(IDOK);
}



//
// Connect to server dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



ConnectServerDlg::ConnectServerDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor.

Arguments:

    CWnd * pParent : Optional pointer to parent window

Return Value:

    N/A

--*/
    : CDialog(ConnectServerDlg::IDD, pParent),
      m_fImpersonate(FALSE),
      m_strServerName(),
      m_strPassword(),
      m_strUserName(),
      m_pMachine(NULL)
{
#if 0 // Keep Classwizard happy

    //{{AFX_DATA_INIT(ConnectServerDlg)
    m_fImpersonate = FALSE;
    m_strServerName = _T("");
    m_strUserName = _T("");
    m_strPassword = _T("");
    //}}AFX_DATA_INIT

#endif // 0
}



void
ConnectServerDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:
    
    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(ConnectServerDlg)
    DDX_Check(pDX, IDC_CHECK_CONNECT_AS, m_fImpersonate);
    DDX_Text(pDX, IDC_SERVERNAME, m_strServerName);
    DDV_MaxChars(pDX, m_strServerName, MAX_SERVERNAME_LEN);
    DDX_Text(pDX, IDC_EDIT_USER_NAME, m_strUserName);
    DDX_Text(pDX, IDC_EDIT_PASSWORD2, m_strPassword);
    DDV_MaxChars(pDX, m_strPassword, PWLEN);
    DDX_Control(pDX, IDC_EDIT_USER_NAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD2, m_edit_Password);
    DDX_Control(pDX, IDC_SERVERNAME, m_edit_ServerName);
    DDX_Control(pDX, IDC_STATIC_USER_NAME, m_static_UserName);
    DDX_Control(pDX, IDC_STATIC_PASSWORD2, m_static_Password);
    DDX_Control(pDX, IDOK, m_button_Ok);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(ConnectServerDlg, CDialog)
    //{{AFX_MSG_MAP(ConnectServerDlg)
    ON_BN_CLICKED(IDC_CHECK_CONNECT_AS, OnCheckConnectAs)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(ID_HELP, OnButtonHelp)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_SERVERNAME, SetControlStates)
    ON_EN_CHANGE(IDC_EDIT_USER_NAME, SetControlStates)
END_MESSAGE_MAP()



void
ConnectServerDlg::SetControlStates()
/*++

Routine Description:

    Set UI control enabled/disabled states.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_UserName.EnableWindow(m_fImpersonate);
    m_static_Password.EnableWindow(m_fImpersonate);
    m_edit_UserName.EnableWindow(m_fImpersonate);
    m_edit_Password.EnableWindow(m_fImpersonate);

    m_button_Ok.EnableWindow(
        m_edit_ServerName.GetWindowTextLength() > 0 &&
        (m_edit_UserName.GetWindowTextLength() > 0 || !m_fImpersonate)
        );
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
ConnectServerDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    SetControlStates();
    
    return TRUE;  
}



void 
ConnectServerDlg::OnButtonBrowse() 
/*++

Routine Description:

    'Browse' button handler.  Browse for a computer name

Arguments:

    None

Return Value:

    None

--*/
{
    CGetComputer picker;
    if (picker.GetComputer(m_hWnd))
    {
        m_edit_ServerName.SetWindowText(picker.m_strComputerName);
        SetControlStates();
        m_button_Ok.SetFocus();
    }
#ifdef _DEBUG
    else
    {
       TRACE(_T("ConnectServerDlg::OnButtonBrowse() -> Cannot get computer name from browser\n"));
    }
#endif
}



void 
ConnectServerDlg::OnCheckConnectAs() 
/*++

Routine Description:

    "Connect As" checbox event handler.  Enable/Disable username/password
    controls.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fImpersonate = !m_fImpersonate;

    SetControlStates();

    if (m_fImpersonate)
    {
        m_edit_UserName.SetFocus();
        m_edit_UserName.SetSel(0, -1);
    }
}



void 
ConnectServerDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Attempt to connect to the machine specified.  If 
    machiname is ok, dismiss the dialog.  Otherwise put up an error message
    and stay active.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_pMachine == NULL);

    CError err;

    if (UpdateData(TRUE))
    {
        do
        {
            LPCTSTR lpszUserName = m_fImpersonate ? (LPCTSTR)m_strUserName : NULL;
            LPCTSTR lpszPassword = m_fImpersonate ? (LPCTSTR)m_strPassword : NULL;

			CString server = m_strServerName;
			if (PathIsUNCServer(m_strServerName))
			{
				server = m_strServerName.Mid(2);
			}
			else
			{
				server = m_strServerName;
			}

            m_pMachine = new CIISMachine(CComAuthInfo(
                server,
                lpszUserName,
                lpszPassword
                ));

            if (m_pMachine)
            {
                //
                // Verify the machine object is created. 
                //
                err = CIISMachine::VerifyMachine(m_pMachine);
                if (err.Failed())
                {
                    //
                    // Not a proper machine object created.  Keep the dialog
                    // open to make corrections. 
                    //
                    m_pMachine->DisplayError(err);
                    m_edit_ServerName.SetSel(0, -1);
                    m_edit_ServerName.SetFocus();
                    SAFE_DELETE(m_pMachine);
                }
				else
				{
					// IIS5.1 block for iis6 remote administration
					CRegKey rk;
					rk.Create(HKEY_LOCAL_MACHINE, g_cszInetSTPBasePath_);
					DWORD major;
					if (ERROR_SUCCESS == rk.QueryValue(major, g_cszMajorVersion_))
					{
						if (m_pMachine->QueryMajorVersion() == 6 && major == 5)
						{
							AfxMessageBox(IDS_UPGRADE_TO_IIS6);
							SAFE_DELETE(m_pMachine);
						}
					}
				}

            }
            else
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                err.MessageBox();
            }
        }
        while(FALSE);
    }
    
    //
    // Dismiss the dialog only if a proper machine object was created
    //  
    if (m_pMachine)
    {
        EndDialog(IDOK);
    }
}

#define HIDD_CONNECT_SERVER      0x29cd9

void 
ConnectServerDlg::OnButtonHelp()
{
   ::WinHelp(m_hWnd, theApp.m_pszHelpFilePath, HELP_CONTEXT, HIDD_CONNECT_SERVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\connects.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        connects.h

   Abstract:
        "Connect to a single server" dialog definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
--*/
#ifndef __CONNECTS_H__
#define __CONNECTS_H__

class CIISMachine;


#define EXTGUID TCHAR



//
// CLoginDlg dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Different ways to display this dialog
//
enum
{
    LDLG_ACCESS_DENIED,     // Access denied
    LDLG_ENTER_PASS,        // Enter password
    LDLG_IMPERSONATION,     // Change impersonation
};



class CLoginDlg : public CDialog
/*++

Class Description:

    Log-in dialog.  Brought up either to enter the password, or to provide
    both username and password

Public Interface:

--*/
{
//
// Construction
//
public:
    CLoginDlg(
        IN int nType,               // See LDLG_ definitions above
        IN CIISMachine * pMachine,
        IN CWnd * pParent           = NULL
        );   

//
// Access
//
public:
    BOOL UserNameChanged() const;

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CLoginDlg)
    enum { IDD = IDD_LOGIN };
    CString m_strUserName;
    CString m_strPassword;
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CStatic m_static_Prompt;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CLoginDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CLoginDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    int m_nType;
    CIISMachine * m_pMachine;
    CString m_strOriginalUserName;
};



class ConnectServerDlg : public CDialog
{
/*++

Class Description:

    Connect to a server dialog.  Also used to ask for the cluster controller
    or for a server to add to the cluster.

Public Interface:

    ConnectServerDlg : Constructor

    GetMachine       : Get the created machine object (may or may not have a created
                       interface)

--*/
//
// Construction
//
public:
    ConnectServerDlg(
        IN CWnd * pParent = NULL
        );   

//
// Access Functions
//
public:
    CIISMachine * GetMachine() { return m_pMachine; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(ConnectServerDlg)
    enum { IDD = IDD_CONNECT_SERVER };
    BOOL    m_fImpersonate;
    CString m_strServerName;
    CString m_strUserName;
    CString m_strPassword;
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CEdit   m_edit_ServerName;
    CStatic m_static_UserName;
    CStatic m_static_Password;
    CButton m_button_Ok;
    //}}AFX_DATA
   

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(ConnectServerDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(ConnectServerDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnCheckConnectAs();
    afx_msg void OnButtonBrowse();
	afx_msg void OnButtonHelp();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISMachine * m_pMachine;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CLoginDlg::UserNameChanged() const
{
    //
    // TRUE if the user name is not the original user name
    //
    return m_strOriginalUserName.CompareNoCase(m_strUserName);
}

#endif // __CONNECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\deffs.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        deffs.h

   Abstract:
        Default Ftp Site Dialog

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __DEFFS_H__
#define __DEFFS_H__


class CDefFtpSitePage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CDefFtpSitePage)

//
// Construction
//
public:
    CDefFtpSitePage(CInetPropertySheet * pSheet = NULL);
    ~CDefFtpSitePage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CDefWebSitePage)
    enum { IDD = IDD_FTP_DEFAULT_SITE };
    BOOL m_fLimitBandwidth;
    CButton m_LimitBandwidth;
    DWORD m_dwMaxBandwidthDisplay;
    CEdit m_MaxBandwidth;
    CSpinButtonCtrl m_MaxBandwidthSpin;
    //}}AFX_DATA
    DWORD m_dwMaxBandwidth;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

   static void 
   ParseMaxNetworkUse(
         DWORD& dwMaxBandwidth, 
         DWORD& dwMaxBandwidthDisplay,
         BOOL& fLimitBandwidth
         );

   static void
   BuildMaxNetworkUse(
         DWORD& dwMaxBandwidth, 
         DWORD& dwMaxBandwidthDisplay,
         BOOL& fLimitBandwidth
         );

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDefWebSitePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CDefWebSitePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckLimitNetworkUse();
    afx_msg void OnItemChanged();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL SetControlStates();

private:
};

inline /* static */ void 
CDefFtpSitePage::BuildMaxNetworkUse(
      DWORD& dwMaxBandwidth, 
      DWORD& dwMaxBandwidthDisplay,
      BOOL& fLimitBandwidth
      )
{
   dwMaxBandwidth = fLimitBandwidth ?
      dwMaxBandwidthDisplay * KILOBYTE : INFINITE_BANDWIDTH;
}

#endif // __DEFFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\deffs.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        deffs.cpp

   Abstract:
        Default Ftp Site Dialog

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "ftpsht.h"
#include "deffs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/* static */
void
CDefFtpSitePage::ParseMaxNetworkUse(
      DWORD& dwMaxBandwidth, 
      DWORD& dwMaxBandwidthDisplay,
      BOOL& fLimitBandwidth
      )
{
    //
    // Special case: If dwMaxBandwidth is 0(an invalid value), the 
    // value likely could not be inherited from the root (the user
    // is an operator and can't see the properties there).  Adjust
    // the value to a possibly misleading value.
    //
    if (dwMaxBandwidth == 0L)
    {
        TRACEEOLID("Adjusting invalid bandwidth throttling value -- "
                   "are you an operator?");
        dwMaxBandwidth = INFINITE_BANDWIDTH;
    }

    fLimitBandwidth = (dwMaxBandwidth != INFINITE_BANDWIDTH);
    dwMaxBandwidthDisplay = fLimitBandwidth ?
      (dwMaxBandwidth / KILOBYTE) : (DEF_BANDWIDTH / KILOBYTE);
}

IMPLEMENT_DYNCREATE(CDefFtpSitePage, CInetPropertyPage)

CDefFtpSitePage::CDefFtpSitePage(
    IN CInetPropertySheet * pSheet
    )
    : CInetPropertyPage(CDefFtpSitePage::IDD, pSheet)
{
}

CDefFtpSitePage::~CDefFtpSitePage()
{
}

void
CDefFtpSitePage::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDefWebSitePage)
    DDX_Check(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_fLimitBandwidth);
    DDX_Control(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_LimitBandwidth);
    DDX_Control(pDX, IDC_MAX_BANDWIDTH, m_MaxBandwidth);
    DDX_Text(pDX, IDC_MAX_BANDWIDTH, m_dwMaxBandwidthDisplay);
    DDX_Control(pDX, IDC_MAX_BANDWIDTH_SPIN, m_MaxBandwidthSpin);
    //}}AFX_DATA_MAP
    if (!pDX->m_bSaveAndValidate || m_fLimitBandwidth)
    {
        DDX_Text(pDX, IDC_MAX_BANDWIDTH, m_dwMaxBandwidthDisplay);
        DDV_MinMaxLong(pDX, m_dwMaxBandwidthDisplay, 
            BANDWIDTH_MIN, BANDWIDTH_MAX);
    }
}

/* virtual */
HRESULT
CDefFtpSitePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_dwMaxBandwidth);
        ParseMaxNetworkUse(
            m_dwMaxBandwidth, 
            m_dwMaxBandwidthDisplay, 
            m_fLimitBandwidth
            );
    END_META_INST_READ(err)

    return err;
}

/* virtual */
HRESULT
CDefFtpSitePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving Ftp default site page now...");

    CError err;

    BuildMaxNetworkUse(
        m_dwMaxBandwidth, 
        m_dwMaxBandwidthDisplay, 
        m_fLimitBandwidth
        );
    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_dwMaxBandwidth);
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}

BOOL
CDefFtpSitePage::SetControlStates()
{
    if (::IsWindow(m_LimitBandwidth.m_hWnd))
    {
        BOOL fLimitOn = m_LimitBandwidth.GetCheck() > 0
//        && HasBwThrottling()
//        && HasAdminAccess()
            ;

        m_MaxBandwidth.EnableWindow(fLimitOn);
        m_MaxBandwidthSpin.EnableWindow(fLimitOn);
        return fLimitOn;
    }
    return FALSE;
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CDefFtpSitePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3PerfPage)
    ON_BN_CLICKED(IDC_CHECK_LIMIT_NETWORK_USE, OnCheckLimitNetworkUse)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_MAX_BANDWIDTH, OnItemChanged)
END_MESSAGE_MAP()

BOOL
CDefFtpSitePage::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();
   //
   // Disable some settings based on what's possible
   //
#if 0
   m_LimitBandwidth.EnableWindow(
        !IsMasterInstance()
     && HasBwThrottling()
     && HasAdminAccess()
        );
#endif
   SETUP_EDIT_SPIN(m_fLimitBandwidth, m_MaxBandwidth, m_MaxBandwidthSpin, 
      BANDWIDTH_MIN, BANDWIDTH_MAX, m_dwMaxBandwidthDisplay);

   SetControlStates();

   return TRUE;
}

void
CDefFtpSitePage::OnItemChanged()
{
    SetControlStates();
    SetModified(TRUE);
}

void
CDefFtpSitePage::OnCheckLimitNetworkUse()
{
    if (SetControlStates())
    {
        m_MaxBandwidth.SetSel(0, -1);
        m_MaxBandwidth.SetFocus();
    }
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\defws.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        defws.h

   Abstract:

        Default Web Site Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __DEFWS_H__
#define __DEFWS_H__



class CDefWebSitePage : public CInetPropertyPage
/*++

Class Description:

    WWW Errors property page

Public Interface:

    CDefWebSitePage       : Constructor
    CDefWebSitePage       : Destructor

--*/
{
    DECLARE_DYNCREATE(CDefWebSitePage)

//
// Construction
//
public:
    CDefWebSitePage(CInetPropertySheet * pSheet = NULL);
    ~CDefWebSitePage();

	int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
//
// Dialog Data
//
protected:
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CDefWebSitePage)
    enum { IDD = IDD_DEFAULT_SITE };
    int     m_nUnlimited;
    BOOL    m_fEnableDynamic;
    BOOL    m_fEnableStatic;
    BOOL    m_fCompatMode;
    CString m_strDirectory;
    CEdit   m_edit_DirectorySize;
    CEdit   m_edit_Directory;
    CStatic m_static_MB;
    CButton m_button_Browse;
    //}}AFX_DATA

    BOOL   m_fEnableLimiting;
    BOOL   m_fCompressionDirectoryChanged;
    BOOL   m_fInitCompatMode;
    CILong m_ilSize;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDefWebSitePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CDefWebSitePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowse();
    afx_msg void OnButtonFileTypes();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    afx_msg void OnCheckDynamicCompression();
    afx_msg void OnCheckStaticCompression();
    afx_msg void OnCheckCompatMode();
    afx_msg void OnChangeEditCompressDirectory();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

//    HRESULT BuildInstanceList();
//    DWORD FetchInstanceSelected();
    void SetControlStates();
    BOOL HasCompression() const;

private:
    CIISCompressionProps * m_ppropCompression;
    CMimeTypes    * m_ppropMimeTypes;
    CStringListEx m_strlMimeTypes;
//    CDWordArray m_rgdwInstances;
    BOOL m_fFilterPathFound;
	LPTSTR m_pPathTemp;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CDefWebSitePage::HasCompression() const
{
    return m_fFilterPathFound 
		&& !CInetPropertyPage::Has10ConnectionLimit() // i.e. is workstation
		&& CInetPropertyPage::HasCompression();
}


#endif // __DEFWS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__46A3FC8A_E61B_11D2_A771_00A0C922E79C__INCLUDED_)
#define AFX_DLLDATAX_H__46A3FC8A_E61B_11D2_A771_00A0C922E79C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__46A3FC8A_E61B_11D2_A771_00A0C922E79C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\dlldatax.c ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        dlldatax.c

   Abstract:

        wrapper for dlldata.c

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/


#ifdef _MERGE_PROXYSTUB     // merge proxy stub DLL



#define REGISTER_PROXY_DLL  // DllRegisterServer, etc.
#define USE_STUBLESS_PROXY  // defined only with MIDL switch /Oicf



#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")



#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow



#include "dlldata.c"
#include "inetmgr_p.c"



#ifdef _NOPROXY //no midl generated dlldata.c



#define STRICT 1
#include <ole2.h>



BOOL 
WINAPI 
PrxDllMain(
    IN HINSTANCE hInstance, 
    IN DWORD dwReason, 
    IN LPVOID lpReserved
    )
{
    return TRUE;
}



STDAPI 
PrxDllCanUnloadNow()
{
    return S_OK;
}



STDAPI 
PrxDllGetClassObject(
    IN REFCLSID rclsid, 
    IN REFIID riid, 
    IN LPVOID * ppv
    )
{
    return CLASS_E_CLASSNOTAVAILABLE;
}



STDAPI 
PrxDllRegisterServer()
{
    return S_OK;
}



STDAPI 
PrxDllUnregisterServer()
{
    return S_OK;
}



#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\defws.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :
        defws.cpp

   Abstract:
        Default Web Site Dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "defws.h"
#include "mime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Directory Size Units
//
#define DS_UNITS MEGABYTE

//
// Default Web Site Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

IMPLEMENT_DYNCREATE(CDefWebSitePage, CInetPropertyPage)

CDefWebSitePage::CDefWebSitePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW Default Web Site page

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A


--*/
    : CInetPropertyPage(CDefWebSitePage::IDD, pSheet),
      m_ppropCompression(NULL),
      m_ppropMimeTypes(NULL),
      m_fFilterPathFound(FALSE),
      m_fCompressionDirectoryChanged(FALSE),
      m_fCompatMode(FALSE)
{
#if 0 // Keep Class Wizard happy
   //{{AFX_DATA_INIT(CDefWebSitePage)
   m_fEnableDynamic = FALSE;
   m_fEnableStatic = FALSE;
   m_fCompatMode = FALSE;
   m_strDirectory = _T("");
   m_nUnlimited = -1;
   m_ilSize = 0L;
   //}}AFX_DATA_INIT
#endif // 0
   m_fInitCompatMode = m_fCompatMode;
}



CDefWebSitePage::~CDefWebSitePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CDefWebSitePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CDefWebSitePage)
    DDX_Control(pDX, IDC_EDIT_COMPRESS_DIRECTORY, m_edit_Directory);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_STATIC_COMPRESS_MB, m_static_MB);
    DDX_Control(pDX, IDC_EDIT_COMPRESS_DIRECTORY_SIZE, m_edit_DirectorySize);
    DDX_Check(pDX, IDC_CHECK_DYNAMIC_COMPRESSION, m_fEnableDynamic);
    DDX_Check(pDX, IDC_CHECK_STATIC_COMPRESSION, m_fEnableStatic);
    DDX_Check(pDX, IDC_COMPAT_MODE, m_fCompatMode);
    DDX_Radio(pDX, IDC_RADIO_COMPRESS_UNLIMITED, m_nUnlimited);
    //}}AFX_DATA_MAP

    if (HasCompression())
    {
        if (!pDX->m_bSaveAndValidate || m_fEnableStatic)
        {
            DDX_Text(pDX, IDC_EDIT_COMPRESS_DIRECTORY, m_strDirectory);
            DDV_MaxChars(pDX, m_strDirectory, _MAX_PATH);
        }

        if (pDX->m_bSaveAndValidate && m_fEnableStatic)
        {
            if (!PathIsValid(m_strDirectory) || !IsFullyQualifiedPath(m_strDirectory))
            {
                ::AfxMessageBox(IDS_ERR_INVALID_PATH);
                pDX->Fail();
            }

            //
            // Perform some additional smart checking on the compression
            // directory if the current machine is local, and the 
            // directory has changed
            //
            if (IsLocal() && m_fCompressionDirectoryChanged)
            {
                //
                // Should exist on the local machine.
                //
                DWORD dwAttr = GetFileAttributes(m_strDirectory);
                if (dwAttr == 0xffffffff 
                    || (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0
                    || IsNetworkPath(m_strDirectory)
                    )
                {
                    ::AfxMessageBox(IDS_ERR_COMPRESS_DIRECTORY);
                    pDX->Fail();
                }

                //
                // Now check to make sure the volume is of the correct
                // type.
                //
                DWORD dwFileSystemFlags;

                if (::GetVolumeInformationSystemFlags(
                    m_strDirectory,
                    &dwFileSystemFlags
                    ))
                {
                    if (!(dwFileSystemFlags & FS_PERSISTENT_ACLS))
                    {
                        //
                        // No ACLS
                        //
                        if (!NoYesMessageBox(IDS_NO_ACL_WARNING))
                        {
                            pDX->Fail();
                        }
                    }

                    if (dwFileSystemFlags & FS_VOL_IS_COMPRESSED
                        || dwAttr & FILE_ATTRIBUTE_COMPRESSED)
                    {
                        //
                        // Compression cache directory is itself compressed
                        //
                        if (!NoYesMessageBox(IDS_COMPRESS_WARNING))
                        {
                            pDX->Fail();
                        }
                    }
                }
            }
        }

        if (!pDX->m_bSaveAndValidate || (m_fEnableLimiting && m_fEnableStatic))
        {
            DDX_Text(pDX, IDC_EDIT_COMPRESS_DIRECTORY_SIZE, m_ilSize);
            DDV_MinMaxLong(pDX, m_ilSize, 1, 1024L);
        }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CDefWebSitePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CDefWebSitePage)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_RADIO_COMPRESS_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_COMPRESS_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_CHECK_DYNAMIC_COMPRESSION, OnCheckDynamicCompression)
    ON_BN_CLICKED(IDC_CHECK_STATIC_COMPRESSION, OnCheckStaticCompression)
    ON_BN_CLICKED(IDC_BUTTON_FILE_TYPES, OnButtonFileTypes)
    ON_BN_CLICKED(IDC_COMPAT_MODE, OnCheckCompatMode)
    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY, OnChangeEditCompressDirectory)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMPRESS_DIRECTORY_SIZE, OnItemChanged)

END_MESSAGE_MAP()



void 
CDefWebSitePage::SetControlStates()
/*++

Routine Description:

    Enable/disable control states depending on the state of
    the dialog.

Arguments:

    None

Return Value:

    None

--*/
{
    GetDlgItem(IDC_STATIC_COMPRESS_DIRECTORY)->EnableWindow(m_fEnableStatic);
    m_edit_Directory.EnableWindow(m_fEnableStatic);
    m_edit_DirectorySize.EnableWindow(m_fEnableStatic && m_fEnableLimiting);
    m_static_MB.EnableWindow(m_fEnableStatic&& m_fEnableLimiting);
    GetDlgItem(IDC_RADIO_COMPRESS_LIMITED)->EnableWindow(m_fEnableStatic);
    GetDlgItem(IDC_RADIO_COMPRESS_UNLIMITED)->EnableWindow(m_fEnableStatic);
    GetDlgItem(IDC_STATIC_MAX_COMPRESS_SIZE)->EnableWindow(m_fEnableStatic);

    //
    // Browse on the local machine only
    //
    m_button_Browse.EnableWindow(IsLocal() && m_fEnableStatic);
}



/* virtual */
HRESULT
CDefWebSitePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    ASSERT(m_ppropCompression == NULL);

    m_ppropCompression = new CIISCompressionProps(QueryAuthInfo());
    if (m_ppropCompression)
    {
        err = m_ppropCompression->LoadData();
        m_fFilterPathFound = err.Succeeded();
        
        if (err.Succeeded())
        {
            m_fEnableDynamic = m_ppropCompression->m_fEnableDynamicCompression;
            m_fEnableStatic = m_ppropCompression->m_fEnableStaticCompression;
            m_fEnableLimiting = m_ppropCompression->m_fLimitDirectorySize;
            {
               TCHAR buf[MAX_PATH];
               ExpandEnvironmentStrings(m_ppropCompression->m_strDirectory, buf, MAX_PATH);
               m_strDirectory = buf;
            }
            m_nUnlimited = m_fEnableLimiting ? RADIO_LIMITED : RADIO_UNLIMITED;

            if (m_ppropCompression->m_dwDirectorySize == 0xffffffff)
            {
                m_ilSize = DEF_MAX_COMPDIR_SIZE / DS_UNITS;
            }
            else
            {
                m_ilSize = m_ppropCompression->m_dwDirectorySize / DS_UNITS;
            }
        }
        else if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Fail quietly
            //
            TRACEEOLID("No compression filters installed");
            err.Reset();    
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

   ASSERT(m_ppropMimeTypes == NULL);
   if (err.Succeeded())
   {
      if (NULL != (m_ppropMimeTypes = new CMimeTypes(
               QueryAuthInfo(), CMetabasePath(TRUE, SZ_MBN_MIMEMAP))))
      {
         err = m_ppropMimeTypes->LoadData();
      }
      else
      {
         err = ERROR_NOT_ENOUGH_MEMORY;
      }
      if (err.Succeeded())
      {
         m_strlMimeTypes = m_ppropMimeTypes->m_strlMimeTypes;
         if (GetSheet()->QueryMajorVersion() >= 6)
         {
             CMetaKey mk(QueryAuthInfo(), QueryMetaPath(), METADATA_PERMISSION_READ);
             err = mk.QueryResult();
             if (err.Succeeded())
             {
                err = mk.QueryValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, m_fCompatMode);
                if (err.Succeeded())
                {
                   m_fInitCompatMode = m_fCompatMode;
                }
             }
          }
          else
          {
             m_fInitCompatMode = m_fCompatMode = TRUE;
          }
      }
   }
   return err;
}



HRESULT
CDefWebSitePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
   ASSERT(IsDirty());

   TRACEEOLID("Saving W3 default web site page now...");

   CError err;
   BeginWaitCursor();

   if (HasCompression())
   {
      ASSERT(m_ppropCompression);
      DWORD dwSize = m_ilSize * DS_UNITS;

      m_ppropCompression->m_fEnableDynamicCompression = m_fEnableDynamic;
      m_ppropCompression->m_fEnableStaticCompression  = m_fEnableStatic;
      m_ppropCompression->m_fLimitDirectorySize       = m_fEnableLimiting;
      // TODO: Replace back %WINDIR% or another system settings in path
      m_ppropCompression->m_strDirectory              = m_strDirectory;
      m_ppropCompression->m_dwDirectorySize           = dwSize;
      err = m_ppropCompression->WriteDirtyProps();
      if (err.Succeeded())
      {
         m_fCompressionDirectoryChanged = FALSE;
      }
   }
   if (err.Succeeded())
   {
      m_ppropMimeTypes->m_strlMimeTypes = m_strlMimeTypes;
      err = m_ppropMimeTypes->WriteDirtyProps();
      if (err.Succeeded() && GetSheet()->QueryMajorVersion() >= 6)
      {
         CMetaKey mk(QueryAuthInfo(), QueryMetaPath(), METADATA_PERMISSION_WRITE);
         err = mk.QueryResult();
         if (err.Succeeded())
         {
            err = mk.SetValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, m_fCompatMode);
            if (err.Succeeded() && m_fCompatMode != m_fInitCompatMode)
            {
               GetSheet()->SetRestartRequired(TRUE);
               // We don't need to save this parameter to sheet,
               // it is important to App Protection combo only, and
               // this combo is disabled for Master props, so it doesn't matter.
            }
         }
      }
   }
   EndWaitCursor();

   return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            



BOOL
CDefWebSitePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Check to make sure compression is supported
    //
    GetDlgItem(IDC_STATIC_COMPRESS_GROUP)->EnableWindow(HasCompression());
    GetDlgItem(IDC_CHECK_DYNAMIC_COMPRESSION)->EnableWindow(HasCompression());
    GetDlgItem(IDC_CHECK_STATIC_COMPRESSION)->EnableWindow(HasCompression());
    GetDlgItem(IDC_RADIO_COMPRESS_UNLIMITED)->EnableWindow(HasCompression());
    GetDlgItem(IDC_RADIO_COMPRESS_LIMITED)->EnableWindow(HasCompression());
    GetDlgItem(IDC_EDIT_COMPRESS_DIRECTORY)->EnableWindow(HasCompression());
    GetDlgItem(IDC_STATIC_MAX_COMPRESS_SIZE)->EnableWindow(HasCompression());
    GetDlgItem(IDC_STATIC_COMPRESS_DIRECTORY)->EnableWindow(HasCompression());
    GetDlgItem(IDC_STATIC_COMPRESS_MB)->EnableWindow(HasCompression());
    GetDlgItem(IDC_EDIT_COMPRESS_DIRECTORY_SIZE)->EnableWindow(HasCompression());
    GetDlgItem(IDC_COMPAT_MODE)->EnableWindow(GetSheet()->QueryMajorVersion() >= 6);

    SetControlStates();

    return TRUE;
}



void 
CDefWebSitePage::OnItemChanged()
/*++

Routine Description:
    
    Handle change in control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
    SetControlStates();
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CDefWebSitePage * pThis = (CDefWebSitePage *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CDefWebSitePage::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}


void 
CDefWebSitePage::OnButtonBrowse() 
{
   ASSERT(IsLocal());
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Directory.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = NULL;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_edit_Directory.SetWindowText(str);
       OnItemChanged();
   }
}



void 
CDefWebSitePage::OnChangeEditCompressDirectory() 
/*++

Routine Description:

    Handle change in compression directory edit box.

Arguments:

    None

Return Value:

    None

--*/
{
    m_fCompressionDirectoryChanged = TRUE;
    OnItemChanged();
}



void 
CDefWebSitePage::OnRadioLimited() 
/*++

Routine Description:

    'Limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fEnableLimiting)
    {
        m_nUnlimited = RADIO_LIMITED;
        m_fEnableLimiting = TRUE;
        OnItemChanged();

        m_edit_DirectorySize.SetSel(0, -1);
        m_edit_DirectorySize.SetFocus();
    }
}



void 
CDefWebSitePage::OnRadioUnlimited() 
/*++

Routine Description:

    'Unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fEnableLimiting)
    {
        m_nUnlimited = RADIO_UNLIMITED;
        m_fEnableLimiting = FALSE;
        OnItemChanged();
    }
}



void 
CDefWebSitePage::OnCheckDynamicCompression() 
/*++

Routine Description:

    "Enable Dynamic Compression' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableDynamic = !m_fEnableDynamic;
    OnItemChanged();
}



void 
CDefWebSitePage::OnCheckStaticCompression() 
/*++

Routine Description:

    "Enable Dynamic Compression' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableStatic = !m_fEnableStatic;
    OnItemChanged();
    if (m_fEnableStatic)
    {
        m_edit_Directory.SetSel(0, -1);
        m_edit_Directory.SetFocus();
    }
}



void 
CDefWebSitePage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();
    
    SAFE_DELETE(m_ppropCompression);
    SAFE_DELETE(m_ppropMimeTypes);
}

void
CDefWebSitePage::OnButtonFileTypes()
{
   AFX_MANAGE_STATE(::AfxGetStaticModuleState());

   CMimeDlg dlg(m_strlMimeTypes, this);

   if (dlg.DoModal() == IDOK)
   {
      OnItemChanged();
   }
}

void
CDefWebSitePage::OnCheckCompatMode()
{
   OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\docum.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        docum.h

   Abstract:

        WWW Documents Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __DOCUM_H__
#define __DOCUM_H__

class CAddDefDocDlg : public CDialog
/*++

Class Description:

    Add default document dialog

Public Interface:
    
    CAddDefDocDlg       : Constructor

    GetDefDocument      : Get the default document entered

--*/
{
//
// Construction
//
public:
    CAddDefDocDlg(IN CWnd * pParent = NULL);

//
// Access:
//
public:                                                   
    CString & GetDefDocument() { return m_strDefDocument; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CAddDefDocDlg)
    enum { IDD = IDD_DEFAULT_DOCUMENT };
    CString m_strDefDocument;
    CButton m_button_Ok;
    CEdit   m_edit_DefDocument;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAddDefDocDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CAddDefDocDlg)
    afx_msg void OnChangeEditDefDocument();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


class CW3DocumentsPage : public CInetPropertyPage
/*++

Class Description:

    Documents property page

Public Interface:

    CW3DocumentsPage      : Constructor
    ~CW3DocumentsPage     : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3DocumentsPage)

//
// Construction
//
public:
    CW3DocumentsPage(IN CInetPropertySheet * pSheet = NULL);
    ~CW3DocumentsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3DocumentsPage)
    enum { IDD = IDD_DIRECTORY_DOCUMENTS };
    BOOL     m_fEnableDefaultDocument;
    BOOL     m_fEnableFooter;
    CString  m_strFooter;
    CEdit    m_edit_Footer;
    CButton  m_check_EnableDefaultDocument;
    CButton  m_check_EnableFooter;
    CButton  m_button_Add;
    CButton  m_button_Remove;
    CButton  m_button_Browse;
    CListBox m_list_DefDocuments;
    //}}AFX_DATA

    DWORD       m_dwDirBrowsing;
    DWORD       m_dwBitRangeDirBrowsing;
    CString     m_strDefaultDocument;

    CUpButton   m_button_Up;
    CDownButton m_button_Down;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3DocumentsPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3DocumentsPage)
    afx_msg void OnCheckEnableDefaultDocument();
    afx_msg void OnCheckEnableDocumentFooter();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonBrowse();
    afx_msg void OnButtonUp();
    afx_msg void OnButtonDown();
    afx_msg void OnSelchangeListDefaultDocument();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    BOOL SetDefDocumentState(BOOL fEnabled);
    BOOL SetDocFooterState(BOOL fEnabled);
    BOOL SetRemoveState();
    BOOL StringFromListBox();
    BOOL DocExistsInList(LPCTSTR lpDoc);
    void SetUpDownStates();
    void ExchangeDocuments(int nLow, int nHigh);
    void MakeFooterCommand(CString & strFooter);
    void ParseFooterCommand(CString & strFooter);
    void StringToListBox();

protected:
    static const LPCTSTR s_lpstrSep;
    static const LPCTSTR s_lpstrFILE;
    static const LPCTSTR s_lpstrSTRING;
    static const LPCTSTR s_lpstrURL;
};


#endif // __DOCUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\errordlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errordlg.cpp

   Abstract:

        Error dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
#include "fltdlg.h"
#include "errordlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//
// HTTP Custom Error Definition
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Static Initialization
//
LPCTSTR CCustomError::s_szSep = _T(",");
LPCTSTR CCustomError::s_szURL = _T("URL");
LPCTSTR CCustomError::s_szFile = _T("FILE");
LPCTSTR CCustomError::s_szNoSubError = _T("*");

#define GET_FIELD()\
    end = strError.Find(s_szSep, start);\
    if (end == -1) \
        break
#define SKIP()\
    start = end + skip
#define GET_INT_FIELD(n)\
    GET_FIELD();\
    (n) = StrToInt(strError.Mid(start, end - start));\
    SKIP()


/* static */
BOOL
CCustomError::CrackErrorString(
    IN  LPCTSTR lpstrErrorString, 
    OUT UINT & nError, 
    OUT UINT & nSubError,
    OUT ERT & nType, 
    OUT CString & str
    )
/*++

Routine Description

    Helper function to parse error string into component parts

Arguments:

    LPCTSTR lpstrErrorString    : Error input string
    UINT & nError               : Error 
    UINT & nSubError            : Sub Error
    int & nType                 : Error type
    CString & str               : Text parameter
    
Return Value:

    TRUE for success, FALSE for failure

--*/
{
    BOOL fSuccess = FALSE;

    do
    {
        CString strError(lpstrErrorString);
        TRACEEOLID(strError);

        int start = 0, end, skip = lstrlen(s_szSep);

        GET_INT_FIELD(nError);
        ASSERT(nError > 0);
        GET_INT_FIELD(nSubError);
        GET_FIELD();
        nType = strError.Mid(start, end - start).CompareNoCase(s_szURL) == 0 
            ? ERT_URL : ERT_FILE;
        SKIP();
        if (-1 != (end = strError.Find(s_szSep, start)))
            str = strError.Mid(start, end - start);
        else
            str = strError.Right(strError.GetLength() - start);
        fSuccess = TRUE;
    }
    while(FALSE);

    return fSuccess;
}



/* static */
void 
CCustomError::CrackErrorDescription(
    IN  LPCTSTR lpstrErrorString, 
    OUT UINT & nError, 
    OUT UINT & nSubError,
    OUT BOOL & fURLSupported,
    OUT CString & str
    )
/*++

Routine Description

    Helper function to parse error description into component parts

Arguments:

    LPCTSTR lpstrErrorString    : Error input string
    UINT & nError               : Error 
    UINT & nSubError            : Sub Error
    BOOL & fURLSupported        : Return TRUE if urls are allowed
    CString & str               : Text parameter
    
Return Value:

    None.

--*/
{
    try
    {
        CString strError(lpstrErrorString);
        TRACEEOLID(strError);

        int start = 0, end, skip = lstrlen(s_szSep);

        do
        {
            GET_INT_FIELD(nError);
            ASSERT(nError > 0);
            GET_INT_FIELD(nSubError);
            GET_FIELD();
            str = strError.Mid(start, end - start);
            SKIP();
            GET_FIELD();
            if (nSubError > 0)
            {
                str += _T(" - ");
                str += strError.Mid(start, end - start);
                SKIP();
                GET_FIELD();
            }
            fURLSupported = end != -1 ? 
                0 == StrToInt(strError.Mid(start, end - start)) : FALSE;
        }
        while (FALSE);
/*
        LPTSTR lp = strError.GetBuffer(0);
        LPTSTR lpField = StringTok(lp, s_szSep);
        nError = _ttoi(lpField);
        ASSERT(nError > 0);
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        nSubError = lpField != NULL ? _ttoi(lpField) : 0;
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        str = lpField;
        lpField = StringTok(NULL, s_szSep);
        ASSERT(lpField != NULL);
        if (nSubError > 0)
        {
            //
            // Add sub error text
            //
            ASSERT(nSubError > 0);
            str += _T(" - ");
            str += lpField;
            lpField = StringTok(NULL, s_szSep);
        }

        ASSERT(lpField != NULL);
        fURLSupported = lpField != NULL ? (_ttoi(lpField) == 0) : FALSE;
*/
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }
}




CCustomError::CCustomError(
    IN LPCTSTR lpstrErrorString
    )
/*++

Routine Description:

   Construct error definition from metabase string
  
Arguments:

    LPCTSTR lpstrErrorString : Error string
    
Return Value:

    N/A 

--*/
    : m_nType(ERT_DEFAULT)
{
    CrackErrorDescription(
        lpstrErrorString,
        m_nError,
        m_nSubError,
        m_fURLSupported,
        m_strDefault
        );
}



void 
CCustomError::BuildErrorString(
    OUT CString & str
    )
/*++

Routine Description:

    Build metabase-ready error string out of the current values

Arguments:

    CString & str : String

Return Value:

    None

--*/
{
    ASSERT(!IsDefault());

    try
    {
        if (m_nSubError > 0)
        {
            str.Format(_T("%d,%d,%s,%s"),
                m_nError,
                m_nSubError,
                IsFile() ? s_szFile : s_szURL,
                (LPCTSTR)m_str
                );
        }
        else
        {
            str.Format(
                _T("%d,%s,%s,%s"),
                m_nError,
                s_szNoSubError,
                IsFile() ? s_szFile : s_szURL,
                (LPCTSTR)m_str
                );
        }
    }
    catch(CMemoryException * e)
    {
        e->ReportError();
        e->Delete();
    }
}



//
// Custom Errors property page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CCustomErrorDlg::CCustomErrorDlg(
    IN OUT CCustomError * pErr,
    IN BOOL fLocal,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Error editing dialog

Arguments:

    CCustomError * pErr   : Error definition to be edited
    BOOL fLocal     : TRUE if the current computer is local
    CWnd * pParent  : Optional parent window or NULL

Return Value:

    N/A

--*/
    : CDialog(CCustomErrorDlg::IDD, pParent),
      m_fLocal(fLocal),
      m_pErr(pErr),
      m_nMessageType(pErr->m_nType),
      m_strTextFile(pErr->m_str),
      m_strDefText(pErr->m_strDefault)
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CCustomErrorDlg)
    m_nMessageType = -1;
    m_strTextFile = _T("");
    m_strDefText = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    VERIFY(m_strFile.LoadString(IDS_FILE_PROMPT));
    VERIFY(m_strURL.LoadString(IDS_URL_PROMPT));
}



void 
CCustomErrorDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCustomErrorDlg)
    DDX_CBIndex(pDX, IDC_COMBO_MESSAGE_TYPE, m_nMessageType);
    DDX_Text(pDX, IDC_STATIC_DEF_TEXT, m_strDefText);
    DDX_Control(pDX, IDC_EDIT_TEXT_FILE, m_edit_TextFile);
    DDX_Control(pDX, IDC_STATIC_SUB_PROMPT, m_static_SubErrorPrompt);
    DDX_Control(pDX, IDC_STATIC_SUB_ERROR_CODE, m_static_SubError);
    DDX_Control(pDX, IDC_STATIC_TEXT_FILE_PROMT, m_static_TextFilePrompt);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_COMBO_MESSAGE_TYPE, m_combo_MessageType);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_STATIC_ERROR_CODE, m_pErr->m_nError);
    DDX_Text(pDX, IDC_STATIC_SUB_ERROR_CODE, m_pErr->m_nSubError);

    DDX_Text(pDX, IDC_EDIT_TEXT_FILE, m_strTextFile);
    m_strTextFile.TrimLeft();
    m_strTextFile.TrimRight();
    if (pDX->m_bSaveAndValidate)
    {
        if (m_nMessageType == CCustomError::ERT_FILE)
        {
            if (PathIsRelative(m_strTextFile) 
              || (m_fLocal && PathIsNetworkPath(m_strTextFile))
               )
            {
                ::AfxMessageBox(IDS_ERR_BAD_PATH);
                pDX->Fail();
            }
            
            if (m_fLocal && 
                (::GetFileAttributes(m_strTextFile) & FILE_ATTRIBUTE_DIRECTORY))
            {
                ::AfxMessageBox(IDS_ERR_FILE_NOT_FOUND);
                pDX->Fail();
            }
        }
        else if (m_nMessageType == CCustomError::ERT_URL)
        {
            if (!IsRelURLPath(m_strTextFile))
            {
                ::AfxMessageBox(IDS_NOT_REL_URL);
                pDX->Fail();
            }
        }
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CCustomErrorDlg, CDialog)
    //{{AFX_MSG_MAP(CCustomErrorDlg)
    ON_CBN_SELCHANGE(IDC_COMBO_MESSAGE_TYPE, OnSelchangeComboMessageType)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_EN_CHANGE(IDC_EDIT_TEXT_FILE, OnChangeEditTextFile)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL
CCustomErrorDlg::SetControlStates()
/*++

Routine Description:

    Set the enabled states of the dialog controls depending on the current
    state of the dialog

Arguments:

    None

Return Value:

    TRUE if file/url is selected, FALSE otherwise

--*/
{
    int nCurSel = m_combo_MessageType.GetCurSel();
    BOOL fFile = nCurSel == CCustomError::ERT_FILE;
    BOOL fDefault = nCurSel == CCustomError::ERT_DEFAULT;
    
    ActivateControl(m_button_Browse, m_fLocal && fFile);

    ActivateControl(m_edit_TextFile,         !fDefault);
    ActivateControl(m_static_TextFilePrompt, !fDefault);
    m_static_TextFilePrompt.SetWindowText(fFile ? m_strFile : m_strURL);

    m_button_OK.EnableWindow(fDefault
        || m_edit_TextFile.GetWindowTextLength() > 0);

    return !fDefault;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CCustomErrorDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Browsing available locally only
    //
    m_button_Browse.EnableWindow(m_fLocal);

    CString str;
    VERIFY(str.LoadString(IDS_DEFAULT_ERROR));
    m_combo_MessageType.AddString(str);
    VERIFY(str.LoadString(IDS_FILE));
    m_combo_MessageType.AddString(str);

    if (m_pErr->URLSupported() || m_nMessageType == CCustomError::ERT_URL)
    {
        VERIFY(str.LoadString(IDS_URL));
        m_combo_MessageType.AddString(str);
    }

    m_combo_MessageType.SetCurSel(m_nMessageType);

    if (m_pErr->m_nSubError == 0)
    {
        DeActivateControl(m_static_SubErrorPrompt);
        DeActivateControl(m_static_SubError);
    }

    SetControlStates();
    
    return TRUE;
}



void 
CCustomErrorDlg::OnSelchangeComboMessageType()
/*++

Routine Description:

    Handle change in message type combo box

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = m_combo_MessageType.GetCurSel();
    if (m_nMessageType == nSel)
    {
        //
        // Selection didn't change
        //
        return;
    }

    m_nMessageType = nSel;

    if (SetControlStates())
    {
        m_edit_TextFile.SetWindowText(_T(""));
        m_edit_TextFile.SetFocus();
    }
}



void 
CCustomErrorDlg::OnChangeEditTextFile()
/*++

Routine Description:

    Handle change in text/file edit box

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CCustomErrorDlg::OnOK()
/*++

Routine Description:

    Handle the OK button being pressed

Arguments:
    
    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        m_pErr->m_nType = (CCustomError::ERT)m_nMessageType;
        m_pErr->m_str = m_strTextFile;
    
        CDialog::OnOK();
    }
}

void 
CCustomErrorDlg::OnButtonBrowse()
/*++

Routine Description:

    Browse for HTML File
    
Arguments:

    None
    
Return Value:

    None 

--*/
{
    ASSERT(m_fLocal);

    //
    // popup the file dialog and let the user select the error htm file
    //
    CString str;
    str.LoadString(IDS_HTML_MASK);
    CFileDialog dlgBrowse(TRUE, NULL, NULL, OFN_HIDEREADONLY, str, this);
    // Disable hook to get Windows 2000 style dialog
	dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

    if (dlgBrowse.DoModal() == IDOK)
    {
        m_pErr->m_str = dlgBrowse.GetPathName();
        m_edit_TextFile.SetWindowText(m_pErr->m_str);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\errordlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errordlg.h

   Abstract:

        Error dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __ERRORDLG_H__
#define __ERRORDLG_H__



class CCustomError : public CObjectPlus
/*++

Class Description:

    Error definitions

Public Interface:

    CCustomError        : Constructors

    IsURL               : TRUE if the custom error is an URL
    IsFILE              : TRUE if the custom error is a file
    IsDefault           : TRUE if the custom error is a default error
    URLSupported        : TRUE if URLS are supported for this error type
    SetValue            : Set the value on the custom error
    MakeDefault         : Make the error a default error

--*/
{
//
// Error types
//
public:
    enum ERT
    {
        ERT_DEFAULT,
        ERT_FILE,
        ERT_URL,
    };

//
// Constructor
//
public:
    //
    // Construct error definition from metabase error
    // error description string.
    //
    CCustomError(LPCTSTR lpstrErrorString);

//
// Access
//
public:
    BOOL IsURL() const;
    BOOL IsFile() const;
    BOOL IsDefault() const;
    BOOL URLSupported() const { return m_fURLSupported; }
    void MakeDefault();
    void SetValue(
        IN ERT nType,
        IN LPCTSTR lpText
        );

//
// Helper Functions
//
public:
    //
    // Build error string
    //
    void BuildErrorString(
        OUT CString & str
        );

    //
    // Parse the error string into component parts
    //  
    static BOOL CrackErrorString(
        IN  LPCTSTR lpstrErrorString, 
        OUT UINT & nError, 
        OUT UINT & nSubError,
        OUT ERT & nType, 
        OUT CString & str
        ); 

protected:
    //
    // Parse error description string into component parts
    //
    static void CrackErrorDescription(
        IN  LPCTSTR lpstrErrorString, 
        OUT UINT & nError, 
        OUT UINT & nSubError,
        OUT BOOL & fURLSupported,
        OUT CString & str
        ); 

//
// Metabase values
//
protected:
    static LPCTSTR s_szSep;
    static LPCTSTR s_szFile;
    static LPCTSTR s_szURL;
    static LPCTSTR s_szNoSubError;

public:
    ERT m_nType;
    UINT m_nError;
    UINT m_nSubError;
    BOOL m_fURLSupported;
    CString m_str;
    CString m_strDefault;
};



class CCustomErrorDlg : public CDialog
/*++

Class Description:

    HTTP Error dialog

Public Interface:

    CCustomErrorDlg       : Constructor

--*/
{
//
// Construction
//
public:
    CCustomErrorDlg(
        IN CCustomError * pErr,
        IN BOOL fLocal,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CCustomErrorDlg)
    enum { IDD = IDD_ERROR_MAPPING };
    int     m_nMessageType;
    CString m_strTextFile;
    CEdit   m_edit_TextFile;
    CStatic m_static_SubErrorPrompt;
    CStatic m_static_SubError;
    CStatic m_static_TextFilePrompt;
    CButton m_button_Browse;
    CButton m_button_OK;
    CComboBox m_combo_MessageType;
    CString m_strDefText;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCustomErrorDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CCustomErrorDlg)
    afx_msg void OnSelchangeComboMessageType();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnChangeEditTextFile();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL SetControlStates();

private:
    BOOL m_fLocal;
    CString m_strFile;
    CString m_strURL;
    CCustomError * m_pErr;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CCustomError::IsURL() const
{
    return m_nType == ERT_URL;
}

inline BOOL CCustomError::IsFile() const
{
    return m_nType == ERT_FILE;
}

inline BOOL CCustomError::IsDefault() const
{
    return m_nType == ERT_DEFAULT;
}

inline void CCustomError::SetValue(
    IN ERT nType,
    IN LPCTSTR lpText
    )
{
    m_str = lpText;
    m_nType = nType;
}

inline void CCustomError::MakeDefault()
{
    m_nType = ERT_DEFAULT;
}

#endif // __ERRORDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\docum.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        docum.cpp

   Abstract:
        WWW Documents Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "supdlgs.h"
#include "docum.h"

#include <lmcons.h>



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CAddDefDocDlg dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CAddDefDocDlg::CAddDefDocDlg(CWnd * pParent OPTIONAL)
    : CDialog(CAddDefDocDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddDefDocDlg)
    m_strDefDocument = _T("");
    //}}AFX_DATA_INIT
}



void 
CAddDefDocDlg::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddDefDocDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_DEF_DOCUMENT, m_edit_DefDocument);
    DDX_Text(pDX, IDC_EDIT_DEF_DOCUMENT, m_strDefDocument);
    DDV_MaxChars(pDX, m_strDefDocument, MAX_PATH);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (!PathIsFileSpec(m_strDefDocument))
        {
            ::AfxMessageBox(IDS_ERR_NO_COMPLETE_PATH);
            pDX->Fail();
        }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CAddDefDocDlg, CDialog)
    //{{AFX_MSG_MAP(CAddDefDocDlg)
    ON_EN_CHANGE(IDC_EDIT_DEF_DOCUMENT, OnChangeEditDefDocument)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CAddDefDocDlg::OnChangeEditDefDocument() 
/*++

Routine Description:

    Respond to a change in the default document edit box

Arguments:

    None./

--*/
{
    m_button_Ok.EnableWindow(m_edit_DefDocument.GetWindowTextLength() > 0);
}



//
// WWW Documents Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CW3DocumentsPage, CInetPropertyPage)



//
// Static Initialization
//
const LPCTSTR CW3DocumentsPage::s_lpstrSep = _T(",");
const LPCTSTR CW3DocumentsPage::s_lpstrFILE = _T("FILE:");
const LPCTSTR CW3DocumentsPage::s_lpstrSTRING = _T("STRING:");
const LPCTSTR CW3DocumentsPage::s_lpstrURL = _T("URL:");



CW3DocumentsPage::CW3DocumentsPage(CInetPropertySheet * pSheet) 
    : CInetPropertyPage(CW3DocumentsPage::IDD, pSheet),
      m_dwBitRangeDirBrowsing(MD_DIRBROW_LOADDEFAULT)
{

#if 0 // Keep Class-wizard happy

    //{{AFX_DATA_INIT(CW3DocumentsPage)
    m_strFooter = _T("");
    m_fEnableDefaultDocument = FALSE;
    m_fEnableFooter = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

}



CW3DocumentsPage::~CW3DocumentsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3DocumentsPage::MakeFooterCommand(CString & strFooter)
/*++

Routine Description:
    Convert the footer document to a full footer string.

Arguments:
    CString & strFooter : On input this is the footer document,
                          at output this will be a full footer command

Return Value:
    None.

Notes:
    Only support FILE: for now

--*/
{
    strFooter.TrimLeft();
    strFooter.TrimRight();

    ASSERT(!PathIsRelative(strFooter));
    strFooter = s_lpstrFILE + strFooter;
}



void
CW3DocumentsPage::ParseFooterCommand(CString & strFooter)
/*++

Routine Description:
    Trim the command from the rest of this command 

Arguments:
    CString & strFooter : On input this is a footer command
                          at output this will be just the footer document
--*/
{
    LPCTSTR lp = strFooter.GetBuffer(0);
    if (!_tcsnccmp(lp, s_lpstrFILE, 5))
    {
        lp += lstrlen(s_lpstrFILE);
    }
    else if (!_tcsnccmp(lp, s_lpstrSTRING, 7))
    {
        lp += lstrlen(s_lpstrSTRING);
    }
    else if (!::_tcsnccmp(lp, s_lpstrURL, 4))
    {
        lp += lstrlen(s_lpstrURL);
    }
    if (lp != strFooter.GetBuffer(0))
    {
        strFooter = lp;
    }
    strFooter.TrimLeft();
}



void
CW3DocumentsPage::StringToListBox()
/*++

Routine Description:

    Parse the default document string, and add each doc
    to the listbox

Arguments:

    None

Return Value:

    None

--*/
{
    int start = 0, end;
    int skip = lstrlen(s_lpstrSep);
    BOOL done = FALSE;
    do
    {
        end = m_strDefaultDocument.Find(s_lpstrSep, start);
        if (end == -1)
        {
            done = TRUE;
            end = m_strDefaultDocument.GetLength();
        }
        CString str = m_strDefaultDocument.Mid(start, end - start);
        str.TrimLeft();
        str.TrimRight();
        m_list_DefDocuments.AddString(str);
        start = end + skip;
    }
    while (!done);
}



BOOL
CW3DocumentsPage::StringFromListBox()
/*++

Routine Description:

    Build up list of default documents from the contents of 
    the listbox.

Arguments:

    None

Return Value:

    TRUE if at least one document was added.

--*/
{
    m_strDefaultDocument.Empty();

    int i;
    for (i = 0; i < m_list_DefDocuments.GetCount(); ++i)
    {
        CString str;
        m_list_DefDocuments.GetText(i, str);
        if (i)
        {
            m_strDefaultDocument += s_lpstrSep;
        }

        m_strDefaultDocument += str;
    }

    return i > 0;
}



void 
CW3DocumentsPage::DoDataExchange(CDataExchange * pDX)
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3DocumentsPage)
    DDX_Check(pDX, IDC_CHECK_ENABLE_DEFAULT_DOCUMENT, m_fEnableDefaultDocument);
    DDX_Check(pDX, IDC_CHECK_ENABLE_DOCUMENT_FOOTER, m_fEnableFooter);
    DDX_Control(pDX, IDC_LIST_DEFAULT_DOCUMENT, m_list_DefDocuments);
    DDX_Control(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_edit_Footer);
    DDX_Control(pDX, IDC_CHECK_ENABLE_DOCUMENT_FOOTER, m_check_EnableFooter);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_BUTTON_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTTON_DOWN, m_button_Down);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate)
    {
        if (m_fEnableDefaultDocument)
        {
            if (!StringFromListBox())
            {
                ::AfxMessageBox(IDS_ERR_DOCUMENTS);
                pDX->Fail();
            }
        }

        if (m_fEnableFooter)
        {
            BeginWaitCursor();
            DDX_Text(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_strFooter);
            DDV_MinMaxChars(pDX, m_strFooter, 1, MAX_PATH);
            if (PathIsRelative(m_strFooter))
            {
                //
                // Footer doc must be a complete path
                //
                ::AfxMessageBox(IDS_ERR_COMPLETE_PATH);
                pDX->Fail();
            }
            else if (IsLocal() && PathIsNetworkPath(m_strFooter))
            {
                //
                // Footer doc must be on local machine.
                //
                ::AfxMessageBox(IDS_NOT_LOCAL_FOOTER);
                pDX->Fail();
            }
            else if (IsLocal() && 
                (::GetFileAttributes(m_strFooter) & FILE_ATTRIBUTE_DIRECTORY))
            {
                //
                // And lastly, but not leastly, the footer document should exist
                //
                ::AfxMessageBox(IDS_ERR_FILE_NOT_FOUND);
                pDX->Fail();
            }
            else
            {
                MakeFooterCommand(m_strFooter);
            }
            EndWaitCursor();
        }
//        else
//        {
//            m_strFooter.Empty();
//        }
    }
    else
    {
        ParseFooterCommand(m_strFooter);
        DDX_Text(pDX, IDC_EDIT_DOCUMENT_FOOTER, m_strFooter);
        DDV_MinMaxChars(pDX, m_strFooter, 1, MAX_PATH);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3DocumentsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3DocumentsPage)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_DEFAULT_DOCUMENT, OnCheckEnableDefaultDocument)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_DOCUMENT_FOOTER, OnCheckEnableDocumentFooter)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_UP, OnButtonUp)
    ON_BN_CLICKED(IDC_BUTTON_DOWN, OnButtonDown)
    ON_LBN_SELCHANGE(IDC_LIST_DEFAULT_DOCUMENT, OnSelchangeListDefaultDocument)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_DEFAULT_DOCUMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOCUMENT_FOOTER, OnItemChanged)

END_MESSAGE_MAP()



void 
CW3DocumentsPage::SetUpDownStates()
{
    int nLast = m_list_DefDocuments.GetCount() - 1;
    int nSel = m_list_DefDocuments.GetCurSel();

    m_button_Up.EnableWindow(nSel > 0);
    m_button_Down.EnableWindow(nSel >= 0 && nSel < nLast);
}



BOOL
CW3DocumentsPage::SetRemoveState()
{
    BOOL fEnabled = m_fEnableDefaultDocument
        && (m_list_DefDocuments.GetCurSel() != LB_ERR);

    m_button_Remove.EnableWindow(fEnabled);

    return fEnabled;
}



BOOL 
CW3DocumentsPage::SetDefDocumentState(BOOL fEnabled)
/*++

Routine Description:

    Set the enabled states of the Default Documents state

Arguments:

    BOOL fEnabled       : TRUE if default document is on

Return Value:

    TRUE if default document is on

--*/
{
    m_button_Add.EnableWindow(fEnabled);
    m_button_Up.EnableWindow(fEnabled);
    m_button_Down.EnableWindow(fEnabled);
    m_list_DefDocuments.EnableWindow(fEnabled);
    SetRemoveState();

    return fEnabled;
}



BOOL 
CW3DocumentsPage::SetDocFooterState(BOOL fEnabled)
/*++

Routine Description:

    Set the enabled state of the footer documents

Arguments:

    BOOL fEnabled       : TRUE if footers are on

Return Value:

    TRUE if footers are on

--*/
{
    m_edit_Footer.EnableWindow(fEnabled);
    m_button_Browse.EnableWindow(IsLocal() && fEnabled);

    return fEnabled;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3DocumentsPage::OnItemChanged()
{
    SetModified(TRUE);
}



void 
CW3DocumentsPage::OnCheckEnableDefaultDocument()
{
    m_fEnableDefaultDocument = !m_fEnableDefaultDocument;
    SetDefDocumentState(m_fEnableDefaultDocument);
    OnItemChanged();
}



void 
CW3DocumentsPage::OnCheckEnableDocumentFooter()
{
    m_fEnableFooter = !m_fEnableFooter;
    if (SetDocFooterState(m_fEnableFooter))
    {
        m_edit_Footer.SetSel(0,-1);
        m_edit_Footer.SetFocus();        
    }

    OnItemChanged();
}



BOOL 
CW3DocumentsPage::OnInitDialog()
{
    CInetPropertyPage::OnInitDialog();

    //
    // Make sure the up/down buttons show up correctly
    //
    CRect rc;
    GetDlgItem(IDC_BUTTONUP)->GetWindowRect(&rc);
    GetDlgItem(IDC_BUTTONUP)->DestroyWindow();
    ScreenToClient(&rc);
    m_button_Up.Create(NULL, 
       WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_OWNERDRAW, rc, this, IDC_BUTTON_UP);
    m_button_Up.LoadBitmaps(IDB_BUTTONUPU, IDB_BUTTONUPD, IDB_BUTTONUPF, IDB_BUTTONUPX);
    m_button_Up.SizeToContent();

    GetDlgItem(IDC_BUTTONDN)->GetWindowRect(&rc);
    GetDlgItem(IDC_BUTTONDN)->DestroyWindow();
    ScreenToClient(&rc);
    m_button_Down.Create(NULL, 
       WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_OWNERDRAW, rc, this, IDC_BUTTON_DOWN);
    m_button_Down.LoadBitmaps(IDB_BUTTONDNU, IDB_BUTTONDND, IDB_BUTTONDNF, IDB_BUTTONDNX);
    m_button_Down.SizeToContent();

    StringToListBox();

    SetDefDocumentState(m_fEnableDefaultDocument);
    SetDocFooterState(m_fEnableFooter);
    SetUpDownStates();
    SetRemoveState();

    return TRUE;  
}



/* virtual */
HRESULT
CW3DocumentsPage::FetchLoadedValues()
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_dwDirBrowsing);
        FETCH_DIR_DATA_FROM_SHEET(m_strDefaultDocument);
        FETCH_DIR_DATA_FROM_SHEET(m_fEnableFooter);
        FETCH_DIR_DATA_FROM_SHEET(m_strFooter);
        m_fEnableDefaultDocument = IS_FLAG_SET(
            m_dwDirBrowsing, 
            MD_DIRBROW_LOADDEFAULT
            );
    END_META_DIR_READ(err)

    return err;
}



HRESULT
CW3DocumentsPage::SaveInfo()
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 documents page now...");

    CError err;

    SET_FLAG_IF(m_fEnableDefaultDocument, m_dwDirBrowsing, MD_DIRBROW_LOADDEFAULT);

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        INIT_DIR_DATA_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_strDefaultDocument)
        //STORE_DIR_DATA_ON_SHEET_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_dwDirBrowsing)
        STORE_DIR_DATA_ON_SHEET(m_fEnableFooter)
        CString buf = m_strFooter;
        if (!m_fEnableFooter)
        {
           m_strFooter.Empty();
        }
        STORE_DIR_DATA_ON_SHEET(m_strFooter)
        m_strFooter = buf;
    END_META_DIR_WRITE(err)
    if (err.Succeeded())
    {
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
    }

    EndWaitCursor();

    return err;
}



int
CW3DocumentsPage::DocExistsInList(LPCTSTR lpDoc)
/*++

Routine Description:

    Check to see if the given document exists in the list

Arguments:

    LPCTSTR lpDoc   : Document to check

Return Value:

    The index where the item exists or LB_ERR if it doesn't exist.

--*/
{
    CString str;
    for (int n = 0; n < m_list_DefDocuments.GetCount(); ++n)
    {
        m_list_DefDocuments.GetText(n, str);
        if (!str.CompareNoCase(lpDoc))
        {
            return n;
        }
    }

    return LB_ERR;
}


void 
CW3DocumentsPage::OnButtonAdd() 
{
    CAddDefDocDlg dlg;
    if (dlg.DoModal() == IDOK)
    {
        //
        // Check to see if it existed already
        //
        try
        {
            int nSel;
            CString strNewDoc(dlg.GetDefDocument());
            
            if ((nSel = DocExistsInList(strNewDoc)) != LB_ERR)
            {
                m_list_DefDocuments.SetCurSel(nSel);
                ::AfxMessageBox(IDS_DUPLICATE_DOC);
                return;
            }

            nSel = m_list_DefDocuments.AddString(strNewDoc);
            if (nSel >= 0)
            {
                m_list_DefDocuments.SetCurSel(nSel);
                SetUpDownStates();
                SetRemoveState();
                OnItemChanged();
            }
        }
        catch(CMemoryException * e)
        {
            e->ReportError();
            e->Delete();
        }
    }
}



void 
CW3DocumentsPage::OnButtonRemove() 
{
    int nSel = m_list_DefDocuments.GetCurSel();
    if (nSel >= 0)
    {
        m_list_DefDocuments.DeleteString(nSel);
        if (nSel >= m_list_DefDocuments.GetCount())
        {
           --nSel;
        }
        m_list_DefDocuments.SetCurSel(nSel);
        SetUpDownStates();
        OnItemChanged();

        if (!SetRemoveState())
        {
            //
            // Make sure we don't focus on a disabled button
            //
            m_button_Add.SetFocus();
        }
    }
}



void 
CW3DocumentsPage::OnButtonBrowse() 
{
    ASSERT(IsLocal());

    //
    // Pop up the file dialog and let the user select the footer htm file.
    //
    CString str;
    str.LoadString(IDS_HTML_MASK);
    CFileDialog dlgBrowse(TRUE, NULL, NULL, OFN_HIDEREADONLY, str, this);

    //
    // If the new style of file-open dialog is requested, comment
    // out the DoModal, and remove the other two comments.
    //
    dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

    if (dlgBrowse.DoModal() == IDOK)
    //if (GetOpenFileName(&dlgBrowse.m_ofn))
    {
        m_edit_Footer.SetWindowText(dlgBrowse.GetPathName());
    }
}



void
CW3DocumentsPage::ExchangeDocuments(
    IN int nLow,
    IN int nHigh
    )
/*++

Routine Description:

    Exchange two documents in the listbox

Arguments:

    int nLow   : Low item
    int nHigh  : High item

Return Value:

    None.

--*/
{
    ASSERT(nLow < nHigh);
    CString str;
    m_list_DefDocuments.GetText(nLow, str);
    m_list_DefDocuments.DeleteString(nLow);
    m_list_DefDocuments.InsertString(nHigh, str);
    OnItemChanged();
}



void 
CW3DocumentsPage::OnButtonUp() 
/*++

Routine Description:

    Move the currently selected doc up

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_DefDocuments.GetCurSel();
    ExchangeDocuments(nCurSel - 1, nCurSel);
    m_list_DefDocuments.SetCurSel(nCurSel - 1);
    m_list_DefDocuments.SetFocus();
    SetUpDownStates();
}



void 
CW3DocumentsPage::OnButtonDown() 
/*++

Routine Description:

    Move the currently selected doc down

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_DefDocuments.GetCurSel();
    ExchangeDocuments(nCurSel, nCurSel + 1);
    m_list_DefDocuments.SetCurSel(nCurSel + 1);
    m_list_DefDocuments.SetFocus();
    SetUpDownStates();
}



void 
CW3DocumentsPage::OnSelchangeListDefaultDocument() 
{
    SetUpDownStates();
    SetRemoveState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\errors.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errors.cpp

   Abstract:

        HTTP errors property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
#include "fltdlg.h"
#include "errors.h"
#include "errordlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CCustomErrorsListBox : a listbox of CCustomError objects
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Column width relative weights
//
#define WT_HTTP_ERROR     3
#define WT_OUTPUT_TYPE    2
#define WT_CONTENTS       8

//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("Errors");

//
// Key under w3svc where the error descriptions live
//
const TCHAR g_cszErrorLocation[] = _T("Info");



IMPLEMENT_DYNAMIC(CCustomErrorsListBox, CHeaderListBox);



const int CCustomErrorsListBox::nBitmaps = 3;



CCustomErrorsListBox::CCustomErrorsListBox(
    IN UINT nIDDefault,
    IN UINT nIDFile,
    IN UINT nIDURL
    )
/*++

Routine Description:

    Error listbox constructor

Arguments:

    UINT nIDDefault : String ID for 'default'
    UINT nIDFile    : String ID for 'file'
    UINT nIDURL     : String ID for 'URL'

--*/
     : CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
    VERIFY(m_str[CCustomError::ERT_DEFAULT].LoadString(nIDDefault));
    VERIFY(m_str[CCustomError::ERT_FILE].LoadString(nIDFile));
    VERIFY(m_str[CCustomError::ERT_URL].LoadString(nIDURL));
}


void
CCustomErrorsListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CCustomError * p = (CCustomError *)ds.m_ItemData;
    ASSERT(p != NULL);

    DrawBitmap(ds, 0, p->m_nType);

    CString strError, strText;

    if (p->m_nSubError > 0)
    {
        strError.Format(_T("%d;%d"), p->m_nError, p->m_nSubError);
    }
    else
    {
        strError.Format(_T("%d"), p->m_nError);
    }

    ColumnText(ds, 0, TRUE, strError);
    ColumnText(ds, 1, FALSE, m_str[p->m_nType] );

    if (p->IsDefault())
    {
        strText.Format(_T("\"%s\""), p->m_strDefault);
    }
    else
    {
        strText = p->m_str;
    }

    ColumnText(ds, 2, FALSE, strText);
}



/* virtual */
BOOL
CCustomErrorsListBox::Initialize()
/*++

Routine Description:

    initialize the listbox.  Insert the columns
    as requested, and lay them out appropriately

Arguments:

    None

Return Value:

    TRUE if initialized successfully, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    HINSTANCE hInst = AfxGetResourceHandle();
    InsertColumn(0, WT_HTTP_ERROR, IDS_HTTP_ERROR, hInst);
    InsertColumn(1, WT_OUTPUT_TYPE, IDS_OUTPUT_TYPE, hInst);
    InsertColumn(2, WT_CONTENTS, IDS_CONTENTS, hInst);

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    SetRedraw(TRUE);

    return TRUE;
}



CHTTPErrorDescriptions::CHTTPErrorDescriptions(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Constructor for default errors object.  This fetches the default
    error definitions

Arguments:

    LPCTSTR lpServerName : Server name

Return Value:

    None

--*/
    : CMetaProperties(
        QueryAuthInfo(),
        CMetabasePath(g_cszSvc, MASTER_INSTANCE, g_cszErrorLocation)
        )
{       
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwMDDataType = MULTISZ_METADATA;
}



/* virtual */
void
CHTTPErrorDescriptions::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_CUSTOM_ERROR_DESC, m_strlErrorDescriptions)
    END_PARSE_META_RECORDS
}



//
// Errors property page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CW3ErrorsPage, CInetPropertyPage)



CW3ErrorsPage::CW3ErrorsPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW error property page

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A


--*/
    : CInetPropertyPage(CW3ErrorsPage::IDD, pSheet),
      m_list_Errors(IDS_DEFAULT_ERROR, IDS_FILE, IDS_URL),
      m_ListBoxRes(IDB_ERRORS, m_list_Errors.nBitmaps),
      m_strlCustomErrors(),
      m_strlErrorDescriptions(),
      m_oblErrors()
{
    //{{AFX_DATA_INIT(CW3ErrorsPage)
    //}}AFX_DATA_INIT

    m_list_Errors.AttachResources(&m_ListBoxRes);
}



CW3ErrorsPage::~CW3ErrorsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}

void
CW3ErrorsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3ErrorsPage)
    DDX_Control(pDX, IDC_BUTTON_SET_TO_DEFAULT, m_button_SetDefault);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_ERRORS, m_list_Errors);

    if (pDX->m_bSaveAndValidate)
    {
        CError err(StoreErrors());
        if (err.MessageBoxOnFailure())
        {
            pDX->Fail();
        }
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3ErrorsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3ErrorsPage)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_SET_TO_DEFAULT, OnButtonSetToDefault)
    ON_LBN_DBLCLK(IDC_LIST_ERRORS, OnDblclkListErrors)
    ON_LBN_SELCHANGE(IDC_LIST_ERRORS, OnSelchangeListErrors)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CW3ErrorsPage::FillListBox()
/*++

Routine Description:

    Populate the listbox with the directory entries

Arguments:

    None

Return Value:

    None

--*/
{
    CObListIter obli(m_oblErrors);
    CCustomError * pError;

    //
    // Remember the selection.
    //
    int nCurSel = m_list_Errors.GetCurSel();

    m_list_Errors.SetRedraw(FALSE);
    m_list_Errors.ResetContent();
    int cItems = 0;

    for (/**/; pError = (CCustomError *)obli.Next(); ++cItems)
    {
        m_list_Errors.AddItem(pError);
    }

    m_list_Errors.SetRedraw(TRUE);
    m_list_Errors.SetCurSel(nCurSel);
}



HRESULT
CW3ErrorsPage::StoreErrors()
/*++

Routine Description:

    Build errors stringlist from the error oblist built up.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CError err;

    try
    {
        m_strlCustomErrors.RemoveAll();
        POSITION pos = m_oblErrors.GetHeadPosition();

        while(pos)
        {
            CCustomError * pErr = (CCustomError *)m_oblErrors.GetNext(pos);
            if (!pErr->IsDefault())
            {
                CString str;
                pErr->BuildErrorString(str);
                m_strlCustomErrors.AddTail(str);
            }
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    return err;
}



CCustomError *
CW3ErrorsPage::FindError(
    IN UINT nError,
    IN UINT nSubError
    )
/*++

Routine Description:

    Find error in the list with the given error code and suberror code

Arguments:

    UINT nError     : Error code
    UINT nSubError  : Sub error code

Return Value:

    Pointer to the error or NULL if not found.

--*/
{
    CCustomError * pErr = NULL;

    POSITION pos = m_oblErrors.GetHeadPosition();
    while(pos)
    {
        pErr = (CCustomError *)m_oblErrors.GetNext(pos);
        ASSERT(pErr != NULL);
        if (pErr->m_nError == nError && pErr->m_nSubError == nSubError)
        {
            //
            // Found it!
            //
            return pErr;
        }
    }

    //
    // Not found!
    //
    return NULL;
}



HRESULT
CW3ErrorsPage::FetchErrors()
/*++

Routine Description:

    Build up the errors list

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CError err;

    CWaitCursor wait;

    do
    {
        try
        {
            //
            // First get the default descriptions
            //
            CHTTPErrorDescriptions ed(QueryServerName());
            err = ed.LoadData();
            if (err.Failed())
            {
                break;
            }

            if (!ed.GetErrorDescriptions().IsEmpty())
            {
                POSITION pos = ed.GetErrorDescriptions().GetHeadPosition();

                while(pos)
                {
                    CString & str = ed.GetErrorDescriptions().GetNext(pos);
                    m_oblErrors.AddTail(new CCustomError(str));
                }
            }
            else
            {
                ::AfxMessageBox(IDS_NO_DEF_ERRORS);
                break;
            }

            //
            // Now match up the overrides if any
            //
            POSITION pos = m_strlCustomErrors.GetHeadPosition();
            while(pos)
            {
                CString & strError = m_strlCustomErrors.GetNext(pos);

                TRACEEOLID(strError);

                UINT nError;
                UINT nSubError;
                CCustomError::ERT nType;
                CString str;
                CCustomError * pErr = NULL;

                if (CCustomError::CrackErrorString(
                    strError, 
                    nError, 
                    nSubError, 
                    nType, 
                    str
                    ))
                {
                    pErr = FindError(nError, nSubError);
                }

                if (pErr != NULL)
                {
                    pErr->SetValue(nType, str);
                }
                else
                {
                    CString strFmt;
                    strFmt.LoadString(IDS_BAD_ERROR);

                    str.Format(strFmt, nError, nSubError);
                    ::AfxMessageBox(str);
                    break;
                }
            }

            FillListBox();
        }
        catch(CMemoryException * e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            e->Delete();
        }
    }
    while(FALSE);

    return err;
}



void
CW3ErrorsPage::SetControlStates()
/*++

Routine Description:

    Enable/disable controls depending on the state of
    the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    CCustomError * pErr = GetSelectedListItem();

    m_button_Edit.EnableWindow(pErr != NULL);
    m_button_SetDefault.EnableWindow(m_list_Errors.GetSelCount() > 0);
}


INT_PTR
CW3ErrorsPage::ShowPropertyDialog()
/*++

Routine Description:

    Display the add/edit dialog.  The return
    value is the value returned by the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel;
    CCustomError * pErr = GetSelectedListItem(&nCurSel);

    if (pErr == NULL)
    {
        //
        // Must be from a double click on extended selection
        //
        return IDCANCEL;
    }
    
    CCustomErrorDlg dlgError(pErr, IsLocal(), this);
    INT_PTR nReturn = dlgError.DoModal();

    if (nReturn == IDOK)
    {
        //
        // Re-display the text
        //
        m_list_Errors.InvalidateSelection(nCurSel);
        SetModified(TRUE);
    }

    return nReturn;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CW3ErrorsPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_list_Errors.Initialize();

    //
    // Build filters oblist
    //
    CError err(FetchErrors());
    err.MessageBoxOnFailure();
    SetControlStates();

    return TRUE;
}



void
CW3ErrorsPage::OnButtonEdit()
/*++

Routine Description:

    'edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertyDialog() == IDOK)
    {
        SetControlStates();
        SetModified(TRUE);
    }
}



void
CW3ErrorsPage::OnButtonSetToDefault()
/*++

Routine Description:

    'set to default' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Apply to each selected item
    //
    m_list_Errors.SetRedraw(FALSE);

    int nSel = 0;
    int cChanges = 0;
    CCustomError * pErr;
    while ((pErr = GetNextSelectedItem(&nSel)) != NULL)
    {
        if (!pErr->IsDefault())
        {
            //
            // Force a redraw of the current item
            //
            pErr->MakeDefault();
            m_list_Errors.InvalidateSelection(nSel);
            ++cChanges;
        }

        ++nSel;
    }

    if (cChanges)
    {    
        SetModified(TRUE);
    }

    m_list_Errors.SetRedraw(TRUE);
    SetControlStates();
}



void
CW3ErrorsPage::OnDblclkListErrors()
/*++

Routine Description:

    error list 'double click' handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CW3ErrorsPage::OnSelchangeListErrors()
/*++

Routine Description:

    error list selection change handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



/* virtual */
HRESULT
CW3ErrorsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_strlCustomErrors);
    END_META_DIR_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3ErrorsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 errors page now...");

    CError err;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_strlCustomErrors)
    END_META_DIR_WRITE(err)

	if (err.Succeeded())
	{
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
	}

    EndWaitCursor();

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\facc.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        facc.h

   Abstract:

        FTP Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FACC_H__
#define __FACC_H__

class CFtpAccountsPage : public CInetPropertyPage
{
/*++

Class Description:

    FTP Service property page

Public Interface:

    CFtpAccountsPage  : Constructor
    ~CFtpAccountsPage : Destructor

--*/
    DECLARE_DYNCREATE(CFtpAccountsPage)

//
// Constructor/Destructor
//
public:
    CFtpAccountsPage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpAccountsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpAccountsPage)
    enum { IDD = IDD_FTP_ACCOUNTS };
    BOOL    m_fAllowAnonymous;
    BOOL    m_fOnlyAnonymous;
    BOOL    m_fPasswordSync;
    CString m_strUserName;
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    CStatic m_static_Password;
    CStatic m_static_UserName;
    CStatic m_static_AccountPrompt;
    CButton m_button_Add;
    CButton m_button_CheckPassword;
    CButton m_button_Browse;
    CButton m_button_CurrentSessions;
    CButton m_button_RemoveAdministrator;
    CButton m_chk_PasswordSync;
    CButton m_chk_AllowAnymous;
    CButton m_chk_OnlyAnonymous;
    //}}AFX_DATA

    CString m_strPassword;
    CAccessEntryListBox m_list_Administrators;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpAccountsPage)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    void SetControlStates(BOOL fAllowAnonymous);
    BOOL SetAdminRemoveState();

    //{{AFX_MSG(CFtpAccountsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnButtonBrowseUser();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonDelete();
    afx_msg void OnCheckAllowAnonymous();
    afx_msg void OnCheckAllowOnlyAnonymous();
    afx_msg void OnCheckEnablePwSynchronization();
    afx_msg void OnSelchangeListAdministrators();
    afx_msg void OnChangeEditUsername();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fPasswordSyncChanged;
    BOOL m_fPasswordSyncMsgShown;
    BOOL m_fUserNameChanged;
    CString m_strServerName;
    CRMCListBoxResources m_ListBoxRes;
    CObListPlus m_oblSID;
};



#endif // __FACC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\errors.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        errors.h

   Abstract:

        HTTP errors property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Forward definitions
//
class CCustomError;



class CCustomErrorsListBox : public CHeaderListBox
/*++

Class Description:

    A listbox of CCustomError objects

Public Interface:

    CCustomErrorsListBox    : Constructor

    GetItem                 : Get error object at index
    AddItem                 : Add item to listbox
    InsertItem              : Insert item into the listbox
    Initialize              : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CCustomErrorsListBox);

public:
    static const nBitmaps;  // Number of bitmaps

public:
    CCustomErrorsListBox(UINT nIDDefault, UINT nIDFile, UINT nIDURL);

public:
    CCustomError * GetItem(UINT nIndex);
    int AddItem(CCustomError * pItem);
    int InsertItem(int nPos, CCustomError * pItem);
    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);

private:
    CString m_str[3];
};



class CHTTPErrorDescriptions : public CMetaProperties
/*++

Class Description:

    List of HTTP error descriptions

Public Interface:

    CHTTPErrorDescriptions  : Constructor

--*/
{
//
// Constructor
//
public:
    CHTTPErrorDescriptions(LPCTSTR lpServerName);

//
// Access
//
public:
    CStringList & GetErrorDescriptions() { return m_strlErrorDescriptions; }

protected:
    virtual void ParseFields();

//
// Data
//
private:
    MP_CStringListEx m_strlErrorDescriptions;
};



class CW3ErrorsPage : public CInetPropertyPage
/*++

Class Description:

    WWW Errors property page

Public Interface:

    CW3ErrorsPage       : Constructor
    CW3ErrorsPage       : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3ErrorsPage)

//
// Construction
//
public:
    CW3ErrorsPage(CInetPropertySheet * pSheet = NULL);
    ~CW3ErrorsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3ErrorsPage)
    enum { IDD = IDD_DIRECTORY_ERRORS };
    CButton m_button_SetDefault;
    CButton m_button_Edit;
    //}}AFX_DATA

    CCustomErrorsListBox  m_list_Errors;
    CStringListEx         m_strlCustomErrors;
    CStringListEx         m_strlErrorDescriptions;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3ErrorsPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3ErrorsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnDblclkListErrors();
    afx_msg void OnSelchangeListErrors();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonSetToDefault();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    void FillListBox();
    INT_PTR ShowPropertyDialog();
    CCustomError * GetSelectedListItem(int * pnSel = NULL);
    CCustomError * GetNextSelectedItem(int * pnStartingIndex);
    CCustomError * FindError(UINT nError, UINT nSubError);
    HRESULT FetchErrors();
    HRESULT StoreErrors();

private:
    CRMCListBoxResources m_ListBoxRes;
    CObListPlus m_oblErrors;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CCustomError * CCustomErrorsListBox::GetItem(UINT nIndex)
{
    return (CCustomError *)GetItemDataPtr(nIndex);
}

inline int CCustomErrorsListBox::AddItem(CCustomError * pItem)
{
    return AddString((LPCTSTR)pItem);
}

inline int CCustomErrorsListBox::InsertItem(int nPos, CCustomError * pItem)
{
    return InsertString(nPos, (LPCTSTR)pItem);
}

inline CCustomError * CW3ErrorsPage ::GetSelectedListItem(
    OUT int * pnSel OPTIONAL
    )
{
    return (CCustomError *)m_list_Errors.GetSelectedListItem(pnSel);
}

inline CCustomError * CW3ErrorsPage::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CCustomError *)m_list_Errors.GetNextSelectedItem(pnStartingIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\facc.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        facc.cpp

   Abstract:

        FTP Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "ftpsht.h"
#include "facc.h"




#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



IMPLEMENT_DYNCREATE(CFtpAccountsPage, CInetPropertyPage)



CFtpAccountsPage::CFtpAccountsPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for FTP service property page

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CFtpAccountsPage::IDD, pSheet),
      m_ListBoxRes(
        IDB_ACLUSERS,
        CAccessEntryListBox::nBitmaps
        ),
      m_oblSID(),
      m_fPasswordSyncChanged(FALSE),
      m_fUserNameChanged(FALSE),
      m_fPasswordSyncMsgShown(FALSE)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CFtpAccountsPage)
    m_strUserName = _T("");
    m_fAllowAnonymous = TRUE;
    m_fOnlyAnonymous = FALSE;
    m_fPasswordSync = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

    m_list_Administrators.AttachResources(&m_ListBoxRes);
}



CFtpAccountsPage::~CFtpAccountsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpAccountsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpAccountsPage)
    DDX_Check(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_fAllowAnonymous);
    DDX_Check(pDX, IDC_CHECK_ONLY_ANYMOUS, m_fOnlyAnonymous);
    DDX_Check(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_fPasswordSync);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_STATIC_PW, m_static_Password);
    DDX_Control(pDX, IDC_STATIC_USERNAME, m_static_UserName);
    DDX_Control(pDX, IDC_STATIC_ACCOUNT_PROMPT, m_static_AccountPrompt);
    DDX_Control(pDX, IDC_BUTTON_CHECK_PASSWORD, m_button_CheckPassword);
    DDX_Control(pDX, IDC_BUTTON_BROWSE_USER, m_button_Browse);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_RemoveAdministrator);
    DDX_Control(pDX, IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, m_chk_PasswordSync);
    DDX_Control(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_chk_AllowAnymous);
    DDX_Control(pDX, IDC_CHECK_ONLY_ANYMOUS, m_chk_OnlyAnonymous);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_LIST_ADMINISTRATORS, m_list_Administrators);

    //
    // Set password/username only during load stage,
    // or if saving when allowing anonymous logons
    //
    if (!pDX->m_bSaveAndValidate || m_fAllowAnonymous)
    {
        DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
        DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);

        //
        // Some people have a tendency to add "\\" before
        // the computer name in user accounts.  Fix this here.
        //
        m_strUserName.TrimLeft();

        while (*m_strUserName == '\\')
        {
            m_strUserName = m_strUserName.Mid(2);
        }


        //
        // Display the remote password sync message if
        // password sync is on, the account is not local,
        // password sync has changed or username has changed
        // and the message hasn't already be shown.
        //
        if (pDX->m_bSaveAndValidate && m_fPasswordSync 
            && !IsLocalAccount(m_strUserName)
            && (m_fPasswordSyncChanged || m_fUserNameChanged)
            && !m_fPasswordSyncMsgShown
            )
        {
            if (!NoYesMessageBox(IDS_WRN_PWSYNC))
            {
                pDX->Fail();
            }

            //
            // Don't show it again
            //
            m_fPasswordSyncMsgShown = TRUE;
        }

        if (!m_fPasswordSync || !pDX->m_bSaveAndValidate)
        {
            DDX_Password(
                pDX, 
                IDC_EDIT_PASSWORD, 
                m_strPassword, 
                g_lpszDummyPassword
                );
        }

        if (!m_fPasswordSync)
        {
            DDV_MaxChars(pDX, m_strPassword, PWLEN);
        }
    }

}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpAccountsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpAccountsPage)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_CBN_SELCHANGE(IDC_LIST_ADMINISTRATORS, OnSelchangeListAdministrators)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_PW_SYNCHRONIZATION, OnCheckEnablePwSynchronization)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_ALLOW_ANONYMOUS, OnCheckAllowAnonymous)
    ON_BN_CLICKED(IDC_CHECK_ONLY_ANYMOUS, OnCheckAllowOnlyAnonymous)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USER, OnButtonBrowseUser)

END_MESSAGE_MAP()



void
CFtpAccountsPage::SetControlStates(
    IN BOOL fAllowAnonymous
    )
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    BOOL fAllowAnonymous : If TRUE, 'allow anonymous' is on.

Return Value:

    None

--*/
{
    m_static_Password.EnableWindow(
        fAllowAnonymous 
     && !m_fPasswordSync 
     && HasAdminAccess()
        );

    m_edit_Password.EnableWindow(
        fAllowAnonymous 
     && !m_fPasswordSync
     && HasAdminAccess()
        );

    m_button_CheckPassword.EnableWindow(
        fAllowAnonymous 
     && !m_fPasswordSync
     && HasAdminAccess()
        );

    m_static_AccountPrompt.EnableWindow(fAllowAnonymous);
    m_static_UserName.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_edit_UserName.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_button_Browse.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_chk_PasswordSync.EnableWindow(fAllowAnonymous && HasAdminAccess());
    m_chk_OnlyAnonymous.EnableWindow(fAllowAnonymous);
}



BOOL
CFtpAccountsPage::SetAdminRemoveState()
/*++

Routine Description:

    Set the state of the remove button depending on the selection in the
    administrators listbox.  Remove is only enabled if ALL selected
    items are removable.

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled.

--*/
{
    int nSel = 0;
    int cSelectedItems = 0;
    BOOL fAllDeletable = TRUE;
    CAccessEntry * pAccess;

    while ((pAccess = m_list_Administrators.GetNextSelectedItem(&nSel)) != NULL)
    {
        ++cSelectedItems;

        if (!pAccess->IsDeletable())
        {
            fAllDeletable = FALSE;
            break;
        }

        ++nSel;
    }

    fAllDeletable = fAllDeletable && (cSelectedItems > 0);

    m_button_RemoveAdministrator.EnableWindow(
        fAllDeletable 
     && HasOperatorList()
     && HasAdminAccess()
        );

    return fAllDeletable;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


BOOL
CFtpAccountsPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_list_Administrators.Initialize();

    CWaitCursor wait;

    //
    // Build the ACL list
    //        
    CError err(BuildAclOblistFromBlob(
        ((CFtpSheet *)GetSheet())->GetInstanceProperties().m_acl,
        m_oblSID
        ));

    err.MessageBoxOnFailure();

    m_list_Administrators.FillAccessListBox(m_oblSID);

    //
    // check if the operators controls are accessible
    //
    m_button_Add.EnableWindow(HasOperatorList() && HasAdminAccess());
    m_list_Administrators.EnableWindow(HasOperatorList() && HasAdminAccess());

    GetDlgItem(IDC_STATIC_OPERATOR_PROMPT1)->EnableWindow(
        HasOperatorList() 
     && HasAdminAccess()
        );

    GetDlgItem(IDC_STATIC_OPERATOR_PROMPT2)->EnableWindow(
        HasOperatorList() 
     && HasAdminAccess()
        );

    SetControlStates(m_fAllowAnonymous);
    SetAdminRemoveState();

    return TRUE;
}



/* virtual */
HRESULT
CFtpAccountsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_strUserName);
        FETCH_INST_DATA_FROM_SHEET(m_strPassword);
        FETCH_INST_DATA_FROM_SHEET(m_fAllowAnonymous);
        FETCH_INST_DATA_FROM_SHEET(m_fOnlyAnonymous);
        FETCH_INST_DATA_FROM_SHEET(m_fPasswordSync);
    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CFtpAccountsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP service page now...");

    //
    // Use m_ notation because the message crackers require it
    //
    CBlob m_acl;
    BOOL fAclDirty = BuildAclBlob(m_oblSID, m_acl);

    CError err;

    BeginWaitCursor();
    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_strUserName)
        STORE_INST_DATA_ON_SHEET(m_fOnlyAnonymous)
        STORE_INST_DATA_ON_SHEET(m_fAllowAnonymous)
        STORE_INST_DATA_ON_SHEET(m_fPasswordSync)
        if (fAclDirty)
        {
            STORE_INST_DATA_ON_SHEET(m_acl)
        }
        if (m_fPasswordSync)
        {
            //
            // Delete password
            //
            // CODEWORK: Shouldn't need to know ID number.
            // Implement m_fDelete flag in CMP template maybe?
            //
            FLAG_INST_DATA_FOR_DELETION(MD_ANONYMOUS_PWD);
        }
        else
        {
            STORE_INST_DATA_ON_SHEET(m_strPassword);
        }
    END_META_INST_WRITE(err)
    EndWaitCursor();

    return err;
}



void
CFtpAccountsPage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);
}



void
CFtpAccountsPage::OnCheckAllowAnonymous()
/*++

Routine Description:

    Respond to 'allow anonymous' checkbox being pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_chk_AllowAnymous.GetCheck() == 0)
    {
        //
        // Show security warning
        //
        CClearTxtDlg dlg;

        if (dlg.DoModal() != IDOK)
        {
            m_chk_AllowAnymous.SetCheck(1);
            return;
        }
    }

    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);
    OnItemChanged();
}



void
CFtpAccountsPage::OnCheckAllowOnlyAnonymous()
/*++

Routine Description:

    Respond to 'allow only anonymous' checkbox being pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_chk_OnlyAnonymous.GetCheck() == 0)
    {
        //
        // Show security warning
        //
        CClearTxtDlg dlg;

        if (dlg.DoModal() != IDOK)
        {
            m_chk_OnlyAnonymous.SetCheck(1);
            return;
        }
    }

    OnItemChanged();
}



void 
CFtpAccountsPage::OnButtonBrowseUser()
/*++

Routine Description:

    User browser button has been pressed.  Browse for IUSR account name

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(str))
    {
        //
        // If the name is non-local (determined by having
        // a slash in the name, password sync is disabled,
        // and a password should be entered.
        //
        m_edit_UserName.SetWindowText(str);

        if (!(m_fPasswordSync = IsLocalAccount(str)))
        {
            m_edit_Password.SetWindowText(_T(""));
            m_edit_Password.SetFocus();
        }

        m_chk_PasswordSync.SetCheck(m_fPasswordSync);
        OnItemChanged();
    }
}



void 
CFtpAccountsPage::OnButtonCheckPassword() 
/*++

Routine Description:

    Check password button has been pressed.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(CComAuthInfo::VerifyUserPassword(m_strUserName, m_strPassword));

    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}



void
CFtpAccountsPage::OnButtonAdd()
/*++

Routine Description:

    'Add' button has been pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_list_Administrators.AddToAccessList(
        this,
        QueryServerName(),
        m_oblSID
        ))
    {
        OnItemChanged();
    }

    SetAdminRemoveState();
}



void
CFtpAccountsPage::OnSelchangeListAdministrators()
/*++

Routine Description:

    Selection Change in admin list box handler

Arguments:

    None.

Return Value:

    None

--*/
{
    SetAdminRemoveState();
}



void 
CFtpAccountsPage::OnButtonDelete()
/*++

Routine Description:

    Delete all selected items in the list box

Arguments:

    None.

Return Value:

    None

--*/
{
    int nSel = 0;
    int cChanges = 0;
    CAccessEntry * pAccess;

    while ((pAccess = m_list_Administrators.GetNextSelectedItem(&nSel)) != NULL)
    {
        //
        // Remove button should be disabled unless all selected
        // items are deletable
        //
        ASSERT(pAccess->IsDeletable());
        if (pAccess->IsDeletable())
        {
            ++cChanges;
            pAccess->FlagForDeletion();
            m_list_Administrators.DeleteString(nSel);

            //
            // Don't advance counter to account for shift
            //
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        OnItemChanged();
    }

    if (!SetAdminRemoveState())
    {
        m_button_Add.SetFocus();
    }
}



void 
CFtpAccountsPage::OnCheckEnablePwSynchronization() 
/*++

Routine Description:

    Handler for 'enable password synchronization' checkbox press

Arguments:

    None

Return Value:

    None

--*/
{
    m_fPasswordSyncChanged = TRUE;
    m_fPasswordSync = !m_fPasswordSync;
    OnItemChanged();
    SetControlStates(m_chk_AllowAnymous.GetCheck() > 0);

    if (!m_fPasswordSync )
    {
        m_edit_Password.SetSel(0,-1);
        m_edit_Password.SetFocus();
    }
}



void 
CFtpAccountsPage::OnChangeEditUsername() 
/*++

Routine description:

    Handler for 'username' edit box change messages

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUserNameChanged = TRUE;
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fltdlg.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        fltdlg.cpp

   Abstract:

        WWW Filters Property Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "w3sht.h"
#include "fltdlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CFilterDlg::CFilterDlg(
    IN OUT CIISFilter & flt,
    IN CIISFilterList * & pFilters,
    IN BOOL fLocal,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Filter properties dialog constructor

Arguments:

    CIISFilter & flt          : Filter being edited
    CFilters * & pFilters     : List of filters that exist
    BOOL fLocal               : TRUE on the local system
    CWnd * pParent OPTIONAL   : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CFilterDlg::IDD, pParent),
      m_fLocal(fLocal),
      m_pFilters(pFilters),
      m_fEditMode(FALSE),
      m_flt(flt)
{
    //{{AFX_DATA_INIT(CFilterDlg)
    m_strExecutable = m_flt.m_strExecutable;
    m_strFilterName = m_flt.m_strName;
    //}}AFX_DATA_INIT

    //
    // Map priority to string ID
    //
    m_strPriority.LoadString(IDS_HIGH + 3 - m_flt.m_nPriority);
}



void 
CFilterDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFilterDlg)
    DDX_Control(pDX, IDC_STATIC_PRIORITY_VALUE, m_static_Priority);
    DDX_Control(pDX, IDC_STATIC_PRIORITY, m_static_PriorityPrompt);
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_FILTERNAME, m_edit_FilterName);
    DDX_Control(pDX, IDC_EDIT_EXECUTABLE, m_edit_Executable);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Text(pDX, IDC_EDIT_FILTERNAME, m_strFilterName);
    DDX_Text(pDX, IDC_STATIC_PRIORITY_VALUE, m_strPriority);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_EXECUTABLE, m_strExecutable);
    DDV_MaxChars(pDX, m_strExecutable, 255);

    if (pDX->m_bSaveAndValidate)
    {
        //
        // Validate executable
        //
        if (PathIsRelative(m_strExecutable))
        {
            ::AfxMessageBox(IDS_ERR_BAD_PATH);
            pDX->Fail();
        }

        if (m_fLocal && 
            (::GetFileAttributes(m_strExecutable) & FILE_ATTRIBUTE_DIRECTORY))
        {
            ::AfxMessageBox(IDS_ERR_FILE_NOT_FOUND);
            pDX->Fail();
        }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFilterDlg, CDialog)
    //{{AFX_MSG_MAP(CFilterDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_EN_CHANGE(IDC_EDIT_EXECUTABLE, OnExecutableChanged)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_FILTERNAME, OnItemChanged)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CFilterDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Available on local connections only
    //
    m_button_Browse.EnableWindow(m_fLocal);

    if ((m_fEditMode = m_edit_FilterName.GetWindowTextLength() > 0))
    {
        m_edit_FilterName.SetReadOnly();
    }

    SetControlStates();
    
    return TRUE;
}



void 
CFilterDlg::OnButtonBrowse() 
/*++

Routine Description:

    Browse button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_fLocal);

    CString strFilterMask((LPCTSTR)IDS_FILTER_MASK);

    //
    // CODEWORK: Derive a class from CFileDialog that allows
    // the setting of the initial path
    //

    //CString strPath;
    //m_edit_Executable.GetWindowText(strPath);
    CFileDialog dlgBrowse(
        TRUE, 
        NULL, 
        NULL, 
        OFN_HIDEREADONLY, 
        strFilterMask, 
        this
        );
    // Disable hook to get Windows 2000 style dialog
	dlgBrowse.m_ofn.Flags &= ~(OFN_ENABLEHOOK);
	dlgBrowse.m_ofn.Flags |= OFN_DONTADDTORECENT|OFN_FILEMUSTEXIST;

	INT_PTR rc = dlgBrowse.DoModal();
    if (rc == IDOK)
    {
        m_edit_Executable.SetWindowText(dlgBrowse.GetPathName());
    }
	else if (rc == IDCANCEL)
	{
		DWORD err = CommDlgExtendedError();
	}

    OnItemChanged();
}



void 
CFilterDlg::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    BOOL fAllowAnonymous : If TRUE, 'allow anonymous' is on.

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(
        m_edit_FilterName.GetWindowTextLength() > 0
     && m_edit_Executable.GetWindowTextLength() > 0);

    ActivateControl(m_static_PriorityPrompt, m_flt.m_nPriority != FLTR_PR_INVALID);
    ActivateControl(m_static_Priority,       m_flt.m_nPriority != FLTR_PR_INVALID);
}



void
CFilterDlg::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFilterDlg::OnExecutableChanged()
/*++

Routine Description:

    Handle change in executable edit box.  Remove priority as this
    is no longer valid

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Priority no longer makes sense.
    // 
    m_flt.m_nPriority = FLTR_PR_INVALID;
    OnItemChanged();
}



BOOL
CFilterDlg::FilterNameExists(
    IN LPCTSTR lpName
    )
/*++

Routine Description:

    Look for a given filter name in the list

Arguments:

    LPCTSTR lpName  : Filter name to look for

Return Value:

    TRUE if the name already existed in the list

--*/
{
    m_pFilters->ResetEnumerator();

    while(m_pFilters->MoreFilters())
    {
        CIISFilter * pFilter = m_pFilters->GetNextFilter();
        ASSERT(pFilter != NULL);

        if (!pFilter->IsFlaggedForDeletion())
        {
            if (!pFilter->m_strName.CompareNoCase(lpName))
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}



void 
CFilterDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Save data

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        if (!PathIsValid(m_strExecutable))
        {
            m_edit_Executable.SetSel(0,-1);
            m_edit_Executable.SetFocus();
            ::AfxMessageBox(IDS_ERR_BAD_PATH);
            return;
        }
        //
        // Make sure the filter name is unique
        //
        if (!m_fEditMode && FilterNameExists(m_strFilterName))
        {
            ::AfxMessageBox(IDS_ERR_DUP_FILTER);
            return;
        }
        m_flt.m_strExecutable = m_strExecutable;
        m_flt.m_strName = m_strFilterName;
        //
        // Anyway to load this from the DLL?
        //
        //m_flt.m_nPriority = FLTR_PR_MEDIUM;
        CDialog::OnOK();
    }

    //
    // Don't dismiss the dialog
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\filters.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        filters.cpp

   Abstract:

        WWW Filters Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
#include "fltdlg.h"
#include "filters.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Column width relative weights
//
#define WT_STATUS             (7)
#define WT_FILTER            (12)
#define WT_PRIORITY           (8)



//
// Bitmap indices
//
enum
{
    BMPID_DISABLED,
    BMPID_LOADED,
    BMPID_UNLOADED,
    BMPID_NOT_COMMITTED,
    /**/
    BMPID_TOTAL
};



//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("Filters");



IMPLEMENT_DYNAMIC(CFiltersListBox, CHeaderListBox);



const int CFiltersListBox::nBitmaps = BMPID_TOTAL;



CFiltersListBox::CFiltersListBox(
    IN UINT nIdLow,
    IN UINT nIdMedium,
    IN UINT nIdHigh,
    IN UINT nIdUnknown
    )
/*++

Routine Description:

    Constructor for filters listbox

Arguments:

    UINT nIdLow     : Resource ID for text string "Low"
    UINT nIdMedium  : Resource ID for text string "Medium"
    UINT nIdHigh    : Resource ID for text string "High"

Return Value:

    N/A

--*/
    : CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
    VERIFY(m_str[FLTR_PR_INVALID].LoadString(nIdUnknown));
    VERIFY(m_str[FLTR_PR_LOW].LoadString(nIdLow));
    VERIFY(m_str[FLTR_PR_MEDIUM].LoadString(nIdMedium));
    VERIFY(m_str[FLTR_PR_HIGH].LoadString(nIdHigh));
}



void
CFiltersListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Draw structure

Return Value:

    None

--*/
{
    CIISFilter * p = (CIISFilter *)ds.m_ItemData;
    ASSERT(p != NULL);

    int n;

    if (p->IsDirty())
    {
        n = BMPID_NOT_COMMITTED;
    }
    else if (!p->IsEnabled())
    {   
        n = BMPID_DISABLED;
    }
    else if (p->m_dwState == MD_FILTER_STATE_LOADED)
    {
        n = BMPID_LOADED;
    }
    else if (p->m_dwState == MD_FILTER_STATE_UNLOADED)
    {
        n = BMPID_UNLOADED;
    }
    else
    {
        n = BMPID_DISABLED;
    }

    DrawBitmap(ds, 0, n);
    ColumnText(ds, 1, FALSE, p->m_strName);

    if (p->IsDirty())
    {
        ColumnText(ds, 2, FALSE, m_str[FLTR_PR_INVALID]);
    }
    else
    {
        ASSERT(p->m_nPriority >= FLTR_PR_INVALID && p->m_nPriority <= FLTR_PR_HIGH);

        if (p->m_nPriority >= FLTR_PR_INVALID && p->m_nPriority <= FLTR_PR_HIGH)
        {
            ColumnText(ds, 2, FALSE, m_str[p->m_nPriority]);
        }
        else
        {
            //
            // Just in case
            //
            ColumnText(ds, 2, FALSE, m_str[FLTR_PR_INVALID]);
        }
    }
}



/* virtual */
BOOL 
CFiltersListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns
    as requested, and lay them out appropriately

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    HINSTANCE hInst = AfxGetResourceHandle();
    InsertColumn(0, WT_STATUS, IDS_STATUS, hInst);
    InsertColumn(1, WT_FILTER, IDS_FILTER_NAME, hInst);
    InsertColumn(2, WT_PRIORITY, IDS_PRIORITY, hInst);

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}



IMPLEMENT_DYNCREATE(CW3FiltersPage, CInetPropertyPage)



CW3FiltersPage::CW3FiltersPage(
    IN CInetPropertySheet * pSheet
    ) 
/*++

Routine Description:

    Filters/application property page constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet pointer

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3FiltersPage::IDD, pSheet),
      m_list_Filters(IDS_LOW, IDS_MEDIUM, IDS_HIGH, IDS_UNKNOWN_PRIORITY),
      m_ListBoxResFilters(IDB_FILTERS, m_list_Filters.nBitmaps),
      m_pfltrs(NULL)
{

#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

    m_list_Filters.AttachResources(&m_ListBoxResFilters);

    VERIFY(m_strYes.LoadString(IDS_YES));
    VERIFY(m_strNo.LoadString(IDS_NO));
    VERIFY(m_strStatus[FLTR_DISABLED].LoadString(IDS_DISABLED));
    VERIFY(m_strStatus[FLTR_LOADED].LoadString(IDS_LOADED));
    VERIFY(m_strStatus[FLTR_UNLOADED].LoadString(IDS_UNLOADED));
    VERIFY(m_strStatus[FLTR_UNKNOWN].LoadString(IDS_UNKNOWN));
    VERIFY(m_strStatus[FLTR_DIRTY].LoadString(IDS_NOT_COMMITTED));
    VERIFY(m_strPriority[FLTR_PR_INVALID].LoadString(IDS_UNKNOWN_PRIORITY));
    VERIFY(m_strPriority[FLTR_PR_LOW].LoadString(IDS_LOW));
    VERIFY(m_strPriority[FLTR_PR_MEDIUM].LoadString(IDS_MEDIUM));
    VERIFY(m_strPriority[FLTR_PR_HIGH].LoadString(IDS_HIGH));
    VERIFY(m_strEnable.LoadString(IDS_ENABLE));
    VERIFY(m_strDisable.LoadString(IDS_DISABLED));

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CW3FiltersPage)
    m_strFiltersPrompt = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    //
    // Change filters prompt on the master
    //
    VERIFY(m_strFiltersPrompt.LoadString(IsMasterInstance()
        ? IDS_MASTER_FILTERS : IDS_INSTANCE_FILTERS));
}



CW3FiltersPage::~CW3FiltersPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CW3FiltersPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX     : Pointer to data exchange object

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3FiltersPage)
    DDX_Control(pDX,  IDC_STATIC_FILTER_NAME_PROMPT, m_static_NamePrompt);
    DDX_Control(pDX,  IDC_STATIC_FILTER_NAME, m_static_Name);
    DDX_Control(pDX, IDC_STATIC_STATUS_PROMPT, m_static_StatusPrompt);
    DDX_Control(pDX, IDC_STATIC_STATUS, m_static_Status);
    DDX_Control(pDX, IDC_STATIC_EXECUTABLE_PROMPT, m_static_ExecutablePrompt);
    DDX_Control(pDX, IDC_STATIC_EXECUTABLE, m_static_Executable);
    DDX_Control(pDX, IDC_STATIC_PRIORITY, m_static_Priority);
    DDX_Control(pDX, IDC_STATIC_PRIORITY_PROMPT, m_static_PriorityPrompt);
    DDX_Control(pDX, IDC_STATIC_DETAILS, m_static_Details);
    DDX_Control(pDX, IDC_BUTTON_DISABLE, m_button_Disable);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Text(pDX, IDC_STATIC_FILTERS, m_strFiltersPrompt);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_LIST_FILTERS, m_list_Filters);
    DDX_Control(pDX, IDC_BUTTON_UP, m_button_Up);
    DDX_Control(pDX, IDC_BUTTON_DOWN, m_button_Down);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3FiltersPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3FiltersPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_DISABLE, OnButtonDisable)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_LBN_DBLCLK(IDC_LIST_FILTERS, OnDblclkListFilters)
    ON_LBN_SELCHANGE(IDC_LIST_FILTERS, OnSelchangeListFilters)
    ON_BN_CLICKED(IDC_BUTTON_DOWN, OnButtonDown)
    ON_BN_CLICKED(IDC_BUTTON_UP, OnButtonUp)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

END_MESSAGE_MAP()



void
CW3FiltersPage::FillFiltersListBox(
    IN CIISFilter * pSelection OPTIONAL
    )
/*++

Routine Description:

    Populate the listbox with the filter entries.

Arguments:

    CIISFilter * pSelection : Item to be selected

Return Value:

    None.

--*/
{
    ASSERT(m_pfltrs != NULL);

    m_pfltrs->ResetEnumerator();

    m_list_Filters.SetRedraw(FALSE);
    m_list_Filters.ResetContent();
    int cItems = 0;

    while(m_pfltrs->MoreFilters())
    {
        CIISFilter * pFilter = m_pfltrs->GetNextFilter();

        if (!pFilter->IsFlaggedForDeletion())
        {
            m_list_Filters.AddItem(pFilter);
            ++cItems;
        }
    }

    m_list_Filters.SetRedraw(TRUE);

    if (pSelection)
    {
        //
        // Select the desired entry
        //
        m_list_Filters.SelectItem(pSelection);
    }
}



void
CW3FiltersPage::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    None

Return Value:

    None

--*/
{
    SetDetailsText();

    CIISFilter * pFilter = NULL;

    BOOL fCanGoUp = FALSE;
    BOOL fCanGoDown = FALSE;
    int nCurSel = m_list_Filters.GetCurSel();

    if (nCurSel != LB_ERR && m_list_Filters.GetCount() > 0)
    {
        //
        // Can only sort within the same priority
        //
        pFilter = m_list_Filters.GetItem(nCurSel);

        m_button_Disable.SetWindowText(pFilter->m_fEnabled
            ? m_strEnable 
            : m_strDisable
            );

        if (nCurSel > 0)
        {
            CIISFilter * pPrev = m_list_Filters.GetItem(nCurSel - 1);

            if (pFilter->m_nPriority == pPrev->m_nPriority)
            {
                fCanGoUp = TRUE;
            }
        }

        if (nCurSel < m_list_Filters.GetCount() - 1)
        {
            CIISFilter * pNext = m_list_Filters.GetItem(nCurSel + 1);

            if (pFilter->m_nPriority == pNext->m_nPriority)
            {
                fCanGoDown = TRUE;
            }
        }
    }

    m_button_Disable.EnableWindow(FALSE);
    m_button_Edit.EnableWindow(pFilter != NULL);
    m_button_Remove.EnableWindow(
       m_list_Filters.GetCount() > 0 && m_list_Filters.GetSelCount() > 0);
	if (!fCanGoUp && ::GetFocus() == m_button_Up.m_hWnd)
	{
		::SetFocus(GetDlgItem(IDC_BUTTON_ADD)->m_hWnd);
	}
    m_button_Up.EnableWindow(fCanGoUp);
	if (!fCanGoDown && ::GetFocus() == m_button_Down.m_hWnd)
	{
		::SetFocus(GetDlgItem(IDC_BUTTON_ADD)->m_hWnd);
	}
    m_button_Down.EnableWindow(fCanGoDown);
}



/* virtual */
HRESULT
CW3FiltersPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    CString path = QueryMetaPath();
	if (!IsMasterInstance())
	{
		CMetabasePath::GetInstancePath(QueryMetaPath(), path);
	}
    m_pfltrs = new CIISFilterList(QueryAuthInfo(), path);
    err = m_pfltrs ? m_pfltrs->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

    return err;
}




/* virtual */
HRESULT
CW3FiltersPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 filters page now...");

    if (m_pfltrs)
    {
        BeginWaitCursor();
        CError err(m_pfltrs->WriteIfDirty());
        EndWaitCursor();

        if (err.Failed())
        {
            return err;
        }    
    }
    
    SetModified(FALSE);                                             

    return S_OK;
}



INT_PTR
CW3FiltersPage::ShowFiltersPropertyDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:
    
    Display the add/edit dialog.  The return
    value is the value returned by the dialog

Arguments:

    BOOL fAdd       : TRUE if we're adding a new filter

Return Value:

    Dialog return value; ID_OK or ID_CANCEL

--*/
{
    CIISFilter flt;
    CIISFilter * pFlt = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        nCurSel = m_list_Filters.GetCurSel();
        ASSERT(nCurSel >= 0);

        if (nCurSel != LB_ERR)
        {
            //
            // Get filter properties
            //
            pFlt = m_list_Filters.GetItem(nCurSel);
        }
    }
    else
    {
        //
        // Point to the empty filter
        //
        pFlt = &flt;
    }

    ASSERT(pFlt != NULL);
    CFilterDlg dlgFilter(*pFlt, m_pfltrs, IsLocal(), this);
    INT_PTR nReturn = dlgFilter.DoModal();

    if (nReturn == IDOK)
    {
        try
        {
            //
            // When editing, delete and re-add (to make sure the
            // list is properly sorted)
            //
            pFlt = new CIISFilter(dlgFilter.GetFilter());

            if (!fAdd)
            {
                ASSERT(m_pfltrs);
                m_pfltrs->RemoveFilter(nCurSel);
                m_list_Filters.DeleteString(nCurSel);
            }

            ASSERT(pFlt->IsInitialized());

            //
            // Add to list and listbox
            //
            m_pfltrs->AddFilter(pFlt);
            m_list_Filters.SetCurSel(m_list_Filters.AddItem(pFlt));

            //
            // Remember to store this one later
            //
            pFlt->Dirty();
            OnItemChanged();
        }
        catch(CMemoryException * e)
        {
            e->Delete();
        }
    }

    return nReturn;
}



void 
CW3FiltersPage::ShowProperties(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Edit/add filter
    
Arguments:

    BOOL fAdd    : TRUE if we're adding a filter

Return Value:

    None

--*/
{
    INT_PTR nResult = ShowFiltersPropertyDialog(fAdd);

    if (nResult == IDOK)
    {
        SetControlStates();
        SetModified(TRUE);
    }
}



void 
CW3FiltersPage::SetDetailsText()
/*++

Routine Description:

    Set the details text based on the currently selected filter

Arguments:

    None

Return Value:

    None

--*/
{
    int  nSel = m_list_Filters.GetCurSel();
    BOOL fShow = (nSel != LB_ERR && m_list_Filters.GetCount() > 0);

    ActivateControl(m_static_NamePrompt,        fShow);
    ActivateControl(m_static_Name,              fShow);
    ActivateControl(m_static_Priority,          fShow);
    ActivateControl(m_static_PriorityPrompt,    fShow);
    ActivateControl(m_static_Executable,        fShow);
    ActivateControl(m_static_ExecutablePrompt,  fShow);
    ActivateControl(m_static_Status,            fShow);
    ActivateControl(m_static_StatusPrompt,      fShow);
    ActivateControl(m_static_Details,           fShow);

    if (fShow)
    {
        CIISFilter * pFilter = m_list_Filters.GetItem(nSel);
        ASSERT(pFilter != NULL);

        //
        // Display path in truncated form
        //    
        FitPathToControl(m_static_Executable, pFilter->m_strExecutable);

        int i;

        if (pFilter->IsDirty())
        {
            i = FLTR_DIRTY;
        }
        else if (!pFilter->IsEnabled())
        {
            i = FLTR_DISABLED;
        }
        else if (pFilter->IsLoaded())
        {
            i = FLTR_LOADED;
        }
        else if (pFilter->IsUnloaded())
        {
            i = FLTR_UNLOADED;
        }
        else
        {
            i = FLTR_UNKNOWN;
        }

        m_static_Name.SetWindowText(pFilter->QueryName());
        m_static_Status.SetWindowText(m_strStatus[i]);

        if (pFilter->IsDirty())
        {
            m_static_Priority.SetWindowText(m_strPriority[FLTR_PR_INVALID]);
        }
        else
        {
            m_static_Priority.SetWindowText(m_strPriority[pFilter->m_nPriority]);
        }
    }
}



void
CW3FiltersPage::ExchangeFilterPositions(
    IN int nSel1,
    IN int nSel2
    )
/*++

Routine Description:

    Exchange 2 filter objects, as indicated by their
    indices.  Selection will take place both in the
    listbox and in the oblist.

Arguments:

    int nSel1           : Index of item 1
    int nSel2           : Index of item 2

Return Value:

    None

--*/
{
    CIISFilter * p1, * p2;

    if (!m_pfltrs->ExchangePositions(nSel1, nSel2, p1, p2))
    {
        ASSERT(FALSE);

        return;
    }
    
    m_list_Filters.SetItemDataPtr(nSel1, p1);
    m_list_Filters.SetItemDataPtr(nSel2, p2); 

    CRect rc1, rc2;
    m_list_Filters.GetItemRect(nSel1, &rc1);
    m_list_Filters.GetItemRect(nSel2, &rc2); 
    m_list_Filters.InvalidateRect(&rc1, TRUE);
    m_list_Filters.InvalidateRect(&rc2, TRUE);

    SetModified(TRUE);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3FiltersPage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}




void 
CW3FiltersPage::OnButtonAdd()
/*++

Routine Description:

    'Add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ShowProperties(TRUE);
}



void 
CW3FiltersPage::OnButtonEdit()
/*++

Routine Description:

    'Edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ShowProperties(FALSE);
}



void 
CW3FiltersPage::OnButtonDisable()
/*++

Routine Description:

    'Disable' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_Filters.GetCurSel();
    CIISFilter * pFilter = m_list_Filters.GetItem(nCurSel);
    ASSERT(pFilter);

/*
    pFilter->m_fEnabled = !pFilter->m_fEnabled;
    m_list_Filters.InvalidateSelection(nCurSel);
    SetControlStates();
*/
}



void 
CW3FiltersPage::OnButtonRemove()
/*++

Routine Description:

    'Remove' button handler

Arguments:

    None

Return Value:

    None

--*/

{
    int nSel = 0;
    int cChanges = 0;
    int nCurSel = m_list_Filters.GetCurSel();

    CIISFilter * pFilter = NULL;

    while ((pFilter = m_list_Filters.GetNextSelectedItem(&nSel)) != NULL)
    {
        pFilter->FlagForDeletion();
        m_list_Filters.DeleteString(nSel);
        ++cChanges;
    }

    if (cChanges)
    {
        m_list_Filters.SetCurSel(nCurSel);

        SetControlStates();
        OnItemChanged();
    }
}



void 
CW3FiltersPage::OnDblclkListFilters()
/*++

Routine Description:

    Filter listbox double click handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void 
CW3FiltersPage::OnSelchangeListFilters()
/*++

Routine Description:

    'Selection Change' handler in the filters listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



BOOL 
CW3FiltersPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CError err;

    CInetPropertyPage::OnInitDialog();

    m_list_Filters.Initialize();

    //
    // Add filters to the listbox
    //
    if (err.Succeeded())
    {
        err = m_pfltrs->LoadAllFilters();
    }

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // Filters path not yet created, this is ok 
        //
        ASSERT(m_pfltrs && m_pfltrs->GetCount() == 0);
        err.Reset();
    }

    //
    // Make sure the up/down buttons show up correctly
    //
    //
    // Make sure the up/down buttons show up correctly
    //
    CRect rc;
    GetDlgItem(IDC_BUTTONUP)->GetWindowRect(&rc);
    GetDlgItem(IDC_BUTTONUP)->DestroyWindow();
    ScreenToClient(&rc);
    m_button_Up.Create(NULL, 
       WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_OWNERDRAW, rc, this, IDC_BUTTON_UP);
    m_button_Up.LoadBitmaps(IDB_BUTTONUPU, IDB_BUTTONUPD, IDB_BUTTONUPF, IDB_BUTTONUPX);
    m_button_Up.SizeToContent();

    GetDlgItem(IDC_BUTTONDN)->GetWindowRect(&rc);
    GetDlgItem(IDC_BUTTONDN)->DestroyWindow();
    ScreenToClient(&rc);
    m_button_Down.Create(NULL, 
       WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_OWNERDRAW, rc, this, IDC_BUTTON_DOWN);
    m_button_Down.LoadBitmaps(IDB_BUTTONDNU, IDB_BUTTONDND, IDB_BUTTONDNF, IDB_BUTTONDNX);
    m_button_Down.SizeToContent();

    if (!err.MessageBoxOnFailure())
    {
        FillFiltersListBox();    
    }

    SetControlStates();
    
    return TRUE; 
}



void 
CW3FiltersPage::OnButtonDown() 
/*++

Routine Description:

    Down button handler.  Exchange positions of the current item
    with the next lower item

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // First get current selection 
    //
    int nCurSel = m_list_Filters.GetCurSel();

    ExchangeFilterPositions(nCurSel, nCurSel + 1);
    m_list_Filters.SetCurSel(nCurSel + 1);
    SetControlStates();
}



void 
CW3FiltersPage::OnButtonUp() 
/*++

Routine Description:

    Up button handler.  Exchange positions of the current item
    with the next higher item

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_Filters.GetCurSel();

    ExchangeFilterPositions(nCurSel - 1, nCurSel);
    m_list_Filters.SetCurSel(nCurSel - 1);
    SetControlStates();
}



void 
CW3FiltersPage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();
    
    //
    // Filters and extensions lists will clean themself up
    //
    SAFE_DELETE(m_pfltrs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\filters.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        filters.h

   Abstract:

        WWW Filters Property Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Forward Definitions
//
class CIISFilter;



class CFiltersListBox : public CHeaderListBox
/*++

Class Description:

    A listbox of filter items

Public Interface:

    CFiltersListBox     : Constructor

    GetItem             : Get filter at specified location
    GetNextSelectedItem : Get next selected filter item
    AddItem             : Add filter to listbox
    InsertItem          : Insert filter into the listbox
    Initialize          : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CFiltersListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;  

public:
    //
    // Constructor
    //
    CFiltersListBox(
        IN UINT nIdLow,
        IN UINT nIdMedium,
        IN UINT nIdHigh,
        IN UINT nIdUnknown
        );

public:
    //
    // Initialize the listbox control
    //
    virtual BOOL Initialize();

    CIISFilter * GetItem(UINT nIndex);
    int AddItem(CIISFilter * pItem);

    int InsertItem(
        IN int nPos,
        IN CIISFilter * pItem
        );

    CIISFilter * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);

private:
    CString m_str[FLT_PR_NUM]; 
};




class CW3FiltersPage : public CInetPropertyPage
/*++

Class Description:

    Filter page

Public Interface:

    CW3FiltersPage      : Constructor

--*/
{
    DECLARE_DYNCREATE(CW3FiltersPage)

//
// Construction
//
public:
    CW3FiltersPage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CW3FiltersPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3FiltersPage)
    enum { IDD = IDD_FILTERS };
    CString m_strFiltersPrompt;
    CStatic m_static_NamePrompt;
    CStatic m_static_Name;
    CStatic m_static_StatusPrompt;
    CStatic m_static_Status;
    CStatic m_static_ExecutablePrompt;
    CStatic m_static_Executable;
    CStatic m_static_Priority;
    CStatic m_static_PriorityPrompt;
    CButton m_static_Details;
    CButton m_button_Disable;
    CButton m_button_Edit;
    CButton m_button_Add;
    CButton m_button_Remove;
    //}}AFX_DATA

    CUpButton   m_button_Up;
    CDownButton m_button_Down;
    CFiltersListBox m_list_Filters;
    CStringList m_strlScriptMaps;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CW3FiltersPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3FiltersPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonDisable();
    afx_msg void OnButtonEdit();
    afx_msg void OnDblclkListFilters();
    afx_msg void OnSelchangeListFilters();
    afx_msg void OnButtonDown();
    afx_msg void OnButtonUp();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void    ExchangeFilterPositions(int nSel1, int nSel2);
    void    SetControlStates();
    void    FillFiltersListBox(CIISFilter * pSelection = NULL);
    void    SetDetailsText();
    void    ShowProperties(BOOL fAdd = FALSE);
    INT_PTR ShowFiltersPropertyDialog(BOOL fAdd = FALSE);
    LPCTSTR BuildFilterOrderString(CString & strFilterOrder);

private:
    CString m_strYes;
    CString m_strNo;
    CString m_strStatus[5];
    CString m_strPriority[FLT_PR_NUM];
    CString m_strEnable;
    CString m_strDisable;
    CIISFilterList * m_pfltrs;
    CRMCListBoxResources m_ListBoxResFilters;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CIISFilter * CFiltersListBox::GetItem(UINT nIndex)
{
    return (CIISFilter *)GetItemDataPtr(nIndex);
}

inline CIISFilter * CFiltersListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CIISFilter *)CRMCListBox::GetNextSelectedItem(pnStartingIndex);
}

inline int CFiltersListBox::AddItem(CIISFilter * pItem)
{
    return AddString ((LPCTSTR)pItem);
}

inline int CFiltersListBox::InsertItem(
    IN int nPos,
    IN CIISFilter * pItem
    )
{
    return InsertString(nPos, (LPCTSTR)pItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fmessage.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fmessage.cpp

   Abstract:
        FTP Messages property page

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "ftpsht.h"
#include "fmessage.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



IMPLEMENT_DYNCREATE(CFtpMessagePage, CInetPropertyPage)

CFtpMessagePage::CFtpMessagePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for FTP message property page

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CFtpMessagePage::IDD, pSheet)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CFtpMessagePage)
    m_strExitMessage = _T("");
    m_strMaxConMsg = _T("");
    m_strWelcome = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    m_hInstRichEdit = LoadLibrary(_T("RichEd20.dll"));
}



CFtpMessagePage::~CFtpMessagePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
   if (m_hInstRichEdit != NULL)
      FreeLibrary(m_hInstRichEdit);
}



void
CFtpMessagePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpMessagePage)
    DDX_Control(pDX, IDC_EDIT_EXIT, m_edit_Exit);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxCon);
    DDX_Text(pDX, IDC_EDIT_EXIT, m_strExitMessage);
    DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_strMaxConMsg);
    DDX_Text(pDX, IDC_EDIT_WELCOME, m_strWelcome);
    DDX_Text(pDX, IDC_EDIT_BANNER, m_strBanner);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpMessagePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpMessagePage)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_EXIT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_WELCOME, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_BANNER, OnItemChanged)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
CFtpMessagePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    CHARFORMAT cf;
    ZeroMemory(&cf, sizeof(cf));
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_FACE;
    cf.bPitchAndFamily = FIXED_PITCH | FF_DONTCARE;
    lstrcpyn((LPTSTR)cf.szFaceName, _T("Courier"), LF_FACESIZE);

    SendDlgItemMessage(IDC_EDIT_WELCOME, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    SendDlgItemMessage(IDC_EDIT_BANNER, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);

    DWORD event = (DWORD)SendDlgItemMessage(IDC_EDIT_WELCOME, EM_GETEVENTMASK, 0, 0);
    event |= ENM_CHANGE;
    SendDlgItemMessage(IDC_EDIT_WELCOME, EM_SETEVENTMASK, 0, (LPARAM)event);

    event = (DWORD)SendDlgItemMessage(IDC_EDIT_BANNER, EM_GETEVENTMASK, 0, 0);
    event |= ENM_CHANGE;
    SendDlgItemMessage(IDC_EDIT_BANNER, EM_SETEVENTMASK, 0, (LPARAM)event);

    return TRUE;
}



/* virtual */
HRESULT
CFtpMessagePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CFtpSheet)

        //
        // Use m_ notation because the message cracker functions require it.
        //
        CStringListEx m_strlWelcome, m_strlBanner;
        FETCH_INST_DATA_FROM_SHEET(m_strExitMessage);
        FETCH_INST_DATA_FROM_SHEET(m_strMaxConMsg);
        FETCH_INST_DATA_FROM_SHEET(m_strlWelcome);
        FETCH_INST_DATA_FROM_SHEET(m_strlBanner);

        //
        // Incoming strings contain '\r' at the end of each string.
        // Append a '\n' for internal consumption
        //
        ConvertStringListToSepLine(m_strlWelcome, m_strWelcome, _T("\n"));
        ConvertStringListToSepLine(m_strlBanner, m_strBanner, _T("\n"));

    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CFtpMessagePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP message page now...");

    CError err;

    BeginWaitCursor();

    //
    // Use m_ notation because the message cracker macros require
    // it.
    //
    CStringListEx m_strlWelcome, m_strlBanner;
    ConvertSepLineToStringList(m_strWelcome, m_strlWelcome, _T("\n"));
    ConvertSepLineToStringList(m_strBanner, m_strlBanner, _T("\n"));

    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_strExitMessage)
        STORE_INST_DATA_ON_SHEET(m_strMaxConMsg)
        STORE_INST_DATA_ON_SHEET(m_strlWelcome)
        STORE_INST_DATA_ON_SHEET(m_strlBanner)
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}



void
CFtpMessagePage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
    CString result;
    GetProperty(0x0, VT_BSTR, (void*)&result);
    return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
    SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
    CY result;
    GetProperty(0x2, VT_CY, (void*)&result);
    return result;
}

void COleFont::SetSize(const CY& propVal)
{
    SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
    BOOL result;
    GetProperty(0x3, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetBold(BOOL propVal)
{
    SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
    BOOL result;
    GetProperty(0x4, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetItalic(BOOL propVal)
{
    SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
    BOOL result;
    GetProperty(0x5, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
    SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
    BOOL result;
    GetProperty(0x6, VT_BOOL, (void*)&result);
    return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
    SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
    short result;
    GetProperty(0x7, VT_I2, (void*)&result);
    return result;
}

void COleFont::SetWeight(short propVal)
{
    SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
    short result;
    GetProperty(0x8, VT_I2, (void*)&result);
    return result;
}

void COleFont::SetCharset(short propVal)
{
    SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fltdlg.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        fltdlg.h

   Abstract:

        WWW Filters Property Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FLTDLG_H__
#define __FLTDLG_H__



enum
{
    FLTR_DISABLED,
    FLTR_LOADED,
    FLTR_UNLOADED,
    FLTR_DIRTY,
    /**/
    FLTR_UNKNOWN
};

enum
{
    FLTR_PR_INVALID,
    FLTR_PR_LOW,
    FLTR_PR_MEDIUM,
    FLTR_PR_HIGH,
};



//
// Num priority levels
//
#define FLT_PR_NUM  (FLTR_PR_HIGH + 1)


//
// CFilterDlg dialog
//
class CFilterDlg : public CDialog
/*++

Class Description:

    Filter property dialog

Public Interface:

    CFilterDlg    : Constructor
    GetFilter     : Get the filter object being edited

--*/
{
//
// Construction
//
public:
    CFilterDlg(
        IN CIISFilter &flt,
        IN CIISFilterList *& pFilters,
        IN BOOL fLocal,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFilterDlg)
    enum { IDD = IDD_FILTER };
    CString m_strExecutable;
    CString m_strFilterName;
    CString m_strPriority;
    CEdit   m_edit_FilterName;
    CEdit   m_edit_Executable;
    CStatic m_static_Priority;
    CStatic m_static_PriorityPrompt;
    CButton m_button_Browse;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFilterDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Access
//
public:
    CIISFilter & GetFilter() { return m_flt; }

//
// Implementation
//
protected:
    //{{AFX_MSG(CFilterDlg)
    afx_msg void OnButtonBrowse();
    afx_msg void OnExecutableChanged();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    BOOL FilterNameExists(LPCTSTR lpName);

private:
    BOOL m_fLocal;
    BOOL m_fEditMode;
    CIISFilter m_flt;
    CIISFilterList *& m_pFilters;
};

#endif // __FLTDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\font.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
    COleFont() {}       // Calls COleDispatchDriver default constructor
    COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    CString GetName();
    void SetName(LPCTSTR);
    CY GetSize();
    void SetSize(const CY&);
    BOOL GetBold();
    void SetBold(BOOL);
    BOOL GetItalic();
    void SetItalic(BOOL);
    BOOL GetUnderline();
    void SetUnderline(BOOL);
    BOOL GetStrikethrough();
    void SetStrikethrough(BOOL);
    short GetWeight();
    void SetWeight(short);
    short GetCharset();
    void SetCharset(short);

// Operations
public:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fsecure.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        security.h

   Abstract:

        FTP Security Property Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __FSECURITY_H__
#define __FSECURITY_H__



class CFtpSecurityPage : public CInetPropertyPage
/*++

Class Description:

    FTP Security property page

Public Interface:

    CFtpSecurityPage     : Constructor
    ~CFtpSecurityPage    : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpSecurityPage)

//
// Construction
//
public:
    CFtpSecurityPage(CInetPropertySheet * pSheet = NULL);
    ~CFtpSecurityPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpSecurityPage)
    enum { IDD = IDD_FTP_DIRECTORY_SECURITY };
    int     m_nGrantedDenied;
    CStatic m_icon_Granted;
    CStatic m_icon_Denied;
    CButton m_radio_Granted;
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    //}}AFX_DATA

    CIPAccessDescriptorListBox m_list_IpAddresses;
    CButton m_radio_Denied;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpSecurityPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpSecurityPage)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListIpAddresses();
    afx_msg void OnErrspaceListIpAddresses();
    afx_msg void OnRadioGranted();
    afx_msg void OnRadioDenied();
    afx_msg void OnSelchangeListIpAddresses();
    afx_msg int  OnVKeyToItem(UINT nKey, CListBox * pListBox, UINT nIndex);
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    void    FillListBox(CIPAccessDescriptor * pSelection = NULL);
    BOOL    SetControlStates();
    DWORD   SortAccessList();

private:
    BOOL m_fDefaultGranted;
    BOOL m_fOldDefaultGranted;
    BOOL m_fIpDirty;
    CObListPlus m_oblAccessList;
    CRMCListBoxResources m_ListBoxRes;
};


#endif //__SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fmessage.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fmessage.h

   Abstract:
        FTP Message property page

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/


class CFtpMessagePage : public CInetPropertyPage
/*++

Class Description:

    FTP Messages property page

Public Interface:

    CFtpMessagePage  : Constructor
    ~CFtpMessagePage : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpMessagePage)

//
// Construction
//
public:
    CFtpMessagePage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpMessagePage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpMessagePage)
    enum { IDD = IDD_FTP_MESSAGES };
    CString m_strExitMessage;
    CString m_strMaxConMsg;
    CString m_strWelcome;
	CString m_strBanner;
    CEdit   m_edit_Exit;
    CEdit   m_edit_MaxCon;
    //}}AFX_DATA

    HMODULE m_hInstRichEdit;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpMessagePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpMessagePage)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fsecure.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        security.cpp

   Abstract:

        FTP Security Property Page 

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "ftpsht.h"
#include "fvdir.h"
#include "fsecure.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Needed for granted/denied icons
//
//#include "..\comprop\resource.h"



IMPLEMENT_DYNCREATE(CFtpSecurityPage, CInetPropertyPage)



CFtpSecurityPage::CFtpSecurityPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet object

Return Value:

    N/A

--*/
    : CInetPropertyPage(
        CFtpSecurityPage::IDD, 
        pSheet, 
        USE_DEFAULT_CAPTION, 
        TRUE                    // Enable enhanced fonts
        ),
      m_ListBoxRes(
        IDB_ACCESS,
        m_list_IpAddresses.nBitmaps
        ),
      m_oblAccessList(),
      m_list_IpAddresses(TRUE),
      m_fIpDirty(FALSE),
      m_fOldDefaultGranted(TRUE),
      m_fDefaultGranted(TRUE)   // By default, we grant access
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CFtpSecurityPage)
    m_nGrantedDenied = 0;
    //}}AFX_DATA_INIT

#endif // 0

    m_list_IpAddresses.AttachResources(&m_ListBoxRes);
}



CFtpSecurityPage::~CFtpSecurityPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // The access list will clean itself up
    //
}



void
CFtpSecurityPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpSecurityPage)
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_ICON_GRANTED, m_icon_Granted);
    DDX_Control(pDX, IDC_ICON_DENIED, m_icon_Denied);
    DDX_Control(pDX, IDC_RADIO_GRANTED, m_radio_Granted);
    DDX_Radio(pDX, IDC_RADIO_GRANTED, m_nGrantedDenied);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_RADIO_DENIED, m_radio_Denied);
    DDX_Control(pDX, IDC_LIST_IP_ADDRESSES, m_list_IpAddresses);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpSecurityPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpSecurityPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_RADIO_GRANTED, OnRadioGranted)
    ON_BN_CLICKED(IDC_RADIO_DENIED, OnRadioDenied)
    ON_LBN_DBLCLK(IDC_LIST_IP_ADDRESSES, OnDblclkListIpAddresses)
    ON_LBN_ERRSPACE(IDC_LIST_IP_ADDRESSES, OnErrspaceListIpAddresses)
    ON_LBN_SELCHANGE(IDC_LIST_IP_ADDRESSES, OnSelchangeListIpAddresses)
    ON_WM_VKEYTOITEM()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



/* virtual */
HRESULT
CFtpSecurityPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    m_nGrantedDenied = 0;

    //
    // Build the IPL list
    //
    CError err(BuildIplOblistFromBlob(
        ((CFtpSheet *)GetSheet())->GetDirectoryProperties().m_ipl,
        m_oblAccessList,
        m_fDefaultGranted
        ));

    err.MessageBoxOnFailure();
    m_nGrantedDenied = m_fDefaultGranted ? DEFAULT_GRANTED : DEFAULT_DENIED;
    m_fOldDefaultGranted = m_fDefaultGranted;

    return S_OK;
}



/* virtual */
HRESULT
CFtpSecurityPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP security page now...");
    
    BOOL fIplDirty = m_fIpDirty || (m_fOldDefaultGranted != m_fDefaultGranted);

    //
    // Use m_ notation because the message crackers require it.
    //
    CBlob m_ipl;

    if (fIplDirty)
    {
        BuildIplBlob(m_oblAccessList, m_fDefaultGranted, m_ipl);
    }

    CError err;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CFtpSheet)
        if (fIplDirty)
        {
            STORE_DIR_DATA_ON_SHEET(m_ipl);
        }
    END_META_DIR_WRITE(err)

    EndWaitCursor();

    if (err.Succeeded())
    {
        m_fIpDirty = FALSE;
        m_fOldDefaultGranted = m_fDefaultGranted;
    }

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CFtpSecurityPage::OnButtonAdd() 
/*++

Routine Description:

    'Add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        SetControlStates();
        m_fIpDirty = TRUE;
        OnItemChanged();
    }
}



void
CFtpSecurityPage::OnButtonEdit() 
/*++

Routine Description:

    'Edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        SetControlStates();
        m_fIpDirty = TRUE;
        OnItemChanged();
    }
}



void
CFtpSecurityPage::OnButtonRemove() 
/*++

Routine Description:

    'Remove' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = 0;
    int nCurSel = m_list_IpAddresses.GetCurSel();

    while (m_list_IpAddresses.GetNextSelectedItem(&nSel))
    {
        m_oblAccessList.RemoveIndex(nSel);
        m_list_IpAddresses.DeleteString(nSel);
    }

    m_fIpDirty = TRUE;
    OnItemChanged();

    if (nCurSel > 0)
    {
        --nCurSel;
    }

    m_list_IpAddresses.SetCurSel(nCurSel);

    if (!SetControlStates())
    {
        m_button_Add.SetFocus();
    }
}



BOOL
CFtpSecurityPage::SetControlStates()
/*++

Routine Description:
    
    Set the enabled status of the controls depending on the current
    state of the dialog

Arguments:

    None

Return Value:

    TRUE if at least one item is currently selected in the listbox

--*/
{
    BOOL fSomeSelection = m_list_IpAddresses.GetSelCount() > 0;

    m_button_Edit.EnableWindow(m_list_IpAddresses.GetSelCount() == 1);
    m_button_Remove.EnableWindow(m_list_IpAddresses.GetSelCount() > 0);

    return fSomeSelection;
}



void
CFtpSecurityPage::FillListBox(
    IN CIPAccessDescriptor * pSelection OPTIONAL
    )
/*++

Routine Description:

    Populate the listbox with the access list
    entries

Arguments:

    CIPAccessDescriptor * pSelection : Item to be selected or NULL.

Return Value:

    None

--*/
{
    CObListIter obli(m_oblAccessList);
    const CIPAccessDescriptor * pAccess;

    m_list_IpAddresses.SetRedraw(FALSE);
    m_list_IpAddresses.ResetContent();

    int cItems = 0 ;
    int nSel = LB_ERR, nItem;

    for ( /**/ ; pAccess = (CIPAccessDescriptor *)obli.Next(); ++cItems)
    {
        //
        // We only list those not adhering to the default
        //
        if (pAccess->HasAccess() != m_fDefaultGranted)
        {
            nItem = m_list_IpAddresses.AddItem(pAccess);

            if (pAccess == pSelection)
            {
                //
                // Found item to be selected
                //
                nSel = nItem;
            }
        }
    }

    m_list_IpAddresses.SetCurSel(nSel);
    m_list_IpAddresses.SetRedraw(TRUE);
}



DWORD
CFtpSecurityPage::SortAccessList()
/*++

Routine Description:

    Sorting the access list by grant denied and ip address
    FillListBox() should be called after this because
    the listbox will no longer reflect the true status
    of the list of directories.

Arguments:

    None

Return Value:
    
    Error return code

--*/
{
    BeginWaitCursor();
    DWORD dw =  m_oblAccessList.Sort(
        (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CIPAccessDescriptor::OrderByAddress);
    EndWaitCursor();

    return dw;
}



INT_PTR
CFtpSecurityPage::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit. Return the value returned 
    by the dialog

Arguments:

    BOOL fAdd : If TRUE, create new item.  Otherwise, edit existing item

Return Value:

    Dialog return code (IDOK/IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CIPAccessDescriptor * pAccess = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        //
        // Edit existing entry -- there better be only one...
        //
        pAccess = m_list_IpAddresses.GetSelectedItem();
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            //
            // Double click?
            //
            return IDCANCEL;
        }
    }

    CIPAccessDlg dlgAccess(
        m_fDefaultGranted, 
        pAccess, 
        &m_oblAccessList, 
        this
        );

    INT_PTR nReturn = dlgAccess.DoModal();

    if (nReturn == IDOK)
    {
        CError err;
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            try
            {
                if (fAdd)
                {
                    m_oblAccessList.AddTail(pAccess);
                }

                SortAccessList();
                FillListBox(pAccess);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;    
                e->Delete();
            }
        }

        err.MessageBoxOnFailure();
    }

    return nReturn;
}



void
CFtpSecurityPage::OnDblclkListIpAddresses()
/*++

Routine Description:

    Map listbox double click to the edit button

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CFtpSecurityPage::OnErrspaceListIpAddresses()
/*++

Routine Description:

    Handle error condition in the ip address listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFtpSecurityPage::OnSelchangeListIpAddresses()
/*++

Routine Description:

    Handle change in the selection of the listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CFtpSecurityPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function
    
Arguments:

    None
    
Return Value:

    None

--*/
{
    SetModified(TRUE);
}



BOOL
CFtpSecurityPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_icon_Granted.SetIcon(::AfxGetApp()->LoadIcon(IDI_GRANTED));
    m_icon_Denied.SetIcon(::AfxGetApp()->LoadIcon(IDI_DENIED));

    m_list_IpAddresses.Initialize();

    m_list_IpAddresses.EnableWindow(HasIPAccessCheck());
    m_button_Add.EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_RADIO_GRANTED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_RADIO_DENIED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_GRANTED)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_DENIED)->EnableWindow(HasIPAccessCheck());

    FillListBox();
    SetControlStates();

    return TRUE;  
}



void
CFtpSecurityPage::OnRadioGranted()
/*++

Routine Description:

    Granted by default has been selected.
    Refill the listbox with items that have
    been explicitly denied.  Although we can
    only have a deny list or a grant list,
    we keep both of them around until it comes
    time to saving the information.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fDefaultGranted)
    {
        m_fDefaultGranted = TRUE;
        FillListBox();
        OnItemChanged();
        SetControlStates();
    }
}



void
CFtpSecurityPage::OnRadioDenied()
/*++

Routine Description:

    As above, but reverse granted and denied 

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fDefaultGranted)
    {
        m_fDefaultGranted = FALSE;
        FillListBox();
        OnItemChanged();
        SetControlStates();
    }
}



int
CFtpSecurityPage::OnVKeyToItem(
    IN UINT nKey, 
    IN CListBox * pListBox, 
    IN UINT nIndex
    ) 
/*++

Routine Description:

    Map insert and delete keys for the listbox

Arguments:

    UINT nKey               : Key pressed
    CListBox * pListBox     : Listbox
    UINT nIndex             : Index selected

Return Value:

    -2 if fully handled, -1 if partially handled, 0+ if not
    handled at all    

--*/
{
    switch(nKey)
    {
    case VK_DELETE:
        OnButtonRemove();
        break;

    case VK_INSERT:
        OnButtonAdd();
        break;

    default:
        //
        // Not completely handled by this function, let
        // windows handle the remaining default action.
        //
        return -1;
    }

    //
    // No further action is neccesary.
    //
    return -2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fservic.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        fservic.cpp

   Abstract:

        FTP Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "ftpsht.h"
#include "fservic.h"
#include "usersess.h"
#include "iisobj.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Some sanity values on max connections
//
#define MAX_MAX_CONNECTIONS      (1999999999L)
#define INITIAL_MAX_CONNECTIONS  (      1000L)
#define UNLIMITED_CONNECTIONS    (2000000000L)

#define MAX_TIMEOUT              (0x7FFFFFFF)

#define LIMITED_CONNECTIONS_MIN    (10)
#define LIMITED_CONNECTIONS_MAX    (40)



IMPLEMENT_DYNCREATE(CFtpServicePage, CInetPropertyPage)



CFtpServicePage::CFtpServicePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for FTP service property page

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CFtpServicePage::IDD, pSheet)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CFtpServicePage)
    m_strComment = _T("");
    m_nTCPPort = 20;
    m_nUnlimited = RADIO_LIMITED;
    m_nIpAddressSel = -1;
    m_fEnableLogging = FALSE;
    //}}AFX_DATA_INIT

    m_nMaxConnections = 50;
    m_nVisibleMaxConnections = 50;
    m_nConnectionTimeOut = 600;
    m_iaIpAddress = (LONG)0L;
    m_strDomainName = _T("");

#endif // 0
}



CFtpServicePage::~CFtpServicePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpServicePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    if (!pDX->m_bSaveAndValidate)
    {
        m_fEnableLogging = LoggingEnabled(m_dwLogType);
    }

    //{{AFX_DATA_MAP(CFtpServicePage)
    DDX_Radio(pDX, IDC_RADIO_UNLIMITED, m_nUnlimited);
    DDX_Check(pDX, IDC_CHECK_ENABLE_LOGGING, m_fEnableLogging);
    DDX_Text(pDX, IDC_EDIT_COMMENT, m_strComment);
    DDV_MinMaxChars(pDX, m_strComment, 0, MAX_PATH);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxConnections);
    DDX_Control(pDX, IDC_STATIC_LOG_PROMPT, m_static_LogPrompt);
    DDX_Control(pDX, IDC_STATIC_CONNECTIONS, m_static_Connections);
    DDX_Control(pDX, IDC_BUTTON_PROPERTIES, m_button_LogProperties);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESS, m_combo_IpAddresses);
    DDX_Control(pDX, IDC_COMBO_LOG_FORMATS, m_combo_LogFormats);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);

    if (!IsMasterInstance())
    {
        DDV_MinMaxUInt(pDX, m_nTCPPort, 1, 65535);
    }

    if (pDX->m_bSaveAndValidate && !FetchIpAddressFromCombo(
        m_combo_IpAddresses,
        m_oblIpAddresses,
        m_iaIpAddress
        ))
    {
        pDX->Fail();
    }

    //
    // Private DDX/DDV Routines
    //
    int nMin = IsMasterInstance() ? 0 : 1;

    if (!pDX->m_bSaveAndValidate || !m_fUnlimitedConnections )
    {
        DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_nVisibleMaxConnections);
    }

    if (m_f10ConnectionLimit)
    {
        //
        // Special validation for unlimited connections.  We use a bogus
        // numeric check for data validation.  Number adjustment happens 
        // later.
        //
        if (pDX->m_bSaveAndValidate && 
            (m_nVisibleMaxConnections < 0 || 
             m_nVisibleMaxConnections > UNLIMITED_CONNECTIONS))
        {
            TCHAR szMin[32];
            TCHAR szMax[32];
            wsprintf(szMin, _T("%ld"), 0);
            wsprintf(szMax, _T("%ld"), 40);
            CString prompt;
            AfxFormatString2(prompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
            AfxMessageBox(prompt, MB_ICONEXCLAMATION);
            prompt.Empty(); // exception prep
            pDX->Fail();
        }
    }
    else
    {
        DDV_MinMaxLong(pDX, m_nVisibleMaxConnections, 0, UNLIMITED_CONNECTIONS);
    }

    DDX_Text(pDX, IDC_EDIT_CONNECTION_TIMEOUT, m_nConnectionTimeOut);
    DDV_MinMaxLong(pDX, m_nConnectionTimeOut, nMin, MAX_TIMEOUT);

    if (pDX->m_bSaveAndValidate)
    {
        EnableLogging(m_dwLogType, m_fEnableLogging);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpServicePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpServicePage)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_LOGGING, OnCheckEnableLogging)
    ON_BN_CLICKED(IDC_RADIO_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_BUTTON_CURRENT_SESSIONS, OnButtonCurrentSessions)
    ON_BN_CLICKED(IDC_BUTTON_PROPERTIES, OnButtonProperties)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_TCP_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_CONNECTION_TIMEOUT, OnItemChanged)
    ON_CBN_EDITCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_LOG_FORMATS, OnItemChanged)

END_MESSAGE_MAP()



void
CFtpServicePage::SetControlStates()
/*++

Routine Description:

    Set the states of the dialog control depending on its current
    values.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_edit_MaxConnections.m_hWnd)
    {
        m_edit_MaxConnections.EnableWindow(!m_fUnlimitedConnections);
        m_static_Connections.EnableWindow(!m_fUnlimitedConnections);
    }
}



void
CFtpServicePage::PopulateKnownIpAddresses()
/*++

Routine Description:

    Fill the combo box with known ip addresses

Arguments:

    None

Return Value:

    None

--*/
{
    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        QueryServerName(),
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel 
        );
    EndWaitCursor();
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CFtpServicePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CInetPropertyPage::OnInitDialog();

    //
    // Take our direction from a phony button
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_LogProperties.Create(
        _T("LogUI"),
        WS_BORDER,
        rc,
        this,
        IDC_LOGUICTRL
        );

    //
    // Initialize the logging ocx; pass it the metabase path of the 
    // virtual server.
    // TODO: Rewrite this crappy logui control to make it more predictable.
    // Here metabase path should not contain leading / and trailing Root
    //
    CString path_inst = QueryMetaPath();
    CString path;
    if (IsMasterInstance())
    {
       CMetabasePath::GetServicePath(path_inst, path);
    }
    else
    {
       CMetabasePath::GetInstancePath(path_inst, path);
    }
    if (path[0] == _T('/'))
    {
        path = path.Right(path.GetLength() - 1);
    }
    m_ocx_LogProperties.SetAdminTarget(QueryServerName(), path);
    m_ocx_LogProperties.SetComboBox(m_combo_LogFormats.m_hWnd);

    GetDlgItem(IDC_RADIO_UNLIMITED)->EnableWindow(!m_f10ConnectionLimit);

    if (IsMasterInstance() || !HasAdminAccess())
    {
        GetDlgItem(IDC_STATIC_IPADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_TCP_PORT)->EnableWindow(FALSE);
        m_combo_IpAddresses.EnableWindow(FALSE);
		GetDlgItem(IDC_STATIC_DESCRIPTION)->EnableWindow(FALSE);
		GetDlgItem(IDC_EDIT_COMMENT)->EnableWindow(FALSE);
    }

    PopulateKnownIpAddresses();
    SetControlStates();
    SetLogState();

    GetDlgItem(IDC_BUTTON_CURRENT_SESSIONS)->EnableWindow(!IsMasterInstance());

    return TRUE;
}



/* virtual */
HRESULT
CFtpServicePage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    m_f10ConnectionLimit = Has10ConnectionLimit();

    BEGIN_META_INST_READ(CFtpSheet)
        FETCH_INST_DATA_FROM_SHEET(m_nMaxConnections);
        FETCH_INST_DATA_FROM_SHEET(m_nConnectionTimeOut);
        FETCH_INST_DATA_FROM_SHEET(m_iaIpAddress);
        FETCH_INST_DATA_FROM_SHEET(m_nTCPPort);
        FETCH_INST_DATA_FROM_SHEET(m_strDomainName);
        FETCH_INST_DATA_FROM_SHEET(m_strComment);
        FETCH_INST_DATA_FROM_SHEET(m_dwLogType);
        
        m_fUnlimitedConnections = m_nMaxConnections >= MAX_MAX_CONNECTIONS;

        if (m_f10ConnectionLimit)
        {
            m_fUnlimitedConnections = FALSE;
            if ((LONG)m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
            {
                m_nMaxConnections = LIMITED_CONNECTIONS_MAX;
            }
        }

        m_nVisibleMaxConnections = m_fUnlimitedConnections
            ? INITIAL_MAX_CONNECTIONS
            : m_nMaxConnections;

        //
        // Set radio value
        //
        m_nUnlimited = m_fUnlimitedConnections ? RADIO_UNLIMITED : RADIO_LIMITED;

        m_nOldTCPPort = m_nTCPPort;
    END_META_INST_READ(err)

    return err;
}




HRESULT
CFtpServicePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP service page now...");

    CError err;

    m_nMaxConnections = m_fUnlimitedConnections 
        ? UNLIMITED_CONNECTIONS
        : m_nVisibleMaxConnections;

    //
    // Check to make sure we're not violating the license
    // agreement
    //
    if (m_f10ConnectionLimit)
    {
        if (m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
        {
            ::AfxMessageBox(IDS_CONNECTION_LIMIT);
            m_nMaxConnections = LIMITED_CONNECTIONS_MIN;
        }
        else if (m_nMaxConnections >  LIMITED_CONNECTIONS_MIN
              && m_nMaxConnections <= LIMITED_CONNECTIONS_MAX)
        {
            ::AfxMessageBox(IDS_WRN_CONNECTION_LIMIT);
        }
    }

    CString strBinding;
    CStringListEx m_strlBindings;

    CInstanceProps::BuildBinding(
        strBinding, 
        m_iaIpAddress, 
        m_nTCPPort, 
        m_strDomainName
        );
    m_strlBindings.AddTail(strBinding);
    m_ocx_LogProperties.ApplyLogSelection();

    BeginWaitCursor();
    BEGIN_META_INST_WRITE(CFtpSheet)
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
        STORE_INST_DATA_ON_SHEET(m_nConnectionTimeOut);
        STORE_INST_DATA_ON_SHEET(m_dwLogType);
        STORE_INST_DATA_ON_SHEET(m_strComment);
        STORE_INST_DATA_ON_SHEET(m_strlBindings);
    END_META_INST_WRITE(err)
    EndWaitCursor();

    if (err.Succeeded())
    {
		CIISMBNode * pNode = (CIISMBNode *)GetSheet()->GetParameter();
		ASSERT(pNode != NULL);
		pNode->Refresh(FALSE);
    }

    return err;
}



void
CFtpServicePage::OnRadioLimited()
/*++

Routine Description:

    'limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = FALSE;
    SetControlStates();
    m_edit_MaxConnections.SetSel(0, -1);
    m_edit_MaxConnections.SetFocus();
    OnItemChanged();
}



void
CFtpServicePage::OnRadioUnlimited()
/*++

Routine Description:

    'unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = TRUE;
    OnItemChanged();
}



void
CFtpServicePage::OnItemChanged()
/*++

Routine Description:

    Register a change in control value on this page.  Mark the page as dirty.
    All change messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    SetModified(TRUE);
}



void
CFtpServicePage::SetLogState()
/*++

Routine Description:

    Set the enabled state of the logging controls depending on
    whether logging is currently enabled

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_LogPrompt.EnableWindow(m_fEnableLogging);
    m_combo_LogFormats.EnableWindow(m_fEnableLogging);
    m_button_LogProperties.EnableWindow(m_fEnableLogging);
}



void
CFtpServicePage::OnCheckEnableLogging()
/*++

Routine Description:

    'Enable logging' checkbox has been toggled.  Reset the state
    of the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableLogging = !m_fEnableLogging;
    SetLogState();
    OnItemChanged();
}



void 
CFtpServicePage::OnButtonProperties() 
/*++

Routine Description:

    Pass on "log properties" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    m_ocx_LogProperties.DoClick();
}



void
CFtpServicePage::OnButtonCurrentSessions()
/*++

Routine Description:

    'Current Sessions' button has been pressed.  Bring up the current
    sessions dialog

Arguments:

    None

Return Value:

    None

-*/
{
    CComAuthInfo * pAuth = GetSheet()->QueryAuthInfo();
    ASSERT(pAuth != NULL);
    CUserSessionsDlg dlg(
        pAuth->QueryServerName(), 
        QueryInstance(), 
        pAuth->QueryUserName(),
        pAuth->QueryPassword(),
        this);
    dlg.DoModal();
}



void 
CFtpServicePage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();
    
    if (m_ocx_LogProperties.m_hWnd)
    {
        m_ocx_LogProperties.Terminate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fservic.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        fservic.h

   Abstract:

        FTP Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __FSERVIC_H__
#define __FSERVIC_H__


//{{AFX_INCLUDES()
#include "logui.h"
//}}AFX_INCLUDES



class CFtpServicePage : public CInetPropertyPage
/*++

Class Description:

    FTP Service property page

Public Interface:

    CFtpServicePage  : Constructor
    ~CFtpServicePage : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpServicePage)

//
// Constructors/Destructors
//
public:
    CFtpServicePage(
        IN CInetPropertySheet * pSheet = NULL
        );

    ~CFtpServicePage();

//
// Dialog Data
//
protected:
    //
    //  Radio button IDs for unlimited radio control
    //
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CFtpServicePage)
    enum { IDD = IDD_FTP_SERVICE };
    int         m_nUnlimited;
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    BOOL        m_fEnableLogging;
    CString     m_strComment;
    CEdit       m_edit_MaxConnections;
    CStatic     m_static_LogPrompt;
    CStatic     m_static_Connections;
    CButton     m_button_LogProperties;
    CComboBox   m_combo_IpAddresses;
    CComboBox   m_combo_LogFormats;
    //}}AFX_DATA

    UINT        m_nOldTCPPort;
    BOOL        m_fUnlimitedConnections;
    DWORD       m_dwLogType;
    CILong      m_nConnectionTimeOut;
    CILong      m_nMaxConnections;
    CILong      m_nVisibleMaxConnections;
    CString     m_strDomainName;
    CIPAddress  m_iaIpAddress;
    CLogUI      m_ocx_LogProperties;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpServicePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    void SetControlStates();
    void SetLogState();
    void PopulateKnownIpAddresses();
    //LPCTSTR QueryMetaPath();

    //{{AFX_MSG(CFtpServicePage)
    afx_msg void OnCheckEnableLogging();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    afx_msg void OnButtonCurrentSessions();
    afx_msg void OnButtonProperties();
    virtual BOOL OnInitDialog();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

protected:
    CObListPlus m_oblIpAddresses;
    BOOL m_f10ConnectionLimit;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

/*
inline LPCTSTR CFtpServicePage::QueryMetaPath()
{
    return ((CFtpSheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}
*/

#endif // __FSERVIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\ftpsht.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        machsht.cpp

   Abstract:
        IIS Machine Property sheet classes

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager (cluster edition)

   Revision History:

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "ftpsht.h"



//
// Help IDs.  Home directory gets substituted.
//
#define HIDD_FTP_DIRECTORY_PROPERTIES       (IDD_FTP_DIRECTORY_PROPERTIES + 0x20000)
#define HIDD_FTP_HOME_DIRECTORY_PROPERTIES  (HIDD_FTP_DIRECTORY_PROPERTIES + 0x20000)



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



CFTPInstanceProps::CFTPInstanceProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor for FTP instance properties

Arguments:

    CComAuthInfo * pAuthInfo        : COM Authentication info
    LPCTSTR lpszMDPath              : MD Path

Return Value:

    N/A

--*/
    : CInstanceProps(pAuthInfo, lpszMDPath, 21U),
      m_nMaxConnections((LONG)0L),
      m_nConnectionTimeOut((LONG)0L),
      m_dwLogType(MD_LOG_TYPE_DISABLED),
      /**/
      m_strUserName(),
      m_strPassword(),
      m_fAllowAnonymous(FALSE),
      m_fOnlyAnonymous(FALSE),
      m_fPasswordSync(TRUE),
      m_acl(),
      /**/
      m_strExitMessage(),
      m_strMaxConMsg(),
      m_strlWelcome(),
	  m_strlBanner(),
      /**/
      m_fDosDirOutput(TRUE),
      /**/
      m_dwDownlevelInstance(1)
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CFTPInstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CInstanceProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      //
      // Service Page
      //
      HANDLE_META_RECORD(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      HANDLE_META_RECORD(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      HANDLE_META_RECORD(MD_LOG_TYPE,            m_dwLogType)
      //
      // Accounts Page
      //
      HANDLE_META_RECORD(MD_ANONYMOUS_USER_NAME,   m_strUserName)
      HANDLE_META_RECORD(MD_ANONYMOUS_PWD,         m_strPassword)
      HANDLE_META_RECORD(MD_ANONYMOUS_ONLY,        m_fOnlyAnonymous)
      HANDLE_META_RECORD(MD_ALLOW_ANONYMOUS,       m_fAllowAnonymous)
      HANDLE_META_RECORD(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
      HANDLE_META_RECORD(MD_ADMIN_ACL,             m_acl)
      //
      // Message Page
      //
      HANDLE_META_RECORD(MD_EXIT_MESSAGE,        m_strExitMessage)
      HANDLE_META_RECORD(MD_MAX_CLIENTS_MESSAGE, m_strMaxConMsg)
      HANDLE_META_RECORD(MD_GREETING_MESSAGE,    m_strlWelcome)
      HANDLE_META_RECORD(MD_BANNER_MESSAGE,		 m_strlBanner)
      //
      // Directory Properties Page
      //
      HANDLE_META_RECORD(MD_MSDOS_DIR_OUTPUT,    m_fDosDirOutput);
      //
      // Default Site
      //
      HANDLE_META_RECORD(MD_DOWNLEVEL_ADMIN_INSTANCE, m_dwDownlevelInstance)
      HANDLE_META_RECORD(MD_MAX_BANDWIDTH, m_dwMaxBandwidth)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CFTPInstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CInstanceProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    BEGIN_META_WRITE()
      //
      // Service Page
      //
      META_WRITE(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      META_WRITE(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      META_WRITE(MD_LOG_TYPE,            m_dwLogType)
      //
      // Accounts Page
      //
      META_WRITE(MD_ANONYMOUS_USER_NAME,   m_strUserName)
      META_WRITE(MD_ANONYMOUS_PWD,         m_strPassword)
      META_WRITE(MD_ANONYMOUS_ONLY,        m_fOnlyAnonymous)
      META_WRITE(MD_ALLOW_ANONYMOUS,       m_fAllowAnonymous)
      META_WRITE(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
      META_WRITE(MD_ADMIN_ACL,             m_acl)
      //
      // Message Page
      //
      META_WRITE(MD_EXIT_MESSAGE,        m_strExitMessage)
      META_WRITE(MD_MAX_CLIENTS_MESSAGE, m_strMaxConMsg)
      META_WRITE(MD_GREETING_MESSAGE,    m_strlWelcome)
      META_WRITE(MD_BANNER_MESSAGE,		 m_strlBanner)
      //
      // Directory Properties Page
      //
      META_WRITE(MD_MSDOS_DIR_OUTPUT,    m_fDosDirOutput);
      //
      // Default Site
      //
      META_WRITE(MD_DOWNLEVEL_ADMIN_INSTANCE, m_dwDownlevelInstance)
      META_WRITE(MD_MAX_BANDWIDTH, m_dwMaxBandwidth)
    END_META_WRITE(err);

    return err;
}



CFTPDirProps::CFTPDirProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    FTP Directory properties object

Arguments:

    CComAuthInfo * pAuthInfo        : COM Authentication info
    LPCTSTR lpszMDPath              : MD Path

Return Value:

    N/A.

--*/
    : CChildNodeProps(
        pAuthInfo,
        lpszMDPath,
        WITH_INHERITANCE,
        FALSE               // Complete information
        ),
      /**/
      m_fDontLog(FALSE),
      m_ipl()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CFTPDirProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CChildNodeProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,  m_pbMDData)
      HANDLE_META_RECORD(MD_VR_USERNAME,      m_strUserName)
      HANDLE_META_RECORD(MD_VR_PASSWORD,      m_strPassword)
      HANDLE_META_RECORD(MD_DONT_LOG,         m_fDontLog);
      HANDLE_META_RECORD(MD_IP_SEC,           m_ipl);
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CFTPDirProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CChildNodeProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    //
    // CODEWORK: Consider DDX/DDV like methods which do both
    // ParseFields and WriteDirtyProps in a single method.  Must
    // take care not to write data which should only be read, not
    // written
    //
    BEGIN_META_WRITE()
      META_WRITE(MD_VR_USERNAME,      m_strUserName)
      META_WRITE(MD_VR_PASSWORD,      m_strPassword)
      META_WRITE(MD_DONT_LOG,         m_fDontLog);
      META_WRITE(MD_IP_SEC,           m_ipl);
    END_META_WRITE(err);

    return err;
}



//
// FTP Property Sheet Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CFtpSheet::CFtpSheet(
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMetaPath,
    CWnd *  pParentWnd,
    LPARAM lParam,
    LONG_PTR handle,
    UINT iSelectPage          
    )
/*++

Routine Description:

    FTP Property sheet constructor

Arguments:

    CComAuthInfo * pAuthInfo  : Authentication information
    LPCTSTR lpszMetPath       : Metabase path
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    LONG_PTR handle           : MMC Console handle
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CInetPropertySheet(
        pAuthInfo,
        lpszMetaPath,
        pParentWnd,
        lParam,
        handle,
        iSelectPage
        ),
      m_ppropInst(NULL),
      m_ppropDir(NULL)
{
}



CFtpSheet::~CFtpSheet()
/*++

Routine Description:

    FTP Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    FreeConfigurationParameters();
}



void
CFtpSheet::WinHelp(
    IN DWORD dwData,
    IN UINT  nCmd
    )
/*++

Routine Description:

    FTP Property sheet help handler

Arguments:

    DWORD dwData            : WinHelp data (dialog ID)
    UINT nCmd               : WinHelp command

Return Value:

    None

Notes:

    Replace the dialog ID if this is the directory tab.  We have
    different help depending on virtual directory, home, file, directory.

--*/
{
    ASSERT(m_ppropDir != NULL);

    if (::lstrcmpi(m_ppropDir->QueryAlias(), g_cszRoot) == 0
        && dwData == HIDD_FTP_DIRECTORY_PROPERTIES)
    {
        //
        // It's a home virtual directory -- change the ID
        //
        dwData = HIDD_FTP_HOME_DIRECTORY_PROPERTIES;
    }

    CInetPropertySheet::WinHelp(dwData, nCmd);
}



/* virtual */ 
HRESULT 
CFtpSheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Load base properties
    //
    CError err(CInetPropertySheet::LoadConfigurationParameters());

    if (err.Failed())
    {
        return err;
    }

    if (m_ppropInst == NULL)
    {
        //
        // First call -- load values
        //
        ASSERT(m_ppropDir == NULL);

        m_ppropInst = new CFTPInstanceProps(QueryAuthInfo(), QueryInstancePath());
        m_ppropDir  = new CFTPDirProps(QueryAuthInfo(), QueryDirectoryPath());

        if (!m_ppropInst || !m_ppropDir)
        {
            TRACEEOLID("LoadConfigurationParameters: OOM");
            SAFE_DELETE(m_ppropDir);
            SAFE_DELETE(m_ppropInst);

            err = ERROR_NOT_ENOUGH_MEMORY;
            return err;
        }

        err = m_ppropInst->LoadData();

        if (err.Succeeded())
        {
            err = m_ppropDir->LoadData();
        }
    }

    return err;
}



/* virtual */ 
void 
CFtpSheet::FreeConfigurationParameters()
/*++

Routine Description:

    Clean up configuration data

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Base class
    //
    CInetPropertySheet::FreeConfigurationParameters();

    ASSERT(m_ppropInst != NULL);
    ASSERT(m_ppropDir  != NULL);

    SAFE_DELETE(m_ppropInst);
    SAFE_DELETE(m_ppropDir);
}




//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\ftpaddnew.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        FtpAddNew.cpp

   Abstract:

        Classes for new FTP site and virtual directory creation

   Author:

        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        11/8/2000       sergeia     Initial creation

--*/

#ifndef _FTP_NEW_WIZARD_H
#define _FTP_NEW_WIZARD_H

class CFtpWizSettings : public CObjectPlus
/*++

Class Description:

    FTP Wizard settings intended to pass along from page
    to page

--*/
{
//
// Constructor/Destructor
//
public:
    CFtpWizSettings(
        CMetaKey * pMetaKey,
        LPCTSTR lpszServerName,
        BOOL fNewSite,
        DWORD   dwInstance   = MASTER_INSTANCE,
        LPCTSTR lpszParent   = NULL
        );

//
// Public Properties
//
public:
    BOOL    m_fNewSite;
    BOOL    m_fLocal;
    BOOL    m_fUNC;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    DWORD   m_dwInstance;        // site instance number
    CString m_strParent;
    CString m_strServerName;     // machine name
    CString m_strDescription;
    CString m_strBinding;
    CString m_strAlias;
    CString m_strPath;
    CString m_strUserName;
    CString m_strPassword;
    HRESULT m_hrResult;
    CMetaKey * m_pKey;
};


//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CFtpWizDescription : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizDescription)
//
// Construction
//
public:
    CFtpWizDescription(CFtpWizSettings * pwsSettings = NULL);
    ~CFtpWizDescription();

//
// Dialog Data
//
protected:
    enum { IDD = IDD_FTP_NEW_INST_DESCRIPTION };
    //{{AFX_DATA(CFtpWizDescription)
    CEdit   m_edit_Description;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizDescription)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizDescription)
    afx_msg void OnChangeEditDescription();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
};



//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizBindings : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizBindings)

//
// Construction
//
public:
    CFtpWizBindings(CFtpWizSettings * pSettings = NULL);
    ~CFtpWizBindings();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizBindings)
    enum { IDD = IDD_FTP_NEW_INST_BINDINGS };
    int        m_nIpAddressSel;
    UINT       m_nTCPPort;
    CComboBox  m_combo_IpAddresses;
    //}}AFX_DATA

    CIPAddress  m_iaIpAddress;
    CObListPlus m_oblIpAddresses;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizBindings)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizBindings)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
};



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizAlias : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizAlias)

//
// Construction
//
public:
    CFtpWizAlias(CFtpWizSettings * pwsSettings = NULL);
    ~CFtpWizAlias();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizAlias)
    enum { IDD = IDD_FTP_NEW_DIR_ALIAS };
    CEdit   m_edit_Alias;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizAlias)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizAlias)
    afx_msg void OnChangeEditAlias();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();


private:
    CFtpWizSettings * m_pSettings;
};



//
// Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizPath : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizPath)

//
// Construction
//
public:
    CFtpWizPath(
		CFtpWizSettings * pwsSettings = NULL,
        BOOL bVDir = TRUE
        );
    ~CFtpWizPath();

    int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizPath)
    enum { IDD = -1 };
    CEdit   m_edit_Path;
    CButton m_button_Browse;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizPath)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizPath)
    afx_msg void OnChangeEditPath();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
    LPTSTR m_pPathTemp;
    CString m_strBrowseTitle;
};



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizUserName : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizUserName)

//
// Construction
//
public:
    CFtpWizUserName(
        IN CFtpWizSettings * pSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CFtpWizUserName();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizUserName)
    enum { IDD = IDD_FTP_NEW_USER_PASSWORD };
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizUserName)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizUserName)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnChangeEditUsername();
    afx_msg void OnButtonCheckPassword();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
};



//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CFtpWizPermissions : public CIISWizardPage
{
    DECLARE_DYNCREATE(CFtpWizPermissions)

//
// Construction
//
public:
    CFtpWizPermissions(
        IN CFtpWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CFtpWizPermissions();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CFtpWizPermissions)
    enum { IDD = IDD_FTP_NEW_PERMS };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CFtpWizPermissions)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpWizPermissions)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CFtpWizSettings * m_pSettings;
    BOOL m_bVDir;
};

#endif //_FTP_NEW_WIZARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\ftpaddnew.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        FtpAddNew.cpp

   Abstract:

        Implementation for classes used in creation of new FTP site and virtual directory

   Author:

        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        11/8/2000       sergeia     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "strfn.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "wizard.h"
#include "FtpAddNew.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#define DEF_PORT        (21)
#define MAX_ALIAS_NAME (240)        // Ref Bug 241148

HRESULT
RebindInterface(OUT IN CMetaInterface * pInterface,
    OUT BOOL * pfContinue, IN  DWORD dwCancelError);

extern CComModule _Module;

HRESULT
CIISMBNode::AddFTPSite(
    const CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type,
    DWORD * inst
    )
{

   CFtpWizSettings ws(
      dynamic_cast<CMetaKey *>(QueryInterface()),
      QueryMachineName(),
      TRUE
      );
   CIISWizardSheet sheet(
      IDB_WIZ_FTP_LEFT, IDB_WIZ_FTP_HEAD);
   CIISWizardBookEnd pgWelcome(
        IDS_FTP_NEW_SITE_WELCOME, 
        IDS_FTP_NEW_SITE_WIZARD, 
        IDS_FTP_NEW_SITE_BODY
        );
   CFtpWizDescription pgDescr(&ws);
   CFtpWizBindings pgBindings(&ws);
   CFtpWizPath pgHome(&ws, FALSE);
   CFtpWizUserName pgUserName(&ws, FALSE);
   CFtpWizPermissions pgPerms(&ws, FALSE);
   CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_FTP_NEW_SITE_SUCCESS,
        IDS_FTP_NEW_SITE_FAILURE,
        IDS_FTP_NEW_SITE_WIZARD
        );

   sheet.AddPage(&pgWelcome);
   sheet.AddPage(&pgDescr);
   sheet.AddPage(&pgBindings);
   sheet.AddPage(&pgHome);
   sheet.AddPage(&pgUserName);
   sheet.AddPage(&pgPerms);
   sheet.AddPage(&pgCompletion);

   if (sheet.DoModal() == IDCANCEL)
   {
      return CError::HResult(ERROR_CANCELLED);
   }
   if (inst != NULL && SUCCEEDED(ws.m_hrResult))
   {
      *inst = ws.m_dwInstance;
   }
   return ws.m_hrResult;
}

HRESULT
CIISMBNode::AddFTPVDir(
    const CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type,
    CString& alias
    )
{

   CFtpWizSettings ws(
      dynamic_cast<CMetaKey *>(QueryInterface()),
      QueryMachineName(),
      FALSE
      );
   CComBSTR path;
   BuildMetaPath(path);
   ws.m_strParent = path;
   CIISWizardSheet sheet(
      IDB_WIZ_FTP_LEFT, IDB_WIZ_FTP_HEAD);
   CIISWizardBookEnd pgWelcome(
        IDS_FTP_NEW_VDIR_WELCOME, 
        IDS_FTP_NEW_VDIR_WIZARD, 
        IDS_FTP_NEW_VDIR_BODY
        );
   CFtpWizAlias pgAlias(&ws);
   CFtpWizPath pgHome(&ws, TRUE);
   CFtpWizUserName pgUserName(&ws, TRUE);
   CFtpWizPermissions pgPerms(&ws, TRUE);
   CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_FTP_NEW_VDIR_SUCCESS,
        IDS_FTP_NEW_VDIR_FAILURE,
        IDS_FTP_NEW_VDIR_WIZARD
        );

   sheet.AddPage(&pgWelcome);
   sheet.AddPage(&pgAlias);
   sheet.AddPage(&pgHome);
   sheet.AddPage(&pgUserName);
   sheet.AddPage(&pgPerms);
   sheet.AddPage(&pgCompletion);

   if (sheet.DoModal() == IDCANCEL)
   {
      return CError::HResult(ERROR_CANCELLED);
   }
   if (SUCCEEDED(ws.m_hrResult))
   {
       alias = ws.m_strAlias;
   }
   return ws.m_hrResult;
}

CFtpWizSettings::CFtpWizSettings(
        CMetaKey * pMetaKey,
        LPCTSTR lpszServerName,     
        BOOL fNewSite,
        DWORD   dwInstance,
        LPCTSTR lpszParent
        ) :
        m_hrResult(S_OK),
        m_pKey(pMetaKey),
        m_fNewSite(fNewSite),
        m_fUNC(FALSE),
        m_fRead(FALSE),
        m_fWrite(FALSE),
        m_dwInstance(dwInstance)

{
    ASSERT(lpszServerName != NULL);

    m_strServerName = lpszServerName;
    m_fLocal = IsServerLocal(m_strServerName);
    if (lpszParent)
    {
        m_strParent = lpszParent;
    }
}


IMPLEMENT_DYNCREATE(CFtpWizDescription, CIISWizardPage)

CFtpWizDescription::CFtpWizDescription(CFtpWizSettings * pData)
    : CIISWizardPage(
        CFtpWizDescription::IDD, IDS_FTP_NEW_SITE_WIZARD, HEADER_PAGE
        ),
      m_pSettings(pData)
{
}

CFtpWizDescription::~CFtpWizDescription()
{
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizDescription, CIISWizardPage)
   //{{AFX_MSG_MAP(CFtpWizDescription)
   ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnChangeEditDescription)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void
CFtpWizDescription::OnChangeEditDescription()
{
   SetControlStates();
}

LRESULT
CFtpWizDescription::OnWizardNext()
{
   if (!ValidateString(m_edit_Description, 
         m_pSettings->m_strDescription, 1, MAX_PATH))
   {
      return -1;
   }
   return CIISWizardPage::OnWizardNext();
}

BOOL
CFtpWizDescription::OnSetActive()
{
   SetControlStates();
   return CIISWizardPage::OnSetActive();
}

void
CFtpWizDescription::DoDataExchange(CDataExchange * pDX)
{
   CIISWizardPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CFtpWizDescription)
   DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_edit_Description);
   //}}AFX_DATA_MAP
}

void
CFtpWizDescription::SetControlStates()
{
   DWORD dwFlags = PSWIZB_BACK;

   if (m_edit_Description.GetWindowTextLength() > 0)
   {
      dwFlags |= PSWIZB_NEXT;
   }
    
   SetWizardButtons(dwFlags); 
}

///////////////////////////////////////////

//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CFtpWizAlias, CIISWizardPage)



CFtpWizAlias::CFtpWizAlias(
    IN OUT CFtpWizSettings * pSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CFtpWizAlias::IDD,
        IDS_FTP_NEW_VDIR_WIZARD,
        HEADER_PAGE
        ),
      m_pSettings(pSettings)
      //m_strAlias()
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CFtpWizAlias)
    m_strAlias = _T("");
    //}}AFX_DATA_INIT

#endif // 0
}



CFtpWizAlias::~CFtpWizAlias()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpWizAlias::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizAlias)
    DDX_Control(pDX, IDC_EDIT_ALIAS, m_edit_Alias);
    //}}AFX_DATA_MAP
}



LRESULT
CFtpWizAlias::OnWizardNext() 
/*++

Routine Description:

    prevent the / and \ characters from being in the alias name

Arguments:

    None

Return Value:

    None

--*/
{
    if (!ValidateString(
        m_edit_Alias, 
        m_pSettings->m_strAlias, 
        1, 
        MAX_ALIAS_NAME
        ))
    {
        return -1;
    }

    //
    // Find the illegal characters. If they exist tell 
    // the user and don't go on.
    //
    if (m_pSettings->m_strAlias.FindOneOf(_T("/\\?*")) >= 0)
    {
        AfxMessageBox(IDS_ILLEGAL_ALIAS_CHARS);
        m_edit_Alias.SetFocus();
        m_edit_Alias.SetSel(0, -1);

        //
        // prevent the wizard page from changing
        //
        return -1;
    }

    //
    // Allow the wizard to continue
    //
    return CIISWizardPage::OnWizardNext();
}



void
CFtpWizAlias::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Alias.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizAlias, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizAlias)
    ON_EN_CHANGE(IDC_EDIT_ALIAS, OnChangeEditAlias)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CFtpWizAlias::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void
CFtpWizAlias::OnChangeEditAlias() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}


///////////////////////////////////////////


IMPLEMENT_DYNCREATE(CFtpWizBindings, CIISWizardPage)


CFtpWizBindings::CFtpWizBindings(
    IN OUT CFtpWizSettings * pSettings
    ) 
    : CIISWizardPage(CFtpWizBindings::IDD,
        IDS_FTP_NEW_SITE_WIZARD, HEADER_PAGE
        ),
      m_pSettings(pSettings),
      m_iaIpAddress(),
      m_oblIpAddresses()
{
    //{{AFX_DATA_INIT(CFtpWizBindings)
    m_nTCPPort = DEF_PORT;
    m_nIpAddressSel = -1;
    //}}AFX_DATA_INIT
}

CFtpWizBindings::~CFtpWizBindings()
{
}

void
CFtpWizBindings::DoDataExchange(
   IN CDataExchange * pDX
   )
{
   CIISWizardPage::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CFtpWizBindings)
   DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
   DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
   DDV_MinMaxUInt(pDX, m_nTCPPort, 1, 65535);
   //}}AFX_DATA_MAP

   DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

   if (pDX->m_bSaveAndValidate)
   {
      if (!FetchIpAddressFromCombo(
            m_combo_IpAddresses,
            m_oblIpAddresses,
            m_iaIpAddress
            ))
      {
         pDX->Fail();
      }

      CString strDomain;
      CInstanceProps::BuildBinding(
            m_pSettings->m_strBinding, 
            m_iaIpAddress, 
            m_nTCPPort, 
            strDomain
            );
   }
}

void
CFtpWizBindings::SetControlStates()
{
   SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizBindings, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizBindings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CFtpWizBindings::OnInitDialog() 
{
    CIISWizardPage::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_pSettings->m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();
    
    return TRUE;
}

BOOL
CFtpWizBindings::OnSetActive() 
{
   SetControlStates();
   return CIISWizardPage::OnSetActive();
}

///////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFtpWizPath, CIISWizardPage)

CFtpWizPath::CFtpWizPath(
    IN OUT CFtpWizSettings * pSettings,
    IN BOOL bVDir 
    ) 
    : CIISWizardPage(
        (bVDir ? IDD_NEW_FTP_DIR_PATH : IDD_NEW_FTP_INST_HOME),         // Template
        (bVDir ? IDS_FTP_NEW_VDIR_WIZARD : IDS_FTP_NEW_SITE_WIZARD),    // Caption
        HEADER_PAGE                                             // Header page
        ),
      m_pSettings(pSettings)
{

#if 0 // Keep ClassWizard happy

    //{{AFX_DATA_INIT(CFtpWizPath)
    m_strPath = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}

CFtpWizPath::~CFtpWizPath()
{
}

void
CFtpWizPath::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizPath)
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_PATH, m_pSettings->m_strPath);
    DDV_MaxChars(pDX, m_pSettings->m_strPath, MAX_PATH);
}

void 
CFtpWizPath::SetControlStates()
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Path.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizPath, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizPath)
    ON_EN_CHANGE(IDC_EDIT_PATH, OnChangeEditPath)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CFtpWizPath::OnSetActive() 
{
    SetControlStates();
    return CIISWizardPage::OnSetActive();
}

LRESULT
CFtpWizPath::OnWizardNext() 
{
    if (!ValidateString(m_edit_Path, m_pSettings->m_strPath, 1, MAX_PATH))
    {
        return -1;
    }
    if (!PathIsValid(m_pSettings->m_strPath))
    {
        m_edit_Path.SetSel(0,-1);
        m_edit_Path.SetFocus();
        ::AfxMessageBox(IDS_ERR_BAD_PATH);
    }

    m_pSettings->m_fUNC = IsUNCName(m_pSettings->m_strPath);

    if (!m_pSettings->m_fUNC)
    {
        if (!IsFullyQualifiedPath(m_pSettings->m_strPath)
         && !IsDevicePath(m_pSettings->m_strPath)
           )
        {
            m_edit_Path.SetSel(0,-1);
            m_edit_Path.SetFocus();
            ::AfxMessageBox(IDS_ERR_BAD_PATH);

            return -1;
        }

        if (m_pSettings->m_fLocal)
        {
            DWORD dwAttr = GetFileAttributes(m_pSettings->m_strPath);
            if (dwAttr == 0xffffffff || 
               (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                m_edit_Path.SetSel(0,-1);
                m_edit_Path.SetFocus();
                ::AfxMessageBox(IDS_ERR_PATH_NOT_FOUND);

                return -1;
            }
        }
    }

    return CIISWizardPage::OnWizardNext();
}

void
CFtpWizPath::OnChangeEditPath() 
{
    SetControlStates();
}

static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CFtpWizPath * pThis = (CFtpWizPath *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CFtpWizPath::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}

void
CFtpWizPath::OnButtonBrowse() 
{
   ASSERT(m_pSettings->m_fLocal);

   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Path.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         m_strBrowseTitle.LoadString(m_pSettings->m_fNewSite ? 
            IDS_FTP_NEW_SITE_WIZARD : IDS_FTP_NEW_VDIR_WIZARD);
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strBrowseTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_edit_Path.SetWindowText(str);
       SetControlStates();
   }
}

BOOL
CFtpWizPath::OnInitDialog() 
{
   CIISWizardPage::OnInitDialog();

   m_button_Browse.EnableWindow(m_pSettings->m_fLocal);

   return TRUE;  
}

///////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFtpWizUserName, CIISWizardPage)

CFtpWizUserName::CFtpWizUserName(
    IN OUT CFtpWizSettings * pSettings,    
    IN BOOL bVDir
    ) 
    : CIISWizardPage(
        CFtpWizUserName::IDD,
        (bVDir ? IDS_FTP_NEW_VDIR_WIZARD : IDS_FTP_NEW_SITE_WIZARD),
        HEADER_PAGE,
        (bVDir ? USE_DEFAULT_CAPTION : IDS_FTP_NEW_SITE_SECURITY_TITLE),
        (bVDir ? USE_DEFAULT_CAPTION : IDS_FTP_NEW_SITE_SECURITY_SUBTITLE)
        ),
      m_pSettings(pSettings)
{

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CFtpWizUserName)
    //}}AFX_DATA_INIT

#endif // 0
}

CFtpWizUserName::~CFtpWizUserName()
{
}

void
CFtpWizUserName::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizUserName)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_pSettings->m_strUserName);
    DDV_MaxChars(pDX, m_pSettings->m_strUserName, UNLEN);

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_pSettings->m_strUserName.TrimLeft();
    while (*m_pSettings->m_strUserName == '\\')
    {
        m_pSettings->m_strUserName = m_pSettings->m_strUserName.Mid(2);
    }

    DDX_Password(pDX, IDC_EDIT_PASSWORD, m_pSettings->m_strPassword, g_lpszDummyPassword);
    DDV_MaxChars(pDX, m_pSettings->m_strPassword, PWLEN);
}



void 
CFtpWizUserName::SetControlStates()
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_UserName.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizUserName, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizUserName)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CFtpWizUserName::OnSetActive() 
{
    if (!m_pSettings->m_fUNC)
    {
        return 0;
    }

    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}

BOOL
CFtpWizUserName::OnInitDialog() 
{
    CIISWizardPage::OnInitDialog();
    return TRUE;  
}

LRESULT
CFtpWizUserName::OnWizardNext() 
{
    if (!ValidateString(
        m_edit_UserName, 
        m_pSettings->m_strUserName, 
        1, 
        UNLEN
        ))
    {
        return -1;
    }
    
    return CIISWizardPage::OnWizardNext();
}

void
CFtpWizUserName::OnButtonBrowseUsers() 
{
    CString str;

    if (GetIUsrAccount(m_pSettings->m_strServerName, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}

void
CFtpWizUserName::OnChangeEditUsername() 
{
   m_edit_Password.SetWindowText(_T(""));
   SetControlStates();
}

void 
CFtpWizUserName::OnButtonCheckPassword() 
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(CComAuthInfo::VerifyUserPassword(
        m_pSettings->m_strUserName, 
        m_pSettings->m_strPassword
        ));

    if (!err.MessageBoxOnFailure())
    {
       ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}

///////////////////////////////////////////

IMPLEMENT_DYNCREATE(CFtpWizPermissions, CIISWizardPage)

CFtpWizPermissions::CFtpWizPermissions(
    IN OUT CFtpWizSettings * pSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is a vdir page, 
                                  FALSE if this is an instance page

Return Value:

    None

--*/
    : CIISWizardPage(
        IDD_FTP_NEW_PERMS,
        (bVDir ? IDS_FTP_NEW_VDIR_WIZARD : IDS_FTP_NEW_SITE_WIZARD),
        HEADER_PAGE,
        (bVDir ? USE_DEFAULT_CAPTION : IDS_FTP_NEW_SITE_PERMS_TITLE),
        (bVDir ? USE_DEFAULT_CAPTION : IDS_FTP_NEW_SITE_PERMS_SUBTITLE)
        ),
      m_bVDir(bVDir),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CFtpWizPermissions)
    //}}AFX_DATA_INIT

    m_pSettings->m_fRead  = TRUE;
    m_pSettings->m_fWrite = FALSE;
}

CFtpWizPermissions::~CFtpWizPermissions()
{
}

void
CFtpWizPermissions::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpWizPermissions)
    //}}AFX_DATA_MAP

    DDX_Check(pDX, IDC_CHECK_READ,  m_pSettings->m_fRead);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_pSettings->m_fWrite);
}

void
CFtpWizPermissions::SetControlStates()
{
   SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpWizPermissions, CIISWizardPage)
    //{{AFX_MSG_MAP(CFtpWizPermissions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
CFtpWizPermissions::OnSetActive() 
{
   SetControlStates();
   return CIISWizardPage::OnSetActive();
}

LRESULT
CFtpWizPermissions::OnWizardNext() 
{
    if (!UpdateData(TRUE))
    {
        return -1;
    }

    ASSERT(m_pSettings != NULL);

    CWaitCursor wait;
    CError err;
    BOOL fRepeat;

    //
    // Build permissions DWORD
    //
    DWORD dwPermissions = 0L;

    SET_FLAG_IF(m_pSettings->m_fRead, dwPermissions, MD_ACCESS_READ);
    SET_FLAG_IF(m_pSettings->m_fWrite, dwPermissions, MD_ACCESS_WRITE);

    if (m_bVDir)
    {
        //
        // First see if by any chance this name already exists
        //
        CMetabasePath target(FALSE, 
            m_pSettings->m_strParent, m_pSettings->m_strAlias);
        CChildNodeProps node(
            m_pSettings->m_pKey,
            target);

        do
        {
            fRepeat = FALSE;
            err = node.LoadData();
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);

        if (err.Succeeded())
        {
            BOOL fNotUnique = TRUE;
            //
            // If the item existed without a VrPath, we'll just blow it
            // away, as a vdir takes presedence over a directory/file.
            //
            if (node.GetPath().IsEmpty())
            {
                err = CChildNodeProps::Delete(
                    m_pSettings->m_pKey,
                    m_pSettings->m_strParent,
                    m_pSettings->m_strAlias
                    );
                fNotUnique = !err.Succeeded();
            }
            //
            // This one already exists and exists as a virtual
            // directory, so away with it.
            //
            if (fNotUnique)
            {
                ::AfxMessageBox(IDS_ERR_ALIAS_NOT_UNIQUE);
                return IDD_FTP_NEW_DIR_ALIAS;
            }
        }

        //
        // Create new vdir
        //
        do
        {
            fRepeat = FALSE;
            err = CChildNodeProps::Add(
                m_pSettings->m_pKey,
                m_pSettings->m_strParent,
                m_pSettings->m_strAlias,        // Desired alias name
                m_pSettings->m_strAlias,        // Name returned here (may differ)
                &dwPermissions,                 // Permissions
                NULL,                           // dir browsing
                m_pSettings->m_strPath,         // Physical path of this directory
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strUserName : NULL),
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strPassword : NULL),
                TRUE                            // Name must be unique
                );
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);
    }
    else
    {
        //
        // Create new instance
        //
        do
        {
            fRepeat = FALSE;
            err = CFTPInstanceProps::Add(
                m_pSettings->m_pKey,
                SZ_MBN_FTP,
                m_pSettings->m_strPath,
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strUserName : NULL),
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strPassword : NULL),
                m_pSettings->m_strDescription,
                m_pSettings->m_strBinding,
                NULL,
                &dwPermissions,
                NULL,
                NULL,
                &m_pSettings->m_dwInstance
                );
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);
    }
    m_pSettings->m_hrResult = err;
    
    return CIISWizardPage::OnWizardNext();
}

HRESULT
RebindInterface(
    OUT IN CMetaInterface * pInterface,
    OUT BOOL * pfContinue,
    IN  DWORD dwCancelError
    )
/*++

Routine Description:

    Rebind the interface

Arguments:

    CMetaInterface * pInterface : Interface to rebind
    BOOL * pfContinue           : Returns TRUE to continue.
    DWORD  dwCancelError        : Return code on cancel

Return Value:

    HRESULT

--*/
{
    CError err;
    CString str, strFmt;

    ASSERT(pInterface != NULL);
    ASSERT(pfContinue != NULL);

    VERIFY(strFmt.LoadString(IDS_RECONNECT_WARNING));
    str.Format(strFmt, (LPCTSTR)pInterface->QueryServerName());

    if (*pfContinue = (YesNoMessageBox(str)))
    {
        //
        // Attempt to rebind the handle
        //
        err = pInterface->Regenerate();
    }
    else
    {
        //
        // Do not return an error in this case.
        //
        err = dwCancelError;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fvdir.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fvdir.h

   Abstract:
        FTP Virtual Directory Properties dialog definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __FVDIR_H__
#define __FVDIR_H__



class CFtpDirectoryPage : public CInetPropertyPage
/*++

Class Description:

    FTP Virtual Directory Page.

Public Interface:

    CFtpDirectoryPage    : Constructor
    ~CFtpDirectoryPage   : Destructor

--*/
{
    DECLARE_DYNCREATE(CFtpDirectoryPage)

//
// Construction
//
public:
    CFtpDirectoryPage(
        IN CInetPropertySheet * pSheet = NULL, 
        IN BOOL fHome                  = FALSE
        );

    ~CFtpDirectoryPage();

	int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
//
// Dialog Data
//
protected:
    //
    // Directory Type
    //
    enum
    {
        RADIO_DIRECTORY,
        RADIO_NETDIRECTORY,
    };

    //
    // Unix/DOS radio button values
    //
    enum
    {
        RADIO_UNIX,
        RADIO_DOS,
    };

    //{{AFX_DATA(CFtpDirectoryPage)
    enum { IDD = IDD_FTP_DIRECTORY_PROPERTIES };
    int     m_nUnixDos;
    int     m_nPathType;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fLogAccess;
    CString m_strPath;
    CStatic m_static_PathPrompt;
    CButton m_check_LogAccess;
    CButton m_check_Write;
    CButton m_check_Read;
    CButton m_button_AddPathType;
    CButton m_button_Browse;
    CButton m_radio_Dir;
    CEdit   m_edit_Path;
    //}}AFX_DATA

    BOOL    m_fOriginallyUNC;
    DWORD   m_dwAccessPerms;
    CString m_strAlias;
    CButton m_radio_Unc;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CFtpDirectoryPage)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CFtpDirectoryPage)
    afx_msg void OnButtonBrowse();
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckWrite();
    afx_msg void OnButtonEditPathType();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioUnc();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
    
    void SetStateByType();
    void SetPathType(LPCTSTR lpstrPath);
    void ChangeTypeTo(int nNewType);

    BOOL IsHome() const { return m_fHome; }

private:
    BOOL    m_fHome;
    CString m_strOldPath;
    CString m_strUserName;
    CString m_strPassword;
    CString m_strPathPrompt;
    CString m_strSharePrompt;
	LPTSTR m_pPathTemp;
	CString m_strBrowseTitle;
};

#endif // __FVDIR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\fvdir.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        fvdir.cpp

   Abstract:
        FTP Virtual Directory Properties dialog

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "ftpsht.h"
#include "fvdir.h"
#include "iisobj.h"
#include <lmcons.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// Directory Properties Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CFtpDirectoryPage, CInetPropertyPage)



CFtpDirectoryPage::CFtpDirectoryPage(
    IN CInetPropertySheet * pSheet,
    IN BOOL fHome
    ) 
/*++

Routine Description:

    Constructor for directory property page

Arguments:

    CInetPropertySheet * pSheet : Sheet pointer
    BOOL fHome                  : TRUE if this is a home directory


--*/
    : CInetPropertyPage(CFtpDirectoryPage::IDD, pSheet,
          fHome ? IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY),
      m_fHome(fHome),
      m_fOriginallyUNC(FALSE)
{
    VERIFY(m_strPathPrompt.LoadString(IDS_PATH));
    VERIFY(m_strSharePrompt.LoadString(IDS_SHARE));

#if 0 // Keep Class-wizard happy

    //{{AFX_DATA_INIT(CFtpDirectoryPage)
    m_nPathType = RADIO_DIRECTORY;
    m_nUnixDos = 0;
    m_fRead = FALSE;
    m_fWrite = FALSE;
    m_fLogAccess = FALSE;
    m_strPath = _T("");
    m_strDefaultDocument = _T("");
    m_strFooter = _T("");
    m_fBrowsingAllowed = FALSE;
    m_fEnableDefaultDocument = FALSE;
    m_fEnableFooter = FALSE;
    m_dwAccessPerms = 0;
    //}}AFX_DATA_INIT

#endif // 0

}



CFtpDirectoryPage::~CFtpDirectoryPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CFtpDirectoryPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control Data

Arguments:

    CDataExchange * pDX : DDX/DDV struct

Return Value:

    None.

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CFtpDirectoryPage)
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);
    DDX_Control(pDX, IDC_CHECK_LOG_ACCESS, m_check_LogAccess);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);
    DDX_Control(pDX, IDC_BUTTON_EDIT_PATH_TYPE, m_button_AddPathType);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
    DDX_Control(pDX, IDC_STATIC_PATH, m_static_PathPrompt);
    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
    DDX_Radio(pDX, IDC_RADIO_UNIX, m_nUnixDos);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_RADIO_UNC, m_radio_Unc);
    DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
    m_strPath.TrimLeft();
    DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);

    if (pDX->m_bSaveAndValidate)
    {
        //
        // Make sure a field names are correct
        //
        if (m_nPathType == RADIO_NETDIRECTORY)
        {
            DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
            m_strPath.TrimLeft();
            DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);

            if (!PathIsValid(m_strPath) || !PathIsUNC(m_strPath))
            {
                ::AfxMessageBox(IDS_BAD_UNC_PATH);
                pDX->Fail();
            }

            /*

                ISSUE: Supposedly this is not necessary...


            if (m_strUserName.IsEmpty())
            {
                ::AfxMessageBox(IDS_ERR_NO_USERNAME);
                OnButtonEditPathType();
                pDX->Fail();
            }

            */
        }
        else // Local Directory
        {
            ASSERT(m_nPathType == RADIO_DIRECTORY);

            if (!IsMasterInstance())
            {
                DDV_MinMaxChars(pDX, m_strPath, 1, MAX_PATH);
            }
            else
            {
                if (m_strPath.IsEmpty())
                {
                    //
                    // No additional validation necc. on master
                    // instance.
                    //
                    return;
                }
            }

            if (!PathIsValid(m_strPath) || (PathIsRelative(m_strPath) && !IsDevicePath(m_strPath)))
            {
                ::AfxMessageBox(IDS_ERR_INVALID_PATH);
                pDX->Fail();
            }

            if (IsLocal())
            {
                DWORD dwAttr = GetFileAttributes(m_strPath);
                if (dwAttr == 0xffffffff || (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                    ::AfxMessageBox(IDS_ERR_PATH_NOT_FOUND);
                    pDX->Fail();
                }
            }
        }
    }
    else
    {
        if (!IsMasterInstance())
        {
            DDV_MinMaxChars(pDX, m_strPath, 1, MAX_PATH);
        }
    }
}



void
CFtpDirectoryPage::SetStateByType()
/*++

Routine Description:

    Set the state of the dialog by the path type currently selected

Arguments:

    None

Return Value:

    None

--*/
{
    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        DeActivateControl(m_button_AddPathType);

	    if (IsLocal() && !IsMasterInstance() && HasAdminAccess())
        {
			ActivateControl(m_button_Browse);
        }
		else
        {
			DeActivateControl(m_button_Browse);
        }

        m_static_PathPrompt.SetWindowText(m_strPathPrompt);
        break;

    case RADIO_NETDIRECTORY:
        ActivateControl(m_button_AddPathType);
        DeActivateControl(m_button_Browse);
        m_static_PathPrompt.SetWindowText(m_strSharePrompt);
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
    }
}



void
CFtpDirectoryPage::SetPathType(
    IN LPCTSTR lpstrPath
    )
/*++

Routine Description:

    Set path type from given path

Arguments:

    LPCTSTR lpstrPath       : Path string

Return Value:

    None

--*/
{
    if (PathIsUNC(lpstrPath))
    {
        m_nPathType = RADIO_NETDIRECTORY;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(1);
    }
    else
    {
        m_nPathType =  RADIO_DIRECTORY;
        m_radio_Unc.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }

    SetStateByType();
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CFtpDirectoryPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CFtpDirectoryPage)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_PATH_TYPE, OnButtonEditPathType)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_UNC, OnRadioUnc)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PATH, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_READ, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
    ON_BN_CLICKED(IDC_RADIO_MSDOS, OnItemChanged)
    ON_BN_CLICKED(IDC_RADIO_UNIX, OnItemChanged)

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CFtpDirectoryPage::OnItemChanged()
/*++

Routine Description:

    Handle change in data on the item

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CFtpDirectoryPage * pThis = (CFtpDirectoryPage *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CFtpDirectoryPage::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}

void
CFtpDirectoryPage::OnButtonBrowse() 
/*++

Routine Description:

    "Browse" button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(IsLocal());
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Path.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         m_strBrowseTitle.LoadString(m_fHome ? 
            IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY);
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strBrowseTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
	   m_strPath = str;
       m_edit_Path.SetWindowText(str);
       SetPathType(m_strPath);
       OnItemChanged();
   }
}



BOOL
CFtpDirectoryPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_button_Browse.EnableWindow(
        IsLocal()
     && !IsMasterInstance()
     && HasAdminAccess());

    SetPathType(m_strPath);

    //
    // Directory listing style dependent on whether or not
    // this is a home directory
    //
    ActivateControl(*GetDlgItem(IDC_STATIC_DIRLISTING), m_fHome);
    ActivateControl(*GetDlgItem(IDC_RADIO_UNIX),        m_fHome);
    ActivateControl(*GetDlgItem(IDC_RADIO_MSDOS),       m_fHome);

    //
    // Some items not available on master instance
    //
    GetDlgItem(IDC_STATIC_PATH_TYPE)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_RADIO_DIR)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_RADIO_UNC)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_STATIC_PATH)->EnableWindow(
        !IsMasterInstance());
    GetDlgItem(IDC_EDIT_PATH)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());
    GetDlgItem(IDC_BUTTON_EDIT_PATH_TYPE)->EnableWindow(
        !IsMasterInstance() && HasAdminAccess());

    m_check_Write.EnableWindow(HasAdminAccess());
    m_check_Read.EnableWindow(HasAdminAccess());

    //
    // Store the original value of fUNC of reference later when 
    // saving out --BoydM
    //
    m_fOriginallyUNC = (m_nPathType == RADIO_NETDIRECTORY);

    return TRUE;  
}



void
CFtpDirectoryPage::ChangeTypeTo(
    IN int nNewType
    )
/*++

Routine Description

    Change the directory type

Arguments:

    int nNewType    : New radio value

Return Value:

    None

--*/
{
    int nOldType = m_nPathType;
    m_nPathType = nNewType;

    if (nOldType == m_nPathType)
    {
        //
        // No change
        //
        return;
    }

    OnItemChanged();
    SetStateByType();

    LPCTSTR lpKeepPath = NULL;

    int nID = -1;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        if (!PathIsUNC(m_strPath) 
			&& (!PathIsRelative(m_strPath) || IsDevicePath(m_strPath)))
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath = m_strPath;
        }

        nID = IDS_DIRECTORY_MASK;
        break;

    case RADIO_NETDIRECTORY:
        if (PathIsUNC(m_strPath))
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath = m_strPath;
        }

        nID = IDS_UNC_MASK;
        break;
    }

    if (lpKeepPath != NULL)
    {
        //
        // Restore the old path
        //
        m_edit_Path.SetWindowText(lpKeepPath);
    }
    else
    {
        //
        // Load mask resource, and display
        // this in the directory
        //
        CString str;
        VERIFY(str.LoadString(nID));
        m_edit_Path.SetWindowText(str);
    }

    m_edit_Path.SetSel(0,-1);
    m_edit_Path.SetFocus();
}



void
CFtpDirectoryPage::OnRadioDir() 
/*++

Routine Description:

    'directory' radio button handler

Arguments:

    None

Return Value:

    None.

--*/
{
    ChangeTypeTo(RADIO_DIRECTORY);
}



void
CFtpDirectoryPage::OnRadioUnc() 
/*++

Routine Description:

    'network directory' radio button handler

Arguments:

    None

Return Value:

    None.

--*/
{
    ChangeTypeTo(RADIO_NETDIRECTORY);
}



/* virtual */
HRESULT
CFtpDirectoryPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CFtpSheet)
        //
        // Use 'm_' notation because the message crackers require it.
        //
        BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strAlias);
        FETCH_DIR_DATA_FROM_SHEET(m_strUserName);
        FETCH_DIR_DATA_FROM_SHEET(m_strPassword);
        FETCH_DIR_DATA_FROM_SHEET(m_strPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);

        m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
        m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
        m_fLogAccess = !m_fDontLog;
    END_META_DIR_READ(err)

    BEGIN_META_INST_READ(CFtpSheet)
        BOOL  m_fDosDirOutput;

        FETCH_INST_DATA_FROM_SHEET(m_fDosDirOutput);
        m_nUnixDos = m_fDosDirOutput ? RADIO_DOS : RADIO_UNIX;
    END_META_INST_READ(err)

    m_nPathType = PathIsUNC(m_strPath) ? 
        RADIO_NETDIRECTORY : RADIO_DIRECTORY;

    //
    // Make sure we were passed the right home directory
    // flag
    //
    ASSERT(IsMasterInstance()
        || (m_fHome && !::lstrcmp(m_strAlias, g_cszRoot))
        || (!m_fHome && ::lstrcmp(m_strAlias, g_cszRoot))
        );

    return err;
}



/* virtual */
HRESULT
CFtpDirectoryPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving FTP virtual directory page now...");

    CError err;

    SET_FLAG_IF(m_fRead, m_dwAccessPerms, MD_ACCESS_READ);
    SET_FLAG_IF(m_fWrite, m_dwAccessPerms, MD_ACCESS_WRITE);

    //
    // Use m_ notation because the message crackers require them
    //
    BOOL m_fDontLog = !m_fLogAccess;
    BOOL m_fDosDirOutput = (m_nUnixDos == RADIO_DOS);
    BOOL fUNC = (m_nPathType == RADIO_NETDIRECTORY);
//    BOOL fUserNameWritten = FALSE;

    BeginWaitCursor();
    BEGIN_META_DIR_WRITE(CFtpSheet)
        if (fUNC)      
        {
//            STORE_DIR_DATA_ON_SHEET_REMEMBER(m_strUserName, fUserNameWritten)
//            if (fUserNameWritten)
//            {
                STORE_DIR_DATA_ON_SHEET(m_strUserName);
                STORE_DIR_DATA_ON_SHEET(m_strPassword);
//            }
        }
        else
        {
            if (m_fOriginallyUNC)
            {
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_USERNAME);
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_PASSWORD);
            }
        }
        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_strPath)
    END_META_DIR_WRITE(err)

    if (err.Succeeded())
    {
        BEGIN_META_INST_WRITE(CFtpSheet)
            STORE_INST_DATA_ON_SHEET(m_fDosDirOutput);  
        END_META_INST_WRITE(err)
    }

    if (err.Succeeded())
    {
		NotifyMMC();
    }

    EndWaitCursor();

    return err;
}



void
CFtpDirectoryPage::OnButtonEditPathType() 
/*++

Routine Description:

    'Connect As..." button handler

Arguments:

    None

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CUserAccountDlg dlg(
        QueryServerName(), 
        m_strUserName,
        m_strPassword, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        m_strUserName = dlg.m_strUserName;
        m_strPassword = dlg.m_strPassword;
        OnItemChanged();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\guids.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        guids.h

   Abstract:

        GUIDs as used by IIS snapin definition

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/
#ifndef _GUIDS_H
#define _GUIDS_H

//
// New Clipboard format that has the Type and Cookie
//
extern const wchar_t * ISM_SNAPIN_INTERNAL;

//
// Published context information for extensions to extend
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

extern const wchar_t * MYCOMPUT_MACHINE_NAME;
extern const wchar_t * ISM_SNAPIN_MACHINE_NAME;
extern const wchar_t * ISM_SNAPIN_SERVICE;
extern const wchar_t * ISM_SNAPIN_INSTANCE;
extern const wchar_t * ISM_SNAPIN_PARENT_PATH;
extern const wchar_t * ISM_SNAPIN_NODE;
extern const wchar_t * ISM_SNAPIN_META_PATH;

//
// GUIDS
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Snapin GUID
//
extern const CLSID CLSID_Snapin;                 // In-Proc server GUID
extern const CLSID CLSID_About;                  // About GUID

//
// IIS Object GUIDS
//
extern "C" const GUID cInternetRootNode;             // Internet root node       num
extern "C" const GUID cMachineNode;                  // Machine node             num
extern "C" const GUID cServiceCollectorNode;         // Service Collector node   num
extern "C" const GUID cInstanceCollectorNode;        // Instance Collector node  num
extern "C" const GUID cInstanceNode;                 // Instance node            num
extern "C" const GUID cChildNode;                    // Child node               num
extern "C" const GUID cFileNode;                     // File node                num
extern "C" const GUID cAppPoolsNode;
extern "C" const GUID cAppPoolNode;
extern "C" const GUID cCompMgmtService;

#endif //_GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\guids.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        guids.cpp

   Abstract:

        GUIDs as used by IIS snapin

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

//
// Internal private clipboard format
//
const wchar_t * ISM_SNAPIN_INTERNAL = L"ISM_SNAPIN_INTERNAL";

//
// Published formats
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

const wchar_t * MYCOMPUT_MACHINE_NAME   = L"MMC_SNAPIN_MACHINE_NAME"; 
const wchar_t * ISM_SNAPIN_MACHINE_NAME = L"ISM_SNAPIN_MACHINE_NAME"; 
const wchar_t * ISM_SNAPIN_SERVICE =      L"ISM_SNAPIN_SERVICE";
const wchar_t * ISM_SNAPIN_INSTANCE =     L"ISM_SNAPIN_INSTANCE";
const wchar_t * ISM_SNAPIN_PARENT_PATH =  L"ISM_SNAPIN_PARENT_PATH";
const wchar_t * ISM_SNAPIN_NODE =         L"ISM_SNAPIN_NODE";
const wchar_t * ISM_SNAPIN_META_PATH =    L"ISM_SNAPIN_META_PATH";

//
// GUIDs
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Snapin GUID
//
// {A841B6C2-7577-11d0-BB1F-00A0C922E79C}
//
//const CLSID CLSID_Snapin = {0xa841b6c2, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// About GUID
//
// {A841B6D2-7577-11d0-BB1F-00A0C922E79C}
//
//const CLSID CLSID_About =  {0xa841b6d2, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// IIS Object GUIDS
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Internet Root Node GUID
//
extern "C" const GUID cInternetRootNode 
    = {0xa841b6c3, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Machine Node GUID
//
extern "C" const GUID cMachineNode 
    = {0xa841b6c4, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Service Collector Node GUID
//
extern "C" const GUID cServiceCollectorNode 
    = {0xa841b6c5, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Instance Collector Node GUID
//
extern "C" const GUID cInstanceCollectorNode 
    = {0xa841b6c6, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Instance Node GUID
//
extern "C" const GUID cInstanceNode 
    = {0xa841b6c7, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// Child Node GUID
//
extern "C" const GUID cChildNode 
    = {0xa841b6c8, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// File Node GUID
//
extern "C" const GUID cFileNode 
    = {0xa841b6c9, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// AppPools container Node GUID
//
extern "C" const GUID cAppPoolsNode 
    = {0xa841b6ca, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// AppPool Node GUID
//
extern "C" const GUID cAppPoolNode 
    = {0xa841b6cb, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

//
// CompMgnt node that we are extending
//
extern "C" const GUID cCompMgmtService 
    = {0x476e6449, 0xaaff, 0x11d0, { 0xb9, 0x44, 0x0, 0xc0, 0x4f, 0xd8, 0xd5, 0xb0}};

#include <initguid.h>
#include "iwamreg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\ftpsht.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        ftpsht.h

   Abstract:
        FTP Property sheet definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager (cluster edition)

   Revision History:

--*/


#ifndef __FTPSHT_H__
#define __FTPSHT_H__


#include "shts.h"


#ifndef LOGGING_ENABLED
#define LOGGING_ENABLED
inline BOOL LoggingEnabled(
    IN DWORD dwLogType
    )
{
    return (dwLogType == MD_LOG_TYPE_ENABLED);
}
#endif


#ifndef ENABLE_LOGGING
#define ENABLE_LOGGING
inline void EnableLogging(
    OUT DWORD & dwLogType, 
    IN  BOOL fEnabled = TRUE
    )
{
    dwLogType = fEnabled ? MD_LOG_TYPE_ENABLED : MD_LOG_TYPE_DISABLED;
}
#endif


class CFTPInstanceProps : public CInstanceProps
/*++

Class Description:

    FTP Properties

Public Interface:

    CFTPInstanceProps   : Constructor

--*/
{
public:
    //
    // Constructor
    //
    CFTPInstanceProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Service Page
    //
    MP_CILong        m_nMaxConnections;
    MP_CILong        m_nConnectionTimeOut;
    MP_DWORD         m_dwLogType;

    //
    // Accounts Page
    //
    MP_CString       m_strUserName;
    MP_CString       m_strPassword;
    MP_BOOL          m_fAllowAnonymous;
    MP_BOOL          m_fOnlyAnonymous;
    MP_BOOL          m_fPasswordSync;
    MP_CBlob         m_acl;

    //
    // Message Page
    //
    MP_CString       m_strExitMessage;
    MP_CString       m_strMaxConMsg;
    MP_CStringListEx m_strlWelcome;
    MP_CStringListEx m_strlBanner;

    //
    // Directory Properties Page
    //
    MP_BOOL          m_fDosDirOutput;

    //
    // Default Site page
    //
    MP_DWORD         m_dwDownlevelInstance;
    MP_DWORD         m_dwMaxBandwidth;
};



class CFTPDirProps : public CChildNodeProps
/*++

Class Description:

    FTP Directory properties

Public Interface:

    CFTPDirProps        : Constructor

--*/
{
public:
    CFTPDirProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Directory properties page
    //
    MP_CString     m_strUserName;
    MP_CString     m_strPassword;
    MP_BOOL        m_fDontLog;
    MP_CBlob       m_ipl;
};




class CFtpSheet : public CInetPropertySheet
/*++

Class Description:

    Ftp Property sheet

Public Interface:

    CFtpSheet     : Constructor

    Initialize    : Initialize config data

--*/
{
public:
    //
    // Constructor
    //
    CFtpSheet(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath,
        IN CWnd *  pParentWnd  = NULL,
        IN LPARAM  lParam      = 0L,
        IN LONG_PTR    handle      = 0L,
        IN UINT    iSelectPage = 0
        );

    ~CFtpSheet();

public:
    HRESULT QueryInstanceResult() const;
    HRESULT QueryDirectoryResult() const;
    CFTPInstanceProps & GetInstanceProperties() { return *m_ppropInst; }
    CFTPDirProps & GetDirectoryProperties() { return *m_ppropDir; }

    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();

protected:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    //{{AFX_MSG(CFtpSheet)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    CFTPInstanceProps * m_ppropInst;
    CFTPDirProps      * m_ppropDir;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT CFtpSheet::QueryInstanceResult() const
{
    //
    // BUGBUG: S_OK if object not yet instantiated
    //
    return m_ppropInst ? m_ppropInst->QueryResult() : S_OK;
}

inline HRESULT CFtpSheet::QueryDirectoryResult() const
{
    //
    // BUGBUG: S_OK if object not yet instantiated
    //
    return m_ppropDir ? m_ppropDir->QueryResult() : S_OK;
}



#endif // __FTPSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\hdrdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        hdrdlg.cpp

   Abstract:

        HTTP Headers dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
//#include "fltdlg.h"
#include "hdrdlg.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CHeaderDlg::CHeaderDlg(
    IN LPCTSTR lpstrHeader,
    IN LPCTSTR lpstrValue,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for HTTP heade dialog

Arguments:

    LPCTSTR lpstrHeader     : Header string
    LPCTSTR lpstrValue      : Value string
    CWnd * pParent          : Parent window
    
Return Value:

    None    

--*/
    : CDialog(CHeaderDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CHeaderDlg)
    m_strHeader = lpstrHeader ? lpstrHeader : _T("");
    m_strValue = lpstrValue ? lpstrValue : _T("");
    //}}AFX_DATA_INIT
}



void 
CHeaderDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CHeaderDlg)
    DDX_Control(pDX, IDC_EDIT_HEADER, m_edit_Header);
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Text(pDX, IDC_EDIT_HEADER, m_strHeader);
    DDX_Text(pDX, IDC_EDIT_VALUE, m_strValue);
    //}}AFX_DATA_MAP
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CHeaderDlg, CDialog)
    //{{AFX_MSG_MAP(CHeaderDlg)
    ON_EN_CHANGE(IDC_EDIT_HEADER, OnChangeEditHeader)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CHeaderDlg::OnChangeEditHeader()
/*++

Routine Description:

    change edit handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(m_edit_Header.GetWindowTextLength() > 0);
}



BOOL 
CHeaderDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    OnChangeEditHeader();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\httppage.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        httppage.cpp

   Abstract:

        HTTP Headers property page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrapp.h"
#include "shts.h"
#include "w3sht.h"
#include "resource.h"
#include "fltdlg.h"
#include "hdrdlg.h"
#include "HTTPPage.h"
#include "mime.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/* static */
void
CHeader::CrackDisplayString(
    IN  LPCTSTR lpstrDisplayString,
    OUT CString & strHeader,
    OUT CString & strValue
    )
/*++

Routine Description:

    Crack the display string into component formats

Arguments:

    LPCTSTR lpstrDisplayString  : Input display string
    CString & strHeader         : Header
    CString & strValue          : Value

Return Value:

    N/A

--*/
{
    strHeader = lpstrDisplayString;
    strHeader.TrimLeft();
    strHeader.TrimRight();
    int nColon = strHeader.Find(_T(':'));
    if (nColon >= 0)
    {
        strValue = (lpstrDisplayString + nColon + 1);
        strHeader.ReleaseBuffer(nColon);
    }

    strValue.TrimLeft();
    strValue.TrimRight();
}



//
// HTTP Custom Header Property Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


#define MINUTE              (60L)
#define HOUR                (60L * MINUTE)
#define DAY                 (24L * HOUR)
#define YEAR                (365 * DAY)

#define EXPIRE_IMMEDIATELY  ((LONG)(0L))
#define EXPIRE_INFINITE     ((LONG)(0xffffffff))
#define EXPIRE_DEFAULT      ((LONG)(1L * DAY)) // 1 day
#define DEFAULT_DYN_EXPIRE  (10L * DAY)
#define EXPIRE_MIN_NUMBER   (1)
#define EXPIRE_MAX_NUMBER   (32767)



IMPLEMENT_DYNCREATE(CW3HTTPPage, CInetPropertyPage)



CW3HTTPPage::CW3HTTPPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Property page constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet data

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3HTTPPage::IDD, pSheet),
      m_fValuesAdjusted(FALSE),
      m_ppropMimeTypes(NULL),
      m_tmNow(CTime::GetCurrentTime())
{

#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CW3HTTPPage)
    m_nTimeSelector = -1;
    m_nImmediateTemporary = -1;
    m_fEnableExpiration = FALSE;
    m_nExpiration = 0L;
    m_strlCustomHeaders = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}



CW3HTTPPage::~CW3HTTPPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3HTTPPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3HTTPPage)
    DDX_Control(pDX, IDC_BUTTON_FILE_TYPES, m_button_FileTypes);
    DDX_Radio(pDX, IDC_RADIO_IMMEDIATELY, m_nImmediateTemporary);
    DDX_Check(pDX, IDC_CHECK_EXPIRATION, m_fEnableExpiration);
    DDX_Control(pDX, IDC_EDIT_EXPIRE, m_edit_Expire);
    DDX_Control(pDX, IDC_RADIO_IMMEDIATELY, m_radio_Immediately);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_Delete);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_STATIC_CONTENT_SHOULD, m_static_Contents);
    DDX_Control(pDX, IDC_COMBO_TIME, m_combo_Time);
    //}}AFX_DATA_MAP

    //
    // Only store and validate immediate expiration date if immediate
    // is selected.
    //
    if (!pDX->m_bSaveAndValidate || m_nImmediateTemporary == RADIO_EXPIRE)
    {
        DDX_CBIndex(pDX, IDC_COMBO_TIME, m_nTimeSelector);
        DDX_Text(pDX, IDC_EDIT_EXPIRE, m_nExpiration);
        DDV_MinMaxLong(pDX, m_nExpiration, EXPIRE_MIN_NUMBER, EXPIRE_MAX_NUMBER);
    }

    DDX_Control(pDX, IDC_RADIO_TIME, m_radio_Time);
    DDX_Control(pDX, IDC_RADIO_ABS_TIME, m_radio_AbsTime);
    DDX_Control(pDX, IDC_DTP_ABS_DATE, m_dtpDate);
    DDX_Control(pDX, IDC_DTP_ABS_TIME, m_dtpTime);
    DDX_Control(pDX, IDC_LIST_HEADERS, m_list_Headers);

    if (pDX->m_bSaveAndValidate)
    {
        StoreTime();
        StoreHeaders();
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CW3HTTPPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3HTTPPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_FILE_TYPES, OnButtonFileTypes)
    ON_BN_CLICKED(IDC_BUTTON_RATINGS_TEMPLATE, OnButtonRatingsTemplate)
    ON_BN_CLICKED(IDC_CHECK_EXPIRATION, OnCheckExpiration)
    ON_CBN_SELCHANGE(IDC_COMBO_TIME, OnSelchangeComboTime)
    ON_LBN_SELCHANGE(IDC_LIST_HEADERS, OnSelchangeListHeaders)
    ON_LBN_DBLCLK(IDC_LIST_HEADERS, OnDblclkListHeaders)
    ON_BN_CLICKED(IDC_RADIO_IMMEDIATELY, OnRadioImmediately)
    ON_BN_CLICKED(IDC_RADIO_TIME, OnRadioTime)
    ON_BN_CLICKED(IDC_RADIO_ABS_TIME, OnRadioAbsTime)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_EXPIRE, OnItemChanged)

END_MESSAGE_MAP()



BOOL
AdjustIfEvenMultiple(
    IN OUT CILong & ilValue,
    IN LONG lMultiple
    )
/*++

Routine Description:

    Check to see if ilValue is an even multiple of lMultiple.
    If so, divide ilValue by lMultiple

Arguments:

    CILong & ilValue      : Value
    LONG lMultiple        : Multiple

Return Value:

    TRUE if ilValue is an even multiple of lMultiple.

--*/
{
    DWORD dw = (DWORD)(LONG)ilValue / (DWORD)lMultiple;
    if (dw * (DWORD)lMultiple == (DWORD)(LONG)ilValue)
    {
        ilValue = (LONG)dw;
        return TRUE;
    }

    return FALSE;
}



BOOL
CW3HTTPPage::CrackExpirationString(
    IN CString & strExpiration
    )
/*++

Routine Description:

    Crack the expiration string into component parts.  Using either N or a blank
    string to signify "No expiration"

Arguments:

    None

Return Value:

    return TRUE if the values had to be adjusted because they were out of
    range.

--*/
{
    strExpiration.TrimLeft();
    strExpiration.TrimRight();
    BOOL fValueAdjusted = FALSE;

    m_fEnableExpiration = !strExpiration.IsEmpty();
    LPCTSTR lp = strExpiration;
    BOOL fAbs = FALSE;
    if (m_fEnableExpiration)
    {
        switch(*lp)
        {
        case _T('D'):
        case _T('d'):
            lp += 2;
            while (_istspace(*lp)) ++lp;
            CvtStringToLong(lp, &m_dwRelTime);
            break;

        case _T('S'):
        case _T('s'):
            lp += 2;
            while (_istspace(*lp)) ++lp;
            m_dwRelTime = EXPIRE_DEFAULT;

            time_t tm;
            if (!CvtGMTStringToInternal(lp, &tm))
            {
                ::AfxMessageBox(IDS_ERR_EXPIRE_RANGE, MB_ICONINFORMATION | MB_OK);
                fValueAdjusted = TRUE;
            }

            m_tm = tm;
            fAbs = TRUE;
            break;

        case _T('N'):
        case _T('n'):
            m_fEnableExpiration = FALSE;
            break;

        default:
            TRACEEOLID("Expiration string in bogus format");
            m_fEnableExpiration = FALSE;
        }
    }

    //
    // Set Values:
    //
    m_nExpiration = (LONG)m_dwRelTime;

    m_nImmediateTemporary = fAbs
        ? RADIO_EXPIRE_ABS
        : (m_nExpiration == EXPIRE_IMMEDIATELY)
            ? RADIO_IMMEDIATELY
            : RADIO_EXPIRE;

    //
    // Adjust time
    //
    if (m_nExpiration == EXPIRE_INFINITE
     || m_nExpiration == EXPIRE_IMMEDIATELY)
    {
        m_nExpiration = EXPIRE_DEFAULT;
    }

    if (AdjustIfEvenMultiple(m_nExpiration, DAY))
    {
        m_nTimeSelector = COMBO_DAYS;
    }
    else if (AdjustIfEvenMultiple(m_nExpiration, HOUR))
    {
        m_nTimeSelector = COMBO_HOURS;
    }
    else
    {
        m_nExpiration /= MINUTE;
        m_nExpiration = __max((DWORD)(LONG)m_nExpiration, 1L);
        if (m_nExpiration < EXPIRE_MIN_NUMBER ||
            m_nExpiration > EXPIRE_MAX_NUMBER)
        {
            m_nExpiration = (EXPIRE_DEFAULT / MINUTE);
            ::AfxMessageBox(IDS_ERR_EXPIRE_RANGE, MB_ICONINFORMATION | MB_OK);
        }

        m_nTimeSelector = COMBO_MINUTES;
    }

    return fValueAdjusted;
}



void
CW3HTTPPage::MakeExpirationString(
    OUT CString & strExpiration
    )
/*++

Routine Description:

    Make the expiration string from component parts

Arguments:

    None

Return Value:

    None

--*/
{
    strExpiration.Empty();

    DWORD dwExpiration = m_nExpiration;

    if (m_fEnableExpiration)
    {
        switch(m_nImmediateTemporary)
        {
        case RADIO_IMMEDIATELY:
            strExpiration = _T("D, 0");
            break;

        case RADIO_EXPIRE:
            switch(m_nTimeSelector)
            {
            case COMBO_MINUTES:
                dwExpiration *= MINUTE;
                break;

            case COMBO_HOURS:
                dwExpiration *= HOUR;
                break;

            case COMBO_DAYS:
                dwExpiration *= DAY;
                break;

            default:
                ASSERT(FALSE);
            }

            strExpiration.Format(_T("D, 0x%0x"), dwExpiration);
            break;

        case RADIO_EXPIRE_ABS:
            CvtInternalToGMTString(m_tm.GetTime(), strExpiration);
            strExpiration = _T("S, ") + strExpiration;
            break;

        default:
            TRACEEOLID("Unknown expiration format");
            ASSERT(FALSE);

            return;
        }
    }
}



/* virtual */
HRESULT
CW3HTTPPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    BEGIN_META_DIR_READ(CW3Sheet)
        CString m_strExpiration;

        FETCH_DIR_DATA_FROM_SHEET(m_strExpiration);
        FETCH_DIR_DATA_FROM_SHEET(m_strlCustomHeaders);

        //
        // Set up some defaults.
        //
        m_dwRelTime = EXPIRE_DEFAULT;

        m_tm = CTime(
            m_tmNow.GetYear(),
            m_tmNow.GetMonth(),
            m_tmNow.GetDay(),
            0, 0, 0          // Midnight
            );
        m_tm += DEFAULT_DYN_EXPIRE;

        m_fValuesAdjusted = CrackExpirationString(m_strExpiration);
    END_META_DIR_READ(err)

    //
    // Fetch the properties from the metabase
    //
    ASSERT(m_ppropMimeTypes == NULL);

    CError err;

    m_ppropMimeTypes = new CMimeTypes(
        QueryAuthInfo(),
//        CMetabasePath(g_cszSvc, QueryInstance(), SZ_MBN_ROOT)
		QueryMetaPath()
        );

    if (m_ppropMimeTypes)
    {
        err = m_ppropMimeTypes->LoadData();
        if (err.Succeeded())
        {
            m_strlMimeTypes = m_ppropMimeTypes->m_strlMimeTypes;
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



void
CW3HTTPPage::StoreTime()
/*++

Routine Description:

    Built datetime by combining current date with the time from the time
    controls.

Arguments:

    None

Return Value:

    None

--*/
{
    SYSTEMTIME tmDate, tmTime;

    m_dtpDate.GetTime(&tmDate);
    m_dtpTime.GetTime(&tmTime);

    m_tm = CTime(
        tmDate.wYear,
        tmDate.wMonth,
        tmDate.wDay,
        tmTime.wHour,
        tmTime.wMinute,
        tmTime.wSecond
        );
}



void
CW3HTTPPage::SetTimeFields()
/*++

Routine Description:

    Set time fields from CTime structure

Arguments:

    None

Return Value:

    None

--*/
{
    SYSTEMTIME stm =
    {
        (WORD)m_tm.GetYear(),
        (WORD)m_tm.GetMonth(),
        (WORD)m_tm.GetDayOfWeek(),
        (WORD)m_tm.GetDay(),
        (WORD)m_tm.GetHour(),
        (WORD)m_tm.GetMinute(),
        (WORD)m_tm.GetSecond(),
        0   // Milliseconds
    };

    m_dtpDate.SetTime(&stm);
    m_dtpTime.SetTime(&stm);
}



void
CW3HTTPPage::FillListBox()
/*++

Routine Description:

    Fill the custom headers listbox with the custom headers entries

Arguments:

    None

Return Value:

    None

--*/
{
    CObListIter obli(m_oblHeaders);
    CHeader * pHeader;

    //
    // Remember the selection.
    //
    int nCurSel = m_list_Headers.GetCurSel();

    m_list_Headers.SetRedraw(FALSE);
    m_list_Headers.ResetContent();
    int cItems = 0 ;

    CString strCustom;
    for ( /**/ ; pHeader = (CHeader *)obli.Next() ; cItems++ )
    {
        m_list_Headers.AddString(pHeader->DisplayString(strCustom));
    }

    m_list_Headers.SetRedraw(TRUE);
    m_list_Headers.SetCurSel(nCurSel);
}



BOOL
CW3HTTPPage::SetControlStates()
/*++

Routine Description:

    Set the control enabled/disabled states depending on the state of the
    dialog

Arguments:

    None

Return Value:

    TRUE if an item was selected in the headers listbox, FALSE otherwise.

--*/
{
    BOOL fSingleSelection = m_list_Headers.GetSelCount() == 1;

    m_button_Edit.EnableWindow(fSingleSelection);
    m_button_Delete.EnableWindow(m_list_Headers.GetSelCount() > 0);

    BOOL fExpire = (m_nImmediateTemporary == RADIO_EXPIRE);
    BOOL fExpireAbs = (m_nImmediateTemporary == RADIO_EXPIRE_ABS);

    m_static_Contents.EnableWindow(m_fEnableExpiration);

    m_radio_Immediately.EnableWindow(m_fEnableExpiration);
    m_radio_Time.EnableWindow(m_fEnableExpiration);
    m_radio_AbsTime.EnableWindow(m_fEnableExpiration);

    m_edit_Expire.EnableWindow(m_fEnableExpiration && fExpire);
    m_combo_Time.EnableWindow(m_fEnableExpiration && fExpire);

    m_dtpDate.EnableWindow(m_fEnableExpiration && fExpireAbs);
    m_dtpTime.EnableWindow(m_fEnableExpiration && fExpireAbs);

    return fSingleSelection;
}



void
CW3HTTPPage::FetchHeaders()
/*++

Routine Description:

    Build custom headers oblist

Arguments:

    None

Return Value:

    None

--*/
{
    POSITION pos = m_strlCustomHeaders.GetHeadPosition();

    while(pos)
    {
        CString & str = m_strlCustomHeaders.GetNext(pos);
        m_oblHeaders.AddTail(new CHeader(str));
    }
}



BOOL
CW3HTTPPage::HeaderExists(
    IN LPCTSTR lpHeader
    )
/*++

Routine Description:

    Check to see if a given header exists in the list

Arguments:

    LPCTSTR strHeader   : Header name

Return Value:

    TRUE if the entry exists, FALSE otherwise.

--*/
{
    POSITION pos = m_oblHeaders.GetHeadPosition();
    while(pos)
    {
        CHeader * pHeader = (CHeader *)m_oblHeaders.GetNext(pos);
        ASSERT(pHeader);
        if (!pHeader->GetHeader().CompareNoCase(lpHeader))
        {
            return TRUE;
        }
    }

    return FALSE;
}



void
CW3HTTPPage::StoreHeaders()
/*++

Routine Description:

    Convert the headers oblist to a stringlist

Arguments:

    None

Return Value:

    None

--*/
{
    m_strlCustomHeaders.RemoveAll();

    POSITION pos = m_oblHeaders.GetHeadPosition();
    while(pos)
    {
        CHeader * pHdr = (CHeader *)m_oblHeaders.GetNext(pos);
        ASSERT(pHdr != NULL);

        CString str;
        pHdr->DisplayString(str);
        m_strlCustomHeaders.AddTail(str);
    }
}



INT_PTR
CW3HTTPPage::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit.
    return the value returned by the dialog

Arguments:

    None

Return Value:

    Return value of the dialog (IDOK or IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CHeader * pHeader = NULL;
    LPCTSTR lpstrHeader = NULL;
    LPCTSTR lpstrValue = NULL;
    int nCurSel = LB_ERR;
    INT_PTR nReturn;

    if (!fAdd)
    {
        nCurSel = m_list_Headers.GetCurSel();
        ASSERT(nCurSel != LB_ERR);
        pHeader = (CHeader *)m_oblHeaders.GetAt(m_oblHeaders.FindIndex(nCurSel));
        ASSERT(pHeader != NULL);
        lpstrHeader = pHeader->QueryHeader();
        lpstrValue = pHeader->QueryValue();
    }

    CHeaderDlg dlg(lpstrHeader, lpstrValue, this);
    nReturn = dlg.DoModal();

    if (nReturn == IDOK)
    {
        CString strEntry;

        if (fAdd)
        {
            if (HeaderExists(dlg.GetHeader()))
            {
                ::AfxMessageBox(IDS_ERR_DUP_HEADER);
                return IDCANCEL;
            }

            pHeader = new CHeader(dlg.GetHeader(), dlg.GetValue());
            m_oblHeaders.AddTail(pHeader);
            m_list_Headers.SetCurSel(m_list_Headers.AddString(
                pHeader->DisplayString(strEntry))
                );
        }
        else
        {
            pHeader->SetHeader(dlg.GetHeader());
            pHeader->SetValue(dlg.GetValue());
            m_list_Headers.DeleteString(nCurSel);
            m_list_Headers.InsertString(
                nCurSel, 
                pHeader->DisplayString(strEntry)
                );
            m_list_Headers.SetCurSel(nCurSel);
        }
    }

    return nReturn;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


void
CW3HTTPPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}



void
CW3HTTPPage::OnButtonAdd()
/*++

Routine Description:

    'add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        SetControlStates();
        OnItemChanged();
    }
}



void
CW3HTTPPage::OnButtonDelete()
/*++

Routine Description:

    'delete' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_Headers.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_Headers.GetCount())
    {
        if (m_list_Headers.GetSel(nSel))
        {
            m_oblHeaders.RemoveIndex(nSel);
            m_list_Headers.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_Headers.SetCurSel(nCurSel);
        if (!SetControlStates())
        {
            //
            // Delete button will be disabled, move focus elsewhere
            //
            GetDlgItem(IDC_BUTTON_ADD)->SetFocus();
        }

        OnItemChanged();
    }
}



void
CW3HTTPPage::OnButtonEdit()
/*++

Routine Description:

    'edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        SetControlStates();
        OnItemChanged();
    }
}



void
CW3HTTPPage::OnCheckExpiration()
/*++

Routine Description:

    'expiration' checkbox

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableExpiration = !m_fEnableExpiration;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnSelchangeComboTime()
/*++

Routine Description:

    'selection change' in time combobox handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    OnItemChanged();
}



void 
CW3HTTPPage::OnSelchangeListHeaders()
/*++

Routine Description:

    'selection change' in headers listbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CW3HTTPPage::OnDblclkListHeaders()
/*++

Routine Description:

    'double click' in headers listbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CW3HTTPPage::OnRadioImmediately()
/*++

Routine Description:

    'immediate' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_IMMEDIATELY;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnRadioTime()
/*++

Routine Description:

    'expire' radio button

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_EXPIRE;
    SetControlStates();
    OnItemChanged();
}



void
CW3HTTPPage::OnRadioAbsTime()
/*++

Routine Description:

    'absolute expire' radio button

Arguments:

    None

Return Value:

    None

--*/
{
    m_nImmediateTemporary = RADIO_EXPIRE_ABS;
    SetControlStates();
    OnItemChanged();
}



BOOL
CW3HTTPPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_button_FileTypes.EnableWindow(m_ppropMimeTypes != NULL);
    m_list_Headers.Initialize();

    //
    // Fill combo box with (Minutes, hours, days)
    //
    CString str;
    VERIFY(str.LoadString(IDS_MINUTES));
    m_combo_Time.AddString(str);
    VERIFY(str.LoadString(IDS_HOURS));
    m_combo_Time.AddString(str);
    VERIFY(str.LoadString(IDS_DAYS));
    m_combo_Time.AddString(str);

    m_combo_Time.SetCurSel(m_nTimeSelector);

    //
    // Set the minimum of the date picker to today
    // and the maximum to Dec 31, 2035.
    //
    CTime m_tmNow(CTime::GetCurrentTime());
    CTime tmThen(2035, 12, 31, 23, 59, 59);
    m_dtpDate.SetRange(&m_tmNow, &tmThen);
    //
    // Create a hidden ratings OCX, which is activated by a press
    // on the ratings button.  We never did get our problems with
    // mnemonics straightened out so that we could use the ocx
    // directly.
    //
    m_ocx_Ratings.Create(
        _T("Rat"),
        WS_BORDER,
        CRect(0, 0, 0, 0),
        this,
        IDC_BUTTON_RATINGS
        );

    SetTimeFields();
    FetchHeaders();
    FillListBox();
    SetControlStates();
    m_ocx_Ratings.SetAdminTarget(
        QueryAuthInfo()->QueryServerName(), QueryMetaPath());

    if (m_fValuesAdjusted)
    {
        //
        // One or more input values was adjusted
        //
        OnItemChanged();
        m_fValuesAdjusted = FALSE;
    }

    return TRUE;
}



HRESULT
CW3HTTPPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 HTTP directory page now...");

    CError err;

    CString m_strExpiration;
    MakeExpirationString(m_strExpiration);

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_strExpiration)
        STORE_DIR_DATA_ON_SHEET(m_strlCustomHeaders)
    END_META_DIR_WRITE(err)

    if (err.Succeeded() && m_ppropMimeTypes)
    {
        m_ppropMimeTypes->m_strlMimeTypes = m_strlMimeTypes;
        err = m_ppropMimeTypes->WriteDirtyProps();
		if (err.Succeeded())
		{
			err = ((CW3Sheet *)GetSheet())->SetKeyType();
		}
    }
    EndWaitCursor();

    return err;
}


void
CW3HTTPPage::OnButtonFileTypes()
/*++

Routine Description:

    'file types' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CMimeDlg dlg(m_strlMimeTypes, this);
    if (dlg.DoModal() == IDOK)
    {
        OnItemChanged();
    }
}


void
CW3HTTPPage::OnButtonRatingsTemplate()
/*++

Routine Description:

    Pass on "ratings" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
	// It is possible that Ratings will be changed and will create metabase
	// item without key type -- this is old crappy code.
	// We should fix it here.
	CError err;
	CString mpath = GetSheet()->QueryMetaPath();
	{
		CMetaKey mk(m_ppropMimeTypes->QueryAuthInfo(), METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_READ);
		err = mk.DoesPathExist(mpath);
	}
	BOOL key = err.Failed();
    m_ocx_Ratings.DoClick();
	if (key)
	{
		// User may cancel dialog, and path wasn't created
		CMetaKey mk(m_ppropMimeTypes->QueryAuthInfo(), METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_READ);
		err = mk.DoesPathExist(mpath);
		key = err.Succeeded();
	}
	// This is pretty annoying, but metabase should not be locked to set a key type
	if (key)
	{
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
		ASSERT(err.Succeeded());
	}
}




void 
CW3HTTPPage::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();

    SAFE_DELETE(m_ppropMimeTypes);
}



BOOL 
CW3HTTPPage::OnNotify(
    WPARAM wParam, 
    LPARAM lParam, 
    LRESULT * pResult
    ) 
/*++

Routine Description:

    Handle notification changes

Arguments:

    WPARAM wParam           : Control ID
    LPARAM lParam           : NMHDR *
    LRESULT * pResult       : Result pointer

Return Value:

    TRUE if handled, FALSE if not

--*/
{
    //
    // Message cracker crashes - so checking this here instead
    //
    if (wParam == IDC_DTP_ABS_DATE || wParam == IDC_DTP_ABS_TIME)
    {
        NMHDR * pHdr = (NMHDR *)lParam;
        if (pHdr->code == DTN_DATETIMECHANGE)
        {
            OnItemChanged();
        }
    }
    
    //
    // Default behaviour -- go to the message map
    //
    return CInetPropertyPage::OnNotify(wParam, lParam, pResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\hdrdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        hdrdlg.h

   Abstract:

        HTTP Headers dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __HDRDLG_H__
#define __HDRDLG_H__



class CHeaderDlg : public CDialog
/*++

Class Description:

    HTTP Header dialog

Public Interface:

    CHeaderDlg          : Constructor
    GetHeader           : Get header name
    GetValue            : Get header value

--*/
{
//
// Construction
//
public:
    CHeaderDlg(
        IN LPCTSTR lpstrHeader = NULL,
        IN LPCTSTR lpstrValue  = NULL,
        IN CWnd * pParent      = NULL
        );

//
// Access
//
public:
    CString & GetHeader() { return m_strHeader; }
    CString & GetValue()  { return m_strValue; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CHeaderDlg)
    enum { IDD = IDD_CUSTOM_HEADER };
    CString m_strHeader;
    CString m_strValue;
    CEdit   m_edit_Header;
    CButton m_button_Ok;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CHeaderDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CHeaderDlg)
    afx_msg void OnChangeEditHeader();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#endif // __HDRDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\iisdirectory.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        iisdirectory.cpp

   Abstract:

        IIS Directory node Object

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        10/28/2000      sergeia     Split from iisobj.cpp

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "connects.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "w3sht.h"
#include "wdir.h"
#include "docum.h"
#include "wfile.h"
#include "wsecure.h"
#include "httppage.h"
#include "errors.h"
#include "fltdlg.h"
#include <lm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW


//
// CIISDirectory Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Site Result View definition
//
/* static */ int 
CIISDirectory::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_NAME,
    IDS_RESULT_PATH,
    IDS_RESULT_STATUS,
};
    

/* static */ int 
CIISDirectory::_rgnWidths[COL_TOTAL] =
{
    180,
    200,
	200,
};

#if 0
/* static */ CComBSTR CIISDirectory::_bstrName;
/* static */ CComBSTR CIISDirectory::_bstrPath;
/* static */ BOOL     CIISDirectory::_fStaticsLoaded = FALSE;
#endif

CIISDirectory::CIISDirectory(
    IN CIISMachine * pOwner,
    IN CIISService * pService,
    IN LPCTSTR szNodeName
    )
/*++

Routine Description:

    Constructor which does not resolve all display information at 
    construction time.

Arguments:

    CIISMachine * pOwner        : Owner machine
    CIISService * pService      : Service type
    LPCTSTR szNodeName          : Node name

Return Value:

    N/A

--*/
    : CIISMBNode(pOwner, szNodeName),
      m_pService(pService),
      m_bstrDisplayName(szNodeName),
      m_fResolved(FALSE),
      //
      // Default Data
      //
      m_fEnabledApplication(FALSE),
      m_dwWin32Error(ERROR_SUCCESS)   
{
    ASSERT_PTR(m_pService);
}



CIISDirectory::CIISDirectory(
    CIISMachine * pOwner,
    CIISService * pService,
    LPCTSTR szNodeName,
    BOOL fEnabledApplication,
    DWORD dwWin32Error,
    LPCTSTR strRedirPath
    )
/*++

Routine Description:

    Constructor that takes full information

Arguments:

    CIISMachine * pOwner        : Owner machine
    CIISService * pService      : Service type
    LPCTSTR szNodeName          : Node name

Return Value:

    N/A

--*/
    : CIISMBNode(pOwner, szNodeName),
      m_pService(pService),
      m_bstrDisplayName(szNodeName),
      m_fResolved(TRUE),
      //
      // Data
      //
      m_fEnabledApplication(fEnabledApplication),
      m_dwWin32Error(dwWin32Error)
{
    m_strRedirectPath = strRedirPath;
    ASSERT_PTR(m_pService);
}



/* virtual */
CIISDirectory::~CIISDirectory()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



/* virtual */
HRESULT
CIISDirectory::RefreshData()
/*++

Routine Description:

    Refresh relevant configuration data required for display.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    CWaitCursor wait;
    CComBSTR bstrPath;
    CMetaKey * pKey = NULL;

    do
    {
        ASSERT_PTR(_lpConsoleNameSpace);
        err = BuildMetaPath(bstrPath);
		BREAK_ON_ERR_FAILURE(err)

        BOOL fContinue = TRUE;
        while (fContinue)
        {
            fContinue = FALSE;
            pKey = new CMetaKey(QueryInterface(), bstrPath);

            if (!pKey)
            {
                TRACEEOLID("RefreshData: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            err = pKey->QueryResult();

            if (IsLostInterface(err))
            {
                SAFE_DELETE(pKey);

                fContinue = OnLostInterface(err);
            }
        }
		BREAK_ON_ERR_FAILURE(err)

        CChildNodeProps child(pKey, NULL /*bstrPath*/, WITH_INHERITANCE, FALSE);
        err = child.LoadData();
        if (err.Failed())
        {
            //
            // Filter out the non-fatal errors
            //
            switch(err.Win32Error())
            {
            case ERROR_ACCESS_DENIED:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                err.Reset();
                break;

            default:
                TRACEEOLID("Fatal error occurred " << err);
            }
        }
        if (err.Succeeded())
        {
            m_dwWin32Error = child.QueryWin32Error();
            m_fEnabledApplication = child.IsEnabledApplication();
        }
        else
        {
            m_dwWin32Error = err.Win32Error();
        }
		if (!child.IsRedirected())
		{
			CString dir;
			CString alias;
			if (GetPhysicalPath(bstrPath, alias, dir))
			{
                m_bstrPath = dir;
				if (PathIsUNCServerShare(dir))
				{
					CString server, share;
					int idx = dir.ReverseFind(_T('\\'));
					ASSERT(idx != -1);
					server = dir.Left(idx);
					share = dir.Mid(++idx);
					LPBYTE pbuf = NULL;
					NET_API_STATUS rc = NetShareGetInfo((LPTSTR)(LPCTSTR)server, (LPTSTR)(LPCTSTR)share, 0, &pbuf);
					if (NERR_Success == rc)
					{
						NetApiBufferFree(pbuf);
					}
					else
					{
						m_dwWin32Error = ERROR_BAD_NETPATH;
						break;
					}
				}
				else if (!PathIsDirectory(dir))
				{
					m_dwWin32Error = ERROR_PATH_NOT_FOUND;
					break;
				}
			}
		}
    }
    while(FALSE);

    SAFE_DELETE(pKey);

    if (m_dwWin32Error == ERROR_SUCCESS)
    {
        m_dwWin32Error = err.Win32Error();
    }

    return err;
}



/* virtual */
HRESULT 
CIISDirectory::EnumerateScopePane(HSCOPEITEM hParent)
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    CError err = EnumerateVDirs(hParent, m_pService);
    if (err.Succeeded() && IsWebDir() && m_strRedirectPath.IsEmpty())
    {
        if (m_dwWin32Error == ERROR_SUCCESS)
        {
            err = EnumerateWebDirs(hParent, m_pService);
        }
    }
    if (err.Failed())
    {
        m_dwWin32Error = err.Win32Error();
        RefreshDisplay();
    }
    return err;
}



/* virtual */
int      
CIISDirectory::QueryImage() const
/*++

Routine Description:

    Return bitmap index for the site

Arguments:

    None

Return Value:

    Bitmap index

--*/
{
    ASSERT_PTR(m_pService);
	if (!m_fResolved)
	{
        if (m_hScopeItem == NULL)
        {
            return iError;
        }
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		CIISDirectory * that = (CIISDirectory *)this;
        CError err = that->RefreshData();
        that->m_fResolved = err.Succeeded();
	}
    if (m_dwWin32Error || !m_pService)
    {
        return iError;
    }

    return IsEnabledApplication()
        ? iApplication : m_pService->QueryVDirImage();
}
    
    
void 
CIISDirectory::InitializeChildHeaders(LPHEADERCTRL lpHeader)
{
    CIISDirectory::InitializeHeaders(lpHeader);
}

/* static */
void
CIISDirectory::InitializeHeaders(LPHEADERCTRL lpHeader)
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
//    if (!_fStaticsLoaded)
//    {
//        _fStaticsLoaded =
//            _bstrName.LoadString(IDS_RESULT_NAME)  &&
//            _bstrPath.LoadString(IDS_RESULT_PATH);
//    }
}

/* virtual */
LPOLESTR 
CIISDirectory::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    switch(nCol)
    {
    case COL_ALIAS:
        return QueryDisplayName();

    case COL_PATH:
       if (!m_strRedirectPath.IsEmpty())
       {
           AFX_MANAGE_STATE(::AfxGetStaticModuleState());
           CString buf;
           buf.Format(IDS_REDIRECT_FORMAT, m_strRedirectPath);
           return (LPOLESTR)(LPCTSTR)buf;
       }
       if (m_bstrPath.Length() == 0)
       {
          CComBSTR mp;
          BuildMetaPath(mp);
          CString name, pp;
          GetPhysicalPath(mp, name, pp);
          m_bstrPath = pp;
       }
       return m_bstrPath;

    case COL_STATUS:
       {
          AFX_MANAGE_STATE(::AfxGetStaticModuleState());

          CError err(m_dwWin32Error);

          if (err.Succeeded())
          {
              return OLESTR("");
          }
   
          _bstrResult = err;
          return _bstrResult;
       }
    }
    TRACEEOLID("CIISDirectory: Bad column number" << nCol);
    return OLESTR("");
}

/*virtual*/
HRESULT
CIISDirectory::AddMenuItems(
    LPCONTEXTMENUCALLBACK piCallback,
    long * pInsertionAllowed,
    DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(piCallback);
    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        piCallback,
        pInsertionAllowed,
        type
        );
    if (SUCCEEDED(hr))
    {
       ASSERT(pInsertionAllowed != NULL);
       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
       {
           AddMenuSeparator(piCallback);
           if (IsFtpDir())
           {
              AddMenuItemByCommand(piCallback, IDM_NEW_FTP_VDIR);
           }
           else if (IsWebDir())
           {
              AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR);
           }
       }
       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
       {
           AddMenuSeparator(piCallback);
           AddMenuItemByCommand(piCallback, IDM_TASK_SECURITY_WIZARD);
       }
    }
    return hr;
}

HRESULT
CIISDirectory::InsertNewAlias(CString alias)
{
    CError err;
    // Now we should insert and select this new site
    CIISDirectory * pAlias = new CIISDirectory(m_pOwner, m_pService, alias);
    if (pAlias != NULL)
    {
        // If item is not expanded we will get error and no effect
        if (!IsExpanded())
        {
            SelectScopeItem();
            IConsoleNameSpace2 * pConsole 
                    = (IConsoleNameSpace2 *)GetConsoleNameSpace();
            pConsole->Expand(QueryScopeItem());
        }
        err = pAlias->AddToScopePaneSorted(QueryScopeItem(), FALSE);
        if (err.Succeeded())
        {
            VERIFY(SUCCEEDED(pAlias->SelectScopeItem()));
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    return err;
}

/* virtual */
HRESULT
CIISDirectory::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString alias;

    switch (lCommandID)
    {
    case IDM_NEW_FTP_VDIR:
        if (SUCCEEDED(hr = CIISMBNode::AddFTPVDir(pObj, type, alias)))
        {
            hr = InsertNewAlias(alias);
        }
        break;

    case IDM_NEW_WEB_VDIR:
        if (SUCCEEDED(hr = CIISMBNode::AddWebVDir(pObj, type, alias)))
        {
            hr = InsertNewAlias(alias);
        }
        break;
    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    return hr;
}

/* virtual */
HRESULT
CIISDirectory::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CComBSTR bstrPath;

    //
    // CODEWORK: What to do with m_err?  This might be 
    // a bad machine object in the first place.  Aborting
    // when the machine object has an error code isn't 
    // such a bad solution here.
    //

    /*
    if (m_err.Failed())
    {
        m_err.MessageBox();
        return m_err;
    }
    */

    CError err(BuildMetaPath(bstrPath));

    if (err.Succeeded())
    {
        err = ShowPropertiesDlg(
            lpProvider,
            QueryAuthInfo(), 
            bstrPath,
            GetMainWindow(),
            (LPARAM)this,
            handle
            );
    }

    err.MessageBoxOnFailure();

    return err;
}

///////////////////////////////////////////////////////////////////

CIISFileName::CIISFileName(
      CIISMachine * pOwner,
      CIISService * pService,
      const DWORD dwAttributes,
      LPCTSTR alias,
      LPCTSTR redirect
      )
   : CIISMBNode(pOwner, alias),
     m_dwAttribute(dwAttributes),
     m_pService(pService),
     m_bstrFileName(alias),
     m_RedirectString(redirect),
     m_fEnabledApplication(FALSE),
     m_dwWin32Error(0),
	 m_fResolved(FALSE)
{
}

/* virtual */
LPOLESTR 
CIISFileName::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    switch(nCol)
    {
    case COL_ALIAS:
        return QueryDisplayName();

    case COL_PATH:
		return OLESTR("");

    case COL_STATUS:
        {
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());

            CError err(m_dwWin32Error);

            if (err.Succeeded())
            {
                return OLESTR("");
            }
            _bstrResult = err;
            return _bstrResult;
        }
    }
    TRACEEOLID("CIISFileName: Bad column number" << nCol);
    return OLESTR("");
}

void 
CIISFileName::InitializeChildHeaders(LPHEADERCTRL lpHeader)
{
    CIISDirectory::InitializeHeaders(lpHeader);
}

/* virtual */
HRESULT 
CIISFileName::EnumerateScopePane(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    return EnumerateWebDirs(hParent, m_pService);
}

/* virtual */
int      
CIISFileName::QueryImage() const
{
    ASSERT_PTR(m_pService);
	if (!m_fResolved)
	{
        if (m_hScopeItem == NULL)
        {
            TRACEEOLID("BUGBUG: Prematurely asked for display information");
            return MMC_IMAGECALLBACK;
        }
        //
        // Required for the wait cursor
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
		CIISFileName * that = (CIISFileName *)this;
        CError err = that->RefreshData();
        that->m_fResolved = err.Succeeded();
	}

    if (m_dwWin32Error || !m_pService)
    {
        return iError;
    }

    if (IsDir())
    {
       return IsEnabledApplication() ? iApplication : iFolder;
    }
    return iFile;
}

    
HRESULT
CIISFileName::DeleteNode(IResultData * pResult)
{
    CString path;
    CComBSTR root;
    BuildMetaPath(root);
    CString physPath, alias;
    GetPhysicalPath(CString(root), alias, physPath);
    physPath.TrimRight(_T("/"));

    if (m_pService->IsLocal() || PathIsUNC(physPath))
    {
        //
        // Local directory, or already a unc path
        //
        path = physPath;
    }
    else
    {
        ::MakeUNCPath(path, m_pService->QueryMachineName(), physPath);
    }
    LPTSTR p = path.GetBuffer(MAX_PATH);
    PathRemoveBlanks(p);
    PathRemoveBackslash(p);
    path += _T('\0');

    TRACEEOLID("Attempting to remove file/directory: " << path);

    CWnd * pWnd = AfxGetMainWnd();

    //
    // Attempt to delete using shell APIs
    //
    SHFILEOPSTRUCT sos;
    ZeroMemory(&sos, sizeof(sos));
    sos.hwnd = pWnd ? pWnd->m_hWnd : NULL;
    sos.wFunc = FO_DELETE;
    sos.pFrom = path;
    sos.fFlags = FOF_ALLOWUNDO;

    CError err;
    // Use assignment to avoid conversion and wrong constructor call
    err = ::SHFileOperation(&sos);

    if (err.Succeeded() && !sos.fAnyOperationsAborted)
    {
        CComBSTR p;
        CMetaInterface * pInterface = QueryInterface();
        ASSERT(pInterface != NULL);
        err = BuildMetaPath(p);
        if (err.Succeeded()) 
        {
            CMetaKey mk(pInterface, METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_WRITE);
            if (mk.Succeeded())
            {
                err = mk.DeleteKey(p);
            }
        }
		if (IsDir())
		{
			err = RemoveScopeItem();
		}
		else
		{
			CIISMBNode * pParent = GetParentNode();
			ASSERT(pParent != NULL);
			err = pParent->RemoveResultNode(this, pResult);
		}
    }

    if (err.Failed())
    {
        DisplayError(err);
    }
    path.ReleaseBuffer();
    return err;
}

HRESULT
CIISFileName::RenameItem(LPOLESTR new_name)
{
   if (new_name == NULL || lstrlen(new_name) == 0)
   {
      return S_OK;
   }
   CString pathFrom, pathTo;
   CComBSTR root;
   BuildMetaPath(root);
   CString physPath, alias;
   GetPhysicalPath(CString(root), alias, physPath);
   physPath.TrimRight(_T("/"));

   if (m_pService->IsLocal() || PathIsUNC(physPath))
   {
       //
       // Local directory, or already a unc path
       //
       pathFrom = physPath;
   }
   else
   {
       ::MakeUNCPath(pathFrom, m_pService->QueryMachineName(), physPath);
   }
   LPTSTR p = pathFrom.GetBuffer(MAX_PATH);
   PathRemoveBlanks(p);
   PathRemoveBackslash(p);
   pathFrom.ReleaseBuffer();
   pathFrom += _T('\0');

   pathTo = pathFrom;
   p = pathTo.GetBuffer(MAX_PATH);
   PathRemoveFileSpec(p);
   PathAppend(p, new_name);
   pathTo.ReleaseBuffer();
   pathTo += _T('\0');

   CWnd * pWnd = AfxGetMainWnd();
   //
   // Attempt to delete using shell APIs
   //
   SHFILEOPSTRUCT sos;
   ZeroMemory(&sos, sizeof(sos));
   sos.hwnd = pWnd ? pWnd->m_hWnd : NULL;
   sos.wFunc = FO_RENAME;
   sos.pFrom = pathFrom;
   sos.pTo = pathTo;
   sos.fFlags = FOF_ALLOWUNDO;

   CError err;
   // Use assignment to avoid conversion and wrong constructor call
   err = ::SHFileOperation(&sos);

   if (err.Succeeded() && !sos.fAnyOperationsAborted)
   {
      CComQIPtr<IResultData, &IID_IResultData> lpResultData(_lpConsole);
      m_bstrFileName = new_name;
      err = lpResultData->UpdateItem(m_hResultItem);
	  m_bstrNode = new_name;
   }
   return err;
}

/* virtual */
HRESULT
CIISFileName::RefreshData()
/*++

Routine Description:

    Refresh relevant configuration data required for display.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    CWaitCursor wait;
    CComBSTR bstrPath;
    CMetaKey * pKey = NULL;

    do
    {
        ASSERT_PTR(_lpConsoleNameSpace);
        err = BuildMetaPath(bstrPath);

        if (err.Failed())
        {
            break;
        }

        BOOL fContinue = TRUE;

        while (fContinue)
        {
            fContinue = FALSE;
            pKey = new CMetaKey(QueryInterface(), bstrPath);

            if (!pKey)
            {
                TRACEEOLID("RefreshData: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
			err = pKey->QueryResult();
            if (IsLostInterface(err))
            {
				SAFE_DELETE(pKey);
                fContinue = OnLostInterface(err);
            }
        }

        if (err.Succeeded())
        {
			CChildNodeProps child(pKey, NULL /*bstrPath*/, WITH_INHERITANCE, FALSE);
			err = child.LoadData();
			if (err.Succeeded())
			{
				m_dwWin32Error = child.QueryWin32Error();
				CString buf = child.m_strAppRoot;
				m_fEnabledApplication = (buf.CompareNoCase(bstrPath) == 0);
			}
			else
			{
				m_dwWin32Error = err.Win32Error();
			}
		}

        if (err.Failed())
        {
            //
            // Filter out the non-fatal errors
            //
            switch(err.Win32Error())
            {
            case ERROR_ACCESS_DENIED:
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                err.Reset();
                break;

            default:
                TRACEEOLID("Fatal error occurred " << err);
            }
        }

    }
    while(FALSE);

    SAFE_DELETE(pKey);

    if (SUCCEEDED(m_dwWin32Error))
    {
        m_dwWin32Error = err.Win32Error();
    }

    ASSERT(err.Succeeded());
    return err;
}

/*virtual*/
HRESULT
CIISFileName::AddMenuItems(
    LPCONTEXTMENUCALLBACK piCallback,
    long * pInsertionAllowed,
    DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(piCallback);
    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        piCallback,
        pInsertionAllowed,
        type
        );
    if (SUCCEEDED(hr))
    {
       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
       {
           AddMenuSeparator(piCallback);
           if (lstrcmpi(m_pService->QueryServiceName(), SZ_MBN_FTP) == 0)
           {
              AddMenuItemByCommand(piCallback, IDM_NEW_FTP_VDIR);
           }
           else if (lstrcmpi(m_pService->QueryServiceName(), SZ_MBN_WEB) == 0)
           {
              AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR);
           }
       }
       ASSERT(pInsertionAllowed != NULL);
       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
       {
           AddMenuSeparator(piCallback);
           AddMenuItemByCommand(piCallback, IDM_TASK_SECURITY_WIZARD);
       }
    }
    return hr;
}


/* virtual */
HRESULT
CIISFileName::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    CString alias;

    switch (lCommandID)
    {
    case IDM_NEW_FTP_VDIR:
        if (SUCCEEDED(hr = CIISMBNode::AddFTPVDir(pObj, type, alias)))
        {
            hr = InsertNewAlias(alias);
        }
        break;

    case IDM_NEW_WEB_VDIR:
        if (SUCCEEDED(hr = CIISMBNode::AddWebVDir(pObj, type, alias)))
        {
            hr = InsertNewAlias(alias);
        }
        break;

	case IDM_BROWSE:
		if (m_hResultItem != 0)
		{
			BuildURL(m_bstrURL);
			if (m_bstrURL.Length())
			{
			   ShellExecute(GetMainWindow()->m_hWnd, _T("open"), m_bstrURL, NULL, NULL, SW_SHOWNORMAL);
			}
		}
		else
		{
			hr = CIISMBNode::Command(lCommandID, pObj, type);
		}
        break;

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT
CIISFileName::InsertNewAlias(CString alias)
{
    CError err;
    // Now we should insert and select this new site
    CIISDirectory * pAlias = new CIISDirectory(m_pOwner, m_pService, alias);
    if (pAlias != NULL)
    {
        // If item is not expanded we will get error and no effect
        if (!IsExpanded())
        {
            SelectScopeItem();
            IConsoleNameSpace2 * pConsole 
                    = (IConsoleNameSpace2 *)GetConsoleNameSpace();
            pConsole->Expand(QueryScopeItem());
        }
        err = pAlias->AddToScopePaneSorted(QueryScopeItem(), FALSE);
        if (err.Succeeded())
        {
            VERIFY(SUCCEEDED(pAlias->SelectScopeItem()));
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    return err;
}

/* virtual */
HRESULT
CIISFileName::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CComBSTR bstrPath;
    CError err(BuildMetaPath(bstrPath));

    if (err.Succeeded())
    {
        if (IsDir())
        {
            err = ShowDirPropertiesDlg(
                lpProvider,
                QueryAuthInfo(), 
                bstrPath,
                GetMainWindow(),
                (LPARAM)this,
                handle
                );
        }
        else
        {
            err = ShowFilePropertiesDlg(
                lpProvider,
                QueryAuthInfo(), 
                bstrPath,
                GetMainWindow(),
                (LPARAM)this,
                handle
                );
        }
    }

    err.MessageBoxOnFailure();

    return err;
}

HRESULT
CIISFileName::ShowDirPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM  lParam,
    LONG_PTR handle
    )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    ASSERT_PTR(lpProvider);

    CError err;

    CW3Sheet * pSheet = new CW3Sheet(
        pAuthInfo,
        lpszMDPath,
        0, 
        pMainWnd,
        lParam,
        handle
        );

    if (pSheet)
    {
        pSheet->SetModeless();

        //
        // Add file pages
        //
        pSheet->SetSheetType(pSheet->SHEET_TYPE_DIR);
        err = AddMMCPage(lpProvider, new CW3DirPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3DocumentsPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, FALSE, FILE_ATTRIBUTE_DIRECTORY));
        err = AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));

    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}

HRESULT
CIISFileName::ShowFilePropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM  lParam,
    LONG_PTR handle
    )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    ASSERT_PTR(lpProvider);

    CError err;

    CW3Sheet * pSheet = new CW3Sheet(
        pAuthInfo,
        lpszMDPath,
        0, 
        pMainWnd,
        lParam,
        handle
        );

    if (pSheet)
    {
        pSheet->SetModeless();
        //
        // Add file pages
        //
        pSheet->SetSheetType(pSheet->SHEET_TYPE_FILE);
        err = AddMMCPage(lpProvider, new CW3FilePage(pSheet));
        err = AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, FALSE, 0));
        err = AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));

    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}

HRESULT
CIISFileName::OnPropertyChange(BOOL fScope, IResultData * pResult)
{
	CError err;
	// We cannot change anything visible in file
	if (IsDir())
	{
		// We cannot change path, therefore we don't need to reenumerate
		err = Refresh(FALSE);
	}
	return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\httppage.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        httppage.h

   Abstract:

        HTTP Headers property page definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __HTTPPAGE_H__
#define __HTTPPAGE_H__



//{{AFX_INCLUDES()
#include "rat.h"
//}}AFX_INCLUDES



class CHeader : public CObjectPlus
/*++

Class Description:

    HTTP Header definition

Public Interface:

    CHeader               : Constructor
    DisplayString         : Build display string
    CrackDisplayString    : Convert from crack display string

--*/
{
//
// Constructor
//
public:
    CHeader(
        IN LPCTSTR lpstrHeader, 
        IN LPCTSTR lpstrValue
        );

    //
    // Parse header info from name:value string
    //
    CHeader(LPCTSTR lpstrDisplayString);

//
// Access
//
public:
    LPCTSTR QueryHeader() const { return m_strHeader; }
    LPCTSTR QueryValue() const { return m_strValue; }
    CString & GetHeader() { return m_strHeader;}
    CString & GetValue() { return m_strValue; }
    void SetHeader(LPCTSTR lpszHeader);
    void SetValue(LPCTSTR lpszValue);

//
// Interface:
public:
    //
    // Build output display string
    //
    LPCTSTR DisplayString(OUT CString & str);

protected:
    //
    // Parse the display string into fields
    //
    static void CrackDisplayString(
        IN  LPCTSTR lpstrDisplayString,
        OUT CString & strHeader,
        OUT CString & strValue
        );

private:
    CString m_strHeader;
    CString m_strValue;
};



class CW3HTTPPage : public CInetPropertyPage
/*++

Class Description:

    HTTP Custom Headers property page

Public Interface:

    CW3HTTPPage     : Constructor

--*/
{
    DECLARE_DYNCREATE(CW3HTTPPage)

//
// Construction
//
public:
    CW3HTTPPage(IN CInetPropertySheet * pSheet = NULL);
    ~CW3HTTPPage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_IMMEDIATELY,
        RADIO_EXPIRE,
        RADIO_EXPIRE_ABS,
    };

    enum
    {
        COMBO_MINUTES,
        COMBO_HOURS,
        COMBO_DAYS,
    };

    //{{AFX_DATA(CW3HTTPPage)
    enum { IDD = IDD_DIRECTORY_HTTP };
    int         m_nTimeSelector;
    int         m_nImmediateTemporary;
    BOOL        m_fEnableExpiration;
    CEdit       m_edit_Expire;
    CButton     m_radio_Immediately;
    CButton     m_button_Delete;
    CButton     m_button_Edit;
    CButton     m_button_PickDate;
    CButton     m_button_FileTypes;
    CStatic     m_static_Contents;
    CComboBox   m_combo_Time;
    //}}AFX_DATA

    DWORD           m_dwRelTime;
    CILong          m_nExpiration;
    CTime           m_tm;
    CTime           m_tmNow;
    CRat            m_ocx_Ratings;
    CButton         m_radio_Time;
    CButton         m_radio_AbsTime;
    CDateTimeCtrl   m_dtpDate;
    CDateTimeCtrl   m_dtpTime;
    CRMCListBox     m_list_Headers;
    CStringListEx   m_strlCustomHeaders;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3HTTPPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3HTTPPage)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonDelete();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonFileTypes();
    afx_msg void OnButtonRatingsTemplate();
    afx_msg void OnCheckExpiration();
    afx_msg void OnSelchangeComboTime();
    afx_msg void OnSelchangeListHeaders();
    afx_msg void OnDblclkListHeaders();
    afx_msg void OnRadioImmediately();
    afx_msg void OnRadioTime();
    afx_msg void OnRadioAbsTime();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void    SetTimeFields();
    void    FillListBox();
    void    FetchHeaders();
    void    StoreTime();
    void    StoreHeaders();
    void    MakeExpirationString(CString & strExpiration);
    BOOL    SetControlStates();
    BOOL    CrackExpirationString(CString & strExpiration);
    BOOL    HeaderExists(LPCTSTR lpHeader);
    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    LPCTSTR QueryMetaPath();

private:
    BOOL          m_fValuesAdjusted;
    CStringListEx m_strlMimeTypes;
    CObListPlus   m_oblHeaders;
    CMimeTypes *  m_ppropMimeTypes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CHeader::CHeader(
    IN LPCTSTR lpstrHeader, 
    IN LPCTSTR lpstrValue
    )
    : m_strHeader(lpstrHeader),
      m_strValue(lpstrValue)
{
}

inline CHeader::CHeader(
    IN LPCTSTR lpstrDisplayString
    )
{
    CrackDisplayString(lpstrDisplayString, m_strHeader, m_strValue);
}

inline LPCTSTR CHeader::DisplayString(
    OUT CString & str
    )
{
    str.Format(_T("%s: %s"), (LPCTSTR)m_strHeader, (LPCTSTR)m_strValue);
    return str;
}

inline void CHeader::SetHeader(
    IN LPCTSTR lpszHeader
    )
{
    m_strHeader = lpszHeader;
}

inline void CHeader::SetValue(
    IN LPCTSTR lpszValue
    )
{
    m_strValue = lpszValue;
}

inline LPCTSTR CW3HTTPPage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().QueryMetaRoot();
}

#endif // __HTTPPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\iisobj.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        iisobj.cpp

   Abstract:

        IIS Object

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "connects.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "w3sht.h"
#include "fltdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//
// CInetMgrComponentData
//
static const GUID CInetMgrGUID_NODETYPE 
    = {0xa841b6c2, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//BOOL CIISObject::m_fIsExtension = FALSE;

#define TB_COLORMASK        RGB(192,192,192)    // Lt. Gray



LPOLESTR
CoTaskDupString(
    IN LPCOLESTR szString
    )
/*++

Routine Description:

    Helper function to duplicate a OLESTR

Arguments:

    LPOLESTR szString       : Source string

Return Value:

    Pointer to the new string or NULL

--*/
{
    OLECHAR * lpString = (OLECHAR *)CoTaskMemAlloc(
        sizeof(OLECHAR)*(lstrlen(szString) + 1)
        );

    if (lpString != NULL)
    {
        lstrcpy(lpString, szString);
    }

    return lpString;
}

const GUID *    CIISObject::m_NODETYPE = &CLSID_InetMgr; //&CInetMgrGUID_NODETYPE;
const OLECHAR * CIISObject::m_SZNODETYPE = OLESTR("A841B6C2-7577-11d0-BB1F-00A0C922E79C");
const CLSID *   CIISObject::m_SNAPIN_CLASSID = &CLSID_InetMgr;


//
// Backup/restore taskpad gif resource
//
#define RES_TASKPAD_BACKUP          _T("/img\\backup.gif")



//
// CIISObject implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Important!  The array indices below must ALWAYS be one
// less than the menu ID -- keep in sync with enumeration
// in iisobj.h!!!!
//
/* static */ CIISObject::CONTEXTMENUITEM_RC CIISObject::_menuItemDefs[] = 
{
    //
    // Menu Commands in toolbar order
    //
    //nNameID                           nStatusID                           nDescriptionID               lCmdID                    lInsertionPointID                  fSpecialFlags
    //                                                                                                                                                                   lpszMouseOverBitmap   lpszMouseOffBitmap
    { IDS_MENU_CONNECT,                 IDS_MENU_TT_CONNECT,                -1,                          IDM_CONNECT,              CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_DISCOVER,                IDS_MENU_TT_DISCOVER,               -1,                          IDM_DISCOVER,             CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_START,                   IDS_MENU_TT_START,                  -1,                          IDM_START,                CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_STOP,                    IDS_MENU_TT_STOP,                   -1,                          IDM_STOP,                 CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_PAUSE,                   IDS_MENU_TT_PAUSE,                  -1,                          IDM_PAUSE,                CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    //
    // These are menu commands that do not show up in the toolbar
    //
    { IDS_MENU_EXPLORE,                 IDS_MENU_TT_EXPLORE,                -1,                          IDM_EXPLORE,              CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_OPEN,                    IDS_MENU_TT_OPEN,                   -1,                          IDM_OPEN,                 CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_BROWSE,                  IDS_MENU_TT_BROWSE,                 -1,                          IDM_BROWSE,               CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_RECYCLE,                 IDS_MENU_TT_RECYCLE,                -1,                          IDM_RECYCLE,              CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },

#if defined(_DEBUG) || DBG
    { IDS_MENU_IMPERSONATE,             IDS_MENU_TT_IMPERSONATE,            -1,                          IDM_IMPERSONATE,          CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_REM_IMPERS,              IDS_MENU_TT_REM_IMPERS,             -1,                          IDM_REMOVE_IMPERSONATION, CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
#endif // _DEBUG

    { IDS_MENU_PROPERTIES,              IDS_MENU_TT_PROPERTIES,             -1,                          IDM_CONFIGURE,            CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_DISCONNECT,              IDS_MENU_TT_DISCONNECT,             -1,                          IDM_DISCONNECT,           CCM_INSERTIONPOINTID_PRIMARY_TOP,  0, NULL,                 NULL,                 },
    { IDS_MENU_BACKUP,                  IDS_MENU_TT_BACKUP,                 IDS_MENU_TT_BACKUP,          IDM_METABACKREST,         CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, NULL,                 NULL,                 },
    { IDS_MENU_SHUTDOWN_IIS,            IDS_MENU_TT_SHUTDOWN_IIS,           -1,                          IDM_SHUTDOWN,             CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, NULL,                 NULL,                 },

    { IDS_MENU_NEWVROOT,                IDS_MENU_TT_NEWVROOT,               IDS_MENU_DS_NEWVROOT,        IDM_NEW_VROOT,            CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWVROOT, RES_TASKPAD_NEWVROOT, },
    { IDS_MENU_NEWINSTANCE,             IDS_MENU_TT_NEWINSTANCE,            IDS_MENU_DS_NEWINSTANCE,     IDM_NEW_INSTANCE,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  },
    { IDS_MENU_NEWFTPSITE,              IDS_MENU_TT_NEWFTPSITE,             IDS_MENU_DS_NEWFTPSITE,      IDM_NEW_FTP_SITE,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  },
    { IDS_MENU_NEWFTPVDIR,              IDS_MENU_TT_NEWFTPVDIR,             IDS_MENU_DS_NEWFTPVDIR,      IDM_NEW_FTP_VDIR,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  },
    { IDS_MENU_NEWWEBSITE,              IDS_MENU_TT_NEWWEBSITE,             IDS_MENU_DS_NEWWEBSITE,      IDM_NEW_WEB_SITE,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  },
    { IDS_MENU_NEWWEBVDIR,              IDS_MENU_TT_NEWWEBVDIR,             IDS_MENU_DS_NEWWEBVDIR,      IDM_NEW_WEB_VDIR,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  },
    { IDS_MENU_NEWAPPPOOL,              IDS_MENU_TT_NEWAPPPOOL,             IDS_MENU_DS_NEWAPPPOOL,      IDM_NEW_APP_POOL,         CCM_INSERTIONPOINTID_PRIMARY_NEW,  0, RES_TASKPAD_NEWSITE,  RES_TASKPAD_NEWSITE,  },
    { IDS_MENU_TASKPAD,                 IDS_MENU_TT_TASKPAD,                -1,                          IDM_VIEW_TASKPAD,         CCM_INSERTIONPOINTID_PRIMARY_VIEW, 0, NULL,                 NULL,                 },
    { IDS_MENU_SECURITY_WIZARD,         IDS_MENU_TT_SECURITY_WIZARD,        IDS_MENU_TT_SECURITY_WIZARD, IDM_TASK_SECURITY_WIZARD, CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, RES_TASKPAD_SECWIZ,   RES_TASKPAD_SECWIZ,   },             
};



//
// Image background colour for the toolbar buttons
//
#define RGB_BK_IMAGES (RGB(255,0,255))      // purple
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))



//
// Toolbar Definition.  String IDs for menu and tooltip 
// text will be resolved at initialization.  The _SnapinButtons
// button text and tooltips text will be loaded from the _SnapinButtonIDs
// below, and should be kept in sync
//

/* static */ UINT CIISObject::_SnapinButtonIDs[] =
{
    /* IDM_CONNECT   */ IDS_MENU_CONNECT,   IDS_MENU_TT_CONNECT,
 // /* IDM_DISCOVER  */ IDS_MENU_DISCOVER,  IDS_MENU_TT_CONNECT,
    /* IDM_START     */ IDS_MENU_START,     IDS_MENU_TT_START,
    /* IDM_STOP      */ IDS_MENU_STOP,      IDS_MENU_TT_STOP,
    /* IDM_PAUSE     */ IDS_MENU_PAUSE,     IDS_MENU_TT_PAUSE,
};

/* static */ MMCBUTTON CIISObject::_SnapinButtons[] =
{
    { IDM_CONNECT    - 1, IDM_CONNECT,    TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
 // { IDM_DISCOVER   - 1, IDM_DISCOVER,   TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
    { 0,                  0,              TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),  _T("") },

    { IDM_START      - 1, IDM_START,      TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
    { IDM_STOP       - 1, IDM_STOP,       TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
    { IDM_PAUSE      - 1, IDM_PAUSE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, NULL,     NULL },
    { 0,                  0,              TBSTATE_ENABLED, TBSTYLE_SEP,    _T(" "),  _T("") },

    //
    // Add-on tools come here
    //
};



#define NUM_BUTTONS (ARRAYLEN(CIISObject::_SnapinButtons))
#define NUM_BITMAPS (5)



/* static */ CComBSTR CIISObject::_bstrResult;
/* static */ CComBSTR CIISObject::_bstrLocalHost = _T("localhost");
/* static */ HBITMAP  CIISObject::_hImage16 = NULL;
/* static */ HBITMAP  CIISObject::_hImage32 = NULL;
/* static */ HBITMAP  CIISObject::_hToolBar = NULL;
/* static */ CComPtr<IConsoleNameSpace> CIISObject::_lpConsoleNameSpace = NULL;
/* static */ CComPtr<IConsole>          CIISObject::_lpConsole          = NULL;
/* static */ CComPtr<IControlbar>       CIISObject::_lpControlBar       = NULL;
/* static */ CComPtr<IToolbar>          CIISObject::_lpToolBar          = NULL;



/* static */
HRESULT
CIISObject::Initialize()
/*++

Routine Description:

    Initialize static objects.  Called once during lifetime of the snap-in.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Initialize only once
    //
   if (_hImage16 != NULL || _hImage32 != NULL || _hToolBar != NULL)
   {
      return S_OK;
   }
//    ASSERT(_hImage16 == NULL);
//    ASSERT(_hImage32 == NULL);
//    ASSERT(_hToolBar == NULL);

    _hImage16 = ::LoadBitmap(
        _Module.GetResourceInstance(), 
        MAKEINTRESOURCE(IDB_INETMGR16)
        );

    _hImage32 = ::LoadBitmap(
        _Module.GetResourceInstance(), 
        MAKEINTRESOURCE(IDB_INETMGR32)
        );

    _hToolBar = ::LoadBitmap(
        _Module.GetResourceInstance(), 
        MAKEINTRESOURCE(IDB_TOOLBAR)
        );

    if (!_hImage16 || !_hImage32 || !_hToolBar)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Resolve tool tips texts
    //
    CComBSTR bstr;
    CString  str;

    int j = 0;
    for (int i = 0; i < NUM_BUTTONS; ++i)
    {
        if (_SnapinButtons[i].idCommand != 0)
        {
            VERIFY(bstr.LoadString(_SnapinButtonIDs[j++]));
            VERIFY(bstr.LoadString(_SnapinButtonIDs[j++]));

            _SnapinButtons[i].lpButtonText = AllocString(bstr);
            _SnapinButtons[i].lpTooltipText = AllocString(bstr);
        }
    }

    return S_OK;
}



/* static */
HRESULT
CIISObject::Destroy()
/*++

Routine Description:

    Destroy static objects.  Called when the snap-in is shut down

Routine Description:

    None

Return Value:

    HRESULT

--*/
{
    SAFE_DELETE_OBJECT(_hImage16);
    SAFE_DELETE_OBJECT(_hImage32);
    SAFE_DELETE_OBJECT(_hToolBar);

    for (int i = 0; i < NUM_BUTTONS; ++i)
    {
        if (_SnapinButtons[i].idCommand != 0)
        {
            SAFE_FREEMEM(_SnapinButtons[i].lpButtonText);
            SAFE_FREEMEM(_SnapinButtons[i].lpTooltipText);
        }
    }

    return S_OK;
}



/* static */
HRESULT
CIISObject::SetImageList(
    IN LPIMAGELIST lpImageList
    )
/*++

Routine Description:

    Set the image list

Arguments:

    LPIMAGELIST lpImageList

Return Value:

    HRESULT

--*/
{
    ASSERT(_hImage16 != NULL);
    ASSERT(_hImage32 != NULL);

    if (lpImageList->ImageListSetStrip(
        (LONG_PTR *)_hImage16, 
        (LONG_PTR *)_hImage32, 
        0, 
        RGB_BK_IMAGES
        ) != S_OK)
    {
        TRACEEOLID("IImageList::ImageListSetStrip failed");
        return E_UNEXPECTED;
    }

    return S_OK;
}



/* static */ 
HRESULT
CIISObject::AttachScopeView(
    IN LPUNKNOWN lpUnknown
    )
/*++

Routine Description:

    Cache interfaces to the scope view.

Arguments:

    IN LPUNKNOWN lpUnknown      : IUnknown

Return Value:

    HRESULT

--*/
{
    ASSERT(_lpConsoleNameSpace == NULL); // BUGBUG: Fires on opening another console file
    ASSERT(_lpConsole == NULL);          // BUGBUG: Fires on opening another console file 
    ASSERT_PTR(lpUnknown);

    HRESULT hr = E_UNEXPECTED;

    do
    {
        //
        // Query the interfaces for console name space and console
        //
        CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> 
            lpConsoleNameSpace(lpUnknown);

        if (!lpConsoleNameSpace)
        {
            break;
        }

        CComQIPtr<IConsole, &IID_IConsole> lpConsole(lpConsoleNameSpace);

        if (!lpConsole)
        {
            break;
        }

        //
        // Cache the interfaces
        //
        _lpConsoleNameSpace = lpConsoleNameSpace;
        _lpConsole = lpConsole;

        hr = S_OK;
    }
    while(FALSE);

    return hr;
}



/* static */
void
CIISObject::BuildResultView(
    IN LPHEADERCTRL lpHeader,
    IN int cColumns,
    IN int * pnIDS,
    IN int * pnWidths
    )
/*++

Routine Description:

    Build the result view columns.

Routine Description:

    LPHEADERCTRL lpHeader   : Header control
    int cColumns            : Number of columns
    int * pnIDS             : Array of column header strings
    int * pnWidths          : Array of column widths

Routine Description:

    None

--*/
{
    ASSERT_READ_PTR(lpHeader);

    CComBSTR bstr;

    for (int n = 0; n < cColumns; ++n)
    {
        VERIFY(bstr.LoadString(pnIDS[n]));
        lpHeader->InsertColumn(n, bstr, LVCFMT_LEFT, pnWidths[n]);
    }
}



/* static */
CWnd * 
CIISObject::GetMainWindow()
/*++

Routine Description:

    Get a pointer to main window object.

Arguments:

    None

Return Value:

    Pointer to main window object.  This object is temporary and should not be
    cached.

--*/
{
    HWND hWnd;
    CWnd * pWnd = NULL;

    ASSERT_PTR(_lpConsole);

    HRESULT hr = _lpConsole->GetMainWindow(&hWnd);

    if (SUCCEEDED(hr))
    {
        pWnd = CWnd::FromHandle(hWnd);
    }
  
    return pWnd;
}



/* static */
HRESULT
CIISObject::__SetControlbar(
    IN LPCONTROLBAR         lpControlBar,           
    IN LPEXTENDCONTROLBAR   lpExtendControlBar
    )
/*++

Routine Description:

    Initialize or remove the toolbar.

Arguments:

    LPCONTROLBAR         lpControlBar           : Control bar or NULL
    LPEXTENDCONTROLBAR   lpExtendControlBar     : ExtendControlBar class

Return Value:

    HRESULT

--*/
{
    //
    // Cache the control bar
    //
    HRESULT hr = S_OK;

    if (lpControlBar)
    {
        if (_lpControlBar)
        {
            _lpControlBar.Release();
        }

        _lpControlBar = lpControlBar;

        do
        {
            //
            // Create our toolbar
            //
            hr = _lpControlBar->Create(
                TOOLBAR, 
                lpExtendControlBar, 
                (LPUNKNOWN *)&_lpToolBar
                );

            if (FAILED(hr))
            {
                break;
            }

            //
            // Add 16x16 bitmaps
            //
            hr = _lpToolBar->AddBitmap(
                NUM_BITMAPS,
                _hToolBar,
                16,
                16,
                TB_COLORMASK
                );

            if (FAILED(hr))
            {
                break;
            }

            //
            // Add the buttons to the toolbar
            //
            hr = _lpToolBar->AddButtons(NUM_BUTTONS, _SnapinButtons);
        }
        while(FALSE);
    }
    else
    {
        //
        // Release existing controlbar
        //
        _lpControlBar.Release();
    }

    return hr;
}



/* static */
HRESULT
CIISObject::AddMMCPage(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CPropertyPage * pPage
    )
/*++

Routine Description:

    Add MMC page to providers sheet.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Property sheet provider
    CPropertyPage * pPage               : Property page to add

Return:

    HRESULT

--*/
{
    ASSERT_READ_PTR(pPage);

    if (pPage == NULL)
    {
        TRACEEOLID("NULL page pointer passed to AddMMCPage");
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    PROPSHEETPAGE_LATEST pspLatest;
	ZeroMemory(&pspLatest, sizeof(PROPSHEETPAGE_LATEST));
    CopyMemory (&pspLatest, &pPage->m_psp, pPage->m_psp.dwSize);
    pspLatest.dwSize = sizeof(pspLatest);
    //
    // MFC Bug work-around.
    //
    MMCPropPageCallback(&pspLatest);

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pspLatest);
    if (hPage == NULL)
    {
        return E_UNEXPECTED;
    }

    return lpProvider->AddPage(hPage);
}



CIISObject::CIISObject()
    : m_hScopeItem(NULL),
    m_hResultItem(0),
	m_fSkipEnumResult(FALSE)
{
	m_fIsExtension = FALSE;
}

CIISObject::~CIISObject()
{
}

/* virtual */
HRESULT
CIISObject::ControlbarNotify(
    IN MMC_NOTIFY_TYPE event,
    IN LPARAM arg, 
    IN LPARAM param
    )
/*++

Routine Description:

    Handle control bar notification messages, such as select or click.

Arguments:

    MMC_NOTIFY_TYPE event       : Notification message
    long arg                    : Message specific argument
    long param                  : Message specific parameter

Return Value:

    HRESULT

--*/
{
    BOOL fSelect = (BOOL)HIWORD(arg);
    BOOL fScope  = (BOOL)LOWORD(arg); 
    HRESULT hr = S_OK;

    switch(event)
    {
    case MMCN_SELECT:
        //
        // Handle selection of this node by attaching the toolbar
        // and enabling/disabling specific buttons
        //
        ASSERT_PTR(_lpToolBar);
        ASSERT_PTR(_lpControlBar);
        hr = _lpControlBar->Attach(TOOLBAR, _lpToolBar);
        if (SUCCEEDED(hr))
        {
            SetToolBarStates();
        }
        break;

    case MMCN_BTN_CLICK:
        //
        // Handle button-click by passing the command ID of the 
        // button to the command handler
        //
        hr = Command((long)param, NULL, fScope ? CCT_SCOPE : CCT_RESULT);
        break;

    case MMCN_HELP:
        break;

    default:
        ASSERT_MSG("Invalid control bar notification received");
    };

    return hr;
}



/* virtual */
HRESULT
CIISObject::SetToolBarStates()
/*++

Routine Description:

    Set the toolbar states depending on the state of this object

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if (_lpToolBar)
    {
        _lpToolBar->SetButtonState(IDM_CONNECT, ENABLED,       IsConnectable());
        _lpToolBar->SetButtonState(IDM_PAUSE,   ENABLED,       IsPausable());
        _lpToolBar->SetButtonState(IDM_START,   ENABLED,       IsStartable());
        _lpToolBar->SetButtonState(IDM_STOP,    ENABLED,       IsStoppable());
        _lpToolBar->SetButtonState(IDM_PAUSE,   BUTTONPRESSED, IsPaused());
    }

    return S_OK;
}



HRESULT 
CIISObject::GetScopePaneInfo(
    IN OUT LPSCOPEDATAITEM lpScopeDataItem
    )
/*++

Routine Description:

    Return information about scope pane.

Arguments:

    LPSCOPEDATAITEM lpScopeDataItem  : Scope data item

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_WRITE_PTR(lpScopeDataItem);

    if (lpScopeDataItem->mask & SDI_STR)
    {
        lpScopeDataItem->displayname = QueryDisplayName();
    }

    if (lpScopeDataItem->mask & SDI_IMAGE)
    {
        lpScopeDataItem->nImage = QueryImage();
    }

    if (lpScopeDataItem->mask & SDI_OPENIMAGE)
    {
        lpScopeDataItem->nOpenImage = QueryImage();
    }

    if (lpScopeDataItem->mask & SDI_PARAM)
    {
        lpScopeDataItem->lParam = (LPARAM)this;
    }

    if (lpScopeDataItem->mask & SDI_STATE)
    {
        //
        // BUGBUG: Wotz all this then?
        //
        ASSERT_MSG("State requested");
        lpScopeDataItem->nState = 0;
    }

    //
    // TODO : Add code for SDI_CHILDREN 
    //
    return S_OK;
}



/* virtual */
int 
CIISObject::CompareScopeItem(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Standard comparison method to compare lexically on display name.
    Derived classes should override if anything other than lexical 
    sort on the display name is required.

Arguments:

    CIISObject * pObject : Object to compare against

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Else sort lexically on the display name.
    //
    return ::lstrcmpi(QueryDisplayName(), pObject->QueryDisplayName());
}



/* virtual */
int 
CIISObject::CompareResultPaneItem(
    IN CIISObject * pObject, 
    IN int nCol
    )
/*++

Routine Description:

    Compare two CIISObjects on sort item criteria

Arguments:

    CIISObject * pObject : Object to compare against
    int nCol             : Column number to sort on

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    if (nCol == 0)
    {
        return CompareScopeItem(pObject);
    }

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Sort lexically on column text
    //
    return ::lstrcmpi(
        GetResultPaneColInfo(nCol), 
        pObject->GetResultPaneColInfo(nCol)
        );
}



HRESULT 
CIISObject::GetResultPaneInfo(LPRESULTDATAITEM lpResultDataItem)
/*++

Routine Description:

    Get information about result pane item

Arguments:

    LPRESULTDATAITEM lpResultDataItem   : Result data item

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_WRITE_PTR(lpResultDataItem);

    if (lpResultDataItem->bScopeItem)
    {
        if (lpResultDataItem->mask & RDI_STR)
        {
            lpResultDataItem->str = GetResultPaneColInfo(lpResultDataItem->nCol);
        }

        if (lpResultDataItem->mask & RDI_IMAGE)
        {
            lpResultDataItem->nImage = QueryImage();
        }

        if (lpResultDataItem->mask & RDI_PARAM)
        {
            lpResultDataItem->lParam = (LPARAM)this;
        }

        return S_OK;
    }

    if (lpResultDataItem->mask & RDI_STR)
    {
        lpResultDataItem->str = GetResultPaneColInfo(lpResultDataItem->nCol);
    }

    if (lpResultDataItem->mask & RDI_IMAGE)
    {
        lpResultDataItem->nImage = QueryImage();
    }

    if (lpResultDataItem->mask & RDI_PARAM)
    {
        lpResultDataItem->lParam = (LPARAM)this;
    }

    if (lpResultDataItem->mask & RDI_INDEX)
    {
        //
        // BUGBUG: Wotz all this then?
        //
        ASSERT_MSG("INDEX???");
        lpResultDataItem->nIndex = 0;
    }

    return S_OK;
}



/* virtual */
LPOLESTR 
CIISObject::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    if (nCol == 0)
    {
        return QueryDisplayName();
    }

    ASSERT_MSG("Override GetResultPaneColInfo");

    return OLESTR("Override GetResultPaneColInfo");
}



/* virtual */
HRESULT
CIISObject::GetResultViewType(
    OUT LPOLESTR * lplpViewType,
    OUT long * lpViewOptions
    )
/*++

Routine Description:

    Tell MMC what our result view looks like

Arguments:

    BSTR * lplpViewType   : Return view type here
    long * lpViewOptions  : View options

Return Value:

    S_FALSE to use default view type, S_OK indicates the
    view type is returned in *ppViewType

--*/
{
    *lplpViewType  = NULL;
    *lpViewOptions = MMC_VIEW_OPTIONS_USEFONTLINKING;

    //
    // Default View
    //
    return S_FALSE;
}



/* virtual */
HRESULT
CIISObject::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT

--*/
{
    //
    // No Pages
    //
    return S_OK;
}



/* virtual */
HRESULT    
CIISObject::QueryPagesFor(
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Check to see if a property sheet should be brought up for this data
    object

Arguments:

    DATA_OBJECT_TYPES type      : Data object type

Return Value:

    S_OK, if properties may be brought up for this item, S_FALSE otherwise

--*/
{
    return IsConfigurable() ? S_OK : S_FALSE;
}



/* virtual */
CIISRoot * 
CIISObject::GetRoot()
/*++

Routine Description:

    Get the CIISRoot object of this tree.

Arguments:

    None

Return Value:

    CIISRoot * or NULL

--*/
{
    ASSERT(!m_fIsExtension);
    LONG_PTR cookie;
    HSCOPEITEM hParent;    

    ASSERT_PTR(_lpConsoleNameSpace);

    HRESULT hr = _lpConsoleNameSpace->GetParentItem(m_hScopeItem, &hParent, &cookie);
    if (SUCCEEDED(hr))
    {
        CIISMBNode * pNode = (CIISMBNode *)cookie;
        ASSERT_PTR(pNode);
        ASSERT_PTR(hParent);

        if (pNode)
        {
            return pNode->GetRoot();
        }
    }

    ASSERT_MSG("Unable to find CIISRoot object!");

    return NULL;
}



HRESULT
CIISObject::AskForAndAddMachine()
/*++

Routine Description:

    Ask user to add a computer name, verify the computer is alive, and add it to 
    the list.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ConnectServerDlg dlg(GetMainWindow());

    if (dlg.DoModal() == IDOK)
    {
        CIISMachine * pMachine = dlg.GetMachine();

        //
        // The machine object we get from the dialog
        // is guaranteed to be good and valid.
        //
        ASSERT_PTR(pMachine);
        ASSERT(pMachine->HasInterface());

        CIISRoot * pRoot = GetRoot();

        if (pRoot)
        {
            //
            // Add new machine object as child of the IIS root
            // object.  
            //
            if (pRoot->m_scServers.Add(pMachine))
            {
                err = pMachine->AddToScopePaneSorted(pRoot->QueryScopeItem());

                if (err.Succeeded())
                {
                    //
                    // Select the item in the scope view
                    //
                    err = pMachine->SelectScopeItem();
                }
            }
            else
            {
                //
                // Duplicate machine already in cache.  Find it and select
                // it.
                //
                TRACEEOLID("Machine already in scope view.");

                CIISObject * pIdentical = pRoot->FindIdenticalScopePaneItem(
                    pMachine
                    );

                //
                // Duplicate must exist!
                //
                ASSERT_READ_PTR(pIdentical);

                if (pIdentical)
                {
                    err = pIdentical->SelectScopeItem();
                }

                delete pMachine;
            }
        }
    }

    return err;
}



/* static */
HRESULT
CIISObject::AddMenuItemByCommand(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN LONG lCmdID,
    IN LONG fFlags
    )
/*++

Routine Description:

    Add menu item by command

Arguments:

    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Callback pointer
    LONG lCmdID                                 : Command ID
    LONG fFlags                                 : Flags

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Offset 1 menu commands
    //
    LONG l = lCmdID -1;

    CComBSTR strName;
    CComBSTR strStatus;

    VERIFY(strName.LoadString(_menuItemDefs[l].nNameID));
    VERIFY(strStatus.LoadString(_menuItemDefs[l].nStatusID));

    CONTEXTMENUITEM cmi;
    cmi.strName = strName;
    cmi.strStatusBarText = strStatus;
    cmi.lCommandID = _menuItemDefs[l].lCmdID;
    cmi.lInsertionPointID = _menuItemDefs[l].lInsertionPointID;
    cmi.fFlags = fFlags;
    cmi.fSpecialFlags = _menuItemDefs[l].fSpecialFlags;

    return lpContextMenuCallback->AddItem(&cmi);
}



/* static */ 
HRESULT 
CIISObject::AddMenuSeparator(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN LONG lInsertionPointID
    )
/*++

Routine Description:

    Add a separator to the given insertion point menu.

Arguments:
    
    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Callback pointer
    LONG lInsertionPointID                      : Insertion point menu id.

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    CONTEXTMENUITEM menuSep = 
    {
        NULL,
        NULL,
        -1,
        lInsertionPointID,
        0,
        CCM_SPECIAL_SEPARATOR
    };

    return lpContextMenuCallback->AddItem(&menuSep);
}



BOOL 
CIISObject::IsExpanded() const
/*++

Routine Description:

    Determine if this object has been expanded.

Arguments:

    None

Return Value:

    TRUE if the node has been expanded,
    FALSE if it has not.

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace != NULL);
    ASSERT(m_hScopeItem != NULL);

    SCOPEDATAITEM  scopeDataItem;

    ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
    scopeDataItem.mask = SDI_STATE;
        
    scopeDataItem.ID = m_hScopeItem;
    
    HRESULT hr = _lpConsoleNameSpace->GetItem(&scopeDataItem);

    return SUCCEEDED(hr) && 
        scopeDataItem.nState == MMC_SCOPE_ITEM_STATE_EXPANDEDONCE;
}


CIISObject *
CIISObject::FindIdenticalScopePaneItem(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Find CIISObject in the scope view.  The scope view is assumed
    to be sorted.

Arguments:

    CIISObject * pObject    : Item to search for

Return Value:

    Pointer to iis object, or NULL if the item was not found

Notes:

    Note that any item with a 0 comparison value is returned, not
    necessarily the identical CIISObject.

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace);
    ASSERT(m_hScopeItem != NULL);

    //
    // Find proper insertion point
    //
    HSCOPEITEM hChildItem = NULL;
    CIISObject * pReturn = NULL;
    CIISObject * pItem;
    LONG_PTR cookie;
    int  nSwitch;

    HRESULT hr = _lpConsoleNameSpace->GetChildItem(
        m_hScopeItem, &hChildItem, &cookie);

    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        ASSERT_PTR(pItem);

        nSwitch = pItem->CompareScopeItem(pObject);

        if (nSwitch == 0)
        {
            //
            // Found it.
            //
            pReturn = pItem;
        }

        if (nSwitch > 0)
        {
            //
            // Should have found it by now.
            //
            break;
        }

        //
        // Advance to next child of same parent
        //
        hr = _lpConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
    }

    return pReturn;
}



/* virtual */
HRESULT
CIISObject::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Add menu items to the context menu

Arguments:

    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Context menu callback
    long * pInsertionAllowed                    : Insertion allowed
    DATA_OBJECT_TYPES type                      : Object type

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    ASSERT(pInsertionAllowed != NULL);
    if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0)
	{
		if (IsConnectable() && !m_fIsExtension)
		{
			AddMenuItemByCommand(lpContextMenuCallback, IDM_CONNECT);
		}

		if (IsDisconnectable() && !m_fIsExtension)
		{
			ASSERT(IsConnectable());
			AddMenuItemByCommand(lpContextMenuCallback, IDM_DISCONNECT);    
		}

		if (IsExplorable())
		{
			AddMenuSeparator(lpContextMenuCallback);
			AddMenuItemByCommand(lpContextMenuCallback, IDM_EXPLORE);
		}
               
		if (IsOpenable())
		{
			AddMenuItemByCommand(lpContextMenuCallback, IDM_OPEN);
		}

		if (IsBrowsable())
		{
			AddMenuItemByCommand(lpContextMenuCallback, IDM_BROWSE);
		}

		if (IsControllable())
		{
			AddMenuSeparator(lpContextMenuCallback);

			UINT nPauseFlags = IsPausable() ? 0 : MF_GRAYED;

			if (IsPaused())
			{
				nPauseFlags |= MF_CHECKED;
			}

			AddMenuItemByCommand(lpContextMenuCallback, IDM_START,  IsStartable() ? 0 : MF_GRAYED);
			AddMenuItemByCommand(lpContextMenuCallback, IDM_STOP,   IsStoppable() ? 0 : MF_GRAYED);
			AddMenuItemByCommand(lpContextMenuCallback, IDM_PAUSE,  nPauseFlags);
		}
	}
    return S_OK;
}



/* virtual */
HRESULT
CIISObject::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * lpObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * lpObj   : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    switch (lCommandID)
    {
    case IDM_CONNECT:
        hr = AskForAndAddMachine();
        break;
    }

    return hr;
}


#if defined(_DEBUG) || DBG

LPCTSTR
ParseEvent(MMC_NOTIFY_TYPE event)
{
    LPCTSTR p = NULL;
    switch (event)
    {
    case MMCN_ACTIVATE: p = _T("MMCN_ACTIVATE"); break;
    case MMCN_ADD_IMAGES: p = _T("MMCN_ADD_IMAGES"); break;
    case MMCN_BTN_CLICK: p = _T("MMCN_BTN_CLICK"); break;
    case MMCN_CLICK: p = _T("MMCN_CLICK"); break;
    case MMCN_COLUMN_CLICK: p = _T("MMCN_COLUMN_CLICK"); break;
    case MMCN_CONTEXTMENU: p = _T("MMCN_CONTEXTMENU"); break;
    case MMCN_CUTORMOVE: p = _T("MMCN_CUTORMOVE"); break;
    case MMCN_DBLCLICK: p = _T("MMCN_DBLCLICK"); break;
    case MMCN_DELETE: p = _T("MMCN_DELETE"); break;
    case MMCN_DESELECT_ALL: p = _T("MMCN_DESELECT_ALL"); break;
    case MMCN_EXPAND: p = _T("MMCN_EXPAND"); break;
    case MMCN_HELP: p = _T("MMCN_HELP"); break;
    case MMCN_MENU_BTNCLICK: p = _T("MMCN_MENU_BTNCLICK"); break;
    case MMCN_MINIMIZED: p = _T("MMCN_MINIMIZED"); break;
    case MMCN_PASTE: p = _T("MMCN_PASTE"); break;
    case MMCN_PROPERTY_CHANGE: p = _T("MMCN_PROPERTY_CHANGE"); break;
    case MMCN_QUERY_PASTE: p = _T("MMCN_QUERY_PASTE"); break;
    case MMCN_REFRESH: p = _T("MMCN_REFRESH"); break;
    case MMCN_REMOVE_CHILDREN: p = _T("MMCN_REMOVE_CHILDREN"); break;
    case MMCN_RENAME: p = _T("MMCN_RENAME"); break;
    case MMCN_SELECT: p = _T("MMCN_SELECT"); break;
    case MMCN_SHOW: p = _T("MMCN_SHOW"); break;
    case MMCN_VIEW_CHANGE: p = _T("MMCN_VIEW_CHANGE"); break;
    case MMCN_SNAPINHELP: p = _T("MMCN_SNAPINHELP"); break;
    case MMCN_CONTEXTHELP: p = _T("MMCN_CONTEXTHELP"); break;
    case MMCN_INITOCX: p = _T("MMCN_INITOCX"); break;
    case MMCN_FILTER_CHANGE: p = _T("MMCN_FILTER_CHANGE"); break;
    case MMCN_FILTERBTN_CLICK: p = _T("MMCN_FILTERBTN_CLICK"); break;
    case MMCN_RESTORE_VIEW: p = _T("MMCN_RESTORE_VIEW"); break;
    case MMCN_PRINT: p = _T("MMCN_PRINT"); break;
    case MMCN_PRELOAD: p = _T("MMCN_PRELOAD"); break;
    case MMCN_LISTPAD: p = _T("MMCN_LISTPAD"); break;
    case MMCN_EXPANDSYNC: p = _T("MMCN_EXPANDSYNC"); break;
    case MMCN_COLUMNS_CHANGED: p = _T("MMCN_COLUMNS_CHANGED"); break;
    case MMCN_CANPASTE_OUTOFPROC: p = _T("MMCN_CANPASTE_OUTOFPROC"); break;
    default: p = _T("Unknown"); break;
    }
    return p;
}

#endif

HRESULT 
CIISObject::Notify(
    IN MMC_NOTIFY_TYPE event,
    IN LPARAM arg,
    IN LPARAM param,
    IN IComponentData * lpComponentData,
    IN IComponent * lpComponent,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Notification handler

Arguments:

    MMC_NOTIFY_TYPE event               : Notification type
    long arg                            : Event-specific argument
    long param                          : Event-specific parameter
    IComponentData * pComponentData     : IComponentData
    IComponent * pComponent             : IComponent
    DATA_OBJECT_TYPES type              : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    
    CError err(E_NOTIMPL);
    ASSERT(lpComponentData != NULL || lpComponent != NULL);

//   CComPtr<IConsole> lpConsole;
    IConsole * lpConsole;
    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> lpHeader;
    CComQIPtr<IResultData, &IID_IResultData> lpResultData;

    if (lpComponentData != NULL)
    {
        lpConsole = ((CInetMgr *)lpComponentData)->m_spConsole;
    }
    else
    {
        lpConsole = ((CInetMgrComponent *)lpComponent)->m_spConsole;
    }

	lpHeader = lpConsole;
	lpResultData = lpConsole;

    switch (event)
    {
    case MMCN_PROPERTY_CHANGE:
	    err = OnPropertyChange((BOOL)arg, lpResultData);
	    break;
    case MMCN_SHOW:
		if (m_fSkipEnumResult)
		{
			m_fSkipEnumResult = FALSE;
		}
		else
		{
			err = EnumerateResultPane((BOOL)arg, lpHeader, lpResultData);
            if (err.Failed())
            {
                // Fail code will prevent MMC from enabling verbs
                err.Reset();
            }
		}
        break;
    case MMCN_EXPAND:
    {
        CWaitCursor wait;
        err = EnumerateScopePane((HSCOPEITEM)param);
    }
        break;
    case MMCN_ADD_IMAGES:
        err = AddImages((LPIMAGELIST)arg);
        break;
    case MMCN_DELETE:
	    err = DeleteNode(lpResultData);
        break;
    
    case MMCN_REMOVE_CHILDREN:
        err = DeleteChildObjects((HSCOPEITEM)arg);
        break;

    case MMCN_VIEW_CHANGE:
        TRACEEOL("MMCN_VIEW_CHANGE arg " << arg << " param " << param);
    case MMCN_REFRESH:
        // Refresh current node, and re-enumerate
        // child nodes of the child nodes had previously
        // been expanded.
        //
        err = Refresh(!IsLeafNode() && IsExpanded());
	    if (err.Succeeded() && HasResultItems())
	    {
            err = CleanResult(lpResultData);
			if (err.Succeeded())
			{
				err = EnumerateResultPane(TRUE, lpHeader, lpResultData);
			}
		}
        break;

    case MMCN_SELECT:
        {
			//
			// Item has been selected -- set verb states
			//
			ASSERT_PTR(lpConsole);
			CComPtr<IConsoleVerb> lpConsoleVerb;
			lpConsole->QueryConsoleVerb(&lpConsoleVerb);
			ASSERT_PTR(lpConsoleVerb);

			if (lpConsoleVerb)
			{
				err = SetStandardVerbs(lpConsoleVerb);
			}
        }
        break;
    case MMCN_RENAME:
       err = RenameItem((LPOLESTR)param);
       break;
    case MMCN_DBLCLICK:
       err = SelectScopeItem();
       break;
	case MMCN_COLUMNS_CHANGED:
	   err = ChangeVisibleColumns((MMC_VISIBLE_COLUMNS *)param);
	   break;
    }

//    TRACEEOLID("CIISObject::Notify -> " << ParseEvent(event) << " error " << err);

    return err;
}



HRESULT
CIISObject::AddToScopePane(
    IN HSCOPEITEM hRelativeID,
    IN BOOL       fChild,
    IN BOOL       fNext,
    IN BOOL       fIsParent
    )
/*++

Routine Description:

    Add current object to console namespace.  Either as the last child
    of a parent item, or right before/after sibling item

Arguments:

    HSCOPEITEM hRelativeID      : Relative scope ID (either parent or sibling)
    BOOL       fChild           : If TRUE, object will be added as child of 
                                  hRelativeID
    BOOL       fNext            : If fChild is TRUE, this parameter is ignored
                                  If fChild is FALSE, and fNext is TRUE,
                                    object will be added before hRelativeID
                                  If fChild is FALSE, and fNext is FALSE,
                                    object will be added after hRelativeID
    BOOL       fIsParent        : If TRUE, it will add the [+] to indicate
                                  that this node may have childnodes.

Return Value

    HRESULT

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace);

    DWORD dwMask = fChild ? SDI_PARENT : fNext ? SDI_NEXT : SDI_PREVIOUS; 

    SCOPEDATAITEM  scopeDataItem;

    ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
    scopeDataItem.mask = 
		SDI_STR | SDI_IMAGE | SDI_CHILDREN | SDI_OPENIMAGE | SDI_PARAM | dwMask;
    scopeDataItem.displayname = MMC_CALLBACK;
    scopeDataItem.nImage = scopeDataItem.nOpenImage = MMC_IMAGECALLBACK;//QueryImage();
    scopeDataItem.lParam = (LPARAM)this;
    scopeDataItem.relativeID = hRelativeID;
    scopeDataItem.cChildren = fIsParent ? 1 : 0;

    HRESULT hr = _lpConsoleNameSpace->InsertItem(&scopeDataItem);

    if (SUCCEEDED(hr))
    {
        //
        // Cache the scope item handle
        //
        ASSERT(m_hScopeItem == NULL);
        m_hScopeItem = scopeDataItem.ID;
		// BUGBUG: looks like MMC_IMAGECALLBACK doesn't work in InsertItem. Update it here.
		scopeDataItem.mask = 
			SDI_IMAGE | SDI_OPENIMAGE;
		_lpConsoleNameSpace->SetItem(&scopeDataItem);
    }

    return hr;
}



HRESULT
CIISObject::AddToScopePaneSorted(
    IN HSCOPEITEM hParent,
    IN BOOL       fIsParent
    )
/*++

Routine Description:

    Add current object to console namespace, sorted in its proper location.

Arguments:

    HSCOPEITEM hParent          : Parent object
    BOOL       fIsParent        : If TRUE, it will add the [+] to indicate
                                  that this node may have childnodes.


Return Value

    HRESULT

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace);

    //
    // Find proper insertion point
    //
    BOOL       fChild = TRUE;
    HSCOPEITEM hChildItem = NULL;
    CIISObject * pItem;
    LONG_PTR   cookie;
    int        nSwitch;

    HRESULT hr = _lpConsoleNameSpace->GetChildItem(hParent, &hChildItem, &cookie);

    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        ASSERT_PTR(pItem);

        nSwitch = CompareScopeItem(pItem);

        //
        // Dups should be weeded out by now.
        //
        ASSERT(nSwitch != 0);

        if (nSwitch < 0)
        {
            //
            // Insert before this item
            //
            fChild = FALSE;
            break;
        }

        //
        // Advance to next child of same parent
        //
        hr = _lpConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
    }

    return AddToScopePane(hChildItem ? hChildItem : hParent, fChild, fIsParent);
}



/* virtual */
HRESULT 
CIISObject::RemoveScopeItem()
/*++

Routine Description:

    Remove the current item from the scope view.  This method is virtual
    to allow derived classes to do cleanup.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace);
    ASSERT(m_hScopeItem != NULL);

    return _lpConsoleNameSpace->DeleteItem(m_hScopeItem, TRUE);
}

HRESULT
CIISObject::ChangeVisibleColumns(MMC_VISIBLE_COLUMNS * pCol)
{
	return S_OK;
}


HRESULT 
CIISObject::SelectScopeItem()
/*++

Routine Description:

    Select this item in the scope view.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace);
    ASSERT_PTR(_lpConsole);
    ASSERT(m_hScopeItem != NULL);

    return _lpConsole->SelectScopeItem(m_hScopeItem);
}



HRESULT 
CIISObject::SetCookie()
/*++

Routine Description:

    Store the cookie (a pointer to the current CIISObject) in the 
    scope view object associated with it.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace);
    ASSERT(m_hScopeItem != NULL);

    SCOPEDATAITEM  scopeDataItem;

    ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
    scopeDataItem.mask = SDI_PARAM;
        
    scopeDataItem.ID = m_hScopeItem;
    scopeDataItem.lParam = (LPARAM)this;
    
    return _lpConsoleNameSpace->SetItem(&scopeDataItem);
}



HRESULT
CIISObject::RefreshDisplay()
/*++

Routine Description:

    Refresh the display parameters of the current node.  

Arguments:

    None

Return Value

    HRESULT

Note:  This does not fetch any configuration information from the metabase,
       that's done in RefreshData();

--*/
{
   HRESULT hr = S_OK;

   if (m_hResultItem == 0)
   {
      SetToolBarStates();

      ASSERT_PTR(_lpConsoleNameSpace);
      ASSERT(m_hScopeItem != NULL);

      SCOPEDATAITEM  scopeDataItem;

      ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
      scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE;
      scopeDataItem.displayname = MMC_CALLBACK;
      scopeDataItem.nImage = scopeDataItem.nOpenImage = QueryImage();
      scopeDataItem.ID = m_hScopeItem;
    
      hr = _lpConsoleNameSpace->SetItem(&scopeDataItem);
   }
   else
   {
      RESULTDATAITEM ri;
      ::ZeroMemory(&ri, sizeof(ri));
      ri.itemID = m_hResultItem;
      ri.mask = RDI_STR | RDI_IMAGE;
      ri.str = MMC_CALLBACK;
      ri.nImage = QueryImage();
      CComQIPtr<IResultData, &IID_IResultData> pResultData(_lpConsole);
      if (pResultData != NULL)
      {
         pResultData->SetItem(&ri);
      }
   }
   ASSERT(SUCCEEDED(hr));
   return hr;
}



/* virtual */
HRESULT
CIISObject::DeleteChildObjects(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Free the iisobject pointers belonging to the descendants of the current
    nodes.  This is in response to a MMCN_REMOVE_CHILDREN objects typically,
    and does not remove the scope nodes from the scope view (for that see 
    RemoveChildren())

Arguments:

    HSCOPEITEM hParent      : Parent scope item handle

Return Value:

    HRESULT

--*/
{
    HSCOPEITEM hChildItem;
    CIISObject * pItem;
    LONG_PTR   cookie;

    ASSERT_PTR(_lpConsoleNameSpace);
    HRESULT hr = _lpConsoleNameSpace->GetChildItem(hParent, &hChildItem, &cookie);

    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        ASSERT_PTR(pItem);

        if (pItem)
        {
            //
            // Recursively commit infanticide
            //
            pItem->DeleteChildObjects(hChildItem);
            delete pItem;
        }

        //
        // Advance to next child of same parent
        //
        hr = _lpConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);
    }

    //
    // BUGBUG: For some reason GetNextItem() returns 1
    //         when no more child items exist, not a true HRESULT
    //
    return S_OK;
}


/*virtual*/
HRESULT
CIISObject::DeleteNode(IResultData * pResult)
{
   ASSERT(IsDeletable());
   return S_OK;
}

/* virtual */
HRESULT
CIISObject::RemoveChildren(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Similar to DeleteChildObjects() this method will actually remove
    the child nodes from the scope view.

Arguments:

    HSCOPEITEM hParent      : Parent scope item handle

Return Value:

    HRESULT

--*/
{
    HSCOPEITEM hChildItem, hItem;
    CIISObject * pItem;
    LONG_PTR   cookie;

    ASSERT_PTR(_lpConsoleNameSpace);
    HRESULT hr = _lpConsoleNameSpace->GetChildItem(hParent, &hChildItem, &cookie);

    while(SUCCEEDED(hr) && hChildItem)
    {
        //
        // The cookie is really the IISObject, which is what we stuff 
        // in the lparam.
        //
        pItem = (CIISObject *)cookie;
        ASSERT_PTR(pItem);

        hItem = pItem ? hChildItem : NULL;
    
        //
        // Determine next sibling before killing current sibling
        //
        hr = _lpConsoleNameSpace->GetNextItem(hChildItem, &hChildItem, &cookie);

        //
        // Now delete the current item from the tree
        //
        if (hItem)
        {
            hr = _lpConsoleNameSpace->DeleteItem(hItem, TRUE);

            //
            // ISSUE: Why doesn't DeleteItem above call some sort of 
            //        notification so that I don't have to do this?
            //
            delete pItem;
        }
    }

    //
    // BUGBUG: For some reason GetNextItem() returns 1
    //         when no more child items exist, not a true HRESULT
    //
    return S_OK;
}




/* virtual  */
HRESULT 
CIISObject::EnumerateResultPane(
    IN BOOL fExpand, 
    IN IHeaderCtrl * lpHeader,
    IN IResultData * lpResultData
    )
/*++

Routine Description:

    Enumerate or destroy the result pane.

Arguments:

    BOOL fExpand                : TRUE  to create the result view,
                                  FALSE to destroy it
    IHeaderCtrl * lpHeader      : Header control
    IResultData * pResultData   : Result view

Return Value:

    HRESULT

--*/
{ 
    if (fExpand)
    {
		if (lpHeader != NULL)
		{
			ASSERT_READ_PTR(lpHeader);
			//
			// Build Result View for object of child type
			//
			InitializeChildHeaders(lpHeader);
		}
    }
    else
    {
        //
        // Destroy child result items
        //
    }

    return S_OK; 
}



/* virtual */
HRESULT 
CIISObject::SetStandardVerbs(LPCONSOLEVERB lpConsoleVerb)
/*++

Routine Description:

    Set the standard MMC verbs based on the this object type
    and state.

Arguments:

    LPCONSOLEVERB lpConsoleVerb     : Console verb interface

Return Value:

    HRESULT

--*/
{
    CError err;

    ASSERT_READ_PTR(lpConsoleVerb);

    //
    // Set enabled/disabled verb states
    //
    lpConsoleVerb->SetVerbState(MMC_VERB_COPY,       HIDDEN,  TRUE);
    lpConsoleVerb->SetVerbState(MMC_VERB_PASTE,      HIDDEN,  TRUE);
    lpConsoleVerb->SetVerbState(MMC_VERB_PRINT,      HIDDEN,  TRUE);    
    lpConsoleVerb->SetVerbState(MMC_VERB_RENAME,     ENABLED, IsRenamable());
    lpConsoleVerb->SetVerbState(MMC_VERB_DELETE,     ENABLED, IsDeletable());
    lpConsoleVerb->SetVerbState(MMC_VERB_REFRESH,    ENABLED, IsRefreshable());
    lpConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, IsConfigurable());

    //
    // Set default verb
    //
    if (IsConfigurable())
    {
        lpConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
    }
    
    if (IsOpenable())
    {
        lpConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
    }

    return err;
}


HRESULT
CIISObject::FillCustomData(CLIPFORMAT cf, LPSTREAM pStream)
{
    ASSERT(FALSE);
    return E_FAIL;
}

HRESULT
CIISObject::FillData(CLIPFORMAT cf, LPSTREAM pStream)
{
    HRESULT hr = CSnapInItemImpl<CIISObject>::FillData(cf, pStream);
    if (hr == DV_E_CLIPFORMAT)
    {
        hr = FillCustomData(cf, pStream);
    }
    return hr;
}

//
// CIISRoot implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISRoot::CIISRoot() :
    m_fRootAdded(FALSE),
    m_pMachine(NULL)
{
    VERIFY(m_bstrDisplayName.LoadString(IDS_ROOT_NODE));
}

CIISRoot::~CIISRoot()
{
}

/* virtual */
HRESULT 
CIISRoot::EnumerateScopePane(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Enumerate scope child items of the root object -- i.e. machine nodes.
    The machine nodes are expected to have been filled by via the IPersist
    methods.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace);

    if (m_fIsExtension)
    {
        return EnumerateScopePaneExt(hParent);
    }
    //
    // The CIISRoot item was not added in the conventional way.
    // Cache the scope item handle, and set the cookie, so that
    // GetRoot() will work for child objects. 
    //
    ASSERT(m_hScopeItem == NULL); 
    m_hScopeItem = hParent;

    CError err(SetCookie());

    if (err.Failed())
    {
        //
        // We're in deep trouble.  For some reason, we couldn't
        // store the CIISRoot cookie in the scope view.  That
        // means anything depending on fetching the root object
        // isn't going to work.  Cough up a hairball, and bail
        // out now.
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());
        ASSERT_MSG("Unable to cache root object");
        err.MessageBox();

        return err;
    }

    //
    // Expand the computer cache 
    //
    if (m_scServers.IsEmpty())
    {
        //
        // Try to create the local machine
        //
        CIISMachine * pLocal = new CIISMachine();

        if (pLocal)
        {
            //
            // Verify the machine object is created.
            //
            err = CIISMachine::VerifyMachine(pLocal);

            if (err.Succeeded())
            {
                TRACEEOLID("Added local computer to cache: ");
                m_scServers.Add(pLocal);
            }

            err.Reset();
        }
    }

    //
    // Add each cached server to the view...
    //
    CIISMachine * pMachine = m_scServers.GetFirst();

    while (pMachine)
    {
        TRACEEOLID("Adding " << pMachine->QueryServerName() << " to scope pane");

        err = pMachine->AddToScopePane(hParent);

        if (err.Failed())
        {
            break;
        }

        pMachine = m_scServers.GetNext();
    }
    
    return err;    
}

HRESULT
CIISRoot::EnumerateScopePaneExt(HSCOPEITEM hParent)
{
    CError err;
    ASSERT(m_scServers.IsEmpty());
    if (!m_fRootAdded)
    {
        CComAuthInfo auth(m_ExtMachineName);
        m_pMachine = new CIISMachine(&auth, this);
        if (m_pMachine != NULL)
        {
            err = m_pMachine->AddToScopePane(hParent);
            m_fRootAdded = err.Succeeded();
            ASSERT(m_hScopeItem == NULL);
            m_hScopeItem = m_pMachine->QueryScopeItem();
        }
        else
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return err;
}

HRESULT
ExtractComputerNameExt(
    IDataObject * pDataObject, 
    CString& strComputer)
{
	//
	// Find the computer name from the ComputerManagement snapin
	//
    CLIPFORMAT CCF_MyComputMachineName = (CLIPFORMAT)RegisterClipboardFormat(MYCOMPUT_MACHINE_NAME);
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { 
        CCF_MyComputMachineName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL
    };

    //
    // Allocate memory for the stream
    //
    int len = MAX_PATH;
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
	if(stgmedium.hGlobal == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;

	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);
    ASSERT(SUCCEEDED(hr));
	//
	// Get the computer name
	//
    strComputer = (LPTSTR)stgmedium.hGlobal;

	GlobalFree(stgmedium.hGlobal);

    return hr;
}

HRESULT
CIISRoot::InitAsExtension(IDataObject * pDataObject)
{
    ASSERT(!m_fIsExtension);
    m_fIsExtension = TRUE;
    CString buf;
    return ExtractComputerNameExt(pDataObject, m_ExtMachineName);
}

HRESULT
CIISRoot::ResetAsExtension()
{
    ASSERT(m_fIsExtension);
    CIISObject::m_fIsExtension = FALSE;
    // Remove machine node from the scope
    CError err = RemoveScopeItem();
    m_hScopeItem = NULL;
    // Delete machine object
    delete m_pMachine;
    m_pMachine = NULL;
    m_fRootAdded = FALSE;
    // Empty machine name
    m_ExtMachineName.Empty();
    // clean out

    return err;
}


/* virtual */
HRESULT
CIISRoot::DeleteChildObjects(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    We need this method for extension case. CompMgmt send this event when
    snapin is connected to another machine. We should clean all computer relevant
    stuff from here and the root, because after that we will get MMCN_EXPAND, as
    at the very beginning of extension cycle.

Arguments:

    HSCOPEITEM hParent      : Parent scope item handle

Return Value:

    HRESULT

--*/
{
    HRESULT hr = CIISObject::DeleteChildObjects(m_hScopeItem);
    if (SUCCEEDED(hr) && m_fIsExtension)
    {
        hr = ResetAsExtension();
    }
    return hr;
}


/* virtual */
void 
CIISRoot::InitializeChildHeaders(
    IN LPHEADERCTRL lpHeader
    )
/*++

Routine Description:

    Build result view for immediate descendant type

Arguments:

    LPHEADERCTRL lpHeader      : Header control

Return Value:

    None

--*/
{
    ASSERT(!m_fIsExtension);
    CIISMachine::InitializeHeaders(lpHeader);
}

HRESULT
CIISRoot::FillCustomData(CLIPFORMAT cf, LPSTREAM pStream)
{
    return E_FAIL;
}


/* virtual */
LPOLESTR 
CIISRoot::GetResultPaneColInfo(int nCol)
{
    if (nCol == 0)
    {
        return QueryDisplayName();
    }
    else if (nCol == 1)
    {
    }
    else if (nCol == 2)
    {
    }
    return OLESTR("");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\iismachine.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        iismachine.cpp

   Abstract:

        IIS Machine node

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        10/28/2000      sergeia     Split from iisobj.cpp

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "connects.h"
#include "metaback.h"
#include "iisobj.h"
#include "shutdown.h"
#include "machsht.h"
#include "w3sht.h"
#include "fltdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW

/* static */ LPOLESTR CIISMachine::_cszNodeName = _T("LM");
/* static */ CComBSTR CIISMachine::_bstrYes;
/* static */ CComBSTR CIISMachine::_bstrNo;
/* static */ CComBSTR CIISMachine::_bstrVersionFmt;
/* static */ BOOL     CIISMachine::_fStaticsLoaded = FALSE;


//
// Define result view for machine objects
//
/* static */ int CIISMachine::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_COMPUTER_NAME,
    IDS_RESULT_COMPUTER_LOCAL,
    IDS_RESULT_COMPUTER_VERSION,
    IDS_RESULT_STATUS,
};
    


/* static */ int CIISMachine::_rgnWidths[COL_TOTAL] =
{
    200,
    50,
    //100,
    150,
    200,
};



/* static */
void
CIISMachine::InitializeHeaders(
    IN LPHEADERCTRL lpHeader
    )
/*++

Routine Description:

    Initialize the result view headers for a machine object

Arguments:

    LPHEADERCTRL lpHeader : Pointer to header control

Return Value:

    None.

--*/
{
    BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);

    if (!_fStaticsLoaded)
    {
        _fStaticsLoaded =
            _bstrYes.LoadString(IDS_YES)                      &&
            _bstrNo.LoadString(IDS_NO)                        &&
            _bstrVersionFmt.LoadString(IDS_VERSION_FMT);
    }
}



/* static */
HRESULT
CIISMachine::VerifyMachine(
    IN OUT  CIISMachine *& pMachine
    )
/*++

Routine Description:

    Create the interface on the given machine object.

Arguments:

    CIISMachine *& pMachine         : Machine object
    BOOL fAskBeforeRedirecting

Return Value:

    HRESULT

Notes:

    THe CIISMachine object pass in may refer to the cluster master
    on return.

--*/
{
    CError err;

    if (pMachine)
    {
        AFX_MANAGE_STATE(::AfxGetStaticModuleState());

        CWaitCursor wait;

        //
        // Attempt to create the interface to ensure the machine
        // contains a metabase.  
        //
        err = pMachine->CreateInterface(FALSE); 
    }

    return err;
}



CIISMachine::CIISMachine(
    CComAuthInfo * pAuthInfo,
    CIISRoot * pRoot
    )
    : m_pInterface(NULL),
      m_bstrDisplayName(NULL),
      m_auth(pAuthInfo),
      m_pRootExt(pRoot),
      m_err(),
      //
      // By default we assume the password is entered.
      // If this machine object is constructed from the
      // cache, it will get reset by InitializeFromStream()
      //
      m_fPasswordEntered(TRUE),
      m_dwVersion(MAKELONG(5, 0)),       // Assume as a default
      CIISMBNode(this, _cszNodeName)
{
    //
    // Load one-liner error messages
    //
    SetErrorOverrides(m_err, TRUE);
    SetDisplayName();
}



CIISMachine::~CIISMachine()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_bstrDisplayName)
    {
        ::SysFreeString(m_bstrDisplayName);
    }

    SAFE_DELETE(m_pInterface);
}



/* static */
HRESULT 
CIISMachine::ReadFromStream(
    OUT IN IStream * pStream,
    OUT CIISMachine ** ppMachine
    )
/*++

Routine Description:

    Static helper function to allocate a new CIISMachine object read
    from the storage stream.

Arguments:

    IStream * pStream           : Stream to read from
    CIISMachine ** ppMachine    : Returns CIISMachine object

Return Value:

    HRESULT

--*/
{
    CComBSTR strMachine, strUser;

    ASSERT_WRITE_PTR(ppMachine);
    ASSERT_READ_WRITE_PTR(pStream);

    CError  err;
    *ppMachine = NULL;
    
    do
    {
        err = strMachine.ReadFromStream(pStream);
        BREAK_ON_ERR_FAILURE(err);
        err = strUser.ReadFromStream(pStream);
        BREAK_ON_ERR_FAILURE(err);

        *ppMachine = new CIISMachine(CComAuthInfo(strMachine, strUser));

        if (!*ppMachine)
        {   
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        err = (*ppMachine)->InitializeFromStream(pStream);
    }
    while(FALSE);

    return err;
}



HRESULT 
CIISMachine::WriteToStream(
    IN OUT IStream * pStgSave
    )
/*++

Routine Description:

    Write machine information to stream.

Arguments:

    IStream * pStgSave      : Open stream

Return Value:

    HRESULT

Notes:

    Be sure to keep this information in sync with CIISMachine::InitializeFromStream()

--*/
{
    ASSERT_READ_WRITE_PTR(pStgSave);

    CComBSTR bstrServerName(m_auth.QueryServerName());
    CComBSTR bstrUserName(m_auth.QueryUserName());

    CError  err;
    ULONG   cb;
    
    do
    {
        err = bstrServerName.WriteToStream(pStgSave);
        BREAK_ON_ERR_FAILURE(err);
        err = bstrUserName.WriteToStream(pStgSave);
        BREAK_ON_ERR_FAILURE(err);

        //
        // Now cache the dynamically-generated information, such
        // as version number, snapin status etc. This will be
        // displayed in the result view before the interface is
        // created.
        //
        err = pStgSave->Write(&m_dwVersion, sizeof(m_dwVersion), &cb);
        BREAK_ON_ERR_FAILURE(err);
    }
    while(FALSE);

    return err;
}



HRESULT
CIISMachine::InitializeFromStream(
    IN IStream * pStream
    )
/*++

Routine Description:

    Read version number and other cached parameters that will
    be overridden at runtime when the interface is created.
    This is cached, because it's required before the interface
    is created.

Arguments:
    
    IStream * pStream      : Open stream

Return Value:

    HRESULT

Notes:

    Be sure to keep this information in sync with CIISMachine::WriteToStream()

--*/
{
    ASSERT_READ_PTR(pStream);

    CError  err;
    ULONG   cb;

    //
    // Passwords are never cached.  IIS status will
    // always be verified when the actual interface
    // is created.
    //
    m_fPasswordEntered = FALSE;

    //
    // Version number
    //
    err = pStream->Read(&m_dwVersion, sizeof(m_dwVersion), &cb);
    return err;
}



void
CIISMachine::SetDisplayName()
/*++

Routine Description:

    Create a special display name for this machine object if it's
    either the local machine, or 

--*/
{
    CString fmt;

    if (IsLocal())
    {
        //
        // Use the local computer name, and not the name
        // that's on the server object, because that could
        // be and ip address or "localhost".
        //
        TCHAR szLocalServer[MAX_PATH + 1];
        DWORD dwSize = MAX_PATH;

        VERIFY(::GetComputerName(szLocalServer, &dwSize));
        fmt.Format(IDS_LOCAL_COMPUTER, szLocalServer);
    }
    else
    {
        //
        // No special display name necessary
        //
        m_bstrDisplayName = NULL;
        return;
    }

    m_bstrDisplayName = ::SysAllocStringLen(fmt, fmt.GetLength());
    TRACEEOLID("Machine display name: " << m_bstrDisplayName);
}



LPOLESTR 
CIISMachine::QueryDisplayName()
/*++

Routine Description:

    Get the display name for the machine/cluster object

Arguments:

    None

Return Value:

    Display Name

--*/
{ 
    if (m_pRootExt != NULL)
        return m_pRootExt->QueryDisplayName();
    else
        return  m_bstrDisplayName ? m_bstrDisplayName : QueryServerName(); 
}



int 
CIISMachine::QueryImage() const 
/*++

Routine Description:

    Return machine bitmap index appropriate for the current
    state of this machine object.

Arguments:

    None

Return Value:

    Bitmap index

--*/
{
    if (m_pRootExt != NULL)
    {
        return m_pRootExt->QueryImage();
    }
    else
    {
        if (m_err.Failed())
        {
            return iErrorMachine;
        }
        return IsLocal() ? iLocalMachine : iMachine;
    }
}



HRESULT
CIISMachine::CreateInterface(
    IN BOOL fShowError
    )
/*++

Routine Description:

    Create the interface.  If the interface is already created, recreate it.

Arguments:

    BOOL fShowError     : TRUE to display error messages

Return Value:

    HRESULT

Notes:

    This function is deliberately NOT called from the constructor for performance
    reasons.

--*/
{
    CError err;

    if (HasInterface())
    {
        //
        // Recreate the interface (this should re-use the impersonation)
        //
        TRACEEOLID("Warning: Rebinding existing interface.");
        err = m_pInterface->Regenerate();
    }
    else
    {
        //
        // Create new interface
        //
        m_pInterface = new CMetaKey(&m_auth);
        err = m_pInterface 
            ? m_pInterface->QueryResult() 
            : ERROR_NOT_ENOUGH_MEMORY;
    }

    if (err.Succeeded())
    {
        //
        // Load its display parameters
        //
        err = RefreshData();
        CMetabasePath path;
        err = DetermineIfAdministrator(
            m_pInterface, 
            path,
            &m_fIsAdministrator
            );
    }

    if (err.Failed())
    {
        if (fShowError)
        {
            DisplayError(err);
        }

        //
        // Kill bogus interface
        //
        SAFE_DELETE(m_pInterface);
    }

    return err;
}



/* virtual */
int 
CIISMachine::CompareScopeItem(
    IN CIISObject * pObject
    )
/*++

Routine Description:

    Compare against another CIISMachine object.

Arguments:

    CIISObject * pObject : Object to compare against

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // pObject is a CIISMachine object (same sortweight)
    //
    CIISMachine * pMachine = (CIISMachine *)pObject;

    //
    // Next sort on local key (local sorts before non-local)
    //
    n1 = IsLocal() ? 0 : 1;
    n2 = pMachine->IsLocal() ? 0 : 1;

    if (n1 != n2)
    {
        return n1 - n2;
    }

    if (!n1 && !n2)
    {
        //
        // This is the local machine, even if the name is different
        //
        return 0;
    }

    //
    // Else sort on name.
    //
    return ::lstrcmpi(QueryServerName(), pMachine->QueryServerName());
}



BOOL
CIISMachine::SetCacheDirty()
/*++

Routine Description:

    Set the cache as dirty

Arguments:

    None

Return Value:

    TRUE for success, FALSE if the cache was not found

--*/
{
    ASSERT(m_pRootExt == NULL);
    //
    // Cache is stored at the root object
    //
    CIISRoot * pRoot = GetRoot();

    ASSERT_PTR(pRoot);

    if (pRoot)
    {
        pRoot->m_scServers.SetDirty();
        return TRUE;
    }

    return FALSE;
}



int
CIISMachine::ResolvePasswordFromCache()
/*++

Routine Description:

    Look through the machine cache for machines with the same username
    as this object.  If they have a password entered, grab it.

Arguments:

    None

Return Value:

    TRUE if a machine with the same username was found whose password
    we stole.  FALSE otherwise.

--*/
{
    BOOL fUpdated = FALSE;

    //
    // Doesn't make sense if this machine object doesn't use impersonation
    // or already has a password.
    //
    ASSERT(UsesImpersonation() && !PasswordEntered());

    CIISRoot * pRoot = GetRoot();

    ASSERT_PTR(pRoot);

    if (pRoot)
    {
        CIISMachine * pMachine = pRoot->m_scServers.GetFirst();

        while(pMachine)
        {
            if (pMachine->UsesImpersonation() && pMachine->PasswordEntered())
            {
                if (!::lstrcmpi(QueryUserName(), pMachine->QueryUserName()))
                {
                    TRACEEOLID("Swiping cached password from " << pMachine->QueryServerName());
                    StorePassword(pMachine->QueryPassword());
                    ++fUpdated;
                    break;
                }
            }

            pMachine = pRoot->m_scServers.GetNext();
        }
    }

    return fUpdated;
}



HRESULT
CIISMachine::Impersonate(
    IN LPCTSTR szUserName,
    IN LPCTSTR szPassword
    )
/*++

Routine Description:

    Set and store proxy blanket security information.  Store username/password
    for use by metaback and other interfaces.

Arguments:

    LPCTSTR szUserName  : Username (domain\username)
    LPCTSTR szPassword  : Password

Return Value:

    None

--*/
{
    ASSERT_READ_PTR(szUserName);
    CError err;

    if (m_pInterface)
    {
        //
        // Already have an interface created; Change the 
        // the security blanket.
        //
        err = m_pInterface->ChangeProxyBlanket(szUserName, szPassword);
    }

    if (err.Succeeded())
    {
        //
        // Store new username/password
        //
        m_auth.SetImpersonation(szUserName, szPassword);
        m_fPasswordEntered = TRUE;
    }

    return err;
}



void 
CIISMachine::RemoveImpersonation() 
/*++

Routine Description:

    Remove impersonation parameters.  Destroy any existing interface.

Arguments:

    None

Return Value:

    N/A

--*/
{ 
    m_auth.RemoveImpersonation(); 
    m_fPasswordEntered = FALSE;

    SAFE_DELETE(m_pInterface);
}



void
CIISMachine::StorePassword(
    IN LPCTSTR szPassword
    )
/*++

Routine Description:

    Store password.

Arguments:

    LPCTSTR szPassword  : Password

Return Value:

    None

--*/
{
    ASSERT_READ_PTR(szPassword);
    m_auth.StorePassword(szPassword);
    m_fPasswordEntered = TRUE;
}



BOOL
CIISMachine::ResolveCredentials()
/*++

Routine Description:

    If this machine object uses impersonation, but hasn't entered a password
    yet, check to see if there are any other machines in the cache with the
    same username and grab its password.  If not, prompt the user for it.

Arguments:

    None

Return Value:

    TRUE if a password was entered.  FALSE otherwise.

--*/
{
    BOOL fPasswordEntered = FALSE;

    if (UsesImpersonation() && !PasswordEntered())
    {
        //
        // Attempt to find the password from the cache
        //
        if (!ResolvePasswordFromCache())
        {
            //
            // Didn't find the password in the cache.  Prompt
            // the user for it.
            //
            CLoginDlg dlg(LDLG_ENTER_PASS, this);

            if (dlg.DoModal() == IDOK)
            {
                fPasswordEntered = TRUE;

                if (dlg.UserNameChanged())
                {
                    //
                    // User name has changed -- remember to
                    // save the machine cache later.
                    //
                    SetCacheDirty();
                }
            }
            else
            {
                //
                // Pressing cancel on this dialog means the user
                // wants to stop using impersonation. 
                //
                RemoveImpersonation();
                SetCacheDirty();
            }
        }
    }

    return fPasswordEntered;
}



BOOL
CIISMachine::HandleAccessDenied(
    IN OUT CError & err
    )
/*++

Routine Description:

    After calling interface method, pass the error object to this function
    to handle the access denied case.  If the error is access denied,
    give the user a chance to change credentials.  Since we assume an
    attempt has been made to create an interface at least -- the interface
    will be recreated with the new credentials.

Arguments:

    CError & err    : Error object.  Checked for ACCESS_DENIED on entry,
                      will contain new error code on exit if the interface
                      was recreated.

Return Value:

    TRUE if new credentials were applied

--*/
{
    BOOL fPasswordEntered = FALSE;

    //
    // If access denied occurs here -- give another chance
    // at entering the password.
    //
    if (err.Win32Error() == ERROR_ACCESS_DENIED)
    {
        CLoginDlg dlg(LDLG_ACCESS_DENIED, this);

        if (dlg.DoModal() == IDOK)
        {
            fPasswordEntered = TRUE;
            err.Reset();

            if (!HasInterface())
            {
                //
                // If we already had an interface, the login dialog
                // will have applied the new security blanket.
                // If we didn't have an interface, it needs to be
                // recreated with the new security blanket.
                //
                CWaitCursor wait;
                err = CreateInterface(FALSE);
            }
        }
    }

    return fPasswordEntered;
}



HRESULT
CIISMachine::CheckCapabilities()
/*++

Routine Description:

    Load the capabilities information for this server.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    //
    // Fetch capability bits and version numbers.
    //
    CString strMDInfo;
    CMetabasePath::GetServiceInfoPath(_T(""), strMDInfo);

    CServerCapabilities sc(m_pInterface, strMDInfo);
    hr = sc.LoadData();

    if (SUCCEEDED(hr))
    {
        DWORD dwVersion = sc.QueryMajorVersion();
        if (dwVersion)
        {
            m_dwVersion = dwVersion | (sc.QueryMinorVersion() << SIZE_IN_BITS(WORD));
        }
        m_fCanAddInstance = sc.HasMultipleSites();
        m_fHas10ConnectionsLimit = sc.Has10ConnectionLimit();
    }

    return hr;
}



/* virtual */
HRESULT 
CIISMachine::RefreshData() 
/*++

Routine Description:

    Refresh relevant configuration data required for display.

Arguments:

    None

Return Value:

    HRESULT

--*/
{ 
    //
    // Check capability and version information.
    //
    CError err(CheckCapabilities());
    SetDisplayName();

    return err;
}



/* virtual */
void 
CIISMachine::SetInterfaceError(
    IN HRESULT hr
    )
/*++

Routine Description:

    Set the interface error.  If different from current error,
    change the display icon

Arguments:

    HRESULT hr      : Error code (S_OK is acceptable)

Return Value:

    None

--*/
{
    if (m_err.HResult() != hr)
    {
        //
        // Change to error/machine icon for the parent machine.
        //
        m_err = hr;
        RefreshDisplay();
    }
}



/* virtual */
HRESULT
CIISMachine::BuildMetaPath(
    OUT CComBSTR & bstrPath
    ) const
/*++

Routine Description:

    Recursively build up the metabase path from the current node
    and its parents

Arguments:

    CComBSTR & bstrPath : Returns metabase path

Return Value:

    HRESULT

--*/
{
    //
    // This starts off the path
    //
    bstrPath.Append(_cszSeparator);
    bstrPath.Append(QueryNodeName());

    return S_OK;
}


/* virtual */
HRESULT 
CIISMachine::BuildURL(
    OUT CComBSTR & bstrURL
    ) const
/*++

Routine Description:

    Recursively build up the URL from the current node
    and its parents.  The URL built up from a machine node
    doesn't make a lot of sense, but for want of anything better,
    this will bring up the default web site.

Arguments:

    CComBSTR & bstrURL : Returns URL

Return Value:

    HRESULT

--*/
{
    CString strOwner;

    if (IsLocal())
    {
        //
        // Security reasons restrict this to "localhost" oftentimes
        //
        strOwner = _bstrLocalHost;
    }
    else
    {
        LPOLESTR lpOwner = QueryMachineName();
        strOwner = PURE_COMPUTER_NAME(lpOwner);
    }

    //
    // An URL on the machine node is built in isolation.
    //
    // ISSUE: Is this really a desirable URL?  Maybe we should
    //        use something else.
    //
    bstrURL = _T("http://");
    bstrURL.Append(strOwner);

    return S_OK;
}



/* virtual */
HRESULT
CIISMachine::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CComBSTR bstrPath;

    //
    // ISSUE: What to do with m_err?  This might be 
    // a bad machine object in the first place.  Aborting
    // when the machine object has an error code isn't 
    // such a bad solution here.  If the error condition
    // no longer exists, a refresh will cure.
    //
    if (m_err.Failed())
    {
        m_err.MessageBox();
        return m_err;
    }

    CError err(BuildMetaPath(bstrPath));

    if (err.Succeeded())
    {
        CIISMachineSheet * pSheet = new CIISMachineSheet(
            QueryAuthInfo(),
            bstrPath,
            GetMainWindow(),
            (LPARAM)this,
            handle
            );

        if (pSheet)
        {
            pSheet->SetModeless();

            //
            // Add pages
            //
            err = AddMMCPage(lpProvider, new CIISMachinePage(pSheet));
        }
        else
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    err.MessageBoxOnFailure();

    return err;
}



/* virtual */
HRESULT 
CIISMachine::EnumerateScopePane(
    IN HSCOPEITEM hParent
    )
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(_lpConsoleNameSpace);
    ASSERT(m_hScopeItem == hParent);

    CError err;
    CString str;
    CIISService * pService, * pWebService = NULL;

    CWaitCursor wait;
    CMetaEnumerator * pme = NULL;

	if (IsExpanded())
	{
		//
		// Verify user credentials are satisfactorily resolved.
		// Machines objects are loaded from the cache without a
		// password, so the function below will ask for it.
		//
		ResolveCredentials();
		wait.Restore();    

		BOOL fShouldRefresh = !HasInterface();
		err = AssureInterfaceCreated(FALSE);

		if (err.Succeeded())
		{
			//
			// Creation of the interface will have loaded display parameters, which
			// may differ from the cached parameters.
			//
			if (fShouldRefresh)
			{
				RefreshDisplay();
			}

			err = CreateEnumerator(pme);
		}

		//
		// Only check for acces denied now, because virtually any idiot
		// is allowed to create a metabase interface, but will get the
		// access denied when calling a method, such as enumeration.
		//
		if (HandleAccessDenied(err))
		{
			wait.Restore();

			//
			// Credentials were changed.  Try again (interface should be
			// created already)
			//
			SAFE_DELETE(pme);

			if (err.Succeeded())
			{
				err = CreateEnumerator(pme);
			}
		}

		//
		// Enumerate administerable services from the metabase
		//
		while (err.Succeeded())
		{
			err = pme->Next(str);

			if (err.Succeeded())
			{
				TRACEEOLID("Enumerating node: " << str);
				pService = new CIISService(this, str);        

				if (!pService)
				{
					err = ERROR_NOT_ENOUGH_MEMORY;
					break;
				}

				//
				// See if we care
				//
				if (pService->IsManagedService())
				{
					err = pService->AddToScopePane(hParent);
					if (err.Succeeded())
					{
						if (0 == lstrcmpi(pService->GetNodeName(), SZ_MBN_WEB))
						{
						   pWebService = pService;
						}
					}
				}
				else
				{
					//
					// Node is not a managed service, or we're managing the 
					// cluster and the service is not clustered.
					//
					delete pService;
				}
			}
		}
    
		if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
		{
			err.Reset();
		}

		// If we are encountered web service, we should add 
		// Application Pools container before this service
		//
		if (err.Succeeded() && pWebService != NULL)
		{
			// We could have iis5 machine which doesn't have any pools
			//
			CMetaKey mk(pme, _T("/LM/W3SVC/AppPools"));
			if (mk.Succeeded())
			{
				CAppPoolsContainer * pPools = new CAppPoolsContainer(
					this, pWebService);
				if (!pPools)
				{
					err = ERROR_NOT_ENOUGH_MEMORY;
					goto Fail;
				}
				// Insert pools container before Web Services node
				err = pPools->AddToScopePane(
						 pWebService->QueryScopeItem(), FALSE, TRUE);
			}
		}

	Fail:
		if (err.Failed())
		{
			DisplayError(err);
		}

		SetInterfaceError(err);   

		//
		// Clean up
		//
		SAFE_DELETE(pme);
	}
    return err;
}



/* virtual */
HRESULT 
CIISMachine::RemoveScopeItem()
/*++

Routine Description:

    Remove the machine from the scope view and the cache.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ASSERT(m_pRootExt == NULL);
    //
    // Find out root before deleting scope node
    //
    CIISRoot * pRoot = GetRoot();
    ASSERT_PTR(pRoot);
    //
    // Remove from the tree
    //
    HRESULT hr = CIISMBNode::RemoveScopeItem();

    if (SUCCEEDED(hr) && pRoot)
    {
        pRoot->m_scServers.Remove(this);
    }

    return hr;
}


/* virtual */
LPOLESTR 
CIISMachine::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    if (m_pRootExt != NULL)
    {
        return m_pRootExt->GetResultPaneColInfo(nCol);
    }

    ASSERT(_fStaticsLoaded);

    switch(nCol)
    {
    case COL_NAME:
        return QueryDisplayName();
    
    case COL_LOCAL: 
        return IsLocal() ? _bstrYes : _bstrNo;

    case COL_VERSION:
        {
            CString str;

            str.Format(_bstrVersionFmt, QueryMajorVersion(), QueryMinorVersion());
            _bstrResult = str;

        }
        return _bstrResult;

    case COL_STATUS:
        {
            if (m_err.Succeeded())
            {
                return OLESTR("");
            }

            AFX_MANAGE_STATE(::AfxGetStaticModuleState());

            return m_err;
        }
    }

    ASSERT_MSG("Bad column number");

    return OLESTR("");
}



/* virtual */
HRESULT
CIISMachine::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Add menu items to the context menu

Arguments:

    LPCONTEXTMENUCALLBACK lpContextMenuCallback : Context menu callback
    long * pInsertionAllowed                    : Insertion allowed
    DATA_OBJECT_TYPES type                      : Object type

Return Value:

    HRESULT

--*/
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    if (SUCCEEDED(hr))
    {
       if (IsAdministrator() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
       {
           AddMenuItemByCommand(lpContextMenuCallback, IDM_METABACKREST);
           AddMenuItemByCommand(lpContextMenuCallback, IDM_SHUTDOWN);
	   }
#if 0
        if (CanAddInstance())
        {
            ASSERT(pInsertionAllowed != NULL);
            if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
            {

#define ADD_SERVICE_MENU(x)\
   if (!bSepAdded)\
   {\
      AddMenuSeparator(lpContextMenuCallback);\
      bSepAdded = TRUE;\
   }\
   AddMenuItemByCommand(lpContextMenuCallback, (x))

               HSCOPEITEM hChild = NULL, hCurrent;
               LONG_PTR cookie;
               BOOL bSepAdded = FALSE;

               hr = _lpConsoleNameSpace->GetChildItem(QueryScopeItem(), &hChild, &cookie);
               while (SUCCEEDED(hr) && hChild != NULL)
               {
                  CIISMBNode * pNode = (CIISMBNode *)cookie;
                  ASSERT(pNode != NULL);
                  if (lstrcmpi(pNode->GetNodeName(), SZ_MBN_FTP) == 0)
                  {
                     ADD_SERVICE_MENU(IDM_NEW_FTP_SITE);
                  }
                  else if (lstrcmpi(pNode->GetNodeName(), SZ_MBN_WEB) == 0)
                  {
                     ADD_SERVICE_MENU(IDM_NEW_WEB_SITE);
                  }
                  else if (lstrcmpi(pNode->GetNodeName(), SZ_MBN_APP_POOLS) == 0)
                  {
                     ADD_SERVICE_MENU(IDM_NEW_APP_POOL);
                  }
                  hCurrent = hChild;
                  hr = _lpConsoleNameSpace->GetNextItem(hCurrent, &hChild, &cookie);
               }
            }
        }
#endif
        //
        // CODEWORK: Add new instance commands for each of the services
        //           keeping in mind which ones are installed and all.
        //           add that info to the table, remembering that this
        //           is per service.
        //
    }

    return hr;
}

#if 0
// BUGBUG: It should be quite different -> we don't know in advance
// which service is this site for
HRESULT
CIISMachine::InsertNewInstance(DWORD inst)
{
    CError err;
    // Now we should insert and select this new site
    TCHAR buf[16];
    CIISSite * pSite = new CIISSite(m_pOwner, this, _itot(inst, buf, 10));
    if (pSite != NULL)
    {
        // If machine is not expanded we will get error and no effect
        if (!IsExpanded())
        {
            SelectScopeItem();
            IConsoleNameSpace2 * pConsole 
                    = (IConsoleNameSpace2 *)GetConsoleNameSpace();
            pConsole->Expand(QueryScopeItem());
        }
        // Now we should find the relevant service node, and inset this one under
        // this node
        err = pSite->AddToScopePaneSorted(QueryScopeItem(), FALSE);
        if (err.Succeeded())
        {
            VERIFY(SUCCEEDED(pSite->SelectScopeItem()));
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    return err;
}
#endif

HRESULT
CIISMachine::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    switch (lCommandID)
    {
    case IDM_DISCONNECT:
        hr = OnDisconnect();
        break;

    case IDM_METABACKREST:
        hr = OnMetaBackRest();
        break;

    case IDM_SHUTDOWN:
        hr = OnShutDown();
        break;
#if 0
    case IDM_NEW_FTP_SITE:
       if (SUCCEEDED(hr = AddFTPSite(pObj, type, &inst)))
       {
           hr = InsertNewInstance(inst);
       }
       break;

    case IDM_NEW_WEB_SITE:
       if (SUCCEEDED(hr = AddWebSite(pObj, type, &inst)))
       {
           hr = InsertNewInstance(inst);
       }
       break;

    case IDM_NEW_APP_POOL:
       hr = AddAppPool(pObj, type);
       break;
#endif

    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    return hr;
}



HRESULT
CIISMachine::OnDisconnect()
/*++

Routine Description:

    Disconnect this machine.  Confirm user choice.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CString str;
    str.Format(IDS_CONFIRM_DISCONNECT, QueryDisplayName());

    if (NoYesMessageBox(str))
    {
        return RemoveScopeItem();
    }

    return S_OK;
}



HRESULT
CIISMachine::OnMetaBackRest()
/*++

Routine Description:

    Backup/Restore the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    //
    // Verify user credentials are satisfactorily resolved.
    // Machines objects are loaded from the cache without a
    // password, so the function below will ask for it.
    //
    ResolveCredentials();

    CBackupDlg dlg(this, GetMainWindow());
    dlg.DoModal();

    if (dlg.HasChangedMetabase())
    {
        //
        // Refresh and re-enumerate child objects
        //
        err = Refresh(TRUE);
    }

    return err;
}



HRESULT
CIISMachine::OnShutDown()
/*++

Routine Description:

    Bring up the IIS shutdown dialog.  If the services on the remote
    machine are restarted, the metabase interface should be recreated.
    
Arguments:

    None
    
Return Value:

    HRESULT    

--*/
{
    CError err;
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    //
    // Verify user credentials are satisfactorily resolved.
    // Machines objects are loaded from the cache without a
    // password, so the function below will ask for it.
    //
    ResolveCredentials();

    CIISShutdownDlg dlg(this, GetMainWindow());
    dlg.DoModal();

    if (dlg.ServicesWereRestarted())
    {
        //
        // Rebind all metabase handles on this server
        //
        err = CreateInterface(TRUE);

        //
        // Now do a refresh on the computer node.  Since we've forced
        // the rebinding already, we should not get the disconnect warning.
        //
        if (err.Succeeded())
        {
            err = Refresh(TRUE);
        }
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\iismbnode.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        iismbnode.cpp

   Abstract:
        CIISMBNode Object

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        10/28/2000      sergeia     Split from iisobj.cpp

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "w3sht.h"
#include "fltdlg.h"
#include "pwiz.h"
#include <lm.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//
// CIISMBNode implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */ LPOLESTR CIISMBNode::_cszSeparator = _T("/");



CIISMBNode::CIISMBNode(
    IN CIISMachine * pOwner,
    IN LPCTSTR szNode
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISMachine * pOwner         : Owner machine object
    LPCTSTR szNode               : Node name

Return Value:

    N/A

--*/
    : m_bstrNode(szNode),
      m_bstrURL(NULL), 
      m_pOwner(pOwner)
{
    ASSERT_READ_PTR(szNode);
    ASSERT_READ_PTR(pOwner);
}


CIISMBNode::~CIISMBNode()
{
   RemoveResultItems();
}


void
CIISMBNode::SetErrorOverrides(
    IN OUT CError & err,
    IN BOOL fShort
    ) const
/*++

Routine Description:

    Set error message overrides

Arguments:

    CError err      : Error message object
    BOOL fShort     : TRUE to use only single-line errors

Return Value:

    None

--*/
{
    //
    // Substitute friendly message for some ID codes.
    //
    // CODEWORK:  Add global overrides as well.
    //
    err.AddOverride(EPT_S_NOT_REGISTERED,       
        fShort ? IDS_ERR_RPC_NA_SHORT : IDS_ERR_RPC_NA);
    err.AddOverride(RPC_S_SERVER_UNAVAILABLE,   
        fShort ? IDS_ERR_RPC_NA_SHORT : IDS_ERR_RPC_NA);

    err.AddOverride(RPC_S_UNKNOWN_IF,           IDS_ERR_INTERFACE);
    err.AddOverride(RPC_S_PROCNUM_OUT_OF_RANGE, IDS_ERR_INTERFACE);
    err.AddOverride(REGDB_E_CLASSNOTREG,        IDS_ERR_NO_INTERFACE);

    if (!fShort)
    {
        err.AddOverride(ERROR_ACCESS_DENIED,    IDS_ERR_ACCESS_DENIED);
    }
}

BOOL 
CIISMBNode::IsAdministrator() const
{
    CIISMBNode * that = (CIISMBNode *)this;
    return that->GetOwner()->HasAdministratorAccess();
}

void 
CIISMBNode::DisplayError(
    IN OUT CError & err
    ) const
/*++

Routine Description:

    Display error message box. Substituting some friendly messages for
    some specific error codes

Arguments:

    CError & err        : Error object contains code to be displayed

Return Value:

    Noen

--*/
{
    SetErrorOverrides(err);
    err.MessageBox();
}



CIISMBNode *
CIISMBNode::GetParentNode() const
    
/*++

Routine Description:

    Helper function to return the parent node in the scope tree

Arguments:

    None

Return Value:

    Parent CIISMBNode or NULL.

--*/
{
    LONG_PTR cookie = NULL;
    HSCOPEITEM hParent;    
    CIISMBNode * pNode = NULL;
    HRESULT hr = S_OK;

    ASSERT_PTR(_lpConsoleNameSpace);

    if (m_hResultItem != 0)
    {
        SCOPEDATAITEM si;
        ::ZeroMemory(&si, sizeof(SCOPEDATAITEM));
        si.mask = SDI_PARAM;
        si.ID = m_hScopeItem;
        hr = _lpConsoleNameSpace->GetItem(&si);
        if (SUCCEEDED(hr))
        {
            cookie = si.lParam;
        }
    }
    else
    {
        hr = _lpConsoleNameSpace->GetParentItem(
            m_hScopeItem,
            &hParent,
            &cookie
            );
    }

    if (SUCCEEDED(hr))
    {
        pNode = (CIISMBNode *)cookie;
        ASSERT_PTR(pNode);
    }

    return pNode;
}



/* virtual */
HRESULT
CIISMBNode::BuildMetaPath(
    OUT CComBSTR & bstrPath
    ) const
/*++

Routine Description:

    Recursively build up the metabase path from the current node
    and its parents

Arguments:

    CComBSTR & bstrPath     : Returns metabase path

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;
    CIISMBNode * pNode = GetParentNode();

    if (pNode)
    {
        hr = pNode->BuildMetaPath(bstrPath);

        if (SUCCEEDED(hr))
        {
            bstrPath.Append(_cszSeparator);
            bstrPath.Append(QueryNodeName());
        }

        return hr;
    }

    //
    // No parent node
    //
    ASSERT_MSG("No parent node");
    return E_UNEXPECTED;
}


HRESULT
CIISMBNode::FillCustomData(CLIPFORMAT cf, LPSTREAM pStream)
{
    HRESULT hr = DV_E_CLIPFORMAT;
    ULONG uWritten;

    if (cf == m_CCF_MachineName)
    {
        hr = pStream->Write(
                QueryMachineName(), 
                (ocslen((OLECHAR*)QueryMachineName()) + 1) * sizeof(OLECHAR),
                &uWritten
                );

        ASSERT(SUCCEEDED(hr));
        return hr;
    }
    //
    // Generate complete metabase path for this node
    //
    CString strField;
    CString strMetaPath;
    CComBSTR bstr;
    if (FAILED(hr = BuildMetaPath(bstr)))
    {
        ASSERT(FALSE);
        return hr;
    }
    strMetaPath = bstr;

    if (cf == m_CCF_MetaPath)
    {
        //
        // Whole metabase path requested
        //
        strField = strMetaPath;
    }
    else
    {
        //
        // A portion of the metabase is requested.  Return the requested
        // portion
        //
        LPCTSTR lpMetaPath = (LPCTSTR)strMetaPath;
        LPCTSTR lpEndPath = lpMetaPath + strMetaPath.GetLength() + 1;
        LPCTSTR lpSvc = NULL;
        LPCTSTR lpInstance = NULL;
        LPCTSTR lpParent = NULL;
        LPCTSTR lpNode = NULL;

        //
        // Break up the metabase path in portions
        //
        if (lpSvc = _tcschr(lpMetaPath, _T('/')))
        {
            ++lpSvc;

            if (lpInstance = _tcschr(lpSvc, _T('/')))
            {
                ++lpInstance;

                if (lpParent = _tcschr(lpInstance, _T('/')))
                {
                    ++lpParent;
                    lpNode = _tcsrchr(lpParent, _T('/'));

                    if (lpNode)
                    {
                        ++lpNode;
                    }
                }
            }
        }

        int n1, n2;
        if (cf == m_CCF_Service)
        {
            //
            // Requested the service string
            //
            if (lpSvc)
            {
                n1 = DIFF(lpSvc - lpMetaPath);
                n2 = lpInstance ? DIFF(lpInstance - lpSvc) : DIFF(lpEndPath - lpSvc);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
        }
        else if (cf == m_CCF_Instance)
        {
            //
            // Requested the instance number
            //
            if (lpInstance)
            {
                n1 = DIFF(lpInstance - lpMetaPath);
                n2 = lpParent ? DIFF(lpParent - lpInstance) : DIFF(lpEndPath - lpInstance);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
        }
        else if (cf == m_CCF_ParentPath)
        {
            //
            // Requestd the parent path
            //
            if (lpParent)
            {
                n1 = DIFF(lpParent - lpMetaPath);
                n2 = lpNode ? DIFF(lpNode - lpParent) : DIFF(lpEndPath - lpParent);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
        }
        else if (cf == m_CCF_Node)
        {
            //
            // Requested the node name
            //
            if (lpNode)
            {
                n1 = DIFF(lpNode - lpMetaPath);
                n2 = DIFF(lpEndPath - lpNode);
                strField = strMetaPath.Mid(n1, n2 - 1);
            }
        }
        else
        {
            ASSERT(FALSE);
            DV_E_CLIPFORMAT;
        }
    }

    TRACEEOLID("Requested metabase path data: " << strField);
    int len = strField.GetLength() + 1;
    hr = pStream->Write(strField, 
            (ocslen(strField) + 1) * sizeof(OLECHAR), &uWritten);
    ASSERT(SUCCEEDED(hr));
    return hr;
}

HRESULT
CIISMBNode::BuildURL(
    OUT CComBSTR & bstrURL
    ) const
/*++

Routine Description:

    Recursively build up the URL from the current node
    and its parents.

Arguments:

    CComBSTR & bstrURL : Returns URL

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    //
    // Prepend parent portion
    //
    CIISMBNode * pNode = GetParentNode();

    if (pNode)
    {
        hr = pNode->BuildURL(bstrURL);

        //
        // And our portion
        //
        if (SUCCEEDED(hr))
        {
            bstrURL.Append(_cszSeparator);
            bstrURL.Append(QueryNodeName());
        }

        return hr;
    }

    //
    // No parent node
    //
    ASSERT_MSG("No parent node");
    return E_UNEXPECTED;
}



BOOL
CIISMBNode::OnLostInterface(
    IN OUT CError & err
    )
/*++

Routine Description:

    Deal with lost interface.  Ask the user to reconnect.

Arguments:

    CError & err        : Error object

Return Value:

    TRUE if the interface was successfully recreated.
    FALSE otherwise.  If it tried and failed the error will

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CString str;
    str.Format(IDS_RECONNECT_WARNING, QueryMachineName());

    if (YesNoMessageBox(str))
    {
        //
        // Attempt to recreate the interface
        //
        err = CreateInterface(TRUE);
        return err.Succeeded();
    }
    
    return FALSE;
}

HRESULT
CIISMBNode::DeleteNode(IResultData * pResult)
{
   CError err;

   if (!NoYesMessageBox(IDS_CONFIRM_DELETE))
      return err;

   do
   {
      CComBSTR path;
      CMetaInterface * pInterface = QueryInterface();
      ASSERT(pInterface != NULL);
      err = BuildMetaPath(path);
      if (err.Failed()) 
         break;
      CMetaKey mk(pInterface, METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_WRITE);
      if (!mk.Succeeded())
         break;
      err = mk.DeleteKey(path);
      if (err.Failed()) 
         break;

      err = RemoveScopeItem();

   } while (FALSE);

   if (err.Failed())
   {
      DisplayError(err);
   }
   return err;
}

HRESULT
CIISMBNode::EnumerateVDirs(HSCOPEITEM hParent, CIISService * pService)
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent              : Parent console handle
    CIISService * pService          : Service type

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(pService);

    CError  err;
    CString strVRoot;
    CMetaEnumerator * pme = NULL;

    err = CreateEnumerator(pme);
        
    while (err.Succeeded())
    {
        CIISDirectory * pDir;

        err = pme->Next(strVRoot);

        if (err.Succeeded())
        {
            TRACEEOLID("Enumerating node: " << strVRoot);

            CChildNodeProps child(pme, strVRoot, WITH_INHERITANCE, FALSE);
            err = child.LoadData();
            DWORD dwWin32Error = err.Win32Error();

            if (err.Failed())
            {
                //
                // Filter out the non-fatal errors
                //
                switch(err.Win32Error())
                {
                case ERROR_ACCESS_DENIED:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    err.Reset();
                    break;

                default:
                    TRACEEOLID("Fatal error occurred " << err);
                }
            }

            if (err.Succeeded())
            {
                //
                // Skip non-virtual directories (that is, those with
                // inherited vrpaths)
                //
                if (!child.IsPathInherited())
                {
                    //
                    // Construct with full information.
                    //
                    pDir = new CIISDirectory(
                        m_pOwner,
                        pService,
                        strVRoot,
                        child.IsEnabledApplication(),
                        child.QueryWin32Error(),
                        child.GetRedirectedPath()
                        );

                    if (!pDir)
                    {
                        err = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }

                    err = pDir->AddToScopePane(hParent);
                }
            }
        }
    }

    SAFE_DELETE(pme);

    if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
    {
        err.Reset();
    }

    if (err.Failed())
    {
        DisplayError(err);
    }

//    SetInterfaceError(err);

    return err;
}

BOOL 
CIISMBNode::GetPhysicalPath(
    LPCTSTR metaPath,
    CString & alias,
    CString & physicalPath
    )
/*++

Routine Description:

    Build a physical path for the current node.  Starting with the current
    node, walk up the tree appending node names until a virtual directory
    with a real physical path is found

Arguments:

    CString & physicalPath       : Returns file path

Return Value:

    Pointer to path

--*/
{
    if (CMetabasePath::IsMasterInstance(metaPath))
        return FALSE;

    BOOL fInherit = FALSE;
    CMetaInterface * pInterface = QueryInterface();
    ASSERT(pInterface != NULL);
    CMetaKey mk(pInterface);
    CError err(mk.QueryValue(
        MD_VR_PATH, 
        physicalPath, 
        &fInherit, 
        metaPath
        ));

    if (err.Failed())
    {
        CString lastNode;
        CMetabasePath::GetLastNodeName(metaPath, lastNode);
        PathAppend(lastNode.GetBuffer(MAX_PATH), alias);
        lastNode.ReleaseBuffer();
        CString buf(metaPath);
        if (NULL == CMetabasePath::ConvertToParentPath(buf))
        {
            return FALSE;
        }
        else if (GetPhysicalPath(buf, lastNode, physicalPath))
        {
           return TRUE;
        }
    }
    if (!alias.IsEmpty())
    {
        PathAppend(physicalPath.GetBuffer(MAX_PATH), alias);
        physicalPath.ReleaseBuffer();
    }
    return TRUE;
}

HRESULT
CIISMBNode::CleanResult(IResultData * lpResultData)
{
   CError err;

   if (!m_ResultItems.IsEmpty())
   {
      POSITION pos = m_ResultItems.GetHeadPosition();
      while (pos != NULL)
      {
         CIISFileName * pNode = m_ResultItems.GetNext(pos);
		 err = lpResultData->DeleteItem(pNode->m_hResultItem, 0);
		 if (err.Failed())
		 {
			 ASSERT(FALSE);
			 break;
		 }
         delete pNode;
      }
      m_ResultItems.RemoveAll();
   }
   return err;
}

HRESULT 
CIISMBNode::EnumerateResultPane_(
    BOOL fExpand, 
    IHeaderCtrl * lpHeader,
    IResultData * lpResultData,
    CIISService * pService
    )
{
	CError err;
    if (HasFileSystemFiles())
    {
       if (fExpand)
       {
          do
          {
              CString dir;
              CComBSTR root;
              BuildMetaPath(root);
              CString physPath, alias;
              GetPhysicalPath(CString(root), alias, physPath);

              if (pService->IsLocal() || PathIsUNC(physPath))
              {
                  dir = physPath;
              }
              else
              {
                  ::MakeUNCPath(dir, pService->QueryMachineName(), physPath);
              }

              dir.TrimLeft();
              dir.TrimRight();

              if (dir.IsEmpty())
              {
                  break;
              }

			  if (PathIsUNCServerShare(dir))
			  {
				  CString server, share;
				  int idx = dir.ReverseFind(_T('\\'));
				  ASSERT(idx != -1);
				  server = dir.Left(idx);
				  share = dir.Mid(++idx);
				  LPBYTE pbuf = NULL;
				  NET_API_STATUS rc = NetShareGetInfo((LPTSTR)(LPCTSTR)server, (LPTSTR)(LPCTSTR)share, 0, &pbuf);
				  if (NERR_Success == rc)
				  {
					  NetApiBufferFree(pbuf);
				  }
				  else
				  {
					  err = ERROR_BAD_NETPATH;
					  break;
				  }
			  }

              dir += _T("\\*");
              WIN32_FIND_DATA w32data;
              HANDLE hFind = ::FindFirstFile(dir, &w32data);

              if (hFind == INVALID_HANDLE_VALUE)
              {
                  err.GetLastWinError();
				  ASSERT(FALSE);
                  break;
              }

              do
              {
                 LPCTSTR name = w32data.cFileName;
                 if ((w32data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                 {
                    CIISFileName * pNode = new CIISFileName(
                       GetOwner(), 
                       pService, 
                       w32data.dwFileAttributes, 
                       name, 
                       NULL);
                    if (!pNode)
                    {
                       err = ERROR_NOT_ENOUGH_MEMORY;
                       break;
                    }
                   RESULTDATAITEM ri;
                   ::ZeroMemory(&ri, sizeof(ri));
                   ri.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                   ri.str = MMC_CALLBACK;
                   ri.nImage = pNode->QueryImage();
                   ri.lParam = (LPARAM)pNode;
                   err = lpResultData->InsertItem(&ri);
                   if (err.Succeeded())
                   {
                      pNode->SetScopeItem(m_hScopeItem);
                      pNode->SetResultItem(ri.itemID);
                      m_ResultItems.AddTail(pNode);
                   }
                   else
                   {
                      delete pNode;
                   }
                 }

              } while (err.Succeeded() && FindNextFile(hFind, &w32data));

              FindClose(hFind);

          } while (FALSE);
       }
       else
       {
          RemoveResultItems();
       }
    }
    ASSERT(err.Succeeded());
    return err;
}


void
CIISMBNode::RemoveResultItems()
{
   if (!m_ResultItems.IsEmpty())
   {
      POSITION pos = m_ResultItems.GetHeadPosition();
      while (pos != NULL)
      {
         CIISFileName * pNode = m_ResultItems.GetNext(pos);
         delete pNode;
      }
      m_ResultItems.RemoveAll();
   }
}


HRESULT
CIISMBNode::EnumerateWebDirs(HSCOPEITEM hParent, CIISService * pService)
/*++

Routine Description:

    Enumerate scope file system child items.

Arguments:

    HSCOPEITEM hParent              : Parent console handle
    CIISService * pService          : Service type

Return Value:

    HRESULT

--*/
{
    ASSERT_PTR(pService);
    CError err;
    do
    {
        CString dir;
        CComBSTR root;
        BuildMetaPath(root);
        CString physPath, alias;
        GetPhysicalPath(CString(root), alias, physPath);

        if (pService->IsLocal() || PathIsUNC(physPath))
        {
            dir = physPath;
        }
        else
        {
            ::MakeUNCPath(dir, pService->QueryMachineName(), physPath);
        }
        dir.TrimLeft();
        dir.TrimRight();
        if (dir.IsEmpty())
        {
            break;
        }

        // Prepare for target machine metabase lookup
        BOOL fCheckMetabase = TRUE;
        CMetaKey mk(QueryInterface(), root, METADATA_PERMISSION_READ, METADATA_MASTER_ROOT_HANDLE);
        CError errMB(mk.QueryResult());
        if (errMB.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
           //
           // Metabase path not found, not a problem.
           //
           fCheckMetabase = FALSE;
           errMB.Reset();
        }

        // We could have vroot pointed to target machine, or to another remote machine.
        // Check if this resource is available and we have access to this resource
        if (PathIsUNC(dir))
        {
            CString server, user, password;

            server = PathFindNextComponent(dir);
            int n = server.Find(_T('\\'));
            if (n != -1)
            {
                server = server.Left(n);
            }
            user = QueryInterface()->QueryAuthInfo()->QueryUserName();
            password = QueryInterface()->QueryAuthInfo()->QueryPassword();
            if (server.CompareNoCase(pService->QueryMachineName()) != 0)
            {
                // non-local resource, get connection credentials
                if (fCheckMetabase)
                {
                    err = mk.QueryValue(MD_VR_USERNAME, user);
                    if (err.Succeeded())
                    {
                        err = mk.QueryValue(MD_VR_PASSWORD, password);
                    }
                    // these credentials could be empty. try defaults
                    err.Reset();
                }
            }
            // Add use for this resource
            NETRESOURCE nr;
            nr.dwType = RESOURCETYPE_DISK;
            nr.lpLocalName = NULL;
            nr.lpRemoteName = (LPTSTR)(LPCTSTR)dir;
            nr.lpProvider = NULL;
            // Empty strings below mean no password, which is wrong. NULLs mean
            // default user and default password -- this could work better for local case.
            LPCTSTR p1 = password, p2 = user;
            if (password.IsEmpty())
            {
                p1 = NULL;
            }
            if (user.IsEmpty())
            {
                p2 = NULL;
            }
            DWORD rc = WNetAddConnection2(&nr, p1, p2, 0);
            if (NO_ERROR != rc)
            {
                err = rc;
                break;
            }
        }
#if 0
        // This is obsolete now
	    if (PathIsUNCServerShare(dir))
		{
		    CString server, share;
		    int idx = dir.ReverseFind(_T('\\'));
		    ASSERT(idx != -1);
		    server = dir.Left(idx);
		    share = dir.Mid(++idx);
		    LPBYTE pbuf = NULL;
		    NET_API_STATUS rc = NetShareGetInfo((LPTSTR)(LPCTSTR)server, (LPTSTR)(LPCTSTR)share, 0, &pbuf);
		    if (NERR_Success == rc)
			{
			    NetApiBufferFree(pbuf);
			}
		    else
			{
			    err = ERROR_BAD_NETPATH;
			    break;
			}
		}
#endif
        dir += _T("\\*");
        WIN32_FIND_DATA w32data;
        HANDLE hFind = ::FindFirstFile(dir, &w32data);

        if (hFind == INVALID_HANDLE_VALUE)
        {
            err.GetLastWinError();
            break;
        }
        do
        {
           LPCTSTR name = w32data.cFileName;
           if (  (w32data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 
              && lstrcmp(name, _T(".")) != 0 
              && lstrcmp(name, _T("..")) != 0
              )
           {
              CIISFileName * pNode = new CIISFileName(m_pOwner, 
                    pService, w32data.dwFileAttributes, name, NULL);
              if (!pNode)
              {
                 err = ERROR_NOT_ENOUGH_MEMORY;
                 break;
              }
              if (fCheckMetabase)
              {
                 errMB = mk.DoesPathExist(w32data.cFileName);
                 if (errMB.Succeeded())
                 {
                    //
                    // Match up with metabase properties.  If the item
                    // is found in the metabase with a non-inherited vrpath,
                    // than a virtual root with this name exists, and this 
                    // file/directory should not be shown.
                    //
                    CString vrpath;
                    BOOL f = FALSE;
                    DWORD attr = 0;
                    errMB = mk.QueryValue(MD_VR_PATH, vrpath, NULL, w32data.cFileName, &attr);
                    if (errMB.Succeeded() && (attr & METADATA_ISINHERITED) == 0) 
                    {
                       TRACEEOLID("file/directory exists as vroot -- tossing" << w32data.cFileName);
                       delete pNode;
                       continue;
                    }
                 }
              }
              err = pNode->AddToScopePane(hParent);
           }
        } while (err.Succeeded() && FindNextFile(hFind, &w32data));

        FindClose(hFind);

    } while (FALSE);

    if (err.Failed())
    {
        DisplayError(err);
    }
    return err;
}

HRESULT 
CIISMBNode::CreateEnumerator(CMetaEnumerator *& pEnum)
/*++

Routine Description:

    Create enumerator object for the current path.  Requires interface
    to already be initialized

Arguments:

    CMetaEnumerator *& pEnum                : Returns enumerator

Return Value:

    HRESULT

--*/
{
    ASSERT(pEnum == NULL);
    ASSERT(m_hScopeItem != NULL);

    CComBSTR bstrPath;

    CError err(BuildMetaPath(bstrPath));

    if (err.Succeeded())
    {
        TRACEEOLID("Build metabase path: " << bstrPath);

        BOOL fContinue = TRUE;

        while(fContinue)
        {
            fContinue = FALSE;

            pEnum = new CMetaEnumerator(QueryInterface(), bstrPath);

            err = pEnum ? pEnum->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

            if (IsLostInterface(err))
            {
                SAFE_DELETE(pEnum);

                fContinue = OnLostInterface(err);
            }
        }
    }

    return err;
}



/* virtual */ 
HRESULT 
CIISMBNode::Refresh(BOOL fReEnumerate)
/*++

Routine Description:
    Refresh current node, and optionally re-enumerate child objects

Arguments:
    BOOL fReEnumerate       : If true, kill child objects, and re-enumerate

--*/
{
    CError err;

    //
    // Set MFC state for wait cursor
    //
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    CWaitCursor wait;

    if (fReEnumerate)
    {
        //
        // Kill child objects
        //
        TRACEEOLID("Killing child objects");

        ASSERT(m_hScopeItem != NULL);
        err = RemoveChildren(m_hScopeItem);

        if (err.Succeeded())
        {
            err = EnumerateScopePane(m_hScopeItem);
        }
    }

    if (err.Succeeded())
    {
        //
        // Refresh current node
        //
        err = RefreshData();
        if (err.Succeeded())
        {
            err = RefreshDisplay();
        }
    }

    return err;
}

/* virtual */
HRESULT
CIISMBNode::GetResultViewType(
    OUT LPOLESTR * lplpViewType,
    OUT long * lpViewOptions
    )
/*++

Routine Description:

    If we have an URL built up, display our result view as that URL,
    and destroy it.  This is done when 'browsing' a metabase node.
    The derived class will build the URL, and reselect the node.

Arguments:

    BSTR * lplpViewType   : Return view type here
    long * lpViewOptions  : View options

Return Value:

    S_FALSE to use default view type, S_OK indicates the
    view type is returned in *ppViewType

--*/
{
    if (m_bstrURL.Length())
    {
        *lpViewOptions = MMC_VIEW_OPTIONS_NONE;
        *lplpViewType  = (LPOLESTR)::CoTaskMemAlloc(
            (m_bstrURL.Length() + 1) * sizeof(WCHAR)
            );

        if (*lplpViewType)
        {
            lstrcpy(*lplpViewType, m_bstrURL);

            //
            // Destroy URL so we get a normal result view next time
            //
            m_bstrURL.Empty();
			m_fSkipEnumResult = TRUE;
            return S_OK;
        }

        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);    
    }

    //
    // No URL waiting -- use standard result view
    //
    return CIISObject::GetResultViewType(lplpViewType, lpViewOptions);
}


HRESULT
ShellExecuteDirectory(
    IN LPCTSTR lpszCommand,
    IN LPCTSTR lpszOwner,
    IN LPCTSTR lpszDirectory
    )
/*++

Routine Description:

    Shell Open or explore on a given directory path

Arguments:

    LPCTSTR lpszCommand    : "open" or "explore"
    LPCTSTR lpszOwner      : Owner server
    LPCTSTR lpszDirectory  : Directory path

Return Value:

    Error return code.

--*/
{
    CString strDir;

    if (::IsServerLocal(lpszOwner) || ::IsUNCName(lpszDirectory))
    {
        //
        // Local directory, or already a unc path
        //
        strDir = lpszDirectory;
    }
    else
    {
        ::MakeUNCPath(strDir, lpszOwner, lpszDirectory);
    }

    TRACEEOLID("Attempting to " << lpszCommand << " Path: " << strDir);

    CError err;
    {
        //
        // AFX_MANAGE_STATE required for wait cursor
        //
        AFX_MANAGE_STATE(::AfxGetStaticModuleState() );
        CWaitCursor wait;

        if (::ShellExecute(
            NULL, 
            lpszCommand, 
            strDir, 
            NULL,
            _T(""), 
            SW_SHOW
            ) <= (HINSTANCE)32)
        {
            err.GetLastWinError();
        }
    }

    return err;
}


HRESULT
CIISMBNode::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    CError err = ERROR_NOT_ENOUGH_MEMORY;

    switch (lCommandID)
    {
    case IDM_BROWSE:
        //
        // Build URL for this node, and force a re-select so as to change
        // the result view
        //
        BuildURL(m_bstrURL);

        if (m_bstrURL.Length())
        {
            //
            // After selection, the browsed URL will come up in the result view
            //
            SelectScopeItem();
        }
        break;

    //
    // CODEWORK:  Build path, and, using the explorer URL, put this stuff
    //            in the result view.
    //
    case IDM_OPEN:
    {
       CComBSTR meta_path;
       CString phys_path, alias;
       BuildMetaPath(meta_path);
       if (GetPhysicalPath(meta_path, alias, phys_path))
       {
           hr = ShellExecuteDirectory(_T("open"), QueryMachineName(), phys_path);
       }
    }
       break;

    case IDM_EXPLORE:
    {
       CComBSTR meta_path;
       CString phys_path, alias;
       BuildMetaPath(meta_path);
       if (GetPhysicalPath(meta_path, alias, phys_path))
       {
           TCHAR url[MAX_PATH];
           DWORD len = MAX_PATH;
           hr = UrlCreateFromPath(phys_path, url, &len, NULL);
           m_bstrURL = url;
           SelectScopeItem();
       }
    }
       break;

    case IDM_TASK_SECURITY_WIZARD:
    {
       CComBSTR path;
       VERIFY(SUCCEEDED(BuildMetaPath(path)));
       hr = RunSecurityWizard(QueryAuthInfo(), 
           QueryInterface(), CString(path), 
           IDB_WIZ_FTP_LEFT_SEC, IDB_WIZ_FTP_HEAD_SEC);
    }
       break;
    //
    // Pass on to base class
    //
    default:
        hr = CIISObject::Command(lCommandID, pObj, type);
    }

    return hr;
}

HRESULT
CIISMBNode::OnPropertyChange(BOOL fScope, IResultData * pResult)
{
	CError err;

	err = Refresh(fScope);
    if (err.Succeeded())
	{
		if (	fScope 
			&&	HasFileSystemFiles()
			&&	!m_ResultItems.IsEmpty()
			)
		{
			err = CleanResult(pResult);
			if (err.Succeeded())
			{
				err = EnumerateResultPane(fScope, NULL, pResult);
			}
		}
		else if (!fScope)
		{
			pResult->UpdateItem(m_hResultItem);
		}

	}

	return err;
}

HRESULT
CIISMBNode::RemoveResultNode(CIISMBNode * pNode, IResultData * pResult)
{
	CError err;
	ASSERT(HasFileSystemFiles());
	err = pResult->DeleteItem(pNode->m_hResultItem, 0);
	if (err.Succeeded())
	{
		BOOL found = FALSE;
		POSITION pos = m_ResultItems.GetHeadPosition();
		while (pos != NULL)
		{
			if (m_ResultItems.GetNext(pos) == pNode)
			{
				found = TRUE;
				break;
			}
		}
		if (found)
		{
			m_ResultItems.RemoveAt(pos);
			delete pNode;
		}
	}
	return err;
}


// See FtpAddNew.cpp for the method CIISMBNode::AddFTPSite
// See WebAddNew.cpp for the method CIISMBNode::AddWebSite
// See add_app_pool.cpp for the method CIISMBNode::AddAppPool
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\iissite.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        iissite.cpp

   Abstract:
        IIS Site Object

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        10/28/2000      sergeia     Split from iisobj.cpp

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "machsht.h"
#include "errors.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW

//
// CIISSite implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Site Result View definition
//
/* static */ int 
CIISSite::_rgnLabels[COL_TOTAL] =
{
    IDS_RESULT_SERVICE_DESCRIPTION,
    IDS_RESULT_SERVICE_STATE,
    IDS_RESULT_SERVICE_DOMAIN_NAME,
    IDS_RESULT_SERVICE_IP_ADDRESS,
    IDS_RESULT_SERVICE_TCP_PORT,
    IDS_RESULT_STATUS,
};
    

/* static */ int 
CIISSite::_rgnWidths[COL_TOTAL] =
{
    180,
    70,
    120,
    105,
    40,
    200,
};



/* static */ CComBSTR CIISSite::_bstrStarted;
/* static */ CComBSTR CIISSite::_bstrStopped;
/* static */ CComBSTR CIISSite::_bstrPaused;
/* static */ CComBSTR CIISSite::_bstrUnknown;
/* static */ CComBSTR CIISSite::_bstrPending;
/* static */ CComBSTR CIISSite::_bstrAllUnassigned;
/* static */ BOOL     CIISSite::_fStaticsLoaded = FALSE;



/* static */
void
CIISSite::InitializeHeaders(LPHEADERCTRL lpHeader)
/*++

Routine Description:

    Initialize the result headers

Arguments:

    LPHEADERCTRL lpHeader : Header control

Return Value:

    None

--*/
{
    CIISObject::BuildResultView(lpHeader, COL_TOTAL, _rgnLabels, _rgnWidths);
//	CIISDirectory::InitializeHeaders(lpHeader);
    if (!_fStaticsLoaded)
    {
        _fStaticsLoaded =
            _bstrStarted.LoadString(IDS_STARTED)  &&
            _bstrStopped.LoadString(IDS_STOPPED)  &&
            _bstrPaused.LoadString(IDS_PAUSED)    &&
            _bstrUnknown.LoadString(IDS_UNKNOWN)  &&
            _bstrPending.LoadString(IDS_PENDING)  &&
            _bstrAllUnassigned.LoadString(IDS_IP_ALL_UNASSIGNED);
    }
}


/* virtual */
void 
CIISSite::InitializeChildHeaders(
    IN LPHEADERCTRL lpHeader
    )
/*++

Routine Description:

    Build result view for immediate descendant type

Arguments:

    LPHEADERCTRL lpHeader      : Header control

Return Value:

    None

--*/
{
    CIISDirectory::InitializeHeaders(lpHeader);
}


CIISSite::CIISSite(
    IN CIISMachine * pOwner,
    IN CIISService * pService,
    IN LPCTSTR szNodeName
    )
/*++

Routine Description:

    Constructor.  Determine if the given service is administrable, 
    and resolve the details

Arguments:

    CIISMachine * pOwner        : Owner machine object
    CIISService * pService      : Service type
    LPCTSTR szNodeName          : Node name (numeric)

Return Value:

    N/A

Notes:

    This constructor does not immediately resolve the display name of the 
    site.  It will only resolve its display information when asked

--*/
    : CIISMBNode(pOwner, szNodeName),
      m_pService(pService),
      m_fResolved(FALSE),
      m_strDisplayName(),
      //
      // Data members -- plonk in some defaults
      //
      m_dwState(MD_SERVER_STATE_INVALID),
      m_fDeletable(FALSE),
      m_fWolfPackEnabled(FALSE),
      m_fFrontPageWeb(FALSE),
      m_sPort(80),
      m_dwID(::_ttol(szNodeName)),
      m_dwIPAddress(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_bstrHostHeaderName(),
      m_bstrComment()
{
    ASSERT_PTR(m_pService);
}



CIISSite::CIISSite(
    IN CIISMachine * pOwner,
    IN CIISService * pService,
    IN LPCTSTR  szNodeName,
    IN DWORD    dwState,
    IN BOOL     fDeletable,
    IN BOOL     fClusterEnabled,
    IN USHORT   sPort,
    IN DWORD    dwID,
    IN DWORD    dwIPAddress,
    IN DWORD    dwWin32Error,
    IN LPOLESTR szHostHeaderName,
    IN LPOLESTR szComment
    )
/*++

Routine Description:

    Construct with full information

Arguments:

    CIISMachine * pOwner        : Owner machine object
    CIISService * pService      : Service type
    LPCTSTR szNodeName          : Node name (numeric)

    plus datamembers

Return Value:

    N/A

--*/
    : CIISMBNode(pOwner, szNodeName),
      m_pService(pService),
      m_fResolved(TRUE),
      m_strDisplayName(),
      //
      // Data Members
      //
      m_dwState(dwState),
      m_fDeletable(fDeletable),
      m_fWolfPackEnabled(fClusterEnabled),
      m_sPort(sPort),
      m_dwID(dwID),
      m_dwIPAddress(dwIPAddress),
      m_dwWin32Error(dwWin32Error),
      m_bstrHostHeaderName(szHostHeaderName),
      m_bstrComment(szComment)
{
    ASSERT_PTR(m_pService);
}



CIISSite::~CIISSite()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



/* virtual */
HRESULT
CIISSite::RefreshData()
/*++

Routine Description:

    Refresh relevant configuration data required for display.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    CWaitCursor wait;
    CComBSTR bstrPath;
    CMetaKey * pKey = NULL;

    do
    {
        ASSERT_PTR(_lpConsoleNameSpace);
        err = BuildMetaPath(bstrPath);
        BREAK_ON_ERR_FAILURE(err);
        // We need instance key here
        CString path_inst;
        CMetabasePath::GetInstancePath(bstrPath, path_inst);

        BOOL fContinue = TRUE;
        while (fContinue)
        {
            fContinue = FALSE;
            if (NULL == (pKey = new CMetaKey(QueryInterface(), path_inst)))
            {
                TRACEEOLID("RefreshData: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            err = pKey->QueryResult();
            if (IsLostInterface(err))
            {
                SAFE_DELETE(pKey);
                fContinue = OnLostInterface(err);
            }
        }
        BREAK_ON_ERR_FAILURE(err);

        CInstanceProps inst(pKey, _T(""), m_dwID);
        err = inst.LoadData();

        BREAK_ON_ERR_FAILURE(err);

        m_dwState = inst.m_dwState;
        m_fDeletable = !inst.m_fNotDeletable;

        //
        // Don't be confused -- cluster enabled refers
        // to wolfpack and has nothing to do with app server
        //
        m_fWolfPackEnabled = inst.IsClusterEnabled();
        m_sPort = (SHORT)inst.m_nTCPPort;
        m_dwID = inst.QueryInstance();
        m_dwIPAddress = inst.m_iaIpAddress;
        m_dwWin32Error = inst.m_dwWin32Error;
        m_bstrHostHeaderName = inst.m_strDomainName;
        m_bstrComment = inst.m_strComment;
		  m_strDisplayName.Empty();
        // Check if it is Frontpage controlled site
        pKey->QueryValue(MD_FRONTPAGE_WEB, m_fFrontPageWeb);

        CChildNodeProps child(pKey, SZ_MBN_ROOT);
        err = child.LoadData();
        BREAK_ON_ERR_FAILURE(err);

        m_strRedirectPath = child.GetRedirectedPath();
    }
    while(FALSE);

    SAFE_DELETE(pKey);

    if (m_dwWin32Error == ERROR_SUCCESS)
    {
        m_dwWin32Error = err.Win32Error();
    }

    return err;
}



/* virtual */
int      
CIISSite::QueryImage() const
/*++

Routine Description:

    Return bitmap index for the site

Arguments:

    None

Return Value:

    Bitmap index

--*/
{ 
    ASSERT_PTR(m_pService);
    if (!m_fResolved)
    {
        TRACEEOLID("Resolving name for site #" << QueryNodeName());

        if (m_hScopeItem == NULL)
        {
            //
            // BUGBUG:
            //
            // This is probably related to MMC bug #324519
            // where we're asked for the display info immediately
            // after adding the item to the console view.  This
            // appears to fail only on refresh because the scope
            // item handle is missing, and we can't build a metabase
            // path yet.
            //
            TRACEEOLID("BUGBUG: Prematurely asked for display information");
            //ASSERT(FALSE);
            return iError;
        }
	    CIISSite * that = (CIISSite *)this;
        CError err = that->RefreshData();
        that->m_fResolved = err.Succeeded();
    }
    return !m_dwWin32Error && m_pService ? m_pService->QuerySiteImage() : iError;
}



/* virtual */
LPOLESTR 
CIISSite::QueryDisplayName()
/*++

Routine Description:

    Return primary display name of this site.
    
Arguments:

    None

Return Value:

    The display name

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    if (!m_fResolved)
    {
        TRACEEOLID("Resolving name for site #" << QueryNodeName());

        if (m_hScopeItem == NULL)
        {
            //
            // BUGBUG:
            //
            // This is probably related to MMC bug #324519
            // where we're asked for the display info immediately
            // after adding the item to the console view.  This
            // appears to fail only on refresh because the scope
            // item handle is missing, and we can't build a metabase
            // path yet.
            //
            TRACEEOLID("BUGBUG: Prematurely asked for display information");
            //ASSERT(FALSE);
            return OLESTR("");
        }

        CError err = RefreshData();
        m_fResolved = err.Succeeded();
    }

    if (m_strDisplayName.IsEmpty())
    {
        CIPAddress ia(m_dwIPAddress);
        CInstanceProps::GetDisplayText(
            m_strDisplayName,
            m_bstrComment,
            m_bstrHostHeaderName,
            ia,
            m_sPort,
            m_dwID
            );
    }
    CString buf = m_strDisplayName;
    if (m_dwState == MD_SERVER_STATE_STOPPED)
    {
        buf.Format(IDS_STOPPED_SITE_FMT, m_strDisplayName);
    }
    else if (m_dwState == MD_SERVER_STATE_PAUSED)
    {
        buf.Format(IDS_PAUSED_SITE_FMT, m_strDisplayName);
    }
    m_bstrDisplayNameStatus = buf;
//    return (LPTSTR)(LPCTSTR)m_strDisplayName;
    return m_bstrDisplayNameStatus;
}



/* virtual */
LPOLESTR 
CIISSite::GetResultPaneColInfo(int nCol)
/*++

Routine Description:

    Return result pane string for the given column number

Arguments:

    int nCol        : Column number

Return Value:

    String

--*/
{
    ASSERT(_fStaticsLoaded);

    TCHAR sz[255];

    switch(nCol)
    {
    case COL_DESCRIPTION:
        return QueryDisplayName();

    case COL_STATE:
        switch(m_dwState)
        {
        case MD_SERVER_STATE_STARTED:
            return _bstrStarted;

        case MD_SERVER_STATE_PAUSED:
            return _bstrPaused;

        case MD_SERVER_STATE_STOPPED:
            return _bstrStopped;

        case MD_SERVER_STATE_STARTING:
        case MD_SERVER_STATE_PAUSING:
        case MD_SERVER_STATE_CONTINUING:
        case MD_SERVER_STATE_STOPPING:
            return _bstrPending;
        }

        return OLESTR("");

    case COL_DOMAIN_NAME:
        return m_bstrHostHeaderName;

    case COL_IP_ADDRESS:
        {
            CIPAddress ia(m_dwIPAddress);

            if (ia.IsZeroValue())
            {
                _bstrResult = _bstrAllUnassigned;
            }
            else
            {
                _bstrResult = ia;
            }
        }
        return _bstrResult;

    case COL_TCP_PORT:
        _bstrResult = ::_itot(m_sPort, sz, 10);
        return _bstrResult;

    case COL_STATUS:
        {
            AFX_MANAGE_STATE(::AfxGetStaticModuleState());

            CError err(m_dwWin32Error);
            if (err.Succeeded())
            {
                return OLESTR("");
            }
        
            _bstrResult = err;
        }
        return _bstrResult;
    }

    ASSERT_MSG("Bad column number");

    return OLESTR("");
}



/* virtual */
int 
CIISSite::CompareResultPaneItem(CIISObject * pObject, int nCol)
/*++

Routine Description:

    Compare two CIISObjects on sort item criteria

Arguments:

    CIISObject * pObject : Object to compare against
    int nCol             : Column number to sort on

Return Value:

    0  if the two objects are identical
    <0 if this object is less than pObject
    >0 if this object is greater than pObject

--*/
{
    ASSERT_READ_PTR(pObject);

    if (nCol == 0)
    {
        return CompareScopeItem(pObject);
    }

    //
    // First criteria is object type
    //
    int n1 = QuerySortWeight();
    int n2 = pObject->QuerySortWeight();

    if (n1 != n2)
    {
        return n1 - n2;
    }

    //
    // Both are CIISSite objects
    //
    CIISSite * pSite = (CIISSite *)pObject;

    switch(nCol)
    {
    //
    // Special case columns
    //
    case COL_IP_ADDRESS:
        {
            CIPAddress ia1(m_dwIPAddress);
            CIPAddress ia2(pSite->QueryIPAddress());
            
            return ia1.CompareItem(ia2);
        }

    case COL_TCP_PORT:
        n1 = QueryPort();
        n2 = pSite->QueryPort();
        return n1 - n2;

    case COL_STATUS:
        {
            DWORD dw1 = QueryWin32Error();
            DWORD dw2 = pSite->QueryWin32Error();

            return dw1 - dw2;
        }

    case COL_DESCRIPTION:
    case COL_STATE:
    case COL_DOMAIN_NAME:
    default:
        //
        // Lexical sort
        //
        return ::lstrcmpi(
            GetResultPaneColInfo(nCol), 
            pObject->GetResultPaneColInfo(nCol)
            );
    }
}



/* virtual */
HRESULT 
CIISSite::BuildURL(CComBSTR & bstrURL) const
/*++

Routine Description:

    Recursively build up the URL from the current node
    and its parents.  For a site node, add the machine name.

Arguments:

    CComBSTR & bstrURL  : Returns URL

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    //
    // Prepend parent portion (protocol in this case)
    //
    CIISMBNode * pNode = GetParentNode();

    if (pNode)
    {
        hr = pNode->BuildURL(bstrURL);
    }

    if (SUCCEEDED(hr))
    {
        CString strOwner;

        ///////////////////////////////////////////////////////////////////////////
        //
        // Try to build an URL.  Use in order of priority:
        //
        //     Domain name:port/root
        //     ip address:port/root
        //     computer name:port/root
        //    
        if (m_bstrHostHeaderName.Length())
        {
            strOwner = m_bstrHostHeaderName;
        }
        else if (m_dwIPAddress != 0L)
        {
            CIPAddress ia(m_dwIPAddress);
            ia.QueryIPAddress(strOwner);
        }
        else
        {
            if (IsLocal())
            {
                //
                // Security reasons restrict this to "localhost" oftentimes
                //
                strOwner = _bstrLocalHost;
            }
            else
            {
                LPOLESTR lpOwner = QueryMachineName();
                strOwner = PURE_COMPUTER_NAME(lpOwner);
            }
        }

        TCHAR szPort[6]; // 65536 max.
        _itot(m_sPort, szPort, 10);

        strOwner += _T(":");
        strOwner += szPort;

        bstrURL.Append(strOwner);
    }

    return hr;
}


/*virtual*/
HRESULT
CIISSite::AddMenuItems(
    LPCONTEXTMENUCALLBACK piCallback,
    long * pInsertionAllowed,
    DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(piCallback);
    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        piCallback,
        pInsertionAllowed,
        type
        );
    if (SUCCEEDED(hr))
    {
       ASSERT(pInsertionAllowed != NULL);
       if ((*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
       {
           AddMenuSeparator(piCallback);
           if (IsFtpSite())
           {
              if (GetOwner()->CanAddInstance() && !GetOwner()->Has10ConnectionsLimit())
              {
                 AddMenuItemByCommand(piCallback, IDM_NEW_FTP_SITE);
              }
              AddMenuItemByCommand(piCallback, IDM_NEW_FTP_VDIR);
           }
           else if (IsWebSite())
           {
              if (GetOwner()->CanAddInstance() && !GetOwner()->Has10ConnectionsLimit())
              {
                 AddMenuItemByCommand(piCallback, IDM_NEW_WEB_SITE);
              }
              AddMenuItemByCommand(piCallback, IDM_NEW_WEB_VDIR);
           }
       }
       if (!m_fFrontPageWeb && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0)
       {
           AddMenuSeparator(piCallback);
           AddMenuItemByCommand(piCallback, IDM_TASK_SECURITY_WIZARD);
       }
    }
    return hr;
}

HRESULT
CIISSite::InsertNewInstance(DWORD inst)
{
	return m_pService->InsertNewInstance(inst);
}

HRESULT
CIISSite::InsertNewAlias(CString alias)
{
    CError err;
    // Now we should insert and select this new site
    CIISDirectory * pAlias = new CIISDirectory(m_pOwner, m_pService, alias);
    if (pAlias != NULL)
    {
        // If item is not expanded we will get error and no effect
        if (!IsExpanded())
        {
            SelectScopeItem();
            IConsoleNameSpace2 * pConsole 
                    = (IConsoleNameSpace2 *)GetConsoleNameSpace();
            pConsole->Expand(QueryScopeItem());
        }
        err = pAlias->AddToScopePaneSorted(QueryScopeItem(), FALSE);
        if (err.Succeeded())
        {
            VERIFY(SUCCEEDED(pAlias->SelectScopeItem()));
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    return err;
}

/* virtual */
HRESULT
CIISSite::Command(
    long lCommandID,     
    CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Handle command from context menu. 

Arguments:

    long lCommandID                 : Command ID
    CSnapInObjectRootBase * pObj    : Base object 
    DATA_OBJECT_TYPES type          : Data object type

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    DWORD dwCommand = 0;
    DWORD inst;
    CString alias;

    switch (lCommandID)
    {
    case IDM_STOP:
        dwCommand = MD_SERVER_COMMAND_STOP;
        break;

    case IDM_START:
        dwCommand = m_dwState == MD_SERVER_STATE_PAUSED ?
            MD_SERVER_COMMAND_CONTINUE : MD_SERVER_COMMAND_START;
        break;

    case IDM_PAUSE:
        dwCommand = m_dwState == MD_SERVER_STATE_PAUSED ?
            MD_SERVER_COMMAND_CONTINUE : MD_SERVER_COMMAND_PAUSE;
        break;

    case IDM_NEW_FTP_SITE:
        if (SUCCEEDED(hr = AddFTPSite(pObj, type, &inst)))
        {
            hr = InsertNewInstance(inst);
        }
        break;

    case IDM_NEW_FTP_VDIR:
        if (SUCCEEDED(hr = CIISMBNode::AddFTPVDir(pObj, type, alias)))
        {
            hr = InsertNewAlias(alias);
        }
        break;

    case IDM_NEW_WEB_SITE:
        if (SUCCEEDED(hr = CIISMBNode::AddWebSite(pObj, type, &inst)))
        {
            hr = InsertNewInstance(inst);
        }
        break;

    case IDM_NEW_WEB_VDIR:
        if (SUCCEEDED(hr = CIISMBNode::AddWebVDir(pObj, type, alias)))
        {
            hr = InsertNewAlias(alias);
        }
        break;
    //
    // Pass on to base class
    //
    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
    }

    if (dwCommand)
    {
        hr = ChangeState(dwCommand);
    }

    return hr;
}




/* virtual */
HRESULT
CIISSite::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CComBSTR bstrPath;

    //
    // CODEWORK: What to do with m_err?  This might be 
    // a bad machine object in the first place.  Aborting
    // when the machine object has an error code isn't 
    // such a bad solution here.
    //

    /*
    if (m_err.Failed())
    {
        m_err.MessageBox();
        return m_err;
    }
    */

    CError err(BuildMetaPath(bstrPath));

    if (err.Succeeded())
    {
        err = ShowPropertiesDlg(
            lpProvider,
            QueryAuthInfo(), 
            bstrPath,
            GetMainWindow(),
            (LPARAM)this,
            handle
            );
    }

    err.MessageBoxOnFailure();

    return err;
}



HRESULT 
CIISSite::ChangeState(DWORD dwCommand)
/*++

Routine Description:

    Change the state of this instance (started/stopped/paused)

Arguments:

    DWORD dwCommand         : MD_SERVER_COMMAND_START, etc.

Return Value:

    HRESULT

--*/
{
    CError err;
    CComBSTR bstrPath;

    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    
    do
    {
        CWaitCursor wait;

        err = BuildMetaPath(bstrPath);
        // We need instance key here
        CString path_inst;
        CMetabasePath::GetInstancePath(bstrPath, path_inst);
        BREAK_ON_ERR_FAILURE(err)

        CInstanceProps ip(QueryAuthInfo(), path_inst);

        err = ip.LoadData();
        BREAK_ON_ERR_FAILURE(err)

        err = ip.ChangeState(dwCommand);
        BREAK_ON_ERR_FAILURE(err)

        err = RefreshData();
        if (err.Succeeded())
        {
            err = RefreshDisplay();
        }
    }
    while(FALSE);

    err.MessageBoxOnFailure();

    return err;
}



/* virtual */
HRESULT 
CIISSite::EnumerateScopePane(HSCOPEITEM hParent)
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    CError err = EnumerateVDirs(hParent, m_pService);
    if (err.Succeeded() && !IsFtpSite() && m_strRedirectPath.IsEmpty())
    {
        if (m_dwWin32Error == ERROR_SUCCESS)
        {
            err = EnumerateWebDirs(hParent, m_pService);
        }
    }
    if (err.Failed())
    {
        m_dwWin32Error = err.Win32Error();
        RefreshDisplay();
    }
    return err;
}

/*virtual*/
HRESULT 
CIISSite::EnumerateResultPane(BOOL fExp, IHeaderCtrl * pHdr, IResultData * pResData)
{
	CError err = CIISObject::EnumerateResultPane(fExp, pHdr, pResData);
    if (    err.Succeeded() 
        &&  QueryWin32Error() == ERROR_SUCCESS
        &&  !IsFtpSite() 
        &&  m_strRedirectPath.IsEmpty()
        )
    {
		err = CIISMBNode::EnumerateResultPane_(fExp, pHdr, pResData, m_pService);
		if (err.Failed())
		{
			m_dwWin32Error = err.Win32Error();
		}
	}
	return err;
}

/* virtual */
HRESULT
CIISSite::BuildMetaPath(CComBSTR & bstrPath) const
/*++

Routine Description:

    Recursively build up the metabase path from the current node
    and its parents

Arguments:

    CComBSTR & bstrPath     : Returns metabase path

Return Value:

    HRESULT

Notes:

    This will return the home directory path, e.g. "lm/w3svc/2/root",
    not the path of the instance.

--*/
{
    //
    // Build instance path
    //
    HRESULT hr = CIISMBNode::BuildMetaPath(bstrPath);
    
    if (SUCCEEDED(hr))
    {
        //
        // Add root directory path
        //
        bstrPath.Append(_cszSeparator);
        bstrPath.Append(g_cszRoot);
    }

    return hr;
}


// CODEWORK: make it work from CIISMBNode::DeleteNode
HRESULT
CIISSite::DeleteNode(IResultData * pResult)
{
   CError err;

   if (!NoYesMessageBox(IDS_CONFIRM_DELETE))
      return err;

   do
   {
      CComBSTR path;
      CMetaInterface * pInterface = QueryInterface();
      ASSERT(pInterface != NULL);
      err = CIISMBNode::BuildMetaPath(path);
      if (err.Failed()) 
         break;
      CMetaKey mk(pInterface, METADATA_MASTER_ROOT_HANDLE, METADATA_PERMISSION_WRITE);
      if (!mk.Succeeded())
         break;
      err = mk.DeleteKey(path);
      if (err.Failed()) 
         break;

      err = RemoveScopeItem();

   } while (FALSE);

   if (err.Failed())
   {
      DisplayError(err);
   }
   return err;
}

//
// We are not supporting empty comments on sites. Even if it is OK for
// metabase, it will bring more problems in UI. Empty name will be displayed
// as [Site #N] in UI, and when user will try to rename it again, it could be
// stored in metabase in this format.
//
HRESULT
CIISSite::RenameItem(LPOLESTR new_name)
{
   CComBSTR path;
   CError err;
   if (new_name != NULL && lstrlen(new_name) > 0)
   {
       err = BuildMetaPath(path);
       if (err.Succeeded())
       {
            // We need instance key here
            CString path_inst;
            CMetabasePath::GetInstancePath(path, path_inst);

            CMetaKey mk(QueryInterface(), path_inst, METADATA_PERMISSION_WRITE);

            err = mk.QueryResult();
            if (err.Succeeded())
            {
                err = mk.SetValue(MD_SERVER_COMMENT, CString(new_name));
                if (err.Succeeded())
                {
                    m_strDisplayName = new_name;
                }
            }
       }
   }
   return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\inetmgrapp.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        inetmgr.h

   Abstract:

        Main MMC snap-in code definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/


#ifndef __INETMGR_H_
#define __INETMGR_H_



#include "resource.h"
#include "inetmgr.h"
//#include "xatlsnap.h"

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif



//
// Icon background colour
//
#define RGB_BK_IMAGES (RGB(255,0,255))      // purple

#include <debugafx.h>


class CInetmgrApp : public CWinApp
/*++

Class Description:

    Main app object

Public Interface:

    InitInstance        : Instance initiation handler
    ExitInstance        : Exit instance handler

--*/
{
public:
    CInetmgrApp();
    virtual BOOL InitInstance();
    virtual int ExitInstance();

//
// Access
//
public:
    LPCTSTR QueryInetMgrHelpPath() const { return m_strInetMgrHelpPath; }


protected:
    //{{AFX_MSG(CSnapinApp)
    afx_msg void OnHelp();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    LPCTSTR m_lpOriginalHelpPath;
    LPCTSTR m_lpOriginalAppName;
    CString m_strInetMgrHelpPath;
    CString m_strInetMgrAppName;
};

class CInetMgr;

class CInetMgrComponent 
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CSnapInObjectRoot<2, CInetMgr>,
      public IPersistStorage,
	  public ISnapinHelp2,
      public IExtendContextMenuImpl<CInetMgrComponent>,
      public IExtendPropertySheetImpl<CInetMgrComponent>,
      public IExtendControlbar,
      public IResultDataCompareEx,
      public IComponentImpl<CInetMgrComponent>
/*++

Class Description:

    IComponentImpl implementation

Public Interface:

    See IComponent, IPersistStorage, etc for documentation

--*/
{
//
// Constructor/Destructor
//
public:
    CInetMgrComponent();

//
// Interface:
//
public:
    BEGIN_COM_MAP(CInetMgrComponent)
        COM_INTERFACE_ENTRY(IComponent)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(ISnapinHelp2)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IExtendControlbar)
        COM_INTERFACE_ENTRY(IResultDataCompareEx)
    END_COM_MAP()

    //
    // IComponent methods
    //
    STDMETHOD(Notify)(
        LPDATAOBJECT lpDataObject, 
        MMC_NOTIFY_TYPE event, 
        LPARAM arg, 
        LPARAM param
        );

    STDMETHOD(CompareObjects)(
        IN LPDATAOBJECT lpDataObjectA,
        IN LPDATAOBJECT lpDataObjectB
        );

    //
    // IPersistStorage methods
    //
    STDMETHOD(GetClassID)(CLSID * pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(InitNew)(IStorage * pStg);
    STDMETHOD(Load)(IStorage * pStg);
    virtual HRESULT STDMETHODCALLTYPE Save(IStorage * pStgSave, BOOL fSameAsLoad);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IStorage * pStgNew);
    virtual HRESULT STDMETHODCALLTYPE HandsOffStorage();

// ISnapinHelp helper function
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR *pszHelpFile);
    //
    // IExtendControlbar methods
    //
    STDMETHOD(SetControlbar)(LPCONTROLBAR lpControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    //
    // IResultDataCompareEx methods
    //
    STDMETHOD(Compare)(RDCOMPARE * prdc, int * pnResult);
};

#if 0
class CIISMachine;

class CCompMgrExtData : public CSnapInItemImpl<CCompMgrExtData, TRUE>
{
public:
	static const GUID * m_NODETYPE;
	static const OLECHAR * m_SZNODETYPE;
	static const OLECHAR * m_SZDISPLAY_NAME;
	static const CLSID * m_SNAPIN_CLASSID;

	CCompMgrExtData()
	{
		memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
		memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
	}

	~CCompMgrExtData()
	{
	}

//    STDMETHOD(CreatePropertyPages)(
//        LPPROPERTYSHEETCALLBACK lpProvider,
//		LONG_PTR handle, 
//		IUnknown* pUnk,
//		DATA_OBJECT_TYPES type);

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
	{
		if (type == CCT_SCOPE || type == CCT_RESULT)
			return S_OK;
		return S_FALSE;
	}
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type);

    HRESULT EnumerateScopePane(HSCOPEITEM hParent, IConsoleNameSpace2 * pScope);

	IDataObject * m_pDataObject;
	virtual void 
    InitDataClass(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		m_pDataObject = pDataObject;
        VERIFY(SUCCEEDED(Init(pDataObject)));
	}

	CSnapInItem * 
    GetExtNodeObject(IDataObject* pDataObject, CSnapInItem* pDefault)
	{
		// Modify to return a different CSnapInItem* pointer.
		return pDefault;
	}

protected:
    HRESULT Init(IDataObject * pDataObject);

    CString m_ExtMachineName;
//	CIISMachine * m_pMachine;
	HSCOPEITEM m_hScopeItem;
};
#endif

class CIISRoot;

class CInetMgr 
    : public CComObjectRootEx<CComSingleThreadModel>,
      public CSnapInObjectRoot<1, CInetMgr>,
      public IComponentDataImpl<CInetMgr, CInetMgrComponent>,
      public IPersistStorage,
	  public ISnapinHelp2,
      public IExtendContextMenuImpl<CInetMgr>,
      public IExtendPropertySheetImpl<CInetMgr>,
      public CComCoClass<CInetMgr, &CLSID_InetMgr>
/*++

Class Description:

    IComponentDataImpl implementation

Public Interface:

    See IComponentData, IPersistStorage, IExtendContextMenu etc, for documentation

--*/
{
//
// Constructor/Destructor
//
public:
    CInetMgr();
    ~CInetMgr();

//EXTENSION_SNAPIN_DATACLASS(CCompMgrExtData)
//BEGIN_EXTENSION_SNAPIN_NODEINFO_MAP(CInetMgr)
//	EXTENSION_SNAPIN_NODEINFO_ENTRY(CCompMgrExtData)
//END_EXTENSION_SNAPIN_NODEINFO_MAP()

//
// Interface
//
public:
    BEGIN_COM_MAP(CInetMgr)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(IPersistStorage)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
		COM_INTERFACE_ENTRY(ISnapinHelp2)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_INETMGR)

    DECLARE_NOT_AGGREGATABLE(CInetMgr)

    //
    // IPersistStorage methods
    //
    STDMETHOD(GetClassID)(CLSID * pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(InitNew)(IStorage * pStg);
    STDMETHOD(Load)(IStorage * pStg);
    virtual HRESULT STDMETHODCALLTYPE Save(IStorage * pStgSave, BOOL fSameAsLoad);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IStorage * pStgNew);
    virtual HRESULT STDMETHODCALLTYPE HandsOffStorage();
// ISnapinHelp helper function
    STDMETHOD(GetHelpTopic)(LPOLESTR *pszHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR *pszHelpFile);

    HRESULT GetDataClass(
         IDataObject * pDataObject, 
         CSnapInItem ** ppItem, 
         DATA_OBJECT_TYPES * pType);

    //
    // IComponentData methods
    //
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CompareObjects)(
        LPDATAOBJECT lpDataObjectA,
        LPDATAOBJECT lpDataObjectB
        );

	STDMETHOD(Notify)(
		LPDATAOBJECT lpDataObject, 
		MMC_NOTIFY_TYPE event, 
		LPARAM arg, 
		LPARAM param
		);
	HRESULT OnPropertyChange(LPARAM arg, LPARAM param);

public:
    static void WINAPI ObjectMain(bool bStarting);


protected:
    BOOL IsExtension();

protected:
    static DWORD   _dwSignature;
    static LPCTSTR _szStream;
};



class ATL_NO_VTABLE CInetMgrAbout  
    : public ISnapinAbout,
      public CComObjectRoot,
      public CComCoClass<CInetMgrAbout, &CLSID_InetMgrAbout>
/*++

Class Description:

    About interface implementation.  Called by MMC to display information
    about the snap-in.

Public Interface:

    See ISnapinAbout for documentation

--*/
{
//
// Interface
//
public:
    CInetMgrAbout()
    {
        m_hSmallImage = m_hLargeImage = NULL;
        m_hSnapinIcon = NULL;
    }

    ~CInetMgrAbout();

    DECLARE_REGISTRY(CInetMgrAbout, _T("InetMgr5xAbout.1"), _T("InetMgr5xAbout.1"), IDS_INETMGR_DESC, THREADFLAGS_BOTH);

    BEGIN_COM_MAP(CInetMgrAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    STDMETHOD(GetSnapinDescription)(LPOLESTR * lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR * lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR * lpVersion);
    STDMETHOD(GetSnapinImage)(HICON * hAppIcon);
    STDMETHOD(GetStaticFolderImage)(
        OUT HBITMAP *  phSmallImage,
        OUT HBITMAP *  phSmallImageOpen,
        OUT HBITMAP *  phLargeImage,
        OUT COLORREF * prgbMask
        );

//
// Helpers
//
protected:
    HRESULT GetStringHelper(UINT nStringID, LPOLESTR * lpString);

    HBITMAP m_hSmallImage, m_hLargeImage;
    HICON m_hSnapinIcon;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT CInetMgrAbout::GetSnapinDescription(
    OUT LPOLESTR * lpDescription
    )
{
    return GetStringHelper(IDS_INETMGR_DESC, lpDescription);
}

inline HRESULT CInetMgrAbout::GetProvider(
    OUT LPOLESTR * lpName
    )
{
    return GetStringHelper(IDS_INETMGR_PROVIDER, lpName);
}

#endif // __INETMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\inetmgrapp.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        inetmgrapp.cpp

   Abstract:
        Snapin object

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "inetmgr.h"
#include "dlldatax.h"
#include "common.h"
#include "guids.h"

#include "inetmgr_i.c"
#include "inetmgrapp.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#ifdef _DEBUG
//
// Allocation tracker
//
BOOL
TrackAllocHook(
    IN size_t nSize,
    IN BOOL   bObject,
    IN LONG   lRequestNumber
    )
{
    //
    // Set breakpoint on specific allocation number
    // to track memory leak.
    //
    //TRACEEOLID("allocation # " << lRequestNumber);

    return TRUE;
}
#endif // _DEBUG

// From stdafx.cpp
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

const LPCTSTR g_cszCLSID           = _T("CLSID");
const LPCTSTR g_cszLS32            = _T("LocalServer32");
const LPCTSTR g_cszIPS32           = _T("InprocServer32");
const LPCTSTR g_cszMMCBasePath     = _T("Software\\Microsoft\\MMC");
const LPCTSTR g_cszSnapins         = _T("Snapins");
const LPCTSTR g_cszNameString      = _T("NameString");
const LPCTSTR g_cszNameStringInd   = _T("NameStringIndirect");
const LPCTSTR g_cszProvider        = _T("Provider");
const LPCTSTR g_cszVersion         = _T("Version");
const LPCTSTR g_cszStandAlone      = _T("StandAlone");
const LPCTSTR g_cszNodeTypes       = _T("NodeTypes");
const LPCTSTR g_cszAbout           = _T("About");
const LPCTSTR g_cszExtensions      = _T("Extensions");
const LPCTSTR g_cszNameSpace       = _T("NameSpace");
const LPCTSTR g_cszDynamicExt      = _T("Dynamic Extensions");
const LPCTSTR g_cszValProvider     = _T("Microsoft");
const LPCTSTR g_cszValVersion      = _T("6.0");
const LPCTSTR g_cszMyCompMsc       = _T("%SystemRoot%\\system32\\compmgmt.msc");
const LPCTSTR g_cszServerAppsLoc   = _T("System\\CurrentControlSet\\Control\\Server Applications");
const LPCTSTR g_cszInetMGRBasePath = _T("Software\\Microsoft\\InetMGR");
const LPCTSTR g_cszInetSTPBasePath = _T("Software\\Microsoft\\InetStp");
const LPCTSTR g_cszMinorVersion	   = _T("MinorVersion");
const LPCTSTR g_cszMajorVersion	   = _T("MajorVersion");
const LPCTSTR g_cszParameters      = _T("Parameters");
const LPCTSTR g_cszHelpPath        = _T("HelpLocation");

//const GUID cInternetRootNode = {0xa841b6c3, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cMachineNode = {0xa841b6c4, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cServiceCollectorNode = {0xa841b6c5, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cInstanceCollectorNode = {0xa841b6c6, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cInstanceNode = {0xa841b6c7, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cChildNode = {0xa841b6c8, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
//const GUID cFileNode = {0xa841b6c9, 0x7577, 0x11d0, { 0xbb, 0x1f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

#define lstruuidNodetypeServerApps  L"{476e6449-aaff-11d0-b944-00c04fd8d5b0}"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_InetMgr, CInetMgr)
    OBJECT_ENTRY(CLSID_InetMgrAbout, CInetMgrAbout)
END_OBJECT_MAP()

//
// Message Map
//
BEGIN_MESSAGE_MAP(CInetmgrApp, CWinApp)
    //{{AFX_MSG_MAP(CInetmgrApp)
    //}}AFX_MSG_MAP
    //
    // Global help commands
    //
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()



//
// Instantiate the app object
//
CInetmgrApp theApp;



CInetmgrApp::CInetmgrApp()
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : CWinApp()
{

#ifdef _DEBUG
    afxMemDF |= checkAlwaysMemDF;
    AfxSetAllocHook(TrackAllocHook);
#endif // _DEBUG    
}

BOOL 
CInetmgrApp::InitInstance()
/*++

Routine Description:

    Instance initiation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
#ifdef _MERGE_PROXYSTUB
    hProxyDll = m_hInstance;
#endif

    ::AfxEnableControlContainer();

    //InitErrorFunctionality();

    _Module.Init(ObjectMap, m_hInstance);

    //
    // Save a pointer to the old help file and app name.
    //
    m_lpOriginalHelpPath = m_pszHelpFilePath;
    m_lpOriginalAppName  = m_pszAppName;
    

    //
    // Build up inetmgr help path, expanding
    // the help path if necessary.
    //
    CString strKey;
    strKey.Format(_T("%s\\%s"), g_cszInetMGRBasePath, g_cszParameters);
    CRegKey rk;
    rk.Create(HKEY_LOCAL_MACHINE, strKey);
    DWORD len = MAX_PATH;
    rk.QueryValue(m_strInetMgrHelpPath.GetBuffer(len), g_cszHelpPath, &len);
    m_strInetMgrHelpPath.ReleaseBuffer(-1);
    m_strInetMgrHelpPath += _T("\\inetmgr.hlp");
    TRACEEOLID("Initialized help file " << m_strInetMgrHelpPath);

    m_pszHelpFilePath = m_strInetMgrHelpPath;
#ifdef _DEBUG
    afxMemDF |= checkAlwaysMemDF;
#endif // _DEBUG

    InitCommonDll();

    VERIFY(m_strInetMgrAppName.LoadString(IDS_APP_NAME));
    m_pszAppName = m_strInetMgrAppName;

    return CWinApp::InitInstance();
}

int 
CInetmgrApp::ExitInstance()
/*++

Routine Description:

    Exit instance handler

Arguments:

    None

Return Value:

    0 for success

--*/
{
    _Module.Term();

    //
    // Restore original help file path and app name, so
    // MFC can safely delete them.
    //
    ASSERT_PTR(m_lpOriginalHelpPath);
    m_pszHelpFilePath = m_lpOriginalHelpPath;
    ASSERT_PTR(m_lpOriginalAppName);
    m_pszAppName = m_lpOriginalAppName;

    return CWinApp::ExitInstance();
}



STDAPI 
DllCanUnloadNow()
/*++

Routine Description:

    Used to determine whether the DLL can be unloaded by OLE

Arguments:

    None

Return Value:

    HRESULT

--*/
{
#ifdef _MERGE_PROXYSTUB

    if (PrxDllCanUnloadNow() != S_OK)
    {
        return S_FALSE;
    }

#endif

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}



STDAPI 
DllGetClassObject(
    IN REFCLSID rclsid, 
    IN REFIID riid, 
    IN LPVOID * ppv
    ) 
/*++

Routine Description:

    Returns a class factory to create an object of the requested type

Arguments:

    REFCLSID rclsid
    REFIID riid
    LPVOID * ppv

Return Value:

    HRESULT

--*/
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
    {
        return S_OK;
    }
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}



STDAPI 
DllRegisterServer()
/*++

Routine Description:

    DllRegisterServer - Adds entries to the system registry

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
#ifdef _MERGE_PROXYSTUB

   HRESULT hRes = PrxDllRegisterServer();
   if (FAILED(hRes))
   {
      return hRes;
   }

#endif

   CError err(_Module.RegisterServer(TRUE));
   if (err.Succeeded())
   {
      CString str, strKey, strExtKey;

      try
      {
         AFX_MANAGE_STATE(::AfxGetStaticModuleState());

         //
         // Create the primary snapin nodes
         //
         CString strNameString((LPCTSTR)IDS_ROOT_NODE);
         CString strNameStringInd;
         TCHAR path[MAX_PATH];
         GetModuleFileName(_Module.GetResourceInstance(), path, MAX_PATH - 1);
         strNameStringInd.Format(_T("@%s,-%d"), path, IDS_ROOT_NODE);
         TRACEEOLID("MUI-lized snapin name: " << strNameStringInd);

         CString strProvider(g_cszValProvider);
         CString strVersion(g_cszValVersion);
    
         strKey.Format(_T("%s\\%s\\%s"), 
            g_cszMMCBasePath, 
            g_cszSnapins,
            GUIDToCString(CLSID_InetMgr, str)
            );
         TRACEEOLID(strKey);

         CString strAbout;
         GUIDToCString(CLSID_InetMgrAbout, strAbout);

         CRegKey rkSnapins, rkStandAlone, rkNodeTypes;
         
         rkSnapins.Create(HKEY_LOCAL_MACHINE, strKey);
         if (NULL != (HKEY)rkSnapins)
         {
            rkSnapins.SetValue(strAbout, g_cszAbout);
            rkSnapins.SetValue(strNameString, g_cszNameString);
            rkSnapins.SetValue(strNameStringInd, g_cszNameStringInd);
            rkSnapins.SetValue(strProvider, g_cszProvider);
            rkSnapins.SetValue(strVersion, g_cszVersion);
         }
         rkStandAlone.Create(rkSnapins, g_cszStandAlone);
         rkNodeTypes.Create(rkSnapins, g_cszNodeTypes);

         //
         // Create the nodetype GUIDS
         //
         CRegKey rkN1, rkN2, rkN3, rkN4, rkN5, rkN6, rkN7, rkN8;

         rkN1.Create(rkNodeTypes, GUIDToCString(cInternetRootNode, str));
         rkN2.Create(rkNodeTypes, GUIDToCString(cMachineNode, str));
         rkN3.Create(rkNodeTypes, GUIDToCString(cInstanceNode, str));
         rkN4.Create(rkNodeTypes, GUIDToCString(cChildNode, str));
         rkN5.Create(rkNodeTypes, GUIDToCString(cFileNode, str));
         rkN6.Create(rkNodeTypes, GUIDToCString(cServiceCollectorNode, str));
         rkN7.Create(rkNodeTypes, GUIDToCString(cAppPoolsNode, str));
         rkN8.Create(rkNodeTypes, GUIDToCString(cAppPoolNode, str));

         {
            //
            // Register as a dynamic extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszDynamicExt
                );

            TRACEEOLID(strExtKey);

            CRegKey rkMMCNodeTypes;
            rkMMCNodeTypes.Create(HKEY_LOCAL_MACHINE, strExtKey);
            if (NULL != (HKEY)rkMMCNodeTypes)
            {
               rkMMCNodeTypes.SetValue(            
                  strNameString,
                  GUIDToCString(CLSID_InetMgr, str)
                  );
            }
         }
         {
            //
            // Register as a namespace extension to computer management
            //
            strExtKey.Format(
                _T("%s\\%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszExtensions,
                g_cszNameSpace
                );

            TRACEEOLID(strExtKey);

            CRegKey rkMMCNodeTypes;
            rkMMCNodeTypes.Create(HKEY_LOCAL_MACHINE, strExtKey);
            if (NULL != (HKEY)rkMMCNodeTypes)
            {
               rkMMCNodeTypes.SetValue(            
                  strNameString,
                  GUIDToCString(CLSID_InetMgr, str)
                  );
            }
         }

         //
         // This key indicates that the service in question is available
         // on the local machine
         //
         CRegKey rkCompMgmt;

         rkCompMgmt.Create(HKEY_LOCAL_MACHINE, g_cszServerAppsLoc);
         if (NULL != (HKEY)rkCompMgmt)
         {
            rkCompMgmt.SetValue(strNameString, GUIDToCString(CLSID_InetMgr, str));
         }
      }
      catch(CMemoryException * e)
      {
         e->Delete();
         err = ERROR_NOT_ENOUGH_MEMORY;
      }
      catch(COleException * e)
      {
         e->Delete();
         err = SELFREG_E_CLASS;
      }
   }
   return err;
}



STDAPI 
DllUnregisterServer()
/*++

Routine Description:

    DllUnregisterServer - Removes entries from the system registry

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
#ifdef _MERGE_PROXYSTUB

   PrxDllUnregisterServer();

#endif
   CError err;

   try
   {
      CString strKey(g_cszMMCBasePath);
      strKey += _T("\\");
      strKey += g_cszSnapins;

      TRACEEOLID(strKey);

      CString str, strExtKey;
      CRegKey rkBase;
      rkBase.Create(HKEY_LOCAL_MACHINE, strKey);
      ASSERT(NULL != (HKEY)rkBase);
      if (NULL != (HKEY)rkBase)
      {
         CRegKey rkCLSID;
         rkCLSID.Create(rkBase, GUIDToCString(CLSID_InetMgr, str));
         ASSERT(NULL != (HKEY)rkCLSID);
         if (NULL != (HKEY)rkCLSID)
         {
            ::RegDeleteKey(rkCLSID, g_cszStandAlone);
            {
               CRegKey rkNodeTypes;
               rkNodeTypes.Create(rkCLSID, g_cszNodeTypes);
               ASSERT(NULL != (HKEY)rkNodeTypes);
               if (NULL != (HKEY)rkNodeTypes)
               {
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cInternetRootNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cMachineNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cInstanceNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cChildNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cFileNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cServiceCollectorNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cAppPoolsNode, str));
                  ::RegDeleteKey(rkNodeTypes, GUIDToCString(cAppPoolNode, str));
               }
            }
            ::RegDeleteKey(rkCLSID, g_cszNodeTypes);
         }
         ::RegDeleteKey(rkBase, GUIDToCString(CLSID_InetMgr, str));
      }

      {
         //
         // Delete a dynamic extension to computer management
         //
         strExtKey.Format(
                _T("%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszDynamicExt
                );

         CRegKey rkMMCNodeTypes;
         rkMMCNodeTypes.Create(HKEY_LOCAL_MACHINE, strExtKey);
		 if (NULL != (HKEY)rkMMCNodeTypes)
		 {
			::RegDeleteValue(rkMMCNodeTypes, GUIDToCString(CLSID_InetMgr, str));
		 }
      }

      {
         //
         // Delete the namespace extension to computer management
         //
         strExtKey.Format(
                _T("%s\\%s\\%s\\%s\\%s"), 
                g_cszMMCBasePath, 
                g_cszNodeTypes,
                lstruuidNodetypeServerApps,
                g_cszExtensions,
                g_cszNameSpace
                );

         CRegKey rkMMCNodeTypes;
         rkMMCNodeTypes.Create(HKEY_LOCAL_MACHINE, strExtKey);
         ::RegDeleteValue(rkMMCNodeTypes, GUIDToCString(CLSID_InetMgr, str));
      }

      //
      // And the service itself no longer available on the local 
      // computer
      //
      CRegKey rkCompMgmt;
      rkCompMgmt.Create(HKEY_LOCAL_MACHINE, g_cszServerAppsLoc);
      ::RegDeleteValue(rkCompMgmt, GUIDToCString(CLSID_InetMgr, str));
   }
   catch(CException * e)
   {
      err.GetLastWinError();
      e->Delete();
   }

   if (err.Failed())
   {
      return err.Failed();
   }
   return _Module.UnregisterServer();
}

HRESULT CInetMgrAbout::GetSnapinVersion(LPOLESTR * lpVersion)
{
    CRegKey rk;
    rk.Create(HKEY_LOCAL_MACHINE, g_cszInetSTPBasePath);
	DWORD minor, major;
    if (	ERROR_SUCCESS == rk.QueryValue(minor, g_cszMinorVersion)
		&&	ERROR_SUCCESS == rk.QueryValue(major, g_cszMajorVersion)
		)
	{
		CString buf;
		buf.Format(_T("%d.%d"), major, minor);
		*lpVersion = (LPOLESTR)::CoTaskMemAlloc((buf.GetLength() + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
		{
			return E_OUTOFMEMORY;
		}

		::ocscpy(*lpVersion, T2OLE((LPTSTR)(LPCTSTR)buf));

		return S_OK;
	}

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\iisobj.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        iisobj.h

   Abstract:
        IIS Object definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef __IISOBJ_H__
#define __IISOBJ_H__

#include "scache.h"
#include "guids.h"

#define RES_TASKPAD_NEWVROOT        _T("/img\\newvroot.gif")
#define RES_TASKPAD_NEWSITE         _T("/img\\newsite.gif")
#define RES_TASKPAD_SECWIZ          _T("/img\\secwiz.gif")

//
// Forward Definitions
//
class CIISRoot;
class CIISMachine;
class CIISService;
class CIISFileName;
class CAppPoolsContainer;


class CIISObject : public CSnapInItemImpl<CIISObject>
/*++

Class Description:

    Base IIS object
    
Public Interface:


--*/
{
protected:
    //
    // Menu Commands, listed in toolbar order.
    //
    // IMPORTANT! -- this must be kept in sync with MenuItemDefs
    // in iisobj.cpp
    //
    enum
    {
        IDM_INVALID,            /* invalid command ID */
        IDM_CONNECT,
        IDM_DISCOVER,
        IDM_START,
        IDM_STOP,
        IDM_PAUSE,
        /**/
        IDM_TOOLBAR             /* Toolbar commands start here */
    };

    //
    // Additional menu commands that do not show up in the toolbar
    //
    enum
    {
        IDM_EXPLORE = IDM_TOOLBAR,
        IDM_OPEN,
        IDM_BROWSE,
        IDM_RECYCLE,

#if defined(_DEBUG) || DBG
        IDM_IMPERSONATE,
        IDM_REMOVE_IMPERSONATION,
#endif // _DEBUG

        IDM_CONFIGURE,
        IDM_DISCONNECT,
        IDM_METABACKREST,
        IDM_SHUTDOWN,

        IDM_NEW_VROOT,
        IDM_NEW_INSTANCE,
        IDM_NEW_FTP_SITE,
        IDM_NEW_FTP_VDIR,
        IDM_NEW_WEB_SITE,
        IDM_NEW_WEB_VDIR,
        IDM_NEW_APP_POOL,
        IDM_VIEW_TASKPAD,
        IDM_TASK_SECURITY_WIZARD,

        //
        // Don't move this last one -- it will be used
        // as an offset for service specific new instance
        // commands
        //
        IDM_NEW_EX_INSTANCE
    };

protected:
    //
    // Sort Weights for CIISObject derived classes
    //
    enum
    {
        SW_ROOT,
        SW_MACHINE,
        SW_APP_POOLS,
        SW_SERVICE,
        SW_SITE,
        SW_VDIR,
        SW_DIR,
        SW_FILE,
        SW_APP_POOL,
    };

//
// Statics
//
public:
   static HRESULT Initialize();
   static HRESULT Destroy();
   static HRESULT SetImageList(LPIMAGELIST lpImageList);

protected:
   static HBITMAP  _hImage16;
   static HBITMAP  _hImage32;
   static HBITMAP  _hToolBar;
   static CComBSTR _bstrResult;

//
// Bitmap indices
//
protected:
    enum
    {
        iIISRoot,
        iLocalMachine,
        iStopped,
        iPaused,
        iStarted,
        iUnknown,
        iError,
        iFolder,
        iFile,
        iBlank,
        iMachine,
        iApplication,
        iFTPSite,
        iFTPDir,
        iWWWSite,
        iWWWDir,
        iErrorMachine,
    };

protected:
    //
    // Menu item definition that uses resource definitions, and
    // provides some additional information for taskpads. This is replacement
    // for MMC structure CONTEXTMENUITEM defined in mmc.h
    //
    typedef struct tagCONTEXTMENUITEM_RC
    {
        UINT    nNameID;
        UINT    nStatusID;
        UINT    nDescriptionID;
        LONG    lCmdID;
        LONG    lInsertionPointID;
        LONG    fSpecialFlags;
        LPCTSTR lpszMouseOverBitmap;
        LPCTSTR lpszMouseOffBitmap;
    } 
    CONTEXTMENUITEM_RC;

    static CONTEXTMENUITEM_RC _menuItemDefs[];
    static MMCBUTTON          _SnapinButtons[];
    static UINT               _SnapinButtonIDs[];
    static BOOL               _fToolbarResolved;

//
// Constructor/Destructor
//
public:
    CIISObject();
    virtual ~CIISObject();

//
// Interface:
//
public:
    virtual void * GetNodeType()
    {
		ASSERT(FALSE);
        return (void *)&cInternetRootNode;
    }
	void * GetDisplayName()
    {
        return (void *)QueryDisplayName();
    }


    STDMETHOD(GetScopePaneInfo)(LPSCOPEDATAITEM lpScopeDataItem);
    STDMETHOD(GetResultPaneInfo)(LPRESULTDATAITEM lpResultDataItem);
    STDMETHOD(GetResultViewType)(LPOLESTR *lplpViewType, long * lpViewOptions);
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader) {}
    virtual HRESULT SetToolBarStates();
    virtual HRESULT RenameItem(LPOLESTR new_name) {return S_OK;}
    STDMETHOD (FillData)(CLIPFORMAT cf, LPSTREAM pStream);
    STDMETHOD (FillCustomData)(CLIPFORMAT cf, LPSTREAM pStream);

    virtual LPOLESTR QueryDisplayName() = 0;
    virtual int      QueryImage() const = 0;
    //
    // Comparison methods
    //
    virtual int CompareScopeItem(CIISObject * pObject);
    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);

    //
    // IExtendContextMenu items
    //
    STDMETHOD(Notify)( 
        IN MMC_NOTIFY_TYPE event,
        IN LPARAM arg,
        IN LPARAM param,
        IN IComponentData * pComponentData,
        IN IComponent * pComponent,
        IN DATA_OBJECT_TYPES type
        );

    STDMETHOD(AddMenuItems)(
        IN LPCONTEXTMENUCALLBACK piCallback,
        IN long * pInsertionAllowed,
        IN DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        IN long lCommandID,
        IN CSnapInObjectRootBase * pObj,
        IN DATA_OBJECT_TYPES type
        );

    //
    // IExtendControlbar methods
    //
    STDMETHOD(SetControlbar)(
        IN LPCONTROLBAR lpControlbar, 
        IN LPEXTENDCONTROLBAR lpExtendControlbar
        );

    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

    //
    // IExtendPropertySheet methods
    //
    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LONG_PTR handle, 
        IN IUnknown * pUnk,
        IN DATA_OBJECT_TYPES type
        );
    
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type);

//
// Access
//
public:
    //
    // Type Functions
    //
    virtual BOOL IsControllable() const     { return FALSE; }
    virtual BOOL IsPausable() const         { return FALSE; }
    virtual BOOL IsConfigurable() const     { return FALSE; }
    virtual BOOL IsDeletable() const        { return FALSE; }
    virtual BOOL IsRefreshable() const      { return FALSE; }
    virtual BOOL IsConnectable() const      { return FALSE; }
    virtual BOOL IsDisconnectable() const   { return FALSE; }
    virtual BOOL IsLeafNode() const         { return FALSE; }
    virtual BOOL HasFileSystemFiles() const { return FALSE; }
	 virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const { return _T(""); }

    //
    // State Functions
    //
    virtual BOOL IsRunning() const          { return FALSE; }
    virtual BOOL IsStopped() const          { return FALSE; }
    virtual BOOL IsPaused() const           { return FALSE; }
    virtual BOOL IsRenamable() const        { return FALSE; }
    virtual BOOL IsClonable() const         { return FALSE; }
    virtual BOOL IsBrowsable() const        { return FALSE; }
    virtual BOOL IsExplorable() const       { return FALSE; }
    virtual BOOL IsOpenable() const         { return FALSE; }

	virtual BOOL HasResultItems() const     { return FALSE; }

//
// Assumed Functions
//
public:
    BOOL IsStartable() const { return IsControllable() && !IsRunning(); }
    BOOL IsStoppable() const { return IsControllable() && (IsRunning() || IsPaused() ); }

public:
    BOOL IsExpanded() const;
    CIISObject * FindIdenticalScopePaneItem(CIISObject * pObject);
    HSCOPEITEM QueryScopeItem() const { return m_hScopeItem; }
    HSCOPEITEM QueryResultItem() const { return m_hResultItem; }
    HRESULT AskForAndAddMachine();

    HRESULT AddToScopePane(
        HSCOPEITEM hRelativeID,
        BOOL fChild = TRUE,           
        BOOL fNext = TRUE,
        BOOL fIsParent = TRUE
        );

    HRESULT AddToScopePaneSorted(HSCOPEITEM hParent, BOOL fIsParent = TRUE);
    HRESULT RefreshDisplay();
    HRESULT SetCookie();
    void SetScopeItem(HSCOPEITEM hItem)
    {
       ASSERT(m_hScopeItem == 0);
       m_hScopeItem = hItem;
    }
    HRESULT SelectScopeItem();
    virtual HRESULT RemoveScopeItem();
    void SetResultItem(HRESULTITEM hItem)
    {
        ASSERT(m_hResultItem == 0);
        m_hResultItem = hItem;
    }
    virtual int QuerySortWeight() const = 0;
	IConsoleNameSpace * GetConsoleNameSpace() {return _lpConsoleNameSpace;}
	IConsole * GetConsole() {return _lpConsole;}
	virtual HRESULT OnPropertyChange(BOOL fScope, IResultData * pResult) { return S_OK; }

//
// Event Handlers
//
protected:
    virtual HRESULT EnumerateResultPane(BOOL fExpand, IHeaderCtrl * lpHeader,
        IResultData * lpResultData);
	virtual HRESULT CleanResult(IResultData * pResultData)
	{
		return S_OK;
	}
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent) { return S_OK; }
    virtual HRESULT DeleteChildObjects(HSCOPEITEM hParent);
    virtual HRESULT RemoveChildren(HSCOPEITEM hParent);
    virtual HRESULT Refresh(BOOL fReEnumerate = TRUE) { return S_OK; }
    virtual HRESULT AddImages(LPIMAGELIST lpImageList);
    virtual HRESULT SetStandardVerbs(LPCONSOLEVERB lpConsoleVerb);
    virtual CIISRoot * GetRoot();
    virtual HRESULT DeleteNode(IResultData * pResult);
	virtual HRESULT ChangeVisibleColumns(MMC_VISIBLE_COLUMNS * pCol);

    static HRESULT AddMMCPage(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CPropertyPage * pPage
        );

protected:
    //
    // Add Menu Command helpers
    //
    static HRESULT AddMenuSeparator(
        IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
        IN LONG lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP
        );

    static HRESULT AddMenuItemByCommand(
        IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
        IN LONG lCmdID,
        IN LONG fFlags = 0
        );

    //
    // Create result view helper
    //
    static void BuildResultView(
        IN LPHEADERCTRL pHeader,
        IN int cColumns,
        IN int * pnIDS,
        IN int * pnWidths
        );

//
// BUGBUG: should be protected
public:
    //
    // Toolbar helper
    //
    static HRESULT __SetControlbar(
       LPCONTROLBAR lpControlBar, LPEXTENDCONTROLBAR lpExtendControlBar);

protected:
    HSCOPEITEM m_hScopeItem;
    HRESULTITEM m_hResultItem;
	BOOL m_fSkipEnumResult;

public:
   static const GUID * m_NODETYPE;
   static const OLECHAR * m_SZNODETYPE;
   static const OLECHAR * m_SZDISPLAY_NAME;
   static const CLSID * m_SNAPIN_CLASSID;
   BOOL m_fIsExtension;

public:
   static HRESULT AttachScopeView(LPUNKNOWN lpUnknown);
   static CWnd * GetMainWindow();

protected:
   static CComPtr<IControlbar> _lpControlBar;
   static CComPtr<IToolbar> _lpToolBar;
   static CComPtr<IConsoleNameSpace> _lpConsoleNameSpace;
   static CComPtr<IConsole> _lpConsole;
   static CComBSTR _bstrLocalHost;

public:
    static CLIPFORMAT m_CCF_MachineName;
    static CLIPFORMAT m_CCF_MyComputMachineName;
    static CLIPFORMAT m_CCF_Service;
    static CLIPFORMAT m_CCF_Instance;
    static CLIPFORMAT m_CCF_ParentPath;
    static CLIPFORMAT m_CCF_Node;
    static CLIPFORMAT m_CCF_MetaPath;

    static void Init()
    {
        m_CCF_MachineName = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_MACHINE_NAME);
        m_CCF_MyComputMachineName = (CLIPFORMAT)RegisterClipboardFormat(MYCOMPUT_MACHINE_NAME);
        m_CCF_Service = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_SERVICE);
        m_CCF_Instance = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_INSTANCE);
        m_CCF_ParentPath = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_PARENT_PATH);
        m_CCF_Node = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_NODE);
        m_CCF_MetaPath = (CLIPFORMAT)RegisterClipboardFormat(ISM_SNAPIN_META_PATH);
    }
};

_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_MachineName = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_MyComputMachineName = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_Service = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_Instance = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_ParentPath = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_Node = 0;
_declspec( selectany ) CLIPFORMAT CIISObject::m_CCF_MetaPath = 0;

class CIISRoot : public CIISObject
{
//
// Constructor/Destructor
//
public:
    CIISRoot();
    virtual ~CIISRoot();

//
// Interface
//
public:
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual HRESULT DeleteChildObjects(HSCOPEITEM hParent);

//
// Access
//
public:
    virtual BOOL IsConnectable() const      
	{ 
		return !IsExtension(); 
	}
    virtual LPOLESTR QueryDisplayName() { return m_bstrDisplayName; }
    virtual int QueryImage() const { return iIISRoot; } 
    virtual int QuerySortWeight() const { return SW_ROOT; }
    virtual void * GetNodeType()
    {
        return (void *)&cInternetRootNode;
    }
    STDMETHOD (FillCustomData)(CLIPFORMAT cf, LPSTREAM pStream);
    BOOL IsExtension() const 
    {
        return m_fIsExtension;
    }

public:
    CIISServerCache m_scServers;
    HRESULT InitAsExtension(IDataObject * pDataObject);
    HRESULT ResetAsExtension();

protected:
    virtual CIISRoot * GetRoot() { return this; }

    HRESULT EnumerateScopePaneExt(HSCOPEITEM hParent);

protected:
    CComBSTR m_bstrDisplayName;
    static OLECHAR * m_SZNODETYPE;
    // we are using this machine name and pointer 
    // only for extension case
    CIISMachine * m_pMachine;
    CString m_ExtMachineName;
    BOOL m_fRootAdded;
};


class CIISMBNode : public CIISObject
/*++

Class Description:

    Metabase node class

Public Interface:

--*/
{
//
// Constructor/Destructor
//
public:
    CIISMBNode(CIISMachine * pOwner, LPCTSTR szNode);
    ~CIISMBNode();

//
// Access
//
public:
    LPOLESTR QueryNodeName() const { return m_bstrNode; }
    CComBSTR & GetNodeName() { return m_bstrNode; }
    virtual LPOLESTR QueryMachineName() const;
    virtual CComAuthInfo * QueryAuthInfo();
    virtual CMetaInterface * QueryInterface();
    virtual BOOL IsLocal() const;
    virtual BOOL HasInterface() const;
	virtual BOOL HasResultItems() const
	{
		return !m_ResultItems.IsEmpty();
	}
    virtual HRESULT CreateInterface(BOOL fShowError);
    virtual HRESULT AssureInterfaceCreated(BOOL fShowError);
    virtual void SetInterfaceError(HRESULT hr);
    BOOL OnLostInterface(CError & err);
    BOOL IsLostInterface(CError & err) const;
    BOOL IsAdministrator() const;
    WORD QueryMajorVersion() const;
    WORD QueryMinorVersion() const;
	CIISMachine * GetOwner() {return m_pOwner;}

//
// Interface:
//
public:
    void DisplayError(CError & err) const;
    virtual BOOL IsRefreshable() const  { return TRUE; }
    virtual HRESULT RefreshData() { return S_OK; }
    virtual HRESULT Refresh(BOOL fReEnumerate = TRUE);
    virtual HRESULT RenameItem(LPOLESTR new_name) 
    {
       ASSERT(IsRenamable());
       return S_OK;
    }
    STDMETHOD (FillCustomData)(CLIPFORMAT cf, LPSTREAM pStream);
    virtual void * GetNodeType()
    {
        // We really shouldn't be here
        return CIISObject::GetNodeType();
    }
	virtual HRESULT OnPropertyChange(BOOL fScope, IResultData * pResult);

public:
    //
    // Build metabase path
    //
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;

    //
    // Build URL
    //
    virtual HRESULT BuildURL(CComBSTR & bstrURL) const;    

    CIISMBNode * GetParentNode() const;
	HRESULT RemoveResultNode(CIISMBNode * pNode, IResultData * pResult);

protected:
    HRESULT EnumerateResultPane_(
        BOOL fExpand, 
        IHeaderCtrl * lpHeader,
        IResultData * lpResultData,
        CIISService * pService
        );
	virtual HRESULT CleanResult(IResultData * pResultData);
    HRESULT CreateEnumerator(CMetaEnumerator *& pEnum);
    HRESULT EnumerateVDirs(HSCOPEITEM hParent, CIISService * pService);
    HRESULT EnumerateWebDirs(HSCOPEITEM hParent, CIISService * pService);
    HRESULT AddFTPSite(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      DWORD * inst
      );

    HRESULT AddFTPVDir(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      CString& alias
      );

    HRESULT AddWebSite(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      DWORD * inst
      );

    HRESULT AddWebVDir(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      CString& alias
      );

    HRESULT AddAppPool(
      const CSnapInObjectRootBase * pObj,
      DATA_OBJECT_TYPES type,
      CAppPoolsContainer * pCont,
      CString& name
      );

    BOOL GetPhysicalPath(
        LPCTSTR metaPath, 
        CString & alias,
        CString &physPath);

protected:
    STDMETHOD(GetResultViewType)(LPOLESTR *lplpViewType, long * lpViewOptions);
    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );
    virtual HRESULT DeleteNode(IResultData * pResult);
//
// Helpers
//
protected:
    void SetErrorOverrides(CError & err, BOOL fShort = FALSE) const;
    LPCTSTR BuildPhysicalPath(CString & strPhysicalPath) const;
    void RemoveResultItems();

protected:
    static LPOLESTR _cszSeparator;

protected:
    CComBSTR m_bstrNode;
    CComBSTR m_bstrURL;
    CString m_strRedirectPath;
    CIISMachine * m_pOwner;

    CList<CIISFileName *, CIISFileName *&> m_ResultItems;
};



class CIISMachine : public CIISMBNode
/*++

Class Description:

    IIS Machine object.  This is the object that owns the interface.
    
Public Interface:


--*/
{
//
// Constructor/Destructor
//
public:
    CIISMachine(CComAuthInfo * pAuthInfo = NULL,
        CIISRoot * pRoot = NULL);
    virtual ~CIISMachine();

//
// Access
//
public:
    virtual BOOL IsConnectable() const 
	{ 
		return (m_pRootExt == NULL); 
	}
    virtual BOOL IsDisconnectable() const 
	{ 
		return (m_pRootExt == NULL); 
	}
    virtual BOOL IsConfigurable() const 
    { 
        return (QueryMajorVersion() >= 6 && IsAdministrator()); 
    }
    virtual BOOL IsBrowsable() const { return TRUE; }

    virtual LPOLESTR QueryDisplayName();
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual int QueryImage() const;
    virtual int CompareScopeItem(CIISObject * pObject);
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const { return IIS_CLASS_COMPUTER_W; }

    virtual LPOLESTR QueryMachineName() const { return QueryServerName();  }
    virtual CComAuthInfo * QueryAuthInfo() { return &m_auth; }
    virtual CMetaInterface * QueryInterface() { return m_pInterface; }
    virtual BOOL HasInterface() const { return m_pInterface != NULL; }
    virtual BOOL IsLocal() const { return m_auth.IsLocal(); }
    virtual HRESULT CreateInterface(BOOL fShowError);
    virtual HRESULT AssureInterfaceCreated(BOOL fShowError);
    virtual void SetInterfaceError(HRESULT hr);

    HRESULT CheckCapabilities();
    HRESULT Impersonate(LPCTSTR szUserName, LPCTSTR szPassword);
    void RemoveImpersonation();
    BOOL HasAdministratorAccess()
    {
        return m_fIsAdministrator;
    }
    void StorePassword(LPCTSTR szPassword);
    BOOL ResolvePasswordFromCache();
    BOOL ResolveCredentials();
    BOOL HandleAccessDenied(CError & err);
    BOOL SetCacheDirty();
    BOOL UsesImpersonation() const { return m_auth.UsesImpersonation(); }
    BOOL PasswordEntered() const { return m_fPasswordEntered; }
    BOOL CanAddInstance() const { return m_fCanAddInstance; }
    BOOL Has10ConnectionsLimit() const { return m_fHas10ConnectionsLimit; }

    WORD QueryMajorVersion() const { return LOWORD(m_dwVersion); }
    WORD QueryMinorVersion() const { return HIWORD(m_dwVersion); }

    LPOLESTR QueryServerName() const { return m_auth.QueryServerName(); }
    LPOLESTR QueryUserName() const { return m_auth.QueryUserName(); }
    LPOLESTR QueryPassword() const { return m_auth.QueryPassword(); }

    virtual void * GetNodeType()
    {
        return (void *)&cMachineNode;
    }

    STDMETHOD(AddMenuItems)(
        IN LPCONTEXTMENUCALLBACK piCallback,
        IN long * pInsertionAllowed,
        IN DATA_OBJECT_TYPES type
        );
    STDMETHOD(Command)(
        IN long lCommandID,     
        IN CSnapInObjectRootBase * pObj,
        IN DATA_OBJECT_TYPES type
        );
    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LONG_PTR handle, 
        IN IUnknown * pUnk,
        IN DATA_OBJECT_TYPES type
        );

protected:
    void SetDisplayName();
    HRESULT OnMetaBackRest();
    HRESULT OnShutDown();
    HRESULT OnDisconnect();
    HRESULT InsertNewInstance(DWORD inst);

//
// Events
//
public:
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;
    virtual HRESULT BuildURL(CComBSTR & bstrURL) const;    

public:
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual HRESULT RemoveScopeItem();
    virtual HRESULT RefreshData();
    virtual int     QuerySortWeight() const { return SW_MACHINE; }

//
// Public Interface:
//
public:
    static void InitializeHeaders(LPHEADERCTRL lpHeader);
    static HRESULT VerifyMachine(CIISMachine *& pMachine);

//
// Stream handlers
//
public:
    static  HRESULT ReadFromStream(IStream * pStg, CIISMachine ** ppMachine);
    HRESULT WriteToStream(IStream * pStgSave);
    HRESULT InitializeFromStream(IStream * pStg);

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_NAME,
        COL_LOCAL,
        COL_VERSION,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

protected:
    static LPOLESTR _cszNodeName;
    static CComBSTR _bstrYes;
    static CComBSTR _bstrNo;
    static CComBSTR _bstrVersionFmt;
    static BOOL     _fStaticsLoaded;

private:
    BOOL m_fPasswordEntered;
    BSTR m_bstrDisplayName;
    DWORD m_dwVersion;
    CError m_err;
    CComAuthInfo m_auth;
    CMetaInterface * m_pInterface;
    CIISRoot * m_pRootExt;
    BOOL m_fCanAddInstance;
    BOOL m_fHas10ConnectionsLimit;
    BOOL m_fIsAdministrator;
};



//
// Callback function to bring up site properties dialog
//
typedef HRESULT (__cdecl * PFNPROPERTIESDLG)(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CComAuthInfo * pAuthInfo,    OPTIONAL
    IN LPCTSTR lpszMDPath,
    IN CWnd * pMainWnd,             OPTIONAL
    IN LPARAM  lParam,              OPTIONAL
    IN LONG_PTR    handle               OPTIONAL
    );



class CIISService : public CIISMBNode
/*++

Class Description:

Public: Interface:

--*/
{
//
// Service definition
//
protected:
    typedef struct tagSERVICE_DEF
    {
        LPCTSTR szNodeName;
        LPCTSTR szProtocol;
        UINT    nDescriptiveName;
        int     nServiceImage;
        int     nSiteImage;
        int     nVDirImage;
        int     nDirImage;
        int     nFileImage;
		LPCTSTR szServiceClass;
		LPCTSTR szServerClass;
		LPCTSTR szVDirClass;
        PFNPROPERTIESDLG pfnSitePropertiesDlg;
        PFNPROPERTIESDLG pfnDirPropertiesDlg;
    }
    SERVICE_DEF;

    static SERVICE_DEF _rgServices[];

    static int ResolveServiceName(
        IN  LPCTSTR    szServiceName
        );

//
// Property Sheet callbacks
//
protected:
    static HRESULT __cdecl ShowFTPSiteProperties(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );

    static HRESULT __cdecl ShowFTPDirProperties(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );

    static HRESULT __cdecl ShowWebSiteProperties(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );

    static HRESULT __cdecl ShowWebDirProperties(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );
  
//
// Constructor/Destructor
// 
public:
    CIISService(
        IN CIISMachine * pOwner,
        IN LPCTSTR szServiceName
        );

    virtual ~CIISService();

//
// Events
//
public:
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);

//
// Interface:
//
public:
    HRESULT ShowSitePropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,
        IN LPARAM lParam,
        IN LONG_PTR handle
        );

    HRESULT ShowDirPropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,
        IN LPARAM lParam,
        IN LONG_PTR handle
        );

    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LONG_PTR handle, 
        IN IUnknown * pUnk,
        IN DATA_OBJECT_TYPES type
        );

//
// Access
//
public:
    BOOL IsManagedService() const;
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual LPOLESTR QueryDisplayName() 
    { 
       return m_bstrDisplayName; 
    }
    virtual int QueryImage() const;
    virtual int QuerySortWeight() const { return SW_SERVICE; }
    LPCTSTR QueryServiceName()
    {
        return _rgServices[m_iServiceDef].szNodeName;
    }
	LPCTSTR QueryServiceClass() const
	{
        return _rgServices[m_iServiceDef].szServiceClass;
	}
	LPCTSTR QueryServerClass() const
	{
        return _rgServices[m_iServiceDef].szServerClass;
	}
	LPCTSTR QueryVDirClass() const
	{
        return _rgServices[m_iServiceDef].szVDirClass;
	}
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const { return QueryServiceClass(); }

//
// Display Types 
//
public:
    int QueryServiceImage () const;
    int QuerySiteImage() const;
    int QueryVDirImage() const;
    int QueryDirImage() const;
    int QueryFileImage() const;

    virtual void * GetNodeType()
    {
        return (void *)&cServiceCollectorNode;
    }
    HRESULT InsertNewInstance(DWORD inst);
//
// Interface:
//
protected:
    STDMETHOD(AddMenuItems)(
        IN LPCONTEXTMENUCALLBACK piCallback,
        IN long * pInsertionAllowed,
        IN DATA_OBJECT_TYPES type
        );
    STDMETHOD(Command)(
        IN long lCommandID,     
        IN CSnapInObjectRootBase * pObj,
        IN DATA_OBJECT_TYPES type
        );
//    STDMETHOD(CreatePropertyPages)(
//        IN LPPROPERTYSHEETCALLBACK lpProvider,
//        IN LONG_PTR handle, 
//        IN IUnknown * pUnk,
//        IN DATA_OBJECT_TYPES type
//        );

    virtual HRESULT BuildURL(CComBSTR & bstrURL) const;

    //
    // Master properties
    //
    virtual BOOL IsConfigurable() const     { return IsAdministrator(); }

private:
    int       m_iServiceDef;
    BOOL      m_fManagedService;
    BOOL      m_fCanAddInstance;
    CComBSTR  m_bstrDisplayName;
};

class CAppPoolNode;
typedef CList<CAppPoolNode *, CAppPoolNode *>	CPoolList;

class CAppPoolsContainer : public CIISMBNode
/*++

Class Description:

Public: Interface:

--*/
{
//
// Property Sheet callbacks
//
protected:
    static HRESULT __cdecl ShowProperties(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );

//
// Constructor/Destructor
// 
public:
    CAppPoolsContainer(
        IN CIISMachine * pOwner,
        IN CIISService * pWebService
        );

    virtual ~CAppPoolsContainer();

//
// Events
//
public:
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);

//
// Interface:
//
public:
    HRESULT ShowPropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );

    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LONG_PTR handle, 
        IN IUnknown * pUnk,
        IN DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        IN long lCommandID,
        IN CSnapInObjectRootBase * pObj,
        IN DATA_OBJECT_TYPES type
        );

//
// Access
//
public:
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual LPOLESTR QueryDisplayName() 
    {
       return m_bstrDisplayName;
    }
    virtual int QueryImage() const {return iFolder;}
    virtual int QuerySortWeight() const {return SW_APP_POOLS;}

    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;

	HRESULT EnumerateAppPools(CPoolList * pList);

    virtual void * GetNodeType()
    {
        return (void *)&cAppPoolsNode;
    }
    HRESULT QueryDefaultPoolId(CString& id);
    HRESULT InsertNewPool(CString& id);
//
// Interface:
//
protected:
    STDMETHOD(AddMenuItems)(
        IN LPCONTEXTMENUCALLBACK piCallback,
        IN long * pInsertionAllowed,
        IN DATA_OBJECT_TYPES type
        );

    //
    // Master properties
    //
    virtual BOOL IsConfigurable() const     { return IsAdministrator(); }

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_DESCRIPTION,
        COL_STATE,
//        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

private:
    CComBSTR  m_bstrDisplayName;
    CIISService * m_pWebService;
};

class CAppPoolNode : public CIISMBNode
{
//
// Constructor/Destructor
//
public:
    //
    // Constructor which will resolve its properties at display time
    //
    CAppPoolNode(
        IN CIISMachine * pOwner,
        IN CAppPoolsContainer * pContainer,
        IN LPCTSTR szNodeName
        );


    virtual ~CAppPoolNode();

//
// Access
//
public:
    virtual int QueryImage() const;
    virtual LPOLESTR QueryDisplayName();
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual HRESULT DeleteNode(IResultData * pResult);

public:
    //
    // Type Functions
    //
    virtual BOOL IsControllable() const { return TRUE; }
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsDeletable() const {return TRUE; }
    virtual BOOL IsRefreshable() const { return TRUE; }
    virtual BOOL IsRenamable() const { return TRUE; }

    //
    // State Functions
    //
    virtual BOOL IsRunning() const { return m_dwState == MD_SERVER_STATE_STARTED; }
    virtual BOOL IsStopped() const { return m_dwState == MD_SERVER_STATE_STOPPED; }
    virtual BOOL IsPaused() const  { return m_dwState == MD_SERVER_STATE_PAUSED; }


//
// Interface:
//
public:
    virtual HRESULT RefreshData();
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual int QuerySortWeight() const { return SW_APP_POOL; }
    virtual HRESULT RenameItem(LPOLESTR new_name);
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;

    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LONG_PTR handle, 
        IN IUnknown * pUnk,
        IN DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        IN long lCommandID,
        IN CSnapInObjectRootBase * pObj,
        IN DATA_OBJECT_TYPES type
        );

    virtual void * GetNodeType()
    {
        return (void *)&cAppPoolNode;
    }

public:
    static void InitializeHeaders(LPHEADERCTRL lpHeader);

protected:
    HRESULT ChangeState(DWORD dwCommand);
    HRESULT ShowPropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );
    STDMETHOD(AddMenuItems)(
        IN LPCONTEXTMENUCALLBACK piCallback,
        IN long * pInsertionAllowed,
        IN DATA_OBJECT_TYPES type
        );

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_DESCRIPTION,
        COL_STATE,
//        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

protected:
    static CComBSTR _bstrStarted;
    static CComBSTR _bstrStopped;
    static CComBSTR _bstrPaused;
    static CComBSTR _bstrUnknown;
    static CComBSTR _bstrPending;
    static BOOL _fStaticsLoaded;

private:
    CString m_strDisplayName;
    
    //
    // Data members
    //
    BOOL m_fDeletable;
//    DWORD m_dwID;
    DWORD m_dwState;
    DWORD m_dwWin32Error;
    CAppPoolsContainer * m_pContainer;
};

class CIISSite : public CIISMBNode
{
//
// Constructor/Destructor
//
public:
    //
    // Constructor which will resolve its properties at display time
    //
    CIISSite(
        CIISMachine * pOwner,
        CIISService * pService,
        LPCTSTR szNodeName
        );

    //
    // Constructor with full information
    //
    CIISSite(
        CIISMachine * pOwner,
        CIISService * pService,
        LPCTSTR  szNodeName,
        DWORD    dwState,
        BOOL     fDeletable,
        BOOL     fClusterEnabled,
        USHORT   sPort,
        DWORD    dwID,
        DWORD    dwIPAddress,
        DWORD    dwWin32Error,
        LPOLESTR szHostHeaderName,
        LPOLESTR szComment
        );

    virtual ~CIISSite();

//
// Access
//
public:
    virtual int QueryImage() const;
    virtual LPOLESTR QueryDisplayName();
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);
	 virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const 
    { 
       if (path != NULL && !CMetabasePath::IsMasterInstance(path))
       {
          return m_pService->QueryVDirClass(); 
       }
       else
       {
          return m_pService->QueryServerClass(); 
       }
    }

public:
    //
    // Type Functions
    //
    virtual BOOL IsControllable() const { return TRUE; }
    virtual BOOL IsPausable() const { return IsRunning() || IsPaused(); }
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsDeletable() const 
    {
        // Do not delete the only site for Pro SKU
        CIISSite * that = (CIISSite *)this;
        return !that->GetOwner()->Has10ConnectionsLimit();
    }
    virtual BOOL IsRenamable() const { return TRUE; }
    virtual BOOL HasFileSystemFiles() const { return TRUE; }

    //
    // State Functions
    //
    virtual BOOL IsRunning() const { return m_dwState == MD_SERVER_STATE_STARTED; }
    virtual BOOL IsStopped() const { return m_dwState == MD_SERVER_STATE_STOPPED; }
    virtual BOOL IsPaused() const  { return m_dwState == MD_SERVER_STATE_PAUSED; }
    virtual BOOL IsBrowsable() const { return TRUE; }
    virtual BOOL IsExplorable() const { return TRUE; }
    virtual BOOL IsOpenable() const { return TRUE; }


//
// Data Access
//
public:
    BOOL   IsWolfPackEnabled() const { return m_fWolfPackEnabled; }
    DWORD  QueryIPAddress() const { return m_dwIPAddress; }
    DWORD  QueryWin32Error() const { return m_dwWin32Error; }
    USHORT QueryPort() const { return m_sPort; }
	BOOL IsFtpSite()
	{
		return lstrcmpi(m_pService->QueryServiceName(), SZ_MBN_FTP) == 0;
	}
	BOOL IsWebSite()
	{
		return lstrcmpi(m_pService->QueryServiceName(), SZ_MBN_WEB) == 0;
	}

//
// Interface:
//
public:
    virtual HRESULT RefreshData();
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual int QuerySortWeight() const { return SW_SITE; }
    virtual HRESULT RenameItem(LPOLESTR new_name);
    virtual HRESULT DeleteNode(IResultData * pResult);

    STDMETHOD(CreatePropertyPages)(
        LPPROPERTYSHEETCALLBACK lpProvider,
        LONG_PTR handle, 
        IUnknown * pUnk,
        DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        long lCommandID,
        CSnapInObjectRootBase * pObj,
        DATA_OBJECT_TYPES type
        );

    virtual void * GetNodeType()
    {
        return (void *)&cInstanceNode;
    }

public:
    static void InitializeHeaders(LPHEADERCTRL lpHeader);
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);

protected:
    virtual HRESULT BuildMetaPath(CComBSTR & bstrPath) const;
    virtual HRESULT BuildURL(CComBSTR & bstrURL) const;    
    virtual HRESULT EnumerateResultPane(BOOL fExp, IHeaderCtrl * pHdr, IResultData * pResData);

    HRESULT ChangeState(DWORD dwCommand);

    HRESULT ShowPropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );
    STDMETHOD(AddMenuItems)(
        IN LPCONTEXTMENUCALLBACK piCallback,
        IN long * pInsertionAllowed,
        IN DATA_OBJECT_TYPES type
        );
    HRESULT InsertNewInstance(DWORD inst);
    HRESULT InsertNewAlias(CString alias);

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_DESCRIPTION,
        COL_STATE,
        COL_DOMAIN_NAME,
        COL_IP_ADDRESS,
        COL_TCP_PORT,
        COL_STATUS,
        /**/
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

protected:
    static CComBSTR _bstrStarted;
    static CComBSTR _bstrStopped;
    static CComBSTR _bstrPaused;
    static CComBSTR _bstrUnknown;
    static CComBSTR _bstrAllUnassigned;
    static CComBSTR _bstrPending;
    static BOOL     _fStaticsLoaded;

private:
    BOOL        m_fResolved;
    CString     m_strDisplayName;
    
    //
    // Data members
    //
    BOOL        m_fDeletable;
    BOOL        m_fWolfPackEnabled;
    BOOL        m_fFrontPageWeb;
    DWORD       m_dwID;
    DWORD       m_dwState;
    DWORD       m_dwIPAddress;
    DWORD       m_dwWin32Error;
    USHORT      m_sPort;
    CComBSTR    m_bstrHostHeaderName;
    CComBSTR    m_bstrComment;
    CIISService * m_pService;
    CComBSTR    m_bstrDisplayNameStatus;
};



class CIISDirectory : public CIISMBNode
/*++

Class Description:

    Vroot/dir/file class.

--*/
{
//
// Constructor/Destructor
//
public:
    //
    // Constructor which will resolve its properties at display time
    //
    CIISDirectory(
        IN CIISMachine * pOwner,
        IN CIISService * pService,
        IN LPCTSTR szNodeName
        );

    //
    // Constructor with full information
    //
    CIISDirectory(
        CIISMachine * pOwner,
        CIISService * pService,
        LPCTSTR szNodeName,
        BOOL fEnabledApplication,
        DWORD dwWin32Error,
        LPCTSTR redir_path
        );

    virtual ~CIISDirectory();

//
// Access
//
public:
    virtual int      QueryImage() const;
    virtual LPOLESTR QueryDisplayName() { return m_bstrDisplayName; }
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const 
	{ 
		return m_pService->QueryVDirClass(); 
	}

public:
    //
    // Type Functions
    //
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsDeletable() const { return TRUE; }
//    virtual BOOL IsRenamable() const { return TRUE; }

    //
    // State Functions
    //
    virtual BOOL IsBrowsable() const { return TRUE; }
    virtual BOOL IsExplorable() const { return TRUE; }
    virtual BOOL IsOpenable() const { return TRUE; }
    virtual BOOL HasFileSystemFiles() const { return TRUE; }
//
// Data Access
//
public:
    BOOL   IsEnabledApplication() const { return m_fEnabledApplication; }
    DWORD  QueryWin32Error() const { return m_dwWin32Error; }
	BOOL IsFtpDir()
	{
		return lstrcmpi(m_pService->QueryServiceName(), SZ_MBN_FTP) == 0;
	}
	BOOL IsWebDir()
	{
		return lstrcmpi(m_pService->QueryServiceName(), SZ_MBN_WEB) == 0;
	}

//
// Interface:
//
public:
    virtual HRESULT RefreshData();
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    virtual int QuerySortWeight() const { return SW_VDIR; }
//    virtual HRESULT RenameItem(LPOLESTR new_name);

    STDMETHOD(AddMenuItems)(
        IN LPCONTEXTMENUCALLBACK piCallback,
        IN long * pInsertionAllowed,
        IN DATA_OBJECT_TYPES type
        );

    STDMETHOD(Command)(
        IN long lCommandID,
        IN CSnapInObjectRootBase * pObj,
        IN DATA_OBJECT_TYPES type
        );

    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LONG_PTR handle, 
        IN IUnknown * pUnk,
        IN DATA_OBJECT_TYPES type
        );

    virtual void * GetNodeType()
    {
        return (void *)&cChildNode;
    }

public:
    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    static void InitializeHeaders(LPHEADERCTRL lpHeader);

protected:
    //virtual HRESULT BuildURL(CComBSTR & bstrURL) const;    
    HRESULT InsertNewAlias(CString alias);
    virtual HRESULT EnumerateResultPane(
        BOOL fExpand, 
        IHeaderCtrl * lpHeader,
        IResultData * lpResultData
        )
    {
		CError err = CIISObject::EnumerateResultPane(fExpand, lpHeader, lpResultData);
		if (    err.Succeeded() 
            &&  !IsFtpDir() 
            &&  QueryWin32Error() == ERROR_SUCCESS 
            &&  m_strRedirectPath.IsEmpty()
            )
		{
			err = CIISMBNode::EnumerateResultPane_(
				fExpand, lpHeader, lpResultData, m_pService);
		}
		return err;
    }
    HRESULT ShowPropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,            OPTIONAL
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,                     OPTIONAL
        IN LPARAM  lParam,                      OPTIONAL
        IN LONG_PTR    handle                       OPTIONAL
        );

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ALIAS = 0,
        COL_PATH,
		COL_STATUS,
        //
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

protected:
//    static CComBSTR _bstrName, _bstrPath;
//    static BOOL     _fStaticsLoaded;

private:
    BOOL        m_fResolved;
    CComBSTR    m_bstrDisplayName;
    CComBSTR    m_bstrPath;
    
    //
    // Data members
    //
    BOOL        m_fEnabledApplication;
    DWORD       m_dwWin32Error;
    CIISService * m_pService;
};

class CApplicationNode : public CIISMBNode
{
public:
    CApplicationNode(
        CIISMachine * pOwner,
        LPCTSTR path,
        LPCTSTR name
        )
    : CIISMBNode(pOwner, name),
    m_meta_path(path)
    {
    }
        
    virtual ~CApplicationNode()
    {
    }

public:
    virtual BOOL IsLeafNode() const { return TRUE; }
    virtual int QueryImage() const
    {
        return iApplication;
    }
    virtual LPOLESTR QueryDisplayName();
    virtual HRESULT BuildMetaPath(CComBSTR& path) const;
    virtual int QuerySortWeight() const
    {
       CString parent, alias;
       CMetabasePath::SplitMetaPathAtInstance(m_meta_path, parent, alias);
       return alias.IsEmpty() ? SW_SITE : SW_VDIR;
    }
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
//    virtual int CompareResultPaneItem(CIISObject * pObject, int nCol);

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ALIAS,
        COL_PATH,
        //
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

    LPCTSTR FriendlyAppRoot(LPCTSTR lpAppRoot, CString & strFriendly);

private:
    CString m_strDisplayName;
    CString m_meta_path;
};

class CIISFileName : public CIISMBNode
{
public:
   CIISFileName(
      CIISMachine * pOwner,
      CIISService * pService,
      const DWORD dwAttributes,
      LPCTSTR alias,
      LPCTSTR redirect
      );

public:
   BOOL IsEnabledApplication() const 
   {
      return m_fEnabledApplication;
   }
   DWORD  QueryWin32Error() const 
   { 
       return m_dwWin32Error; 
   }

//
// Access
//
public:
    virtual int QueryImage() const;
    virtual LPOLESTR QueryDisplayName() 
    { 
        return m_bstrFileName; 
    }
    virtual LPOLESTR GetResultPaneColInfo(int nCol);
    virtual HRESULT DeleteNode(IResultData * pResult);
	virtual LPCTSTR GetKeyType(LPCTSTR path = NULL) const 
	{ 
		return (m_dwAttribute & FILE_ATTRIBUTE_DIRECTORY) != 0 ?
			IIS_CLASS_WEB_DIR_W : IIS_CLASS_WEB_FILE_W; 
	}

    //
    // Type Functions
    //
    virtual BOOL IsConfigurable() const { return TRUE; }
    virtual BOOL IsDeletable() const { return TRUE; }
    virtual BOOL IsRenamable() const { return TRUE; }
    virtual BOOL IsLeafNode() const { return TRUE; }

    //
    // State Functions
    //
    virtual BOOL IsBrowsable() const { return TRUE; }
    virtual BOOL IsExplorable() const 
    { 
        return IsDir(); 
    }
    virtual BOOL IsOpenable() const 
	{ 
		return TRUE; 
	}
    virtual BOOL HasFileSystemFiles() const 
    { 
        return IsDir(); 
    }

    virtual int QuerySortWeight() const 
    { 
       return IsDir() ? SW_DIR : SW_FILE; 
    }

    virtual void InitializeChildHeaders(LPHEADERCTRL lpHeader);
    virtual HRESULT RefreshData();
    virtual HRESULT EnumerateScopePane(HSCOPEITEM hParent);
    STDMETHOD(AddMenuItems)(
        IN LPCONTEXTMENUCALLBACK piCallback,
        IN long * pInsertionAllowed,
        IN DATA_OBJECT_TYPES type
        );
    STDMETHOD(Command)(
        IN long lCommandID,
        IN CSnapInObjectRootBase * pObj,
        IN DATA_OBJECT_TYPES type
        );
    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN LONG_PTR handle, 
        IN IUnknown * pUnk,
        IN DATA_OBJECT_TYPES type
        );

    virtual void * GetNodeType()
    {
        return (void *)&cFileNode;
    }
    virtual HRESULT RenameItem(LPOLESTR new_name);
	virtual HRESULT OnPropertyChange(BOOL fScope, IResultData * pResult);

protected:
    //
    // Result View Layout
    //
    enum
    {
        COL_ALIAS,
        COL_PATH,
        COL_STATUS,
        //
        COL_TOTAL
    };

    static int _rgnLabels[COL_TOTAL];
    static int _rgnWidths[COL_TOTAL];

    HRESULT ShowPropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,
        IN LPARAM  lParam,
        IN LONG_PTR handle
        );
    
    HRESULT ShowDirPropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,
        IN LPARAM  lParam,
        IN LONG_PTR handle
        );

    HRESULT ShowFilePropertiesDlg(
        IN LPPROPERTYSHEETCALLBACK lpProvider,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN CWnd * pMainWnd,
        IN LPARAM  lParam,
        IN LONG_PTR handle
        );

    HRESULT InsertNewAlias(CString alias);
    virtual HRESULT EnumerateResultPane(
        BOOL fExpand, 
        IHeaderCtrl * lpHeader,
        IResultData * lpResultData
        )
    {
		CError err = CIISObject::EnumerateResultPane(fExpand, lpHeader, lpResultData);
		if (err.Succeeded() && m_dwWin32Error == ERROR_SUCCESS)
		{
			err = CIISMBNode::EnumerateResultPane_(fExpand,
				lpHeader, lpResultData, m_pService);
		}
		return err;
    }

    BOOL IsDir() const
    {
        return (m_dwAttribute & FILE_ATTRIBUTE_DIRECTORY) != 0;
    }

private:
	BOOL m_fResolved;
    CComBSTR m_bstrFileName;
    CString m_RedirectString;
    BOOL m_fEnabledApplication;
    DWORD m_dwAttribute;
    DWORD m_dwWin32Error;
    CIISService * m_pService;
};


#if 0 
class CIISFileSystem
/*++

Class Description:

    Pure virtual base class to help enumerate the filesystem.  Sites, 
    virtual directory and file/directory nodes will be "is a" nodes
    of this type, in addition to deriving from CIISMBNode.

Public Interface:

--*/
{
//
// Constructor/Destructor
//
public:
    CIISFileSystem(LPCTSTR szFileName, BOOL fTerminal = FALSE);
    virtual ~CIISFileSystem();

protected:
    HRESULT BuildFilePath(
        IN  IConsoleNameSpace * lpConsoleNameSpace,
        IN  HSCOPEITEM hScopeItem,
        OUT CComBSTR & bstrPath
        ) const;

    BOOL IsFileTerminal() const { return m_fTerminal; }
    
private:
    CComBSTR  m_bstrFileName;
    BOOL      m_fTerminal;
};

#endif 0



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline HRESULT CIISObject::AddImages(LPIMAGELIST lpImageList)
{ 
    return SetImageList(lpImageList); 
}

inline HRESULT CIISObject::SetControlbar(
    IN LPCONTROLBAR lpControlbar, 
    IN LPEXTENDCONTROLBAR lpExtendControlbar
    )
{
    return __SetControlbar(lpControlbar, lpExtendControlbar);
}

inline /* virtual */ CMetaInterface * CIISMBNode::QueryInterface()
{
    ASSERT_PTR(m_pOwner != NULL);
    ASSERT(m_pOwner->HasInterface());

    return m_pOwner->QueryInterface();
}

inline /* virtual */ CComAuthInfo * CIISMBNode::QueryAuthInfo()
{
    ASSERT_PTR(m_pOwner != NULL);

    return m_pOwner->QueryAuthInfo();
}

inline /* virtual */ LPOLESTR CIISMBNode::QueryMachineName() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->QueryMachineName();
}

inline WORD CIISMBNode::QueryMajorVersion() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->QueryMajorVersion();
}

inline WORD CIISMBNode::QueryMinorVersion() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->QueryMinorVersion();
}

inline /* virtual */ BOOL CIISMBNode::IsLocal() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->IsLocal();
}

inline /* virtual */ BOOL CIISMBNode::HasInterface() const
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->HasInterface();
}

inline /* virtual */ HRESULT CIISMBNode::CreateInterface(BOOL fShowError)
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->CreateInterface(fShowError);
}
 
inline /* virtual */ HRESULT CIISMBNode::AssureInterfaceCreated(BOOL fShowError)
{
    ASSERT_PTR(m_pOwner);
    return m_pOwner->AssureInterfaceCreated(fShowError);
}

inline /* virtual */ void CIISMBNode::SetInterfaceError(HRESULT hr)
{
    ASSERT_PTR(m_pOwner);
    m_pOwner->SetInterfaceError(hr);
}

inline BOOL CIISMBNode::IsLostInterface(CError & err) const 
{ 
    return err.Win32Error() == RPC_S_SERVER_UNAVAILABLE; 
}

inline HRESULT CIISMachine::AssureInterfaceCreated(BOOL fShowError)
{
    return m_pInterface ? S_OK : CreateInterface(fShowError);
}

inline CIISService::QueryImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nServiceImage;
}

inline CIISService::QueryServiceImage() const
{
    return QueryImage();
}

inline CIISService::QuerySiteImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nSiteImage;
}

inline CIISService::QueryVDirImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nVDirImage;
}

inline CIISService::QueryDirImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nDirImage;
}

inline CIISService::QueryFileImage() const
{
    ASSERT(m_iServiceDef >= 0);
    return _rgServices[m_iServiceDef].nFileImage;
}

inline BOOL CIISService::IsManagedService() const 
{ 
    return m_fManagedService; 
}

inline HRESULT CIISSite::ShowPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM  lParam,
    LONG_PTR    handle
    )
{
    ASSERT_PTR(m_pService);
    return m_pService->ShowSitePropertiesDlg(
        lpProvider,
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        handle
        );
}

inline HRESULT CIISDirectory::ShowPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM  lParam,
    LONG_PTR    handle
    )
{
    ASSERT_PTR(m_pService);
    return m_pService->ShowDirPropertiesDlg(
        lpProvider,
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        handle
        );
}

inline HRESULT 
CIISFileName::ShowPropertiesDlg(
    LPPROPERTYSHEETCALLBACK lpProvider,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath,
    CWnd * pMainWnd,
    LPARAM  lParam,
    LONG_PTR    handle
    )
{
    ASSERT_PTR(m_pService);
    return m_pService->ShowDirPropertiesDlg(
        lpProvider,
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        handle
        );
}

#endif // __IISOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\iisservice.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        iisservice.cpp

   Abstract:

        IISService Object

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        10/28/2000      sergeia  Split from iisobj.cpp

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "connects.h"
#include "iisobj.h"
#include "ftpsht.h"
#include "fservic.h"
#include "facc.h"
#include "fmessage.h"
#include "fvdir.h"
#include "fsecure.h"
#include "w3sht.h"
#include "wservic.h"
#include "wvdir.h"
#include "wsecure.h"
#include "fltdlg.h"
#include "filters.h"
#include "w3accts.h"
#include "perform.h"
#include "docum.h"
#include "httppage.h"
#include "defws.h"
#include "deffs.h"
#include "errors.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW
//
// CIISService Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


/* static */
HRESULT
__cdecl
CIISService::ShowFTPSiteProperties(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpszMDPath,
    IN CWnd * pMainWnd,                     OPTIONAL
    IN LPARAM  lParam,                      OPTIONAL
    IN LONG_PTR    handle                       OPTIONAL
    )
/*++

Routine Description:

    Callback function to display FTP site properties.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT_PTR(lpProvider);

    CError err;

    CFtpSheet * pSheet = new CFtpSheet(
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        handle
        );

    if (pSheet)
    {
        pSheet->SetModeless();

        CIISMachine * pOwner = ((CIISMBNode *)lParam)->GetOwner();
        ASSERT(pOwner != NULL);
        //
        // Add instance pages
        //
        if (!pOwner->Has10ConnectionsLimit() || !CMetabasePath::IsMasterInstance(lpszMDPath))
        {
			err = AddMMCPage(lpProvider, new CFtpServicePage(pSheet));
		}
        err = AddMMCPage(lpProvider, new CFtpAccountsPage(pSheet));
        err = AddMMCPage(lpProvider, new CFtpMessagePage(pSheet));

        //
        // Add directory pages
        //
        err = AddMMCPage(lpProvider, new CFtpDirectoryPage(pSheet, TRUE));
		if (pOwner->QueryMajorVersion() >= 6)
		{
        	err = AddMMCPage(lpProvider, new CFtpSecurityPage(pSheet));
		}
        //
        // Add master site pages
        //
        if (CMetabasePath::IsMasterInstance(lpszMDPath) && pOwner->QueryMajorVersion() >= 6)
        {
            err = AddMMCPage(lpProvider, new CDefFtpSitePage(pSheet));
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



/* static */
HRESULT
__cdecl
CIISService::ShowFTPDirProperties(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpszMDPath,
    IN CWnd * pMainWnd,                     OPTIONAL
    IN LPARAM  lParam,                      OPTIONAL
    IN LONG_PTR    handle                       OPTIONAL
    )
/*++

Routine Description:

    Callback function to display FTP dir properties.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT_PTR(lpProvider);

    CError err;

    CFtpSheet * pSheet = new CFtpSheet(
        pAuthInfo,
        lpszMDPath,
        pMainWnd,
        lParam,
        handle
        );

    if (pSheet)
    {
        pSheet->SetModeless();

        CIISMachine * pOwner = ((CIISMBNode *)lParam)->GetOwner();
        ASSERT(pOwner != NULL);
        //
        // Add directory pages
        //
        err = AddMMCPage(lpProvider, new CFtpDirectoryPage(pSheet, FALSE));
		if (pOwner->QueryMajorVersion() >= 6)
		{
        	err = AddMMCPage(lpProvider, new CFtpSecurityPage(pSheet));
		}
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}

/* static */
HRESULT
__cdecl
CIISService::ShowWebSiteProperties(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpszMDPath,
    IN CWnd * pMainWnd,                     OPTIONAL
    IN LPARAM  lParam,                      OPTIONAL
    IN LONG_PTR    handle                       OPTIONAL
    )
/*++

Routine Description:

    Callback function to display Web site properties.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT_PTR(lpProvider);

    CError err;

    CW3Sheet * pSheet = new CW3Sheet(
        pAuthInfo,
        lpszMDPath,
        0, 
        pMainWnd,
        lParam,
        handle
        );

    if (pSheet)
    {
        pSheet->SetModeless();
        pSheet->SetSheetType(pSheet->SHEET_TYPE_SITE);

        CIISMachine * pOwner = ((CIISMBNode *)lParam)->GetOwner();
        ASSERT(pOwner != NULL);

		BOOL bMaster = CMetabasePath::IsMasterInstance(lpszMDPath);
		BOOL bClient = pOwner->Has10ConnectionsLimit();
		BOOL bDownlevel = (pOwner->QueryMajorVersion() == 5 && pOwner->QueryMinorVersion() == 0);
        //
        // Add instance pages
        //
        if (!bClient || !bMaster)
        {
			err = AddMMCPage(lpProvider, new CW3ServicePage(pSheet));
		}
        if (!bClient)
		{
            err = AddMMCPage(lpProvider, new CW3AccountsPage(pSheet));
            if (bDownlevel)
            {
				if (!bMaster)
				{
					err = AddMMCPage(lpProvider, new CW3PerfPage(pSheet));
				}
            }
			else
			{
			    err = AddMMCPage(lpProvider, new CW3PerfPage(pSheet));
			}
        }
        err = AddMMCPage(lpProvider, new CW3FiltersPage(pSheet));
        //
        // Add directory pages
        //
        err = AddMMCPage(lpProvider, new CW3DirectoryPage(pSheet, TRUE));
        err = AddMMCPage(lpProvider, new CW3DocumentsPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, TRUE, FILE_ATTRIBUTE_VIRTUAL_DIRECTORY));
        err = AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));
        if (bMaster && pOwner->QueryMajorVersion() >= 6)
        {
           err = AddMMCPage(lpProvider, new CDefWebSitePage(pSheet));
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return S_OK;
}



/* static */
HRESULT
__cdecl
CIISService::ShowWebDirProperties(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpszMDPath,
    IN CWnd * pMainWnd,                     OPTIONAL
    IN LPARAM  lParam,                      OPTIONAL
    IN LONG_PTR    handle                       OPTIONAL
    )
/*++

Routine Description:

    Callback function to display Web dir properties.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT_PTR(lpProvider);

    CError err;

    CW3Sheet * pSheet = new CW3Sheet(
        pAuthInfo,
        lpszMDPath,
        0, 
        pMainWnd,
        lParam,
        handle
        );

    if (pSheet)
    {
        pSheet->SetModeless();

        //
        // Add directory pages
        //
        pSheet->SetSheetType(pSheet->SHEET_TYPE_VDIR);
        err = AddMMCPage(lpProvider, new CW3DirectoryPage(pSheet, FALSE));
        err = AddMMCPage(lpProvider, new CW3DocumentsPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, FALSE, FILE_ATTRIBUTE_VIRTUAL_DIRECTORY));
        err = AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
        err = AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));

    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;
}



//
// Administrable services
//
/* static */ CIISService::SERVICE_DEF CIISService::_rgServices[] = 
{
    { 
        _T("MSFTPSVC"),   
        _T("ftp://"),  
        IDS_SVC_FTP, 
        iFolder,    // TODO: Need service bitmap
        iFTPSite, 
        iFTPDir,
        iFolder,
        iFile,
		IIS_CLASS_FTP_SERVICE_W,
		IIS_CLASS_FTP_SERVER_W,
		IIS_CLASS_FTP_VDIR_W,
        &CIISService::ShowFTPSiteProperties, 
        &CIISService::ShowFTPDirProperties, 
    },
    { 
        _T("W3SVC"),      
        _T("http://"), 
        IDS_SVC_WEB, 
        iFolder,    // TODO: Need service bitmap
        iWWWSite, 
        iWWWDir,
        iFolder,
        iFile,
		IIS_CLASS_WEB_SERVICE_W,
		IIS_CLASS_WEB_SERVER_W,
		IIS_CLASS_WEB_VDIR_W,
        &CIISService::ShowWebSiteProperties, 
        &CIISService::ShowWebDirProperties, 
    },
};



/* static */
int
CIISService::ResolveServiceName(
    IN  LPCTSTR    szServiceName
    )
/*++

Routine Description:

    Look up the service name in the table.  Return table index.

Arguments:

    LPCTSTR    szServiceName        : Metabase node name

Return Value:

    Table index or -1 if not found.    

--*/
{
    int iDef = -1;

    //
    // Sequential search because we expect just a few entries
    //
    for (int i = 0; i < ARRAY_SIZE(_rgServices); ++i)
    {
        if (!::lstrcmpi(szServiceName, _rgServices[i].szNodeName))
        {
            iDef = i;
            break;
        }
    }

    return iDef;
}



CIISService::CIISService(
    IN CIISMachine * pOwner,
    IN LPCTSTR szServiceName
    )
/*++

Routine Description:

    Constructor.  Determine if the given service is administrable, 
    and resolve the details

Arguments:

    CIISMachine * pOwner        : Owner machine object
    LPCTSTR szServiceName       : Service name

Return Value:

    N/A

--*/
    : CIISMBNode(pOwner, szServiceName)
{
    m_iServiceDef = ResolveServiceName(QueryNodeName());
    m_fManagedService = (m_iServiceDef >= 0);
    m_fCanAddInstance = pOwner->CanAddInstance();

    if (m_fManagedService)
    {
        ASSERT(m_iServiceDef < ARRAY_SIZE(_rgServices));
        VERIFY(m_bstrDisplayName.LoadString(
            _rgServices[m_iServiceDef].nDescriptiveName
            ));
    }
}



/* virtual */
CIISService::~CIISService()
/*++

Routine Description:

    Destructor

Arguments:
    
    N/A

Return Value:

    N/A

--*/
{
}

/* virtual */
void 
CIISService::InitializeChildHeaders(
    IN LPHEADERCTRL lpHeader
    )
/*++

Routine Description:

    Build result view for immediate descendant type

Arguments:

    LPHEADERCTRL lpHeader      : Header control

Return Value:

    None

--*/
{
    CIISSite::InitializeHeaders(lpHeader);
}

/* virtual */
HRESULT 
CIISService::EnumerateScopePane(HSCOPEITEM hParent)
/*++

Routine Description:

    Enumerate scope child items.

Arguments:

    HSCOPEITEM hParent                      : Parent console handle

Return Value:

    HRESULT

--*/
{
    CError  err;
    DWORD   dwInstance;
    CString strInstance;
    CMetaEnumerator * pme = NULL;

    if (!IsAdministrator())
    {
        return err;
    }
    err = CreateEnumerator(pme);
        
    while (err.Succeeded())
    {
        CIISSite * pSite;

        err = pme->Next(dwInstance, strInstance);

        if (err.Succeeded())
        {
            TRACEEOLID("Enumerating node: " << dwInstance);
            if (NULL == (pSite = new CIISSite(m_pOwner, this, strInstance)))
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            err = pSite->AddToScopePane(hParent);
        }
    }

    SAFE_DELETE(pme);

    if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
    {
        err.Reset();
    }

    if (err.Failed())
    {
        DisplayError(err);
    }

//    SetInterfaceError(err);

    return err;
}

/* virtual */
HRESULT
CIISService::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK lpContextMenuCallback,
    IN OUT long * pInsertionAllowed,
    IN DATA_OBJECT_TYPES type
    )
{
    ASSERT_READ_PTR(lpContextMenuCallback);

    //
    // Add base menu items
    //
    HRESULT hr = CIISObject::AddMenuItems(
        lpContextMenuCallback,
        pInsertionAllowed,
        type
        );

    if (SUCCEEDED(hr) && m_fCanAddInstance)
    {
        ASSERT(pInsertionAllowed != NULL);
        if (IsAdministrator() && (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0)
        {
           AddMenuSeparator(lpContextMenuCallback);

           if (lstrcmpi(GetNodeName(), SZ_MBN_FTP) == 0)
           {
              AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_FTP_SITE);
           }
           else if (lstrcmpi(GetNodeName(), SZ_MBN_WEB) == 0)
           {
              AddMenuItemByCommand(lpContextMenuCallback, IDM_NEW_WEB_SITE);
           }
        }
        //
        // CODEWORK: Add new instance commands for each of the services
        //           keeping in mind which ones are installed and all.
        //           add that info to the table, remembering that this
        //           is per service.
        //
    }

    return hr;
}

HRESULT
CIISService::InsertNewInstance(DWORD inst)
{
    CError err;
    // Now we should insert and select this new site
    TCHAR buf[16];
    CIISSite * pSite = new CIISSite(m_pOwner, this, _itot(inst, buf, 10));
    if (pSite != NULL)
    {
        // If service is not expanded we will get error and no effect
        if (!IsExpanded())
        {
            SelectScopeItem();
            IConsoleNameSpace2 * pConsole 
                    = (IConsoleNameSpace2 *)GetConsoleNameSpace();
            pConsole->Expand(QueryScopeItem());
        }
		// WAS needs some time to update status of new site as started
		Sleep(1000);
        err = pSite->AddToScopePaneSorted(QueryScopeItem(), FALSE);
        if (err.Succeeded())
        {
            VERIFY(SUCCEEDED(pSite->SelectScopeItem()));
        }
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    return err;
}

HRESULT
CIISService::Command(
    IN long lCommandID,     
    IN CSnapInObjectRootBase * pObj,
    IN DATA_OBJECT_TYPES type
    )
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    HRESULT hr = S_OK;
    DWORD inst;

    switch (lCommandID)
    {
    case IDM_NEW_FTP_SITE:
        if (SUCCEEDED(hr = AddFTPSite(pObj, type, &inst)))
        {
            hr = InsertNewInstance(inst);
        }
        break;

    case IDM_NEW_WEB_SITE:
        if (SUCCEEDED(hr = AddWebSite(pObj, type, &inst)))
        {
            hr = InsertNewInstance(inst);
        }
        break;

    default:
        hr = CIISMBNode::Command(lCommandID, pObj, type);
        break;
    }
    return hr;
}

/* virtual */
HRESULT 
CIISService::BuildURL(
    OUT CComBSTR & bstrURL
    ) const
/*++

Routine Description:

    Recursively build up the URL from the current node
    and its parents.

Arguments:

    CComBSTR & bstrURL  : Returns URL

Return Value:

    HRESULT

--*/
{
    //
    // This starts off the URL
    //
    ASSERT(m_iServiceDef < ARRAY_SIZE(_rgServices));
    bstrURL = _rgServices[m_iServiceDef].szProtocol;

    return S_OK;
}



HRESULT
CIISService::ShowSitePropertiesDlg(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpszMDPath,
    IN CWnd * pMainWnd,                     OPTIONAL
    IN LPARAM  lParam,                      OPTIONAL
    IN LONG_PTR    handle                       OPTIONAL
    )
/*++

Routine Description:

    Display site properties dialog

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT(m_iServiceDef >= 0 && m_iServiceDef < ARRAY_SIZE(_rgServices));
    return (*_rgServices[m_iServiceDef].pfnSitePropertiesDlg)(
        lpProvider,
        pAuthInfo, 
        lpszMDPath,
        pMainWnd,
        lParam,
        handle
        );
}



HRESULT
CIISService::ShowDirPropertiesDlg(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CComAuthInfo * pAuthInfo,            OPTIONAL
    IN LPCTSTR lpszMDPath,
    IN CWnd * pMainWnd,                     OPTIONAL
    IN LPARAM  lParam,                      OPTIONAL
    IN LONG_PTR    handle                       OPTIONAL
    )
/*++

Routine Description:

    Display directory properties dialog

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  Property sheet provider
    CComAuthInfo * pAuthInfo            COM Authentication info or NULL.
    LPCTSTR lpszMDPath                  Metabase path
    CWnd * pMainWnd                     Parent window
    LPARAM  lParam                      LPARAM to pass to MMC
    LONG    handle                      handle to pass to MMC

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT(m_iServiceDef >= 0 && m_iServiceDef < ARRAY_SIZE(_rgServices));
    return (*_rgServices[m_iServiceDef].pfnDirPropertiesDlg)(
        lpProvider,
        pAuthInfo, 
        lpszMDPath,
        pMainWnd,
        lParam,
        handle
        );
}




/* virtual */
HRESULT
CIISService::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN LONG_PTR handle, 
    IN IUnknown * pUnk,
    IN DATA_OBJECT_TYPES type
    )
/*++

Routine Description:

    Create the property pages for the given object

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Provider
    LONG_PTR handle                     : Handle.
    IUnknown * pUnk,
    DATA_OBJECT_TYPES type

Return Value:

    HRESULT
                                                
--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CComBSTR bstrPath;

    //
    // CODEWORK: What to do with m_err?  This might be 
    // a bad machine object in the first place.  Aborting
    // when the machine object has an error code isn't 
    // such a bad solution here.
    //

    /*
    if (m_err.Failed())
    {
        m_err.MessageBox();
        return m_err;
    }
    */

    CError err(BuildMetaPath(bstrPath));

    if (err.Succeeded())
    {
        //
        // Show master properties
        //
        err = ShowSitePropertiesDlg(
            lpProvider,
            QueryAuthInfo(), 
            bstrPath,
            GetMainWindow(),
            (LPARAM)this,
            handle
            );
    }

    err.MessageBoxOnFailure();

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\inetmgrcomp.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        inetmgr.cpp

   Abstract:

        Main MMC snap-in code

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "guids.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


//const GUID * CCompMgrExtData::m_NODETYPE = &cCompMgmtService;
//const OLECHAR * CCompMgrExtData::m_SZNODETYPE = OLESTR("476e6446-aaff-11d0-b944-00c04fd8d5b0");
//const OLECHAR * CCompMgrExtData::m_SZDISPLAY_NAME = OLESTR("CMSnapin");
//const CLSID * CCompMgrExtData::m_SNAPIN_CLASSID = &CLSID_InetMgr;

extern CInetmgrApp theApp;

static HRESULT
GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
	if (lpCompiledHelpFile == NULL)
		return E_INVALIDARG;
	CString strFilePath, strWindowsPath, strBuffer;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// Use system API to get windows directory.
	UINT uiResult = GetWindowsDirectory(strWindowsPath.GetBuffer(MAX_PATH), MAX_PATH);
	strWindowsPath.ReleaseBuffer();
	if (uiResult <= 0 || uiResult > MAX_PATH)
	{
		return E_FAIL;
	}

	if (!strFilePath.LoadString(IDS_HELPFILE))
	{
		return E_FAIL;
	}
   
	strBuffer = strWindowsPath;
	strBuffer += _T('\\');
	strBuffer += strFilePath;

	*lpCompiledHelpFile 
			= reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((strBuffer.GetLength() + 1) 
					* sizeof(_TCHAR)));
	if (*lpCompiledHelpFile == NULL)
		return E_OUTOFMEMORY;
	USES_CONVERSION;
	_tcscpy(*lpCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)strBuffer));
	return S_OK;
}

//
// CInetMgrComponent Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CInetMgrComponent::CInetMgrComponent() 
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
{
}


HRESULT
CInetMgrComponent::Notify(
    IN LPDATAOBJECT lpDataObject, 
    IN MMC_NOTIFY_TYPE event, 
    IN LPARAM arg, 
    IN LPARAM param
    )
/*++

Routine Description:

    Notification handler.

Arguments:

    LPDATAOBJECT lpDataObject       : Data object
    MMC_NOTIFY_TYPE event           : Notification event
    long arg                        : Event specific argument
    long param                      : Event specific parameter

Return Value:

    HRESULT

--*/
{
    if (lpDataObject != NULL)
    {
        //
        // Pass it on to IComponentImpl
        //
        return IComponentImpl<CInetMgrComponent>::Notify(lpDataObject, event, arg, param);
    }

    return E_NOTIMPL;
}



HRESULT
CInetMgrComponent::GetClassID(
    OUT CLSID * pClassID
    )
/*++

Routine Description:

    Get class ID for storage stream.

Arguments:

    CLSID * pClassID            : Returns class ID information

Return Value:

    HRESULT

--*/
{
    *pClassID = CLSID_InetMgr;

    return S_OK;
}   


STDMETHODIMP 
CInetMgrComponent::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
	return ::GetHelpTopic(lpCompiledHelpFile);
}

STDMETHODIMP 
CInetMgrComponent::GetLinkedTopics(LPOLESTR *lpCompiledHelpFile)
{
	return S_FALSE;
}


HRESULT
CInetMgrComponent::IsDirty()
/*++

Routine Description:

    Check to see if we need to write to the cache.

Arguments:

    None

Return Value:

    S_OK if dirty, S_FALSE if not

--*/
{
    TRACEEOLID("CInetMgrComponent::IsDirty");

    return S_FALSE;
}



HRESULT
CInetMgrComponent::InitNew(
    IN OUT IStorage * pStg
    )
/*++

Routine Description:

    Initialize storage stream.

Arguments:

    IStorage * pStg      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::InitNew");

    return S_OK;
}



HRESULT
CInetMgrComponent::Load(
    IN OUT IStorage * pStg
    )
/*++

Routine Description:

    Load from the storage stream

Arguments:

    IStorage * pStg      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::Load");

    return S_OK;
}



/* virtual */
HRESULT 
STDMETHODCALLTYPE 
CInetMgrComponent::Save(
    IN OUT IStorage * pStgSave,
    IN BOOL fSameAsLoad
    )
/*++

Routine Description:

    Save to to the storage stream.

Arguments:

    IStorage * pStgSave     : Storage stream
    BOOL fSameAsLoad        : TRUE if same as load

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::Save");

    return S_OK;
}

    

/* virtual */ 
HRESULT 
STDMETHODCALLTYPE 
CInetMgrComponent::SaveCompleted(IStorage * pStgNew)
/*++

Routine Description:

    Save completed.

Arguments:

    IStorage * pStgNew      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::SaveCompleted");

    return S_OK;
}



/* virtual */
HRESULT 
STDMETHODCALLTYPE 
CInetMgrComponent::HandsOffStorage()
/*++

Routine Description:

    Hands off storage.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::HandsOffStorage");

    return S_OK;

}



/* virtual */ 
HRESULT 
CInetMgrComponent::SetControlbar(
    IN LPCONTROLBAR lpControlBar
    )
/*++

Routine Description:

    Set/Reset the control bar

Arguments:

    LPCONTROLBAR lpControlBar       : Control bar pointer or NULL

Return Value:

    HRESULT

--*/
{
    return CIISObject::__SetControlbar(lpControlBar, this);
}



/* virtual */
HRESULT
CInetMgrComponent::ControlbarNotify(
    IN MMC_NOTIFY_TYPE event, 
    IN LPARAM arg, 
    IN LPARAM param
    )
/*++

Routine Description:

    Handle control bar notification message.  Figure out the CIISObject
    selected, and pass the notification message off to it.

Arguments:

    MMC_NOTIFY_TYPE event       : Notification message
    long arg                    : Message specific argument
    long param                  : Message specific parameter

Return Value:

    HRESULT

--*/
{
    HRESULT hr = S_OK;

    CSnapInItem * pItem = NULL;
    DATA_OBJECT_TYPES type;

    //
    // Special casing this is annoying...
    //
    // CODEWORK: Handle MMCN_HELP and others
    //
    if (event == MMCN_BTN_CLICK)
    {
        hr = m_pComponentData->GetDataClass((IDataObject *)arg, &pItem, &type);
    }
    else if (event == MMCN_SELECT)
    {
        hr = m_pComponentData->GetDataClass((IDataObject *)param, &pItem, &type);
    }

    //
    // Find out CIISObject this belongs to and pass on
    // the message
    //
    CIISObject * pObject = (CIISObject *)pItem;

    if (SUCCEEDED(hr) && pObject != NULL)
    {
        hr = pObject->ControlbarNotify(event, arg, param);
    }

    return hr;
}



/* virtual */
HRESULT
CInetMgrComponent::Compare(
    IN  RDCOMPARE * prdc, 
    OUT int * pnResult
    )
/*++

Routine Description:

    Compare method used for sorting the result and scope panes.

Arguments:

    RDCOMPARE * prdc    : Compare structure
    int * pnResult      : Returns result

Return Value:

    HRESULT

--*/
{
    if (!pnResult || !prdc || !prdc->prdch1->cookie || !prdc->prdch2->cookie)
    {
        ASSERT_MSG("Invalid parameter(s)");
        return E_POINTER;
    }

    CIISObject * pObjectA = (CIISObject *)prdc->prdch1->cookie;
    CIISObject * pObjectB = (CIISObject *)prdc->prdch2->cookie;

    *pnResult = pObjectA->CompareResultPaneItem(pObjectB, prdc->nColumn);

    return S_OK;
}



/* virtual */
HRESULT
CInetMgrComponent::CompareObjects(
    IN LPDATAOBJECT lpDataObjectA,
    IN LPDATAOBJECT lpDataObjectB
    )
/*++

Routine Description:

    Compare two data objects.  This method is used to see if a property
    sheet for the given data object is already open

Arguments:

    LPDATAOBJECT lpDataObjectA      : A data object
    LPDATAOBJECT lpDataObjectB      : B data object

Return Value:

    S_OK if they match, S_FALSE otherwise

--*/
{
    //
    // Pass it on to IComponentImpl
    //
    return IComponentImpl<CInetMgrComponent>::CompareObjects(lpDataObjectA, lpDataObjectB);
}



//
// CInetMgr Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */ DWORD   CInetMgr::_dwSignature = 0x3517;
/* static */ LPCTSTR CInetMgr::_szStream = _T("CInetMgr");



/* static */ 
void 
WINAPI 
CInetMgr::ObjectMain(
    IN bool bStarting
    )
/*++

Routine Description:

    CInetMgr main entry point

Arguments:

    bool bStarting      : TRUE if starting

Return Value:

    None

--*/
{
    if (bStarting)
    {
        //
        // Register clipboard formats
        //
        CSnapInItem::Init();
        CIISObject::Init();
    }
}




CInetMgr::CInetMgr() 
{
    //
    // Initialize the root node
    //
    CIISObject::Initialize();

    m_pNode = new CIISRoot;
    ASSERT_PTR(m_pNode);
    m_pComponentData = this;
}



CInetMgr::~CInetMgr()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    //
    // Clean up the root node
    //
    delete m_pNode;
    m_pNode = NULL;
    CIISObject::Destroy();
}



HRESULT 
CInetMgr::Initialize(
    IN LPUNKNOWN lpUnknown
    )
/*++

Routine Description:

    Initialize the snap-in
    
Arguments:

    LPUNKNOWN lpUnknown  : IUnknown

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = 
        IComponentDataImpl<CInetMgr, CInetMgrComponent>::Initialize(lpUnknown);

    if (FAILED(hr))
    {
        return hr;
    }

    hr = CIISObject::AttachScopeView(lpUnknown);

    if (FAILED(hr))
    {
        TRACEEOLID("failed to query console name space interface");

        return hr;
    }

    CComPtr<IImageList> lpImageList;

    hr = m_spConsole->QueryScopeImageList(&lpImageList);
    if (FAILED(hr) || lpImageList == NULL)
    {
        TRACEEOLID("IConsole::QueryScopeImageList failed");
        return E_UNEXPECTED;
    }

    return CIISObject::SetImageList(lpImageList);
}


HRESULT 
CInetMgr::OnPropertyChange(LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    if (param != 0)
    {
        CSnapInItem * pNode = (CSnapInItem *)param;
        LPDATAOBJECT pDataObject = NULL;
        pNode->GetDataObject(&pDataObject, CCT_SCOPE);
        hr = m_spConsole->UpdateAllViews(pDataObject, param, 0);
    }

    return hr;
}

HRESULT
CInetMgr::Notify(
    LPDATAOBJECT lpDataObject, 
    MMC_NOTIFY_TYPE event, 
    LPARAM arg, 
    LPARAM param
    )
{
    HRESULT hr = S_OK;

    if (lpDataObject == NULL)
    {
        switch (event)
        {
        case MMCN_PROPERTY_CHANGE:
            hr = OnPropertyChange(arg, param);
            break;
        case MMCN_SNAPINHELP:
            break;
        default:
            break;
        }
    }
    else
    {
        hr = IComponentDataImpl<CInetMgr, CInetMgrComponent>::Notify(
            lpDataObject, event, arg, param);
    }
    return hr;
}


HRESULT
CInetMgr::GetClassID(CLSID * pClassID)
/*++

Routine Description:

    Get class ID for storage stream

Arguments:

    CLSID * pClassID            : Returns class ID information

Return Value:

    HRESULT

--*/
{
    *pClassID = CLSID_InetMgr;

    return S_OK;
}   


STDMETHODIMP 
CInetMgr::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
	return ::GetHelpTopic(lpCompiledHelpFile);
}


STDMETHODIMP 
CInetMgr::GetLinkedTopics(LPOLESTR *lpCompiledHelpFile)
{
	return S_FALSE;
}

HRESULT
CInetMgr::IsDirty()
/*++

Routine Description:

    Check to see if we need to write to the cache.

Arguments:

    None

Return Value:

    S_OK if dirty, S_FALSE if not

--*/
{
    TRACEEOLID("CInetMgrComponent::IsDirty");
    ASSERT_PTR(m_pNode);

    if (IsExtension())
    {
        return FALSE;
    }
    else
    {
        return ((CIISRoot *)m_pNode)->m_scServers.IsDirty() ? S_OK : S_FALSE;
    }
}



HRESULT
CInetMgr::InitNew(IStorage * pStg)
/*++

Routine Description:

    Initialize new storage stream (newly created console file)

Arguments:

    IStorage * pStg      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::InitNew");

    //
    // We could create the stream here, but it's just as easy to
    // create it inside Save().
    //
    return S_OK;
}



HRESULT
CInetMgr::Load(IStorage * pStg)
/*++

Routine Description:

    Load machine cache from the storage stream.

Arguments:

    IStorage * pStg      : Storage stream

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TRACEEOLID("CInetMgrComponent::Load");

    if (IsExtension())
    {
        return S_OK;
    }

    ASSERT_READ_WRITE_PTR(pStg);

    DWORD   cBytesRead;
    DWORD   dw;
    HRESULT hr = S_OK;
    CIISServerCache & cache = ((CIISRoot *)m_pNode)->m_scServers;
    IStream * pStream = NULL;

    ASSERT(cache.IsEmpty());

    do
    {
        hr = pStg->OpenStream(
            _szStream,
            NULL,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            0L,
            &pStream
            );

        if (FAILED(hr))
        {
            break;
        }

        //
        // Read and verify the signature
        //
        hr = pStream->Read(&dw, sizeof(dw), &cBytesRead);
        ASSERT(SUCCEEDED(hr) && cBytesRead == sizeof(dw));

        if (FAILED(hr))
        {
            break;
        }

        if (dw != _dwSignature)
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_CORRUPT);
            break;
        }

        //
        // Read number of machines in the cache
        //
        DWORD cMachines;

        hr = pStream->Read(&cMachines, sizeof(cMachines), &cBytesRead);
        ASSERT(SUCCEEDED(hr) && cBytesRead == sizeof(cMachines));

        if (FAILED(hr))
        {
            break;
        }

        TRACEEOLID("Reading " << cMachines << " machines from cache");

        CIISMachine * pMachine;

        //
        // Read each machine from the cache
        //
        for (dw = 0; dw < cMachines; ++dw)
        {
            hr = CIISMachine::ReadFromStream(pStream, &pMachine);

            if (FAILED(hr))
            {
                break;
            }

            if (!cache.Add(pMachine))
            {
                delete pMachine;
            }
        }
    }
    while(FALSE);

    if (pStream)
    {
        pStream->Release();
    }

    if (hr == STG_E_FILENOTFOUND)
    {
        //
        // Stream was not initialized.  This is acceptable.
        //
        hr = S_OK;
    }

    //
    // Mark cache as clean
    //
    cache.SetDirty(FALSE);

    return hr;
}



/* virtual */
HRESULT STDMETHODCALLTYPE 
CInetMgr::Save(IStorage * pStgSave, BOOL fSameAsLoad)
/*++

Routine Description:

    Save computer cache to to the storage stream.

Arguments:

    IStorage * pStgSave     : Storage stream
    BOOL fSameAsLoad        : TRUE if same as load

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TRACEEOLID("CInetMgrComponent::Save");

    if (IsExtension())
    {
        return S_OK;
    }

    //
    // Write the computer names to the cache
    //
    ASSERT_READ_WRITE_PTR(pStgSave);

    DWORD   cBytesWritten;
    HRESULT hr = STG_E_CANTSAVE;
    IStream * pStream = NULL;
    CIISServerCache & cache = ((CIISRoot *)m_pNode)->m_scServers;

    do
    {
        hr = pStgSave->CreateStream(
            _szStream,
            STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE,
            0L,
            0L,
            &pStream
            );

        if (FAILED(hr))
        {
            break;
        }

        //
        // Write the signature
        //
        hr = pStream->Write(&_dwSignature, sizeof(_dwSignature), &cBytesWritten);
        ASSERT(SUCCEEDED(hr) && cBytesWritten == sizeof(_dwSignature));

        if (FAILED(hr))
        {
            break;
        }

        //
        // Write number of entries.
        //
        INT_PTR dw = cache.GetCount();

        hr = pStream->Write(&dw, sizeof(dw), &cBytesWritten);
        ASSERT(SUCCEEDED(hr) && cBytesWritten == sizeof(dw));

        if (FAILED(hr))
        {
            break;
        }

        //
        // Write each string -- but write them in reverse
        // order to improve our sort performance when we load
        // the cache.
        //
        CIISMachine * pMachine = cache.GetLast();

        while(pMachine)
        {
            hr = pMachine->WriteToStream(pStream);

            if (FAILED(hr))
            {
                break;
            }

            pMachine = cache.GetPrev();
        }
    }
    while(FALSE);

    if (pStream)
    {
        pStream->Release();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Mark cache as clean
        //
        cache.SetDirty(FALSE);
    }

    return hr;
}

    

/* virtual */ 
HRESULT 
STDMETHODCALLTYPE 
CInetMgr::SaveCompleted(IStorage * pStgNew)
/*++

Routine Description:

    Save completed notification.

Arguments:

    IStorage * pStgNew      : Storage stream

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::SaveCompleted");

    //
    // Nothing to do
    //
    return S_OK;
}



/* virtual */
HRESULT 
STDMETHODCALLTYPE 
CInetMgr::HandsOffStorage()
/*++

Routine Description:

    Hands off storage.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    TRACEEOLID("CInetMgrComponent::HandsOffStorage");

    //
    // Nothing to do
    //
    return S_OK;
}



/* virtual */
HRESULT
CInetMgr::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
/*++

Routine Description:

    Compare two data objects.  This method is used by MMC to see if a property
    sheet for the given data object is already open.

Arguments:

    LPDATAOBJECT lpDataObjectA      : A data object
    LPDATAOBJECT lpDataObjectB      : B data object

Return Value:

    S_OK if they match, S_FALSE otherwise

--*/
{
    HRESULT hr = E_POINTER;

    do
    {
        if (!lpDataObjectA || !lpDataObjectB)
        {
            TRACEEOLID("IComponentData::CompareObjects called with NULL ptr");
            break;
        }

        CSnapInItem * pItemA;
        CSnapInItem * pItemB;
        DATA_OBJECT_TYPES type;

        hr = m_pComponentData->GetDataClass(lpDataObjectA, &pItemA, &type);

        if (SUCCEEDED(hr))
        {
            hr = m_pComponentData->GetDataClass(lpDataObjectB, &pItemB, &type);
        }

        if (FAILED(hr))
        {
            break;
        }

        if (!pItemA || !pItemB)
        {
            hr = E_POINTER;
            break;
        }

        if (pItemA == pItemB)
        {
            //
            // Literally the same object
            //
            hr = S_OK;
            break;
        }

        CIISObject * pObjectA = (CIISObject *)pItemA;
        CIISObject * pObjectB = (CIISObject *)pItemB;

        hr = !pObjectA->CompareScopeItem(pObjectB) ? S_OK : S_FALSE;
    }
    while(FALSE);

    return hr;
}

HRESULT 
CInetMgr::GetDataClass(
    IDataObject * pDataObject, 
    CSnapInItem ** ppItem, 
    DATA_OBJECT_TYPES * pType)
{
    if (ppItem == NULL)
	    return E_POINTER;
    if (pType == NULL)
	    return E_POINTER;

    *ppItem = NULL;
    *pType = CCT_UNINITIALIZED;
    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE,
			NULL,
			DVASPECT_CONTENT,
			-1,
			TYMED_HGLOBAL
		};

	stgmedium.hGlobal = GlobalAlloc(0, sizeof(GUID));
    if (stgmedium.hGlobal == NULL)
        return E_OUTOFMEMORY; 

	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);
    if (FAILED(hr))
    { 
	    GlobalFree(stgmedium.hGlobal);
	    return hr;
    }

	GUID guid;
	memcpy(&guid, stgmedium.hGlobal, sizeof(GUID));

	GlobalFree(stgmedium.hGlobal);
	hr = S_OK;

	if (IsEqualGUID(guid, cCompMgmtService))
    {
        if (!IsExtension())
        {
			CIISRoot * pRootExt = new CIISRoot;
			if (pRootExt == NULL)
			{
				return E_OUTOFMEMORY;
			}
            hr = pRootExt->InitAsExtension(pDataObject);
			if (FAILED(hr))
			{
				return hr;
			}
			if (m_pNode != NULL)
			{
				delete m_pNode;
			}
			m_pNode = pRootExt;
        }
        *ppItem = m_pNode;

		return hr;
    }
	return CSnapInItem::GetDataClass(pDataObject, ppItem, pType);
};

BOOL
CInetMgr::IsExtension()
{
    ASSERT(m_pNode != NULL);
    CIISRoot * pRoot = (CIISRoot *)m_pNode;
    return pRoot->IsExtension();
}


//
// CInetMrgAbout Class
// 
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
CInetMgrAbout::GetStringHelper(UINT nStringID, LPOLESTR * lpString)
/*++

Routine Description:

    Get resource string helper function.  Called from inline string fetcher
    methods.

Arguments:

    UINT nStringID      : String ID from local resource segment
    LPOLESTR * lpString : Returns the string

Return Value:

    HRESULT

--*/
{
    USES_CONVERSION;

    TCHAR szBuf[256];

    if (::LoadString(
        _Module.GetResourceInstance(), 
        nStringID, 
        szBuf, 
        256) == 0)
    {
        return E_FAIL;
    }

    *lpString = (LPOLESTR)::CoTaskMemAlloc(
        (lstrlen(szBuf) + 1) * sizeof(OLECHAR)
        );

    if (*lpString == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ::ocscpy(*lpString, T2OLE(szBuf));

    return S_OK;
}



HRESULT
CInetMgrAbout::GetSnapinImage(HICON * hAppIcon)
/*++

Routine Description:

    Get the icon for this snapin.

Arguments:

    HICON * hAppIcon : Return handle to the icon

Return Value:

    HRESULT

--*/
{
    if (hAppIcon == NULL)
    {
        return E_POINTER;
    }
    m_hSnapinIcon = ::LoadIcon(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDI_INETMGR)
        );

    *hAppIcon = m_hSnapinIcon;

    ASSERT(*hAppIcon != NULL);

    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}



HRESULT
CInetMgrAbout::GetStaticFolderImage(
    HBITMAP *  phSmallImage,
    HBITMAP *  phSmallImageOpen,
    HBITMAP *  phLargeImage,
    COLORREF * prgbMask
    )
/*++

Routine Description:

    Get the static folder images.

Arguments:

    HBITMAP * phSmallImage      : Small folder
    HBITMAP * phSmallImageOpen  : Small open folder
    HBITMAP * phLargeImage      : Large image
    COLORREF * prgbMask         : Mask

Return Value:

    HRESULT

--*/
{
    if (!phSmallImage || !phSmallImageOpen || !phLargeImage || !prgbMask)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    m_hSmallImage = (HBITMAP)::LoadImage(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDB_SMALL_ROOT),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR
        );
    m_hLargeImage = (HBITMAP)::LoadImage(
        _Module.GetModuleInstance(),
        MAKEINTRESOURCE(IDB_LARGE_ROOT),
        IMAGE_BITMAP,
        0,
        0,
        LR_DEFAULTCOLOR
        );

    *phSmallImage = m_hSmallImage;
    *phSmallImageOpen = m_hSmallImage;
    *phLargeImage = m_hLargeImage;
    *prgbMask = RGB_BK_IMAGES;

    return *phSmallImage && *phLargeImage ? S_OK : E_FAIL;
}


CInetMgrAbout::~CInetMgrAbout()
{
    if (m_hSmallImage != NULL)
    {
        ::DeleteObject(m_hSmallImage);
    }
    if (m_hLargeImage != NULL)
    {
        ::DeleteObject(m_hLargeImage);
    }
    if (m_hSnapinIcon != NULL)
    {
        ::DestroyIcon(m_hSnapinIcon);
    }
}


#if 0
HRESULT
ExtractComputerNameExt(IDataObject * pDataObject, CString& strComputer)
{
	//
	// Find the computer name from the ComputerManagement snapin
	//
    CLIPFORMAT CCF_MyComputMachineName = (CLIPFORMAT)RegisterClipboardFormat(MYCOMPUT_MACHINE_NAME);
	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { 
        CCF_MyComputMachineName, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL
    };

    //
    // Allocate memory for the stream
    //
    int len = MAX_PATH;
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);
	if(stgmedium.hGlobal == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;

	HRESULT hr = pDataObject->GetDataHere(&formatetc, &stgmedium);
    ASSERT(SUCCEEDED(hr));
	//
	// Get the computer name
	//
    strComputer = (LPTSTR)stgmedium.hGlobal;

	GlobalFree(stgmedium.hGlobal);

    return hr;
}

HRESULT
CCompMgrExtData::Init(IDataObject * pDataObject)
{
    return ExtractComputerNameExt(pDataObject, m_ExtMachineName);
}

HRESULT 
STDMETHODCALLTYPE 
CCompMgrExtData::Notify(
		MMC_NOTIFY_TYPE event,
        LPARAM arg,
        LPARAM param,
		IComponentData* pComponentData,
		IComponent* pComponent,
		DATA_OBJECT_TYPES type)
{
	CError err;

    CComPtr<IConsole> pConsole;
    CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> pHeader;
    CComQIPtr<IResultData, &IID_IResultData> pResultData;

    if (pComponentData != NULL)
    {
        pConsole = ((CInetMgr *)pComponentData)->m_spConsole;
    }
    else
    {
        pConsole = ((CInetMgrComponent *)pComponent)->m_spConsole;
    }
    CComQIPtr<IConsoleNameSpace2, &IID_IConsoleNameSpace2> pScope = pConsole;
	switch (event)
	{
	case MMCN_EXPAND:
        err = EnumerateScopePane((HSCOPEITEM)param, pScope);
		break;
	default:
		err = CSnapInItemImpl<CCompMgrExtData, TRUE>::Notify(event, arg, param, pComponentData, pComponent, type);
		break;
	}
	return err;
}

HRESULT
CCompMgrExtData::EnumerateScopePane(HSCOPEITEM hParent, IConsoleNameSpace2 * pScope)
{
    CError err;
    ASSERT_PTR(pScope);

    DWORD dwMask = SDI_PARENT; 

    SCOPEDATAITEM  scopeDataItem;

    ::ZeroMemory(&scopeDataItem, sizeof(SCOPEDATAITEM));
    scopeDataItem.mask = 
		SDI_STR | SDI_IMAGE | SDI_CHILDREN | SDI_OPENIMAGE | SDI_PARAM | dwMask;
    scopeDataItem.displayname = MMC_CALLBACK;
    scopeDataItem.nImage = scopeDataItem.nOpenImage = MMC_IMAGECALLBACK;//QueryImage();
    scopeDataItem.lParam = (LPARAM)this;
    scopeDataItem.relativeID = hParent;
    scopeDataItem.cChildren = 1;

    err = pScope->InsertItem(&scopeDataItem);

    if (err.Succeeded())
    {
        //
        // Cache the scope item handle
        //
        ASSERT(m_hScopeItem == NULL);
        m_hScopeItem = scopeDataItem.ID;
		// MMC_IMAGECALLBACK doesn't work in InsertItem. Update it here.
		scopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
		err = pScope->SetItem(&scopeDataItem);
    }
    return err;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\inetprop.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        inetprop.h

   Abstract:

        Internet Properties base classes definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _INETPROP_H_
#define _INETPROP_H_

// Some useful macros to set edit control
// and buddy spin control
//
#define SETUP_SPIN(s,min,max,pos)\
   (s).SetRange32((min),(max));\
   (s).SetPos((pos));\
   (s).SetAccel(3, toAcc)

#define SETUP_EDIT_SPIN(f, e, s, min, max, pos)\
   (e).EnableWindow((f));\
   (s).EnableWindow((f));\
   SETUP_SPIN((s),(min),(max),(pos))

//
// InitializeAndFetch parameters
//
#define WITHOUT_INHERITANCE (FALSE)
#define WITH_INHERITANCE    (TRUE)

//
// SSL Port number to use if SSL is not enabled
//
#define SSL_NOT_ENABLED     (0)

//
// Bandwidth and compression definitions
//
#define BANDWIDTH_MIN           (1)
#define BANDWIDTH_MAX           (32767)
#define INFINITE_BANDWIDTH      (0xffffffff)
#define KILOBYTE                (1024L)
#define MEGABYTE                (1024L * KILOBYTE)
#define DEF_BANDWIDTH           (1 * MEGABYTE)
#define DEF_MAX_COMPDIR_SIZE    (1 * MEGABYTE)

//
// Private FILE_ATTRIBUTE used to designate a virtual directory
//
#define FILE_ATTRIBUTE_VIRTUAL_DIRECTORY    (0x10000000)


//
// Attribute crackers
//
#define IS_VROOT(dwAttributes) ((dwAttributes & FILE_ATTRIBUTE_VIRTUAL_DIRECTORY) != 0)
#define IS_DIR(dwAttributes) ((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
#define IS_FILE(dwAttributes) ((dwAttributes & (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_VIRTUAL_DIRECTORY)) == 0)

//
// Metabase constants
//

//
// TODO: From mdkeys?
//
extern const LPCTSTR g_cszTemplates;
extern const LPCTSTR g_cszCompression;
extern const LPCTSTR g_cszMachine;
extern const LPCTSTR g_cszMimeMap;
extern const LPCTSTR g_cszRoot;
extern const LPCTSTR g_cszSep;
extern const TCHAR g_chSep;

//
// Utility Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//
// Forward Definitions
//
class CIPAddress;

//
// Determine if the currently logged-in user us an administrator
// or operator in the virtual server provided
//
HRESULT
DetermineIfAdministrator(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR lpszMetabasePath,
    OUT BOOL * pfAdministrator
    );



//
// Utility classes
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CMaskedDWORD
/*++

Class Description:

    A masked DWORD class.  This class performs assignments and comparison 
    on a masked range of the DWORD value.  For example, if a mask of 
    0x000000FF is set, any comparisons or assignments will only involve 
    the least significant byte.  A comparison against another DWORD will
    only compare that least significant byte, and an assignment will only
    set the least significant byte, leaving the rest untouched.

Public Interface:

    CMaskedDWORD        : Constructor
    operator ==         : Comparison operator
    operator !=         : Comparison operator
    operator =          : Assignment operator
    operator DWORD      : Cast to the value
    void SetMask        : Set the mask

--*/
{
//
// Constructor/Destructor
//
public:
    CMaskedDWORD(
        IN DWORD dwValue = 0L,
        IN DWORD dwMask  = 0xFFFFFFFF
        )
        : m_dwValue(dwValue),
          m_dwMask(dwMask)
    {
    }

public:
    BOOL operator ==(DWORD dwValue) const;
    BOOL operator !=(DWORD dwValue) const { return !(operator ==(dwValue)); }

    CMaskedDWORD & operator =(DWORD dwValue);
    operator DWORD() const { return m_dwValue; }
    operator DWORD &() { return m_dwValue; }
    void SetMask(DWORD dwMask) { m_dwMask = dwMask; }

private:
    DWORD m_dwValue;
    DWORD m_dwMask;
};


//
// Forward Definitions
//
class CIPAddress;



template <class TYPE, class ARG_TYPE> 
class CMPProp
{
public:
    CMPProp(ARG_TYPE value);
    CMPProp();
    operator ARG_TYPE() const;
    CMPProp<TYPE, ARG_TYPE> & operator =(ARG_TYPE value);
    BOOL m_fDirty;
    TYPE m_value;
};

template <class TYPE, class ARG_TYPE> 
inline CMPProp<TYPE, ARG_TYPE>::CMPProp(ARG_TYPE value)
    : m_value(value),
      m_fDirty(FALSE)
{
}

template <class TYPE, class ARG_TYPE> 
inline CMPProp<TYPE, ARG_TYPE>::CMPProp()
    : m_value(),
      m_fDirty(FALSE)
{
}

template <class TYPE, class ARG_TYPE>
inline CMPProp<TYPE, ARG_TYPE>::operator ARG_TYPE() const
{
    return (ARG_TYPE)m_value;
}

template <class TYPE, class ARG_TYPE>
inline CMPProp<TYPE, ARG_TYPE> & CMPProp<TYPE, ARG_TYPE>::operator =(ARG_TYPE value)
{
    if (m_value != value)
    {
        m_value = value;
        m_fDirty = TRUE;
    }
    
    return *this;
}


//
// MP Access (use operators where possible!)
//
#define MP_V(x) (x.m_value)
#define MP_D(x) (x.m_fDirty)


//
// Common property types
//
typedef CMPProp<CBlob, CBlob&>                   MP_CBlob;
typedef CMPProp<CString, LPCTSTR>                MP_CString;
typedef CMPProp<CStringListEx, CStringListEx &>  MP_CStringListEx;
typedef CMPProp<CILong, LONG>                    MP_CILong;
typedef CMPProp<int, int>                        MP_int;
typedef CMPProp<DWORD, DWORD>                    MP_DWORD;
typedef CMPProp<BOOL, BOOL>                      MP_BOOL;
typedef CMPProp<CMaskedDWORD, DWORD>             MP_CMaskedDWORD;



//
// CODEWORK: Turns these into proper methods
//
#define BEGIN_META_WRITE()\
{                                               \
    HRESULT hr = S_OK;                          \
    do                                          \
    {                                           \
        m_dwaDirtyProps.RemoveAll();            \

#define META_WRITE(id, value)\
        if(MP_D(value))                         \
        {                                       \
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting();          \
                if (FAILED(hr)) break;          \
            }                                   \
            hr = SetValue(id, MP_V(value));     \
            if (FAILED(hr)) break;              \
            MP_D(value) = FALSE;                \
            m_dwaDirtyProps.AddTail(id);        \
        }                                       \

#define META_WRITE_INHERITANCE(id, value, foverride)\
        if(MP_D(value))                         \
        {                                       \
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting();          \
                if (FAILED(hr)) break;          \
            }                                   \
            hr = SetValue(id, MP_V(value), &foverride);\
            if (FAILED(hr)) break;              \
            MP_D(value) = FALSE;                \
            m_dwaDirtyProps.AddTail(id);        \
        }                                       \

#define META_DELETE(id)\
        FlagPropertyForDeletion(id);            \

#define END_META_WRITE(err)\
        POSITION pos;                           \
        pos = m_dwaDeletedProps.GetHeadPosition();\
        while(pos != NULL)                      \
        {                                       \
            DWORD dwID = m_dwaDeletedProps.GetNext(pos);\
            if (!IsOpen())                      \
            {                                   \
                hr = OpenForWriting(FALSE);     \
                if (SUCCEEDED(hr))              \
                {                               \
                    TRACEEOLID("Deleting #" << dwID);\
                    hr = DeleteValue(dwID);          \
                    m_dwaDirtyProps.AddTail(dwID);   \
                }                                    \
            }                                   \
        }                                       \
        m_dwaDeletedProps.RemoveAll();          \
        if (IsOpen()) Close();                  \
        pos = m_dwaDirtyProps.GetHeadPosition();\
        hr = S_OK;                              \
        while(pos != NULL)                      \
        {                                       \
            hr = CheckDescendants(m_dwaDirtyProps.GetNext(pos), &m_auth, m_strMetaRoot); \
            if (FAILED(hr)) break;              \
        }                                       \
    }                                           \
    while(FALSE);                               \
    err = hr;                                   \
}



/* ABSTRACT */ class CMetaProperties : public CMetaKey
/*++

Class Description:

    Abstract base class that reads all metadata at a specific
    metabase path.  

Public Interface:

    QueryResult             : Get result code from construction
    QueryMetaPath           : Get the metabase path

Virtual Interface:

    ParseFields             : Break up data into member variables    

--*/
{
//
// Constructor/Destructor
//
protected:
    //
    // Constructor which creates new interface
    //
    CMetaProperties(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

    //
    // Construct with existing interface
    //
    CMetaProperties(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath
        );

    //
    // Construct with open key
    //
    CMetaProperties(
        IN CMetaKey * pKey,
        IN LPCTSTR lpszMDPath
        );

    //
    // Destructor
    //
    ~CMetaProperties();

public:
    //
    // GetAllData()
    //
    virtual HRESULT LoadData();
    virtual HRESULT WriteDirtyProps();
    void FlagPropertyForDeletion(DWORD dwID);

    virtual HRESULT CMetaProperties::QueryResult() const;
    LPCTSTR QueryMetaRoot() const { return m_strMetaRoot; }

protected:
    virtual void ParseFields() = 0;
    void Cleanup();
    HRESULT OpenForWriting(BOOL fCreate = TRUE);

protected:
    BOOL     m_fInherit;
    HRESULT  m_hResult;
    CString  m_strMetaRoot;
    DWORD    m_dwMDUserType;
    DWORD    m_dwMDDataType;
    CList<DWORD, DWORD> m_dwaDirtyProps;
    CList<DWORD, DWORD> m_dwaDeletedProps;

    //
    // Read all values
    //
    DWORD    m_dwNumEntries;
    DWORD    m_dwMDDataLen;
    PBYTE    m_pbMDData;
};



//
// Machine Properties object
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


class CMachineProps : public CMetaProperties
/*++

Class Description:

    Global machine properties

Public Interface:

    CMachineProps       : Constructor

    WriteDirtyProps     : Write dirty properties

--*/
{
public:
    CMachineProps(CComAuthInfo * pAuthInfo);
    CMachineProps(CMetaInterface * pInterface);

public:
    HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

public:
    MP_BOOL m_fEnableMetabaseEdit;
};



//
// Compression Properties Object
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CIISCompressionProps : public CMetaProperties
/*++

Class Description:

    Compression settings

Public Interface:

    CIISCompressionProps : Constructor

    WriteIfDirty         : Write data if dirty

--*/
{
public:
    CIISCompressionProps(
        IN CComAuthInfo * pAuthInfo
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

    //
    // Load data
    //
    virtual HRESULT LoadData();

public:
    MP_BOOL    m_fEnableStaticCompression;
    MP_BOOL    m_fEnableDynamicCompression;
    MP_BOOL    m_fLimitDirectorySize;
    MP_DWORD   m_dwDirectorySize;
    MP_CString m_strDirectory;

protected:
    virtual void ParseFields();

private:
    BOOL m_fPathDoesNotExist;
};



class CMimeTypes : public CMetaProperties
/*++

Class Description:

    A list of mime types.

Public Interface:

    CMimeTypes          : Constructor

    WriteIfDirty        : Write properties if dirty

--*/
{
public:
    //
    // Constructor that creates new interface
    //
    CMimeTypes(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

    //
    // Constructor that uses an existing interface
    //
    CMimeTypes(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write the data;
    //
    virtual HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

public:
    MP_CStringListEx   m_strlMimeTypes;
};



class CServerCapabilities : public CMetaProperties
/*++

Class Description:

    Server capabilities object

Public Interface:

    CServerCapabilities     : Constructor

--*/
{
public:
    //
    // Constructor that creates a new interface
    //
    CServerCapabilities(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath                      // e.g. "lm/w3svc/info"
        );

    //
    // Constructor that uses an existing interface
    //
    CServerCapabilities(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath                      // e.g. "lm/w3svc/info"
        );

public:
    BOOL IsSSLSupported()       const { return (m_dwCapabilities & IIS_CAP1_SSL_SUPPORT) != 0L; }
    BOOL IsSSL128Supported()    const 
    { 
       if (m_dwVersionMajor >= 6)
       {
          // We have this feature ALWAYS enabled in iis6 and iis5.1
          return TRUE;
       }
       else if (m_dwVersionMajor == 5 && m_dwVersionMinor == 1)
       {
          return TRUE;
       }
       else
       {
          return (m_dwConfiguration & MD_SERVER_CONFIG_SSL_128) != 0L; 
       }
    }
    BOOL HasMultipleSites()     const { return (m_dwCapabilities & IIS_CAP1_MULTIPLE_INSTANCE) != 0L; }
    BOOL HasBwThrottling()      const { return (m_dwCapabilities & IIS_CAP1_BW_THROTTLING) != 0L; }
    BOOL Has10ConnectionLimit() const { return (m_dwCapabilities & IIS_CAP1_10_CONNECTION_LIMIT) != 0L; }
    BOOL HasIPAccessCheck()     const { return (m_dwCapabilities & IIS_CAP1_IP_ACCESS_CHECK) != 0L; }
    BOOL HasOperatorList()      const { return (m_dwCapabilities & IIS_CAP1_OPERATORS_LIST) != 0L; }
    BOOL HasFrontPage()         const { return (m_dwCapabilities & IIS_CAP1_FP_INSTALLED) != 0L; }
    BOOL HasCompression()       const { return (m_dwCapabilities & IIS_CAP1_SERVER_COMPRESSION) != 0L; }
    BOOL HasCPUThrottling()     const { return (m_dwCapabilities & IIS_CAP1_CPU_AUDITING) != 0L; }
    BOOL HasDAV()               const { return (m_dwCapabilities & IIS_CAP1_DAV) != 0L; }
    BOOL HasDigest()            const { return (m_dwCapabilities & IIS_CAP1_DIGEST_SUPPORT) != 0L; }
    BOOL HasNTCertMapper()      const { return (m_dwCapabilities & IIS_CAP1_NT_CERTMAP_SUPPORT) != 0L; }
    DWORD QueryMajorVersion()   const { return m_dwVersionMajor; }
    DWORD QueryMinorVersion()   const { return m_dwVersionMinor; }

protected:
    virtual void ParseFields();

private:
    //
    // Capabilities fields
    //
    MP_DWORD m_dwPlatform;
    MP_DWORD m_dwVersionMajor;
    MP_DWORD m_dwVersionMinor;
    MP_DWORD m_dwCapabilities;
    MP_DWORD m_dwConfiguration;
};



class CInstanceProps : public CMetaProperties
/*++

Class Description:

    Generic instance properties.  Construct with lightweight = TRUE
    to fetch enough information for enumeration only.

Public Interface:

    CInstanceProps:         : Constructor

    Add                     : static method to create new instance
    Remove                  : static method to remove instance
    ChangeState             : Change the state of a property
    QueryError              : Get the win32 error
    GetDisplayText          : Generate display name of instance

--*/
{
public:
    //
    // Public method to convert instance info to display text
    //
    static LPCTSTR GetDisplayText(
        OUT CString & strName,
        IN  LPCTSTR szComment,
        IN  LPCTSTR szHostHeaderName,
        //IN  LPCTSTR szServiceName,
        IN  CIPAddress & ia, 
        IN  UINT uPort,
        IN  DWORD dwID
        );

public:
    //
    // Constructor that creates an interface
    //
    CInstanceProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN UINT    nDefPort     = 0U
        );

    //
    // Constructor that reuses existing interface
    //
    CInstanceProps(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath,
        IN UINT    nDefPort     = 0U
        );

    //
    // Special constructor that uses an open parent key,
    // and uses a relative path off the open key.
    //
    CInstanceProps(
        IN CMetaKey * pKey, 
        IN LPCTSTR lpszMDPath,
        IN DWORD   dwInstance,
        IN UINT    nDefPort     = 0U
        );

public:
    //
    // Parse the binding string into component parts
    //
    static void CrackBinding(
        IN  CString lpszBinding,
        OUT CIPAddress & iaIpAddress, 
        OUT UINT & nTCPPort, 
        OUT CString & strDomainName
        );

    //
    // Parse the secure binding string into component parts
    //
    static void CrackSecureBinding(
        IN  CString lpszBinding,
        OUT CIPAddress & iaIpAddress, 
        OUT UINT & nSSLPort
        );

    //
    // Find the SSL port applicable to the given
    // IP Address.  Return the index where this SSL port
    // was found, or -1 if it was not found.
    //
    static int FindMatchingSecurePort(
        IN  CStringList & strlBindings, 
        IN  CIPAddress & iaIpAddress,
        OUT UINT & m_nSSLPort
        );

    //
    // Find ip address/port combo
    //
    static BOOL IsPortInUse(
        IN CStringList & strlBindings,
        IN CIPAddress & iaIPAddress,
        IN UINT nPort
        );

    //
    // Build binding string
    //
    static void BuildBinding(
        OUT CString & strBinding, 
        IN  CIPAddress & iaIpAddress, 
        IN  UINT & nTCPPort, 
        IN  CString & lpszDomainName
        );

    //
    // Build secure binding string
    //
    static void BuildSecureBinding(
        OUT CString & strBinding, 
        IN  CIPAddress & iaIpAddress, 
        IN  UINT & nSSLPort 
        );

    //
    // Create new instance
    //
    static HRESULT Add(
        IN  CMetaInterface * pInterface,
        IN  LPCTSTR lpszService,
        IN  LPCTSTR lpszHomePath,
        IN  LPCTSTR lpszUserName        = NULL,
        IN  LPCTSTR lpszPassword        = NULL,
        IN  LPCTSTR lpszDescription     = NULL,
        IN  LPCTSTR lpszBinding         = NULL,
        IN  LPCTSTR lpszSecureBinding   = NULL,
        IN  DWORD * pdwPermissions      = NULL,
        IN  DWORD * pdwDirBrowsing      = NULL,
        IN  DWORD * pwdAuthFlags        = NULL,
        OUT DWORD * pdwInstance         = NULL    
        );

    //
    // Remove existing instance
    //
    static HRESULT Delete(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance
        );

//
// Access
//
public:
    //
    // Change the running state of the instance
    //
    HRESULT ChangeState(
        IN DWORD dwCommand
        );

    //
    // Get the WIN32 error
    //
    DWORD QueryError() const { return m_dwWin32Error; }

    //
    // Get the instance number
    //
    DWORD QueryInstance() const { return m_dwInstance; }

    //
    // Check to see if this is a deletable instance
    //
    BOOL IsDeletable() const { return !m_fNotDeletable; }

    //
    // Check to see if this is a cluster enabled instance
    //
    BOOL IsClusterEnabled() const { return m_fCluster; }

    //
    // Get the friendly name for this instance
    //
    LPCTSTR GetDisplayText(
        OUT CString & strName
        //IN  LPCTSTR szServiceName
        );

    //
    // Get the complete metabase path to the home directory
    //
    LPCTSTR GetHomePath(OUT CString & str);

    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:
    virtual void ParseFields();

public:
    //
    // Meta values
    //
    MP_BOOL          m_fNotDeletable;
    MP_BOOL          m_fCluster;
    MP_CStringListEx m_strlBindings;
    MP_CString       m_strComment;
    MP_DWORD         m_dwState;
    MP_DWORD         m_dwWin32Error;

    //
    // Derived Values
    //
    UINT             m_nTCPPort;
    CIPAddress       m_iaIpAddress;
    CString          m_strDomainName;

private:
    DWORD            m_dwInstance;
};



class CChildNodeProps : public CMetaProperties
/*++

Class Description:

    Generic child node properties.  Could be a vdir, a dir
    or a file.

Public Interface:

    CChildNodeProps         : Constructor

    Add                     : Create new virtual directory
    Delete                  : Delete virtual directory
    Rename                  : Rename virtual directory

    QueryError              : Get the win32 error
    IsPathInherited         : Return TRUE if the path was inherited
    FillInstanceInfo        : Fill instance info structure
    FillChildInfo           : Fill child info structure

--*/
{
public:
    //
    // Constructors
    //
    CChildNodeProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

    CChildNodeProps(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszMDPath,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

    CChildNodeProps(
        IN CMetaKey * pKey,
        IN LPCTSTR lpszPath     = NULL,
        IN BOOL    fInherit     = WITHOUT_INHERITANCE,
        IN BOOL    fPathOnly    = FALSE
        );

public:
    //
    // Create new virtual directory
    //
    static HRESULT Add(
        IN CMetaInterface * pInterface,

        IN LPCTSTR lpszParentPath,
        /*
        IN  LPCTSTR lpszService,
        IN  DWORD   dwInstance,         
        IN  LPCTSTR lpszParentPath,     
        */
        IN  LPCTSTR lpszAlias,
        OUT CString & strAliasCreated,
        IN  DWORD * pdwPermissions      = NULL,
        IN  DWORD * pdwDirBrowsing      = NULL,
        IN  LPCTSTR lpszVrPath          = NULL,
        IN  LPCTSTR lpszUserName        = NULL,
        IN  LPCTSTR lpszPassword        = NULL,
        IN  BOOL    fExactName          = TRUE
        );

    //
    // Delete virtual directory
    //
    static HRESULT Delete(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszParentPath,      OPTIONAL
        IN LPCTSTR lpszNode
        );

    //
    // Rename virtual directory
    //
    static HRESULT Rename(
        IN CMetaInterface * pInterface,
        IN LPCTSTR lpszParentPath,      OPTIONAL
        IN LPCTSTR lpszOldName,
        IN LPCTSTR lpszNewName
        );

public:
    //
    // TRUE, if this is an enabled application
    //
    BOOL IsEnabledApplication() { return m_fIsAppRoot; }

    //
    // Get the alias name
    //
    LPCTSTR QueryAlias() const { return m_strAlias; }
    //CString & GetAlias() { return m_strAlias; }

    //
    // Get the error
    //
    DWORD QueryWin32Error() const { return m_dwWin32Error; }

    //
    // This is how to separate file/dir props from vdirs
    //
    BOOL IsPathInherited() const { return m_fPathInherited; }

    //
    // Empty the path if it was inherited
    //
    void RemovePathIfInherited();

    //
    // CODEWORK: Ugly solution.
    //
    // Call this method to override the inheritance status of the
    // http redirect path
    //
    void MarkRedirAsInherit(BOOL fInherit) { m_fInheritRedirect = fInherit; }

    //
    // Get the path
    //
    CString & GetPath() { return MP_V(m_strPath); }

    //
    // Get the redirected path
    //
    CString & GetRedirectedPath() { return m_strRedirectPath; }

    //
    // Get the access perms
    //
    DWORD QueryAccessPerms() const { return m_dwAccessPerms; }

    //
    // Get dir browsing bits
    //
    DWORD QueryDirBrowsing() const { return m_dwDirBrowsing; }

    //
    // True if the child is redirected
    //
    BOOL IsRedirected() const { return !m_strRedirectPath.IsEmpty(); }

    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

    //
    // Break down redirect statement into component paths
    //
    void ParseRedirectStatement();

    //
    // Reverse the above -- reassemble the redirect statement
    //
    void BuildRedirectStatement();

protected:
    //
    // Redirect tags
    //
    static const TCHAR   _chTagSep;
    static const LPCTSTR _cszExactDestination;
    static const LPCTSTR _cszChildOnly;
    static const LPCTSTR _cszPermanent;

public:
    BOOL            m_fIsAppRoot;
    BOOL            m_fPathInherited;
    BOOL            m_fInheritRedirect;
    BOOL            m_fExact;               // Redirect tag
    BOOL            m_fChild;               // Redirect tag
    BOOL            m_fPermanent;           // Redirect tag
    CString         m_strAlias;
    CString         m_strFullMetaPath;
    CString         m_strRedirectPath;      // Redirect _path_

public:
    MP_BOOL         m_fAppIsolated;
    MP_DWORD        m_dwWin32Error;
    MP_DWORD        m_dwDirBrowsing;
    MP_CString      m_strPath;
    MP_CString      m_strRedirectStatement; // Path + tags
    MP_CString      m_strAppRoot;
    MP_CMaskedDWORD m_dwAccessPerms;
};



inline CMetaKey * GetMetaKeyFromHandle(IN HANDLE hServer)
{
    ASSERT(hServer != NULL);
    return (CMetaKey *)hServer;
}

inline LPCTSTR GetServerNameFromHandle(IN HANDLE hServer)
{
    ASSERT(hServer != NULL);
    return ((CMetaKey *)hServer)->QueryServerName();
}


//
// Metabase Helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Get record data size
//
inline DWORD RecordDataSize(
    IN METADATA_GETALL_RECORD * pAllRecord, 
    IN int iIndex
    )
{
    return pAllRecord[iIndex].dwMDDataLen;
}

//
// Fetch data at index as DWORD
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT DWORD & dwValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    dwValue = *((UNALIGNED DWORD *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as UINT
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT UINT & uValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    uValue = (UINT)*((UNALIGNED DWORD *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as int
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT int & iValue
    )
{
    ASSERT(RecordDataSize(pAllRecord, iIndex) == sizeof(DWORD));
    iValue = (int)*((UNALIGNED DWORD *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as a CString
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CString & strValue
    )
{
    strValue = (LPTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset);
}

//
// Fetch data at index as a CStringList
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CStringList & strlValue
    )
{
    ConvertDoubleNullListToStringList(
        ((LPCTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset)),
        strlValue,
        (RecordDataSize(pAllRecord, iIndex)) / sizeof(TCHAR)
        );
}

//
// Fetch binary data as a blob
//
inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CBlob & blob
    )
{
    blob.SetValue(
        RecordDataSize(pAllRecord, iIndex), 
        ((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}    

inline void FetchMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CILong & ilValue
    )
{
    ilValue = (LONG)*((UNALIGNED DWORD *)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset));
}

//
// Fetch data at index as CString, and check inheritance status
//
inline void FetchInheritedMetaValue(
    IN  METADATA_GETALL_RECORD * pAllRecord, 
    IN  int iIndex,
    OUT CString & strValue,
    OUT BOOL & fIsInherited
    )
{
    strValue = (LPTSTR)((PBYTE)pAllRecord + pAllRecord[iIndex].dwMDDataOffset);
    fIsInherited = (pAllRecord[iIndex].dwMDAttributes & METADATA_ISINHERITED) != 0;
}

//
// Flag Operations
//
#define IS_FLAG_SET(dw, flag) ((((dw) & (flag)) != 0) ? TRUE : FALSE)
#define SET_FLAG(dw, flag)    dw |= (flag)
#define RESET_FLAG(dw, flag)  dw &= ~(flag)
#define SET_FLAG_IF(cond, dw, flag)\
    if (cond)                      \
    {                              \
        SET_FLAG(dw, flag);        \
    }                              \
    else                           \
    {                              \
        RESET_FLAG(dw, flag);      \
    }

//
// Meta record crackers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#define BEGIN_PARSE_META_RECORDS(dwNumEntries, pbMDData)\
{                                                       \
    METADATA_GETALL_RECORD * pAllRecords =              \
        (METADATA_GETALL_RECORD *)pbMDData;             \
    ASSERT(pAllRecords != NULL);                        \
                                                        \
    for (DWORD i = 0; i < dwNumEntries; ++i)            \
    {                                                   \
        METADATA_GETALL_RECORD * pRec = &pAllRecords[i];\
        switch(pRec->dwMDIdentifier)                    \
        {

#define HANDLE_META_RECORD(id, value)\
        case id:                                        \
            FetchMetaValue(pAllRecords, i, MP_V(value));\
            break;

#define HANDLE_INHERITED_META_RECORD(id, value, fIsInherited)\
        case id:                                                               \
            FetchInheritedMetaValue(pAllRecords, i, MP_V(value), fIsInherited);\
            break;


#define END_PARSE_META_RECORDS\
        }                                                \
    }                                                    \
}



//
// Sheet -> page crackers
//
#define BEGIN_META_INST_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryInstanceResult()))                       \
        {                                                                \
            break;                                                       \
        }

#define FETCH_INST_DATA_FROM_SHEET(value)\
    value = pSheet->GetInstanceProperties().value;                       \
    TRACEEOLID(value);

#define END_META_INST_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_DIR_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryDirectoryResult()))                      \
        {                                                                \
            break;                                                       \
        }

#define FETCH_DIR_DATA_FROM_SHEET(value)\
    value = pSheet->GetDirectoryProperties().value;                      \
    TRACEEOLID(value);

#define END_META_DIR_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}


#define BEGIN_META_INST_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_INST_DATA_ON_SHEET(value)\
        pSheet->GetInstanceProperties().value = value;

#define STORE_INST_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetInstanceProperties().value = value;    \
        dirty = MP_D(((sheet *)GetSheet())->GetInstanceProperties().value);

#define FLAG_INST_DATA_FOR_DELETION(id)\
        pSheet->GetInstanceProperties().FlagPropertyForDeletion(id);

#define END_META_INST_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetInstanceProperties().WriteDirtyProps();            \
}


#define BEGIN_META_DIR_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_DIR_DATA_ON_SHEET(value)\
        pSheet->GetDirectoryProperties().value = value;

#define STORE_DIR_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetDirectoryProperties().value = value;      \
        dirty = MP_D(pSheet->GetDirectoryProperties().value);

#define INIT_DIR_DATA_MASK(value, mask)\
        MP_V(pSheet->GetDirectoryProperties().value).SetMask(mask);

#define FLAG_DIR_DATA_FOR_DELETION(id)\
        pSheet->GetDirectoryProperties().FlagPropertyForDeletion(id);

#define END_META_DIR_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetDirectoryProperties().WriteDirtyProps();           \
}




//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CMaskedDWORD::operator ==(DWORD dwValue) const
{
    return (m_dwValue & m_dwMask) == (dwValue & m_dwMask); 
} 

inline CMaskedDWORD & CMaskedDWORD::operator =(DWORD dwValue) 
{ 
    m_dwValue = ((m_dwValue &= ~m_dwMask) |= (dwValue & m_dwMask));
    return *this;
}

inline /*virtual */ HRESULT CMetaProperties::WriteDirtyProps()
{
    ASSERT_MSG("Not implemented");
    return E_NOTIMPL;
}

inline void CMetaProperties::FlagPropertyForDeletion(DWORD dwID)
{
    m_dwaDeletedProps.AddTail(dwID);
}

inline LPCTSTR CInstanceProps::GetDisplayText(
    OUT CString & strName
    //IN  LPCTSTR szServiceName
    )
{
    return CInstanceProps::GetDisplayText(
        strName, 
        m_strComment, 
        m_strDomainName,
        //szServiceName,
        m_iaIpAddress,
        m_nTCPPort,
        QueryInstance()
        );
}

inline LPCTSTR CInstanceProps::GetHomePath(CString & str)
{
    str = m_strMetaRoot + SZ_MBN_SEP_STR + g_cszRoot;
    return str;
}


inline void CChildNodeProps::RemovePathIfInherited()
{
    if (IsPathInherited())
    {
        MP_V(m_strPath).Empty();
    }
}


/*
inline void CChildNodeProps::FillInstanceInfo(ISMINSTANCEINFO * pii)
{
    _tcsncpy(pii->szPath, GetPath(), STRSIZE(pii->szPath));
    _tcsncpy(pii->szRedirPath, GetRedirectedPath(), STRSIZE(pii->szRedirPath));
    pii->fChildOnlyRedir = m_fChild;
}

inline void CChildNodeProps::FillChildInfo(ISMCHILDINFO * pii)
{
    //
    // Set the output structure
    //
    pii->fInheritedPath = IsPathInherited();
    pii->fEnabledApplication = IsEnabledApplication();
    pii->dwError = QueryWin32Error();

    _tcsncpy(
        pii->szAlias, 
        GetAlias(), 
        STRSIZE(pii->szAlias)
        );

    _tcsncpy(
        pii->szPath, 
        GetPath(),
        STRSIZE(pii->szPath)
        );

    _tcsncpy(
        pii->szRedirPath, 
        IsRedirected() ? GetRedirectedPath() : _T(""),
        STRSIZE(pii->szRedirPath)
        );

    pii->fChildOnlyRedir = m_fChild;
}
*/


#endif // _INETPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\inetprop.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        inetprop.cpp

   Abstract:

        Internet Properties base classes

   Author:

        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "inetprop.h"

#include "mmc.h"

extern "C"
{
    #include <lm.h>
}

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define new DEBUG_NEW


//
// Period to sleep while waiting for service to attain desired state
//
#define SLEEP_INTERVAL (500L)

//
// Maximum time to wait for service to attain desired state
//
#define MAX_SLEEP        (180000)       // For a service
#define MAX_SLEEP_INST   ( 30000)       // For an instance

//
// Instance numbers
//
#define FIRST_INSTANCE      (1)
#define LAST_INSTANCE       (0xffffffff)
#define MAX_INSTANCE_LEN    (32)



//
// Calling instance
//
//HINSTANCE hDLLInstance;



//
// Utility Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


const LPCTSTR g_cszTemplates   = SZ_MBN_INFO SZ_MBN_SEP_STR SZ_MBN_TEMPLATES;
const LPCTSTR g_cszCompression = SZ_MBN_FILTERS SZ_MBN_SEP_STR SZ_MBN_COMPRESSION SZ_MBN_SEP_STR SZ_MBN_PARAMETERS;
const LPCTSTR g_cszMachine     = SZ_MBN_MACHINE;
const LPCTSTR g_cszMimeMap     = SZ_MBN_MIMEMAP;
const LPCTSTR g_cszRoot        = SZ_MBN_ROOT;
const LPCTSTR g_cszSep         = SZ_MBN_SEP_STR;
const LPCTSTR g_cszInfo        = SZ_MBN_INFO;
const TCHAR g_chSep            = SZ_MBN_SEP_CHAR;



/*

NET_API_STATUS
ChangeInetServiceState(
    IN  LPCTSTR lpszServer,
    IN  LPCTSTR lpszService,
    IN  int nNewState,
    OUT int * pnCurrentState
    )
/*++

Routine Description:

    Start/stop/pause or continue a _service_

Arguments:

    LPCTSTR lpszServer   : Server name
    LPCTSTR lpszService  : Service name
    int nNewState        : INetService* definition.
    int * pnCurrentState : Ptr to current state (will be changed)

Return Value:

    Error return code

--/
{
#ifdef NO_SERVICE_CONTROLLER

    *pnCurrentState = INetServiceUnknown;

    return ERROR_SERVICE_REQUEST_TIMEOUT;

#else

    SC_HANDLE hService = NULL;
    SC_HANDLE hScManager = NULL;
    NET_API_STATUS err = ERROR_SUCCESS;

    do
    {
        hScManager = ::OpenSCManager(lpszServer, NULL, SC_MANAGER_ALL_ACCESS);

        if (hScManager == NULL)
        {
            err = ::GetLastError();
            break;
        }

        hService = ::OpenService(hScManager, lpszService, SERVICE_ALL_ACCESS);

        if (hService == NULL)
        {
            err = ::GetLastError();
            break;
        }

        BOOL fSuccess = FALSE;
        DWORD dwTargetState;
        DWORD dwPendingState;
        SERVICE_STATUS ss;

        switch(nNewState)
        {
        case INetServiceStopped:
            dwTargetState = SERVICE_STOPPED;
            dwPendingState = SERVICE_STOP_PENDING;
            fSuccess = ::ControlService(hService, SERVICE_CONTROL_STOP, &ss);
            break;

        case INetServiceRunning:
            dwTargetState = SERVICE_RUNNING;
            if (*pnCurrentState == INetServicePaused)
            {
                dwPendingState = SERVICE_CONTINUE_PENDING;
                fSuccess = ::ControlService(hService,
                    SERVICE_CONTROL_CONTINUE, &ss);
            }
            else
            {
                dwPendingState = SERVICE_START_PENDING;
                fSuccess = ::StartService(hService, 0, NULL);
            }
            break;

        case INetServicePaused:
            dwTargetState = SERVICE_PAUSED;
            dwPendingState = SERVICE_PAUSE_PENDING;
            fSuccess = ::ControlService(hService, SERVICE_CONTROL_PAUSE, &ss);
            break;

        default:
            ASSERT_MSG("Invalid service state requested");
            err = ERROR_INVALID_PARAMETER;
        }

        if (!fSuccess && err == ERROR_SUCCESS)
        {
            err = ::GetLastError();
        }

        //
        // Wait for the service to attain desired state, timeout
        // after 3 minutes.
        //
        DWORD dwSleepTotal = 0L;

        while (dwSleepTotal < MAX_SLEEP)
        {
            if (!::QueryServiceStatus(hService, &ss))
            {
                err = ::GetLastError();
                break;
            }

            if (ss.dwCurrentState != dwPendingState)
            {
                //
                // Done one way or another
                //
                if (ss.dwCurrentState != dwTargetState)
                {
                    //
                    // Did not achieve desired result. Something went
                    // wrong.
                    //
                    if (ss.dwWin32ExitCode)
                    {
                        err = ss.dwWin32ExitCode;
                    }
                }

                break;
            }

            //
            // Still pending...
            //
            ::Sleep(SLEEP_INTERVAL);

            dwSleepTotal += SLEEP_INTERVAL;
        }

        if (dwSleepTotal >= MAX_SLEEP)
        {
            err = ERROR_SERVICE_REQUEST_TIMEOUT;
        }

        //
        // Update state information
        //
        switch(ss.dwCurrentState)
        {
        case SERVICE_STOPPED:
        case SERVICE_STOP_PENDING:
            *pnCurrentState = INetServiceStopped;
            break;

        case SERVICE_RUNNING:
        case SERVICE_START_PENDING:
        case SERVICE_CONTINUE_PENDING:
            *pnCurrentState = INetServiceRunning;
            break;

        case SERVICE_PAUSE_PENDING:
        case SERVICE_PAUSED:
            *pnCurrentState = INetServicePaused;
            break;

        default:
            *pnCurrentState = INetServiceUnknown;
        }
    }
    while(FALSE);

    if (hService)
    {
        ::CloseServiceHandle(hService);
    }

    if (hScManager)
    {
        ::CloseServiceHandle(hScManager);
    }

    return err;

#endif // NO_SERVICE_CONTROLLER
}

*/



BOOL
DoesServerExist(
    IN LPCTSTR lpszServer
    )
/*++

Routine Description:

    Check to make sure the machine exists

Arguments:

    LPCTSTR lpszServer      : machine name

Return Value:

    TRUE if the server exists, FALSE otherwise.

--*/
{
#ifdef NO_SERVICE_CONTROLLER

    //
    // Assume it exists
    //
    return TRUE;

#else

    //
    // CODEWORK: This is not the best way to do this, especially
    //           not across proxies and what not.
    //
    SC_HANDLE hScManager;
    NET_API_STATUS err = ERROR_SUCCESS;

    hScManager = ::OpenSCManager(lpszServer, NULL, SC_MANAGER_CONNECT);

    if (hScManager == NULL)
    {
        err = ::GetLastError();
    }

    ::CloseServiceHandle(hScManager);

    return err != RPC_S_SERVER_UNAVAILABLE;

#endif // NO_SERVICE_CONTROLLER

}



//
// CMetaProperties implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMetaProperties::CMetaProperties(
    IN CComAuthInfo * pAuthInfo      OPTIONAL,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor -- creates the interface

Arguments:

    CIISServer * pAuthInfo  : Auth info.  NULL indicates the local computer
    LPCTSTR lpszMDPath      : Metabase path

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_fInherit(TRUE),
      m_strMetaRoot(lpszMDPath),
      CMetaKey(pAuthInfo)
{
   CMetabasePath::CleanMetaPath(m_strMetaRoot);
}



CMetaProperties::CMetaProperties(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor -- attach to an existing interface.

Arguments:

    CMetaInterface * pInterface  : Existing interface
    LPCTSTR lpszMDPath           : Metabase path

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_fInherit(TRUE),
      m_strMetaRoot(lpszMDPath),
      CMetaKey(pInterface)
{
   CMetabasePath::CleanMetaPath(m_strMetaRoot);
}



CMetaProperties::CMetaProperties(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    CMetaKey * pKey     : Open key
    LPCTSTR lpszMDPath  : Path

Return Value:

    N/A

--*/
    : m_hResult(S_OK),
      m_dwNumEntries(0),
      m_dwMDUserType(ALL_METADATA),
      m_dwMDDataType(ALL_METADATA),
      m_dwMDDataLen(0),
      m_pbMDData(NULL),
      m_strMetaRoot(lpszMDPath),
      m_fInherit(TRUE),
      CMetaKey(FALSE, pKey)
{
   CMetabasePath::CleanMetaPath(m_strMetaRoot);
}



CMetaProperties::~CMetaProperties()
/*++

Routine Description:

    Destructor -- clean up

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    Cleanup();
}



/* virtual */
HRESULT 
CMetaProperties::LoadData()
/*++

Routine Description:

    Fetch all data with or without inheritance, and call the derived
    class to parse the data into fields.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Get all data off the master root
    //
    DWORD dwMDAttributes = METADATA_NO_ATTRIBUTES;

    if (m_fInherit)
    {
         dwMDAttributes = METADATA_INHERIT
            | METADATA_PARTIAL_PATH
            | METADATA_ISINHERITED;
    }

    m_hResult = GetAllData(
        dwMDAttributes,
        m_dwMDUserType,
        m_dwMDDataType,
        &m_dwNumEntries,
        &m_dwMDDataLen,
        &m_pbMDData,
        m_strMetaRoot
        );

    if (SUCCEEDED(m_hResult))
    {
        //
        // Call the derived class to break up data into fields
        //
        ParseFields();
    }

    Cleanup();

    return m_hResult;
}



void 
CMetaProperties::Cleanup()
/*++

Routine Description:

    Free data

Arguments:

    None

Return Value:

    None

--*/
{
    SAFE_FREEMEM(m_pbMDData);

    m_dwNumEntries = 0;
    m_dwMDDataLen = 0;
}



/* virtual */
HRESULT 
CMetaProperties::QueryResult() const
/*++

Routine Description:
    
    Determine the construction return code

Arguments:

    None

Return Value: 

    HRESULT

--*/
{   
    HRESULT hr = CMetaKey::QueryResult();

    return SUCCEEDED(hr) ? m_hResult : hr;
}



HRESULT 
CMetaProperties::OpenForWriting(
    IN BOOL fCreate     OPTIONAL
    )
/*++

Routine Description:

    Attempt to open the path for writing.  If fCreate is TRUE
    (default), then create the path if it doesn't yet exist

Arguments:

    BOOL fCreate        : If TRUE, create the path if it doesn't exist.

Return Value:

    HRESULT

Notes:

    If the key is already open, this will fire an ASSERT and close
    it.

--*/
{
    CError err;

    if (IsOpen())
    {
        ASSERT_MSG("Key already open -- closing");
        Close();
    }

    BOOL fNewPath;

    do
    {
        fNewPath = FALSE;

        err = Open(METADATA_PERMISSION_WRITE, m_strMetaRoot);

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND && fCreate)
        {
            TRACEEOLID("Metabase path doesn't exist -- creating it");

            err = CreatePathFromFailedOpen();
            fNewPath = err.Succeeded();
        }
    }
    while(fNewPath);

    return err;
}


//
// Machine properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMachineProps::CMachineProps(
    IN CComAuthInfo * pAuthInfo       OPTIONAL
    )
    : CMetaProperties(pAuthInfo, CMetabasePath()),
      m_fEnableMetabaseEdit(TRUE)
{
   // The only property we have here should actually be on metabase root
   m_strMetaRoot = SZ_MBN_SEP_CHAR;
   m_strMetaRoot += SZ_MBN_MACHINE;
}

CMachineProps::CMachineProps(
    IN CMetaInterface * pInterface
    )
    : CMetaProperties(pInterface, CMetabasePath()),
      m_fEnableMetabaseEdit(TRUE)
{
   // The only property we have here should actually be on metabase root
   m_strMetaRoot = SZ_MBN_SEP_CHAR;
   m_strMetaRoot += SZ_MBN_MACHINE;
}

/* virtual */
void 
CMachineProps::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

--*/
{
   BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_ROOT_ENABLE_EDIT_WHILE_RUNNING, m_fEnableMetabaseEdit)
   END_PARSE_META_RECORDS
}



HRESULT
CMachineProps::WriteDirtyProps()
{
   CError err;

   BEGIN_META_WRITE()
      META_WRITE(MD_ROOT_ENABLE_EDIT_WHILE_RUNNING, m_fEnableMetabaseEdit)
   END_META_WRITE(err);

   return err;
}



//
// Compression Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CIISCompressionProps::CIISCompressionProps(
    IN CComAuthInfo * pAuthInfo         OPTIONAL
    )
/*++

Routine Description:

    Constructor for compression properties object

Arguments:

    CComAuthInfo * pAuthInfo   : Auth info.  NULL indicates the local computer

Return Value:

    N/A

--*/
    : CMetaProperties(
        pAuthInfo, 
        CMetabasePath(SZ_MBN_WEB, MASTER_INSTANCE, g_cszCompression)
        ),
      //
      // Default properties
      //
      m_fEnableStaticCompression(FALSE),
      m_fEnableDynamicCompression(FALSE),
      m_fLimitDirectorySize(FALSE),
      m_fPathDoesNotExist(FALSE),
      m_dwDirectorySize(0xffffffff),
      m_strDirectory()
{
    //
    // Override base parameters
    //
    m_fInherit = FALSE;
}



/* virtual */ 
HRESULT 
CIISCompressionProps::LoadData()
/*++

Routine Description:

    Fetch all data with or without inheritance, and call the derived
    class to parse the data into fields.

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CMetaProperties::LoadData());
    m_fPathDoesNotExist = (err.Win32Error() == ERROR_PATH_NOT_FOUND);

    return err;
}



/* virtual */
void 
CIISCompressionProps::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,           m_pbMDData)
      HANDLE_META_RECORD(MD_HC_DO_STATIC_COMPRESSION,  m_fEnableStaticCompression)
      HANDLE_META_RECORD(MD_HC_DO_DYNAMIC_COMPRESSION, m_fEnableDynamicCompression)
      HANDLE_META_RECORD(MD_HC_DO_DISK_SPACE_LIMITING, m_fLimitDirectorySize)
      HANDLE_META_RECORD(MD_HC_MAX_DISK_SPACE_USAGE,   m_dwDirectorySize)
      HANDLE_META_RECORD(MD_HC_COMPRESSION_DIRECTORY,  m_strDirectory)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT 
CIISCompressionProps::WriteDirtyProps()
/*++

Routine Description:

    Write dirty properties

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_HC_DO_STATIC_COMPRESSION,  m_fEnableStaticCompression)
      META_WRITE(MD_HC_DO_DYNAMIC_COMPRESSION, m_fEnableDynamicCompression)
      META_WRITE(MD_HC_DO_DISK_SPACE_LIMITING, m_fLimitDirectorySize)
      META_WRITE(MD_HC_MAX_DISK_SPACE_USAGE,   m_dwDirectorySize)
      META_WRITE(MD_HC_COMPRESSION_DIRECTORY,  m_strDirectory)
    END_META_WRITE(err);

    return err;
}



//
// Mime Types Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMimeTypes::CMimeTypes(
    IN CComAuthInfo * pAuthInfo         OPTIONAL,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Mime types list constructor

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer
    LPCTSTR lpszMDPath       : Metabase path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pAuthInfo,
        lpszMDPath
        /*
        lpszService,
        dwInstance,
        lpszParent,
        dwInstance == MASTER_INSTANCE  && lpszService == NULL
            ? g_cszMimeMap 
            : lpszAlias
        */

        //
        // BUGBUG: dwInstance == MASTER_INSTANCE and g_cszMimeMap not used
        ),
      //
      // Default properties
      //
      m_strlMimeTypes()
{
}



CMimeTypes::CMimeTypes(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Mime types list constructor

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pInterface,
        lpszMDPath
        /*
        lpszService,
        dwInstance,
        lpszParent,
        dwInstance == MASTER_INSTANCE && lpszService == NULL
            ? g_cszMimeMap 
            : lpszAlias
        */
        //
        // BUGBUG: MASTER_INSTANCE, g_cszMimeMap not used
        //
        ),
      //
      // Default properties
      //
      m_strlMimeTypes()
{
}



void
CMimeTypes::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:


    None

Return Value:

    None

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_MIME_MAP, m_strlMimeTypes)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CMimeTypes::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_MIME_MAP, m_strlMimeTypes);
    END_META_WRITE(err);

    return err;
}




//
// Server Capabilities
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CServerCapabilities::CServerCapabilities(
    IN CComAuthInfo * pAuthInfo        OPTIONAL,
    IN LPCTSTR lpszMDPath              
    )
/*++

Routine Description:

    Constructor for server capabilities object

Arguments:

    CComAuthInfo * pAuthInfo  : Server name.  NULL indicates the local computer
    LPCTSTR lpszMDPath        : e.g. "lm/w3svc/info"

Return Value:

    N/A

--*/
    : CMetaProperties(pAuthInfo, lpszMDPath),
      //
      // Default properties 
      //
      m_dwPlatform(),
      m_dwVersionMajor(),
      m_dwVersionMinor(),
      m_dwCapabilities((DWORD)~IIS_CAP1_10_CONNECTION_LIMIT),
      m_dwConfiguration(0L)
{
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwMDDataType = DWORD_METADATA;
}



CServerCapabilities::CServerCapabilities(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor for server capabilities object that uses an existing interface.

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : e.g. "lm/w3svc/info"

Return Value:

    N/A

--*/
    : CMetaProperties(pInterface, lpszMDPath),
      //
      // Default properties 
      //
      m_dwPlatform(),
      m_dwVersionMajor(),
      m_dwVersionMinor(),
      m_dwCapabilities((DWORD)~IIS_CAP1_10_CONNECTION_LIMIT),
      m_dwConfiguration(0L)
{
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwMDDataType = DWORD_METADATA;
}



/* virtual */
void
CServerCapabilities::ParseFields()
/*++

Routine Description:

    Parse the fetched data into fields

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Only reading UT_SERVER, DWORD_METADATA.
    //
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,           m_pbMDData)
      HANDLE_META_RECORD(MD_SERVER_PLATFORM,           m_dwPlatform)
      HANDLE_META_RECORD(MD_SERVER_VERSION_MAJOR,      m_dwVersionMajor)
      HANDLE_META_RECORD(MD_SERVER_VERSION_MINOR,      m_dwVersionMinor)
      HANDLE_META_RECORD(MD_SERVER_CAPABILITIES,       m_dwCapabilities)
      HANDLE_META_RECORD(MD_SERVER_CONFIGURATION_INFO, m_dwConfiguration)
    END_PARSE_META_RECORDS
}




//
// Instance Properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* static */
LPCTSTR
CInstanceProps::GetDisplayText(
    OUT CString & strName,
    IN  LPCTSTR szComment,
    IN  LPCTSTR szHostHeaderName,
    IN  CIPAddress & ia,
    IN  UINT uPort,
    IN  DWORD dwID
    )
/*++

Routine Description:

    Build display text from instance information

Arguments:

    CString & strName
    LPCTSTR szComment
    LPCTSTR szHostHeaderName
    LPCTSTR szServiceName
    CIPAddress & ia
    UINT uPort
    DWORD dwID

Return Value:

    Pointer to the name buffer.

--*/
{
    //
    // Generate display name
    //
    // First use the comment,
    // if that's not available, use the host header name,
    // if that's not available, use the IP address:port.
    // If that's not available, use the instance number.
    // 
    //
    CComBSTR bstrFmt;

    if (szComment && *szComment)
    {
        strName = szComment;
    }
    else if (szHostHeaderName && *szHostHeaderName)
    {
        strName = szHostHeaderName;
    }
    else
    {
        if(!ia.IsZeroValue() && uPort != 0)
        {
            VERIFY(bstrFmt.LoadString(IDS_INSTANCE_PORT_FMT));
            strName.Format(bstrFmt,(LPCTSTR)ia, uPort);
        }
        else
        {
            VERIFY(bstrFmt.LoadString(IDS_INSTANCE_DEF_FMT));
            strName.Format(bstrFmt, dwID);
        }
    }

    return strName;
}



/* static */
void
CInstanceProps::CrackBinding(
    IN  CString strBinding,
    OUT CIPAddress & iaIpAddress,
    OUT UINT & nTCPPort,
    OUT CString & strDomainName
    )
/*++

Routine Description:

    Helper function to crack a binding string

Arguments:

    CString strBinding          : Binding string to be parsed
    CIPAddress & iaIpAddress    : IP Address output
    UINT & nTCPPort             : TCP Port
    CString & strDomainName     : Domain (host) header name

Return Value:

    None

--*/
{
    //
    // Zero initialize
    //
    iaIpAddress.SetZeroValue();
    nTCPPort = 0;
    strDomainName.Empty();

    int iColonPos = strBinding.Find(_TCHAR(':'));

    if(iColonPos != -1)
    {
        //
        // Get the IP address
        //
        iaIpAddress = strBinding.Left(iColonPos);

        //
        // Look for the second colon
        //
        strBinding = strBinding.Mid(iColonPos + 1);
        iColonPos  = strBinding.Find(_TCHAR(':'));
    }

    if(iColonPos != -1)
    {
        //
        // Get the port number
        //
        nTCPPort = ::_ttol(strBinding.Left(iColonPos));

        //
        // Look for the NULL termination
        //
        strBinding = strBinding.Mid(iColonPos + 1);
        iColonPos = strBinding.Find(_TCHAR('\0'));
    }

    if(iColonPos != -1)
    {
        strDomainName = strBinding.Left(iColonPos);
    }
}



/* static */
void
CInstanceProps::CrackSecureBinding(
    IN  CString strBinding,
    OUT CIPAddress & iaIpAddress,
    OUT UINT & nSSLPort
    )
/*++

Routine Description:

    Helper function to crack a secure binding string

Arguments:

    CString strBinding          : Binding string to be parsed
    CIPAddress & iaIpAddress    : IP Address output
    UINT & nSSLPort             : SSL Port

Return Value:

    None

--*/
{
    //
    // Same as regular binding without domain name
    //
    CString strDomainName;

    CrackBinding(strBinding, iaIpAddress, nSSLPort, strDomainName);

    ASSERT(strDomainName.IsEmpty());
}




/* static */
int
CInstanceProps::FindMatchingSecurePort(
    IN  CStringList & strlSecureBindings,
    IN  CIPAddress & iaIPAddress,
    OUT UINT & nSSLPort
    )
/*++

Routine Description:

    Find the SSL port applicable to the given IP Address.

Arguments:

    CStringList & strlSecureBindings : Input stringlist of secure bindings
    CIPAddress & iaIPAddress         : IP Address to target
    UINT & nSSLPort                  : Returns the SSL Port

Return Value:

    The index of the binding string, or -1 if not found.

Notes:

    The SSL port will be set to 0, if the IP address does not exist.

    A 0.0.0.0 ip address translates to "All Unassigned".

--*/
{
    nSSLPort = 0;

    int cItems = 0;
    POSITION pos = strlSecureBindings.GetHeadPosition();

    while(pos)
    {
        CString & strBinding = strlSecureBindings.GetNext(pos);

        CIPAddress ia;
        UINT nPort;
        CrackSecureBinding(strBinding, ia, nPort);

        if (ia == iaIPAddress)
        {
            //
            // Found it!
            //
            nSSLPort = nPort;
            return cItems;
        }

        ++cItems;
    }

    //
    // Not found
    //
    return -1;
}



/* static */
BOOL
CInstanceProps::IsPortInUse(
    IN CStringList & strlBindings,
    IN CIPAddress & iaIPAddress,
    IN UINT nPort
    )
/*++

Routine Description:

    Check to see if the give ip address/port combination is in use.

Arguments:

    CStringList & strlBindings    : Input stringlist of bindings
    CIPAddress & iaIpAddress      : IP Address target
    UINT nPort                    : Port

Return Value:

    TRUE if the given ip address/port combo is in use

Notes:

    Host header name is ignored


--*/
{
    POSITION pos = strlBindings.GetHeadPosition();

    while(pos)
    {
        CString & strBinding = strlBindings.GetNext(pos);

        CIPAddress ia;
        UINT n;
        CString str;
        CrackBinding(strBinding, ia, n, str);

        if (ia == iaIPAddress && n == nPort)
        {
            //
            // Found it!
            //
            return TRUE;
        }
    }

    //
    // Not found
    //
    return FALSE;

}



/* static */
void
CInstanceProps::BuildBinding(
    OUT CString & strBinding,
    IN  CIPAddress & iaIpAddress,
    IN  UINT & nTCPPort,
    IN  CString & strDomainName
    )
/*++

Routine Description:

    Build up a binding string from its component parts

Arguments:

    CString & strBinding        : Output binding string
    CIPAddress & iaIpAddress    : ip address (could be 0.0.0.0)
    UINT & nTCPPort             : TCP Port
    CString & strDomainName     : Domain name (host header)

Return Value:

    None.

--*/
{
    if (!iaIpAddress.IsZeroValue())
    {
        strBinding.Format(
            _T("%s:%d:%s"),
            (LPCTSTR)iaIpAddress,
            nTCPPort,
            (LPCTSTR)strDomainName
            );
    }
    else
    {
        //
        // Leave the ip address field blank
        //
        strBinding.Format(_T(":%d:%s"), nTCPPort, (LPCTSTR)strDomainName);
    }
}



/* static */
void
CInstanceProps::BuildSecureBinding(
    OUT CString & strBinding,
    IN  CIPAddress & iaIpAddress,
    IN  UINT & nSSLPort
    )
/*++

Routine Description:

    Build up a binding string from its component parts

Arguments:

    CString & strBinding        : Output binding string
    CIPAddress & iaIpAddress    : ip address (could be 0.0.0.0)
    UINT & nSSLPort             : SSL Port

Return Value:

    None.

--*/
{
    CString strDomainName;

    BuildBinding(strBinding, iaIpAddress, nSSLPort, strDomainName);
}



CInstanceProps::CInstanceProps(
    IN CComAuthInfo * pAuthInfo     OPTIONAL,
    IN LPCTSTR lpszMDPath,
    IN UINT    nDefPort             OPTIONAL
    )
/*++

Routine Description:

    Constructor for instance properties

Arguments:

    CComAuthInfo * pAuthInfo : Auth info.  NULL indicates the local computer
    LPCTSTR lpszMDPath       : Metabase path
    UINT    nDefPort         : Default port

Return Value:

    N/A

--*/
    : CMetaProperties(pAuthInfo, lpszMDPath),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fNotDeletable(FALSE),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress(NULL_IP_ADDRESS),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED)
{
    //
    // Fetch just enough info for the enumeration
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwInstance = CMetabasePath::GetInstanceNumber(lpszMDPath);
}



CInstanceProps::CInstanceProps(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,
    IN UINT    nDefPort                     OPTIONAL
    )
/*++

Routine Description:

    Constructor that uses an existing interface

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    UINT    nDefPort            : Default port

Return Value:

    N/A

--*/
    : CMetaProperties(pInterface, lpszMDPath),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fNotDeletable(FALSE),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress((LONG)0),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED)
{
    //
    // Fetch enough for enumeration only
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
    m_dwInstance = CMetabasePath::GetInstanceNumber(lpszMDPath);
}



CInstanceProps::CInstanceProps(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,      OPTIONAL
    IN DWORD   dwInstance,
    IN UINT    nDefPort         OPTIONAL
    )
/*++

Routine Description:

    Read instance properties off an open parent key

Arguments:

    CMetaKey * pKey      : Open key (parent node)
    LPCTSTR lpszMDPath   : Relative instance path off the open key
    DWORD   dwInstance   : Instance number (0 for master instance)
    UINT    nDefPort     : Default port number

Return Value:

    N/A

--*/
    : CMetaProperties(pKey, lpszMDPath),
      m_dwInstance(dwInstance),
      m_dwWin32Error(ERROR_SUCCESS),
      //
      // Default Instance Values
      //
      m_strlBindings(),
      m_strComment(),
      m_fNotDeletable(FALSE),
      m_fCluster(FALSE),
      m_nTCPPort(nDefPort),
      m_iaIpAddress((LONG)0),
      m_strDomainName(),
      m_dwState(MD_SERVER_STATE_STOPPED)
{
    //
    // Fetch enough for enumeration only
    //
    m_dwMDUserType = IIS_MD_UT_SERVER;
}



/* virtual */
void
CInstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_SERVER_BINDINGS, m_strlBindings)
      HANDLE_META_RECORD(MD_SERVER_COMMENT,  m_strComment)
      HANDLE_META_RECORD(MD_SERVER_STATE,    m_dwState)
      HANDLE_META_RECORD(MD_WIN32_ERROR,     m_dwWin32Error);
      HANDLE_META_RECORD(MD_NOT_DELETABLE,   m_fNotDeletable);
      HANDLE_META_RECORD(MD_CLUSTER_ENABLED, m_fCluster);
    END_PARSE_META_RECORDS

    //
    // Crack the primary binding
    //
    if (MP_V(m_strlBindings).GetCount() > 0)
    {
        CString & strBinding = MP_V(m_strlBindings).GetHead();
        CrackBinding(strBinding, m_iaIpAddress, m_nTCPPort, m_strDomainName);
    }
}



/* virtual */
HRESULT
CInstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
      META_WRITE(MD_SERVER_BINDINGS, m_strlBindings)
      META_WRITE(MD_SERVER_COMMENT,  m_strComment)
      META_WRITE(MD_SERVER_STATE,    m_dwState)
    END_META_WRITE(err);

    return err;
}



HRESULT
CInstanceProps::ChangeState(
    IN DWORD dwCommand
    )
/*++

Routine Description:

    Change the state of the instance

Arguments:

    DWORD dwCommand     : Command

Return Value:

    HRESULT

--*/
{
    DWORD  dwTargetState;
    DWORD  dwPendingState;
    CError err;

    switch(dwCommand)
    {
    case MD_SERVER_COMMAND_STOP:
        dwTargetState = MD_SERVER_STATE_STOPPED;
        dwPendingState = MD_SERVER_STATE_STOPPING;
        break;

    case MD_SERVER_COMMAND_START:
        dwTargetState = MD_SERVER_STATE_STARTED;

        dwPendingState = (m_dwState == MD_SERVER_STATE_PAUSED)
            ? MD_SERVER_STATE_CONTINUING
            : MD_SERVER_STATE_STARTING;
        break;

    case MD_SERVER_COMMAND_CONTINUE:
        dwTargetState = MD_SERVER_STATE_STARTED;
        dwPendingState = MD_SERVER_STATE_CONTINUING;
        break;

    case MD_SERVER_COMMAND_PAUSE:
        dwTargetState = MD_SERVER_STATE_PAUSED;
        dwPendingState = MD_SERVER_STATE_PAUSING;
        break;

    default:
        ASSERT_MSG("Invalid service state requested");
        err = ERROR_INVALID_PARAMETER;
    }

    err = OpenForWriting(FALSE);

    if (err.Succeeded())
    {
        err = SetValue(MD_SERVER_COMMAND, dwCommand);
        Close();
    }

    if (err.Succeeded())
    {
        //
        // Wait for the service to attain desired state, timeout
        // after specified interval
        //
        DWORD dwSleepTotal = 0L;
        DWORD dwOldState = m_dwState;

        if (dwOldState == dwTargetState)
        {
            //
            // Current state matches desired
            // state already.  ISM must be behind
            // the times.  
            //
            return err;
        }

        //
        // CODEWORK: Write a 0 win32error to the instance properties
        //           prior to attempting to start the instance.
        //
        m_dwWin32Error = 0;

        while (dwSleepTotal < MAX_SLEEP_INST)
        {
            err = LoadData();

            if (err.Failed())
            {
                break;
            }

            if ((m_dwState != dwPendingState && m_dwState != dwOldState) 
              || m_dwWin32Error != ERROR_SUCCESS
               )
            {
                //
                // Done one way or another
                //
                if (m_dwState != dwTargetState)
                {
                    //
                    // Did not achieve desired result. Something went
                    // wrong.
                    //
                    if (m_dwWin32Error)
                    {
                        err = m_dwWin32Error;
                    }
                }

                break;
            }

            //
            // Still pending...
            //
            ::Sleep(SLEEP_INTERVAL);

            dwSleepTotal += SLEEP_INTERVAL;
        }

        if (dwSleepTotal >= MAX_SLEEP_INST)
        {
            //
            // Timed out.  If there is a real error in the metabase
            // use it, otherwise use a generic timeout error
            //
            err = m_dwWin32Error;

            if (err.Succeeded())
            {
                err = ERROR_SERVICE_REQUEST_TIMEOUT;
            }
        }
    }

    return err;
}



/* static */
HRESULT
CInstanceProps::Add(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR lpszService,
    IN  LPCTSTR lpszHomePath,
    IN  LPCTSTR lpszUserName,       OPTIONAL
    IN  LPCTSTR lpszPassword,       OPTIONAL
    IN  LPCTSTR lpszDescription,    OPTIONAL
    IN  LPCTSTR lpszBinding,        OPTIONAL
    IN  LPCTSTR lpszSecureBinding,  OPTIONAL
    IN  DWORD * pdwPermissions,     OPTIONAL
    IN  DWORD * pdwDirBrowsing,     OPTIONAL
    IN  DWORD * pwdAuthFlags,       OPTIONAL
    OUT DWORD * pdwInstance         OPTIONAL
    )
/*++

Routine Description:

    Create a new instance.  Find a free instance number, and attempt
    to create it. Optionally return the new instance number.

Arguments:

    const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszService        : Service name
    LPCTSTR lpszHomePath       : physical path for the new home directory
    LPCTSTR lpszUserName       : User name
    LPCTSTR lpszPassword       : Password
    LPCTSTR lpszDescription    : Optional instance description.
    LPCTSTR lpszBinding        : Binding string
    LPCTSTR lpszSecureBinding  : Secure binding string
    DWORD * pdwPermission      : Permission bits
    DWORD * pdwDirBrowsing     : Directory browsing
    DWORD * pwdAuthFlags       : Authorization flags
    DWORD * pdwInstance        : Buffer to the new instance number

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface, 
        CMetabasePath(lpszService),
        METADATA_PERMISSION_WRITE
        );

    CError err(mk.QueryResult());

    if (err.Failed())
    {
        //
        // The service key MUST exist!
        //
        ASSERT(err.Win32Error() != ERROR_PATH_NOT_FOUND);

        return err;
    }

    //
    // Loop through until we find a free instance number.  This
    // is not ideal, but the only way to do this for now.
    //
    CString strPath;
    LPTSTR lp = strPath.GetBuffer(MAX_INSTANCE_LEN);

    for (DWORD dw = FIRST_INSTANCE; dw <= LAST_INSTANCE; ++dw)
    {
        ::_ultot(dw, lp, 10);
        err = mk.DoesPathExist(lp);

        if (err.Failed())
        {
            if (err.Win32Error() != ERROR_PATH_NOT_FOUND)
            {
                //
                // Unexpected error
                //
                return err;
            }

            //
            // Ok, now create it
            //
            strPath.ReleaseBuffer();
            err = mk.AddKey(strPath);

            if (err.Succeeded())
            {
                if (pdwInstance)
                {
                    //
                    // Store instance number
                    //
                    *pdwInstance = dw;
                }

                //
                // Write the key name
                //
                CString strKeyName;
                CString strKeyDirName;

                if (!::lstrcmpi(lpszService, SZ_MBN_WEB))
                {
                    strKeyName = IIS_CLASS_WEB_SERVER_W;
                    strKeyDirName = IIS_CLASS_WEB_VDIR_W;

                }
                else if (!::lstrcmpi(lpszService, SZ_MBN_FTP))
                {
                    strKeyName = IIS_CLASS_FTP_SERVER_W;
                    strKeyDirName = IIS_CLASS_FTP_VDIR_W;
                }
                else
                {
                    ASSERT_MSG("unrecognized service name");
                }

                err = mk.SetValue(
                    MD_KEY_TYPE, 
                    strKeyName,
                    NULL,
                    strPath
                    );

                //
                // Optionally write the description field
                //
                if (lpszDescription)
                {
                    CString strDescription(lpszDescription);
                    err = mk.SetValue(
                        MD_SERVER_COMMENT, 
                        strDescription,
                        NULL,
                        strPath
                        );
                }

                //
                // The service binding
                //
                if (lpszBinding)
                {
                    CString strBinding(lpszBinding);
                    CStringListEx strlBindings;
                    strlBindings.AddTail(strBinding);
                    err = mk.SetValue(
                        MD_SERVER_BINDINGS, 
                        strlBindings,
                        NULL,
                        strPath
                        );
                }

                //
                // The secure binding
                //
                if (lpszSecureBinding)
                {
                    CString strBinding(lpszSecureBinding);
                    CStringListEx strlBindings;
                    strlBindings.AddTail(strBinding);
                    err = mk.SetValue(
                        MD_SECURE_BINDINGS, 
                        strlBindings,
                        NULL,
                        strPath
                        );
                }

                strPath += g_cszSep;
                strPath += g_cszRoot;

                //
                // Now add the home directory for it
                //
                err = mk.AddKey(strPath);

                if (err.Succeeded())
                {
                    CString strHomePath(lpszHomePath);
                    err = mk.SetValue(MD_VR_PATH,  strHomePath, NULL, strPath);
                    err = mk.SetValue(MD_KEY_TYPE, strKeyDirName, NULL, strPath);

                    if (pwdAuthFlags)
                    {
                        err = mk.SetValue(
                            MD_AUTHORIZATION, 
                            *pwdAuthFlags,
                            NULL, 
                            strPath
                            );
                    }

                    if (lpszUserName != NULL)
                    {
                        ASSERT_PTR(lpszPassword);

                        CString strUserName(lpszUserName);
                        err = mk.SetValue(
                            MD_VR_USERNAME, 
                            strUserName,
                            NULL, 
                            strPath
                            );
                    }

                    if (lpszPassword != NULL)
                    {
                        ASSERT_PTR(lpszUserName);

                        CString strPassword(lpszPassword);
                        err = mk.SetValue(
                            MD_VR_PASSWORD, 
                            strPassword,
                            NULL, 
                            strPath
                            );
                    }

                    if (pdwPermissions != NULL)
                    {
                        err = mk.SetValue(
                            MD_ACCESS_PERM,  
                            *pdwPermissions,
                            NULL, 
                            strPath
                            );
                    }       

                    if (pdwDirBrowsing != NULL)
                    {
                        //
                        // WWW only
                        //
                        err = mk.SetValue(
                            MD_DIRECTORY_BROWSING,  
                            *pdwDirBrowsing,
                            NULL, 
                            strPath
                            );
                    }
                }
            }
  
            return err;
        }
    }

    //
    // 4 billion instances???!!!!! This error message
    // may not be ideal, but it will have to do for now.
    //
    return CError::HResult(ERROR_SHARING_BUFFER_EXCEEDED);
}



/* static */
HRESULT
CInstanceProps::Delete(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance
    )
/*++

Routine Description:

    Delete the given instance number

Arguments:

    LPCTSTR lpszServer     : Server name
    LPCTSTR lpszService    : Service name (e.g. W3SVC)
    DWORD   dwInstance     : Instance number to be deleted

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface, 
        CMetabasePath(lpszService), 
        NULL, 
        METADATA_PERMISSION_WRITE
        );

    CError err(mk.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    CString strPath;
    LPTSTR lp = strPath.GetBuffer(MAX_INSTANCE_LEN);
    ::_ltot(dwInstance, lp, 10);
    strPath.ReleaseBuffer();
    err = mk.DeleteKey(strPath);

    return err;
}



//
// Child node properties
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Redirect tags
//
const TCHAR   CChildNodeProps::_chTagSep            = _T(',');
const LPCTSTR CChildNodeProps::_cszExactDestination = _T("EXACT_DESTINATION");
const LPCTSTR CChildNodeProps::_cszChildOnly        = _T("CHILD_ONLY");
const LPCTSTR CChildNodeProps::_cszPermanent        = _T("PERMANENT");



CChildNodeProps::CChildNodeProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit,       OPTIONAL
    IN BOOL    fPathOnly       OPTIONAL
    )
/*++

Routine Description:

    Child node properties (Can be file, dir, or vdir)

Arguments:

    CComAuthInfo * pAuthInfo   : Authentication info
    LPCTSTR lpszMDPath         : Metabase path
    BOOL    fInherit           : TRUE to inherit values, FALSE otherwise
    BOOL    fPathOnly          : TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pAuthInfo,
        lpszMDPath
        ),
      m_strRedirectStatement(),
      m_strFullMetaPath(lpszMDPath),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        //
        // Fetch only the homeroot physical path
        //
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
    CMetabasePath::GetLastNodeName(lpszMDPath, m_strAlias);
}



CChildNodeProps::CChildNodeProps(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit,        OPTIONAL
    IN BOOL    fPathOnly        OPTIONAL
    )
/*++

Routine Description:

    Child node properties (Can be file, dir, or vdir)

Arguments:

    CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszMDPath          : Metabase path
    BOOL    fInherit            : TRUE to inherit values, FALSE otherwise
    BOOL    fPathOnly           : TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(
        pInterface,
        lpszMDPath
        ),
      m_strRedirectStatement(),
      m_strFullMetaPath(lpszMDPath),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        //
        // Fetch only the homeroot physical path
        //
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
    CMetabasePath::GetLastNodeName(lpszMDPath, m_strAlias);
}



CChildNodeProps::CChildNodeProps(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,        OPTIONAL
    IN BOOL    fInherit,        OPTIONAL 
    IN BOOL    fPathOnly        OPTIONAL   
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey    Open key
    LPCTSTR lpszMDPath       Path               
    BOOL    fInherit         TRUE to inherit properties
    BOOL    fPathOnly        TRUE to only fetch the path

Return Value:

    N/A

--*/
    : CMetaProperties(pKey, lpszMDPath),
      m_strRedirectStatement(),
      m_strFullMetaPath(),
      m_strRedirectPath(),
      m_fExact(FALSE),
      m_fChild(FALSE),
      m_fPermanent(FALSE),
      m_dwAccessPerms(0L),
      m_dwDirBrowsing(0L),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fIsAppRoot(FALSE),
      m_fAppIsolated(FALSE),
      //
      // Default properties
      //
      m_fPathInherited(FALSE),
      m_strPath()
{
    if (fPathOnly)
    {
        ASSERT(FALSE);
        m_dwMDUserType = IIS_MD_UT_FILE;
        m_dwMDDataType = STRING_METADATA;
    }
    else
    {
        //
        // Build full metabase path, because we need to compare it
        // against the app root path
        //
        CMetabasePath path(FALSE, pKey->QueryMetaPath(), lpszMDPath);
        m_strFullMetaPath = path.QueryMetaPath();
    }

    //
    // Override base parameters
    //
    m_fInherit = fInherit;
    CMetabasePath::GetLastNodeName(m_strFullMetaPath, m_strAlias);
}



void
CChildNodeProps::ParseRedirectStatement()
/*++

Routine Description:

    Break down the redirect statement into its component parts (path
    plus directives)

Arguments:

    None

Return Value:

    None

--*/
{
    m_fExact     = FALSE;
    m_fChild     = FALSE;
    m_fPermanent = FALSE;

    m_strRedirectPath = m_strRedirectStatement;

    int nComma = m_strRedirectPath.Find(_chTagSep);

    if (nComma >= 0)
    {
        //
        // Check past the separator for these tags
        //
        LPCTSTR lpstr = m_strRedirectPath;
        lpstr += (nComma + 1);

        m_fExact     = _tcsstr(lpstr, _cszExactDestination) != NULL;
        m_fChild     = _tcsstr(lpstr, _cszChildOnly) != NULL;
        m_fPermanent = _tcsstr(lpstr, _cszPermanent) != NULL;
        m_strRedirectPath.ReleaseBuffer(nComma);
    }
}



void
CChildNodeProps::BuildRedirectStatement()
/*++

Routine Description:

    Assemble the redirect statement from its component parts (path
    plus directives)

Arguments:

    None

Return Value:

    None

--*/
{
    CString strStatement = m_strRedirectPath;

    ASSERT(strStatement.Find(_chTagSep) < 0);

    if (m_fExact)
    {
        strStatement += _chTagSep;
        strStatement += _T(' ');
        strStatement += _cszExactDestination;
    }

    if (m_fChild)
    {
        strStatement += _chTagSep;
        strStatement += _T(' ');
        strStatement += _cszChildOnly;
    }

    if (m_fPermanent)
    {
        strStatement += _chTagSep;
        strStatement += _T(' ');
        strStatement += _cszPermanent;
    }

    m_strRedirectStatement = strStatement;
}



/* virtual */
void
CChildNodeProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_INHERITED_META_RECORD(MD_VR_PATH,  m_strPath, m_fPathInherited)
      HANDLE_META_RECORD(MD_HTTP_REDIRECT,      m_strRedirectStatement)
      HANDLE_META_RECORD(MD_WIN32_ERROR,        m_dwWin32Error)
      HANDLE_META_RECORD(MD_ACCESS_PERM,        m_dwAccessPerms)
      HANDLE_META_RECORD(MD_DIRECTORY_BROWSING, m_dwDirBrowsing)
      HANDLE_META_RECORD(MD_APP_ROOT,           m_strAppRoot)
      HANDLE_META_RECORD(MD_APP_ISOLATED,       m_fAppIsolated)
    END_PARSE_META_RECORDS

    //
    // Check to see if this is an application root
    //
    if (!MP_V(m_strAppRoot).IsEmpty())
    {
        TRACEEOLID("App root: " << m_strAppRoot);
        
        m_fIsAppRoot = m_strFullMetaPath.CompareNoCase(m_strAppRoot) == 0;
//        m_fIsAppRoot = m_strMetaRoot.CompareNoCase(m_strAppRoot) == 0;
    }

    //
    // Break down redirect statement into component parts
    //
    ParseRedirectStatement();
}



/* virtual */
HRESULT
CChildNodeProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_WRITE()
        META_WRITE(MD_VR_PATH,            m_strPath)
        META_WRITE(MD_ACCESS_PERM,        m_dwAccessPerms)
        META_WRITE(MD_DIRECTORY_BROWSING, m_dwDirBrowsing)
        if (IsRedirected())
        {
            //
            // (Re-)Assemble the redirect statement from its component parts
            //
            BuildRedirectStatement();
            META_WRITE_INHERITANCE(MD_HTTP_REDIRECT, m_strRedirectStatement, m_fInheritRedirect)
        }
        else
        {
            // If m_strRedirectPath is empty, but redir statement is not empty,
            // then redirection was just removed, we should delete it dirty or not
            if (!((CString)m_strRedirectStatement).IsEmpty())
            {
                META_DELETE(MD_HTTP_REDIRECT)
            }
        }
    END_META_WRITE(err);
        
    return err;
}



/* static */
HRESULT
CChildNodeProps::Add(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR   lpszParentPath,
    IN  LPCTSTR   lpszAlias,
    OUT CString & strAliasCreated,
    IN  DWORD *   pdwPermissions,      OPTIONAL
    IN  DWORD *   pdwDirBrowsing,      OPTIONAL
    IN  LPCTSTR   lpszVrPath,          OPTIONAL
    IN  LPCTSTR   lpszUserName,        OPTIONAL
    IN  LPCTSTR   lpszPassword,        OPTIONAL
    IN  BOOL      fExactName
    )
/*++

Routine Description:

    Create new child node.  Optionally, this will append a number
    to the alias name to ensure uniqueness

Arguments:

    const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszParentPath     : Parent path
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszVrPath         : VrPath property
    LPCTSTR lpszUserName       : User name
    LPCTSTR lpszPassword       : Password
    BOOL    fExactName         : If TRUE, do not change the name
                                 to enforce uniqueness.

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(pInterface);
    CError err(mk.QueryResult());

    if (err.Failed())
    {
        //
        // Hopeless...
        //
        return err;
    }

    BOOL fNewPath;

    do
    {
        fNewPath = FALSE;

        err = mk.Open(
            METADATA_PERMISSION_WRITE, 
            lpszParentPath
            /*
            lpszService,
            dwInstance,
            lpszParentPath
            */
            );

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // This could happen -- creating a virtual
            // server underneath a physical directory
            // which does not exist in the metabase.
            //
            CString strParent, strAlias;
            CMetabasePath::SplitMetaPathAtInstance(lpszParentPath, strParent, strAlias);
            err = mk.Open(
                METADATA_PERMISSION_WRITE,
                strParent
                //lpszParentPath
                //lpszService,
                //dwInstance
                );

            if (err.Failed())
            {
                //
                // This really should never fail, because we're opening
                // the path at the instance.
                //
                ASSERT_MSG("Instance path does not exist");
                break;
            }

            //err = mk.AddKey(lpszParentPath);
            err = mk.AddKey(strAlias);

            fNewPath = err.Succeeded();

            mk.Close();
        }
    }
    while(fNewPath);

    if (err.Failed())
    {
        return err;
    }

    strAliasCreated = lpszAlias;
    DWORD dw = 2;

    FOREVER
    {
        //
        // Append a number if the name is not unique.
        //
        err = mk.DoesPathExist(strAliasCreated);

        if (err.Failed())
        {
            if (err.Win32Error() != ERROR_PATH_NOT_FOUND)
            {
                //
                // Unexpected error
                //
                return err;
            }

            //
            // Ok, now create it
            //
            err = mk.AddKey(strAliasCreated);

            if (err.Succeeded())
            {
                CString strKeyName;
                CString buf, service;
                CMetabasePath::GetServicePath(lpszParentPath, buf);
                CMetabasePath::GetLastNodeName(buf, service);
                if (0 == service.CompareNoCase(SZ_MBN_WEB))
                {
                    strKeyName = IIS_CLASS_WEB_VDIR_W;
                }
                else if (0 == service.CompareNoCase(SZ_MBN_FTP))
                {
                    strKeyName = IIS_CLASS_FTP_VDIR_W;
                }
                else
                {
                    ASSERT_MSG("unrecognized service name");
                }

                err = mk.SetValue(
                    MD_KEY_TYPE, 
                    strKeyName,
                    NULL,
                    strAliasCreated
                    );

                if (lpszVrPath != NULL)
                {
                    CString strVrPath(lpszVrPath);
                    err = mk.SetValue(
                        MD_VR_PATH, 
                        strVrPath, 
                        NULL, 
                        strAliasCreated
                        );
                }

                if (lpszUserName != NULL)
                {
                    ASSERT_PTR(lpszPassword);

                    CString strUserName(lpszUserName);
                    err = mk.SetValue(
                        MD_VR_USERNAME, 
                        strUserName,
                        NULL,
                        strAliasCreated
                        );
                }

                if (lpszPassword != NULL)
                {
                    ASSERT_PTR(lpszUserName);

                    CString strPassword(lpszPassword);
                    err = mk.SetValue(
                        MD_VR_PASSWORD, 
                        strPassword,
                        NULL,
                        strAliasCreated
                        );
                }

                if (pdwPermissions != NULL)
                {
                    err = mk.SetValue(
                        MD_ACCESS_PERM, 
                        *pdwPermissions,
                        NULL,
                        strAliasCreated
                        );
                }

                if (pdwDirBrowsing != NULL)
                {
                    //
                    // WWW only
                    //
                    err = mk.SetValue(
                        MD_DIRECTORY_BROWSING,  
                        *pdwDirBrowsing,
                        NULL,
                        strAliasCreated
                        );
                }
            }

            return err;
        }

        //
        // Name is not unique, increase the number and try
        // again if permitted to so.  Otherwise return the
        // 'path exists' error.
        //
        if (fExactName)
        {
            err = ERROR_ALREADY_EXISTS;
            return err;
        }

        TCHAR szNumber[32];
        ::_ultot(dw++, szNumber, 10);
        strAliasCreated = lpszAlias;
        strAliasCreated += szNumber;

        //
        // Continue on...
        //
    }
}



/* static */
HRESULT
CChildNodeProps::Delete(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszParentPath,  OPTIONAL
    IN LPCTSTR lpszNode
    )
/*++

Routine Description:

    Delete child node off the given parent path

Arguments:

    const CMetaInterface * pInterface, Existing interface
    LPCTSTR lpszParentPath     : Parent path (could be NULL)
    LPCTSTR lpszNode           : Name of node to be deleted

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface, 
        lpszParentPath,
        METADATA_PERMISSION_WRITE
        );
    CError err(mk.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    err = mk.DeleteKey(lpszNode);

    return err;
}



/* static */
HRESULT
CChildNodeProps::Rename(
    IN CMetaInterface * pInterface,
    IN LPCTSTR lpszParentPath,      OPTIONAL
    IN LPCTSTR lpszOldName,
    IN LPCTSTR lpszNewName
    )
/*++

Routine Description:

    Rename a child node off the given path

Arguments:

    IN const CMetaInterface * pInterface : Existing interface
    LPCTSTR lpszParentPath     : Parent path (could be NULL)
    LPCTSTR lpszOldName        : Old node name
    LPCTSTR lpszNewName        : New node name

Return Value:

    HRESULT

--*/
{
    CMetaKey mk(
        pInterface, 
        lpszParentPath,
        METADATA_PERMISSION_WRITE
        );

    CError err(mk.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    err = mk.RenameKey(lpszOldName, lpszNewName);

    return err;
}


//
// ISM Helpers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
DetermineIfAdministrator(
    IN  CMetaInterface * pInterface,
    IN  LPCTSTR lpszMetabasePath,
    OUT BOOL * pfAdministrator
    )
/*++

Routine Description:

    Attempt to actually resolve whether or not the current user
    has administrator or merely "operator" access.  Until this method
    is called by the derived class, the user is assumed to have
    full administrator access, and may therefore get "access denied"
    errors in inconvenient places.

    The method to determine admin access is rather lame at the moment.
    There's a dummy metabase property that only allows admins to write
    to it, so we try to write to it to see if we're an admin.

Arguments:

    CMetaInterface * pInterface     : Metabase interface
    LPCTSTR lpszMetabasePath        : Metabase path
    BOOL * pfAdministrator          : Returns TRUE/FALSE for administrator
                                      status

Return Value:

    Error return code.  

Notes:

    This function used to be used on instance paths.  Now uses simple metabase
    paths.

--*/
{
    ASSERT_WRITE_PTR(pfAdministrator);
    ASSERT_PTR(pInterface);

    if (!pfAdministrator || !pInterface)
    {
        return E_POINTER;
    }

    *pfAdministrator = FALSE;

    //
    // Reuse existing interface we have lying around.
    //
    CMetaKey mk(pInterface);
    CError err(mk.QueryResult());

    if (err.Succeeded())
    {
       CString path(lpszMetabasePath);
       while (FAILED(mk.DoesPathExist(path)))
       {
          // Goto parent
          if (NULL == CMetabasePath::ConvertToParentPath(path))
		  {
			  break;
		  }
       }

       err = mk.Open(
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            path
            );

       if (err.Succeeded())
       {
            //
            // Write some nonsense
            //
            DWORD dwDummy = 0x1234;
            err = mk.SetValue(MD_ISM_ACCESS_CHECK, dwDummy);

            //
            // And delete it again
            //
            if (err.Succeeded())
            {
                mk.DeleteValue(MD_ISM_ACCESS_CHECK);
            }

            mk.Close();
        }
    }

    ASSERT(err.Succeeded() || err.Win32Error() == ERROR_ACCESS_DENIED);
    *pfAdministrator = (err.Succeeded());

#ifdef _DEBUG

    if (*pfAdministrator)
    {
        TRACEEOLID("You are a full admin.");
    }
    else
    {
        TRACEEOLID("You're just a lowly operator at best.  Error code is " << err);
    }

#endif // _DEBUG

    if (err.Win32Error() == ERROR_ACCESS_DENIED)
    {
        //
        // Expected result
        //
        err.Reset();
    }

    return err.Win32Error();
}



#if 0

//
// Dll Version Only
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



STDAPI
DllRegisterServer()
/*++

Routine Description:

    DllRegisterServer - Adds entries to the system registry

Arguments:

    None.

Return Value:

    HRESULT

Notes:

    This entry point doesn't do anything presently.  It's here to function as a 
    placeholder, and because we don't want to fail being called by regsvr32.
    
--*/
{
    return S_OK;
}



STDAPI
DllUnregisterServer()
/*++

Routine Description:

    DllUnregisterServer - Removes entries from the system registry

Arguments:

    None.

Return Value:

    HRESULT

Notes:

    See notes on DllRegisterServer above.

--*/
{
    return S_OK;
}



static AFX_EXTENSION_MODULE extensionDLL = {NULL, NULL};



extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpReserved
    )
/*++

Routine Description:

    DLL Main entry point

Arguments:

    HINSTANCE hInstance : Instance handle
    DWORD dwReason      : DLL_PROCESS_ATTACH, etc
    LPVOID lpReserved   : Reserved value

Return Value:

    1 for succesful initialisation, 0 for failed initialisation

--*/
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        ASSERT(hInstance != NULL);
//        hDLLInstance = hInstance;

        if (!::AfxInitExtensionModule(extensionDLL, hInstance)
         || !InitErrorFunctionality()
         || !InitIntlSettings()
           )
        {
            return 0;
        }

#if defined(_DEBUG) || DBG
        //
        // Force tracing on.
        //
        afxTraceEnabled = TRUE;
#endif // _DEBUG
        break;

    case DLL_PROCESS_DETACH:
        //
        // termination
        //
        TerminateIntlSettings();
        TerminateErrorFunctionality();
        ::AfxTermExtensionModule(extensionDLL);
        break;
    }

    //
    // Succes loading the DLL
    //
    return 1;
}

#endif // IISUI_EXPORTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\ipdomdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipdomdlg.h

   Abstract:

        IP and domain security restrictions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _IPDOMDLG_H_
#define _IPDOMDLG_H_

class CIPDomainDlg : public CEmphasizedDialog
/*++

Class Description:

    IP address and domain name restrictions dialog

Public Interface:

    CIPDomainDlg        : Constructor
    GetAccessList       : Get the list of granted/denied objects

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CIPDomainDlg(
        IN OUT BOOL & fIpDirty,
        IN OUT BOOL & fDefaultGranted,
        IN OUT BOOL & fOldDefaultGranted,
        IN CObListPlus & oblAccessList,
        IN CWnd * pParent = NULL
        );

//
// Access
//
public:
    CObListPlus & GetAccessList();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIPDomainDlg)
    enum { IDD = IDD_IP_SECURITY };
    int     m_nGrantedDenied;
    CStatic m_icon_Granted;
    CStatic m_icon_Denied;
    CButton m_radio_Granted;
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    CButton m_radio_Denied;
    CIPAccessDescriptorListBox m_list_IpAddresses;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIPDomainDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CIPDomainDlg)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListIpAddresses();
    afx_msg void OnErrspaceListIpAddresses();
    afx_msg void OnRadioGranted();
    afx_msg void OnRadioDenied();
    afx_msg void OnSelchangeListIpAddresses();
    afx_msg int  OnVKeyToItem(UINT nKey, CListBox * pListBox, UINT nIndex);
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    INT_PTR ShowPropertiesDialog(BOOL fAdd = FALSE);
    void    FillListBox(CIPAccessDescriptor * pSelection = NULL);
    BOOL    SetControlStates();
    DWORD   SortAccessList();

private:
    BOOL & m_fDefaultGranted;
    BOOL & m_fOldDefaultGranted;
    BOOL & m_fIpDirty;
    CObListPlus m_oblAccessListGranted, m_oblAccessListDenied;
	CObListPlus m_oblReturnList;
	CObListPlus * m_pCurrentList;
    CRMCListBoxResources m_ListBoxRes;
};

#endif // _IPDOMDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\logui.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "logui.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CLogUI

IMPLEMENT_DYNCREATE(CLogUI, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CLogUI properties

CString CLogUI::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CLogUI::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

COleFont CLogUI::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CLogUI::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

BOOL CLogUI::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CLogUI::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

short CLogUI::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CLogUI::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CLogUI operations

void CLogUI::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName, szMetaTarget);
}

void CLogUI::ApplyLogSelection()
{
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::SetComboBox(HWND hComboBox)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         hComboBox);
}

void CLogUI::Terminate()
{
    InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CLogUI::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\logui.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CLogUI wrapper class
#ifndef _LOGUI_H
#define _LOGUI_H

class CLogUI : public CWnd
{
protected:
    DECLARE_DYNCREATE(CLogUI)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xba634603, 0xb771, 0x11d0, { 0x92, 0x96, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    CString GetCaption();
    void SetCaption(LPCTSTR);
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    short GetBorderStyle();
    void SetBorderStyle(short);

// Operations
public:
    void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
    void ApplyLogSelection();
    void SetComboBox(HWND hComboBox);
    void Terminate();
    void DoClick();
};
#endif //_LOGUI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\ipdomdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ipdomdlg.cpp

   Abstract:

        IP and domain security restrictions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "supdlgs.h"
#include "ipdomdlg.h"


//
// Needed for granted/denied icons
//
//#include "..\comprop\resource.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define ILIST_DENY      0
#define ILIST_GRANT     1

#define ITYPE_DNS       0
#define ITYPE_IP        1



CIPDomainDlg::CIPDomainDlg(
    IN BOOL & fIpDirty,
    IN BOOL & fDefaultGranted,
    IN BOOL & fOldDefaultGranted,
    IN CObListPlus & oblAccessList,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    IP/Domain access restrictions dialog constructor

Argumentss:

    CWnd * pParent       : Parent window

Return Value:

    N/A

--*/
    : CEmphasizedDialog(CIPDomainDlg::IDD, pParent),
      m_ListBoxRes(
        IDB_ACCESS,
        m_list_IpAddresses.nBitmaps
        ),
      m_oblAccessListGranted(),
      m_oblAccessListDenied(),
	  m_oblReturnList(),
      m_list_IpAddresses(TRUE),
      m_fIpDirty(fIpDirty),
      m_fOldDefaultGranted(fOldDefaultGranted),
      m_fDefaultGranted(fDefaultGranted)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CIPDomainDlg)
    m_nGrantedDenied = 0;
    //}}AFX_DATA_INIT

#endif // 0

    //
    // Keep a temporary copy of these
    //
    m_oblAccessListGranted.SetOwnership(FALSE);
    m_oblAccessListDenied.SetOwnership(FALSE);
	m_oblReturnList.SetOwnership(FALSE);

    CObListIter obli(oblAccessList);
    const CIPAccessDescriptor * pAccess;
    while (NULL != (pAccess = (CIPAccessDescriptor *)obli.Next()))
    {
        if (pAccess->HasAccess())
        {
			m_oblAccessListGranted.AddTail((CObject *)pAccess);
		}
		else
		{
			m_oblAccessListDenied.AddTail((CObject *)pAccess);
		}
	}
    m_list_IpAddresses.AttachResources(&m_ListBoxRes);
    m_nGrantedDenied = m_fDefaultGranted ? DEFAULT_GRANTED : DEFAULT_DENIED;
	m_pCurrentList = m_fDefaultGranted ? &m_oblAccessListDenied : &m_oblAccessListGranted;
}



void 
CIPDomainDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CEmphasizedDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CIPDomainDlg)
    DDX_Control(pDX, IDC_RADIO_GRANTED, m_radio_Granted);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_ICON_GRANTED, m_icon_Granted);
    DDX_Control(pDX, IDC_ICON_DENIED, m_icon_Denied);
    DDX_Radio(pDX, IDC_RADIO_GRANTED, m_nGrantedDenied);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_RADIO_DENIED, m_radio_Denied);
    DDX_Control(pDX, IDC_LIST_IP_ADDRESSES, m_list_IpAddresses);
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CIPDomainDlg, CEmphasizedDialog)
    //{{AFX_MSG_MAP(CIPDomainDlg)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_LBN_DBLCLK(IDC_LIST_IP_ADDRESSES, OnDblclkListIpAddresses)
    ON_LBN_ERRSPACE(IDC_LIST_IP_ADDRESSES, OnErrspaceListIpAddresses)
    ON_BN_CLICKED(IDC_RADIO_GRANTED, OnRadioGranted)
    ON_BN_CLICKED(IDC_RADIO_DENIED, OnRadioDenied)
    ON_LBN_SELCHANGE(IDC_LIST_IP_ADDRESSES, OnSelchangeListIpAddresses)
    ON_WM_VKEYTOITEM()
    //}}AFX_MSG_MAP

END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CIPDomainDlg::OnButtonAdd() 
/*++

Routine Description:

    'Add' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(TRUE) == IDOK)
    {
        m_fIpDirty = TRUE;
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnButtonEdit() 
/*++

Routine Description:

    'Edit' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (ShowPropertiesDialog(FALSE) == IDOK)
    {
        m_fIpDirty = TRUE;
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnButtonRemove() 
/*++

Routine Description:

    'Remove' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = 0;
    int nCurSel = m_list_IpAddresses.GetCurSel();
    while (m_list_IpAddresses.GetNextSelectedItem(&nSel))
    {
		m_pCurrentList->RemoveIndex(nSel);
        m_list_IpAddresses.DeleteString(nSel);
    }

    m_fIpDirty = TRUE;

    if (nCurSel > 0)
    {
        --nCurSel;
    }

    m_list_IpAddresses.SetCurSel(nCurSel);

    if (!SetControlStates())
    {
        m_button_Add.SetFocus();
    }
}



BOOL
CIPDomainDlg::SetControlStates()
/*++

Routine Description:

    Set button states depending on content of the listbox and the controls
    
Arguments:

    None

Return Value:

    TRUE if at least one item is currently selected in the listbox.

--*/
{
    BOOL fSomeSelection = m_list_IpAddresses.GetSelCount() > 0;

    m_button_Edit.EnableWindow(m_list_IpAddresses.GetSelCount() == 1);
    m_button_Remove.EnableWindow(m_list_IpAddresses.GetSelCount() > 0);

    return fSomeSelection;
}



void
CIPDomainDlg::FillListBox(
    IN CIPAccessDescriptor * pSelection OPTIONAL
    )
/*++

Routine Description:

    Fill the ip address listbox from the oblist of access entries

Arguments:

    CIPAccessDescriptor * pSelection : Item to be selected or NULL.

Return Value:

    None

--*/
{
    CObListIter obli(*m_pCurrentList);
    const CIPAccessDescriptor * pAccess;

    m_list_IpAddresses.SetRedraw(FALSE);
    m_list_IpAddresses.ResetContent();

    int cItems = 0 ;
    int nSel = LB_ERR, nItem;
    for ( /**/; pAccess = (CIPAccessDescriptor *)obli.Next(); ++cItems)
    {
        //
        // We only list those not adhering to the default
        //
        if (pAccess->HasAccess() != m_fDefaultGranted)
        {
            nItem = m_list_IpAddresses.AddItem(pAccess);
            if (pAccess == pSelection)
            {
                //
                // Found item to be selected
                //
                nSel = nItem;
            }
        }
    }

    m_list_IpAddresses.SetCurSel(nSel);
    m_list_IpAddresses.SetRedraw(TRUE);
}



DWORD
CIPDomainDlg::SortAccessList()
/*++

Routine Description:

    Sorting the access list by grant denied and ip address
    FillListBox() should be called after this because
    the listbox will no longer reflect the true status
    of the list of directories.

Arguments:

    None

Return Value:

    Error Return code

--*/
{
    BeginWaitCursor();
    DWORD dw =  m_pCurrentList->Sort((CObjectPlus::PCOBJPLUS_ORDER_FUNC) 
        &CIPAccessDescriptor::OrderByAddress);
    EndWaitCursor();

    return dw;
}


INT_PTR
CIPDomainDlg::ShowPropertiesDialog(
    IN BOOL fAdd
    )
/*++

Routine Description:

    Bring up the dialog used for add or edit. Return the value returned 
    by the dialog

Arguments:

    BOOL fAdd : If TRUE, create new item.  Otherwise, edit existing item

Return Value:

    Dialog return code (IDOK/IDCANCEL)

--*/
{
    //
    // Bring up the dialog
    //
    CIPAccessDescriptor * pAccess = NULL;
    int nCurSel = LB_ERR;

    if (!fAdd)
    {
        //
        // Edit existing entry -- there better be only one...
        //
        pAccess = m_list_IpAddresses.GetSelectedItem();
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            //
            // Double click?
            //
            return IDCANCEL;
        }
    }

    CIPAccessDlg dlgAccess(
        m_fDefaultGranted, 
        pAccess, 
        m_pCurrentList, 
        this, 
        TRUE
        );

    INT_PTR nReturn = dlgAccess.DoModal();

    if (nReturn == IDOK)
    {
        CError err;
        ASSERT(pAccess != NULL);

        if (pAccess == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            try
            {
                if (fAdd)
                {
                    m_pCurrentList->AddTail(pAccess);
                }

                SortAccessList();
                FillListBox(pAccess);
            }
            catch(CMemoryException * e)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;    
                e->Delete();
            }
        }

        err.MessageBoxOnFailure();
    }

    return nReturn;
}



void
CIPDomainDlg::OnDblclkListIpAddresses()
/*++

Routine Description:

    Double click handler for IP listbox

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}



void
CIPDomainDlg::OnErrspaceListIpAddresses()
/*++

Routine Description:

    Error -- out of memory error for IP listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CIPDomainDlg::OnSelchangeListIpAddresses()
/*++

Routine Description:

    ip address 'selection change' notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



BOOL 
CIPDomainDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CEmphasizedDialog::OnInitDialog();

    m_icon_Granted.SetIcon(::AfxGetApp()->LoadIcon(IDI_GRANTED));
    m_icon_Denied.SetIcon(::AfxGetApp()->LoadIcon(IDI_DENIED));

    m_list_IpAddresses.Initialize();

    FillListBox();
    SetControlStates();
 
    return TRUE;  
}



void 
CIPDomainDlg::OnRadioGranted()
/*++

Routine Description:

    'Granted' radio button handler.

    Granted by default has been selected.  Refill the listbox with 
    items that have been explicitly denied.  Although we can
    only have a deny list or a grant list, we keep both of them 
    around until it comes time to saving the information.

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_fDefaultGranted)
    {
        m_fDefaultGranted = TRUE;
		m_pCurrentList = &m_oblAccessListDenied;
        FillListBox();
        SetControlStates();
    }
}



void 
CIPDomainDlg::OnRadioDenied()
/*++

Routine Description:

    'Denied' radio button handler.  Same as above, with reverse granted 
    and denied.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fDefaultGranted)
    {
        m_fDefaultGranted = FALSE;
		m_pCurrentList = &m_oblAccessListGranted;
        FillListBox();
        SetControlStates();
    }
}



int 
CIPDomainDlg::OnVKeyToItem(
    IN UINT nKey, 
    IN CListBox * pListBox, 
    IN UINT nIndex
    ) 
/*++

Routine Description:

    Map virtual keys to commands for ip listbox

Arguments:

    UINT nKey           Specifies the virtual-key code of the key 
                        that the user pressed.
    CListBox * pListBox Specifies a pointer to the list box. The 
                        pointer may be temporary and should not be stored for later use.

    UINT nIndex         Specifies the current caret position.

Return Value:

    -2  : No further action necessary
    -1  : Perform default action for the keystroke
    >=0 : Indicates the default action should be performed on the index
          specified.   

--*/
{
    switch(nKey)
    {
    case VK_DELETE:
        OnButtonRemove();
        break;

    case VK_INSERT:
        OnButtonAdd();
        break;

    default:
        //
        // Not completely handled by this function, let
        // windows handle the remaining default action.
        //
        return -1;
    }

    //
    // No further action is neccesary.
    //
    return -2;
}

CObListPlus&
CIPDomainDlg::GetAccessList()
{
	m_oblReturnList.RemoveAll();
	m_oblReturnList.AddTail(&m_oblAccessListGranted);
	m_oblReturnList.AddTail(&m_oblAccessListDenied);
	return m_oblReturnList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\machsht.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        machsht.cpp

   Abstract:
        IIS Machine Property sheet classes

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/


#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "machsht.h"
#include "mime.h"
#include <iisver.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define new DEBUG_NEW


//
// CIISMachineSheet class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CIISMachineSheet::CIISMachineSheet(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMetaPath,
    IN CWnd *  pParentWnd,
    IN LPARAM  lParam,
    IN LONG_PTR    handle,
    IN UINT    iSelectPage
    )
/*++

Routine Description:

    IIS Machine Property sheet constructor

Arguments:

    CComAuthInfo * pAuthInfo  : Authentication information
    LPCTSTR lpszMetPath       : Metabase path
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    LONG_PTR handle           : MMC Console handle
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CInetPropertySheet(
        pAuthInfo,
        lpszMetaPath,
        pParentWnd,
        lParam,
        handle,
        iSelectPage
        ),
      m_ppropMachine(NULL)
{
}

CIISMachineSheet::~CIISMachineSheet()
/*++

Routine Description:

    Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    FreeConfigurationParameters();
}



/* virtual */ 
HRESULT 
CIISMachineSheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Load base values
    //
    CError err(CInetPropertySheet::LoadConfigurationParameters());

    if (err.Failed())
    {
        return err;
    }

    ASSERT(m_ppropMachine == NULL);

    m_ppropMachine = new CMachineProps(QueryAuthInfo());
    if (!m_ppropMachine)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }

    err = m_ppropMachine->LoadData();

    return err;
}



/* virtual */ 
void 
CIISMachineSheet::FreeConfigurationParameters()
/*++

Routine Description:

    Clean up configuration data

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Free Base values
    //
    CInetPropertySheet::FreeConfigurationParameters();
    ASSERT_PTR(m_ppropMachine);
    SAFE_DELETE(m_ppropMachine);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISMachineSheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



IMPLEMENT_DYNCREATE(CIISMachinePage, CInetPropertyPage)

CIISMachinePage::CIISMachinePage(
    IN CIISMachineSheet * pSheet
    )
/*++

Routine Description:

    Constructor.

Arguments:

    CInetPropertySheet * pSheet : Associated property sheet

Return Value:

    N/A

--*/
    : CInetPropertyPage(CIISMachinePage::IDD, pSheet)
{
#if 0 // Keep classwizard happy

    //{{AFX_DATA_INIT(CIISMachinePage)
    //}}AFX_DATA_INIT

#endif // 0

}



CIISMachinePage::~CIISMachinePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}


void
CIISMachinePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIISMachinePage)
    DDX_Control(pDX, IDC_ENABLE_MB_EDIT, m_EnableMetabaseEdit);
    DDX_Check(pDX, IDC_ENABLE_MB_EDIT, m_fEnableMetabaseEdit);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISMachinePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CIISMachinePage)
    ON_BN_CLICKED(IDC_ENABLE_MB_EDIT, OnCheckEnableEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* virtual */
HRESULT
CIISMachinePage::FetchLoadedValues()
/*++

Routine Description:

    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
   CError err;

   BEGIN_META_MACHINE_READ(CIISMachineSheet)
      FETCH_MACHINE_DATA_FROM_SHEET(m_fEnableMetabaseEdit)
   END_META_MACHINE_READ(err);
   return err;
}



/* virtual */
HRESULT
CIISMachinePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page.

Arguments:

    None

Return Value:

    Error return code

--*/
{
   ASSERT(IsDirty());

   CError err;
   BeginWaitCursor();

   BEGIN_META_MACHINE_WRITE(CIISMachineSheet)
      STORE_MACHINE_DATA_ON_SHEET(m_fEnableMetabaseEdit)
   END_META_MACHINE_WRITE(err);

   EndWaitCursor();
   return S_OK;
}

BOOL
CIISMachinePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();
    if (  GetSheet()->QueryMajorVersion() < VER_IISMAJORVERSION
       || GetSheet()->QueryMinorVersion() < VER_IISMINORVERSION
       )
    {
       m_EnableMetabaseEdit.EnableWindow(FALSE);
    }
    return TRUE;
}

void
CIISMachinePage::OnCheckEnableEdit()
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\machsht.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        machsht.h

   Abstract:

        IIS Machine Property sheet definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/


#ifndef __MACHSHT_H__
#define __MACHSHT_H__


#include "shts.h"



#define BEGIN_META_MACHINE_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryMachineResult()))                        \
        {                                                                \
            break;                                                       \
        }

#define FETCH_MACHINE_DATA_FROM_SHEET(value)\
    value = pSheet->GetMachineProperties().value;                        \
    TRACEEOLID(value);

#define END_META_MACHINE_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_MACHINE_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_MACHINE_DATA_ON_SHEET(value)\
        pSheet->GetMachineProperties().value = value;

#define STORE_MACHINE_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetMachineProperties().value = value;                   \
        dirty = MP_D(pSheet->GetMachineProperties().value);

#define END_META_MACHINE_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetMachineProperties().WriteDirtyProps();             \
}



class CIISMachineSheet : public CInetPropertySheet
/*++

Class Description:

    IIS Machine Property sheet

Public Interface:

    CFtpSheet     : Constructor

    Initialize    : Initialize config data

--*/
{
public:
    //
    // Constructor
    //
    CIISMachineSheet(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath,
        IN CWnd *  pParentWnd  = NULL,
        IN LPARAM  lParam      = 0L,
        IN LONG_PTR    handle      = 0L,
        IN UINT    iSelectPage = 0
        );

    ~CIISMachineSheet();

public:
    HRESULT QueryMachineResult() const;
    CMachineProps & GetMachineProperties() { return *m_ppropMachine; }

    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();

    //{{AFX_MSG(CIISMachineSheet)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CMachineProps * m_ppropMachine;
};



class CIISMachinePage : public CInetPropertyPage
/*++

Class Description:

    Machine properties page

--*/
{
    DECLARE_DYNCREATE(CIISMachinePage)

//
// Construction
//
public:
    CIISMachinePage(CIISMachineSheet * pSheet = NULL);
    ~CIISMachinePage();


//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISMachinePage)
    enum { IDD = IDD_IIS_MACHINE };
    BOOL m_fEnableMetabaseEdit;
    CButton m_EnableMetabaseEdit;
    //}}AFX_DATA

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CIISMachinePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CIISMachinePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckEnableEdit();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

inline HRESULT CIISMachineSheet::QueryMachineResult() const
{
    return m_ppropMachine ? m_ppropMachine->QueryResult() : E_POINTER;
}

#endif // __MACHSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\mime.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        mime.cpp

   Abstract:

        Mime mapping dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "resource.h"
#include "mime.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CMimeEditDlg::CMimeEditDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor to create new mime mapping

Arguments:

    CWnd * pParent  : Optional parent window or NULL

Return Value:

    N/A

--*/
    : m_strExt(),
      m_strMime(),
      CDialog(CMimeEditDlg::IDD, pParent)
{
}



CMimeEditDlg::CMimeEditDlg(
    IN LPCTSTR lpstrExt,
    IN LPCTSTR lpstrMime,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor to edit existing mime mapping

Arguments:

    LPCTSTR lpstrExt  : Extension
    LPCTSTR lpstrMime : Mime mapping
    CWnd * pParent    : Optional parent window or NULL

Return Value:

    N/A

--*/
    : m_strExt(lpstrExt),
      m_strMime(lpstrMime),
      CDialog(CMimeEditDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CMimeEditDlg)
    //}}AFX_DATA_INIT
}



void 
CMimeEditDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CMimeEditDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_MIME, m_edit_Mime);
    DDX_Control(pDX, IDC_EDIT_EXTENT, m_edit_Extent);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CMimeEditDlg, CDialog)
    //{{AFX_MSG_MAP(CMimeEditDlg)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_MIME,  OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_EXTENT, OnItemChanged)

END_MESSAGE_MAP()



void 
CMimeEditDlg::SetControlStates()
/*++

Routine Description:

    Enable/disable controls depending on current dialog data

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Ok.EnableWindow(
        m_edit_Extent.GetWindowTextLength() > 0
     && m_edit_Mime.GetWindowTextLength() > 0
        );
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CMimeEditDlg::OnItemChanged()
/*++

Routine Description:

    Respond to changes

Arguments:

    None.

Return Value:

    None.

--*/
{
    SetControlStates();
}



BOOL 
CMimeEditDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    m_edit_Extent.SetWindowText(m_strExt);
    m_edit_Mime.SetWindowText(m_strMime);

    SetControlStates();
    
    return TRUE;
}



void 
CMimeEditDlg::OnOK()
/*++

Routine Description:

    'OK' button was pressed -- store data.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    m_edit_Extent.GetWindowText(m_strExt);
    m_edit_Mime.GetWindowText(m_strMime);

    CleanExtension(m_strExt);

    CDialog::OnOK();
}




CMimeDlg::CMimeDlg(
    IN CStringListEx & strlMimeTypes,
    IN CWnd * pParent               OPTIONAL
    )
/*++

Routine Description:

    Constructor for the MIME listing dialog

Arguments:

    CStringListEx & strlMimeTypes : Listing of mime types to edit
    CWnd * pParent                : Optional parent window or NULL

Return Value:

    N/A

--*/
    : m_fDirty(FALSE),
      m_strlMimeTypes(strlMimeTypes),
      CDialog(CMimeDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CMimeDlg)
    //}}AFX_DATA_INIT
}



void
CMimeDlg::DoDataExchange(
    IN OUT CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/

{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMimeDlg)
    DDX_Control(pDX, IDOK, m_button_Ok);
    DDX_Control(pDX, IDC_EDIT_EXTENSION, m_edit_Extention);
    DDX_Control(pDX, IDC_EDIT_CONTENT_TYPE, m_edit_ContentType);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_MIME, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT_MIME, m_button_Edit);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_MIME_TYPES, m_list_MimeTypes);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CMimeDlg, CDialog)
    //{{AFX_MSG_MAP(CMimeDlg)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_MIME, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_NEW_TYPE, OnButtonNewType)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_MIME, OnButtonRemove)
    ON_LBN_DBLCLK(IDC_LIST_MIME_TYPES, OnDblclkListMimeTypes)
    ON_LBN_SELCHANGE(IDC_LIST_MIME_TYPES, OnSelchangeListMimeTypes)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_CONTENT_TYPE, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_EXTENSION, OnItemChanged)

END_MESSAGE_MAP()



void 
CMimeDlg::SetControlStates()
/*++

Routine Description:

    Enable/disable controls depending on current dialog data

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Remove.EnableWindow(m_list_MimeTypes.GetSelCount() > 0);
    m_button_Edit.EnableWindow(m_list_MimeTypes.GetSelCount() == 1);
    m_button_Ok.EnableWindow(m_fDirty);
}



BOOL
CMimeDlg::BuildDisplayString(
    IN  CString & strIn,
    OUT CString & strOut
    )
/*++

Routine Description:

    Build a listbox-suitable display string for the mime type

Arguments:

    CString & strIn     : Input string in metabase format
    CString & strOut    : Output string in display format

Return Value:

    TRUE if successfull, FALSE otherwise

--*/
{
    BOOL fSuccess = FALSE;

    int nComma = strIn.Find(_T(','));
    if (nComma >= 0)
    {
        CString strExt = strIn.Left(nComma);
        CString strMime = strIn.Mid(nComma + 1);

        try
        {
            BuildDisplayString(strExt, strMime, strOut);
            ++fSuccess;
        }
        catch(CMemoryException * e)
        {
            TRACEEOLID("Mem exception in BuildDisplayString");
            e->ReportError();
            e->Delete();
        }
    }

    return fSuccess;
}



BOOL
CMimeDlg::CrackDisplayString(
    IN  CString & strIn,
    OUT CString & strExt,
    OUT CString & strMime
    )
/*++

Routine Description:

    Parse a display-formatted mime mapping string, and break into
    component parts

Arguments:

    CString & strIn     : Input string in display format
    CString & strExt    : Output extension string
    CString & strMime   : Output MIME string.


Return Value:

    TRUE if successfull, FALSE otherwise

--*/
{
    BOOL fSuccess = FALSE;

    try
    {
        int nTab = strIn.Find(_T('\t'));
        if (nTab >= 0)
        {
            strExt = strIn.Left(nTab);
            strMime = strIn.Mid(nTab + 1);

            ++fSuccess;
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Mem exception in CrackDisplayString");
        e->ReportError();
        e->Delete();
    }

    return fSuccess;
}



int
CMimeDlg::FindMimeType(
    IN const CString & strTargetExt
    )
/*++

Routine Description:

    Find a mime type by its extention.  The return value
    is the listbox index where the item may be found, or
    -1 if the item doesn't exist

Arguments:

    const CString & strTargetExt : Target extension we're searching for

Return Value:

    The index of the MIME mapping for this extension if found, or -1
    otherwise.

--*/
{
    CString str;
    CString strExt;
    CString strMime;

    //
    // CODEWORK: Change to binsearch 
    //
    for (int n = 0; n < m_list_MimeTypes.GetCount(); ++n)
    {
        m_list_MimeTypes.GetText(n, str);    
        if (CrackDisplayString(str, strExt, strMime))
        {
            if (!strExt.CompareNoCase(strTargetExt))
            {
                //
                // Found it.
                //
                return n;
            }
        }        
    }

    //
    // Not found
    //
    return -1;
}



void 
CMimeDlg::FillListBox()
/*++

Routine Description:

    Move the mime mappings from the string list to
    the listbox

Arguments:

    None.

Return Value:

    None.

--*/
{
    BeginWaitCursor();

    POSITION pos = m_strlMimeTypes.GetHeadPosition();

    while(pos)
    {
        CString & str = m_strlMimeTypes.GetNext(pos);
        CString strOut;

        if (BuildDisplayString(str, strOut))
        {
            m_list_MimeTypes.AddString(strOut);
        }
    }

    EndWaitCursor();
}



void 
CMimeDlg::FillFromListBox()
/*++

Routine Description:

    Reverse the above; Move the contents of the listbox
    back to the stringlist

Arguments:

    None.

Return Value:

    None.

--*/

{
    CString str;
    CString strExt;
    CString strMime;

    BeginWaitCursor();

    m_strlMimeTypes.RemoveAll();

    for (int n = 0; n < m_list_MimeTypes.GetCount(); ++n)
    {
        m_list_MimeTypes.GetText(n, str);    
        if (CrackDisplayString(str, strExt, strMime))
        {
            BuildMetaString(strExt, strMime, str);
            m_strlMimeTypes.AddTail(str);
        }
    }

    EndWaitCursor();
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CMimeDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    m_list_MimeTypes.Initialize();

    FillListBox();
    SetControlStates(); 
    
    return TRUE;
}



void 
CMimeDlg::OnButtonEdit()
/*++

Routine Description:

    'Edit' button has been pressed -- edit current selection

Arguments:

    None.

Return Value:

    None.

--*/
{
    int nCurSel = m_list_MimeTypes.GetCurSel();

    if (nCurSel >= 0)
    {
        CString str;
        CString strExt;
        CString strMime;

        m_list_MimeTypes.GetText(nCurSel, str);

        if (CrackDisplayString(str, strExt, strMime))
        {
            CMimeEditDlg dlg(strExt, strMime, this);

            if (dlg.DoModal() == IDOK)
            {
                strExt = dlg.m_strExt;
                strMime = dlg.m_strMime;

                BuildDisplayString(strExt, strMime, str);
                m_list_MimeTypes.DeleteString(nCurSel);
                nCurSel = m_list_MimeTypes.AddString(str);
                m_list_MimeTypes.SetCurSel(nCurSel);
                m_fDirty = TRUE;

                OnSelchangeListMimeTypes();        
            }
        }
    }
}



void 
CMimeDlg::OnButtonNewType() 
/*++

Routine Description:

    'New' button has been pressed.  Create new MIME mapping, and
    bring up configuration on it.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CMimeEditDlg dlg(this);

    if (dlg.DoModal() == IDOK)
    {
        CString str;
        CString strExt = dlg.m_strExt;
        CString strMime = dlg.m_strMime;

        //
        // Check to see if this extension already existed
        // in the list
        //
        int nOldSel = FindMimeType(strExt);
        if (nOldSel >= 0)
        {
            //
            // Yes, ask to have it replaced
            //
            if (::AfxMessageBox(
                IDS_REPLACE_MIME, 
                MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2
                ) == IDYES)
            {
                //
                // Kill the old one
                //
                m_list_MimeTypes.DeleteString(nOldSel);
            }
            else
            {
                //
                // Nope..
                //
                return;    
            }
        }

        BuildDisplayString(strExt, strMime, str);
        int nCurSel = m_list_MimeTypes.AddString(str);
        m_list_MimeTypes.SetCurSel(nCurSel);
        m_fDirty = TRUE;

        OnSelchangeListMimeTypes();
    }
}



void 
CMimeDlg::OnButtonRemove()
/*++

Routine Description:

    'Remove' button has been pressed.  Remove the current MIME mapping.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (::AfxMessageBox(
        IDS_REMOVE_MIME, 
        MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2
        ) != IDYES)
    {
        //
        // Changed his mind
        //
        return;
    }

    int nCurSel = m_list_MimeTypes.GetCurSel();

    int nSel = 0;
    while (nSel < m_list_MimeTypes.GetCount())
    {
        if (m_list_MimeTypes.GetSel(nSel))
        {
            m_list_MimeTypes.DeleteString(nSel);   
            m_fDirty = TRUE;
            continue;
        }

        ++nSel;
    }

    if (m_fDirty)
    {
        if (nCurSel > 0)
        {
            --nCurSel;
        }

        m_list_MimeTypes.SetCurSel(nCurSel);
        OnSelchangeListMimeTypes();
    }
}



void 
CMimeDlg::OnItemChanged()
/*++

Routine Description:

    Respond to changes

Arguments:

    None.

Return Value:

    None.

--*/
{
    SetControlStates();
}



void 
CMimeDlg::OnDblclkListMimeTypes()
/*++

Routine Description:

    Double clicking on an item is the same as pressing edit

Arguments:

    None.

Return Value:

    None.

--*/
{
    OnButtonEdit();
}



void
CMimeDlg::OnSelchangeListMimeTypes() 
/*++

Routine Description:

    Respond to change in selection in the listbox.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Update the text in the description box
    //
    int nCurSel = m_list_MimeTypes.GetCurSel();
    
    if (nCurSel >= 0)
    {
        CString str;
        CString strExt;
        CString strMime;

        m_list_MimeTypes.GetText(nCurSel, str);

        if (CrackDisplayString(str, strExt, strMime))
        {
            m_edit_Extention.SetWindowText(strExt);
            m_edit_ContentType.SetWindowText(strMime);
        }
    }
    else
    {
        m_edit_Extention.SetWindowText(_T(""));
        m_edit_ContentType.SetWindowText(_T(""));
    }

    SetControlStates();
}



void 
CMimeDlg::OnOK()
/*++

Routine Description:

    'OK' button was pressed -- store data.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    if (m_fDirty)
    {
        FillFromListBox();
    }

    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\metaback.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        metaback.cpp

   Abstract:
        Metabase backup and restore dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/


//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "mddefw.h"
#include "metaback.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



//
// CBackupsListBox : a listbox of CBackup objects
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Column width relative weights
//
#define WT_LOCATION      8
#define WT_VERSION       2
#define WT_DATE          6



//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("MetaBack");



IMPLEMENT_DYNAMIC(CBackupsListBox, CHeaderListBox);



const int CBackupsListBox::nBitmaps = 1;


#define HAS_BACKUP_PASSWORD(x) \
    ((x)->QueryMajorVersion() == 5 && (x)->QueryMinorVersion() == 1) || ((x)->QueryMajorVersion() >= 6)

CBackupsListBox::CBackupsListBox()
/*++

Routine Description:

    Backups listbox constructor

Arguments:

    None

Return Value:

    N/A

--*/
     : CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
}



void
CBackupsListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CBackupFile * p = (CBackupFile *)ds.m_ItemData;
    ASSERT_READ_PTR(p);

    DrawBitmap(ds, 0, 0);

    CString strVersion;
    strVersion.Format(_T("%ld"), p->QueryVersion());

#define MAXLEN (128)

    //
    // Convert date and time to local format
    //
    CTime tm;
    p->GetTime(tm);

    SYSTEMTIME stm =
    {
        (WORD)tm.GetYear(),
        (WORD)tm.GetMonth(),
        (WORD)tm.GetDayOfWeek(),
        (WORD)tm.GetDay(),
        (WORD)tm.GetHour(),
        (WORD)tm.GetMinute(),
        (WORD)tm.GetSecond(),
        0   // Milliseconds
    };

    CString strDate, strTime;
    LPTSTR lp = strDate.GetBuffer(MAXLEN);
    ::GetDateFormat(
        LOCALE_USER_DEFAULT,
        DATE_SHORTDATE,
        &stm,
        NULL,
        lp,
        MAXLEN
        );
    strDate.ReleaseBuffer();

    lp = strTime.GetBuffer(MAXLEN);
    GetTimeFormat(LOCALE_USER_DEFAULT, 0L, &stm, NULL, lp, MAXLEN);
    strTime.ReleaseBuffer();

    strDate += _T(" ");
    strDate += strTime;

    ColumnText(ds, 0, TRUE, (LPCTSTR)p->QueryLocation());
    ColumnText(ds, 1, FALSE, strVersion);
    ColumnText(ds, 2, FALSE, strDate);
}



/* virtual */
BOOL
CBackupsListBox::Initialize()
/*++

Routine Description:

    initialize the listbox.  Insert the columns
    as requested, and lay them out appropriately

Arguments:

    None

Return Value:

    TRUE if initialized successfully, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    HINSTANCE hInst = AfxGetResourceHandle();
    InsertColumn(0, WT_LOCATION, IDS_BACKUP_LOCATION, hInst);
    InsertColumn(1, WT_VERSION, IDS_BACKUP_VERSION, hInst);
    InsertColumn(2, WT_DATE, IDS_BACKUP_DATE, hInst);

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}



//
// Backup file object properties dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CBkupPropDlg::CBkupPropDlg(
    IN CIISMachine * pMachine,    
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISMachine * pMachine  : Machine object
    CWnd * pParent          : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CBkupPropDlg::IDD, pParent),
      m_pMachine(pMachine),
      m_strName(),
      m_strPassword()
{
    ASSERT_PTR(m_pMachine);
}



void 
CBkupPropDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CBkupPropDlg)
    DDX_Control(pDX, IDC_EDIT_BACKUP_NAME, m_edit_Name);
    DDX_Control(pDX, IDC_BACKUP_PASSWORD, m_edit_Password);
    DDX_Control(pDX, IDC_BACKUP_PASSWORD_CONFIRM, m_edit_PasswordConfirm);
    DDX_Control(pDX, IDC_USE_PASSWORD, m_button_Password);
    DDX_Control(pDX, IDOK, m_button_OK);
    DDX_Text(pDX, IDC_EDIT_BACKUP_NAME, m_strName);
    DDV_MaxChars(pDX, m_strName, MD_BACKUP_MAX_LEN - 1);
    //}}AFX_DATA_MAP
    if (m_button_Password.GetCheck())
    {
        DDX_Text(pDX, IDC_BACKUP_PASSWORD, m_strPassword);
        DDV_MinChars(pDX, m_strPassword, MIN_PASSWORD_LENGTH);
        DDX_Text(pDX, IDC_BACKUP_PASSWORD_CONFIRM, m_strPasswordConfirm);
        DDV_MinChars(pDX, m_strPasswordConfirm, MIN_PASSWORD_LENGTH);
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CBkupPropDlg, CDialog)
    //{{AFX_MSG_MAP(CBkupPropDlg)
    ON_EN_CHANGE(IDC_EDIT_BACKUP_NAME, OnChangeEditBackupName)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD, OnChangeEditPassword)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD_CONFIRM, OnChangeEditPassword)
    ON_BN_CLICKED(IDC_USE_PASSWORD, OnUsePassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CBkupPropDlg::OnChangeEditBackupName() 
/*++

Routine Description:

    Backup name edit change notification handler.

Arguments:

    None.

Return Value:

    None.

--*/
{
   BOOL bEnableOK = m_edit_Name.GetWindowTextLength() > 0;
   m_button_OK.EnableWindow(bEnableOK);
   if (bEnableOK && m_button_Password.GetCheck())
   {
      m_button_OK.EnableWindow(
         m_edit_Password.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
         && m_edit_PasswordConfirm.GetWindowTextLength() >= MIN_PASSWORD_LENGTH);
   }
}

BOOL 
CBkupPropDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();
    
    m_button_OK.EnableWindow(FALSE);
    m_button_Password.EnableWindow(HAS_BACKUP_PASSWORD(m_pMachine));
    m_button_Password.SetCheck(FALSE);
    m_edit_Password.EnableWindow(FALSE);
    m_edit_PasswordConfirm.EnableWindow(FALSE);
    
    return TRUE;  
}

void 
CBkupPropDlg::OnChangeEditPassword() 
{
    m_button_OK.EnableWindow(
       m_edit_Password.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
       && m_edit_PasswordConfirm.GetWindowTextLength() >= MIN_PASSWORD_LENGTH
       && m_edit_Name.GetWindowTextLength() > 0);
}

void
CBkupPropDlg::OnUsePassword()
{
   BOOL bUseIt = m_button_Password.GetCheck();
   m_edit_Password.EnableWindow(bUseIt);
   m_edit_PasswordConfirm.EnableWindow(bUseIt);
   if (bUseIt)
   {
       OnChangeEditPassword();
   }
   else
   {
      OnChangeEditBackupName();
   }
}

void
CBkupPropDlg::OnOK()
/*++

Routine Description:

    'OK' button handler -- create the backup.

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        if (m_button_Password.GetCheck() && m_strPassword.Compare(m_strPasswordConfirm) != 0)
        {
           AfxMessageBox(IDS_PASSWORDS_DOESNT_MATCH);
           return;
        }

        BeginWaitCursor();

        ASSERT_PTR(m_pMachine);

        //
        // CODEWORK: Verify impersonation settings
        //
        CMetaBack mb(m_pMachine->QueryAuthInfo());
        CError err(mb.QueryResult());

        if (err.Succeeded())
        {
            if (HAS_BACKUP_PASSWORD(m_pMachine))
            {
                if (m_button_Password.GetCheck())
                {
                    err = mb.BackupWithPassword(m_strName, m_strPassword);
                }
                else
                {
                    err = mb.BackupWithPassword(m_strName, _T(""));
                }
            }
            else
            {
                err = mb.Backup(m_strName);
            }
        }

        EndWaitCursor();

        if (err.Failed())
        {
            m_edit_Name.SetSel(0, -1);
            //
            // Special error message if IISADMIN just didn't
            // like the name.
            //
            if (err.Win32Error() == ERROR_INVALID_PARAMETER)
            {
                ::AfxMessageBox(IDS_BACKUP_BAD_NAME);
                ((CEdit *)GetDlgItem(IDC_EDIT_BACKUP_NAME))->SetSel(0, -1);
            }
            else
            {
                err.MessageBox();
            }
          
            //
            // Don't dismiss the dialog
            //
            return;
        }

        EndDialog(IDOK);
    }
}



//
// Metabase/Restore dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CBackupDlg::CBackupDlg(
    IN CIISMachine * pMachine,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISMachine * pMachine      : Machine object
    CWnd * pParent              : Optional parent window

Return Value:

    N/A

--*/
    : m_pMachine(pMachine),
      m_list_Backups(),
      m_ListBoxRes(IDB_BACKUPS, m_list_Backups.nBitmaps),
      m_oblBackups(),
      m_fChangedMetabase(FALSE),
      CDialog(CBackupDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CBackupDlg)
    //}}AFX_DATA_INIT

    ASSERT_PTR(m_pMachine);

    m_list_Backups.AttachResources(&m_ListBoxRes);
}



void 
CBackupDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CBackupDlg)
    DDX_Control(pDX, IDC_BUTTON_RESTORE, m_button_Restore);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_Delete);
    DDX_Control(pDX, IDOK, m_button_Close);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_BACKUPS, m_list_Backups);
}



void
CBackupDlg::SetControlStates()
/*++

Routine Description:

    Setting control states depending on the state of the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Restore.EnableWindow(m_list_Backups.GetSelCount() == 1);
    m_button_Delete.EnableWindow(m_list_Backups.GetSelCount() > 0);
}



HRESULT
CBackupDlg::EnumerateBackups(
    LPCTSTR lpszSelect  OPTIONAL
    )
/*++

Routine Description:

    Enumerate all existing backups, and add them to the listbox

Arguments:

    LPCTSTR lpszSelect      : Optional item to select

Return Value:

    HRESULT

Notes:

    The highest version number of the given name (if any) will
    be selected.

--*/
{
    CWaitCursor wait;

    m_list_Backups.SetRedraw(FALSE);
    m_list_Backups.ResetContent();
    m_oblBackups.RemoveAll();

    int nSel = LB_ERR;

    ASSERT_PTR(m_pMachine);

    //
    // CODEWORK: Verify impersonation settings
    //
    CMetaBack mb(m_pMachine->QueryAuthInfo());
    CError err(mb.QueryResult());

    if (err.Succeeded())
    {
        DWORD dwVersion;
        FILETIME ft;
        TCHAR szPath[MAX_PATH + 1] = _T("");

        int nItem = 0;

        FOREVER
        {
            *szPath = _T('\0');
            err = mb.Next(&dwVersion, szPath, &ft);

            if (err.Failed())
            {
                break;
            }

            TRACEEOLID(szPath << " v" << dwVersion);

            CBackupFile * pItem = new CBackupFile(szPath, dwVersion, &ft);
            if (!pItem)
            {
                TRACEEOLID("EnumerateBackups: OOM");
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            m_oblBackups.AddTail(pItem);
            VERIFY(LB_ERR != m_list_Backups.AddItem(pItem));

            if (lpszSelect != NULL && lstrcmpi(lpszSelect, szPath) == 0)
            {
                //
                // Remember selection for later
                //
                nSel = nItem;
            }

            ++nItem;
        }

        if (err.Win32Error() == ERROR_NO_MORE_ITEMS)
        {
            //
            // Finished enumeration successfully
            //
            err.Reset();
        }
    }

    //
    // Select item requested if any
    //
    m_list_Backups.SetCurSel(nSel);
    m_list_Backups.SetRedraw(TRUE);
    SetControlStates();

    return err;
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CBackupDlg, CDialog)
    //{{AFX_MSG_MAP(CBackupDlg)
    ON_BN_CLICKED(IDC_BUTTON_CREATE, OnButtonCreate)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_BUTTON_RESTORE, OnButtonRestore)
    ON_LBN_DBLCLK(IDC_LIST_BACKUPS, OnDblclkListBackups)
    ON_LBN_SELCHANGE(IDC_LIST_BACKUPS, OnSelchangeListBackups)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CBackupDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler

Arguments:

    None

Return Value:

    TRUE if successfully initialized, FALSE otherwise.

--*/
{
    CDialog::OnInitDialog();

    m_list_Backups.Initialize();

    CError err(EnumerateBackups());

    if (err.Failed())
    {
        err.AddOverride(REGDB_E_CLASSNOTREG, IDS_ERR_NO_BACKUP_RESTORE);
        m_pMachine->DisplayError(err);
        EndDialog(IDCANCEL);
    }

    return TRUE;
}



void
CBackupDlg::OnButtonCreate()
/*++

Routine Description:

    "Create" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CBkupPropDlg dlg(m_pMachine, this);

    if (dlg.DoModal() == IDOK)
    {
        //
        // We can only return OK if the creation worked
        // which is done in the properties dialog.
        //
        EnumerateBackups(dlg.QueryName());
    }
}



void
CBackupDlg::OnButtonDelete()
/*++

Routine Description:

    "Delete" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (!NoYesMessageBox(IDS_CONFIRM_DELETE_ITEMS))
    {
        //
        // Changed his mind
        //
        return;
    }

    m_list_Backups.SetRedraw(FALSE);
    CWaitCursor wait;

    ASSERT_PTR(m_pMachine);

    //
    // CODEWORK: Verify metabase settings
    //
    CMetaBack mb(m_pMachine->QueryAuthInfo());
    CError err(mb.QueryResult());

    if (err.Failed())
    {
        m_pMachine->DisplayError(err);
        return;
    }

    int nSel = 0;
    CBackupFile * pItem;

    while ((pItem = m_list_Backups.GetNextSelectedItem(&nSel)) != NULL)
    {
        TRACEEOLID("Deleting backup " 
            << pItem->QueryLocation() 
            << " v" 
            << pItem->QueryVersion()
            );

        err = mb.Delete(
            pItem->QueryLocation(),
            pItem->QueryVersion()
            );

        if (err.Failed())
        {
            m_pMachine->DisplayError(err);
            break;
        }

        m_list_Backups.DeleteString(nSel);

        //
        // Don't advance counter to account for shift
        //
    }

    m_list_Backups.SetRedraw(TRUE);
    SetControlStates();

    //
    // Ensure focus is not on a disabled button.
    //
    m_button_Close.SetFocus();
}



void 
CBackupDlg::OnButtonRestore() 
/*++

Routine Description:

    'Restore' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CBackupFile * pItem = GetSelectedListItem();
    ASSERT_READ_PTR(pItem);

    if (pItem != NULL)
    {
        if (NoYesMessageBox(IDS_RESTORE_CONFIRM))
        {
            ASSERT_PTR(m_pMachine);

            //
            // CODEWORK: Verify impersonation settings
            //
            CMetaBack mb(m_pMachine->QueryAuthInfo());
            CError err(mb.QueryResult());

            if (err.Succeeded())
            {
                //
                // the WAM stuff takes a while
                //
                CWaitCursor wait;

                //
                // Restore method will take care of WAM save/recover
                //
                if (HAS_BACKUP_PASSWORD(m_pMachine))
                {
                    err = mb.RestoreWithPassword(pItem->QueryLocation(), pItem->QueryVersion(), _T(""));
                }
                else
                {
                    err = mb.Restore(pItem->QueryLocation(), pItem->QueryVersion());
                }
            }

            if (err.Win32Error() == ERROR_WRONG_PASSWORD)
            {
                CBackupPassword dlg(this);
                if (dlg.DoModal() == IDOK)
                {
                   CWaitCursor wait;
                   err = mb.RestoreWithPassword(pItem->QueryLocation(), pItem->QueryVersion(), dlg.m_password);
                   if (err.Win32Error() == ERROR_WRONG_PASSWORD)
                   {
                      ::AfxMessageBox(
                          IDS_WRONG_PASSWORD, 
                          MB_OK | MB_ICONEXCLAMATION
                          );
                      return;
                   }
                   else if (err.Failed())
                   {
                      ::AfxMessageBox(
                          IDS_ERR_CANNOT_RESTORE, 
                          MB_OK | MB_ICONEXCLAMATION
                          );
                      return;
                   }
                   else
                   {
                      ::AfxMessageBox(IDS_SUCCESS, MB_OK | MB_ICONINFORMATION);
                      m_button_Close.SetFocus();
                      m_fChangedMetabase = TRUE;
                   }
                }
                else
                {
                   return;
                }
            }
            else if (err.Succeeded())
            {
                ::AfxMessageBox(IDS_SUCCESS, MB_OK | MB_ICONINFORMATION);
                m_button_Close.SetFocus();
                m_fChangedMetabase = TRUE;
            }
            else
            {
               err.MessageBox();
            }
        }
    }
}



void
CBackupDlg::OnDblclkListBackups()
/*++

Routine Description:

    Backup list "double click" notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Nothing presents itself as an obvious action here
    //
}



void
CBackupDlg::OnSelchangeListBackups()
/*++

Routine Description:

    Backup list "selection change" notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}


CBackupPassword::CBackupPassword(CWnd * pParent) :
   CDialog(CBackupPassword::IDD, pParent)
{
}


BEGIN_MESSAGE_MAP(CBackupPassword, CDialog)
    //{{AFX_MSG_MAP(CBackupPassword)
    ON_EN_CHANGE(IDC_BACKUP_PASSWORD, OnChangedPassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void 
CBackupPassword::DoDataExchange(
    IN CDataExchange * pDX
    )
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CBackupPassword)
    DDX_Control(pDX, IDC_BACKUP_PASSWORD, m_edit);
    DDX_Control(pDX, IDOK, m_button_OK);
    DDX_Text(pDX, IDC_BACKUP_PASSWORD, m_password);
    //}}AFX_DATA_MAP
}

BOOL 
CBackupPassword::OnInitDialog() 
{
    CDialog::OnInitDialog();
   
    m_button_OK.EnableWindow(FALSE);
//    ::SetFocus(GetDlgItem(IDC_BACKUP_PASSWORD)->m_hWnd);
    
    return FALSE;  
}

void 
CBackupPassword::OnChangedPassword() 
{
    m_button_OK.EnableWindow(
       m_edit.GetWindowTextLength() > 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\metaback.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        metaback.h

   Abstract:
        Metabase backup and restore dialog definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __METABACK_H__
#define __METABACK_H__



class CBackupFile : public CObjectPlus
/*++

Class Description:

    Backup location object

Public Interface:

    CBackupFile     : Constructor

    QueryVersion    : Get the version number
    QueryLocation   : Get the location name
    GetTime         : Get the time

--*/
{
//
// Constructor
//
public:
    CBackupFile(
        IN LPCTSTR lpszLocation,
        IN DWORD dwVersion,
        IN FILETIME * pft
        );

public:
    DWORD QueryVersion() const { return m_dwVersion; }
    LPCTSTR QueryLocation() const { return m_strLocation; }
    void GetTime(OUT CTime & tim);

private:
    DWORD m_dwVersion;
    CString m_strLocation;
    FILETIME m_ft;
};




class CBackupsListBox : public CHeaderListBox
/*++

Class Description:

    A listbox of CBackupFile objects

Public Interface:

    CBackupsListBox         : Constructor

    GetItem                 : Get backup object at index
    AddItem                 : Add item to listbox
    InsertItem              : Insert item into the listbox
    Initialize              : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CBackupsListBox);

public:
    static const nBitmaps;  // Number of bitmaps

public:
    CBackupsListBox();

public:
    CBackupFile * GetItem(UINT nIndex);
    CBackupFile * GetNextSelectedItem(int * pnStartingIndex);
    int AddItem(CBackupFile * pItem);
    int InsertItem(int nPos, CBackupFile * pItem);
    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);
};



class CBkupPropDlg : public CDialog
/*++

Class Description:

    Backup file properties dialog

Public Interface:

    CBkupPropDlg        : Constructor

    QueryName           : Return the name of the backup file

--*/
{
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CBkupPropDlg(
        IN CIISMachine * pMachine,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    LPCTSTR QueryName() const { return m_strName; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CBkupPropDlg)
    enum { IDD = IDD_BACKUP };
    CEdit   m_edit_Name;
    CButton m_button_OK;
    CString m_strPassword;
	CEdit   m_edit_Password;
	CString m_strPasswordConfirm;
	CEdit   m_edit_PasswordConfirm;
	CButton m_button_Password;
    CString m_strName;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CBkupPropDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CBkupPropDlg)
    afx_msg void OnChangeEditBackupName();
    afx_msg void OnChangeEditPassword();
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnUsePassword();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CIISMachine * m_pMachine;
};

#define MIN_PASSWORD_LENGTH	1

class CBackupPassword : public CDialog
{
public:
   CBackupPassword(CWnd * pParent);

    //{{AFX_DATA(CBackupPassword)
    enum { IDD = IDD_PASSWORD };
    CEdit m_edit;
    CButton m_button_OK;
    CString m_password;
    //}}AFX_DATA

    virtual void DoDataExchange(CDataExchange * pDX);

protected:
    //{{AFX_MSG(CBackupPassword)
    afx_msg void OnChangedPassword();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    CString m_confirm_password;
};

class CBackupDlg : public CDialog
/*++

Class Description:

    Metabase backup/restore dialog

Public Interface:

    CBackupDlg              : Constructor

    HasChangedMetabase      : TRUE if the metabase was changed

--*/
{
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CBackupDlg(
        IN CIISMachine * pMachine,
        IN CWnd * pParent = NULL
        );   

//
// Access
//
public:
    BOOL HasChangedMetabase() const { return m_fChangedMetabase; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CBackupDlg)
    enum { IDD = IDD_METABACKREST };
    CButton m_button_Restore;
    CButton m_button_Delete;
    CButton m_button_Close;
    //}}AFX_DATA

    CBackupsListBox m_list_Backups;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CBackupDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CBackupDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonCreate();
    afx_msg void OnButtonDelete();
    afx_msg void OnButtonRestore();
    afx_msg void OnDblclkListBackups();
    afx_msg void OnSelchangeListBackups();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    HRESULT EnumerateBackups(IN LPCTSTR lpszSelect = NULL);
    CBackupFile * GetSelectedListItem(OUT int * pnSel = NULL);

private:
    BOOL                 m_fChangedMetabase;
    CIISMachine *        m_pMachine;
    CObListPlus          m_oblBackups;
    CRMCListBoxResources m_ListBoxRes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CBackupFile::CBackupFile(
    IN LPCTSTR lpszLocation,
    IN DWORD dwVersion,
    IN FILETIME * pft
    )
    : m_dwVersion(dwVersion),
      m_strLocation(lpszLocation)
{
    CopyMemory(&m_ft, pft, sizeof(m_ft));
}

inline void CBackupFile::GetTime(CTime & tim)
{
    tim = m_ft;
}

inline CBackupFile * CBackupsListBox::GetItem(UINT nIndex)
{
    return (CBackupFile *)GetItemDataPtr(nIndex);
}

inline CBackupFile * CBackupsListBox::GetNextSelectedItem(int * pnStartingIndex)
{
    return (CBackupFile *)CHeaderListBox::GetNextSelectedItem(pnStartingIndex);
}

inline int CBackupsListBox::AddItem(CBackupFile * pItem)
{
    return AddString((LPCTSTR)pItem);
}

inline int CBackupsListBox::InsertItem(int nPos, CBackupFile * pItem)
{
    return InsertString(nPos, (LPCTSTR)pItem);
}

inline CBackupFile * CBackupDlg::GetSelectedListItem(int * pnSel)
{
    return (CBackupFile *)m_list_Backups.GetSelectedListItem(pnSel);
}



#endif // __METABACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\mime.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mime.h

   Abstract:

        Mime mapping dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef _MIME_H_
#define _MIME_H_



class CMimeEditDlg : public CDialog
/*++

Class Description:

    MIME editor dialog.

Public Interface:

    CMimeEditDlg  : MIME editor dialog constructor

--*/
{
//
// Construction
//
public:
    //
    // Create new  mime mapping constructor
    //
    CMimeEditDlg(
        IN CWnd * pParent = NULL
        );   

    //
    // Constructor to edit existing MIME mapping
    //
    CMimeEditDlg(
        IN LPCTSTR lpstrExt,
        IN LPCTSTR lpstrMime,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
public:
    //{{AFX_DATA(CMimeEditDlg)
    enum { IDD = IDD_MIME_PROPERTY };
    CButton m_button_Ok;
    CEdit   m_edit_Mime;
    CEdit   m_edit_Extent;
    //}}AFX_DATA

    CString m_strMime;
    CString m_strExt;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CMimeEditDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //
    // Enable/disable controls depending on window status
    //
    void SetControlStates();

    //
    // Extentions must start with a dot, add it if it isn't there
    //
    void CleanExtension(
        IN OUT CString & strExtension
        );

    //{{AFX_MSG(CMimeEditDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()
};



class CMimeDlg : public CDialog
/*++

Class Description:

    MIME listings dialog

Public Interface:

    CMimeDlg : Constructor for the dialog

--*/
{
//
// Construction
//
public:
    CMimeDlg(
        IN CStringListEx & strlMimeTypes,
        IN CWnd * pParent = NULL
        );  

//
// Dialog Data
//
protected:
    //
    // Build the MIME list from the listbox
    //
    void FillFromListBox();

    //
    // Fill the listbox from the list of MIME types
    //
    void FillListBox();

    //
    // Enable/disable control states depending on dialog data
    //
    void SetControlStates();

    //
    // Build a listbox-suitable display string for the mime type
    //
    void BuildDisplayString(
       IN  CString & strExt,
       IN  CString & strMime,
       OUT CString & strOut
       );

    //
    // As above, but use a metabase internal formatted string for input
    //
    BOOL BuildDisplayString(
        IN  CString & strIn,
        OUT CString & strOut
        );

    //
    // Build a string in the metabase internal format for this mime type
    //
    void BuildMetaString(
       IN  CString & strExt,
       IN  CString & strMime,
       OUT CString & strOut
       );

    //
    // Given the listbox suitable display string, break it in extension
    // and MIME type strings
    //
    BOOL CrackDisplayString(
        IN  CString & strIn,
        OUT CString & strExt,
        OUT CString & strMime
        );

    //
    // Find a MIME entry for the given extension, or return -1 if not found
    //
    int FindMimeType(
        IN const CString & strTargetExt
        );

    //{{AFX_DATA(CMimeDlg)
    enum { IDD = IDD_MIME_TYPES };
    CEdit    m_edit_Extention;
    CEdit    m_edit_ContentType;
    CButton  m_button_Remove;
    CButton  m_button_Edit;
    CButton  m_button_Ok;
    //}}AFX_DATA

    CStringListEx & m_strlMimeTypes;
    CRMCListBox   m_list_MimeTypes;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMimeDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMimeDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonNewType();
    afx_msg void OnButtonRemove();
    afx_msg void OnDblclkListMimeTypes();
    afx_msg void OnSelchangeListMimeTypes();
    virtual void OnOK();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()


private:
    BOOL m_fDirty;
};


//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CMimeEditDlg::CleanExtension(
    IN OUT CString & strExtension
    )
{
    if (strExtension[0] != _T('.'))
    {
        strExtension = _T('.') + strExtension;
    }
}

inline void CMimeDlg::BuildDisplayString(
   IN  CString & strExt,
   IN  CString & strMime,
   OUT CString & strOut
   )
{
    strOut.Format(_T("%s\t%s"), (LPCTSTR)strExt, (LPCTSTR)strMime);
}

inline void CMimeDlg::BuildMetaString(
   IN  CString & strExt,
   IN  CString & strMime,
   OUT CString & strOut
   )
{
    strOut.Format(_T("%s,%s"), (LPCTSTR)strExt, (LPCTSTR)strMime);
}


#endif // _MIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\mmmdlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mmmdlg.h

   Abstract:

        Multi-multi-multi dialog editor definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __MMMDLG_H__
#define __MMMDLG_H__


//
// UINT DDX/DDV helper function that uses a blank string to denote 0
//
void AFXAPI DDXV_UINT(
    IN CDataExchange * pDX,
    IN UINT nID,
    IN OUT UINT & uValue,
    IN UINT uMin,
    IN UINT uMax,
    IN UINT nEmptyErrorMsg = 0
    );

//
// Helper function to check to see if binding is unique
//
BOOL
IsBindingUnique(
    IN CString & strBinding,
    IN CStringList & strlBindings,
    IN int iCurrent = -1
    );

/*
//
// Helper function to build and verify binding strings.
//
BOOL
VerifyBindingInfo(
    OUT CString & strBinding,
    OUT CString & strSecureBinding,
    IN  CStringList & strlBindings,
    IN  CStringList & strlSecureBindings,
    IN  int iBindings,
    IN  int iSSLBindings,
    IN  CIPAddress & iaIpAddress,
    IN  UINT nTCPPort,
    IN  UINT nSSLPort,
    IN  CString & strDomainName
    );
*/


class CMMMListBox : public CHeaderListBox
{
/*++

Class Description:

    Multi-multi-multi listbox.

Public Interface:

    CMMMListBox    : Constructor

    GetItem        : Get item at specified position
                     in the listbox
    AddItem        : Add new item to the listbox
    Initialize     : Initialize the listbox

--*/
    DECLARE_DYNAMIC(CMMMListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;

public:
    CMMMListBox(
        IN LPCTSTR lpszRegKey,
        IN int cColumns,
        IN const ODL_COLUMN_DEF * pColumns
        );

public:
    CString & GetItem(UINT nIndex);
    int AddItem(CString & item);
    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & ds);

protected:
    int m_cColumns;
    const ODL_COLUMN_DEF * m_pColumns;
    CString m_strDefaultIP;
    CString m_strNoPort;
};



class CMMMEditDlg : public CDialog
/*++

Class Description:

    Multi-Multi-Multi edit entry dialog

Public Interface:

    CMMMEditDlg     : Constructor

--*/
{
//
// Construction
//
public:
    CMMMEditDlg(
        IN CString & strServerName,
        IN OUT CStringList & strlBindings,
        IN CStringList & strlOtherBindings,
        IN OUT CString & strEntry,
        IN BOOL fIPBinding = TRUE,
        IN CWnd * pParent = NULL
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CMMMEditDlg)
    enum { IDD = IDD_EDIT_MMM };
    int         m_nIpAddressSel;
    UINT        m_nPort;
    CString     m_strDomainName;
    CStatic     m_static_Port;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    CIPAddress m_iaIpAddress;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMMMEditDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMMMEditDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    BOOL m_fIPBinding;
    CString & m_strServerName;
    CString & m_entry;
    CObListPlus m_oblIpAddresses;
    CStringList & m_strlBindings;
    CStringList & m_strlOtherBindings;
};



class CMMMDlg : public CDialog
/*++

Class Description:

    Mutlti-multi-multi dialog

Public Interface:

    CMMMDlg     : Constructor

--*/
{
//
// Construction
//
public:
    CMMMDlg(
        IN LPCTSTR lpServerName,
        IN DWORD   dwInstance,
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpMetaPath,
        IN CStringList & strlBindings,
        IN CStringList & strlSecureBindings,
        IN CWnd * pParent = NULL
        );

//
// Access
//
public:
    CStringList & GetBindings() { return m_strlBindings; }
    CStringList & GetSecureBindings() { return m_strlSecureBindings; }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CMMMDlg)
    enum { IDD = IDD_MMM };
    CButton m_button_Add;
    CButton m_button_Remove;
    CButton m_button_Edit;
    CButton m_button_AddSSL;
    CButton m_button_RemoveSSL;
    CButton m_button_EditSSL;
    CButton m_button_OK;
    //}}AFX_DATA

    CMMMListBox m_list_Bindings;
    CMMMListBox m_list_SSLBindings;

    CStringList m_strlBindings;
    CStringList m_strlSecureBindings;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMMMDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CMMMDlg)
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonEdit();
    afx_msg void OnButtonRemove();
    afx_msg void OnButtonAddSsl();
    afx_msg void OnButtonEditSsl();
    afx_msg void OnButtonRemoveSsl();
    afx_msg void OnDblclkListMmm();
    afx_msg void OnDblclkListSslMmm();
    afx_msg void OnSelchangeListMmm();
    afx_msg void OnSelchangeListSslMmm();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    BOOL OnItemChanged();
    BOOL SetControlStates();
    void AddBindings(CMMMListBox & list, CStringList & strl);

private:
    BOOL m_fDirty;
    BOOL m_fCertInstalled;
    CString m_strServerName;
    CComAuthInfo * m_pAuthInfo;
    CString m_strMetaPath;
    CRMCListBoxResources m_ListBoxRes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CString & CMMMListBox::GetItem(UINT nIndex)
{
    return *(CString *)GetItemDataPtr(nIndex);
}

inline int CMMMListBox::AddItem(CString & item)
{
    return AddString((LPCTSTR)&item);
}

#endif // __MMMDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\mmmdlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        mmmdlg.cpp

   Abstract:

        Multi-multi-multi dialog editor

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetmgrapp.h"
#include "mmmdlg.h"
#include "inetprop.h"
#include "w3sht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Registry key name for this dialog
//
const TCHAR g_szRegKeyIP[] = _T("MMMIpBindings");
const TCHAR g_szRegKeySSL[] = _T("MMMSSLBindings");

//
// IP Bindings Listbox Column Definitions
//
static const ODL_COLUMN_DEF g_aIPColumns[] =
{
// ===============================================
// Weight   Label
// ===============================================
    {  6,   IDS_MMM_IP_ADDRESS,         },
    {  3,   IDS_MMM_TCP_PORT,           },
    { 10,   IDS_MMM_DOMAIN_NAME,        },
};

//
// SSL Bindings Listbox Column Definitions
//
static const ODL_COLUMN_DEF g_aSSLColumns[] =
{
// ===============================================
// Weight   Label
// ===============================================
    {  2,   IDS_MMM_IP_ADDRESS,         },
    {  1,   IDS_MMM_SSL_PORT,           },
};

#define NUM_COLUMNS(cols) (sizeof(cols) / sizeof(cols[0]))

IMPLEMENT_DYNAMIC(CMMMListBox, CRMCListBox);

//
// Bitmap indices
//
enum
{
    BMPID_BINDING,

    //
    // Don't move this one
    //
    BMPID_TOTAL
};


const int CMMMListBox::nBitmaps = BMPID_TOTAL;


CMMMListBox::CMMMListBox(
    IN LPCTSTR lpszRegKey,
    IN int cColumns,
    IN const ODL_COLUMN_DEF * pColumns
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : CHeaderListBox(HLS_STRETCH, lpszRegKey),
      m_cColumns(cColumns),
      m_pColumns(pColumns)
{
    VERIFY(m_strDefaultIP.LoadString(IDS_DEFAULT));
    VERIFY(m_strNoPort.LoadString(IDS_MMM_NA));
}



void
CMMMListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds : Draw item structure

Return Value:

    None

--*/
{
    CString & strBinding = *(CString *)ds.m_ItemData;

    TRACEEOLID(strBinding);

    UINT nPort;
    LPCTSTR lp;
    CString strHostHeader;
    CString strPort;
    CString strIP;
    CIPAddress iaIpAddress;

    CInstanceProps::CrackBinding(
        strBinding, 
        iaIpAddress, 
        nPort, 
        strHostHeader
        );

    //
    // Display Granted/Denied with appropriate bitmap
    //
    DrawBitmap(ds, 0, BMPID_BINDING);

    if (iaIpAddress.IsZeroValue())
    {
        lp = m_strDefaultIP;
    }
    else
    {
        lp = iaIpAddress.QueryIPAddress(strIP);
    }

    ColumnText(ds, 0, TRUE, lp);

    if (nPort > 0)
    {
        strPort.Format(_T("%u"), nPort);
        lp = strPort;
    }
    else
    {
        lp = m_strNoPort;
    }

    ColumnText(ds, 1, FALSE, lp);
    ColumnText(ds, 2, FALSE, strHostHeader);
}



/* virtual */
BOOL
CMMMListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    HINSTANCE hInst = AfxGetResourceHandle();
    for (int nCol = 0; nCol < m_cColumns; ++nCol)
    {
        InsertColumn(nCol, m_pColumns[nCol].nWeight, m_pColumns[nCol].nLabelID, hInst);
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}



void AFXAPI
DDXV_UINT(
    IN CDataExchange * pDX,
    IN UINT nID,
    IN OUT UINT & uValue,
    IN UINT uMin,
    IN UINT uMax,
    IN UINT nEmptyErrorMsg  OPTIONAL
    )
/*++

Routine Description:

    DDX/DDV Function that uses a space to denote a 0 value

Arguments:

    CDataExchange * pDX     : Data exchange object
    UINT nID                : Resource ID
    OUT UINT & uValue       : Value
    UINT uMin               : Minimum value
    UINT uMax               : Maximum value
    UINT nEmptyErrorMsg     : Error message ID for empty unit, or 0 if empty OK

Return Value:

    None.

--*/
{
    ASSERT(uMin <= uMax);

    CWnd * pWnd = CWnd::FromHandle(pDX->PrepareEditCtrl(nID));
    ASSERT(pWnd != NULL);

    if (pDX->m_bSaveAndValidate)
    {
        if (pWnd->GetWindowTextLength() > 0)
        {
            DDX_Text(pDX, nID, uValue);
            DDV_MinMaxUInt(pDX, uValue, uMin, uMax);
        }
        else
        {
            uValue = 0;
            if (nEmptyErrorMsg)
            {
                ::AfxMessageBox(nEmptyErrorMsg);
                pDX->Fail();
            }
        }
    }
    else
    {
        if (uValue != 0)
        {
            DDX_Text(pDX, nID, uValue);
        }    
        else
        {
            pWnd->SetWindowText(_T(""));
        }
    }
}



BOOL
IsBindingUnique(
    IN CString & strBinding,
    IN CStringList & strlBindings,
    IN int iCurrent                 OPTIONAL
    )
/*++

Routine Description:

    Helper function to determine if a binding is unique.

Arguments:

    CString & strBinding            : Binding string
    CStringList & strlBindings      : List of bindings
    int iCurrent                    : Index of "current" item.  
                                      Not used for uniqueness checking.

Return Value:

    TRUE if the binding is unique, FALSE otherwise.

--*/
{
    int iItem = 0;
        
    for(POSITION pos = strlBindings.GetHeadPosition(); pos != NULL; /**/ )
    {
        CString & str = strlBindings.GetNext(pos);
        if (iItem != iCurrent && &str != &strBinding && str == strBinding)
        {
            //
            // Not unique!
            //
            return FALSE;
        }

        ++iItem;
    }

    //
    // Unique
    //
    return TRUE;
}


//
// Multi-multi-multi editing dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CMMMEditDlg::CMMMEditDlg(
    IN CString & strServerName,
    IN CStringList & strlBindings,
    IN CStringList & strlOtherBindings,
    IN OUT CString & entry,
    IN BOOL fIPBinding,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName          : Server name
    CStringList & strlBindings       : bindings
    CStringList & strlOtherBindings  : "other" bindings list
    CString & entry                  : Entry being edited
    BOOL fIPBinding                  : TRUE for IP, FALSE for SSL
    CWnd * pParent                   : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CMMMEditDlg::IDD, pParent),
      m_strServerName(strServerName),
      m_strlBindings(strlBindings),
      m_strlOtherBindings(strlOtherBindings),
      m_entry(entry),
      m_fIPBinding(fIPBinding),
      m_nIpAddressSel(-1)
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CMMMEditDlg)
    m_nIpAddressSel = -1;
    //}}AFX_DATA_INIT

#endif // 0

    CInstanceProps::CrackBinding(
        m_entry, 
        m_iaIpAddress, 
        m_nPort, 
        m_strDomainName
        );
}

void 
CMMMEditDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMMMEditDlg)
    DDX_Text(pDX, IDC_EDIT_DOMAIN_NAME, m_strDomainName);
    DDV_MaxChars(pDX, m_strDomainName, MAX_PATH);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
    DDX_Control(pDX, IDC_STATIC_PORT, m_static_Port);
    //}}AFX_DATA_MAP

    DDXV_UINT(pDX, IDC_EDIT_PORT, m_nPort, 1, 65535);

    DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

    if (pDX->m_bSaveAndValidate && !FetchIpAddressFromCombo(
            m_combo_IpAddresses, m_oblIpAddresses, m_iaIpAddress))
    {
        pDX->Fail();
    }

    // Currently IIS support in domain names only A-Z,a-z,0-9,.-
    if (pDX->m_bSaveAndValidate)
    {
        LPCTSTR p = m_strDomainName;
        while (p != NULL && *p != 0)
        {
            TCHAR c = towupper(*p);
            if (    (c >= _T('A') && c <= _T('Z')) 
                ||  (c >= _T('0') && c <= _T('9'))
                ||  (c == _T('.') || c == _T('-'))
                )
            {
                p++;
                continue;
            }
            else
            {
                AfxMessageBox(IDS_WARNING_DOMAIN_NAME);
                pDX->PrepareEditCtrl(IDC_EDIT_DOMAIN_NAME);
                pDX->Fail();
            }
        }
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CMMMEditDlg, CDialog)
    //{{AFX_MSG_MAP(CMMMEditDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CMMMEditDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();

    //
    // Configure dialog for either SSL or IP binding editing
    //
    CString str;
    VERIFY(str.LoadString(m_fIPBinding 
        ? IDS_EDIT_MMM_TITLE
        : IDS_EDIT_SSL_MMM_TITLE));
    SetWindowText(str);

    VERIFY(str.LoadString(m_fIPBinding 
        ? IDS_TCP_PORT
        : IDS_SSL_PORT));
    m_static_Port.SetWindowText(str);

    ActivateControl(*GetDlgItem(IDC_STATIC_HEADER_NAME), m_fIPBinding);
    ActivateControl(*GetDlgItem(IDC_EDIT_DOMAIN_NAME),   m_fIPBinding);
#if 0
    CHARFORMAT cf;
    ZeroMemory(&cf, sizeof(cf));
    cf.cbSize = sizeof(cf);
    cf.dwMask = CFM_FACE;
    cf.bPitchAndFamily = FIXED_PITCH | FF_DONTCARE;
    lstrcpyn((LPTSTR)cf.szFaceName, _T("Courier"), LF_FACESIZE);

    SendDlgItemMessage(IDC_EDIT_DOMAIN_NAME, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
#endif
    DWORD event = (DWORD)SendDlgItemMessage(IDC_EDIT_DOMAIN_NAME, EM_GETEVENTMASK, 0, 0);
    event |= ENM_CHANGE;
    SendDlgItemMessage(IDC_EDIT_DOMAIN_NAME, EM_SETEVENTMASK, 0, (LPARAM)event);

    return TRUE;  
}



void 
CMMMEditDlg::OnOK() 
/*++

Routine Description:

    OK button handler.  Verify values are acceptable, and change

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    if (m_nPort == 0)
    {
        ::AfxMessageBox(IDS_NO_PORT);
        return;
    }

    CString strOldBinding(m_entry);
    CInstanceProps::BuildBinding(m_entry, m_iaIpAddress, m_nPort, m_strDomainName);

    //
    // Ensure the ip/address doesn't exist in the "other" binding list
    //
    if (CInstanceProps::IsPortInUse(m_strlOtherBindings, m_iaIpAddress, m_nPort))
    {
        //
        // Restore the old binding
        //
        m_entry = strOldBinding;
        ::AfxMessageBox(m_fIPBinding 
            ? IDS_ERR_PORT_IN_USE_SSL 
            : IDS_ERR_PORT_IN_USE_TCP);
        return; 
    }
    

    if (!IsBindingUnique(m_entry, m_strlBindings))
    {
        //
        // Restore the old binding
        //
        m_entry = strOldBinding;
        ::AfxMessageBox(IDS_ERR_BINDING);
        return; 
    }

    CDialog::OnOK();
}

//
// Multi-multi-multi list dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

CMMMDlg::CMMMDlg(
    IN LPCTSTR lpServerName,
    IN DWORD   dwInstance,
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpMetaPath,
    IN OUT CStringList & strlBindings,
    IN OUT CStringList & strlSecureBindings,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CStringList & strlBindings          : Service bindings
    CStringList & strlSecureBindings    : SSL port bindings
    CWnd * pParent                      : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CMMMDlg::IDD, pParent),
      m_ListBoxRes(
        IDB_BINDINGS,
        CMMMListBox::nBitmaps
        ),
      m_list_Bindings(g_szRegKeyIP, NUM_COLUMNS(g_aIPColumns), g_aIPColumns),
      m_list_SSLBindings(g_szRegKeySSL, NUM_COLUMNS(g_aSSLColumns), g_aSSLColumns),
      m_strlBindings(),
      m_strlSecureBindings(),
      m_strServerName(lpServerName),
      m_strMetaPath(lpMetaPath),
      m_pAuthInfo(pAuthInfo),
      m_fDirty(FALSE)
{
    //{{AFX_DATA_INIT(CMMMDlg)
    //}}AFX_DATA_INIT
    
    m_fCertInstalled = ::IsCertInstalledOnServer(m_pAuthInfo, lpMetaPath),
    m_strlBindings.AddTail(&strlBindings);
    m_strlSecureBindings.AddTail(&strlSecureBindings);
    m_list_Bindings.AttachResources(&m_ListBoxRes);
    m_list_SSLBindings.AttachResources(&m_ListBoxRes);
}


void 
CMMMDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMMMDlg)
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    DDX_Control(pDX, IDC_BUTTON_REMOVE, m_button_Remove);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_button_Edit);
    DDX_Control(pDX, IDC_BUTTON_ADD_SSL, m_button_AddSSL);
    DDX_Control(pDX, IDC_BUTTON_REMOVE_SSL, m_button_RemoveSSL);
    DDX_Control(pDX, IDC_BUTTON_EDIT_SSL, m_button_EditSSL);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_MMM, m_list_Bindings);
    DDX_Control(pDX, IDC_LIST_SSL_MMM, m_list_SSLBindings);
}



BOOL
CMMMDlg::OnItemChanged()
/*++

Routine Description:

    Mark that the dialog as dirty

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled

--*/
{
    m_fDirty = TRUE;

    return SetControlStates();
}



BOOL
CMMMDlg::SetControlStates()
/*++

Routine Description:

    Set the enabled state of the controls depending on the current
    values in the dialog

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled

--*/
{
    BOOL fSel = m_list_Bindings.GetSelCount() > 0;

    m_button_Remove.EnableWindow(fSel);
    m_button_Edit.EnableWindow(m_list_Bindings.GetSelCount() == 1);
    m_button_RemoveSSL.EnableWindow(m_list_SSLBindings.GetSelCount() > 0);
    m_button_EditSSL.EnableWindow(m_list_SSLBindings.GetSelCount() == 1);

    m_button_OK.EnableWindow(m_fDirty && m_list_Bindings.GetCount() > 0);

    return fSel;
}



void
CMMMDlg::AddBindings(
    IN CMMMListBox & list, 
    IN CStringList & strlBindings
    )
/*++

Routine Description:

    Add bindings information to the specified listbox

Arguments:

    CMMMListBox & list              : MMM Listbox (SSL or IP)
    CStringList & strlBindings      : SSL or IP bindings

Return Value:

    None

--*/
{
    for (POSITION pos = strlBindings.GetHeadPosition(); pos != NULL; /**/)
    {
        CString & strBinding = strlBindings.GetNext(pos);
        list.AddItem(strBinding);
    }
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CMMMDlg, CDialog)
    //{{AFX_MSG_MAP(CMMMDlg)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
    ON_BN_CLICKED(IDC_BUTTON_ADD_SSL, OnButtonAddSsl)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_SSL, OnButtonEditSsl)
    ON_BN_CLICKED(IDC_BUTTON_REMOVE_SSL, OnButtonRemoveSsl)
    ON_LBN_DBLCLK(IDC_LIST_MMM, OnDblclkListMmm)
    ON_LBN_DBLCLK(IDC_LIST_SSL_MMM, OnDblclkListSslMmm)
    ON_LBN_SELCHANGE(IDC_LIST_MMM, OnSelchangeListMmm)
    ON_LBN_SELCHANGE(IDC_LIST_SSL_MMM, OnSelchangeListSslMmm)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void 
CMMMDlg::OnButtonAdd() 
/*++

Routine Description:

    Add button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Add entry
    //
    CString strEntry;

    CMMMEditDlg dlg(
        m_strServerName, 
        m_strlBindings,
        m_strlSecureBindings,
        strEntry, 
        TRUE, /* IP binding */
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        POSITION pos = m_strlBindings.AddTail(strEntry);
        int nSel = m_list_Bindings.AddItem(m_strlBindings.GetAt(pos));
        m_list_Bindings.SetCurSel(nSel);
        OnItemChanged();
    }
}

void 
CMMMDlg::OnButtonEdit() 
/*++

Routine Description:

    Edit button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Edit entry
    //
    int nCurSel = m_list_Bindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        CString & strEntry = m_list_Bindings.GetItem(nCurSel);
        CMMMEditDlg dlg(
            m_strServerName, 
            m_strlBindings,
            m_strlSecureBindings,
            strEntry, 
            TRUE, /* IP binding */
            this
            );

        if (dlg.DoModal() == IDOK)
        {
            m_list_Bindings.InvalidateSelection(nCurSel);
            OnItemChanged();
        }
    }
}

void 
CMMMDlg::OnButtonRemove() 
/*++

Routine Description:

    Remove button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_Bindings.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_Bindings.GetCount())
    {
        //
        // Remove Selected entry
        //
        if (m_list_Bindings.GetSel(nSel))
        {
            m_strlBindings.RemoveAt(m_strlBindings.FindIndex(nSel));
            m_list_Bindings.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_Bindings.SetCurSel(nCurSel);
        if (!OnItemChanged())
        {
            m_button_Add.SetFocus();
        }
    }
/*
    //
    // Remove Selected entry
    //
    int nCurSel = m_list_Bindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        m_strlBindings.RemoveAt(m_strlBindings.FindIndex(nCurSel));
        m_list_Bindings.DeleteString(nCurSel);
        if (nCurSel >= m_list_Bindings.GetCount())
        {
            --nCurSel;
        }
        m_list_Bindings.SetCurSel(nCurSel);

        if (!OnItemChanged())
        {
            m_button_Add.SetFocus();
        }
    }
*/
}


void 
CMMMDlg::OnDblclkListMmm() 
/*++

Routine Description:

    Double click notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEdit();
}


void 
CMMMDlg::OnSelchangeListMmm() 
/*++

Routine Description:

    selection change notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CMMMDlg::OnButtonAddSsl() 
/*++

Routine Description:

    'Add SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Add entry
    //
    CString strEntry;

    CMMMEditDlg dlg(
        m_strServerName, 
        m_strlSecureBindings,
        m_strlBindings,
        strEntry, 
        FALSE, /* SSL binding */
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        POSITION pos = m_strlSecureBindings.AddTail(strEntry);
        int nSel = m_list_SSLBindings.AddItem(m_strlSecureBindings.GetAt(pos));
        m_list_SSLBindings.SetCurSel(nSel);
        OnItemChanged();
    }
}



void 
CMMMDlg::OnButtonEditSsl() 
/*++

Routine Description:

    'Edit SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Edit entry
    //
    int nCurSel = m_list_SSLBindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        CString & strEntry = m_list_SSLBindings.GetItem(nCurSel);
        CMMMEditDlg dlg(
            m_strServerName, 
            m_strlSecureBindings,
            m_strlBindings,
            strEntry, 
            FALSE, /* SSL binding */
            this
            );

        if (dlg.DoModal() == IDOK)
        {
            m_list_SSLBindings.InvalidateSelection(nCurSel);
            OnItemChanged();
        }
    }
}



void 
CMMMDlg::OnButtonRemoveSsl() 
/*++

Routine Description:

    'Remove SSL' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    int nCurSel = m_list_SSLBindings.GetCurSel();
    int nSel = 0;
    int cChanges = 0;
    while (nSel < m_list_SSLBindings.GetCount())
    {
        //
        // Remove Selected entry
        //
        if (m_list_SSLBindings.GetSel(nSel))
        {
            m_strlSecureBindings.RemoveAt(m_strlSecureBindings.FindIndex(nSel));
            m_list_SSLBindings.DeleteString(nSel);
            ++cChanges;
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        m_list_SSLBindings.SetCurSel(nCurSel);
        OnItemChanged();
        if (m_list_SSLBindings.GetSelCount() == 0)
        {
            //
            // Remove will be disabled
            //
            m_button_AddSSL.SetFocus();
        }
    }

/*
    //
    // Remove Selected entry
    //
    int nCurSel = m_list_SSLBindings.GetCurSel();
    if (nCurSel != LB_ERR)
    {
        m_strlSecureBindings.RemoveAt(m_strlSecureBindings.FindIndex(nCurSel));
        m_list_SSLBindings.DeleteString(nCurSel);
        if (nCurSel >= m_list_SSLBindings.GetCount())
        {
            --nCurSel;
        }
        m_list_SSLBindings.SetCurSel(nCurSel);

        OnItemChanged();
        if (m_list_SSLBindings.GetCurSel() == LB_ERR)
        {
            //
            // Remove will be disabled
            //
            m_button_AddSSL.SetFocus();
        }
    }
*/
}



void 
CMMMDlg::OnDblclkListSslMmm() 
/*++

Routine Description:

    SSL List 'double click' handler

Arguments:

    None

Return Value:

    None

--*/
{
    OnButtonEditSsl();
}



void 
CMMMDlg::OnSelchangeListSslMmm() 
/*++

Routine Description:

    SSL List 'selection change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



BOOL 
CMMMDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    m_list_Bindings.Initialize();
    m_list_SSLBindings.Initialize();

    AddBindings(m_list_Bindings, m_strlBindings);
    AddBindings(m_list_SSLBindings, m_strlSecureBindings);

    //
    // No certificates, no SSL
    //
    GetDlgItem(IDC_GROUP_SSL)->EnableWindow(m_fCertInstalled);
    m_list_SSLBindings.EnableWindow(m_fCertInstalled);
    m_button_AddSSL.EnableWindow(m_fCertInstalled);
    m_button_RemoveSSL.EnableWindow(m_fCertInstalled);
    m_button_EditSSL.EnableWindow(m_fCertInstalled);

    SetControlStates();
    
    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\perform.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        perform.cpp

   Abstract:
        WWW Performance Property Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/29/2000      sergeia     Changed for IIS6. Removed excessive commenting

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "supdlgs.h"
#include "perform.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define CONNECTIONS_MIN     0
#define CONNECTIONS_MAX     2000000

#define LIMITED_CONNECTIONS_MIN    (10)
#define LIMITED_CONNECTIONS_MAX    (40)
//#define MAX_MAX_CONNECTIONS      (1999999999L)
#define INITIAL_MAX_CONNECTIONS  (      1000L)
//#define UNLIMITED_CONNECTIONS    (2000000000L)


IMPLEMENT_DYNCREATE(CW3PerfPage, CInetPropertyPage)

/* static */
void
CW3PerfPage::ParseMaxNetworkUse(
      DWORD& dwMaxBandwidth, 
      DWORD& dwMaxBandwidthDisplay,
      BOOL& fLimitBandwidth
      )
{
    //
    // Special case: If dwMaxBandwidth is 0(an invalid value), the 
    // value likely could not be inherited from the root (the user
    // is an operator and can't see the properties there).  Adjust
    // the value to a possibly misleading value.
    //
    if (dwMaxBandwidth == 0L)
    {
        TRACEEOLID("Adjusting invalid bandwidth throttling value -- "
                   "are you an operator?");
        dwMaxBandwidth = INFINITE_BANDWIDTH;
    }

    fLimitBandwidth = (dwMaxBandwidth != INFINITE_BANDWIDTH);
    dwMaxBandwidthDisplay = fLimitBandwidth ?
      (dwMaxBandwidth / KILOBYTE) : (DEF_BANDWIDTH / KILOBYTE);
}



CW3PerfPage::CW3PerfPage(
    IN CInetPropertySheet * pSheet
    )
    : CInetPropertyPage(CW3PerfPage::IDD, pSheet)
{
#ifdef _DEBUG
    afxMemDF |= checkAlwaysMemDF;
#endif // _DEBUG
    m_nUnlimited = RADIO_LIMITED;
    m_nMaxConnections = 50;
    m_nVisibleMaxConnections = 50;
}

CW3PerfPage::~CW3PerfPage()
{
}

void
CW3PerfPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3PerfPage)
    DDX_Check(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_fLimitBandwidth);
    DDX_Control(pDX, IDC_CHECK_LIMIT_NETWORK_USE, m_LimitBandwidth);
    DDX_Control(pDX, IDC_MAX_BANDWIDTH, m_MaxBandwidth);
    DDX_Text(pDX, IDC_MAX_BANDWIDTH, m_dwMaxBandwidthDisplay);
    DDX_Control(pDX, IDC_MAX_BANDWIDTH_SPIN, m_MaxBandwidthSpin);
    DDX_Control(pDX, IDC_STATIC_MAX_NETWORK_USE, m_MaxBandwidthTxt);
    DDX_Check(pDX, IDC_UNINSTALL_PSHED, m_fUninstallPSHED);
    DDX_Control(pDX, IDC_UNINSTALL_PSHED, m_UninstallPSHED);
    DDX_Control(pDX, IDC_STATIC_PSHED_REQUIRED, m_static_PSHED_Required);

    DDX_Control(pDX, IDC_STATIC_CONN, m_WebServiceConnGrp);
    DDX_Control(pDX, IDC_STATIC_CONN_TXT, m_WebServiceConnTxt);
    DDX_Control(pDX, IDC_RADIO_UNLIMITED, m_radio_Unlimited);
    DDX_Control(pDX, IDC_RADIO_LIMITED, m_radio_Limited);
    DDX_Radio(pDX, IDC_RADIO_UNLIMITED, m_nUnlimited);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxConnections);
    DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_nMaxConnections);
    DDX_Control(pDX, IDC_SPIN_MAX_CONNECTIONS, m_MaxConnectionsSpin);
    DDX_Control(pDX, IDC_STATIC_CONNECTIONS, m_ConnectionsTxt);
    //}}AFX_DATA_MAP
    if (!pDX->m_bSaveAndValidate || m_fLimitBandwidth)
    {
        DDX_Text(pDX, IDC_MAX_BANDWIDTH, m_dwMaxBandwidthDisplay);
        DDV_MinMaxLong(pDX, m_dwMaxBandwidthDisplay, 
            BANDWIDTH_MIN, BANDWIDTH_MAX);
    }
    if (IsMasterInstance())
    {
       if (!pDX->m_bSaveAndValidate || !m_fUnlimitedConnections )
       {
           DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_nVisibleMaxConnections);
       }
       DDV_MinMaxDWord(pDX, m_nVisibleMaxConnections, 0, UNLIMITED_CONNECTIONS);
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3PerfPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3PerfPage)
    ON_BN_CLICKED(IDC_CHECK_LIMIT_NETWORK_USE, OnCheckLimitNetworkUse)
    ON_BN_CLICKED(IDC_RADIO_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_UNLIMITED, OnRadioUnlimited)
    //}}AFX_MSG_MAP
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_MAX_BANDWIDTH, OnItemChanged)
END_MESSAGE_MAP()



BOOL
CW3PerfPage::SetControlStates()
/*++

Routine Description:

    Set control states depending on contents of the dialog

Arguments:

    None

Return Value:

    TRUE if the 'limit network use' is on.

--*/
{
    BOOL fLimitOn = FALSE;
    if (::IsWindow(m_LimitBandwidth.m_hWnd))
    {
        fLimitOn = m_LimitBandwidth.GetCheck() > 0
            && HasBwThrottling()
            && HasAdminAccess();

        m_static_PSHED_Required.ShowWindow(fLimitOn &&
                fLimitOn != m_fLimitBandwidthInitial ? SW_SHOW : SW_HIDE);
        m_UninstallPSHED.ShowWindow(!fLimitOn &&
                fLimitOn != m_fLimitBandwidthInitial ? SW_SHOW : SW_HIDE);

        m_MaxBandwidthTxt.EnableWindow(fLimitOn);
        m_MaxBandwidth.EnableWindow(fLimitOn);
        m_MaxBandwidthSpin.EnableWindow(fLimitOn);
    }
    if (::IsWindow(m_edit_MaxConnections.m_hWnd))
    {
        m_edit_MaxConnections.EnableWindow(!m_fUnlimitedConnections);
        m_MaxConnectionsSpin.EnableWindow(!m_fUnlimitedConnections);
        m_ConnectionsTxt.EnableWindow(!m_fUnlimitedConnections);
    }
    return fLimitOn;
}



/* virtual */
HRESULT
CW3PerfPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_INST_READ(CW3Sheet)
        FETCH_INST_DATA_FROM_SHEET(m_nMaxConnections);
        FETCH_INST_DATA_FROM_SHEET(m_dwMaxBandwidth);
        ParseMaxNetworkUse(
            m_dwMaxBandwidth, 
            m_dwMaxBandwidthDisplay, 
            m_fLimitBandwidth
            );

        m_fUnlimitedConnections =
            ((ULONG)(LONG)m_nMaxConnections >= UNLIMITED_CONNECTIONS);

        //
        // Set the visible max connections edit field, which
        // may start out with a default value
        //
        m_nVisibleMaxConnections = m_fUnlimitedConnections
            ? INITIAL_MAX_CONNECTIONS : m_nMaxConnections;

        //
        // Set radio value
        //
        m_nUnlimited = m_fUnlimitedConnections ? RADIO_UNLIMITED : RADIO_LIMITED;
    END_META_INST_READ(err)

    m_fLimitBandwidthInitial = m_fLimitBandwidth;

    return err;
}



/* virtual */
HRESULT
CW3PerfPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 performance page now...");

    CError err;

    BuildMaxNetworkUse(
        m_dwMaxBandwidth, 
        m_dwMaxBandwidthDisplay, 
        m_fLimitBandwidth
        );

    m_nMaxConnections = m_fUnlimitedConnections
        ? UNLIMITED_CONNECTIONS
        : m_nVisibleMaxConnections;
    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CW3Sheet)
        STORE_INST_DATA_ON_SHEET(m_dwMaxBandwidth);
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
    END_META_INST_WRITE(err)

    EndWaitCursor();

    m_fLimitBandwidthInitial = m_fLimitBandwidth;

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


BOOL 
CW3PerfPage::OnSetActive() 
{
    return CInetPropertyPage::OnSetActive();
}



void
CW3PerfPage::OnItemChanged()
{
    SetControlStates();
    SetModified(TRUE);
}

void
CW3PerfPage::OnRadioLimited()
/*++

Routine Description:

    'limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = FALSE;
    SetControlStates();
    m_edit_MaxConnections.SetSel(0,-1);
    m_edit_MaxConnections.SetFocus();
    OnItemChanged();
}


void
CW3PerfPage::OnRadioUnlimited()
/*++

Routine Description:

    'unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = TRUE;
    OnItemChanged();
}

void
CW3PerfPage::OnCheckLimitNetworkUse()
/*++

Routine Description:

    The "limit network use" checkbox has been clicked
    Enable/disable the "max bandwidth" controls.

Arguments:

    None

Return Value:

    None

--*/
{
    if (SetControlStates())
    {
        m_MaxBandwidth.SetSel(0, -1);
        m_MaxBandwidth.SetFocus();
    }
    OnItemChanged();
}

BOOL
CW3PerfPage::OnInitDialog()
{
   UDACCEL toAcc[3] = {{1, 1}, {3, 5}, {6, 10}};

   CInetPropertyPage::OnInitDialog();

   m_LimitBandwidth.EnableWindow(
     HasBwThrottling() && HasAdminAccess());
   m_UninstallPSHED.ShowWindow(SW_HIDE);
   m_static_PSHED_Required.ShowWindow(SW_HIDE);

   if (!IsMasterInstance())
   {
      m_WebServiceConnGrp.ShowWindow(SW_HIDE);
      m_WebServiceConnTxt.ShowWindow(SW_HIDE);
      m_radio_Unlimited.ShowWindow(SW_HIDE);
      m_radio_Limited.ShowWindow(SW_HIDE);
      m_edit_MaxConnections.ShowWindow(SW_HIDE);
      m_MaxConnectionsSpin.ShowWindow(SW_HIDE);
      m_ConnectionsTxt.ShowWindow(SW_HIDE);
   }
   else
   {
      SETUP_SPIN(m_MaxConnectionsSpin, 
             CONNECTIONS_MIN, CONNECTIONS_MAX, m_nMaxConnections);
   }

   SETUP_EDIT_SPIN(m_fLimitBandwidth, m_MaxBandwidth, m_MaxBandwidthSpin, 
      BANDWIDTH_MIN, BANDWIDTH_MAX, m_dwMaxBandwidthDisplay);

   SetControlStates();

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\perform.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        perform.h

   Abstract:
        WWW Performance Property Page definitions

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/29/2000      sergeia     Changed for IIS6. Removed excessive commenting

--*/
#ifndef __PERFORM_H__
#define __PERFORM_H__


class CW3PerfPage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CW3PerfPage)

    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };
//
// Construction
//
public:
    CW3PerfPage(CInetPropertySheet * pSheet = NULL);
    ~CW3PerfPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3PerfPage)
    enum { IDD = IDD_PERFORMANCE };
    BOOL m_fLimitBandwidth;
    CButton m_LimitBandwidth;
    CStatic m_MaxBandwidthTxt;
    CEdit m_MaxBandwidth;
    DWORD m_dwMaxBandwidthDisplay;
    CSpinButtonCtrl m_MaxBandwidthSpin;
    BOOL m_fUninstallPSHED;
    CButton m_UninstallPSHED;
    CStatic m_static_PSHED_Required;

    int     m_nUnlimited;
    CStatic m_WebServiceConnGrp;
    CStatic m_WebServiceConnTxt;
    CStatic m_ConnectionsTxt;
    CEdit   m_edit_MaxConnections;
    CButton m_radio_Unlimited;
    CButton m_radio_Limited;
    CSpinButtonCtrl m_MaxConnectionsSpin;
    //}}AFX_DATA
    BOOL m_fLimitBandwidthInitial;
    DWORD m_dwMaxBandwidth;
    BOOL m_fUnlimitedConnections;
    CILong m_nMaxConnections;
    CILong m_nVisibleMaxConnections;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3PerfPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

protected:
   static void 
   ParseMaxNetworkUse(
         DWORD& dwMaxBandwidth, 
         DWORD& dwMaxBandwidthDisplay,
         BOOL& fLimitBandwidth
         );

   static void
   BuildMaxNetworkUse(
         DWORD& dwMaxBandwidth, 
         DWORD& dwMaxBandwidthDisplay,
         BOOL& fLimitBandwidth
         );

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3PerfPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckLimitNetworkUse();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

    BOOL SetControlStates();
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


inline /* static */ void 
CW3PerfPage::BuildMaxNetworkUse(
      DWORD& dwMaxBandwidth, 
      DWORD& dwMaxBandwidthDisplay,
      BOOL& fLimitBandwidth
      )
{
   dwMaxBandwidth = fLimitBandwidth ?
      dwMaxBandwidthDisplay * KILOBYTE : INFINITE_BANDWIDTH;
}

#endif // __PERFORM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\pshed.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows 2000 (c) 1999
//
//  File:   install.cpp
//
//  Contents:   Net config code that installs the packet scheduler based
//              the domain policy
//
//  Author: Shreedhar Madhavapeddi (ShreeM)
//
//  Reworked by Sergei Antonov (sergeia) -- removed ugly notation and 
//  adapted to iis needs
//          
//  Usage Notes:
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <netcfgx.h>
#include <devguid.h>

static const GUID * c_aguidClass[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT
};


HRESULT CallINetCfg(BOOL Install);

HRESULT
AddRemovePSCHED(INetCfg * pINetCfg, BOOL Install)
{
    HRESULT hr;
    INetCfgClassSetup * pSetup;
    INetCfgComponent * pIComp;
    OBO_TOKEN OboToken;
    
    pSetup = NULL;
    pIComp = NULL;

    if (!pINetCfg)
    {
        return E_POINTER;
    }

    hr = pINetCfg->QueryNetCfgClass (&GUID_DEVCLASS_NETSERVICE,
                IID_INetCfgClassSetup, (VOID**)&pSetup);

    if (S_OK == hr)
    {
        ZeroMemory (&OboToken, sizeof(OboToken));
        OboToken.Type = OBO_USER;

        if (Install) 
        {
            hr = pSetup->Install (
                                  L"ms_psched",
                                  &OboToken,
                                  0, 0, NULL, NULL,
                                  &pIComp);

            if (NETCFG_S_REBOOT == hr)
            {
                hr = S_OK;
            }
                
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }
        }
        else
        {
            // first find the component.
            hr = pINetCfg->FindComponent (L"ms_psched", &pIComp);
            
            if (S_OK == hr)
            {
                hr = pSetup->DeInstall (
                                        pIComp,
                                        &OboToken,
                                        NULL);
                
                if (NETCFG_S_REBOOT == hr)
                {
                    hr = S_OK;
                }
                
                if (NETCFG_S_STILL_REFERENCED == hr)
                {
                    hr = S_OK;
                }

            }
        }

        if (pIComp && SUCCEEDED(hr))
        {
            pIComp->Release();
        }
        pSetup->Release();
    }
    HRESULT hrT = pINetCfg->Uninitialize ();

    return hr;
}


HRESULT 
CallINetCfg(BOOL Install)
{
    HRESULT hr = S_OK;

    // initialize COM
    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pncLock = NULL;
            
            // Get the locking interface
            hr = pnc->QueryInterface(IID_INetCfgLock,
                                     (LPVOID *)&pncLock);
            if (SUCCEEDED(hr))
            {
                // Attempt to lock the INetCfg for read/write
                static const ULONG c_cmsTimeout = 15000;
                static const WCHAR c_szSampleNetcfgApp[] =
                    L"Internet Information Services MMC Snapin";
                PWSTR szLockedBy;
                hr = pncLock->AcquireWriteLock(c_cmsTimeout,
                                               c_szSampleNetcfgApp,
                                               &szLockedBy);
                if (S_FALSE == hr)
                {
                    hr = NETCFG_E_NO_WRITE_LOCK;
//                    _tprintf(L"Could not lock INetcfg, it is already locked by '%s'", szLockedBy);
                    pncLock->Release();
                    pnc->Release();
                    CoUninitialize();
                    
                }

                if (SUCCEEDED(hr))
                {
                
                    // Initialize the INetCfg object.
                    //
                    hr = pnc->Initialize(NULL);
                    if (SUCCEEDED(hr))
                    {
                        pnc->AddRef();
                        AddRemovePSCHED(pnc, Install); 
                    }
                    else
                    {
                        // initialize failed, if obtained lock, release it
                        pncLock->ReleaseWriteLock();
                    }

                }
                pncLock->Release();
                pnc->Release();
            }
            else 
            {
                pnc->Release();
            }
        }
        
        if (FAILED(hr))
        {
            CoUninitialize();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\rat.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CRat wrapper class

class CRat : public CWnd
{
protected:
    DECLARE_DYNCREATE(CRat)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0xba634607, 0xb771, 0x11d0, { 0x92, 0x96, 0x0, 0xc0, 0x4f, 0xb6, 0x67, 0x8b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:
    short GetBorderStyle();
    void SetBorderStyle(short);
    BOOL GetEnabled();
    void SetEnabled(BOOL);
    COleFont GetFont();
    void SetFont(LPDISPATCH);
    CString GetCaption();
    void SetCaption(LPCTSTR);

// Operations
public:
    void SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget);
    void DoClick();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\pwiz.cpp ===
fs/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        pwiz.cpp

   Abstract:

        IIS Security Wizard

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//

#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "resource.h"
#include "pwiz.h"
#include <aclapi.h>
//#include <ntseapi.h>
#include <shlwapi.h>

BOOL CheckIfParentHasAccess(CComAuthInfo *pAuthInfo, CString csMetabaseNode);
BOOL ConvertToServiceLevelPath(CString & strMetaPath);

//
// IIS Security Template Class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


//
// Package of access rights granted for "READ" access
//
#define ACCMASK_READ_FLAGS  (0L\
    | FILE_READ_DATA\
    | READ_CONTROL\
    | SYNCHRONIZE\
    | FILE_READ_ATTRIBUTES\
    | FILE_READ_EA\
    )

//
// Package of access rights granted for "WRITE" access
//
// Note: This includes "delete" because the web service assumes
//       "delete" when granting write access.  This differs from
//       the norm.
//
#define ACCMASK_WRITE_FLAGS (0L\
    | FILE_WRITE_DATA\
    | FILE_APPEND_DATA\
    | DELETE\
    | FILE_WRITE_ATTRIBUTES\
    | FILE_WRITE_EA\
    )

//
// Package of access rights granted for "EXECUTE" access
//
#define ACCMASK_EXEC_FLAGS  (0L\
    | FILE_EXECUTE\
    )

//
// Package of access rights granted for "DIR BROWSE" access
//
//#define ACCMASK_DIRBROWSE_FLAGS (0L\
//    | DS_LIST_OBJECT\
//    )

//
// Package of access rights granted for "FULL CONTROL" access
//
#define ACCMASK_ADMIN_FLAGS (0L\
    | STANDARD_RIGHTS_ALL\
    | FILE_READ_DATA\
    | FILE_WRITE_DATA\
    | FILE_APPEND_DATA\
    | FILE_READ_EA\
    | FILE_WRITE_EA\
    | FILE_EXECUTE\
    | FILE_ADD_FILE\
    | FILE_ADD_SUBDIRECTORY\
    | FILE_READ_ATTRIBUTES\
    | FILE_WRITE_ATTRIBUTES\
    | FILE_LIST_DIRECTORY\
    | FILE_DELETE_CHILD\
    | FILE_TRAVERSE\
    | ACTRL_DS_LIST_OBJECT\
    )
//
// Package of access rights granted for "Everyone"
#define ACC_MASK_EVERYONE_FLAGS (0L\
      | ACCMASK_READ_FLAGS\
      | ACCMASK_EXEC_FLAGS\
      )
//
//
// Access permission bit strings
//
FLAGTOSTRING fsAccessPerms[] = 
{
    { MD_ACCESS_READ,    IDS_PERMS_READ,                TRUE },
    { MD_ACCESS_WRITE,   IDS_PERMS_WRITE,               TRUE },
    { MD_ACCESS_SCRIPT,  IDS_PERMS_SCRIPT,              TRUE },
    { MD_ACCESS_EXECUTE, IDS_PERMS_EXECUTE,             TRUE },
};

//
// Access mask bit strings
//
FLAGTOSTRING fsAclFlags[] = 
{
    { FILE_READ_DATA,         IDS_ACL_READ,           TRUE },
    { READ_CONTROL,           IDS_ACL_READ_CONTROL,   TRUE },
    { FILE_READ_ATTRIBUTES,   IDS_ACL_READ_ATTRIB,    TRUE },
    { FILE_READ_EA,           IDS_ACL_READ_PROP,      TRUE },
    { FILE_WRITE_DATA,        IDS_ACL_WRITE,          TRUE },
    { FILE_APPEND_DATA,       IDS_ACL_APPEND,         TRUE },
    { DELETE,                 IDS_ACL_DELETE,         TRUE },
    { FILE_WRITE_ATTRIBUTES,  IDS_ACL_WRITE_ATTRIB,   TRUE },
    { FILE_WRITE_EA,          IDS_ACL_WRITE_PROP,     TRUE },
    { FILE_EXECUTE,           IDS_ACL_EXECUTE,        TRUE },
//    { DS_LIST_CONTENTS,       IDS_ACL_LIST_OBJECT,    TRUE },
};


CIISSecurityTemplate::CIISSecurityTemplate(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit     
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey   : Open key
    LPCTSTR lpszMDPath      : Path
    BOOL    fInherit        : TRUE to inherit properties

Return Value:

    N/A

--*/
    : CMetaProperties(pKey, lpszMDPath),
      m_dwAccessPerms(0L),
      m_dlProperties(),
      m_strlSummary(),
      m_ipl()
{
    //
    // Set base class member
    //
    m_fInherit = fInherit;

    //
    // Managed Properties
    //
    m_dlProperties.AddTail(MD_ACCESS_PERM);
    m_dlProperties.AddTail(MD_IP_SEC);
}



/* virtual */
void
CIISSecurityTemplate::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,    m_pbMDData)
      HANDLE_META_RECORD(MD_ACCESS_PERM,        m_dwAccessPerms)
      HANDLE_META_RECORD(MD_IP_SEC,             m_ipl)
    END_PARSE_META_RECORDS

    //
    // If "execute" or "script" is on, read should be as well (makes
    // little sense otherwise)
    //
    if (IS_FLAG_SET(MP_V(m_dwAccessPerms), (MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT)))
    {
        SET_FLAG(MP_V(m_dwAccessPerms), MD_ACCESS_READ);
    }
}



/* virtual */
HRESULT 
CIISSecurityTemplate::ApplySettings(
    IN BOOL fUseTemplate,
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
{
    BOOL fWriteProperties = TRUE;

    CMetaKey mk(pAuthInfo, lpszMDPath, METADATA_PERMISSION_WRITE);
    CError err(mk.QueryResult());

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        if (fUseTemplate)
        {
            //
            // Create the path
            //
            err = mk.CreatePathFromFailedOpen();

            if (err.Succeeded())
            {
                err = mk.ReOpen(METADATA_PERMISSION_WRITE);
            }
        }
        else
        {
            //
            // No need to delete properties; everything's already
            // inherited.
            //
            fWriteProperties = FALSE;
            err.Reset();
        }
    }

    if (fWriteProperties)
    {
        do
        {
            BREAK_ON_ERR_FAILURE(err);
            
            if (fUseTemplate)
            {
                //
                // Write values from template
                //
                err = mk.SetValue(
                    MD_ACCESS_PERM, 
                    m_dwAccessPerms
                    );
                BREAK_ON_ERR_FAILURE(err);

                err = mk.SetValue(MD_IP_SEC, m_ipl);
                BREAK_ON_ERR_FAILURE(err);
            }
            else
            {
                //
                // We're going to use inheritance, so delete
                // the values that might exist here
                //
                ASSERT(m_dlProperties.GetCount() > 0);

                POSITION pos = m_dlProperties.GetHeadPosition();

                while(pos)
                {
                    DWORD dwID = m_dlProperties.GetNext(pos);
                    err = mk.DeleteValue(dwID);

                    if (err.HResult() == MD_ERROR_DATA_NOT_FOUND)
                    {
                        //
                        // That's ok
                        //
                        err.Reset();
                    }

                    if (err.Failed())
                    {
                        break;
                    }
                }
            }
        }
        while(FALSE);
    }

    return err;
}

void
CIISSecurityTemplate::AddSummaryString(
    LPCTSTR szTextItem,
    int cIndentLevel
    )
/*++

Routine Description:

    Helper function to add strings to the summary

Arguments:

    LPCTSTR szTextItem      : String to be added
    int cIndentLevel        : Indentation level

Return Value:

    None

--*/
{
    CString str(szTextItem);
    
    //
    // Add a tab at the beginning of each string for each
    // level of indentation requested
    //
    for (int i = 0; i < cIndentLevel; ++i)
    {
        str = _T("\t") + str;
    }

    m_strlSummary.AddTail(str);
}


void
CIISSecurityTemplate::AddSummaryString(
    UINT nID, int cIndentLevel)
/*++

Routine Description:

    Helper function to add strings to the summary which are referred to
    by string table resource ID

Arguments:

    UINT nID                : Resource ID
    int cIndentLevel        : Indentation level

Return Value:

    None

--*/
{
    CString str;
    VERIFY(str.LoadString(nID));

    AddSummaryString(str, cIndentLevel);
}

/* virtual */
void 
CIISSecurityTemplate::GenerateSummary(
    BOOL fUseTemplate,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Generate text summary of what's in the security template

Notes:

    This doesn't clear the summary.  It's the responsibility of
    the calling process to clear beforehand, otherwise the summary
    items get added at the end.  

    The derived class is expected to add its own information

--*/
{
    //
    // Summarize Access Permissions:
    //
    int nIndentLevel = 0;

    AddSummaryString(IDS_PERMISSIONS, nIndentLevel++);

    if (m_dwAccessPerms == 0L)
    {
        AddSummaryString(IDS_SUMMARY_NONE, nIndentLevel);
    }
    else
    {
        for (int i = 0; i < ARRAY_SIZE(fsAccessPerms); ++i)
        {
            if (IS_FLAG_SET(
                m_dwAccessPerms, 
                fsAccessPerms[i].dwFlag
                ) == fsAccessPerms[i].fSet)
            {
                AddSummaryString(fsAccessPerms[i].nID, nIndentLevel);
            }
        }
    }

    //
    // Summarize IP Access Restrictions:
    //
    --nIndentLevel;
    AddSummaryString(IDS_ADDRESS_RESTRICTIONS, nIndentLevel++);

    if (MP_V(m_ipl).IsEmpty())
    {
        AddSummaryString(IDS_SUMMARY_NONE, nIndentLevel);
    }
    else
    {
        CObListPlus oblAccessList;
        BOOL        fGrantByDefault;

        //
        // Get text version of ip access list for the summary
        //
        CError err(BuildIplOblistFromBlob(
            m_ipl,
            oblAccessList,
            fGrantByDefault
            ));

        if (err.Succeeded())
        {
            //
            // List default denied/granted state
            //
            AddSummaryString(
                fGrantByDefault ? IDS_SUMMARY_GRANTED : IDS_SUMMARY_DENIED,
                nIndentLevel
                );

            //
            // Enumerate restrictions (exceptions to the default)
            //
            CObListIter obli(oblAccessList);
            CIPAccessDescriptor * pAccess;

            CString str,
                    strAddress,
                    strGrpFormat,
                    strGrantedFmt,
                    strDeniedFmt;

            VERIFY(strGrantedFmt.LoadString(IDS_SPECIFIC_GRANTED));
            VERIFY(strDeniedFmt.LoadString(IDS_SPECIFIC_DENIED));
            VERIFY(strGrpFormat.LoadString(IDS_FMT_SECURITY));

            while (pAccess = (CIPAccessDescriptor *)obli.Next())
            {
                if (pAccess->IsDomainName())
                {
                    strAddress = pAccess->QueryDomainName();
                }
                else if (pAccess->IsSingle())
                {
                    strAddress = (LPCTSTR)pAccess->QueryIPAddress();
                }
                else
                {
                    CString strIP, strMask;

                    strAddress.Format(
                        strGrpFormat, 
                        (LPCTSTR)pAccess->QueryIPAddress().QueryIPAddress(strIP), 
                        (LPCTSTR)pAccess->QuerySubnetMask().QueryIPAddress(strMask)
                        );
                }

                str.Format( 
                    pAccess->HasAccess() ? strGrantedFmt : strDeniedFmt,
                    strAddress
                    );

                AddSummaryString(str, nIndentLevel);
            }
        }
        else
        {
            //
            // better than nothing
            //
            AddSummaryString(IDS_ADDRESS_IP, nIndentLevel);
        }
    }
}

//////////////////////////////////////////////////////////////////////

CFTPSecurityTemplate::CFTPSecurityTemplate(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit     
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey   : Open key
    LPCTSTR lpszMDPath      : Path
    BOOL    fInherit        : TRUE to inherit values, FALSE if not

Return Value:

    N/A

--*/
    : CIISSecurityTemplate(pKey, lpszMDPath, fInherit),
      m_fAllowAnonymous(FALSE),
      m_fAnonymousOnly(FALSE)
{
    //
    // Managed Properties
    //
    m_dlProperties.AddTail(MD_ALLOW_ANONYMOUS);
    m_dlProperties.AddTail(MD_ANONYMOUS_ONLY);
}



/* virtual */
HRESULT 
CFTPSecurityTemplate::LoadData()
/*++

Routine Description:

    LoadData() base class override

Arguments:

    None

Return Value:

    HRESULT

Notes:

    The FTP wizard has an annoying idiosynchrasy:  access authentication 
    settings are per site, not per vdir.   Therefore, they need to be set
    and fetched in a separate path, and not be set at all if not
    setting props on a site.  What a pain...

--*/
{
    TRACEEOLID(m_strMetaPath);

    m_strMetaRoot = _T("Root");
    CError err(CIISSecurityTemplate::LoadData());

    if (lstrcmpi(m_strMetaRoot, g_cszRoot) == 0)
    {
        //
        // Fetch the anonymous access settings from
        // the instance node.  Note: This explicit step
        // should only be necessary for templates, because 
        // this would otherwise be picked up on inheritance.
        //
        ASSERT(!m_fInherit);
        m_strMetaRoot.Empty();

        err = CIISSecurityTemplate::LoadData();
    }
    return err;
}


/* virtual */
HRESULT 
CWebSecurityTemplate::LoadData()
/*++

Routine Description:

    LoadData() base class override

Arguments:

    None

Return Value:

    HRESULT

Notes:

--*/
{
    TRACEEOLID(m_strMetaPath);
    m_strMetaRoot = _T("Root");

    CError err(CIISSecurityTemplate::LoadData());
    return err;
}



/* virtual */
void
CFTPSecurityTemplate::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base class values
    //
    CIISSecurityTemplate::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,    m_pbMDData)
      HANDLE_META_RECORD(MD_ALLOW_ANONYMOUS,    m_fAllowAnonymous)
      HANDLE_META_RECORD(MD_ANONYMOUS_ONLY,     m_fAnonymousOnly)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT 
CFTPSecurityTemplate::ApplySettings(
    BOOL fUseTemplates,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath
    )
{
    //
    // Write base class properties
    //
    CError err(CIISSecurityTemplate::ApplySettings(
        fUseTemplates,
        pAuthInfo,
        lpszMDPath
        ));

    if (err.Failed())
    {
        return err;
    }

    BOOL fWriteProperties = TRUE;

    CMetaKey mk(pAuthInfo, lpszMDPath, METADATA_PERMISSION_WRITE);
    err = mk.QueryResult();
    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        if (!fUseTemplates)
        {
            //
            // No need to delete properties; everything's already
            // inherited.  Note that this is the only legit failure
            // case.  If using a template, the base class must have
            // created the path by now.
            //
            fWriteProperties = FALSE;
            err.Reset();
        }
    }

    if (fWriteProperties)
    {
        do
        {
            if (mk.IsHomeDirectoryPath())
            {
                BREAK_ON_ERR_FAILURE(err);

                //
                // Path describes an instance path, which is the only
                // time we need to do anything here
                //
                err = mk.ConvertToParentPath(TRUE);
                BREAK_ON_ERR_FAILURE(err);

                if (fUseTemplates)
                {
                    //
                    // Write values from template
                    //
                    err = mk.SetValue(MD_ALLOW_ANONYMOUS, m_fAllowAnonymous);
                    BREAK_ON_ERR_FAILURE(err);
                    err = mk.SetValue(MD_ANONYMOUS_ONLY, m_fAnonymousOnly);
                }
                else
                {
                    //
                    // Inheritance case: delete authentication
                    // values
                    //
                    mk.DeleteValue(MD_ALLOW_ANONYMOUS);
                    mk.DeleteValue(MD_ANONYMOUS_ONLY);
                }
            }
        }
        while(FALSE);
    }
    return err;
}



/* virtual */
void 
CFTPSecurityTemplate::GenerateSummary(
    BOOL fUseTemplates,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath
    )
{
    //
    // Authentication methods apply to instances only
    //
    if (CMetabasePath::IsHomeDirectoryPath(lpszMDPath))
    {
        //
        // Add private summary items
        //
        AddSummaryString(IDS_AUTHENTICATION_METHODS);

        //
        // Summarize Authentication Methods:
        //
        AddSummaryString(m_fAllowAnonymous ? 
                IDS_AUTHENTICATION_ANONYMOUS : IDS_AUTHENTICATION_NO_ANONYMOUS, 1);

        if (m_fAllowAnonymous && m_fAnonymousOnly)
        {
            AddSummaryString(IDS_AUTHENTICATION_ANONYMOUS_ONLY, 1);
        }
    }

    //
    // Add base class summary
    //
    CIISSecurityTemplate::GenerateSummary(
        fUseTemplates, pAuthInfo, lpszMDPath);
}

///////////////////////////////////////////////////////////////////////

CWebSecurityTemplate::CWebSecurityTemplate(
    CMetaKey * pKey,
    LPCTSTR lpszMDPath,
    BOOL fInherit     
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey   : Open key
    LPCTSTR lpszMDPath      : Path
    BOOL    fInherit        : TRUE to inherit values, FALSE if not

Return Value:

    N/A

--*/
    : CIISSecurityTemplate(pKey, lpszMDPath, fInherit),
      m_dwAuthentication(MD_AUTH_ANONYMOUS),
      m_dwDirBrowsing(
        MD_DIRBROW_SHOW_DATE      |
        MD_DIRBROW_SHOW_TIME      |
        MD_DIRBROW_SHOW_SIZE      |
        MD_DIRBROW_SHOW_EXTENSION
        )
{
    //
    // Managed Properties
    //
    m_dlProperties.AddTail(MD_AUTHORIZATION);
    m_dlProperties.AddTail(MD_DIRECTORY_BROWSING);
}



/* virtual */
void
CWebSecurityTemplate::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base class values
    //
    CIISSecurityTemplate::ParseFields();
   
    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,    m_pbMDData)
      HANDLE_META_RECORD(MD_AUTHORIZATION,      m_dwAuthentication)
      HANDLE_META_RECORD(MD_DIRECTORY_BROWSING, m_dwDirBrowsing)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT 
CWebSecurityTemplate::ApplySettings(
    BOOL fUseTemplates,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Apply the settings to the specified destination path

Arguments:
    
    BOOL fUseTemplates         : TRUE if the source is from a template,
                                 FALSE if using inheritance.
    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name 
    DWORD   dwInstance         : Instance        
    LPCTSTR lpszParent         : Parent path (or NULL)
    LPCTSTR lpszAlias          : Alias name  (or NULL)

Return Value:

    HRESULT

--*/
{
    //
    // Write base class properties
    //
    CError err(CIISSecurityTemplate::ApplySettings(
        fUseTemplates, pAuthInfo, lpszMDPath
        ));

    if (err.Failed())
    {
        return err;
    }

    BOOL fWriteProperties = TRUE;

    CMetaKey mk(
        pAuthInfo,
        lpszMDPath, 
        METADATA_PERMISSION_WRITE
        );

    err = mk.QueryResult();

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        if (!fUseTemplates)
        {
            //
            // No need to delete properties; everything's already
            // inherited.  Note that this is the only legit failure
            // case.  If using a template, the base class must have
            // created the path by now.
            //
            fWriteProperties = FALSE;
            err.Reset();
        }
    }

    if (fWriteProperties)
    {
        do
        {
            BREAK_ON_ERR_FAILURE(err);
            
            if (fUseTemplates)
            {
                //
                // Write values from template
                //
                err = mk.SetValue(
                    MD_AUTHORIZATION, 
                    m_dwAuthentication
                    );

                BREAK_ON_ERR_FAILURE(err);

                err = mk.SetValue(
                    MD_DIRECTORY_BROWSING,
                    m_dwDirBrowsing
                    );
                BREAK_ON_ERR_FAILURE(err);
            }

            //
            // Nothing to do in the inheritance case, because the 
            // base class knows which properties should be deleted
            //
        }
        while(FALSE);
    }

    return err;
}

//
// Authentication bit strings
//
FLAGTOSTRING fsAuthentications[] = 
{
    { MD_AUTH_ANONYMOUS, IDS_AUTHENTICATION_ANONYMOUS,     TRUE  },
    { MD_AUTH_ANONYMOUS, IDS_AUTHENTICATION_NO_ANONYMOUS,  FALSE },
    { MD_AUTH_BASIC,     IDS_AUTHENTICATION_BASIC,         TRUE  },
    { MD_AUTH_MD5,       IDS_AUTHENTICATION_DIGEST,        TRUE  },
    { MD_AUTH_NT,        IDS_AUTHENTICATION_NT,            TRUE  },
};

/* virtual */
void 
CWebSecurityTemplate::GenerateSummary(
    BOOL fUseTemplates,
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Generate text summary of what's in the security template.  Arguments are
    the same as ApplySettings(), so that the summary can reflect what will
    actually be set.

Arguments:

    BOOL fUseTemplates         : TRUE if the source is from a template,
                                 FALSE if using inheritance.
    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name 
    DWORD   dwInstance         : Instance        
    LPCTSTR lpszParent         : Parent path (or NULL)
    LPCTSTR lpszAlias          : Alias name  (or NULL)

Return Value:

    None
--*/
{
    AddSummaryString(IDS_AUTHENTICATION_METHODS);

    int i;

    //
    // Summarize Authentication Methods:
    //
    if (m_dwAuthentication == 0L)
    {
        AddSummaryString(IDS_SUMMARY_NONE, 1);
    }
    else
    {
        for (i = 0; i < ARRAY_SIZE(fsAuthentications); ++i)
        {
            if (IS_FLAG_SET(m_dwAuthentication, fsAuthentications[i].dwFlag) == fsAuthentications[i].fSet)
            {
                AddSummaryString(fsAuthentications[i].nID, 1);
            }
        }
    }

    AddSummaryString(IDS_DIRECTORY_BROWSE);
    if (IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_ENABLED))
    {
        AddSummaryString(IDS_DIR_BROWSE_ON, 1);
    }
	else
	{
		AddSummaryString(IDS_DIR_BROWSE_OFF, 1);
    }

    if (IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_LOADDEFAULT))
    {
        AddSummaryString(IDS_LOAD_DEFAULT_ON, 1);
    }
    else
    {
        AddSummaryString(IDS_LOAD_DEFAULT_OFF, 1);
    }

    //
    // Add base class summary
    //
    CIISSecurityTemplate::GenerateSummary(
        fUseTemplates, pAuthInfo, lpszMDPath);
}

///////////////////////////////////////////////////////////////////////

CIISSecWizSettings::CIISSecWizSettings(
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMDPath
    )
    : CObjectPlus(),
      m_auth(pAuthInfo),
      m_strMDPath(lpszMDPath),
      m_fUseTemplate(TRUE),
      m_fSetAcls(FALSE),
      m_fReplaceAcls(FALSE),
      m_pist(NULL),
      m_hResult(S_OK)
{
}



CIISSecWizSettings::~CIISSecWizSettings()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if (m_pist != NULL)
    {
        delete m_pist;
    }
}



HRESULT
CIISSecWizSettings::FetchProperties(
    CMetaKey & mk,
    LPCTSTR lpszPath,
    BOOL fInherit
    )
/*++

Routine Description:

    Fetch metabase properties that are applicable for the security wizard

Arguments:

    CMetaKey & mk    : open key
    LPCTSTR lpszPath : Optional path
    BOOL    fInherit : TRUE to inherit properties

Return Value:

    HRESULT

--*/
{
    CError err(mk.QueryResult());
    
    if (err.Succeeded())
    {
        if (m_pist != NULL)
        {
            //
            // Clean up existing template data (must 
            // have pressed "back")
            //
            delete m_pist;
        }

        //
        // Create security template by calling the provided
        // allocator (which allocates an object of the 
        // derived class which is service-specific)
        //
        LPCTSTR p = lpszPath;
        if (p == NULL)
        {
            p = mk.QueryMetaPath();
        }
        CString spath, sname;
        CMetabasePath::GetServicePath(p, spath);
        CMetabasePath::GetLastNodeName(spath, sname);
        if (sname.CompareNoCase(SZ_MBN_WEB) == 0)
        {
            m_pist = new CWebSecurityTemplate(&mk, lpszPath, fInherit);
        }
        else if (sname.CompareNoCase(SZ_MBN_FTP) == 0)
        {
            m_pist = new CFTPSecurityTemplate(&mk, lpszPath, fInherit);
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }

        if (m_pist == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            err = m_pist->LoadData();
        }
    }

    return err;
}



//
// Permissions Wizard Source Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CPWSource, CIISWizardPage)



CPWSource::CPWSource(
    IN CIISSecWizSettings * pSettings
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISSecWizSettings * pSettings      : Settings

Return Value:

    None

--*/
    : CIISWizardPage(
        CPWSource::IDD,        // Template
        IDS_PERMWIZ,           // Caption
        HEADER_PAGE            // Header
        ),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CPWSource)
    m_nSource = RADIO_INHERITANCE;
    //}}AFX_DATA_INIT

//    ASSERT(m_pSettings);
//    ASSERT(!m_pSettings->m_strServer.IsEmpty());
}



CPWSource::~CPWSource()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CPWSource::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CPWSource)
    DDX_Radio(pDX, IDC_RADIO_INHERIT, m_nSource);
    //}}AFX_DATA_MAP
}



void
CPWSource::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CPWSource, CIISWizardPage)
    //{{AFX_MSG_MAP(CPWSource)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CPWSource::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    return CIISWizardPage::OnSetActive();
}



LRESULT 
CPWSource::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Store the source specified, so the next
    pages can skip or continue.

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    UpdateData(TRUE);

    m_pSettings->m_fUseTemplate = (m_nSource == RADIO_TEMPLATE);

    if (!m_pSettings->m_fUseTemplate)
    {
        CError err;

        CMetaKey mk(
            m_pSettings->m_auth,
            m_pSettings->m_strMDPath
            );

        if (mk.IsHomeDirectoryPath())
        {
            //
            // Current path is a virtual server, and we're
            // at the home directory.  We need to back up 
            // twice.
            //
            err = mk.ConvertToParentPath(TRUE);
            ASSERT(err.Succeeded());
        }

        //
        // Convert to first parent path
        //
        err = mk.ConvertToParentPath(FALSE);
        if (err.Succeeded())
        {
            err = m_pSettings->FetchProperties(mk, NULL, TRUE);
        }

        if (err.MessageBoxOnFailure())
        {
            return -1;
        }

        // Doing Inhert, so let's make sure
        // that at least the node that we are inheriting from
        // will have some sort of access...
        if (FALSE == CheckIfParentHasAccess(m_pSettings->m_auth,m_pSettings->m_strMDPath))
        {
            // popup messagebox saying that parent that we are inheriting from
            // does not give anyone access.
            if (::AfxMessageBox(IDS_PARENT_PATH_MISSING_PERMISSIONS, MB_YESNO | MB_DEFBUTTON2 ) != IDYES)
            {
                return -1;
            }
        }
    }

    return CIISWizardPage::OnWizardNext();
}



//
// Permissions Wizard Template Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CPWTemplate, CIISWizardPage)



CPWTemplate::CPWTemplate(
    IN CIISSecWizSettings * pSettings
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISSecWizSettings * pSettings      : Settings

Return Value:

    None

--*/
    : CIISWizardPage(
        CPWTemplate::IDD,        // Template
        IDS_PERMWIZ,             // Caption
        HEADER_PAGE              // Header
        ),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CPWTemplate)
    //}}AFX_DATA_INIT

    ASSERT(m_pSettings);
//    ASSERT(!m_pSettings->m_strServer.IsEmpty());
}



CPWTemplate::~CPWTemplate()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CPWTemplate::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CPWTemplate)
    DDX_Control(pDX, IDC_LIST_TEMPLATES,   m_list_Templates);
    DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_edit_Description);
    //}}AFX_DATA_MAP
}



void
CPWTemplate::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    int nSel = m_list_Templates.GetCurSel();

    if (nSel >= 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }

    SetWizardButtons(dwFlags);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CPWTemplate, CIISWizardPage)
    //{{AFX_MSG_MAP(CPWTemplate)
    ON_LBN_SELCHANGE(IDC_LIST_TEMPLATES, OnSelchangeListTemplates)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CPWTemplate::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE to show the page, FALSE to skip it.

--*/
{
    if (!m_pSettings->m_fUseTemplate)
    {
        return FALSE;
    }

    SetControlStates();

    return CIISWizardPage::OnSetActive();
}



LRESULT 
CPWTemplate::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Store the source specified, so the next
    pages can skip or continue.

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    UpdateData(TRUE);

    int nSel = m_list_Templates.GetCurSel();

    if (nSel < 0)
    {
        return -1;
    }
    
    CString strItem;

    m_list_Templates.GetText(nSel, strItem);

    //
    // Fetch the template, which is the text up until the tab
    // character
    //
    int nTab = strItem.Find(_T('\t'));
    ASSERT(nTab >= 0);

    if (nTab >= 0)
    {
        strItem.ReleaseBuffer(nTab);
    }

    TRACEEOLID(strItem);

    //
    // Read the properties from the selected template
    //
    CString strMDTemplates;
    CString strMDTemplates2;

    if (!CMetabasePath::GetServiceInfoPath(
        m_pSettings->m_strMDPath,
        strMDTemplates,
        NULL
        ))
    {
        ASSERT_MSG("Unable to generate info path");
        return -1;
    }

    strMDTemplates = CMetabasePath(FALSE, strMDTemplates, SZ_MBN_TEMPLATES);

    // at this point
    // strMDTemplates=/LM/W3SVC/Info/Templates
    //
    // since this is a vdir, make it look like:
    // strMDTemplates=/LM/W3SVC/Info/Templates/Secure Web Site
    //
    strMDTemplates = strMDTemplates + _T("/") + strItem;
    CMetaKey mk(
        m_pSettings->m_auth,
        strMDTemplates
        );

    CError err(m_pSettings->FetchProperties(mk, NULL, FALSE));
    if (err.MessageBoxOnFailure())
    {
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}



BOOL 
CPWTemplate::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    //
    // Assure the comments remain offscreen
    //
    m_list_Templates.SetTabStops(5000);

    //
    // Enumerate the existing templates
    //
    CError  err;
    CString strMDTemplates;

    do
    {
        

        if (!CMetabasePath::GetServiceInfoPath(m_pSettings->m_strMDPath, strMDTemplates, NULL))
        {
            ASSERT_MSG("Unable to generate info path");
            err = ERROR_PATH_NOT_FOUND;
            break;
        }
        
        strMDTemplates = CMetabasePath(FALSE, strMDTemplates, SZ_MBN_TEMPLATES);

        CMetaEnumerator mk(
            m_pSettings->m_auth,
            strMDTemplates
            );

        err = mk.QueryResult();

        if (err.Failed())
        {
            break;
        }

        //
        // Enumerate and add to the listbox.
        //
        CString strTemplate, strComment, strListItem;

        while (err.Succeeded())
        {
            err = mk.Next(strTemplate);

            if (err.Succeeded())
            {
                //
                // Read off the open key
                //
                err = mk.QueryValue(
                    MD_SERVER_COMMENT, 
                    strComment, 
                    NULL, 
                    strTemplate
                    );

                if (err.Succeeded())
                {
                    TRACEEOLID(strComment);

                    //
                    // Append the comment in the off-screen
                    // area of the listbox
                    //
                    strListItem.Format(_T("%s\t%s"), 
                        (LPCTSTR)strTemplate, 
                        (LPCTSTR)strComment
                        );

                    m_list_Templates.AddString(strListItem);
                }
            }
        }
    }
    while(FALSE);

    if (err.Failed())
    {
        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            AfxMessageBox(IDS_NO_TEMPLATES);
        }
        else if (err.Win32Error() != ERROR_NO_MORE_ITEMS)
        {
            err.MessageBox();
        }
    }

    return TRUE;  
}



void 
CPWTemplate::OnSelchangeListTemplates() 
/*++

Routine Description:

    Handle selection change in the templates listbox

Arguments:

    None

Return Value:

    None

--*/
{
    int nSel = m_list_Templates.GetCurSel();
    ASSERT(nSel >= 0);

    if (nSel >= 0)
    {
        CString strItem;

        m_list_Templates.GetText(nSel, strItem);

        //
        // Fetch the comment, which is just beyond the tab
        // character
        //
        int nTab = strItem.Find(_T('\t'));
        ASSERT(nTab >= 0);

        if (nTab >= 0)
        {
            strItem = strItem.Mid(nTab + 1);
        }

        m_edit_Description.SetWindowText(_T(""));
        m_edit_Description.SetWindowText(strItem);
        Invalidate();
        UpdateWindow();
    }

    SetControlStates();
}



//
// Permissions Wizard ACL Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CPWACL, CIISWizardPage)



CPWACL::CPWACL(
    IN CIISSecWizSettings * pSettings
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISSecWizSettings * pSettings      : Settings

Return Value:

    None

--*/
    : CIISWizardPage(
        CPWACL::IDD,        // Template
        IDS_PERMWIZ,        // Caption,
        HEADER_PAGE         // Header
        ),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CPWACL)
    m_nRadioAclType = RADIO_MAXIMUM;
    //}}AFX_DATA_INIT

    ASSERT(m_pSettings);
//    ASSERT(!m_pSettings->m_strServer.IsEmpty());
}



CPWACL::~CPWACL()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CPWACL::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CPWACL)
    DDX_Control(pDX, IDC_ED_BOLD4, m_static_Line4);
    DDX_Control(pDX, IDC_ED_BOLD3, m_static_Line3);
    DDX_Control(pDX, IDC_ED_BOLD2, m_static_Line2);
    DDX_Control(pDX, IDC_ED_BOLD1, m_static_Line1);
    DDX_Radio(pDX, IDC_RADIO_ACL_MAXIMUM, m_nRadioAclType);
    //}}AFX_DATA_MAP
}



void
CPWACL::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CPWACL, CIISWizardPage)
    //{{AFX_MSG_MAP(CPWACL)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



BOOL
GetPhysicalPath(
    IN  CMetaKey & mk,
    IN  CString & strMetaPath,
    OUT CString & strPhysicalPath
    )
/*++

Routine Description:

    Get the physical path of the parent as described by the metabase path

Arguments:

    CMetaKey & mk               : Open metabase key
    CString & strMetaPath       : Metabase path
    CString & strPhysicalPath   : Returns physical path

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    //
    // Get physical path of parent
    //
    CString strAlias;
    int nSlash = strMetaPath.ReverseFind(SZ_MBN_SEP_CHAR);

    if (nSlash < 0)
    {
        //
        // Didn't encounter a physical path at all!
        //
        TRACEEOLID("No physical path established -- ACLS skipped");
        ASSERT(FALSE);

        return FALSE;
    }

    strAlias = strMetaPath.Mid(nSlash + 1);
    strMetaPath.ReleaseBuffer(nSlash);

    TRACEEOLID(strAlias);
    TRACEEOLID(strMetaPath);

    BOOL fInherit = FALSE;
    CError err(mk.QueryValue(
        MD_VR_PATH, 
        strPhysicalPath, 
        &fInherit, 
        strMetaPath
        ));

    if (err.Failed())
    {
        GetPhysicalPath(mk, strMetaPath, strPhysicalPath);
    }
    
    strPhysicalPath += _T("\\");
    strPhysicalPath += strAlias;

    return TRUE;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


LRESULT 
CPWACL::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Store the acl replacement type specified, so the next
    pages can skip or continue.

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    UpdateData(TRUE);

    switch(m_nRadioAclType)
    {
    case RADIO_MINIMUM:
        m_pSettings->m_fReplaceAcls = FALSE;
        break;

    case RADIO_MAXIMUM:
        m_pSettings->m_fReplaceAcls = TRUE;
        break;

    case RADIO_NONE:
    default:    
        m_pSettings->m_fSetAcls = FALSE;
    }

    return CIISWizardPage::OnWizardNext();
}


static PSID psidAdministrators = NULL;
static PSID psidEveryone = NULL;

BOOL 
CPWACL::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE to show the page, FALSE to skip it.

--*/
{
    //
    // Assume no acls until all tests pass
    //
    m_pSettings->m_fSetAcls = FALSE;

    if (!m_pSettings->m_auth->IsLocal())
    {
        TRACEEOLID("We're not local -- skipping ACL phase");
        return FALSE;
    }

    //
    // Get properties on the current directory object
    //
    CChildNodeProps props(
        m_pSettings->m_auth, 
        m_pSettings->m_strMDPath,
        WITH_INHERITANCE
        );

    CError err(props.LoadData());

    if (err.MessageBoxOnFailure())
    {
        TRACEEOLID("Unable to determine directory properties -- skipping ACLS");
        ASSERT(FALSE);

        return FALSE;
    }

    m_pSettings->m_fRedirected = props.IsRedirected();

    if (m_pSettings->m_fRedirected)
    {
        TRACEEOLID("Redirection in place, will not set ACLS");

        return FALSE;
    }

    //
    // If the path is on a remote store, Then no ACL page. - boydm
    //
    if (::IsUNCName(MP_V(props.m_strPath)))
    {
        TRACEEOLID("share is remote, will not set ACLS");

        return FALSE;
    }

    //
    // Don't get confused here, build the real physical path
    //
    if (props.IsPathInherited())
    {
        TRACEEOLID("Path inherited");

        //
        // Look for parent path.
        //
        CString strMetaPath(props.QueryMetaRoot());
        TRACEEOLID(strMetaPath);

        CMetaKey mk(m_pSettings->m_auth);
        err = mk.QueryResult();

        if (err.Failed())
        {
            ASSERT(FALSE);

            return FALSE;
        }

        if (!GetPhysicalPath(mk, strMetaPath, m_pSettings->m_strPath))
        {
            ASSERT(FALSE);

            return FALSE;
        }

    }
    else
    {
        m_pSettings->m_strPath = props.m_strPath;
    }

    DWORD dwFileSystemFlags;

    if (::GetVolumeInformationSystemFlags(
        m_pSettings->m_strPath,
        &dwFileSystemFlags
        ))
    {
        if (!(dwFileSystemFlags & FS_PERSISTENT_ACLS))
        {
            //
            // No ACLS
            //
            TRACEEOLID("Volume type doesn't accept ACLS -- skipping");

            return FALSE;
        }
    }

    //
    // Build ACL information to be set
    //
    m_pSettings->m_AccessMaskAdmin = ACCMASK_ADMIN_FLAGS;
    m_pSettings->m_AccessMaskDefault
        = m_pSettings->m_AccessMaskEveryone = ACC_MASK_EVERYONE_FLAGS;

    //
    // Display proposed ACEs in bold-faced entries on the dialog
    //
    UINT nID = IDC_ED_BOLD1;

    CString str;

    VERIFY(str.LoadString(IDS_ACL_ADMINS));
    GetDlgItem(nID++)->SetWindowText(str);

    if (IS_FLAG_SET(m_pSettings->m_pist->m_dwAccessPerms, MD_ACCESS_READ))
    {
        VERIFY(str.LoadString(IDS_ACL_EV_READ));
        GetDlgItem(nID++)->SetWindowText(str);

        m_pSettings->m_AccessMaskEveryone |= ACCMASK_READ_FLAGS;
    }

    if (IS_FLAG_SET(m_pSettings->m_pist->m_dwAccessPerms, MD_ACCESS_WRITE))
    {
        VERIFY(str.LoadString(IDS_ACL_EV_WRITE));
        GetDlgItem(nID++)->SetWindowText(str);

        m_pSettings->m_AccessMaskEveryone |= ACCMASK_WRITE_FLAGS;
    }

    if (IS_FLAG_SET(m_pSettings->m_pist->m_dwAccessPerms, MD_ACCESS_EXECUTE))
    {
        VERIFY(str.LoadString(IDS_ACL_EV_EXEC));
        GetDlgItem(nID++)->SetWindowText(str);

        m_pSettings->m_AccessMaskEveryone |= ACCMASK_EXEC_FLAGS;
    }

   ZeroMemory(&m_pSettings->m_rgaae, sizeof(m_pSettings->m_rgaae));
   SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY siaWorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

	AllocateAndInitializeSid(
		&siaNtAuthority,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS, 
		0, 0, 0, 0, 0, 0,
		&psidAdministrators);
	AllocateAndInitializeSid(
		&siaWorldSidAuthority,
		1,
		SECURITY_WORLD_RID,
		0, 0, 0, 0, 0, 0, 0,
		&psidEveryone);

    //
    // Set up permissions for the "Everyone" group
    //
    m_pSettings->m_rgaae[0].Trustee.pMultipleTrustee = NULL;
    m_pSettings->m_rgaae[0].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    m_pSettings->m_rgaae[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    m_pSettings->m_rgaae[0].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    m_pSettings->m_rgaae[0].Trustee.ptstrName = (LPTSTR)psidEveryone;

    m_pSettings->m_rgaae[0].grfAccessMode = SET_ACCESS;
    m_pSettings->m_rgaae[0].grfAccessPermissions  = m_pSettings->m_AccessMaskEveryone;
    m_pSettings->m_rgaae[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    
    //
    // Set up permissions for the "Administrators" group
    //
    m_pSettings->m_rgaae[1].Trustee.pMultipleTrustee  = NULL;
    m_pSettings->m_rgaae[1].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    m_pSettings->m_rgaae[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
    m_pSettings->m_rgaae[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    m_pSettings->m_rgaae[1].Trustee.ptstrName = (LPTSTR)psidAdministrators;

    m_pSettings->m_rgaae[1].grfAccessMode = SET_ACCESS;
    m_pSettings->m_rgaae[1].grfAccessPermissions  = m_pSettings->m_AccessMaskAdmin;
    m_pSettings->m_rgaae[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

    SetControlStates();

    //
    // Passed all tests, we'll give the option to set ACLS
    //
    m_pSettings->m_fSetAcls = TRUE;

    return CIISWizardPage::OnSetActive();
}



//
// Permissions Wizard Template Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CPWSummary, CIISWizardPage)



CPWSummary::CPWSummary(
    IN CIISSecWizSettings * pSettings
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISSecWizSettings * pSettings      : Settings

Return Value:

    None

--*/
    : CIISWizardPage(
        CPWSummary::IDD,        // Template
        IDS_PERMWIZ,            // Caption
        HEADER_PAGE             // Header
        ),
      m_pSettings(pSettings)
{
    //{{AFX_DATA_INIT(CPWSummary)
    //}}AFX_DATA_INIT

    ASSERT(m_pSettings);
//    ASSERT(!m_pSettings->m_strServer.IsEmpty());
}



CPWSummary::~CPWSummary()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CPWSummary::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CPWSummary)
    DDX_Control(pDX, IDC_LIST_SUMMARY, m_list_Summary);
    //}}AFX_DATA_MAP
}



void
CPWSummary::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CPWSummary, CIISWizardPage)
    //{{AFX_MSG_MAP(CPWSummary)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CPWSummary::GenerateAclSummary()
/*++

Routine Description:

    Break down ACL list into the summary

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Summarize ACL Settings:
    //
    int nIndentLevel = 0;

    if (m_pSettings->m_fSetAcls)
    {
        m_pSettings->m_pist->AddSummaryString(
            m_pSettings->m_fReplaceAcls
                ? IDS_ACL_REPLACEMENT
                : IDS_ACL_ADDED,
            nIndentLevel++
            );

        m_pSettings->m_pist->AddSummaryString(IDS_ACL_ADMIN, nIndentLevel);
        m_pSettings->m_pist->AddSummaryString(IDS_ACL_EVR,   nIndentLevel++);

//        if (m_pSettings->m_AccessMaskEveryone 
//            == m_pSettings->m_AccessMaskDefault)
//        {
//            //
//            // "Everyone" has zero access
//            //
//            m_pSettings->m_pist->AddSummaryString(
//                IDS_SUMMARY_NONE, 
//                nIndentLevel
//                );
//        }
//        else
//        {
            //
            // Enumerate the specific rights granted
            // to "everyone"
            //
            for (int i = 0; i < ARRAY_SIZE(fsAclFlags); ++i)
            {
                if (IS_FLAG_SET(
                    m_pSettings->m_AccessMaskEveryone, 
                    fsAclFlags[i].dwFlag
                    ) == fsAclFlags[i].fSet)
                {
                    m_pSettings->m_pist->AddSummaryString(
                        fsAclFlags[i].nID, 
                        nIndentLevel
                        );
                }
            }
//        }
    }
    else
    {
        m_pSettings->m_pist->AddSummaryString(IDS_ACL_NONE, nIndentLevel);
    }
}




void
CPWSummary::DisplaySummary()
/*++

Routine Description:

    Break down the security settings and display them in text
    form in the summary listbox.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    // Generate Summary
    //
    m_pSettings->m_pist->ClearSummary();

    m_pSettings->m_pist->GenerateSummary(
        m_pSettings->m_fUseTemplate,
        m_pSettings->m_auth,
        m_pSettings->m_strMDPath
        );

    GenerateAclSummary();

    //
    // Display it in the listbox
    //
    m_list_Summary.ResetContent();
    POSITION pos = m_pSettings->m_pist->GetHeadPosition();

    while(pos)
    {
        CString & str = m_pSettings->m_pist->GetNext(pos);
        m_list_Summary.AddString(str);
    }
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CPWSummary::OnSetActive() 
{
    SetControlStates();
    DisplaySummary();
    return CIISWizardPage::OnSetActive();
}



/* virtual */
LRESULT
CPWSummary::OnWizardNext() 
{
    //
    // Store everything here
    //
    CError err(m_pSettings->m_pist->ApplySettings(
        m_pSettings->m_fUseTemplate,
        m_pSettings->m_auth,
        m_pSettings->m_strMDPath
        ));

    //
    // Set the ACLS
    //
    if (err.Succeeded() && m_pSettings->m_fSetAcls)
    {
        err = ApplyACLSToFiles();
    }

    //
    // Store the error for the completion page
    //
    m_pSettings->m_hResult = err;

    return CIISWizardPage::OnWizardNext();
}



HRESULT
CPWSummary::ApplyACLSToFiles()
/*++

Routine Description:

    Apply ACLS to files

Arguments:

    None

Return Value:

    HRESULT

--*/
{
   CError err;
   SECURITY_INFORMATION si = 0;
   SECURITY_DESCRIPTOR * psd = NULL;
   PACL pOldDacl = NULL, pNewDacl = NULL;;


   //
   // Can take a while.
   //
   CWaitCursor waitcursor;
   
   do
   {
      err = GetNamedSecurityInfo(
               (LPTSTR)(LPCTSTR)m_pSettings->m_strPath,
               SE_FILE_OBJECT,
               DACL_SECURITY_INFORMATION,
               NULL,                         // owner SID
               NULL,                         // group SID
               &pOldDacl,                    // pointer to the DACL
               NULL,                         // pointer to the SACL
               (PVOID *)&psd
               );
      BREAK_ON_ERR_FAILURE(err);

      if (!m_pSettings->m_fReplaceAcls)
      {
         m_pSettings->m_rgaae[0].grfAccessMode = GRANT_ACCESS;
         m_pSettings->m_rgaae[1].grfAccessMode = GRANT_ACCESS;
      }
      // Prepare DACL according to template
      err = SetEntriesInAcl(
               ARRAY_SIZE(m_pSettings->m_rgaae),
               m_pSettings->m_rgaae,
               m_pSettings->m_fReplaceAcls ? NULL : pOldDacl,
               &pNewDacl
               );
      BREAK_ON_ERR_FAILURE(err);

      // Set permissions on the selected object
      si |= DACL_SECURITY_INFORMATION;
      si |= PROTECTED_DACL_SECURITY_INFORMATION;
      err = HRESULT_FROM_WIN32(SetNamedSecurityInfo(
                                 (LPTSTR)(LPCTSTR)m_pSettings->m_strPath,
                                 SE_FILE_OBJECT,
                                 si,
                                 NULL,
                                 NULL,
                                 pNewDacl,
                                 NULL));
	   BREAK_ON_ERR_FAILURE(err);
      // For children of this object we should set empty DACL
      // if we need only permissions inherited from parent
      if (PathIsDirectory(m_pSettings->m_strPath))
      {
         if (m_pSettings->m_fReplaceAcls)
         {
            // Build security descriptor with empty DACL
            ACL daclEmpty = {0};
            InitializeAcl(&daclEmpty, sizeof(ACL), ACL_REVISION);
            si = 0;
            si |= DACL_SECURITY_INFORMATION;
            si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
            err = SetPermToChildren(
                m_pSettings->m_strPath,
                si,
                &daclEmpty,
                NULL);
            BREAK_ON_ERR_FAILURE(err);
         }
      }
        // In other cases children should inherit permissions from the parent
    }
    while(FALSE);

    if (pOldDacl != NULL) 
    {
		LocalFree(pOldDacl);
	}
    if (pNewDacl != NULL) 
	{
		LocalFree(pNewDacl);
	}
    if (psd != NULL) 
    {
        LocalFree(psd);
    }
    return err;
}



BOOL 
CPWSummary::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    //
    // Set the tabs based on the hidden column headers
    //
    CRect rc1, rc2;
    ASSERT(NULL != GetDlgItem(IDC_STATIC_TAB2) && NULL != GetDlgItem(IDC_STATIC_TAB1));
    if (NULL != GetDlgItem(IDC_STATIC_TAB2) && NULL != GetDlgItem(IDC_STATIC_TAB1))
    {
       GetDlgItem(IDC_STATIC_TAB2)->GetWindowRect(&rc2);
       GetDlgItem(IDC_STATIC_TAB1)->GetWindowRect(&rc1);
       m_list_Summary.SetTabStops(((LPRECT)rc2)->left - ((LPRECT)rc1)->left);
    }

    return TRUE;  
}



HRESULT 
RunSecurityWizard(
    CComAuthInfo * pauth,
    CMetaInterface * pInterface,
    CString& meta_path,
    UINT nLeftBmpId,
    UINT nHeadBmpId
    )
{
    CError err;

    ASSERT(pInterface != NULL);

    BOOL fAdmin;
    err = DetermineIfAdministrator(
        pInterface, meta_path, &fAdmin);

    if (err.Failed() || !fAdmin)
    {
        AfxMessageBox(IDS_ACL_ADMINS);
        return err;
    }

    CIISWizardSheet sheet(nLeftBmpId, nHeadBmpId);

    CIISSecWizSettings sws(pauth, meta_path);

    CIISWizardBookEnd pgWelcome(IDS_PWIZ_WELCOME, IDS_PERMWIZ, IDS_PWIZ_BODY);
    CPWSource         pgSource(&sws);
    CPWTemplate       pgTemplate(&sws);
    CPWACL            pgACL(&sws);
    CPWSummary        pgSummary(&sws);
    CIISWizardBookEnd pgCompletion(&sws.m_hResult, 
        IDS_PWIZ_SUCCESS, IDS_PWIZ_FAILURE, IDS_PERMWIZ);

    sheet.AddPage(&pgWelcome);
    sheet.AddPage(&pgSource);
    sheet.AddPage(&pgTemplate);
    sheet.AddPage(&pgACL);
    sheet.AddPage(&pgSummary);
    sheet.AddPage(&pgCompletion);

    sheet.DoModal();

    return err;
}


BOOL CheckIfParentHasAccess(CComAuthInfo *pAuthInfo, CString csMetabaseNode)
{
    int iReturn = TRUE;
    CError  err;

    // check if the node is "/LM/W3SVC/1/Root"
    if (TRUE == ConvertToServiceLevelPath(csMetabaseNode))
    {
        // look at this /lm/w3svc node to see if there is access
        // at this node.
        CMetaKey mk1(pAuthInfo,csMetabaseNode);
        err = mk1.QueryResult();
        if (err.Failed())
        {
            // let it inherit by default
            iReturn = TRUE;
            goto CheckIfParentHasAccess_Exit;
        }

        DWORD dwAccessPerms;
        err = mk1.QueryValue(MD_ACCESS_PERM, dwAccessPerms);
        if (err.Succeeded())
        {
            iReturn = TRUE;
        }
        else
        {
            iReturn = FALSE;
        }
        mk1.Close();
    }

CheckIfParentHasAccess_Exit:
    return iReturn;
}


BOOL ConvertToServiceLevelPath(CString &strMetaPath)
/*++
Routine Description:
    Given the path, convert it to the service level path
    e.g. "/LM/W3SVC/1/ROOT" returns "/LM/W3SVC/"
Arguments:
    CString & strMetaPath    : Path to be converted
Return value:
    Pointer to the converted path, or NULL in case of error
--*/
{
    // TRIM Off the last "/" or "\"
    INT iLen = 0;
    BOOL iReturn= 0;

    LPTSTR lpBuffer = NULL;
    LPTSTR pch1 = NULL;
    LPTSTR pch2 = NULL;
    
    iLen = strMetaPath.GetLength();
    lpBuffer = (LPTSTR) LocalAlloc(LMEM_FIXED, (iLen + 1) * sizeof(TCHAR));
    if (!lpBuffer)
    {
        return FALSE;
    }

    _tcscpy(lpBuffer,strMetaPath);

    pch1 = _tcsrchr(lpBuffer, _T('/'));
    if(pch1)
    {
        *pch1 = _T('\0');
    }
    else
    {
        pch1 = _tcsrchr(pch1, _T('\\'));
        if(pch1){*pch1 = _T('\0');}
    }

    pch2 = _tcsrchr(lpBuffer, _T('/'));
    if(pch2){*pch2 = _T('\0');}
    else
    {
        pch2 = _tcsrchr(lpBuffer, _T('\\'));
        if(pch2){*pch2 = _T('\0');}
    }

    strMetaPath = lpBuffer;

    if (lpBuffer){LocalFree(lpBuffer);}
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\rat.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "rat.h"

// Dispatch interfaces referenced by this interface
#include "font.h"

/////////////////////////////////////////////////////////////////////////////
// CRat

IMPLEMENT_DYNCREATE(CRat, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CRat properties

short CRat::GetBorderStyle()
{
    short result;
    GetProperty(DISPID_BORDERSTYLE, VT_I2, (void*)&result);
    return result;
}

void CRat::SetBorderStyle(short propVal)
{
    SetProperty(DISPID_BORDERSTYLE, VT_I2, propVal);
}

BOOL CRat::GetEnabled()
{
    BOOL result;
    GetProperty(DISPID_ENABLED, VT_BOOL, (void*)&result);
    return result;
}

void CRat::SetEnabled(BOOL propVal)
{
    SetProperty(DISPID_ENABLED, VT_BOOL, propVal);
}

COleFont CRat::GetFont()
{
    LPDISPATCH pDispatch;
    GetProperty(DISPID_FONT, VT_DISPATCH, (void*)&pDispatch);
    return COleFont(pDispatch);
}

void CRat::SetFont(LPDISPATCH propVal)
{
    SetProperty(DISPID_FONT, VT_DISPATCH, propVal);
}

CString CRat::GetCaption()
{
    CString result;
    GetProperty(DISPID_CAPTION, VT_BSTR, (void*)&result);
    return result;
}

void CRat::SetCaption(LPCTSTR propVal)
{
    SetProperty(DISPID_CAPTION, VT_BSTR, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// CRat operations

void CRat::SetAdminTarget(LPCTSTR szMachineName, LPCTSTR szMetaTarget)
{
    static BYTE parms[] =
        VTS_BSTR VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         szMachineName, szMetaTarget);
}

void CRat::DoClick()
{
    InvokeHelper(DISPID_DOCLICK, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\scache.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        scache.cpp

   Abstract:

        IIS Server cache

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/



#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "scache.h"




#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW




//
// CIISServerCache implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CIISServerCache::Add(
    IN CIISMachine * pMachine
    ) 
/*++

Routine Description:

    Add server to server cache.

Arguments:

    CIISMachine * pMachine      : Pointer to machine

Return Value:

    TRUE if the machine was added.
    FALSE if it was not (already existed)

Notes:

    The CIISMachine pointer is not owned by the cache.  

--*/
{ 
    BOOL fTossed = FALSE;

    int nSwitch;
    CIISMachine * pCurrent;
    POSITION pos = GetHeadPosition();

    //
    // Find proper insertion point.  Fairly lame linear search,
    // but cache is not expected to contain above a dozen items or so
    // and routine is not called often.
    //
    while(pos)
    {
        pCurrent = (CIISMachine *)GetAt(pos);

        nSwitch = pMachine->CompareScopeItem(pCurrent);

        if (nSwitch < 0)
        {
            InsertBefore(pos, pMachine);
            break;
        }

        if (nSwitch == 0)
        {
            ++fTossed;
            break;
        }

        CPtrList::GetNext(pos);
    }

    if (!pos)
    {
        AddTail(pMachine);
    }

    //
    // Remember to save changes
    //
    if (!fTossed)
    {
        SetDirty();
    }

#ifdef _DEBUG

    //
    // Do a quick sanity check of the cache
    //
    int cLocals = 0;

    CIISMachine * pPrev    = NULL;
    pCurrent = GetFirst();

    while(pCurrent)
    {
        if (pPrev)
        {
            //
            // Make sure the list is sorted
            //
            ASSERT(pCurrent->CompareScopeItem(pPrev) > 0);
        }

        pPrev = pCurrent;
        pCurrent = GetNext();
    }

    //
    // Only one local computer
    //
    ASSERT(cLocals <= 1);

#endif // _DEBUG

    return !fTossed;
}



BOOL 
CIISServerCache::Remove(
    IN CIISMachine * pMachine
    ) 
/*++

Routine Description:

    Remove server from the cache. 

Arguments:

    CIISMachine * pMachine  : Server to be removed

Return Value:

    TRUE for success, FALSE for failure

--*/
{ 
    BOOL fRemoved = FALSE;

    int nSwitch;
    CIISMachine * pCurrent;
    POSITION pos = GetHeadPosition();

    //
    // Look for machine object to be deleted
    //
    // ISSUE: We can currently rely on the actual CIISMachine ptr
    //        to be matched, though we don't take advantage of that
    //        with improved search.
    //
    while(pos)
    {
        pCurrent = (CIISMachine *)GetAt(pos);

        nSwitch = pMachine->CompareScopeItem(pCurrent);

        if (nSwitch < 0)
        {
            //
            // Not in the list -- won't find it either
            //
            ASSERT_MSG("Attempting to remove non-existing machine");
            break;
        }

        if (nSwitch == 0)
        {
            //
            // Found it.  If the ASSERT fires, check the "ISSUE" above
            //
            ASSERT(pCurrent == pMachine);
            RemoveAt(pos);
            ++fRemoved;
            break;
        }

        CPtrList::GetNext(pos);
    }

    //
    // Remember to save changes
    //
    if (fRemoved)
    {
        SetDirty();
    }

    return fRemoved;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inetmgr.rc
//
#define IDI_INETMGR                     1
#define IDI_SHUTDOWN                    2
#define IDB_RDATA_TB                    5
#define IDB_RDATA_MB                    6
#define IDB_RDATA_WB                    7
#define IDB_INETMGR16                   10
#define IDB_INETMGR32                   11
#define IDB_ACCESS                      12
#define IDB_BACKUPS                     22
#define IDR_INETMGR                     30
#define IDB_TOOLBAR                     46
#define IDI_IP_SECURITY                 47
#define IDI_SECURE                      48
#define IDB_BUTTONDND                   49
#define IDB_BUTTONDNF                   50
#define IDB_BUTTONDNU                   51
#define IDB_BUTTONDNX                   52
#define IDB_BUTTONUPD                   53
#define IDB_BUTTONUPF                   54
#define IDB_BUTTONUPU                   55
#define IDB_BUTTONUPX                   56
#define IDD_NEW_USER_PASSWORD           57
#define IDD_APP_POOL_GENERAL            58
#define IDD_APP_POOL_RECYCLE            59
#define IDB_WIZ_WEB_LEFT                60
#define IDB_WIZ_WEB_HEAD                61
#define IDB_SMALL_ROOT                  62
#define IDB_LARGE_ROOT                  63
#define IDS_PROJNAME                    100
#define IDS_INETMGR_DESC                101
#define IDS_INETMGR_PROVIDER            102
#define IDS_ROOT_NODE                   104
#define IDS_LOCAL_COMPUTER              105
#define IDS_SVC_WEB                     106
#define IDS_SVC_FTP                     107
#define IDS_UNKNOWN                     108
#define IDS_APP_NAME                    109
#define IDI_FILE_TYPES                  129
#define IDI_DEFAULT_PROPERTIES          130
#define IDS_CONNECTION_LIMIT            130
#define IDS_WRN_CONNECTION_LIMIT        131
#define IDS_APPLICATION_POOL            132
#define IDS_NO_MACHINE_PROPS            133
#define IDS_CONFIRM_DELETE_ITEMS        134
#define IDS_SUCCESS                     135
#define IDS_RECONNECT_WARNING           136
#define IDS_CONFIRM_DISCONNECT          137
#define IDS_YES                         138
#define IDS_NO                          139
#define IDS_IIS_START                   140
#define IDS_IIS_STOP                    141
#define IDS_IIS_SHUTDOWN                142
#define IDS_IIS_RESTART                 143
#define IDS_IIS_START_DETAILS           144
#define IDS_IIS_STOP_DETAILS            145
#define IDS_IIS_SHUTDOWN_DETAILS        146
#define IDS_IIS_RESTART_DETAILS         147
#define IDS_TCPIP                       148
#define IDS_NETBIOS                     149
#define IDS_BACKUP_LOCATION             150
#define IDS_BACKUP_VERSION              151
#define IDS_BACKUP_DATE                 152
#define IDS_RESTORE_CONFIRM             153
#define IDS_BACKUP_BAD_NAME             154
#define IDS_STARTED                     155
#define IDS_STOPPED                     156
#define IDS_PAUSED                      157
#define IDS_IP_ALL_UNASSIGNED           158
#define IDS_ENTER_PASSWORD              159
#define IDS_SHUTDOWN_PROGRESS           160
#define IDS_RESOLVE_PASSWORD            161
#define IDS_IMPERSONATION_PROMPT        162
#define IDS_IMPERSONATION               163
#define IDS_MENU_REM_IMPERS             164
#define IDS_MENU_TT_REM_IMPERS          165
#define IDS_REMOVE_IMPERSONATION        166
#define IDS_VERSION_FMT                 167
#define IDS_USERS_TOTAL                 180
#define IDS_CONNECTED_USERS             181
#define IDS_FROM                        182
#define IDS_TIME                        183
#define IDS_DISCONNECT_ERR              184
#define IDS_CONFIRM_DISCONNECT_USER     185
#define IDS_CONFIRM_DISCONNECT_ALL      186
#define IDS_FTP_SERVICE_NOT_STARTED     187
#define IDS_WRN_PWSYNC                  188
#define IDS_ERR_COMPRESS_DIRECTORY      189
#define IDS_NO_ACL_WARNING              190
#define IDS_COMPRESS_WARNING            191
#define IDD_TIME_PICKER                 201
#define IDC_TIMESPAN_SPIN               208
#define IDC_REQUESTS_SPIN               209
#define IDC_TIME_PICKER                 212
#define IDB_RDATA_TBT                   256
#define IDS_MENU_CONNECT                300
#define IDS_MENU_DISCOVER               301
#define IDS_MENU_PROPERTIES             302
#define IDS_MENU_START                  303
#define IDS_MENU_STOP                   304
#define IDS_MENU_PAUSE                  305
#define IDS_MENU_IMPERSONATE            306
#define IDS_MENU_EXPLORE                307
#define IDS_MENU_OPEN                   308
#define IDS_MENU_BROWSE                 309
#define IDS_MENU_NEWINSTANCE            310
#define IDS_MENU_NEWVROOT               311
#define IDS_MENU_EX_NEWINSTANCE         312
#define IDS_MENU_TT_IMPERSONATE         313
#define IDS_MENU_TASKPAD                314
#define IDS_MENU_DISCONNECT             315
#define IDS_MENU_SECURITY_WIZARD        316
#define IDS_MENU_BACKUP                 317
#define IDS_MENU_SHUTDOWN_IIS           318
#define IDS_MENU_TT_CONNECT             320
#define IDS_MENU_TT_DISCOVER            321
#define IDS_MENU_TT_PROPERTIES          322
#define IDS_MENU_TT_START               323
#define IDS_MENU_TT_STOP                324
#define IDS_MENU_TT_PAUSE               325
#define IDS_MENU_TT_EXPLORE             327
#define IDS_MENU_TT_OPEN                328
#define IDS_MENU_TT_BROWSE              329
#define IDS_MENU_TT_NEWINSTANCE         330
#define IDS_MENU_TT_NEWVROOT            331
#define IDS_MENU_TT_EX_NEWINSTANCE      332
#define IDS_MENU_TT_DISCONNECT          333
#define IDS_PERM_SUCCESS                334
#define IDS_MENU_TT_BACKUP              335
#define IDS_MENU_TT_TASKPAD             336
#define IDS_MENU_TT_SECURITY_WIZARD     337
#define IDS_MENU_TT_SHUTDOWN_IIS        338
#define IDS_MENU_DS_NEWINSTANCE         339
#define IDS_MENU_DS_NEWVROOT            340
#define IDS_SUMMARY_GRANTED             345
#define IDS_SUMMARY_DENIED              346
#define IDS_SPECIFIC_GRANTED            349
#define IDS_SPECIFIC_DENIED             350
#define IDS_PERMWIZ                     351
#define IDS_NO_TEMPLATES                352
#define IDS_RESULT_COMPUTER_NAME        370
#define IDS_RESULT_COMPUTER_LOCAL       371
#define IDS_RESULT_SERVICE_DESCRIPTION  373
#define IDS_RESULT_SERVICE_DOMAIN_NAME  374
#define IDS_RESULT_SERVICE_IP_ADDRESS   375
#define IDS_RESULT_SERVICE_TCP_PORT     376
#define IDS_RESULT_SERVICE_STATE        377
#define IDS_RESULT_NAME                 378
#define IDS_RESULT_PATH                 379
#define IDS_RESULT_ATTRIBUTES           380
#define IDS_RESULT_STATUS               381
#define IDS_RESULT_COMPUTER_VERSION     382
#define IDS_REPLACE_MIME                383
#define IDS_REMOVE_MIME                 384
#define IDS_TAB_HOME_DIRECTORY          385
#define IDS_TAB_VIRTUAL_DIRECTORY       386
#define IDS_PATH                        387
#define IDS_SHARE                       388
#define IDS_BAD_UNC_PATH                389
#define IDS_ERR_INVALID_PATH            390
#define IDS_ERR_PATH_NOT_FOUND          391
#define IDS_DIRECTORY_MASK              392
#define IDS_UNC_MASK                    393
#define IDS_ACCESS                      394
#define IDS_IP_ADDRESS_SUBNET_MASK      395
#define IDS_DENY                        396
#define IDS_GRANT                       397
#define IDS_PROMPT_NETWORK_ID           398
#define IDS_PROMPT_IP_ADDRESS           399
#define IDS_PROMPT_DOMAIN               400
#define IDS_DOMAIN_PERF                 401
#define IDS_IP_INVALID                  402
#define IDS_INVALID_DOMAIN_NAME         403
#define IDS_DUPLICATE_ENTRY             404
#define IDS_PENDING                     405
#define IDS_ILLEGAL_ALIAS_CHARS         406
#define IDS_DENIED                      407
#define IDS_GRANTED                     408
#define IDS_SUMMARY_NONE                409
#define IDS_PERMISSIONS                 410
#define IDS_PERMS_READ                  411
#define IDS_PERMS_WRITE                 412
#define IDS_PERMS_SCRIPT                413
#define IDS_PERMS_EXECUTE               414
#define IDS_NEW_FTP_VDIR_WIZARD         415
#define IDS_NEW_FTP_SITE_WIZARD         416
#define IDS_SITE_FTP_PERMS_TITLE        417
#define IDS_SITE_FTP_PERMS_SUBTITLE     418
#define IDS_SITE_FTP_SECURITY_TITLE     419
#define IDS_SITE_FTP_SECURITY_SUBTITLE  420
#define IDS_SITE_FTP_WELCOME            421
#define IDS_SITE_FTP_BODY               422
#define IDS_SITE_FTP_SUCCESS            423
#define IDS_TCP_SSL_PART                424
#define IDS_ERR_BINDING                 425
#define IDS_MMM_IP_ADDRESS              426
#define IDS_MMM_TCP_PORT                427
#define IDS_MMM_DOMAIN_NAME             428
#define IDS_MMM_SSL_PORT                429
#define IDS_MMM_NA                      430
#define IDS_DEFAULT                     431
#define IDS_EDIT_MMM_TITLE              432
#define IDS_EDIT_SSL_MMM_TITLE          433
#define IDS_TCP_PORT                    434
#define IDS_SSL_PORT                    435
#define IDS_NO_PORT                     436
#define IDS_ERR_PORT_IN_USE_TCP         437
#define IDS_ERR_PORT_IN_USE_SSL         438
#define IDS_WEB_MASTER                  439
#define IDS_APPROOT_FMT                 440
#define IDS_BUTTON_DISABLE              441
#define IDS_BUTTON_ENABLE               442
#define IDS_BUTTON_CREATE               443
#define IDS_BUTTON_REMOVE               444
#define IDS_TAB_DIR                     445
#define IDS_TAB_FILE                    446
#define IDS_PROMPT_DIR                  447
#define IDS_PROMPT_UNC                  448
#define IDS_PROMPT_REDIRECT             449
#define IDS_BAD_URL_PATH                450
#define IDS_ERR_APP                     451
#define IDS_APPROOT_UNKNOWN             452
#define IDS_REDIRECT_MASK               453
#define IDS_DEF_APP                     454
#define IDS_WRN_WRITE_EXEC              455
#define IDS_WRN_UNLOAD_POOP             456
#define IDS_COMBO_INPROC                457
#define IDS_COMBO_POOLEDPROC            458
#define IDS_COMBO_OUTPROC               459
#define IDS_PERMISSIONS_NONE            460
#define IDS_PERMISSIONS_SCRIPT          461
#define IDS_PERMISSIONS_EXECUTE         462
#define IDS_RADIO_FILE                  463
#define IDS_RADIO_VDIR                  464
#define IDS_RADIO_DIR                   465
#define IDS_TAB_FILE_SECURITY           466
#define IDS_TAB_DIR_SECURITY            467
#define IDS_WRN_DIGEST                  468
#define IDS_WRN_NO_AUTH                 469
#define IDS_OCX_CERTMAP                 470
#define IDS_CTL_LOCAL_ONLY              471
#define IDS_CTL_NEW                     472
#define IDS_CTL_DESCRIPTION             473
#define IDS_CTL_UNNAMED                 474
#define IDS_STATUS                      475
#define IDS_FILTER_NAME                 476
#define IDS_FILTER_EXECUTABLE           477
#define IDS_PRIORITY                    478
#define IDS_HIGH                        479
#define IDS_MEDIUM                      480
#define IDS_LOW                         481
#define IDS_UNKNOWN_PRIORITY            482
#define IDS_DISABLED                    483
#define IDS_LOADED                      484
#define IDS_UNLOADED                    485
#define IDS_NOT_COMMITTED               486
#define IDS_ENABLE                      487
#define IDS_MASTER_FILTERS              488
#define IDS_INSTANCE_FILTERS            489
#define IDS_ERR_BAD_PATH                490
#define IDS_ERR_FILE_NOT_FOUND          491
#define IDS_FILTER_MASK                 492
#define IDS_ERR_DUP_FILTER              493
#define IDS_FILE_PROMPT                 494
#define IDS_URL_PROMPT                  495
#define IDS_NOT_REL_URL                 496
#define IDS_DEFAULT_ERROR               497
#define IDS_FILE                        498
#define IDS_URL                         499
#define IDS_HTTP_ERROR                  500
#define IDS_OUTPUT_TYPE                 501
#define IDS_CONTENTS                    502
#define IDS_BAD_ERROR                   503
#define IDS_NO_DEF_ERRORS               504
#define IDS_ERR_EXPIRE_RANGE            505
#define IDS_ERR_DUP_HEADER              506
#define IDS_MINUTES                     507
#define IDS_DAYS                        508
#define IDS_INSTANCE_DEF_FMT            509
#define IDS_INSTANCE_PORT_FMT           510
#define IDS_APP_POOLS                   511
#define IDS_MENU_NEWFTPSITE             512
#define IDS_MENU_NEWWEBSITE             513
#define IDS_MENU_NEWAPPPOOL             514
#define IDS_MENU_TT_NEWFTPSITE          515
#define IDS_MENU_TT_NEWWEBSITE          516
#define IDS_MENU_TT_NEWAPPPOOL          517
#define IDS_MENU_DS_NEWFTPSITE          518
#define IDS_MENU_DS_NEWWEBSITE          519
#define IDS_MENU_DS_NEWAPPPOOL          520
#define IDS_CONFIRM_DELETE              521
#define IDS_FTP_NEW_SITE_WIZARD         522
#define IDS_FTP_NEW_VDIR_WIZARD         523
#define IDS_FTP_NEW_SITE_WELCOME        524
#define IDS_FTP_NEW_SITE_BODY           525
#define IDS_FTP_NEW_SITE_SUCCESS        526
#define IDS_FTP_NEW_SITE_FAILURE        527
#define IDS_FTP_NEW_SITE_PERMS_TITLE    528
#define IDS_FTP_NEW_SITE_PERMS_SUBTITLE 529
#define IDS_FTP_NEW_SITE_SECURITY_TITLE 530
#define IDS_FTP_NEW_SITE_SECURITY_SUBTITLE 531
#define IDS_MENU_RECYCLE                532
#define IDS_MENU_TT_RECYCLE             533
#define IDS_ASK_TO_RESTART              534
#define IDS_LOCALSYSTEM                 535
#define IDS_LOCALSERVICE                536
#define IDS_NETSERVICE                  537
#define IDS_WEB_NEW_SITE_WIZARD         538
#define IDS_WEB_NEW_VDIR_WIZARD         539
#define IDS_WEB_NEW_SITE_SECURITY_SUBTITLE 540
#define IDS_WEB_NEW_SITE_SECURITY_TITLE 541
#define IDS_WEB_NEW_SITE_PERMS_TITLE    542
#define IDS_WEB_NEW_SITE_PERMS_SUBTITLE 543
#define IDS_EXECUTE_AND_WRITE_WARNING   544
#define IDS_ERR_ALIAS_NOT_UNIQUE        545
#define IDS_WEB_NEW_SITE_WELCOME        546
#define IDS_WEB_NEW_SITE_BODY           547
#define IDS_WEB_NEW_SITE_SUCCESS        548
#define IDS_WEB_NEW_SITE_FAILURE        549
#define IDS_WEB_NEW_VDIR_WELCOME        550
#define IDS_WEB_NEW_VDIR_BODY           551
#define IDS_MENU_NEWFTPVDIR             552
#define IDS_MENU_TT_NEWFTPVDIR          553
#define IDS_MENU_DS_NEWFTPVDIR          554
#define IDS_FTP_NEW_VDIR_WELCOME        555
#define IDS_FTP_NEW_VDIR_BODY           556
#define IDS_FTP_NEW_VDIR_SUCCESS        557
#define IDS_FTP_NEW_VDIR_FAILURE        558
#define IDS_MENU_NEWWEBVDIR             559
#define IDS_MENU_TT_NEWWEBVDIR          560
#define IDS_MENU_DS_NEWWEBVDIR          561
#define IDS_WEB_NEW_VDIR_SUCCESS        562
#define IDS_WEB_NEW_VDIR_FAILURE        563
#define IDS_PWIZ_WELCOME                564
#define IDS_PWIZ_BODY                   565
#define IDS_PWIZ_SUCCESS                566
#define IDS_PWIZ_FAILURE                567
#define IDS_AUTHENTICATION_METHODS      568
#define IDS_AUTHENTICATION_ANONYMOUS    569
#define IDS_AUTHENTICATION_NO_ANONYMOUS 570
#define IDS_AUTHENTICATION_ANONYMOUS_ONLY 571
#define IDS_AUTHENTICATION_BASIC        572
#define IDS_AUTHENTICATION_NT           573
#define IDS_AUTHENTICATION_DIGEST       574
#define IDS_ADDRESS_RESTRICTIONS        575
#define IDS_ACL_ADMINS                  576
#define IDS_ACL_EV_READ                 577
#define IDS_ACL_EV_WRITE                578
#define IDS_ACL_EV_EXEC                 579
#define IDS_ACL_SUMMARY                 580
#define IDS_ACL_NONE                    581
#define IDS_ACL_REPLACEMENT             582
#define IDS_ACL_ADDED                   583
#define IDS_ACL_ADMIN                   584
#define IDS_ACL_EVR                     585
#define IDS_ACL_READ                    586
#define IDS_ACL_READ_CONTROL            587
#define IDS_ACL_READ_ATTRIB             588
#define IDS_ACL_READ_PROP               589
#define IDS_ACL_WRITE                   590
#define IDS_ACL_APPEND                  591
#define IDS_ACL_DELETE                  592
#define IDS_ACL_WRITE_ATTRIB            593
#define IDS_ACL_WRITE_PROP              594
#define IDS_ACL_EXECUTE                 595
#define IDS_ACL_LIST_OBJECT             596
#define IDS_HOURS                       597
#define IDS_WSAHOST_NOT_FOUND           598
#define IDS_DIR_BROWSE_ON               599
#define IDS_DIR_BROWSE_OFF              600
#define IDS_LOAD_DEFAULT_ON             601
#define IDS_LOAD_DEFAULT_OFF            602
#define IDS_DIRECTORY_BROWSE            603
#define IDS_REDIRECT_FORMAT             604
#define IDS_WARNING_DOMAIN_NAME         605
#define IDS_STOPPED_SITE_FMT            606
#define IDS_PAUSED_SITE_FMT             607
#define IDS_HELPFILE                    608
#define IDS_ERR_NONEMPTY_APPPOOL        609
#define IDS_UPGRADE_TO_IIS6             610
#define IDC_EDIT_DESCRIPTION            1001
#define IDC_STATIC_PASSWORD2            1002
#define IDC_EDIT_PASSWORD2              1003
#define IDC_STATIC_PROMPT2              1004
#define IDC_EDIT_MAX_NETWORK_USE        1009
#define IDC_MAX_BANDWIDTH               1009
#define IDC_CHECK_LIMIT_NETWORK_USE     1015
#define IDC_EDIT_PATH                   1015
#define IDC_STATIC_MAX_NETWORK_USE      1016
#define IDC_EDIT_REDIRECT               1016
#define IDC_STATIC_KBS                  1017
#define IDC_BUTTON_ADD_SSL              1018
#define IDC_LIST_ERRORS                 1019
#define IDC_BUTTON_SET_TO_DEFAULT       1020
#define IDS_HTML_MASK                   1022
#define IDS_NO_ACTION                   1023
#define IDS_THROTTLE_BACK               1024
#define IDS_TURN_ON_TRACING             1025
#define IDS_SHUTDOWN                    1026
#define IDC_BUTTON_FILE_TYPES           1031
#define IDC_STATIC_THROTTLE_PROMPT      1038
#define IDS_ERR_DOCUMENTS               1039
#define IDC_STATIC_TAB1                 1046
#define IDS_ERR_COMPLETE_PATH           1047
#define IDC_STATIC_TAB2                 1047
#define IDS_ERR_NO_COMPLETE_PATH        1053
#define IDC_LIST_BACKUPS                1057
#define IDC_BUTTON_CREATE               1058
#define IDC_BUTTON_RESTORE              1059
#define IDC_BUTTON_DELETE               1060
#define IDC_EDIT_BACKUP_NAME            1061
#define IDC_COMBO_RESTART               1062
#define IDC_STATIC_DETAILS              1063
#define IDC_PROGRESS_SHUTDOWN           1064
#define IDC_STATIC_PROGRESS             1065
#define IDS_DUPLICATE_DOC               1066
#define IDC_SERVERNAME                  1066
#define IDS_NOT_LOCAL_FOOTER            1067
#define IDC_RADIO_INHERIT               1067
#define IDC_RADIO_TEMPLATE              1068
#define IDC_BUTTON_EDIT_ANONYMOUS       1068
#define IDC_LIST_TEMPLATES              1069
#define IDC_BUTTON_REMOVE_SSL           1069
#define IDC_RADIO_ACL_MAXIMUM           1070
#define IDC_RADIO_ACL_MINIMUM           1071
#define IDC_RADIO_NO_ACL                1072
#define IDC_LIST_SUMMARY                1073
#define IDC_CHECK_CONNECT_AS            1074
#define IDC_STATIC_USER_NAME            1075
#define IDC_EDIT_USER_NAME              1076
#define IDC_BUTTON_BROWSE               1077
#define IDC_LIST_MIME_TYPES             1078
#define IDC_EDIT_EXTENSION              1079
#define IDC_EDIT_ALIAS                  1079
#define IDC_BUTTON_NEW_TYPE             1080
#define IDC_STATIC_EXTENSION            1081
#define IDC_BASDOM_COMBO                1081
#define IDC_EDIT_CONTENT_TYPE           1082
#define IDC_STATIC_CONTENT_TYPE         1083
#define IDC_BASDOM                      1083
#define IDC_BUTTON_EDIT_MIME            1084
#define IDC_BASDOM_SELECT               1084
#define IDC_BUTTON_REMOVE_MIME          1085
#define IDC_COMPAT_MODE                 1085
#define IDC_REALM                       1085
#define IDC_EDIT_EXTENT                 1086
#define IDC_ENABLE_MB_EDIT              1086
#define IDC_REALM_SELECT                1086
#define IDC_EDIT_MIME                   1087
#define IDC_FRIENDLY_NAME               1087
#define IDC_STATIC_GROUP_MIME_DETAILS   1088
#define IDC_USE_TEMPLATE                1088
#define IDC_TEMPLATE_LIST               1089
#define IDC_USE_CUSTOM                  1090
#define IDC_MEMORY_LIMIT                1091
#define IDC_MEMORY_SPIN                 1092
#define IDC_TEMPLATE_NAME               1093
#define IDC_SAVE_TEMPLATE               1094
#define IDC_PERF_IDLE_TIMEOUT           1095
#define IDC_IDLETIME_SPIN               1096
#define IDC_IDLETIME                    1097
#define IDC_LIMIT_QUEUE                 1098
#define IDC_QUEUESIZE                   1099
#define IDC_QUEUESIZE_SPIN              1100
#define IDC_ENABLE_CPU_ACCOUNTING       1101
#define IDC_CPU_USE                     1102
#define IDC_CPU_USE_SPIN                1103
#define IDC_REFRESHTIME                 1104
#define IDC_REFRESHTIME_SPIN            1105
#define IDC_EXCEED_ACTION               1106
#define IDC_MAXPROCESSES                1107
#define IDC_MAXPROCESSES_SPIN           1108
#define IDC_ENABLE_PING                 1109
#define IDC_PINGINTERVAL                1110
#define IDC_PINGINTERVAL_SPIN           1111
#define IDC_ENABLE_RAPID_FAIL           1112
#define IDC_CRASHES_COUNT               1113
#define IDC_CRASHES_COUNT_SPIN          1114
#define IDC_CHECK_TIME                  1115
#define IDC_CHECK_TIME_SPIN             1116
#define IDC_STARTUP_LIMIT               1117
#define IDC_CHECK_READ                  1118
#define IDC_STARTUP_LIMIT_SPIN          1118
#define IDC_CHECK_WRITE                 1119
#define IDC_SHUTDOWN_LIMIT              1119
#define IDC_CHECK_LOG_ACCESS            1120
#define IDC_SHUTDOWN_LIMIT_SPIN         1120
#define IDC_CHECK_DIRECTORY_BROWSING_ALLOWED 1121
#define IDC_ENABLE_DEBUG                1121
#define IDC_CHECK_INDEX                 1122
#define IDC_FILE_NAME                   1122
#define IDC_CHECK_AUTHOR                1123
#define IDC_BROWSE                      1123
#define IDC_PREDEFINED                  1124
#define IDC_SYSTEM_ACCOUNTS             1125
#define IDC_CONFIGURABLE                1126
#define IDC_USER_NAME                   1127
#define IDC_USER_PASS                   1128
#define IDC_UNINSTALL_PSHED             1129
#define IDC_UNLIMITED_CONN              1130
#define IDC_LIMITED_CONN                1131
#define IDC_CONNECTIONS_COUNT           1132
#define IDC_STATIC_CONN                 1133
#define IDC_CONNECTIONS_COUNT_SPIN      1135
#define IDC_SPIN_MAX_CONNECTIONS        1135
#define IDC_MAX_BANDWIDTH_SPIN          1136
#define IDC_STATIC_CONN_TXT             1137
#define IDC_LOG_UTF8                    1138
#define IDC_EDIT_POOL_NAME              1140
#define IDC_EDIT_POOL_ID                1142
#define IDC_TEMPLATES                   1143
#define IDC_USE_POOL                    1144
#define IDC_POOLS                       1145
#define IDC_STATIC_PSHED_REQUIRED       1146
#define IDC_RADIO_UNLIMITED             1182
#define IDC_RADIO_LIMITED               1183
#define IDC_EDIT_TCP_PORT               1184
#define IDC_EDIT_CONNECTION_TIMEOUT     1185
#define IDC_EDIT_MAX_CONNECTIONS        1186
#define IDC_EDIT_WELCOME                1187
#define IDC_EDIT_EXIT                   1188
#define IDC_EDIT_COMMENT                1189
#define IDC_EDIT_BANNER                 1189
#define IDC_CHECK_ALLOW_ANONYMOUS       1190
#define IDC_CHECK_ONLY_ANYMOUS          1191
#define IDC_STATIC_PW                   1192
#define IDC_RADIO_UNIX                  1193
#define IDC_RADIO_MSDOS                 1194
#define IDC_BUTTON_CURRENT_SESSIONS     1195
#define IDC_BUTTON_REFRESH              1196
#define IDC_LIST_USERS                  1197
#define IDC_BUTTON_DISCONNECT           1198
#define IDC_BUTTON_DISCONNECT_ALL       1199
#define IDC_STATIC_NUM_CONNECTED        1200
#define IDC_BUTTON_BROWSE_USER          1201
#define IDC_CHECK_ENABLE_LOGGING        1202
#define IDC_COMBO_LOG_FORMATS           1203
#define IDC_BUTTON_PROPERTIES           1204
#define IDC_CHECK_ENABLE_PW_SYNCHRONIZATION 1205
#define IDC_STATIC_PATH                 1206
#define IDC_RADIO_DIR                   1207
#define IDC_RADIO_UNC                   1208
#define IDC_STATIC_DESCRIPTION          1209
#define IDC_STATIC_IPADDRESS            1210
#define IDC_STATIC_TCP_PORT             1211
#define IDC_STATIC_ID                   1212
#define IDC_STATIC_DIRLISTING           1213
#define IDC_STATIC_PATH_TYPE            1214
#define IDC_STATIC_OPERATOR_PROMPT1     1215
#define IDC_STATIC_OPERATOR_PROMPT2     1216
#define IDC_STATIC_ACCOUNT_PROMPT       1217
#define IDC_LIST_ADMINISTRATORS         1218
#define IDC_COMBO_IP_ADDRESS            1219
#define IDC_STATIC_CONNECTIONS          1220
#define IDC_BUTTON_EDIT_PATH_TYPE       1221
#define IDC_LOGUICTRL                   1223
#define IDC_STATIC_LOG_PROMPT           1224
#define IDC_COMBO_FTPSITES              1225
#define IDC_APPSCTRL                    1226
#define IDC_EDIT_BASIC_DOMAIN           1227
#define IDC_EDIT_IP_ADDRESS             1228
#define IDD_FTP_SERVICE                 2000
#define IDD_METABACKREST                2001
#define IDD_BACKUP                      2002
#define IDD_SHUTDOWN                    2003
#define IDB_USERS                       2005
#define IDD_FTP_DIRECTORY_SECURITY      2005
#define IDB_ERRORS                      2006
#define IDD_FTP_MESSAGES                2007
#define IDD_DIRECTORY_ERRORS            2008
#define IDD_IIS_MACHINE                 2010
#define IDD_FTP_DIRECTORY_PROPERTIES    2011
#define IDD_SD_PROGRESS                 2014
#define IDD_MIME_PROPERTY               2015
#define IDD_PERMWIZ_SOURCE              2016
#define IDD_PERMWIZ_TEMPLATE            2017
#define IDD_PERMWIZ_ACL                 2018
#define IDD_PERMWIZ_SUMMARY             2019
#define IDB_WIZ_FTP_LEFT                2019
#define IDD_MIME_TYPES                  2020
#define IDB_WIZ_FTP_HEAD                2020
#define IDD_CONNECT_SERVER              2021
#define IDB_WIZ_FTP_LEFT_DIR            2021
#define IDD_USER_SESSIONS               2022
#define IDB_WIZ_FTP_HEAD_DIR            2022
#define IDD_LOGIN                       2023
#define IDD_FTP_DEFAULT_SITE            2024
#define IDB_WIZ_FTP_LEFT_SEC            2024
#define IDD_FTP_ACCOUNTS                2025
#define IDB_WIZ_FTP_HEAD_SEC            2025
#define IDD_SITE_SECURITY               2026
#define IDD_IP_ACCESS                   2027
#define IDD_DNS                         2028
#define IDD_CLEARTEXTWARNING            2029
#define IDD_USER_ACCOUNT                2030
#define IDD_PERFORMANCE                 2031
#define IDD_DIRECTORY_DOCUMENTS         2032
#define IDD_DEFAULT_DOCUMENT            2033
#define IDD_MMM                         2037
#define IDD_BASIC_DOMAIN                2038
#define IDD_EDIT_MMM                    2040
#define IDB_BINDINGS                    2040
#define IDD_NEW_FTP_INST_DESCRIPTION    2041
#define IDD_NEW_FTP_INST_BINDINGS       2042
#define IDD_NEW_FTP_INST_HOME           2043
#define IDD_NEW_FTP_DIR_ALIAS           2044
#define IDD_NEW_FTP_DIR_PATH            2045
#define IDD_NEW_FTP_PERMS               2046
#define IDD_NEW_FTP_USER_PASSWORD       2047
#define IDD_WEB_SERVICE                 2048
#define IDD_ACCOUNTS                    2049
#define IDD_WEB_DIRECTORY_PROPERTIES    2050
#define IDD_DIRECTORY_SECURITY          2051
#define IDD_AUTHENTICATION              2052
#define IDD_IP_SECURITY                 2053
#define IDD_SECURE_COMMUNICATIONS       2054
#define IDD_ANONYMOUS                   2055
#define IDD_FILTERS                     2056
#define IDD_FILTER                      2057
#define IDB_FILTERS                     2058
#define IDD_ERROR_MAPPING               2059
#define IDD_CUSTOM_HEADER               2060
#define IDD_DIRECTORY_HTTP              2061
#define IDD_FTP_NEW_INST_DESCRIPTION    2070
#define IDD_FTP_NEW_INST_BINDINGS       2071
#define IDD_FTP_NEW_DIR_ALIAS           2072
#define IDD_FTP_NEW_USER_PASSWORD       2073
#define IDD_FTP_NEW_PERMS               2074
#define IDD_DEFAULT_SITE                2075
#define IDD_APP_POOL_PERF               2076
#define IDD_APP_POOL_HEALTH             2077
#define IDD_APP_POOL_DEBUG              2078
#define IDD_APP_POOL_IDENT              2079
#define IDD_WEB_NEW_INST_DESCRIPTION    2100
#define IDD_WEB_NEW_DIR_ALIAS           2101
#define IDD_WEB_NEW_PERMS               2102
#define IDD_WEB_NEW_DIR_PATH            2103
#define IDD_WEB_NEW_INST_HOME           2104
#define IDD_WEB_NEW_INST_BINDINGS       2105
#define IDD_WEB_NEW_USER_PASSWORD       2106
#define IDD_PASSWORD                    2200
#define IDC_BACKUP_PASSWORD             2201
#define IDD_ADD_APP_POOL                2201
#define IDC_BACKUP_PASSWORD_CONFIRM     2202
#define IDD_WEB_FILE_PROPERTIES         2202
#define IDC_USE_PASSWORD                2203
#define IDS_PASSWORDS_DOESNT_MATCH      2204
#define IDS_WRONG_PASSWORD              2205
#define IDS_DEBUG_EXEC_MASK             2206
#define IDS_PARENT_PATH_MISSING_PERMISSIONS 2207
#define IDC_CHECK_ENABLE_DEFAULT_DOCUMENT 3031
#define IDC_EDIT_DEFAULT_DOCUMENT       3032
#define IDC_CHECK_ENABLE_DOCUMENT_FOOTER 3033
#define IDC_EDIT_DOCUMENT_FOOTER        3035
#define IDC_EDIT_SSL_PORT               3036
#define IDC_CHECK_CLEAR_TEXT            3051
#define IDC_CHECK_NT_CHALLENGE_RESPONSE 3053
#define IDC_CHECK_UUENCODED             3054
#define IDC_CHECK_ANONYMOUS             3054
#define IDC_STATIC_ANONYMOUS_LOGON      3056
#define IDC_BUTTON_EDIT_SSL             3058
#define IDC_EDIT_DOMAIN_NAME            3074
#define IDC_CHECK_USE_KEEPALIVE         3085
#define IDC_STATIC_ERROR_CODE           3102
#define IDC_COMBO_MESSAGE_TYPE          3103
#define IDC_STATIC_TEXT_FILE_PROMT      3104
#define IDC_EDIT_TEXT_FILE              3105
#define IDC_STATIC_SSL_PORT             3112
#define IDC_BUTTON_ADVANCED             3116
#define IDC_BUTTON_AUTHENTICATION       3121
#define IDC_BUTTON_COMMUNICATIONS       3122
#define IDC_BUTTON_IP_SECURITY          3123
#define IDC_STATIC_AUTHENTICATION       3129
#define IDC_CHECK_SSL_ACCOUNT_MAPPING   3143
#define IDC_CHECK_REQUIRE_SSL           3148
#define IDC_CHECK_REQUIRE_128BIT        3150
#define IDC_SLIDER_PERFORMANCE_TUNING   3156
#define IDC_BUTTON_CONNECT_AS           3171
#define IDC_CERTMAPCTRL1                3174
#define IDC_STATIC_PATH_PROMPT          3182
#define IDC_STATIC_THROTTLING           3184
#define IDC_EDIT_DEF_DOCUMENT           3192
#define IDC_LIST_DEFAULT_DOCUMENT       3203
#define IDC_LIST_MMM                    3206
#define IDC_STATIC_WEB_SITE             3207
#define IDC_LIST_SSL_MMM                3207
#define IDC_BUTTON_DEFAULT              3210
#define IDC_STATIC_SUB_PROMPT           3212
#define IDC_COMBO_IP_ADDRESSES          3213
#define IDC_STATIC_SUB_ERROR_CODE       3214
#define IDC_STATIC_DEF_TEXT             3215
#define IDC_RADIO_REDIRECT              3229
#define IDC_STATIC_DIRFLAGS_LARGE       3320
#define IDC_STATIC_DIRFLAGS_SMALL       3321
#define IDC_CHECK_EXACT                 3400
#define IDC_CHECK_CHILD                 3401
#define IDC_CHECK_PERMANENT             3402
#define IDC_STATIC_REDIRECT_PROMPT      3403
#define IDC_STATIC_REDIRFLAGS           3404
#define IDC_STATIC_APPLICATIONS         3503
#define IDC_STATIC_APP_PROMPT           3504
#define IDC_EDIT_APPLICATION            3505
#define IDC_STATIC_STARTING_POINT       3506
#define IDC_STATIC_SP_PROMPT            3507
#define IDC_COMBO_PROCESS               3508
#define IDC_STATIC_PERMISSIONS          3509
#define IDC_BUTTON_CREATE_REMOVE_APP    3510
#define IDC_BUTTON_UNLOAD_APP           3511
#define IDC_APP_CONFIGURATION           3512
#define IDC_STATIC_APPLICATION_SETTINGS 3513
#define IDC_COMBO_PERMISSIONS           3514
#define IDC_STATIC_PROTECTION           3515
#define IDC_EDIT_PORT                   3809
#define IDC_STATIC_PORT                 3810
#define IDC_STATIC_HEADER_NAME          3811
#define IDC_GROUP_IP                    3813
#define IDC_STATIC_IP                   3814
#define IDC_ICON_IP                     3816
#define IDC_STATIC_SSL_PROMPT           3820
#define IDC_RADIO_NO_CERT               3821
#define IDC_RADIO_ACCEPT_CERT           3822
#define IDC_RADIO_REQUIRE_CERT          3823
#define IDC_GROUP_SSL                   3824
#define IDC_CHECK_ENABLE_CPU_ACCOUNTING 3829
#define IDC_STATIC_CPU_PROMPT           3830
#define IDC_EDIT_CPU                    3831
#define IDC_STATIC_PERCENT              3832
#define IDC_CHECK_LOG_EVENT_ONLY        3833
#define IDC_CHECK_ENFORCE_LIMITS        3833
#define IDC_BUTTON_GET_CERTIFICATES     3848
#define IDC_CHECK_DIGEST                3849
#define IDC_BUTTON_NEW_CTL              3850
#define IDC_CHECK_ENABLE_DS             3851
#define IDC_CHECK_ENABLE_CTL            3853
#define IDC_BUTTON_EDIT_CTL             3855
#define IDC_STATIC_CURRENT_CTL          3857
#define IDC_COMBO_CTL                   3858
#define IDC_CTL_SEPERATOR               3868
#define IDC_GROUP_SECURE                3869
#define IDC_ICON_SECURE                 3873
#define IDC_VIEW_CERTIFICATE            3874
#define IDC_STATIC_WZ_WELCOME           4000
#define IDC_STATIC_WZ_TITLE             4001
#define IDC_STATIC_WZ_SUBTITLE          4002
#define IDC_STATIC_WZ_BODY              4003
#define IDC_STATIC_WZ_CLICK             4004
#define IDC_STATIC_WZ_HEADER_DIVIDER    4005
#define IDC_ED_BOLD1                    4011
#define IDC_ED_BOLD2                    4012
#define IDC_ED_BOLD3                    4013
#define IDC_ED_BOLD4                    4014
#define IDC_ED_BOLD5                    4015
#define IDC_STATIC_COMPRESS_GROUP       5000
#define IDC_CHECK_DYNAMIC_COMPRESSION   5001
#define IDC_CHECK_STATIC_COMPRESSION    5002
#define IDC_STATIC_COMPRESS_DIRECTORY   5003
#define IDC_EDIT_COMPRESS_DIRECTORY     5004
#define IDC_STATIC_MAX_COMPRESS_SIZE    5005
#define IDC_RADIO_COMPRESS_UNLIMITED    5006
#define IDC_RADIO_COMPRESS_LIMITED      5007
#define IDC_EDIT_COMPRESS_DIRECTORY_SIZE 5008
#define IDC_STATIC_COMPRESS_MB          5009
#define IDB_ACLUSERS                    10021
#define IDI_AUTHENTICATION              10050
#define IDI_GRANTED                     10051
#define IDI_DENIED                      10052
#define IDI_RATINGS                     10053
#define IDC_RECYCLE_TIMER               10235
#define IDC_TIMESPAN                    10240
#define IDC_REQUEST_LIMIT               10241
#define IDC_ADD_TIME                    10248
#define IDC_DELETE_TIME                 10249
#define IDC_CHANGE_TIME                 10250
#define IDC_RECYCLE_TIMESPAN            10271
#define IDC_RECYCLE_REQUESTS            10272
#define IDC_TIMES_LIST                  10273
#define IDC_RECYCLE_MEMORY              10274
#define IDC_BUTTON_ADD                  11008
#define IDC_IPA_SUBNET_MASK             11010
#define IDC_STATIC_PASSWORD             11011
#define IDC_BUTTON_EDIT                 11012
#define IDC_BUTTON_REMOVE               11013
#define IDC_LIST_IP_ADDRESSES           11014
#define IDC_RADIO_GRANTED               11018
#define IDC_RADIO_DENIED                11019
#define IDC_RADIO_SINGLE                11020
#define IDC_RADIO_MULTIPLE              11021
#define IDC_STATIC_SUBNET_MASK          11022
#define IDC_STATIC_IP_ADDRESS           11023
#define IDC_IPA_IPADDRESS               11024
#define IDC_BUTTON_DNS                  11025
#define IDC_EDIT_DNS_NAME               11026
#define IDC_STATIC_BY_DEFAULT           11027
#define IDC_STATIC_EXCEPT               11028
#define IDC_ICON_GRANTED                11029
#define IDC_ICON_DENIED                 11030
#define IDC_RADIO_DOMAIN                11033
#define IDC_EDIT_DOMAIN                 11034
#define IDC_EDIT_USERNAME               11052
#define IDC_EDIT_PASSWORD               11053
#define IDC_STATIC_USERNAME             11054
#define IDC_BUTTON_CHECK_PASSWORD       11055
#define IDC_STATIC_USERNAME2            11055
#define IDC_BUTTON_BROWSE_USERS         11056
#define IDC_STATIC_FILTERS              11057
#define IDC_LIST_FILTERS                11058
#define IDC_BUTTON_UP                   11059
#define IDC_BUTTONUP                    11059
#define IDC_BUTTON_DOWN                 11060
#define IDC_BUTTONDN                    11060
#define IDC_BUTTON_DN                   11060
#define IDC_BUTTON_DISABLE              11061
#define IDC_STATIC_FILTER_NAME_PROMPT   11062
#define IDC_STATIC_FILTER_NAME          11063
#define IDC_STATIC_STATUS_PROMPT        11064
#define IDC_STATIC_STATUS               11065
#define IDC_STATIC_EXECUTABLE_PROMPT    11066
#define IDC_STATIC_EXECUTABLE           11067
#define IDC_STATIC_PRIORITY_PROMPT      11068
#define IDC_STATIC_PRIORITY             11069
#define IDC_EDIT_FILTERNAME             11070
#define IDC_EDIT_EXECUTABLE             11071
#define IDC_STATIC_PRIORITY_VALUE       11072
#define IDC_EDIT_HEADER                 11073
#define IDC_EDIT_VALUE                  11074
#define IDC_CHECK_EXPIRATION            11075
#define IDC_STATIC_CONTENT_SHOULD       11076
#define IDC_RADIO_IMMEDIATELY           11077
#define IDC_RADIO_TIME                  11078
#define IDC_RADIO_ABS_TIME              11079
#define IDC_EDIT_EXPIRE                 11080
#define IDC_COMBO_TIME                  11081
#define IDC_DTP_ABS_DATE                11082
#define IDC_DTP_ABS_TIME                11083
#define IDC_LIST_HEADERS                11084
#define IDC_BUTTON_RATINGS_TEMPLATE     11085
#define IDC_BUTTON_RATINGS              11086
#define IDC_CHECK_SCRIPT                11087
#define IDC_CHECK_EXECUTE               11088
#define IDC_CHECK_DIRBROWS              11089

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        66
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1149
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\pwiz.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        pwiz.h

   Abstract:
        IIS Security Wizard

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __IISPWIZ_H__
#define __IISPWIZ_H__

class CBlob;

#define NUM_ACCESS_RECORDS      (2)

typedef CList<DWORD, DWORD>  CDWORDList;                 

//
// Structure to map a flag to a string ID
//
typedef struct tagFLAGTOSTRING
{
    DWORD dwFlag;
    UINT  nID;
    BOOL  fSet;
} FLAGTOSTRING;


class CIISSecurityTemplate : public CMetaProperties
/*++

Class Description:

    Security template info

Public Interface:

    CIISSecurityTemplate        : Constructor

    ApplySettings               : Apply template to destination path
    ClearSummary                : Clear the text summary
    GenerateSummary             : Generate the text summary

--*/
{
public:
    CIISSecurityTemplate(
        CMetaKey * pKey,
        LPCTSTR lpszMDPath,
        BOOL fInherit
        );

public:
    //
    // Apply settings to destination path
    //
    virtual HRESULT ApplySettings(
        BOOL fUseTemplates,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath
        );

    //
    // Build summary strings from security settings.  Clear summary
    // before calling GenerateSummary().
    //
    virtual void GenerateSummary(
        BOOL fUseTemplates,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath
        );
    void ClearSummary() { m_strlSummary.RemoveAll(); }
    POSITION GetHeadPosition() { return m_strlSummary.GetHeadPosition(); }
    CString & GetNext(POSITION & pos) { return m_strlSummary.GetNext(pos); }

    void AddSummaryString(
        LPCTSTR szTextItem,
        int cIndentLevel = 0
        );

    void AddSummaryString(
        UINT nID,
        int cIndentLevel = 0
        );

protected:
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    MP_DWORD m_dwAccessPerms;
    MP_CBlob m_ipl;

protected:
    //
    // The derived class is expected to add its managed properties
    // to this list in its constructor
    //
    CDWORDList m_dlProperties;
    CStringList m_strlSummary;
};

class CFTPSecurityTemplate : public CIISSecurityTemplate
{
public:
    CFTPSecurityTemplate(
        CMetaKey * pKey, LPCTSTR lpszMDPath, BOOL fInherit);

public:
    virtual HRESULT ApplySettings(
        BOOL fUseTemplates,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath
        );
    virtual HRESULT LoadData();
    virtual void GenerateSummary(
        BOOL fUseTemplates,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath
        );
    
protected:
    virtual void ParseFields();

public:
    MP_BOOL m_fAllowAnonymous;
    MP_BOOL m_fAnonymousOnly;
};


class CWebSecurityTemplate : public CIISSecurityTemplate
{
public:
    CWebSecurityTemplate(
        CMetaKey * pKey, LPCTSTR lpszMDPath, BOOL fInherit);

public:
    virtual HRESULT ApplySettings(
        BOOL fUseTemplates,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath
        );
    virtual HRESULT LoadData();
    virtual void GenerateSummary(
        BOOL fUseTemplates,
        CComAuthInfo * pAuthInfo,
        LPCTSTR lpszMDPath
        );

protected:
    virtual void ParseFields();

public:
    MP_DWORD m_dwAuthentication;
    MP_DWORD m_dwDirBrowsing;
};

//
// Launch security wizard
//
HRESULT
RunSecurityWizard(
    CComAuthInfo * pAuthInfo,
    CMetaInterface * pInterface,
    CString& meta_path,
    UINT nLeftBmpId,
    UINT nHeadBmpId
    );

class CIISSecWizSettings : public CObjectPlus
/*++

Class Description:

    Security wizard settings -- passed around from page
    to page.

Public Interface:

    CIISSecWizSettings     : Constructor    

--*/
{
//
// Constructor/Destructor
//
public:
    CIISSecWizSettings(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

    ~CIISSecWizSettings();

public:
    //
    // Fetch the metabase properties from the open key
    // (could be template or another vroot)
    //
    HRESULT FetchProperties(
        IN  CMetaKey & mk,
        IN  LPCTSTR lpszPath = NULL,
        IN  BOOL    fInherit = FALSE
        );

//
// Data Members
//
public:
    BOOL    m_fSetAcls;
    BOOL    m_fReplaceAcls;
    BOOL    m_fRedirected;
    BOOL    m_fUseTemplate;
    DWORD   m_dwInstance;
    DWORD   m_AccessMaskAdmin;
    DWORD   m_AccessMaskEveryone;
    DWORD   m_AccessMaskDefault;
    HRESULT m_hResult;
    CString m_strPath;
    CComAuthInfo * m_auth;
    CString m_strMDPath;
    CIISSecurityTemplate * m_pist;
    EXPLICIT_ACCESS m_rgaae[NUM_ACCESS_RECORDS];
};



//
// Permissions Wizard Source Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CPWSource : public CIISWizardPage
{
    DECLARE_DYNCREATE(CPWSource)

//
// Construction
//
public:
    CPWSource(IN CIISSecWizSettings * pSettings = NULL);
    ~CPWSource();

//
// Dialog Data
//
protected:
    enum { RADIO_INHERITANCE, RADIO_TEMPLATE, };

    //{{AFX_DATA(CPWSource)
    enum { IDD = IDD_PERMWIZ_SOURCE };
    int     m_nSource;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPWSource)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWSource)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();    

private:
    CIISSecWizSettings * m_pSettings;
};



//
// Permissions Wizard Template Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CPWTemplate : public CIISWizardPage
{
    DECLARE_DYNCREATE(CPWTemplate)

//
// Construction
//
public:
    CPWTemplate(IN CIISSecWizSettings * pSettings = NULL);
    ~CPWTemplate();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CPWTemplate)
    enum { IDD = IDD_PERMWIZ_TEMPLATE };
    CListBox    m_list_Templates;
    CEdit       m_edit_Description;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPWTemplate)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWTemplate)
    virtual BOOL OnInitDialog();
    afx_msg void OnSelchangeListTemplates();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();    

private:
    CIISSecWizSettings * m_pSettings;
};



//
// Permissions Wizard ACL Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CPWACL : public CIISWizardPage
{
    DECLARE_DYNCREATE(CPWACL)

//
// Construction
//
public:
    CPWACL(IN CIISSecWizSettings * pSettings = NULL);
    ~CPWACL();

//
// Dialog Data
//
protected:
    enum { RADIO_MAXIMUM, RADIO_MINIMUM, RADIO_NONE, };

    //{{AFX_DATA(CPWACL)
    enum { IDD = IDD_PERMWIZ_ACL };
    CStatic m_static_Line4;
    CStatic m_static_Line3;
    CStatic m_static_Line2;
    CStatic m_static_Line1;
    int     m_nRadioAclType;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPWACL)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWACL)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();    

private:
    CIISSecWizSettings * m_pSettings;
};



//
// Permissions Wizard Summary Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CPWSummary : public CIISWizardPage
{
    DECLARE_DYNCREATE(CPWSummary)

//
// Construction
//
public:
    CPWSummary(IN CIISSecWizSettings * pSettings = NULL);
    ~CPWSummary();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CPWSummary)
    enum { IDD = IDD_PERMWIZ_SUMMARY };
    CListBox    m_list_Summary;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CPWSummary)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CPWSummary)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();    
    void GenerateAclSummary();
    void DisplaySummary();

    HRESULT ApplyACLSToFiles();

    HRESULT
    SetPermToChildren(
	      IN CString& FileName,
	      IN SECURITY_INFORMATION si,
         IN PACL pDacl,
         IN PACL pSacl
	      );

private:
    CIISSecWizSettings * m_pSettings;
};

#endif // __IISPWIZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\seccom.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        authent.cpp

   Abstract:

        WWW Authentication Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
//#include "supdlgs.h"
#include "w3sht.h"
#include "wincrypt.h"
#include "cryptui.h"
#include "certmap.h"
//#include "basdom.h"
#include "anondlg.h"
#include "seccom.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const   LPCTSTR     SZ_CTL_DEFAULT_STORE_NAME = _T("CA");
const   LPCSTR      szOID_IIS_VIRTUAL_SERVER =  "1.3.6.1.4.1.311.30.1";



//
// Needed for GetModuleFileName() below:
//
extern HINSTANCE hInstance;


   
CSecCommDlg::CSecCommDlg(
    IN LPCTSTR lpstrServerName, 
    IN LPCTSTR lpstrMetaPath,
    IN CString & strBasicDomain,
    IN DWORD & dwAuthFlags,
    IN CComAuthInfo * pAuthInfo,
    IN DWORD & dwAccessPermissions,
    IN BOOL    fIsMasterInstance,
    IN BOOL    fSSLSupported,
    IN BOOL    fSSL128Supported,
    IN BOOL    fU2Installed,
    IN CString & strCTLIdentifier,
    IN CString & strCTLStoreName,
    IN BOOL    fEditCTLs,
    IN BOOL    fIsLocal,
    IN CWnd *  pParent                       OPTIONAL
    )
/*++

Routine Description:

    Authentication dialog constructor

Arguments:

    LPCTSTR lpstrServerName             : Server name
    LPCTSTR lpstrMetaPath               : Metabase path
    CString & strBasicDomain            : Basic domain name
    DWORD & dwAuthFlags                 : Authorization flags
    DWORD & dwAccessPermissions         : Access permissions
    BOOL    fIsMasterInstance           : Master instance
    BOOL    fSSLSupported               : TRUE if SSL is supported
    BOOL    fSSL128Supported            : TRUE if 128 bit SSL is supported
    CString & strCTLIdentifier
    CString & strCTLStoreName
    BOOL    fEditCTLs
    BOOL    fIsLocal
    CWnd *  pParent                     : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CSecCommDlg::IDD, pParent),
      m_strServerName(lpstrServerName),
      m_strMetaPath(lpstrMetaPath),
      m_dwAuthFlags(dwAuthFlags),
      m_pAuthInfo(pAuthInfo),
      m_dwAccessPermissions(dwAccessPermissions),
      m_fIsMasterInstance(fIsMasterInstance),
      m_fSSLEnabledOnServer(FALSE),
      m_fSSLInstalledOnServer(FALSE),
      m_fSSL128Supported(fSSL128Supported),
      m_fU2Installed(fU2Installed),
      m_hCTLStore(NULL),
      m_bCTLDirty(FALSE),
      m_iLastUsedCert(-1),
      m_fIsLocal(fIsLocal),
      m_fEditCTLs(fEditCTLs)
{
#if 0 // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CSecCommDlg)
    m_nRadioNoCert = -1;
    m_fAccountMapping = FALSE;
    //m_fEnableDS = FALSE;
    m_fRequireSSL = FALSE;
    m_fEnableCtl = FALSE;
    m_strCtl = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    if (fSSLSupported)
    {
        ::IsSSLEnabledOnServer(
            m_pAuthInfo, 
            m_fSSLInstalledOnServer, 
            m_fSSLEnabledOnServer
            );
    }
    else
    {
        m_fSSLInstalledOnServer = m_fSSLEnabledOnServer = FALSE;
    }

    if (IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_REQUIRE_CERT))
    {
        m_nRadioNoCert = RADIO_REQ_CERT;
    }
    else if (IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_NEGO_CERT))
    {
        m_nRadioNoCert = RADIO_ACCEPT_CERT;
    }
    else
    {
        m_nRadioNoCert = RADIO_NO_CERT;
    }

    m_fRequireSSL = m_fSSLInstalledOnServer
         && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_SSL);

    m_fRequire128BitSSL = m_fSSLInstalledOnServer
        && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_SSL128);

    m_fAccountMapping = m_fSSLInstalledOnServer
        && IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_MAP_CERT);

    //
    // CTL information.
    //
    if (fEditCTLs)
    {
        m_strCTLIdentifier = strCTLIdentifier;
        m_strCTLStoreName = strCTLStoreName;

        if (m_strCTLStoreName.IsEmpty())
        {
            m_strCTLStoreName = SZ_CTL_DEFAULT_STORE_NAME;
        }

        m_strCtl.Empty();
        m_fEnableCtl = !m_strCTLIdentifier.IsEmpty()
            && !strCTLStoreName.IsEmpty();

        //
        // For now, we only allow enabling when editing the local machine
        //
        m_fEnableCtl &= m_fIsLocal;
    }
    else
    {
        m_fEnableCtl = FALSE;
        m_check_EnableCtl.EnableWindow(FALSE);
    }
}



CSecCommDlg::~CSecCommDlg()
/*++

Routine Description:

    custom destructor for CSecCommDlg

Arguments:

    None
Return Value:

    None

--*/
{
    // dereference the CTL context pointers in the combo box
    //CleanUpCTLList();
}



void 
CSecCommDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecCommDlg)
    
    DDX_Radio(pDX, IDC_RADIO_NO_CERT, m_nRadioNoCert);
    DDX_Check(pDX, IDC_CHECK_SSL_ACCOUNT_MAPPING, m_fAccountMapping);
    DDX_Check(pDX, IDC_CHECK_REQUIRE_SSL, m_fRequireSSL);
    DDX_Check(pDX, IDC_CHECK_REQUIRE_128BIT, m_fRequire128BitSSL);
    DDX_Check(pDX, IDC_CHECK_ENABLE_CTL, m_fEnableCtl);
    DDX_CBString(pDX, IDC_COMBO_CTL, m_strCtl);
    DDX_Control(pDX, IDC_CTL_SEPERATOR, m_static_CTLSeparator);
    DDX_Control(pDX, IDC_STATIC_CURRENT_CTL, m_static_CTLPrompt);
    DDX_Control(pDX, IDC_CHECK_SSL_ACCOUNT_MAPPING, m_check_AccountMapping);
    DDX_Control(pDX, IDC_CHECK_REQUIRE_SSL, m_check_RequireSSL);
    DDX_Control(pDX, IDC_CHECK_REQUIRE_128BIT, m_check_Require128BitSSL);
    DDX_Control(pDX, IDC_CHECK_ENABLE_CTL, m_check_EnableCtl);
    DDX_Control(pDX, IDC_BUTTON_EDIT_CTL, m_button_EditCtl);
    DDX_Control(pDX, IDC_BUTTON_NEW_CTL, m_button_NewCtl);
    DDX_Control(pDX, IDC_CERTMAPCTRL1, m_ocx_ClientMappings);
    DDX_Control(pDX, IDC_COMBO_CTL, m_combo_ctl);
    //}}AFX_DATA_MAP

    //
    // Private DDX Controls
    //
    DDX_Control(pDX, IDC_RADIO_REQUIRE_CERT, m_radio_RequireCert);
    DDX_Control(pDX, IDC_RADIO_ACCEPT_CERT, m_radio_AcceptCert);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CSecCommDlg, CDialog)
    //{{AFX_MSG_MAP(CSecCommDlg)
    ON_BN_CLICKED(IDC_CHECK_SSL_ACCOUNT_MAPPING, OnCheckSslAccountMapping)
    ON_BN_CLICKED(IDC_CHECK_REQUIRE_SSL, OnCheckRequireSsl)
    ON_BN_CLICKED(IDC_RADIO_ACCEPT_CERT, OnRadioAcceptCert)
    ON_BN_CLICKED(IDC_RADIO_NO_CERT, OnRadioNoCert)
    ON_BN_CLICKED(IDC_RADIO_REQUIRE_CERT, OnRadioRequireCert)
    ON_BN_CLICKED(IDC_BUTTON_EDIT_CTL, OnButtonEditCtl)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_CTL, OnCheckEnableCtl)
    ON_BN_CLICKED(IDC_BUTTON_NEW_CTL, OnButtonNewCtl)
    ON_CBN_SELCHANGE(IDC_COMBO_CTL, OnSelchangeComboCtl)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CSecCommDlg::SetControlStates()
/*++

Routine Description:

    Set control states depending on current data in the dialog

Arguments:

    None

Return Value:

    None

--*/
{
    m_check_RequireSSL.EnableWindow(m_fSSLEnabledOnServer);
    m_check_Require128BitSSL.EnableWindow(
        m_fSSLEnabledOnServer 
     && m_fSSL128Supported 
     && m_fRequireSSL
        );

    m_ocx_ClientMappings.EnableWindow(
        m_fAccountMapping 
     && !m_fU2Installed
     && !m_fIsMasterInstance
        );

    m_radio_RequireCert.EnableWindow(m_fRequireSSL);

    //
    // Special case: if "require SSL" is off, but "require 
    // client certificates" is on, change the latter to "accept 
    // client certificates"
    //
    if (m_radio_RequireCert.GetCheck() > 0 && !m_fRequireSSL)
    {
        m_radio_RequireCert.SetCheck(0);
        m_radio_AcceptCert.SetCheck(1);
        m_nRadioNoCert = RADIO_ACCEPT_CERT;
    }

    if (m_fEditCTLs)
    {
        m_static_CTLPrompt.EnableWindow(m_fEnableCtl);
        m_combo_ctl.EnableWindow(m_fEnableCtl);
        m_button_EditCtl.EnableWindow(m_fEnableCtl);
        m_button_NewCtl.EnableWindow(m_fEnableCtl);
        m_ocx_CertificateAuthorities.EnableWindow(m_fEnableCtl);

        //
        // If enable Ctl is on, but nothing is selected, disable Edit
        //
        if (m_fEnableCtl)
        {
            if (m_combo_ctl.GetCurSel() == CB_ERR)
            {
                m_button_EditCtl.EnableWindow(FALSE);
            }
        }
    }
    else
    {
        m_fEnableCtl = FALSE;

        //
        // Hide the controls
        //
        DeActivateControl(m_static_CTLPrompt);
        DeActivateControl(m_combo_ctl);
        DeActivateControl(m_button_EditCtl);
        DeActivateControl(m_button_NewCtl);
        DeActivateControl(m_ocx_CertificateAuthorities);
        DeActivateControl(m_check_EnableCtl);
        DeActivateControl(m_static_CTLSeparator);
    }

}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CSecCommDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Initialize certificate authorities ocx
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_CertificateAuthorities.Create(
        _T("CertWiz"),
        WS_BORDER,
        rc,
        this,
        IDC_APPSCTRL
        );

    CString strCaption;
    VERIFY(strCaption.LoadString(IDS_OCX_CERTMAP));

    m_ocx_ClientMappings.SetCaption(strCaption);
    m_ocx_ClientMappings.SetServerInstance(m_strMetaPath);
    m_ocx_ClientMappings.SetMachineName(m_strServerName);

    //
    // Initialize the CTL list data
    //
    InitializeCTLList();

    SetControlStates();

    return TRUE;  
}



void 
CSecCommDlg::OnCheckSslAccountMapping()
/*++

Routine Description:

    SSL Account mapping checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fAccountMapping = !m_fAccountMapping;
    SetControlStates();
}



void 
CSecCommDlg::OnOK()
/*++

Routine Description:

    OK button handler, save information

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        SET_FLAG_IF(m_fAccountMapping, m_dwAccessPermissions, MD_ACCESS_MAP_CERT);
        SET_FLAG_IF(m_fRequireSSL, m_dwAccessPermissions, MD_ACCESS_SSL);
        SET_FLAG_IF(m_fRequire128BitSSL, m_dwAccessPermissions, MD_ACCESS_SSL128);
        RESET_FLAG(m_dwAccessPermissions, 
            (MD_ACCESS_REQUIRE_CERT | MD_ACCESS_NEGO_CERT));

        switch(m_nRadioNoCert)
        {
        case RADIO_REQ_CERT:
            SET_FLAG(m_dwAccessPermissions, 
                (MD_ACCESS_REQUIRE_CERT | MD_ACCESS_NEGO_CERT));
            break;

        case RADIO_ACCEPT_CERT:
            SET_FLAG(m_dwAccessPermissions, MD_ACCESS_NEGO_CERT);
            break;
        }

        //
        // Provide warning if no authentication is selected
        //
        if (!m_dwAuthFlags && !m_dwAccessPermissions 
         && !NoYesMessageBox(IDS_WRN_NO_AUTH))
        {
            //
            // Don't dismiss the dialog
            //
            return;
        }

        //
        // If CTL stuff has changed, update the strings
        //
        if (m_bCTLDirty)
        {
            //
            // Get the index of the selected item
            //
            INT iSel = m_combo_ctl.GetCurSel();

            //
            // If nothing is selected, then clear out the strings
            //
            if (!m_fEnableCtl || (iSel == CB_ERR))
            {
                m_strCTLIdentifier.Empty();
                m_strCTLStoreName.Empty();
            }
            else
            {
                //
                // There is one selected. Update the Identifier string
                // first get the context itself
                //
                PCCTL_CONTEXT pCTL =
                    (PCCTL_CONTEXT)m_combo_ctl.GetItemData(iSel);

                if (pCTL != NULL)
                {
                    //
                    // Now get the list identifier for it and put it in
                    // the string the list identifier is a inherint value
                    // of the context and doesn't need to be read in seperately.
                    // We can just reference it.
                    //
                    m_strCTLIdentifier.Empty();

                    if (pCTL->pCtlInfo
                     && pCTL->pCtlInfo->ListIdentifier.cbData >= 2
                     && pCTL->pCtlInfo->ListIdentifier.cbData)
                    {
                        //
                        // If the identifiers are the same, then this is
                        // our default CTL
                        //
//                      m_strCTLIdentifier =
//                          (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData;

                        wcsncpy(m_strCTLIdentifier.GetBuffer(
                                pCTL->pCtlInfo->ListIdentifier.cbData + 2),
                                (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData,
                                pCTL->pCtlInfo->ListIdentifier.cbData
                                );

                        m_strCTLIdentifier.ReleaseBuffer();
                    }
                }
                else
                {
                    m_strCTLIdentifier.Empty();
                    m_strCTLStoreName.Empty();
                }
            }
        }

        CDialog::OnOK();
    }
}



void 
CSecCommDlg::OnCheckRequireSsl() 
/*++

Routine Description:

    'require ssl' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fRequireSSL = !m_fRequireSSL;
    SetControlStates();
}



void 
CSecCommDlg::OnRadioNoCert() 
/*++

Routine Description:

    'Do not accept certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_NO_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnRadioAcceptCert() 
/*++

Routine Description:

    'accept certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_ACCEPT_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnRadioRequireCert() 
/*++

Routine Description:

    'require certificates' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nRadioNoCert = RADIO_REQ_CERT;
    SetControlStates(); 
}



void 
CSecCommDlg::OnCheckEnableCtl() 
/*++

Routine Description:

    'Enable CTL' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Since this is local only, if we are remote and the user checks the
    // box, then we should alert them to the situation and then do nothing.
    //
    if (!m_fIsLocal)
    {
        AfxMessageBox(IDS_CTL_LOCAL_ONLY);

        return;
    }


    m_fEnableCtl = !m_fEnableCtl;

    //
    // If we are now disabling, record the current cert and then blank it
    //
    if (!m_fEnableCtl)
    {
        m_iLastUsedCert = m_combo_ctl.GetCurSel();
        m_combo_ctl.SetCurSel(-1);
    }
    else
    {
        //
        // We are enabling, use the last recorded cert
        //
        m_combo_ctl.SetCurSel(m_iLastUsedCert);
    }

    m_bCTLDirty = TRUE;
    SetControlStates();
}



void 
CSecCommDlg::OnButtonEditCtl() 
/*++

Routine Description:

    "Edit CTL" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Get the index of the selected item
    //
    INT iSel = m_combo_ctl.GetCurSel();
    ASSERT( iSel != CB_ERR );

    //
    // Get the selected CTL context
    //
    PCCTL_CONTEXT   pCTL = (PCCTL_CONTEXT)m_combo_ctl.GetItemData(iSel);

    //
    // Pass in the selected CTL context to edit it
    //
    PCCTL_CONTEXT pCTLNew = CallCTLWizard( pCTL );

    //
    // If the CTL on the item has changed, then update the private data item
    //
    if (pCTLNew && pCTLNew != pCTL)
    {
        //
        // start be deleting the current item from the list
        //
        m_combo_ctl.DeleteString(iSel);

        //
        // free the old context
        //
        CertFreeCTLContext(pCTL);

        //
        // now add the new one and select it.
        //
        AddCTLToList(pCTLNew, TRUE);
        SetControlStates();

        //
        // set the dirty flag
        //
        m_bCTLDirty = TRUE;
    }
}



void
CSecCommDlg::OnButtonNewCtl() 
/*++

Routine Description:

    "New CTL" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Pass in NULL to create a new CTL
    //
    PCCTL_CONTEXT   pCTL = CallCTLWizard(NULL);

    //
    // If a CTL was created, add it to the list and select it.
    //
    if (pCTL != NULL)
    {
        AddCTLToList(pCTL, TRUE);
        SetControlStates();
        m_bCTLDirty = TRUE;
    }
}



PCCTL_CONTEXT
CSecCommDlg::CallCTLWizard( 
    IN PCCTL_CONTEXT pCTLSrc 
    )
/*++

Routine Description:

    Adds a CTL to the drop down CTL list. Note that the context pointers are
    set as the private data on the list items. This means that they will need
    to be de-referenced when this object is destroyed. See the 
    routine CleanUpCTLList.

    This routine by boydm

Arguments:

    PCCTL_CONTEXT pctl ctl context pointer of the ctl being added
    BOOL fSelect       flag specifying if this ctl should be selected after it
                       is added

Return Value:

    returns TRUE if successful

--*/
{
    PCCTL_CONTEXT       pCTLOut = NULL;

    CRYPTUI_WIZ_BUILDCTL_NEW_CTL_INFO   newInfo;
    CTL_USAGE           useInfo;
    CString             szFriendly;
    CString             szDescription;
    CString             szListIdentifier;
    LPOLESTR            pszListIdentifier = NULL;
    LPCSTR              rgbpszUsageArray[2];

    //
    // Prepare the main src structure
    //
    CRYPTUI_WIZ_BUILDCTL_SRC_INFO   srcInfo;
    ZeroMemory( &srcInfo, sizeof(srcInfo) );
    srcInfo.dwSize = sizeof(srcInfo);

    //
    // If we are editing an existing CTL then we do one thing
    //
    if ( pCTLSrc )
    {
        srcInfo.dwSourceChoice = CRYPTUI_WIZ_BUILDCTL_SRC_EXISTING_CTL;
        srcInfo.pCTLContext = pCTLSrc;
    }
    else
    {
        //
        // Prepare the usage arrays
        //
        ZeroMemory( &rgbpszUsageArray, sizeof(rgbpszUsageArray) );
        rgbpszUsageArray[0] = szOID_IIS_VIRTUAL_SERVER;

        //
        // Must also have client auth - or else no certs show up in the list!
        //
        rgbpszUsageArray[1] = szOID_PKIX_KP_CLIENT_AUTH;
        ZeroMemory( &useInfo, sizeof(useInfo) );
        useInfo.cUsageIdentifier = 2;
        useInfo.rgpszUsageIdentifier = (PCHAR*)&rgbpszUsageArray;

        //
        // Prep the new ctl structure, which may or may not get used
        //
        ZeroMemory( &newInfo, sizeof(newInfo) );

        //
        // We making a new CTL, fill in the rest of the stuff
        //
        srcInfo.dwSourceChoice = CRYPTUI_WIZ_BUILDCTL_SRC_NEW_CTL;
        srcInfo.pNewCTLInfo = &newInfo;

        //
        // Load the friendly name and the description
        //
        szFriendly.LoadString(IDS_CTL_NEW);
        szDescription.LoadString(IDS_CTL_DESCRIPTION);

        //
        // Create a guid string for the identifier
        //
        GUID id;
        HRESULT hres = CoCreateGuid(&id);
        hres = StringFromGUID2(id, szListIdentifier.GetBuffer(1000), 1000);
        szListIdentifier.ReleaseBuffer();

        //
        // Fill in the newInfo structure
        //
        newInfo.dwSize = sizeof(newInfo);

        //
        // For now - don't set the usage
        //
        newInfo.pSubjectUsage = &useInfo;

        //
        // Put the generated list identifier into place
        //
        newInfo.pwszListIdentifier = (LPTSTR)(LPCTSTR)szListIdentifier;

        //
        // Fill in the friendly strings that were loaded from the resources
        //
        newInfo.pwszFriendlyName = (LPTSTR)(LPCTSTR)szFriendly;
        newInfo.pwszDescription = (LPTSTR)(LPCTSTR)szDescription;
    }

    //
    // Make the call to the CTL wizard
    //
    if (!CryptUIWizBuildCTL(
            CRYPTUI_WIZ_BUILDCTL_SKIP_SIGNING |
            CRYPTUI_WIZ_BUILDCTL_SKIP_PURPOSE |
            CRYPTUI_WIZ_BUILDCTL_SKIP_DESTINATION,
            m_hWnd,         
            NULL,    
            &srcInfo,
            NULL,     
            &pCTLOut
            ))
    {
        //
        // The user canceled the CTL wizard or it failed in general.
        // the CTL wizard puts up its own error dialogs
        //
        return NULL;
    }

/*
    // get the friendly name from the CTL that comes out of the wizard.
    // the process of signing this CTL does not transfer the friendly
    // name to the resulting new CTL. Oh well.
    DWORD       cbProperty;
    CertGetCTLContextProperty(
        IN pCTLOut,
        IN CERT_FRIENDLY_NAME_PROP_ID,
        OUT NULL,
        IN OUT &cbProperty
        );
    // increase buffer just to cover any nulls just to be safe
    cbProperty += 2;
    // get the friendly name
    CertGetCTLContextProperty(
        IN pCTLOut,
        IN CERT_FRIENDLY_NAME_PROP_ID,
        OUT szFriendly.GetBuffer(cbProperty),
        IN OUT &cbProperty
        );
    szFriendly.ReleaseBuffer();

    // get the description from the CTL that comes out of the wizard.
    // the process of signing this CTL does not transfer the friendly
    // name to the resulting new CTL. Oh well.
    CertGetCTLContextProperty(
        IN pCTLOut,
        IN CERT_DESCRIPTION_PROP_ID,
        OUT NULL,
        IN OUT &cbProperty
        );
    // increase buffer just to cover any nulls just to be safe
    cbProperty += 2;
    // get the friendly name
    CertGetCTLContextProperty(
        IN pCTLOut,
        IN CERT_DESCRIPTION_PROP_ID,
        OUT szDescription.GetBuffer(cbProperty),
        IN OUT &cbProperty
        );
    szDescription.ReleaseBuffer();


    // prepare the signer information
    CMSG_SIGNER_ENCODE_INFO     infoSigner;
    ZeroMemory( &infoSigner, sizeof(infoSigner) );
    infoSigner.cbSize = sizeof(infoSigner);
    infoSigner.pCertInfo = m_pServerCert->pCertInfo;

    
//    infoSigner.HashAlgorithm.pszObjId = szOID_RSA_SHA1RSA;


//CERT_CONTEXT

    // prepare the signing cert information
    CERT_BLOB                   infoSigningCert;
    infoSigningCert.cbData = m_pServerCert->cbCertEncoded;
    infoSigningCert.pbData = m_pServerCert->pbCertEncoded;

    // prepare the signed information
    CMSG_SIGNED_ENCODE_INFO     infoSigned;
    ZeroMemory( &infoSigned, sizeof(infoSigned) );
    infoSigned.cbSize = sizeof(infoSigned);
//    infoSigned.cSigners = 1;
//    infoSigned.rgSigners = &infoSigner;
    infoSigned.cCertEncoded = 1;
    infoSigned.rgCertEncoded = &infoSigningCert;

    // find out how much space we need for the encoded signed message
    DWORD       cbEncodedCTLMessage;
    PBYTE       pbyteEncodedMessage = NULL;
    // make the call to get the space requirement
    
    BOOL f = CryptMsgSignCTL(
        IN CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        IN pCTLOut->pbCtlContent,
        IN pCTLOut->cbCtlContent,
        IN &infoSigned,
        IN 0,
        OUT NULL,
        IN OUT &cbEncodedCTLMessage
        );

    if ( f )
        {
        // allocate the buffer for the message
        pbyteEncodedMessage = (PBYTE)GlobalAlloc( GPTR, cbEncodedCTLMessage );
        if ( !pbyteEncodedMessage )
            {
            f = FALSE;
            }
        else
            {
            // make the real call and get the message
            f = CryptMsgSignCTL(
                IN CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                IN pCTLOut->pbCtlContent,
                IN pCTLOut->cbCtlContent,
                IN &infoSigned,
                IN 0,
                OUT pbyteEncodedMessage,
                IN OUT &cbEncodedCTLMessage
                );
            }
        }
    
    // at this point we are done with the CTL returned by the wizard
    CertFreeCTLContext( pCTLOut );
    pCTLOut = NULL;

    // If the signing failed, ask the user if that want to proceed anyway
    if ( !f && AfxMessageBox( IDS_CTL_SIGN_FAIL, MB_YESNO ) == IDNO )
        {
        CertFreeCTLContext( pCTLOut );
        if ( pbyteEncodedMessage )
            {
            GlobalFree( pbyteEncodedMessage );
            }
        return NULL;
        }

    // add the encoded and signed CTL to the Cert store.
    if ( CertAddEncodedCTLToStore(
            IN m_hCTLStore,
            IN CRYPT_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            IN pbyteEncodedMessage,
            IN cbEncodedCTLMessage,
            IN CERT_STORE_ADD_REPLACE_EXISTING,
            OUT &pCTLOut
            ) )
        {
*/
  /*
        // replace the friendly name and description that just got lost
        CertSetCTLContextProperty(
            IN pCTLOut,
            IN CERT_FRIENDLY_NAME_PROP_ID,
            IN 0,
            IN (LPCTSTR)szFriendly
            );
        CertSetCTLContextProperty(
            IN pCTLOut,
            IN CERT_DESCRIPTION_PROP_ID,
            IN 0,
            IN (LPCTSTR)szDescription
            );
*/
/*
        }
    else
        {
        // we failed to write it out to the store.
        AfxMessageBox( IDS_CTL_WRITE_FAIL );
        }


    // cleanup
    if ( pbyteEncodedMessage )
        {
        GlobalFree( pbyteEncodedMessage );
        }
*/
    
    //
    // Add the certificate context to the store
    //
    if (pCTLOut != NULL)
    {
        PCCTL_CONTEXT pCTLAdded = NULL;

        if (CertAddCTLContextToStore(
            m_hCTLStore,
            pCTLOut,
            CERT_STORE_ADD_REPLACE_EXISTING,
            &pCTLAdded
            ))
        {
            CertFreeCTLContext( pCTLOut );
            pCTLOut = pCTLAdded;
        }
        else
        {
            CertFreeCTLContext( pCTLOut );
            pCTLOut = NULL;
        }
    }

    return pCTLOut;
}



BOOL
CSecCommDlg::AddCTLToList(
    IN PCCTL_CONTEXT pCTL,
    IN BOOL fSelect
    )
/*++

Routine Description:

    Adds a CTL to the drop down CTL list. Note that the context pointers are
    set as the private data on the list items. This means that they will need
    to be de-referenced when this object is destroyed. See the 
    routine CleanUpCTLList.

    This routine by boydm

Arguments:

    PCCTL_CONTEXT pctl ctl context pointer of the ctl being added
    BOOL fSelect -     flag specifying if this ctl should be selected after it 
                       is added

Return Value:

    returns TRUE if successful

--*/
{
    BOOL fSuccess;

    ASSERT(pCTL != NULL);

    if (!pCTL)
    {
        return FALSE;
    }

    //
    // First, we extract the friendly name from the CTL.
    //
    CString     szFriendlyName;     // the friendly name
    DWORD       cbName = 0;         // count of BYTES for the name, not chars

    //
    // Find out how much space we need
    //
    fSuccess = CertGetCTLContextProperty(
        pCTL,
        CERT_FRIENDLY_NAME_PROP_ID,
        NULL,
        &cbName
        );

    //
    // Increase buffer just to cover any nulls just to be safe
    //
    cbName += 2;

    //
    // Get the friendly name
    //
    fSuccess = CertGetCTLContextProperty(
        pCTL,
        CERT_FRIENDLY_NAME_PROP_ID,
        szFriendlyName.GetBuffer(cbName),
        &cbName
        );

    szFriendlyName.ReleaseBuffer();

    //
    // If we did not get the name, then load the default name.
    // The friendly name is an optional parameter in the CTL so it
    // is OK if it is not there.
    //
    if (!fSuccess)
    {
        szFriendlyName.LoadString(IDS_CTL_UNNAMED);
    }

    //
    // Add the friendly name string to the drop down CTL list and record
    // the index of the newly created item
    //
    INT iCTLPosition = m_combo_ctl.AddString(szFriendlyName);

    //
    // If it worked, then add the context pointer to the item as private data
    //
    if (iCTLPosition >=0)
    {
        m_combo_ctl.SetItemData(iCTLPosition, (ULONG_PTR)pCTL);

        //
        // if we have been told to select the CTL, do so at this point
        //
        if (fSelect)
        {
            m_combo_ctl.SetCurSel(iCTLPosition);
        }
    }
    
    //
    // Return TRUE if we successfully added the CTL
    //
    return (iCTLPosition >=0);
}



void
CSecCommDlg::InitializeCTLList() 
/*++

Routine Description:

    Initializes the CTL drop down box by opening the CTL store pointer
    to the target store and filling in the CTL list box with the enumerated
    values.

    This routine by boydm

Arguments:

    None

Return Value:
    None

--*/
{
    //
    // For now this is Local ONLY
    //
    if (!m_fIsLocal)
    {
        return;
    }

    //
    // Build the remote name for the store.
    // It takes the form of "\\MACHINE_NAME\STORENAME"
    // The store name is always "MY" and is define above. The machine
    // name is the name of the machine being edited. The leading \\ in the
    // machine name is optional so we will skip it in this case
    //
    CString szStore;
    
    //
    // Start by adding the machine name that we are targeting
    //
    szStore = m_strServerName;

    //
    // Add the specific store name
    //
    szStore += _T('\\');
    szStore += m_strCTLStoreName;

    //
    // BUGBUG just use MY for now
    //
    szStore = m_strCTLStoreName;

    //
    // Open the store
    //
    m_hCTLStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
        0,
        NULL,
        CERT_SYSTEM_STORE_LOCAL_MACHINE,
        szStore 
        );

    //
    // If we failed to open the store, then we will be unable to do anything
    // with CTLs on this machine at all. Disable everything having to do
    // with the CTL controls.
    //
    if (!m_hCTLStore)
    {
        m_fEnableCtl = FALSE;

        //
        // Return early as we have no need to enumerate the CTLs
        //
        return;
    }

    //
    // Enumerate all the CTLs in the store and add them to the drop-down list
    //
    PCCTL_CONTEXT   pCTLEnum = NULL;

    //
    // Enumerate undil NULL is returned. Note that CertEnumCTLsInStore
    // free the context passed into pCTLEnum if it is non NULL. Thus we
    // need to create a duplicate of it to add to the drop-list
    //
    while (pCTLEnum = CertEnumCTLsInStore(m_hCTLStore, pCTLEnum))
    {
        //
        // Make a duplicate of the CTL context for storing in thte list
        //
        PCCTL_CONTEXT pCTL = CertDuplicateCTLContext(pCTLEnum);

        if (!pCTL)
        {
            //
            // Duplication Failed
            //
            continue;
        }

        //
        // The list identifier is a inherint value of the context and doesn't
        // need to be read in separately. We can just referenece it
        //
        BOOL fIsCurrentCTL = FALSE;

        if (pCTL->pCtlInfo
         && pCTL->pCtlInfo->ListIdentifier.cbData >= 2 
         && pCTL->pCtlInfo->ListIdentifier.cbData)
        {
            //
            // If the identifiers are the same, then this is our default CTL
            //
            fIsCurrentCTL = (wcsncmp( 
                (LPCTSTR)m_strCTLIdentifier,
                (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData,
                pCTL->pCtlInfo->ListIdentifier.cbData 
                ) == 0);
                
            // fIsCurrentCTL = ( m_strCTLIdentifier == (PWCHAR)pCTL->pCtlInfo->ListIdentifier.pbData );
        }

        //
        // Add the CTL to the list
        //
        AddCTLToList(pCTL, fIsCurrentCTL);
    }
}



void
CSecCommDlg::CleanUpCTLList() 
/*++

Routine Description:

    Dereferences all the CTL context pointers in the private data of
    the items in the CTL combo box.
    Then it closes the CTL store handle

    This routine by boydm

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD cItems = m_combo_ctl.GetCount();

    //
    // Loop through each item and free its reference to the CTL pointer
    //
    for (DWORD i = 0; i < cItems; ++i)
    {
        //
        // Get the CTL context pointer from the item's private data
        //
        PCCTL_CONTEXT pCTL = (PCCTL_CONTEXT)m_combo_ctl.GetItemData(i);

        if (pCTL)
        {
            CertFreeCTLContext(pCTL);
        }
    }

    //
    // Close the handle to the store that contains the CTLs
    //
    if (m_hCTLStore)
    {
        CertCloseStore( m_hCTLStore, CERT_CLOSE_STORE_FORCE_FLAG );
        m_hCTLStore = NULL;
    }
}



void
CSecCommDlg::OnSelchangeComboCtl() 
/*++

Routine Description:

    The selection in the drop-down list changed

    This routine by boydm

  Arguments:

    None

Return Value:
    None

--*/
{
    SetControlStates();
    m_bCTLDirty = TRUE;
}



void 
CSecCommDlg::OnDestroy() 
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CDialog::OnDestroy();
    
    CleanUpCTLList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\scache.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        scache.h

   Abstract:

        IIS Server cache definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __SCACHE_H__
#define __SCACHE_H__



class CIISMachine;



class CIISServerCache : public CPtrList
/*++

Class Description:

    Server cache.  Server cache will be maintained in sorted order.

Public Interface:

    CIISServerCache     : Constructor
    ~CIISServerCache    : Destructor

    IsDirty             : TRUE if the cache is dirty
    SetDirty            : Set the dirty bit
    Add                 : Add machine object to cache
    Remove              : Remove machine object from cache
    GetFirst            : Get first machine object in cache
    GetNext             : Get next machine object in cache.
                          GetFirst must have been called first.
    GetLast             : Get last machine object in cache
    GetPrev             : Get previous machine object in cache
                          GetLast must have been called first.

--*/
{
public:
    CIISServerCache() : m_pos(NULL), m_fDirty(FALSE) {};
    ~CIISServerCache() {};

public:
    BOOL IsDirty() const { return m_fDirty; }
    void SetDirty(BOOL fDirty = TRUE) { m_fDirty = fDirty; }
    BOOL Add(CIISMachine * pMachine);
    BOOL Remove(CIISMachine * pMachine);
    CIISMachine * GetNext() { return m_pos ? (CIISMachine *)CPtrList::GetNext(m_pos) : NULL; }
    CIISMachine * GetFirst() { m_pos = GetHeadPosition(); return GetNext(); }
    CIISMachine * GetPrev() { return m_pos ? (CIISMachine *)CPtrList::GetPrev(m_pos) : NULL; }
    CIISMachine * GetLast() { m_pos = GetTailPosition(); return GetPrev(); }

private:
    POSITION m_pos;
    BOOL     m_fDirty;
};



#endif // __SCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\seccom.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        authent.cpp

   Abstract:

        WWW Authentication Dialog Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __SECCOM_H__
#define __SECCOM_H__


//{{AFX_INCLUDES()
#include "certmap.h"
#include "certauth.h"
#include "certwiz.h"
//}}AFX_INCLUDES



class CSecCommDlg : public CDialog
/*++

Class Description:

    Authantication dialog

Public Interface:

    CSecCommDlg  : Constructor

--*/
{
//
// Construction
//
public:
    CSecCommDlg(
        IN LPCTSTR lpstrServerName,         // For API name only
        IN LPCTSTR lpstrMetaPath,           // For use in ocx only
        IN CString & strBasicDomain,
        IN DWORD & dwAuthFlags,
        IN CComAuthInfo * pAuthInfo,
        IN DWORD & dwAccessPermissions,
        IN BOOL    fIsMasterInstance,
        IN BOOL    fSSLSupported,
        IN BOOL    fSSL128Supported,
        IN BOOL    fU2Installed,
        IN CString & strCTLIdentifier,
        IN CString & strCTLStoreName,
        IN BOOL    fEditCTLs,
        IN BOOL    fIsLocal,
        IN CWnd *  pParent = NULL            OPTIONAL
        );

    ~CSecCommDlg();

//
// Dialog Data
//
public:
    CString m_strCTLIdentifier;
    CString m_strCTLStoreName;
    BOOL    m_bCTLDirty;

protected:
    //
    // Radio button values
    //
    enum
    {
        RADIO_NO_CERT,
        RADIO_ACCEPT_CERT,
        RADIO_REQ_CERT,
    };

    //{{AFX_DATA(CSecCommDlg)
    enum { IDD = IDD_SECURE_COMMUNICATIONS };
    int         m_nRadioNoCert;
    BOOL        m_fAccountMapping;
    BOOL        m_fRequireSSL;
    BOOL        m_fRequire128BitSSL;
    BOOL        m_fEnableCtl;
    CString     m_strCtl;
    CStatic     m_static_CTLPrompt;
    CStatic     m_static_CTLSeparator;
    CButton     m_check_AccountMapping;
    CButton     m_check_RequireSSL;
    CButton     m_check_Require128BitSSL;
    CButton     m_check_EnableDS;
    CButton     m_check_EnableCtl;
    CButton     m_button_EditCtl;
    CButton     m_button_NewCtl;
    CCertmap    m_ocx_ClientMappings;
    CComboBox   m_combo_ctl;
    //}}AFX_DATA

    CButton     m_radio_RequireCert;
    CButton     m_radio_AcceptCert;
    CCertWiz    m_ocx_CertificateAuthorities;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CSecCommDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CSecCommDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    afx_msg void OnCheckSslAccountMapping();
    afx_msg void OnCheckRequireSsl();
    afx_msg void OnRadioAcceptCert();
    afx_msg void OnRadioNoCert();
    afx_msg void OnRadioRequireCert();
    afx_msg void OnButtonEditCtl();
    afx_msg void OnCheckEnableCtl();
    afx_msg void OnButtonNewCtl();
    afx_msg void OnSelchangeComboCtl();
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    BOOL AddCTLToList(PCCTL_CONTEXT pCTL, BOOL fSelect);
    PCCTL_CONTEXT CallCTLWizard(PCCTL_CONTEXT pCTLSrc);

    void InitializeCTLList();
    void CleanUpCTLList();

    HCERTSTORE  m_hCTLStore;

    INT m_iLastUsedCert;
    DWORD & m_dwAuthFlags;
    CComAuthInfo * m_pAuthInfo;
    DWORD & m_dwAccessPermissions;
    DWORD m_dwInstance;
    BOOL m_fEditCTLs;
    BOOL m_fSSLEnabledOnServer;
    BOOL m_fSSLInstalledOnServer;
    BOOL m_fSSL128Supported;
    BOOL m_fU2Installed;
    BOOL m_fIsLocal;
    BOOL m_fIsMasterInstance;
    CString m_strServerName;
    CString m_strMetaPath;
};


#endif // __SECCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\setperm.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :
        setperm.cpp

   Abstract:
        IIS Security Wizard helper file

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
		7/12/99		created
--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "resource.h"
#include "pwiz.h"
#include <aclapi.h>
//#include <ntseapi.h>
#include <shlwapi.h>

static HRESULT
SetSecurityDeep(
   LPTSTR *ppszBuffer,
   UINT * pcchBuffer,
   DWORD dwAttributes,
   SECURITY_INFORMATION si,
   PACL pDacl,
   PACL pSacl
   );

static BOOL 
PathIsDotOrDotDot(LPCTSTR pszPath)
{
   if (TEXT('.') == *pszPath++)
   {
      if (TEXT('\0') == *pszPath || (TEXT('.') == *pszPath && TEXT('\0') == *(pszPath + 1)))
         return TRUE;
   }
   return FALSE;
}

HRESULT
CPWSummary::SetPermToChildren(
	IN CString& FileName,
   IN SECURITY_INFORMATION si,
	IN PACL pDacl,
   IN PACL pSacl
	)
{
   HRESULT hr = S_OK;
   LPTSTR pszBuffer = NULL;
   UINT cchBuffer = 0, cchFolder;
   HANDLE hFind;
   WIN32_FIND_DATA fd;

   pszBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, 2 * MAX_PATH * sizeof(TCHAR));
   if (pszBuffer == NULL)
      return E_OUTOFMEMORY;
   cchBuffer = (UINT)LocalSize(pszBuffer) / sizeof(TCHAR);
   lstrcpy(pszBuffer, FileName);
   cchFolder = lstrlen(pszBuffer);
   // Append a backslash if it's not there already
   if (pszBuffer[cchFolder-1] != TEXT('\\'))
   {
      pszBuffer[cchFolder] = TEXT('\\');
      cchFolder++;
   }

   // Append the '*' wildcard
   pszBuffer[cchFolder] = TEXT('*');
   pszBuffer[cchFolder+1] = TEXT('\0');

   if (INVALID_HANDLE_VALUE != (hFind = FindFirstFile(pszBuffer, &fd)))
   {
      do
      {
         if (PathIsDotOrDotDot(fd.cFileName))
            continue;
         //
         // Build full path name and recurse
         //
         lstrcpyn(pszBuffer + cchFolder, fd.cFileName, cchBuffer - cchFolder);
         if (fd.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
         {
            hr = SetSecurityDeep(&pszBuffer,
                     &cchBuffer,
                     fd.dwFileAttributes,
                     si,
                     pDacl,
                     pSacl);
         }
         else
         {
            hr = HRESULT_FROM_WIN32(SetNamedSecurityInfo(
                                 pszBuffer,
                                 SE_FILE_OBJECT,
                                 si,
                                 NULL,
                                 NULL,
                                 pDacl,
                                 pSacl));
         }
      }
      while (S_OK == hr && FindNextFile(hFind, &fd));
      FindClose(hFind);
   }
   if (pszBuffer != NULL)
      LocalFree(pszBuffer);
   return hr;
}

static HRESULT
SetSecurityDeep(
   LPTSTR *ppszBuffer,
   UINT * pcchBuffer,
   DWORD dwAttributes,
   SECURITY_INFORMATION si,
   PACL pDacl,
   PACL pSacl
   )
{
   HRESULT hr = S_OK;
   DWORD dwErr = NOERROR;
   LPTSTR pszBuffer;
   BOOL bWriteDone = FALSE;

   pszBuffer = *ppszBuffer;
   //
   // Recursively apply the new SD to subfolders
   //
   if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
   {
      HANDLE hFind;
      WIN32_FIND_DATA fd;
      UINT cchFolder;
      UINT cchSizeRequired;

      cchFolder = lstrlen(pszBuffer);

      //
      // If the buffer is getting tight, realloc
      //
      cchSizeRequired = cchFolder + 1 + sizeof(fd.cFileName) / sizeof(TCHAR); // 1 for backslash
      if (cchSizeRequired > *pcchBuffer)
      {
         cchSizeRequired += MAX_PATH;  // so we don't realloc as often
         pszBuffer = (LPTSTR)LocalReAlloc(*ppszBuffer, cchSizeRequired * sizeof(TCHAR), LMEM_MOVEABLE);
         if (pszBuffer)
         {
            *ppszBuffer = pszBuffer;
            *pcchBuffer = cchSizeRequired;
         }
         else
         {
            // fd.cFileName typically has some empty space, so we
            // may be able to continue
            pszBuffer = *ppszBuffer;
            if (*pcchBuffer < cchFolder + 3) // backslash, '*', and NULL
               return E_OUTOFMEMORY;
         }
      }

      // Append a backslash if it's not there already
      if (pszBuffer[cchFolder-1] != TEXT('\\'))
      {
         pszBuffer[cchFolder] = TEXT('\\');
         cchFolder++;
      }

      // Append the '*' wildcard
      pszBuffer[cchFolder] = TEXT('*');
      pszBuffer[cchFolder+1] = TEXT('\0');

      //
      // Enumerate the folder contents
      //
      hFind = FindFirstFile(pszBuffer, &fd);

      if (INVALID_HANDLE_VALUE == hFind)
      {
         dwErr = GetLastError();

         if (ERROR_ACCESS_DENIED == dwErr)
         {
            // Remove the '*' wildcard
            pszBuffer[cchFolder-1] = TEXT('\0');

            if (si & DACL_SECURITY_INFORMATION)
            {
               //
               // The user may be granting themselves access, so call
               // WriteObjectSecurity and retry FindFirstFile.
               //
               // Don't blindly call WriteObjectSecurity before FindFirstFile
               // since it's possible the user has access now but is removing
               // their own access.
               //
               bWriteDone = TRUE;
               hr = HRESULT_FROM_WIN32(SetNamedSecurityInfo(
                                 pszBuffer,
                                 SE_FILE_OBJECT,
                                 si,
                                 NULL,
                                 NULL,
                                 pDacl,
                                 pSacl));
               if (SUCCEEDED(hr))
               {
                  // Retry FindFirstFile
                  pszBuffer[cchFolder-1] = TEXT('\\');
                  hFind = FindFirstFile(pszBuffer, &fd);
               }
            }
         }
      }

      if (hFind != INVALID_HANDLE_VALUE)
      {
         do
         {
            if (PathIsDotOrDotDot(fd.cFileName))
               continue;

            //
            // Build full path name and recurse
            //
            lstrcpyn(pszBuffer + cchFolder, fd.cFileName, *pcchBuffer - cchFolder);
            hr = SetSecurityDeep(ppszBuffer,
                     pcchBuffer,
                     fd.dwFileAttributes,
                     si,
                     pDacl,
                     pSacl);

            // In case the buffer was reallocated
            pszBuffer = *ppszBuffer;
         }
         while (S_OK == hr && FindNextFile(hFind, &fd));

         FindClose(hFind);
      }
      else if (NOERROR != dwErr)
      {
         hr = S_FALSE;   // abort
      }

      // Truncate the path back to the original length (sans backslash)
      pszBuffer[cchFolder-1] = TEXT('\0');
   }

   //
   // Finally, write out the new security descriptor
   //
   if (!bWriteDone)
   {
      hr = HRESULT_FROM_WIN32(SetNamedSecurityInfo(
                                 pszBuffer,
                                 SE_FILE_OBJECT,
                                 si,
                                 NULL,
                                 NULL,
                                 pDacl,
                                 pSacl));
   }
   if (SUCCEEDED(hr))
   {
      //
      // Notify the shell if we change permissions on a folder (48220)
      //
      if (  (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) 
         && (si & DACL_SECURITY_INFORMATION)
         )
      {
         SHChangeNotify(
            SHCNE_UPDATEDIR,
            SHCNF_PATH | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT,
            pszBuffer,
            NULL);
      }
   }
   else
   {
      hr = S_FALSE;   // abort
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\shts.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        shts.cpp

   Abstract:

        IIS Property sheet classes

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager (cluster edition)

   Revision History:

--*/

#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "mime.h"
#include "iisobj.h"
#include "shutdown.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



//
// CInetPropertySheet class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNAMIC(CInetPropertySheet, CPropertySheet)



CInetPropertySheet::CInetPropertySheet(
    CComAuthInfo * pAuthInfo,
    LPCTSTR lpszMetaPath,
    CWnd * pParentWnd,
    LPARAM lParam,             
    LONG_PTR handle,
    UINT iSelectPage         
    )
/*++

Routine Description:

    IIS Property Sheet constructor

Arguments:

    CComAuthInfo * pAuthInfo  : Authentication information
    LPCTSTR lpszMetPath       : Metabase path
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    LONG_PTR handle           : MMC Console handle
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CPropertySheet(_T(""), pParentWnd, iSelectPage),
      m_auth(pAuthInfo),
      m_strMetaPath(lpszMetaPath),
      m_dwInstance(0L),
      m_bModeless(FALSE),
      m_hConsole(handle),
      m_lParam(lParam),
      m_fHasAdminAccess(TRUE),      // Assumed by default
      m_pCap(NULL),
      m_refcount(0),
      m_fRestartRequired(FALSE),
	  m_fChanged(FALSE)
{
    m_fIsMasterPath = CMetabasePath::IsMasterInstance(lpszMetaPath);
    TRACEEOLID("Metabase path is master? " << m_fIsMasterPath);
}



void
CInetPropertySheet::NotifyMMC()
/*++

Routine Description:

    Notify MMC that changes have been made, so that the changes are
    reflected.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Notify MMC to update changes.
    //
    if (m_hConsole != NULL)
    {
        ASSERT(m_lParam != 0L);
        MMCPropertyChangeNotify(m_hConsole, m_lParam);
    }
}



CInetPropertySheet::~CInetPropertySheet()
/*++

Routine Description:

    IIS Property Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
   // At this moment we should have in m_pages only pages that were not activated
   // in this session.
   while (!m_pages.IsEmpty())
   {
      CInetPropertyPage * pPage = m_pages.RemoveHead();
      delete pPage;
   }
   if (m_fChanged)
   {
	  NotifyMMC();
   }
   if (m_hConsole != NULL)
   {
      MMCFreeNotifyHandle(m_hConsole);
   }
}


void
CInetPropertySheet::AttachPage(CInetPropertyPage * pPage)
{
   m_pages.AddTail(pPage);
}


void
CInetPropertySheet::DetachPage(CInetPropertyPage * pPage)
{
   POSITION pos = m_pages.Find(pPage);
   ASSERT(pos != NULL);
   if (pos != NULL)
   {
	  m_fChanged |= pPage->IsDirty();
      m_pages.RemoveAt(pos);
   }
}

WORD 
CInetPropertySheet::QueryMajorVersion() const
{
   CIISMBNode * pNode = (CIISMBNode *)m_lParam;
   ASSERT(pNode != NULL);
   return pNode->QueryMajorVersion();
}

WORD 
CInetPropertySheet::QueryMinorVersion() const
{
   CIISMBNode * pNode = (CIISMBNode *)m_lParam;
   ASSERT(pNode != NULL);
   return pNode->QueryMinorVersion();
}

/* virtual */ 
HRESULT 
CInetPropertySheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Load base values
    //
    CError err;

    if (m_pCap == NULL)
    {
        TRACEEOLID("Determining path locations for " << m_strMetaPath);

        //
        // Capability info stored off the service path ("lm/w3svc").
        //
        ASSERT(m_strInfoPath.IsEmpty());

        //
        // Building path components
        //
        CMetabasePath::GetServiceInfoPath(m_strMetaPath, m_strInfoPath);

        TRACEEOLID("Storing info path: " << m_strInfoPath);

        //
        // Split into instance and directory paths
        //
        if (IsMasterInstance())
        {
            m_strServicePath = m_strInstancePath = QueryMetaPath();
        }
        else 
        {
            VERIFY(CMetabasePath::GetInstancePath(
                QueryMetaPath(), 
                m_strInstancePath,
                &m_strDirectoryPath
                ));

            VERIFY(CMetabasePath::GetServicePath(
                QueryMetaPath(),
                m_strServicePath
                ));
        }

        TRACEEOLID("Service path " << m_strServicePath);
        TRACEEOLID("Instance path " << m_strInstancePath);

        if (m_strDirectoryPath.IsEmpty() && !IsMasterInstance())
        {
            m_strDirectoryPath = CMetabasePath(FALSE, QueryMetaPath(), g_cszRoot);
        }
        else
        {
            m_strDirectoryPath = QueryMetaPath();
        }

        TRACEEOLID("Directory path " << m_strDirectoryPath);

        m_dwInstance = CMetabasePath::GetInstanceNumber(m_strMetaPath);

        TRACEEOLID("Instance number " << m_dwInstance);
        
        m_pCap = new CServerCapabilities(QueryAuthInfo(), m_strInfoPath);
    
        if (!m_pCap)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            return err;
        }

        err = m_pCap->LoadData();

        if (err.Succeeded())
        {
            err = DetermineAdminAccess();
        }
    }
    return err;
}



/* virtual */ 
void 
CInetPropertySheet::FreeConfigurationParameters()
/*++

Routine Description:

    Clean up configuration data

Arguments:

    None

Return Value:

    None

--*/
{
//    ASSERT_PTR(m_pCap);
    SAFE_DELETE(m_pCap);
}




void
CInetPropertySheet::WinHelp(
    IN DWORD dwData,
    IN UINT nCmd
    )
/*++

Routine Description:

    WinHelp override.  We can't use the base class, because our
    'sheet' doesn't usually have a window handle

Arguments:

    DWORD dwData        : Help data
    UINT nCmd           : Help command

Return Value:

    None

--*/
{

#ifdef _DEBUG
    TCHAR szBuffer[20];
    _stprintf(szBuffer,_T("WinHelp:0x%x\n"),dwData);OutputDebugString(szBuffer);
#endif

    if (m_hWnd == NULL)
    {
        /*
        //
        // Special case
        //
        ::WinHelp(
            HWND hWndMain,
            LPCWSTR lpszHelp,
            UINT uCommand,
            DWORD dwData
            );
        */

        CWnd * pWnd = ::AfxGetMainWnd();

        if (pWnd != NULL)
        {
            pWnd->WinHelp(dwData, nCmd);
        }

        return;
    }

    CPropertySheet::WinHelp(dwData, nCmd);
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CInetPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


//
// CInetPropertyPage class
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// CInetPropertyPage property page
//
IMPLEMENT_DYNAMIC(CInetPropertyPage, CPropertyPage)




#ifdef _DEBUG

/* virtual */
void
CInetPropertyPage::AssertValid() const
{
}



/* virtual */
void
CInetPropertyPage::Dump(CDumpContext& dc) const
{
}

#endif // _DEBUG



CInetPropertyPage::CInetPropertyPage(
    IN UINT nIDTemplate,
    IN CInetPropertySheet * pSheet,
    IN UINT nIDCaption,
    IN BOOL fEnableEnhancedFonts            OPTIONAL
    )
/*++

Routine Description:

    IIS Property Page Constructor

Arguments:

    UINT nIDTemplate            : Resource template
    CInetPropertySheet * pSheet : Associated property sheet
    UINT nIDCaption             : Caption ID
    BOOL fEnableEnhancedFonts   : Enable enhanced fonts

Return Value:

    N/A

--*/
    : CPropertyPage(nIDTemplate, nIDCaption),
      m_nHelpContext(nIDTemplate + 0x20000),
      m_fEnableEnhancedFonts(fEnableEnhancedFonts),
      m_bChanged(FALSE),
      m_pSheet(pSheet)
{
    //{{AFX_DATA_INIT(CInetPropertyPage)
    //}}AFX_DATA_INIT

    m_psp.dwFlags |= PSP_HASHELP;

    ASSERT(m_pSheet != NULL);
    m_pSheet->AttachPage(this);
}



CInetPropertyPage::~CInetPropertyPage()
/*++

Routine Description:

    IIS Property Page Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CInetPropertyPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CInetPropertyPage)
    //}}AFX_DATA_MAP
}



/* virtual */
void 
CInetPropertyPage::PostNcDestroy()
/*++

Routine Description:

    handle destruction of the window by freeing the this
    pointer (as this modeless dialog must have been created
    on the heap)

Arguments:

    None.

Return Value:

    None

--*/
{
    m_pSheet->Release(this);
    delete this;
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CInetPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CInetPropertyPage)
    ON_COMMAND(ID_HELP, OnHelp)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



/* virtual */
BOOL
CInetPropertyPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.  Reset changed
    status (sometimes gets set by e.g. spinboxes when the dialog is
    constructed), so make sure the dialog is considered clean.

Arguments:

    None

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    m_bChanged = FALSE;

    //
    // Tell derived class to load its configuration parameters
    //
    CError err(LoadConfigurationParameters());

    if (err.Succeeded())
    {
        err = FetchLoadedValues();
    }

    BOOL bResult = CPropertyPage::OnInitDialog();

    err.MessageBoxOnFailure();

    if (m_fEnableEnhancedFonts)
    {
        CFont * pFont = &m_fontBold;

        if (CreateSpecialDialogFont(this, pFont))
        {
            ApplyFontToControls(this, pFont, IDC_ED_BOLD1, IDC_ED_BOLD5);
        }
    }

    // We should call AddRef here, not in page constructor, because PostNCDestroy()
    // is getting called only for pages that were activated, not for all created pages.
    // OnInitDialog is also called for activated pages only -- so we will get parity
    // and delete property sheet.
    //
    ASSERT(m_pSheet != NULL);
    m_pSheet->AddRef();

    return bResult;
}



void
CInetPropertyPage::OnHelp()
/*++

Routine Description:

    'Help' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT_PTR(m_pSheet);

#ifdef _DEBUG
    TCHAR szBuffer[20];
    _stprintf(szBuffer,_T("WinHelp:0x%x\n"),m_nHelpContext);OutputDebugString(szBuffer);
#endif

    m_pSheet->WinHelp(m_nHelpContext);
}



BOOL
CInetPropertyPage::OnHelpInfo(
    IN HELPINFO * pHelpInfo
    )
/*++

Routine Description:

    Eat "help info" command

Arguments:

    None

Return Value:

    None

--*/
{
    OnHelp();

    return TRUE;
}



BOOL
CInetPropertyPage::OnApply()
/*++

Routine Description:

    Handle "OK" or "APPLY".  Call the derived class to save its stuff,
    and set the dirty state depending on whether saving succeeded or 
    failed.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL bSuccess = TRUE;

    if (IsDirty())
    {
        CError err(SaveInfo());

        if (err.MessageBoxOnFailure())
        {
            //
            // Failed, sheet will not be dismissed.
            //
            // CODEWORK: This page should be activated.
            //
            bSuccess = FALSE;
        }

        SetModified(!bSuccess);
        if (bSuccess && GetSheet()->RestartRequired())
        {
           // ask user about immediate restart
           if (IDYES == ::AfxMessageBox(IDS_ASK_TO_RESTART, MB_YESNO | MB_ICONQUESTION))
           {
              // restart IIS
              CIISMachine * pMachine = new CIISMachine(QueryAuthInfo());
              if (pMachine != NULL)
              {
                 CIISShutdownDlg dlg(pMachine, this);
                 dlg.PerformCommand(ISC_RESTART);
                 bSuccess = dlg.ServicesWereRestarted();
                 delete pMachine;
              }
           }
           // mark restart required false to suppress it on other pages
           GetSheet()->SetRestartRequired(FALSE);
        }
    }

    return bSuccess;
}



void
CInetPropertyPage::SetModified(
    IN BOOL bChanged
    )
/*++

Routine Description:

    Keep private check on dirty state of the property page.

Arguments:

    BOOL bChanged : Dirty flag

Return Value:

    None

--*/
{
    CPropertyPage::SetModified(bChanged);
    m_bChanged = bChanged;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\shutdown.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        shutdown.h

   Abstract:

        IIS Shutdown/restart dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

    Internet Services Manager (cluster edition)

   Revision History:

--*/



#ifndef __SHUTDOWN_H__
#define __SHUTDOWN_H__



//
// IIS Service Command
//
typedef struct tagIISCOMMAND
{
    //TCHAR   szServer[MAX_PATH + 1];
    BOOL    fFinished;
    HRESULT hReturn;
    DWORD   dwMilliseconds;
    CWnd  * pParent;
    CIISMachine * pMachine;
    CRITICAL_SECTION cs;
}   
IISCOMMAND;


//
// Shutdown progress dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CShutProgressDlg : public CDialog
/*++

Class Description:

    Shutdown progress indicator dialog.  Displays a progress bar, and gives
    the opportunity to kill immediately.

Public Interface:

    CShutProgressDlg        Constructor

Notes:

    This dialog displays a progress bar with the number of seconds for shutdown.

    The return value is IDOK if Kill() should be executed, or if no further action
    is required.

--*/
{
//
// Construction
//
public:
    CShutProgressDlg(
        IN IISCOMMAND * pCommand
        );   

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CShutProgressDlg)
    enum { IDD = IDD_SD_PROGRESS };
    CStatic       m_static_ProgressMsg;
    CProgressCtrl m_prgShutdown;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CShutProgressDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX); 
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CShutProgressDlg)
    afx_msg void OnTimer(UINT nIDEvent);
    afx_msg void OnDestroy();
    virtual void OnOK();
    virtual void OnCancel();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    int     m_nProgress;
    UINT    m_uTimeoutSec;
    IISCOMMAND * m_pCommand;
    CString m_strProgress;
};



//
// Shutdown dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



enum
{
    //
    // Note: make sure that associated resource IDs remain
    //       sequential.
    //
    ISC_START,
    ISC_STOP,
    ISC_SHUTDOWN,
    ISC_RESTART,
    /**/
    NUM_ISC_ITEMS
};



class CIISShutdownDlg : public CDialog
/*++

Class Description:

    IIS Shutdown/Restart dialog

Public Interface:

    CIISShutdownDlg         - Constructor

    ServicesWereRestarted   Returns true if the services were restarted

--*/
{
//
// Construction
//
public:
    CIISShutdownDlg(
        IN CIISMachine * pMachine,
        IN CWnd * pParent       = NULL
        );

//
// Access
//
public:
    BOOL ServicesWereRestarted() const { return m_fServicesRestarted; }
    HRESULT PerformCommand(int iCmd);

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CIISShutdownDlg)
    enum { IDD = IDD_SHUTDOWN };
    CStatic     m_static_Details;
    CComboBox   m_combo_Restart;
    //}}AFX_DATA

    CString m_strDetails[NUM_ISC_ITEMS];

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIISShutdownDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);    
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CIISShutdownDlg)
    afx_msg void OnSelchangeComboRestart();
    afx_msg void OnDblclkComboRestart();
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetDetailsText();

private:
    CIISMachine * m_pMachine;
    BOOL m_fServicesRestarted;
};



#endif // __SHUTDOWN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\shts.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        shts.h

   Abstract:
        IIS Property sheet definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __SHTS_H__
#define __SHTS_H__

//
// Sheet Definitions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Sheet -> page crackers
//
#define BEGIN_META_INST_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryInstanceResult()))                       \
        {                                                                \
            break;                                                       \
        }

#define FETCH_INST_DATA_FROM_SHEET(value)\
    value = pSheet->GetInstanceProperties().value;                       \
    TRACEEOLID(value);

#define END_META_INST_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_DIR_READ(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
    do                                                                   \
    {                                                                    \
        if (FAILED(pSheet->QueryDirectoryResult()))                      \
        {                                                                \
            break;                                                       \
        }

#define FETCH_DIR_DATA_FROM_SHEET(value)\
    value = pSheet->GetDirectoryProperties().value;                      \
    TRACEEOLID(value);

#define END_META_DIR_READ(err)\
                                                                         \
    }                                                                    \
    while(FALSE);                                                        \
}

#define BEGIN_META_INST_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_INST_DATA_ON_SHEET(value)\
        pSheet->GetInstanceProperties().value = value;

#define STORE_INST_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetInstanceProperties().value = value;    \
        dirty = MP_D(((sheet *)GetSheet())->GetInstanceProperties().value);

#define FLAG_INST_DATA_FOR_DELETION(id)\
        pSheet->GetInstanceProperties().FlagPropertyForDeletion(id);

#define END_META_INST_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetInstanceProperties().WriteDirtyProps();            \
}


#define BEGIN_META_DIR_WRITE(sheet)\
{                                                                        \
    sheet * pSheet = (sheet *)GetSheet();                                \
                                                                         \
    do                                                                   \
    {                                                                    \

#define STORE_DIR_DATA_ON_SHEET(value)\
        pSheet->GetDirectoryProperties().value = value;

#define STORE_DIR_DATA_ON_SHEET_REMEMBER(value, dirty)\
        pSheet->GetDirectoryProperties().value = value;      \
        dirty = MP_D(pSheet->GetDirectoryProperties().value);

#define INIT_DIR_DATA_MASK(value, mask)\
        MP_V(pSheet->GetDirectoryProperties().value).SetMask(mask);

#define FLAG_DIR_DATA_FOR_DELETION(id)\
        pSheet->GetDirectoryProperties().FlagPropertyForDeletion(id);

#define END_META_DIR_WRITE(err)\
                                                                        \
    }                                                                   \
    while(FALSE);                                                       \
                                                                        \
    err = pSheet->GetDirectoryProperties().WriteDirtyProps();           \
}

class CInetPropertyPage;

class CInetPropertySheet : public CPropertySheet
/*++

Class Description:

    IIS Object configuration property sheet.

Public Interface:

    CInetPropertySheet          : Constructor
    ~CInetPropertySheet         : Destructor

    cap                         : Get capabilities

--*/
{
    DECLARE_DYNAMIC(CInetPropertySheet)

//
// Construction/destruction
//
public:
    CInetPropertySheet(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath,
        IN CWnd * pParentWnd        = NULL,
        IN LPARAM lParam            = 0L,
        IN LONG_PTR handle              = 0L,
        IN UINT iSelectPage         = 0
        );

    virtual ~CInetPropertySheet();

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CInetPropertySheet)
    //}}AFX_VIRTUAL

//
// Access
//
public:
    BOOL IsLocal()            const { return m_auth.IsLocal(); }
    BOOL IsMasterInstance()   const { return m_fIsMasterPath; }
    BOOL HasAdminAccess()     const { return m_fHasAdminAccess; }
    BOOL RestartRequired()    const { return m_fRestartRequired; }
    DWORD QueryInstance()     const { return m_dwInstance; }
    LPCTSTR QueryServerName() const { return m_auth.QueryServerName(); }
    LPCTSTR QueryMetaPath()   const { return m_strMetaPath; }

    LPCTSTR QueryServicePath() const { return m_strServicePath; }
    LPCTSTR QueryInstancePath() const { return m_strInstancePath; }
    LPCTSTR QueryDirectoryPath() const { return m_strDirectoryPath; }
    LPCTSTR QueryInfoPath() const { return m_strInfoPath; }

    CComAuthInfo * QueryAuthInfo()  { return &m_auth; }
    CServerCapabilities & cap()     { return *m_pCap; }
    LPARAM GetParameter() {return m_lParam;}

public:
    void AddRef() 
    { 
       ++m_refcount; 
    }
    void Release(CInetPropertyPage * pPage) 
    { 
       DetachPage(pPage);
       if (--m_refcount <= 0) 
          delete this; 
    }
    void AttachPage(CInetPropertyPage * pPage);

    void NotifyMMC();
    void SetModeless();
    BOOL IsModeless() const { return m_bModeless; }

public:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    //
    // Override in derived class to load delayed values
    //
    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();

    void SetRestartRequired(BOOL flag);
    WORD QueryMajorVersion() const;
    WORD QueryMinorVersion() const;

//
// Generated message map functions
//
protected:
   //{{AFX_MSG(CInetPropertySheet)
   //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void Initialize();
    void DetachPage(CInetPropertyPage * pPage);

    //
    // Attempt to resolve admin/operator access for the given
    // metbase path (instance path)
    //
    HRESULT DetermineAdminAccess();

    void SetIsMasterInstance(BOOL flag) {m_fIsMasterPath = flag;}

protected:
    int     m_refcount;
	BOOL	m_fChanged;
    DWORD   m_dwInstance;
    CString m_strMetaPath;
    CString m_strServicePath;
    CString m_strInstancePath;
    CString m_strDirectoryPath;
    CString m_strInfoPath;
    CComAuthInfo m_auth;

private:
    BOOL    m_bModeless;
    BOOL    m_fHasAdminAccess;
    BOOL    m_fIsMasterPath;
    BOOL    m_fRestartRequired;
    LONG_PTR    m_hConsole;
    LPARAM  m_lParam;
    CServerCapabilities *  m_pCap;
    CList<CInetPropertyPage *, CInetPropertyPage *&> m_pages;
};



//
// Page Definitions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CInetPropertyPage : public CPropertyPage
/*++

Class Description:

    IIS Configuration property page class

Public Interface:

    CInetPropertyPage           : Constructor
    ~CInetPropertyPage          : Destructor

    SaveInfo                    : Save info on this page if dirty

--*/
{
    DECLARE_DYNAMIC(CInetPropertyPage)

//
// Construction/Destruction
//
public:
    CInetPropertyPage(
        IN UINT nIDTemplate,
        IN CInetPropertySheet * pSheet,
        IN UINT nIDCaption              = USE_DEFAULT_CAPTION,
        IN BOOL fEnableEnhancedFonts    = FALSE
        );

    ~CInetPropertyPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CInetPropertyPage)
    //enum { IDD = _UNKNOWN_RESOURCE_ID_ };
    //}}AFX_DATA

//
// Overrides
//
public:
    //
    // Derived classes must provide their own equivalents
    //
    /* PURE */ virtual HRESULT FetchLoadedValues() = 0;
    /* PURE */ virtual HRESULT SaveInfo() = 0;

    //
    // Is the data on this page dirty?
    //
    BOOL IsDirty() const { return m_bChanged; }

    //{{AFX_VIRTUAL(CInetPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext & dc) const;
#endif

protected:
    //
    // Generated message map functions
    //
    //{{AFX_MSG(CInetPropertyPage)
    afx_msg void OnHelp();
    afx_msg BOOL OnHelpInfo(HELPINFO * pHelpInfo);
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    virtual BOOL OnInitDialog();
    virtual BOOL OnApply();

//
// Helper function
//
protected:
    BOOL GetIUsrAccount(CString & str);

//
// Access Functions
//
protected:
    //
    // Get associated property sheet object
    //
    CInetPropertySheet * GetSheet()     { return m_pSheet; }
    BOOL IsLocal()            const     { return m_pSheet->IsLocal(); }
    BOOL IsMasterInstance()   const     { return m_pSheet->IsMasterInstance(); }
    BOOL HasAdminAccess()     const     { return m_pSheet->HasAdminAccess(); }
    DWORD QueryInstance()     const     { return m_pSheet->QueryInstance(); }
    LPCTSTR QueryServerName() const     { return m_pSheet->QueryServerName(); }
    LPCTSTR QueryMetaPath() const       { return m_pSheet->QueryMetaPath(); }
    LPCTSTR QueryServicePath() const    { return m_pSheet->QueryServicePath(); }
    LPCTSTR QueryInstancePath() const   { return m_pSheet->QueryInstancePath(); }
    LPCTSTR QueryDirectoryPath() const  { return m_pSheet->QueryDirectoryPath(); }
    LPCTSTR QueryInfoPath() const       { return m_pSheet->QueryInfoPath(); }
    CComAuthInfo * QueryAuthInfo()      { return m_pSheet->QueryAuthInfo(); }
    HRESULT LoadConfigurationParameters() { return m_pSheet->LoadConfigurationParameters(); }

    //
    // Update MMC with new changes
    //
    void NotifyMMC();

public:
    //
    // Keep private information on page dirty state, necessary for
    // SaveInfo() later.
    //
    void SetModified(
        IN BOOL bChanged = TRUE
        );

//
// Capability bits
//
protected:
    BOOL IsSSLSupported()       const { return m_pSheet->cap().IsSSLSupported(); }
    BOOL IsSSL128Supported()    const { return m_pSheet->cap().IsSSL128Supported(); }
    BOOL HasMultipleSites()     const { return m_pSheet->cap().HasMultipleSites(); }
    BOOL HasBwThrottling()      const { return m_pSheet->cap().HasBwThrottling(); }
    BOOL Has10ConnectionLimit() const { return m_pSheet->cap().Has10ConnectionLimit(); }
    BOOL HasIPAccessCheck()     const { return m_pSheet->cap().HasIPAccessCheck(); }
    BOOL HasOperatorList()      const { return m_pSheet->cap().HasOperatorList(); } 
    BOOL HasFrontPage()         const { return m_pSheet->cap().HasFrontPage(); }
    BOOL HasCompression()       const { return m_pSheet->cap().HasCompression(); }
    BOOL HasCPUThrottling()     const { return m_pSheet->cap().HasCPUThrottling(); }
    BOOL HasDAV()               const { return m_pSheet->cap().HasDAV(); }
    BOOL HasDigest()            const { return m_pSheet->cap().HasDigest(); }
    BOOL HasNTCertMapper()      const { return m_pSheet->cap().HasNTCertMapper(); }

protected:
    BOOL m_bChanged;
    CInetPropertySheet * m_pSheet;

protected:
    BOOL      m_fEnableEnhancedFonts;
    CFont     m_fontBold;
    UINT      m_nHelpContext;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CInetPropertySheet::SetModeless()
{
    m_bModeless = TRUE;
}

inline void CInetPropertySheet::SetRestartRequired(BOOL flag)
{
   m_fRestartRequired = flag;
}

inline HRESULT CInetPropertySheet::DetermineAdminAccess()
{
    //
    // Make sure this is called after parms are loaded.
    //
    return m_pCap ? ::DetermineIfAdministrator(
        m_pCap,                      // Reuse existing interface
        m_strMetaPath,
        &m_fHasAdminAccess
        ) : E_FAIL;
}

inline BOOL CInetPropertyPage::GetIUsrAccount(CString & str)
{
    return ::GetIUsrAccount(QueryServerName(), this, str);
}

inline void CInetPropertyPage::NotifyMMC()
{
    m_pSheet->NotifyMMC();
}

#endif // __SHTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\shutdown.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        shutdown.cpp

   Abstract:

        IIS Shutdown/restart dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

    Internet Services Manager

   Revision History:

--*/



//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "shutdown.h"



//
// Shutdown in milliseconds
//
#define IIS_SHUTDOWN_TIMEOUT        30000L      // 30 Ms



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



CRITICAL_SECTION gcs;



UINT
__cdecl
StopIISServices(
    IN LPVOID pParam
    )
/*++

Routine Description:

    Worker thread to perform IIS Service Control Command

Arguments:

    LPVOID * pParam     : Casts to IISCOMMAND (see above)

Return Value:

    UINT

--*/
{
    IISCOMMAND * pCmd = (IISCOMMAND *)pParam;

    // 
    // This thread needs its own CoInitialize
    //
    CError err(CoInitialize(NULL));             

    ASSERT_PTR(pCmd->pMachine);
    CIISSvcControl isc(pCmd->pMachine->QueryAuthInfo());
    err = isc.QueryResult();

    //
    // Block access to pCmd since the main thread will try to
    // delete it.
    //
    EnterCriticalSection(&gcs);

    if (err.Succeeded())
    {
        err = isc.Stop(IIS_SHUTDOWN_TIMEOUT, TRUE);
    }

    //
    // Clean Up, returning the error code
    //
    EnterCriticalSection(&pCmd->cs);
    pCmd->fFinished = TRUE;
    pCmd->hReturn   = err;
    LeaveCriticalSection(&pCmd->cs);
    LeaveCriticalSection(&gcs);

    return 0;
}



//
// Shutdown progress dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



//
// Timer ID and values
//
#define ID_TIMER (1)
#define A_SECOND (1000L)    



CShutProgressDlg::CShutProgressDlg(
    IN IISCOMMAND * pCommand
    )
/*++

Routine Description:

    Constructor for shutdown progress dialog

Arguments:

    IISCOMMAND * pCommand       : Command structure

Return Value:

    N/A

--*/
    : CDialog(CShutProgressDlg::IDD, pCommand->pParent),
      m_pCommand(pCommand),
      m_uTimeoutSec(pCommand->dwMilliseconds / A_SECOND)
{
    //{{AFX_DATA_INIT(CShutProgressDlg)
    //}}AFX_DATA_INIT
}



void 
CShutProgressDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CShutProgressDlg)
    DDX_Control(pDX, IDC_STATIC_PROGRESS, m_static_ProgressMsg);
    DDX_Control(pDX, IDC_PROGRESS_SHUTDOWN, m_prgShutdown);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CShutProgressDlg, CDialog)
    //{{AFX_MSG_MAP(CShutProgressDlg)
    ON_WM_TIMER()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CShutProgressDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    VERIFY(m_strProgress.LoadString(IDS_SHUTDOWN_PROGRESS));

    m_nProgress = 0;
    m_prgShutdown.SetRange32(0, m_uTimeoutSec);
    m_prgShutdown.SetPos(m_nProgress);
    m_prgShutdown.SetStep(1);

    //
    // Start the progress bar ticking, once per second.
    //
    UINT_PTR nID = SetTimer(ID_TIMER, A_SECOND, NULL);

    if (nID != ID_TIMER)
    {
        //
        // Failed to create the timer.  Pop up an error, and 
        // cancel the dialog.  
        // 
        CError err(ERROR_NO_SYSTEM_RESOURCES);
        err.MessageBox();
        EndDialog(IDCANCEL);
    }
    
    return TRUE; 
}



void 
CShutProgressDlg::OnTimer(
    IN UINT nIDEvent
    ) 
/*++

Routine Description:

    Timer handler.  Upgrade the progressbar with another second on the clock

Arguments:

    UINT nIDEvent       : Timer id

Return Value:

    None

--*/
{
    ASSERT(nIDEvent == ID_TIMER);

    m_prgShutdown.SetPos(++m_nProgress);

    //
    // Display progress on the tick marker
    //
    CString str;
    str.Format(m_strProgress, m_uTimeoutSec - (UINT)m_nProgress  + 1);
    m_static_ProgressMsg.SetWindowText(str);

    //
    // Check to see if the stop thread has finished its action already
    //
    BOOL fFinished;

    EnterCriticalSection(&m_pCommand->cs);
    fFinished = m_pCommand->fFinished;
    LeaveCriticalSection(&m_pCommand->cs);

    if (fFinished)
    {
        //
        // The worker thread has finished, so there's no reason to
        // keep the user in suspense -- dismiss the dialog
        //
        EndDialog(IDCANCEL); 
    }

    if ((UINT)m_nProgress > m_uTimeoutSec)
    {
        //
        // We've timed out -- tell the main thread to Kill!()
        //
        OnOK();
    }

    //
    // I doubt there's any default processing here, but anyway...
    //
    CDialog::OnTimer(nIDEvent);
}



void 
CShutProgressDlg::OnDestroy() 
/*++

Routine Description:

    Handle dialog destruction, kill the timer.

Arguments:

    None

Return Value:
    
    None

--*/
{
    CDialog::OnDestroy();

    ::KillTimer(m_hWnd, (UINT_PTR)ID_TIMER);
}



void 
CShutProgressDlg::OnOK()
/*++

Routine Description:

    OK handler -- ok button maps to "Kill Now!"

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Kill!
    //
    EndDialog(IDOK);
}



void 
CShutProgressDlg::OnCancel() 
/*++

Routine Description:

    Cancel button handler.  This dialog cannot be cancelled, so the cancel
    notification is eaten.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Eat cancel command (user pressed escape)
    //
}



//
// Shutdown dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISShutdownDlg::CIISShutdownDlg(
    IN CIISMachine * pMachine,
    IN CWnd * pParent       OPTIONAL
    )
/*++

Routine Description:

    Constructor

Arguments:

    CIISMachine * pMachine  : Machine object
    CWnd * pParent          : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CIISShutdownDlg::IDD, pParent),
      m_fServicesRestarted(FALSE),
      m_pMachine(pMachine)
{
    //{{AFX_DATA_INIT(CIISShutdownDlg)
    //}}AFX_DATA_INIT

    ASSERT_PTR(m_pMachine);
}



void 
CIISShutdownDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIISShutdownDlg)
    DDX_Control(pDX, IDC_COMBO_RESTART,  m_combo_Restart);
    DDX_Control(pDX, IDC_STATIC_DETAILS, m_static_Details);
    //}}AFX_DATA_MAP
}



void
CIISShutdownDlg::SetDetailsText()
/*++

Routine Description:

    Set the details text to correspond to what's in the combo box

Arguments:

    None

Return Value:

    None

--*/
{
    UINT nSel = m_combo_Restart.GetCurSel();

//    ASSERT(nSel >= 0 && nSel < NUM_ISC_ITEMS);

    m_static_Details.SetWindowText(m_strDetails[nSel]);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIISShutdownDlg, CDialog)
    //{{AFX_MSG_MAP(CIISShutdownDlg)
    ON_CBN_SELCHANGE(IDC_COMBO_RESTART, OnSelchangeComboRestart)
    ON_CBN_DBLCLK(IDC_COMBO_RESTART, OnDblclkComboRestart)
    ON_BN_CLICKED(ID_HELP, OnHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



HRESULT
CIISShutdownDlg::PerformCommand(
    IN int iCmd
    )
/*++

Routine Description:

    Perform restart command

Arguments:

    int iCmd - One of the following commands:

        ISC_START
        ISC_STOP
        ISC_SHUTDOWN
        ISC_RESTART

Return Value:

    HRESULT

--*/
{
    //
    // Make sure the service is supported
    //
    ASSERT_PTR(m_pMachine);

    BeginWaitCursor();
    CIISSvcControl isc(m_pMachine->QueryAuthInfo());
    EndWaitCursor();

    CError err(isc.QueryResult());

    if (err.Failed())
    {
        return err;
    }

    //
    // Create command structure to hand off to 
    // worker thread
    //
    IISCOMMAND * pCommand = new IISCOMMAND;

    if (!pCommand)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        return err;
    }

    ::ZeroMemory(pCommand, sizeof(IISCOMMAND));
    pCommand->pMachine = m_pMachine;
    pCommand->dwMilliseconds = IIS_SHUTDOWN_TIMEOUT;
    pCommand->pParent = this;

    InitializeCriticalSection(&pCommand->cs);
    InitializeCriticalSection(&gcs);

    CShutProgressDlg dlg(pCommand);
    CWinThread * pStopThread = NULL;
    BOOL fStartServices      = FALSE;
    INT_PTR nReturn          = IDCANCEL;

    //
    // Fire off the thread that does the actual work, while we
    // put up the progress UI
    //
    switch(iCmd)
    {
    case ISC_RESTART:
        ++fStartServices;
        //
        // Fall through...
        //
    case ISC_STOP:
        //
        // Stop the services in the workerthread
        //
        pStopThread = AfxBeginThread(&StopIISServices, pCommand);
        nReturn = dlg.DoModal();
        break;

    case ISC_START:
        ++fStartServices;
        break;

    case ISC_SHUTDOWN:
        BeginWaitCursor();
        err = isc.Reboot(IIS_SHUTDOWN_TIMEOUT, m_pMachine->IsLocal());
        EndWaitCursor();
        break;

    default:
        //
        // Internal error!
        //
        ASSERT_MSG("Invalid command code!");
        err = ERROR_INVALID_FUNCTION;
    }

    //
    // Determine if a kill is necessary (timed-out or user
    // pressed 'Kill')
    //
    BeginWaitCursor();

    if (nReturn == IDOK)
    {
        TRACEEOLID("Killing now!");
        err = isc.Kill();
        Sleep(1000L);
    }
    else
    {
        //
        // Waiting for the thread to finish
        //
        if (pStopThread != NULL)
        {
            BOOL fDone = FALSE;

            while(!fDone)
            {
                TRACEEOLID("Checking to see if thread has finished");

                EnterCriticalSection(&pCommand->cs);

                if (pCommand->fFinished)
                {
                    err = pCommand->hReturn;
                    ++fDone;
                }

                LeaveCriticalSection(&pCommand->cs);

                //
                // Pause a bit to catch our breath.
                //
                if (!fDone)
                {
                    Sleep(500);
                }
            }
        }
    }

    //
    // Everything should be stopped, start it up again
    // if necessary.
    //
    if (err.Succeeded() && fStartServices)
    {
        err = isc.Start(IIS_SHUTDOWN_TIMEOUT);
        m_fServicesRestarted = err.Succeeded();
    }

    EndWaitCursor();

    //
    // Clean up when the worker thread says we can.
    //
    EnterCriticalSection(&gcs);
    DeleteCriticalSection(&pCommand->cs);
    delete pCommand;
    LeaveCriticalSection(&gcs);

    DeleteCriticalSection(&gcs);

    return err;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CIISShutdownDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // Load combobox text and details
    //
    CString strFmt, str;

    //
    // This may take a second or two...
    //
    BeginWaitCursor();
    CIISSvcControl isc(m_pMachine->QueryAuthInfo());
    EndWaitCursor();

    CError err(isc.QueryResult());

    if (err.Failed())
    {
        //
        // Failed to obtain interface -- quit now.
        //
        if (err.HResult() == REGDB_E_CLASSNOTREG
         || err.HResult() == CS_E_PACKAGE_NOTFOUND
           )
        {
            //
            // Friendly message about the interface not being supported.
            //
            ::AfxMessageBox(IDS_ERR_NO_SHUTDOWN);
        }
        else
        {
            m_pMachine->DisplayError(err);
        }

        EndDialog(IDCANCEL);
    }

    UINT nOption = IDS_IIS_START;
    UINT nDetails = IDS_IIS_START_DETAILS;

    for (int i = ISC_START; i <= ISC_RESTART; ++i)
    {
        VERIFY(strFmt.LoadString(nOption++));
        str.Format(strFmt, m_pMachine->QueryServerName());
        VERIFY(m_strDetails[i].LoadString(nDetails++));

        m_combo_Restart.AddString(str);
    }
    
    m_combo_Restart.SetCurSel(ISC_RESTART);
    m_combo_Restart.SetFocus();

    SetDetailsText();
    
    return FALSE;  
}



void 
CIISShutdownDlg::OnSelchangeComboRestart() 
/*++

Routine Description:

    Selection change notification handler.  Change the text in the details
    static text to reflect the new selection in the combo box

Arguments:

    None

Return Value:

    None

--*/
{
    SetDetailsText();
}



void 
CIISShutdownDlg::OnDblclkComboRestart() 
/*++

Routine Description:

    Double-click notification handler.  Maps to OK

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Go with the current selection
    //
    OnOK();
}



void 
CIISShutdownDlg::OnOK() 
/*++

Routine Description:

    "OK" button has been pressed, and perform the selected action.

Arguments:

    None

Return Value:

    None

--*/
{
    int iCmd = m_combo_Restart.GetCurSel();

    CError err = PerformCommand(iCmd);

    if (err.Failed())
    {
        m_pMachine->DisplayError(err);

        //
        // Failed -- do not dismiss the dialog
        //
        return;
    }

    //
    // No error, dismiss the dialog
    //
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\stdafx.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        stdafx.h

   Abstract:

        Precompiled header file

   Author:

        Just about totally auto-generated.

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __STDAFX_H__
#define __STDAFX_H__

#define VC_EXTRALEAN

#include <ctype.h>



#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED


#include <afxwin.h>
#include <afxdisp.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxtempl.h>
#include <afxcmn.h>
#include <afxdtctl.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
//#include <atlsnap.h>

#include <iiscnfg.h>
#include <inetreg.h>
#include <lmcons.h>
#include <tchar.h>

#include <aclapi.h>
#include <shlwapi.h>

#define _COMIMPORT
#include "common.h"
#include "atlsnap.h"

//{{AFX_INSERT_LOCATION}}


#endif // __STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\supdlgs.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        supdlgs.cpp

   Abstract:
        Supporting dialogs

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include <iiscnfgp.h>
#include <winsock2.h>
#include "common.h"
#include "InetMgrApp.h"
#include "supdlgs.h"




#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



#define new DEBUG_NEW



//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("Advanced");



//
// Site Security Listbox Column Definitions
//
// Note: IDS_IP_ADDRESS_SUBNET_MASK is overridden
//       in w3scfg
//
static const ODL_COLUMN_DEF g_aColumns[] =
{
// ===============================================
// Weight   Label                 
// ===============================================
    {  4,   IDS_ACCESS,                 },
    { 15,   IDS_IP_ADDRESS_SUBNET_MASK, },
};



#define NUM_COLUMNS (sizeof(g_aColumns) / sizeof(g_aColumns[0]))




//
// CUserAccountDlg dialog
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CUserAccountDlg::CUserAccountDlg(
    IN LPCTSTR lpstrServer,
    IN LPCTSTR lpstrUserName,
    IN LPCTSTR lpstrPassword,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Constructor for bringing up the user account dialog

Arguments:

    LPCTSTR lpstrServer     : Server
    LPCTSTR lpstrUserName   : Starting Username
    LPCTSTR lpstrPassword   : Starting Password
    CWnd * pParent          : Parent window handle

Return Value:

    N/A

--*/
    : m_strUserName(lpstrUserName),
      m_strPassword(lpstrPassword),
      m_strServer(lpstrServer),
      CDialog(CUserAccountDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CUserAccountDlg)
    //}}AFX_DATA_INIT
}



void 
CUserAccountDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control Data

Arguments:

    CDataExchange * pDX : DDX/DDV struct

Return Value:

    None.

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CUserAccountDlg)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_strUserName);
    DDV_MinMaxChars(pDX, m_strUserName, 1, UNLEN);
    DDX_Password(pDX, IDC_EDIT_PASSWORD, m_strPassword, g_lpszDummyPassword);
    DDV_MaxChars(pDX, m_strPassword, PWLEN);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CUserAccountDlg, CDialog)
    //{{AFX_MSG_MAP(CUserAccountDlg)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void
CUserAccountDlg::OnButtonBrowseUsers()
/*++

Routine Description:

    User browse dialog pressed, bring up
    the user browser

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(m_strServer, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}



void 
CUserAccountDlg::OnChangeEditUsername() 
/*++

Routine Description:

    Handle change in user name edit box by blanking out the password

Arguments:

    None

Return Value:

    None

--*/
{
    m_edit_Password.SetWindowText(_T(""));
}



void
CUserAccountDlg::OnButtonCheckPassword()
/*++

Routine Description:

    'Check Password' has been pressed.  Try to validate
    the password that has been entered

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(CComAuthInfo::VerifyUserPassword(m_strUserName, m_strPassword));

    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}



//
// Text dialog that warns of clear text violation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CClearTxtDlg::CClearTxtDlg(
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Clear text dialog constructor

Arguments:

    CWnd * pParent : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CClearTxtDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CClearTxtDlg)
    //}}AFX_DATA_INIT
}



void
CClearTxtDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CClearTxtDlg)
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CClearTxtDlg, CDialog)
    //{{AFX_MSG_MAP(CClearTxtDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CClearTxtDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    (GetDlgItem(IDCANCEL))->SetFocus();
    CenterWindow();
    MessageBeep(MB_ICONEXCLAMATION);

    return FALSE;
}


IMPLEMENT_DYNAMIC(CIPAccessDescriptorListBox, CHeaderListBox);




//
// Bitmap indices
//
enum
{
    BMPID_GRANTED = 0,
    BMPID_DENIED,
    BMPID_SINGLE,
    BMPID_MULTIPLE,

    //
    // Don't move this one
    //
    BMPID_TOTAL
};




const int CIPAccessDescriptorListBox::nBitmaps = BMPID_TOTAL;




CIPAccessDescriptorListBox::CIPAccessDescriptorListBox(
    IN BOOL fDomainsAllowed
    )
/*++

Routine Description:

    Constructor

Arguments:

    fDomainsAllowed : TRUE if domain names are legal.

Return Value:

    N/A

--*/
    : m_fDomainsAllowed(fDomainsAllowed),
      CHeaderListBox(HLS_STRETCH, g_szRegKey)
{
    m_strGranted.LoadString(IDS_GRANTED);
    m_strDenied.LoadString(IDS_DENIED);
    m_strFormat.LoadString(IDS_FMT_SECURITY);
}




void
CIPAccessDescriptorListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds : Draw item structure

Return Value:

    None

--*/
{
    CIPAccessDescriptor * p = (CIPAccessDescriptor *)ds.m_ItemData;
    ASSERT_READ_PTR(p);

    //
    // Display Granted/Denied with appropriate bitmap
    //
    DrawBitmap(ds, 0, p->HasAccess() ? BMPID_GRANTED : BMPID_DENIED);
    ColumnText(ds, 0, TRUE, p->HasAccess() ? m_strGranted : m_strDenied);

    //
    // Display IP Address with multiple/single bitmap
    //
    DrawBitmap(ds, 1, p->IsSingle() ? BMPID_SINGLE : BMPID_MULTIPLE);

    if (p->IsDomainName())
    {
        ColumnText(ds, 1, TRUE, p->QueryDomainName());
    }
    else if (p->IsSingle())
    {
        //
        // Display only ip address
        //
        ColumnText(ds, 1, TRUE, p->QueryIPAddress());
    }
    else
    {
        //
        // Display ip address/subnet mask
        //
        CString str, strIP, strMask;

        str.Format(
            m_strFormat, 
            (LPCTSTR)p->QueryIPAddress().QueryIPAddress(strIP), 
            (LPCTSTR)p->QuerySubnetMask().QueryIPAddress(strMask)
            );
        ColumnText(ds, 1, TRUE, str);
    }
}




/* virtual */
BOOL 
CIPAccessDescriptorListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay 
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    HINSTANCE hInst = AfxGetResourceHandle();
    for (int nCol = 0; nCol < NUM_COLUMNS; ++nCol)
    {
        InsertColumn(nCol, g_aColumns[nCol].nWeight, g_aColumns[nCol].nLabelID, hInst);
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}




//
// CAccessEntryListBox - a listbox of user SIDs
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNAMIC(CAccessEntryListBox, CRMCListBox);



const int CAccessEntryListBox::nBitmaps = 8;



void
CAccessEntryListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

   Draw item in the listbox

Arguments:

    CRMCListBoxDrawStruct & ds   : Input data structure

Return Value:

    N/A

--*/
{
    CAccessEntry * pEntry = (CAccessEntry *)ds.m_ItemData;
    ASSERT_READ_PTR(pEntry);
    ASSERT(pEntry->IsSIDResolved());

    DrawBitmap(ds, 0, pEntry->QueryPictureID());
    ColumnText(ds, 0, TRUE, pEntry->QueryUserName());
}



void
CAccessEntryListBox::FillAccessListBox(
    IN CObListPlus & obl
    )
/*++

Routine Description:

    Fill a listbox with entries from the oblist.

    Entries will not be shown if the deleted flag is set, or if
    their access mask does not fit with the requested access mask.

Arguments:

    CObListPlus & obl       : List of access entries

Return Value:

    None.

--*/
{
    CObListIter obli(obl);
    CAccessEntry * pAccessEntry;

    //
    // Remember the selection.
    //
    CAccessEntry * pSelEntry = GetSelectedItem();

    SetRedraw(FALSE);
    ResetContent();
    int cItems = 0;

    for ( /**/ ; pAccessEntry = (CAccessEntry *)obli.Next(); ++cItems)
    {
        if (pAccessEntry->IsVisible() && !pAccessEntry->IsDeleted())
        {
            AddItem(pAccessEntry);
        }
    }

    SetRedraw(TRUE);
    SelectItem(pSelEntry);
}



void 
CAccessEntryListBox::ResolveAccessList(
    IN CObListPlus &obl
    )
/*++

Routine Description:

    For each member of the list, resolve the SID into a username.

Arguments:

    CObListPlus & obl       : List of access entries

Return Value:

    None.

--*/
{
    CObListIter obli(obl);
    CAccessEntry * pAccessEntry;

    while (pAccessEntry = (CAccessEntry *)obli.Next())
    {
        if (!pAccessEntry->IsSIDResolved())
        {
            pAccessEntry->ResolveSID();
        }
    }
}



BOOL
CAccessEntryListBox::AddUserPermissions(
    IN LPCTSTR lpstrServer,
    IN CObListPlus &oblSID,
    IN CAccessEntry * newUser,
    IN ACCESS_MASK accPermissions
    )
/*++

Routine Description:

    Add a user to the service list.  The return value is
    what would be its listbox index.

Arguments:

    LPCTSTR lpstrServer             : Server name
    CObListPlus &oblSID             : List of SIDs
    CAccessEntry * newUser          : User details from user browser
    ACCESS_MASK accPermissions      : Access permissions

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    CAccessEntry * pAccessEntry;

    //
    // Look it up in the list to see if it exists already
    //
    CObListIter obli(oblSID);

    while(pAccessEntry = (CAccessEntry *)obli.Next())
    {
        if (*pAccessEntry == newUser->GetSid())
        {
            TRACEEOLID("Found existing account -- adding permissions");

            if (pAccessEntry->IsDeleted())
            {
                //
                // Back again..
                //
                pAccessEntry->FlagForDeletion(FALSE);
            }
            break;
        }
    }

    if (pAccessEntry == NULL)
    {
        //
        // I am creating new entry here to be sure that I could delete 
        // it from the input array. The SID is copied to new entry.
        //
        pAccessEntry = new CAccessEntry(*newUser);
        if (pAccessEntry)
        {
	        pAccessEntry->MarkEntryAsNew();
   	     oblSID.AddTail(pAccessEntry);
   	  }
   	  else
   	  {
		     return FALSE;
		  }
    }

    pAccessEntry->AddPermissions(accPermissions);

    return TRUE;
}


/*

BOOL
CAccessEntryListBox::AddUserPermissions(
    IN LPCTSTR lpstrServer,
    IN CObListPlus &oblSID,
    IN LPUSERDETAILS pusdtNewUser,
    IN ACCESS_MASK accPermissions
    )
/*++

Routine Description:

    Add a user to the service list.  The return value is
    the what would be its listbox index.

Arguments:

    LPCTSTR lpstrServer             : Server name
    CObListPlus &oblSID             : List of SIDs
    LPUSERDETAILS pusdtNewUser      : User details from user browser
    ACCESS_MASK accPermissions      : Access permissions

Return Value:

    TRUE for success, FALSE for failure.

--/
{
    //
    // Look it up in the list to see if it exists already
    //
    CObListIter obli(oblSID);
    CAccessEntry * pAccessEntry;

    while(pAccessEntry = (CAccessEntry *)obli.Next())
    {
        if (*pAccessEntry == pusdtNewUser->psidUser)
        {
            TRACEEOLID("Found existing account -- adding permissions");

            if (pAccessEntry->IsDeleted())
            {
                //
                // Back again..
                //
                pAccessEntry->FlagForDeletion(FALSE);
            }
            break;
        }
    }

    if (pAccessEntry == NULL)
    {
        TRACEEOLID("This account did not yet exist -- adding new one");

        pAccessEntry = new CAccessEntry(accPermissions,
            pusdtNewUser->psidUser,
            lpstrServer,
            TRUE
            );

        if (!pAccessEntry)
        {
            TRACEEOLID("AddUserPermissions: OOM");
            return FALSE;
        }

        pAccessEntry->MarkEntryAsNew();
        oblSID.AddTail(pAccessEntry);
    }
    else
    {
        pAccessEntry->AddPermissions(accPermissions);
    }

    return TRUE;
}


*/



BOOL
CAccessEntryListBox::AddToAccessList(
    IN  CWnd * pWnd,
    IN  LPCTSTR lpstrServer,
    OUT CObListPlus & obl
    )
/*++

Routine Description:

    Bring up the Add Users and Groups dialogs from netui.

Arguments:

    CWnd * pWnd             : Parent window
    LPCTSTR lpstrServer     : Server that owns the accounts
    CObListPlus & obl       : Returns the list of selected users.

Return Value:

    TRUE if anything was added, FALSE otherwise.

--*/
{
    CGetUsers usrBrowser(lpstrServer, TRUE);
    BOOL bRes = usrBrowser.GetUsers(pWnd->GetSafeHwnd());
    UINT cItems = 0;

    if (bRes)
    {
        //
        // Specify access mask for an operator
        //
        ACCESS_MASK accPermissions =
            (MD_ACR_READ | MD_ACR_WRITE | MD_ACR_ENUM_KEYS);

        for (int i = 0; i < usrBrowser.GetSize(); i++)
        {
            if (!AddUserPermissions(lpstrServer, obl, usrBrowser[i], accPermissions))
            {
                bRes = FALSE;
                break;
            }

            cItems++;
        }
    }
    if (cItems > 0)
    {
        FillAccessListBox(obl);
    }
    return bRes;
}



CDnsNameDlg::CDnsNameDlg(
    IN CIPAddressCtrl * pIpControl OPTIONAL,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Construct with optional associated IP address control

Arguments:

    CWndIpAddress * pIpControl : Associated IP control
    CWnd * pParent             : Pointer to parent window

Return Value:

    N/A

--*/
    : m_pIpControl(pIpControl),
      m_dwIPValue(0L),
      CDialog(CDnsNameDlg::IDD, pParent)
{
#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CDnsNameDlg)
    //}}AFX_DATA_INIT

#endif // 0

    if (m_pIpControl)
    {
        m_pIpControl->GetAddress(m_dwIPValue);
    }
}



CDnsNameDlg::CDnsNameDlg(
    IN DWORD dwIPValue,
    IN CWnd * pParent OPTIONAL
    )
/*++

Routine Description:

    Construct with associated IP value

Arguments:

    DWORD dwIPValue : IP Value
    CWnd * pParent  : Pointer to parent window

Return Value:

    N/A

--*/
    : m_pIpControl(NULL),
      m_dwIPValue(dwIPValue),
      CDialog(CDnsNameDlg::IDD, pParent)
{
}



void
CDnsNameDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDnsNameDlg)
    DDX_Control(pDX, IDC_EDIT_DNS_NAME, m_edit_DNSName);
    DDX_Control(pDX, IDOK, m_button_OK);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CDnsNameDlg, CDialog)
    //{{AFX_MSG_MAP(CDnsNameDlg)
    ON_EN_CHANGE(IDC_EDIT_DNS_NAME, OnChangeEditDnsName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



DWORD 
CDnsNameDlg::FillIpControlFromName()
/*++

Routine Description:

    Do a DNS lookup from the hostname in the edit control, and place
    the ip value in the ip control if we have one.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CString str;
    DWORD err = 0;
    HOSTENT * pHostent = NULL;

    m_edit_DNSName.GetWindowText(str);

    BeginWaitCursor();

#ifdef _UNICODE

    CHAR * pAnsi = AllocAnsiString(str);

    if (pAnsi == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    
    pHostent = ::gethostbyname(pAnsi);

#else

    pHostent = ::gethostbyname((LPCTSTR)str);

#endif // _UNICODE;

    if (pHostent != NULL)
    {
        //
        // Got a valid lookup.  Convert the value to host order,
        // optionally set the value in the associated ip control
        //
        m_dwIPValue = ::ntohl(*((u_long *)pHostent->h_addr_list[0]));
        if (m_pIpControl)
        {
            m_pIpControl->SetAddress(m_dwIPValue);
        }
    }
    else
    {
        err = ::WSAGetLastError();
    }

    EndWaitCursor();

#ifdef _UNICODE

    FreeMem(pAnsi);

#endif // _UNICODE

    return err;
}



DWORD
CDnsNameDlg::FillNameFromIpValue()
/*++

Routine Description:

    Given the ip value, fill, do a reverse lookup, and fill the name in
    the edit control.

Arguments:

    None

Return Value:

    Error return code

--*/
{
    DWORD err = ERROR_SUCCESS;

    if (m_dwIPValue == 0L)
    {
        //
        // Don't bother filling this
        // one in -- not an error, though
        //
        return err;
    }

    //
    // Call the Winsock API to get host name and alias information.
    //
    u_long ulAddrInNetOrder = ::htonl((u_long)m_dwIPValue);

    BeginWaitCursor();
    HOSTENT * pHostInfo = ::gethostbyaddr(
        (CHAR *)&ulAddrInNetOrder,
        sizeof ulAddrInNetOrder, 
        PF_INET 
        );
    EndWaitCursor();

    if (pHostInfo == NULL)
    {
        return ::WSAGetLastError();
    }

    try
    {
        CString str(pHostInfo->h_name);
        m_edit_DNSName.SetWindowText(str);
    }
    catch(CException * e)
    {
        err = ::GetLastError();
        e->Delete();
    }

    return err;
}

//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

void
CDnsNameDlg::OnOK()
/*++

Routine Description:

    Attempt to resolve the the IP address in response to the OK button
    being pressed.  Don't dismiss the dialog if the name is not
    resolvable.

Arguments:

    None

Return Value:

    None

--*/
{
    CError err(FillIpControlFromName());
    if (err.Failed())
    {
		UINT errId = 0;

		if (err.Win32Error() == WSAHOST_NOT_FOUND)
		{
			errId = IDS_WSAHOST_NOT_FOUND;
		}
		if (errId == 0)
		{
			err.MessageBoxOnFailure();
		}
		else
		{
			::AfxMessageBox(errId);
		}
        //
        // Failed, don't dismiss the dialog
        //
        return;
    }

    //
    // Dismiss the dialog
    //
    CDialog::OnOK();
}



void
CDnsNameDlg::OnChangeEditDnsName()
/*++

Routine Description:

    Enable/disable the ok button depending on the contents of the edit control.

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_OK.EnableWindow(m_edit_DNSName.GetWindowTextLength() > 0);
}



BOOL 
CDnsNameDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    //
    // If an address has been pre-set do a reverse lookup
    //
    if (m_dwIPValue)
    {
        CError err(FillNameFromIpValue());
        err.MessageBoxOnFailure();
    }

    OnChangeEditDnsName();

    return TRUE;
}



//
// IP Access Dialog
//



CIPAccessDlg::CIPAccessDlg(
    IN BOOL fDenyAccessMode,
    IN OUT CIPAccessDescriptor *& pAccess,
    IN CObListPlus * poblAccessList         OPTIONAL,
    IN CWnd * pParent                       OPTIONAL,
    IN BOOL fAllowDomains
    )
/*++

Routine Description:

    Constructor for the access descriptor editor dialog.  If constructed
    with a NULL access descriptor pointer, the access descriptor will
    be allocated, otherwise the dialog will edit the existing one in
    place.

Arguments:

    BOOL fDenyAccessMode         : If TRUE, we're denying access, if FALSE,
                                   we're granting access.
    CIPAccessDescriptor *& pAccess : Object being edited, or NULL to allocate 
                                   a new access descriptor
    CObListPlus * poblAccessList : List of already existing entries to check
                                   for duplicates, or NULL
    CWnd * pParent,              : Pointer to parent window or NULL
    BOOL fAllowDomains           : If TRUE, domain names are valid, otherwise
                                   they will not be available

Return Value:

    N/A

--*/
    : CDialog(CIPAccessDlg::IDD, pParent),
      m_pAccess(pAccess),
      m_poblAccessList(poblAccessList),
      m_fNew(pAccess == NULL),
      m_fDenyAccessMode(fDenyAccessMode),
      m_fAllowDomains(fAllowDomains)
{
#if 0   // Keep Class Wizard happy

    //{{AFX_DATA_INIT(CIPAccessDlg)
    m_nStyle = RADIO_SINGLE;
    //}}AFX_DATA_INIT

#endif // 0

    if (m_pAccess == NULL)
    {
        //
        // Allocate new one
        //
        m_pAccess = new CIPAccessDescriptor;

        if (m_pAccess)
        {
            m_pAccess->GrantAccess(!m_fDenyAccessMode);
        }
    }

    if (m_pAccess == NULL)
    {
        TRACEEOLID("Invalid access object -- possible memory failure");
        return;
    }
    
    if (m_pAccess->IsDomainName())
    {
        m_nStyle = RADIO_DOMAIN;
    }
    else
    {
        m_nStyle = m_pAccess->IsSingle() ? RADIO_SINGLE : RADIO_MULTIPLE;
    }

    //
    // We can only look at granted items when
    // deny by default is on and vice versa
    //
    ASSERT(m_pAccess->HasAccess() == !m_fDenyAccessMode);

    //
    // Load static strings
    //
    VERIFY(m_bstrIPAddress.LoadString(IDS_PROMPT_IP_ADDRESS));
    VERIFY(m_bstrNetworkID.LoadString(IDS_PROMPT_NETWORK_ID));
    VERIFY(m_bstrDomainName.LoadString(IDS_PROMPT_DOMAIN));
}



void
CIPAccessDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIPAccessDlg)
    DDX_Control(pDX, IDOK, m_button_OK);
    DDX_Control(pDX, IDC_EDIT_DOMAIN, m_edit_Domain);
    DDX_Control(pDX, IDC_STATIC_IP_ADDRESS, m_static_IpAddress);
    DDX_Control(pDX, IDC_STATIC_SUBNET_MASK, m_static_SubnetMask);
    DDX_Control(pDX, IDC_BUTTON_DNS, m_button_DNS);
    DDX_Radio(pDX, IDC_RADIO_SINGLE, m_nStyle);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_RADIO_DOMAIN, m_radio_Domain);
    DDX_Control(pDX, IDC_IPA_IPADDRESS, m_ipa_IPAddress);
    DDX_Control(pDX, IDC_IPA_SUBNET_MASK, m_ipa_SubnetMask);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CIPAccessDlg, CDialog)
    //{{AFX_MSG_MAP(CIPAccessDlg)
    ON_BN_CLICKED(IDC_RADIO_MULTIPLE, OnRadioMultiple)
    ON_BN_CLICKED(IDC_RADIO_SINGLE, OnRadioSingle)
    ON_BN_CLICKED(IDC_RADIO_DOMAIN, OnRadioDomain)
    ON_BN_CLICKED(IDC_BUTTON_DNS, OnButtonDns)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_IPA_IPADDRESS, OnItemChanged)
    ON_EN_CHANGE(IDC_IPA_SUBNET_MASK, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN, OnItemChanged)

END_MESSAGE_MAP()



void
CIPAccessDlg::SetControlStates(
    IN int nStyle
    )
/*++

Routine Description:

    Show/hide controls depending on the type of access descriptor we're
    editing.

Arguments:

    int nStyle : Radio button style

Return Value:

    None

--*/
{
    m_nStyle = nStyle;

    ActivateControl(m_ipa_IPAddress,     m_nStyle != RADIO_DOMAIN);
    ActivateControl(m_static_SubnetMask, m_nStyle == RADIO_MULTIPLE);
    ActivateControl(m_ipa_SubnetMask,    m_nStyle == RADIO_MULTIPLE);
    ActivateControl(m_button_DNS,        m_nStyle == RADIO_SINGLE);
    ActivateControl(m_edit_Domain,       m_nStyle == RADIO_DOMAIN);

    //
    // Change the prompt over the editbox/ip address box to explain
    // what's supposed to be edited.
    //
    switch(m_nStyle)
    {
    case RADIO_SINGLE:
        m_static_IpAddress.SetWindowText(m_bstrIPAddress);
        break;

    case RADIO_MULTIPLE:
        m_static_IpAddress.SetWindowText(m_bstrNetworkID);
        break;

    case RADIO_DOMAIN:
        ASSERT(m_fAllowDomains);
        m_static_IpAddress.SetWindowText(m_bstrDomainName);
        break;
    }
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CIPAccessDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    ASSERT_READ_PTR(m_pAccess);

    if (m_pAccess == NULL)
    {
        CError err(ERROR_NOT_ENOUGH_MEMORY);
        TRACEEOLID("access descriptor is NULL -- aborting dialog");
        err.MessageBox();
        EndDialog(IDCANCEL);

        return FALSE;
    }

    //
    // Domain selection not always available
    //
    ASSERT(!(!m_fAllowDomains && m_pAccess->IsDomainName()));
    ActivateControl(m_radio_Domain, m_fAllowDomains);

    //
    // Use an appropriate title for the dialog depending on
    // whether we're editing a 'grant' item or a 'deny' item
    //
    CComBSTR bstrTitle;
    
    VERIFY(bstrTitle.LoadString(m_fDenyAccessMode ? IDS_DENY : IDS_GRANT));
    SetWindowText(bstrTitle);

    //
    // Set fields to be edited
    //
    if (m_pAccess->IsDomainName())
    {
        m_edit_Domain.SetWindowText(m_pAccess->QueryDomainName());    
    }
    else
    {
        DWORD dwIP = m_pAccess->QueryIPAddress();

        if (dwIP != 0L)
        {
            m_ipa_IPAddress.SetAddress(m_pAccess->QueryIPAddress());
        }

        if (!m_pAccess->IsSingle())
        {
            m_ipa_SubnetMask.SetAddress(m_pAccess->QuerySubnetMask());
        }
    }

    //
    // Configure the dialog appropriately
    //
    SetControlStates(m_nStyle);

    //
    // No changes made yet
    //
    m_button_OK.EnableWindow(FALSE);

    return TRUE;
}



void
CIPAccessDlg::OnRadioSingle()
/*++

Routine Description:

    'Single' radio button has been pressed. Change dialog style 
    appropriately.

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates(RADIO_SINGLE);
    OnItemChanged();
}



void
CIPAccessDlg::OnRadioMultiple()
/*++

Routine Description:

    'Multiple' radio button has been pressed. Change dialog style 
    appropriately.

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates(RADIO_MULTIPLE);
    OnItemChanged();
}



void 
CIPAccessDlg::OnRadioDomain() 
/*++

Routine Description:

    'Domain' radio button has been pressed. Change dialog style 
    appropriately.  If this the first time domain has been pressed,
    put up a warning about the performance implications of using
    domain filtering.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_fAllowDomains);

    static BOOL fShownWarning = FALSE;

    if (!fShownWarning)
    {
        fShownWarning = TRUE;
        ::AfxMessageBox(IDS_DOMAIN_PERF);
    }

    SetControlStates(RADIO_DOMAIN);
    OnItemChanged();
}



void 
CIPAccessDlg::OnItemChanged()
/*++

Routine Description:

    Control data has changed.  Check to see if sufficient data have been
    entered given the type of access descriptor being edited, and enable
    or disable the OK button based on that result.

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwIP;
    DWORD dwMask;
    BOOL fOK = FALSE;
    CString strDomain;

    switch(m_nStyle)
    {
    case RADIO_DOMAIN:
        m_edit_Domain.GetWindowText(strDomain);
        fOK = !strDomain.IsEmpty();
        break;

    case RADIO_SINGLE:
        m_ipa_IPAddress.GetAddress(dwIP);
        fOK = (dwIP != 0L);
        break;

    case RADIO_MULTIPLE:
        m_ipa_IPAddress.GetAddress(dwIP);
        m_ipa_SubnetMask.GetAddress(dwMask);
        fOK = (dwIP != 0L && dwMask != 0L);
        break;
    }
    
    m_button_OK.EnableWindow(fOK);
}



void 
CIPAccessDlg::OnButtonDns() 
/*++

Routine Description:

    'DNS' Button was pressed.  Bring up the DNS name resolver dialog
    which will set the value in the associated IP address control.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for a DNS name to resolve to an IP address.  The ip address
    // control is passed along to the dns name dialog which will manage
    // the ip addresses in it automatically.
    //
    CDnsNameDlg dlg(&m_ipa_IPAddress);
    dlg.DoModal();
}



void
CIPAccessDlg::OnCancel()
/*++

Routine Description:

    IDCANCEL handler.  If we had allocated the access descriptor, throw it
    away now.

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fNew && m_pAccess != NULL)
    {
        delete m_pAccess;
        m_pAccess = NULL;
    }

    CDialog::OnCancel();
}



void
CIPAccessDlg::OnOK()
/*++

Routine Description:

    Handler for IDOK.  Save control data to the access descriptor object
    being edited.  If we have a list of access descriptors, check for
    duplicates.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Must have been allocated by now.
    //
    ASSERT_READ_PTR(m_pAccess);

    UpdateData(TRUE);

    if (m_nStyle == RADIO_DOMAIN)
    {
        CString strDomain;
        m_edit_Domain.GetWindowText(strDomain);

        //
        // Ensure that wildcards are used only in the first char
        // of the name, or not at all.
        //
        int nWildCard;
        if ((nWildCard = strDomain.ReverseFind(_T('*'))) != -1)
        {
            if (nWildCard != 0 
                || strDomain.GetLength() < 3 
                || strDomain[1] != _T('.'))
            {
                //
                // Don't dismiss
                //
                m_edit_Domain.SetFocus();
                m_edit_Domain.SetSel(0,-1);
                ::AfxMessageBox(IDS_INVALID_DOMAIN_NAME);
                return;
            }
        }

        m_pAccess->SetValues(!m_fDenyAccessMode, strDomain);
    }
    else 
    {
        DWORD dwIP;
        m_ipa_IPAddress.GetAddress(dwIP);

        //
        // Filter out bogus ip addresses
        //
        if (dwIP == 0L || dwIP == (DWORD)-1L)
        {
            //
            // Don't dismiss the dialog
            //
            m_ipa_IPAddress.SetFocus();
            ::AfxMessageBox(IDS_IP_INVALID);
            return;
        }

        if (m_nStyle == RADIO_SINGLE)
        {
            m_pAccess->SetValues(!m_fDenyAccessMode, dwIP);
        }
        else // Multiple
        {
            DWORD dwMask;
            m_ipa_SubnetMask.GetAddress(dwMask);

            m_pAccess->SetValues(!m_fDenyAccessMode, dwIP, dwMask);
        }
    }

    //
    // Check for duplicates in the list
    //
    if (m_poblAccessList)
    {
        if (m_pAccess->DuplicateInList(*m_poblAccessList))
        {
            //
            // Found duplicate; don't dismiss the dialog
            //
            ::AfxMessageBox(IDS_DUPLICATE_ENTRY);
            return;
        }
    }

    //
    // Everything ok -- dismiss the dialog.
    //
    EndDialog(IDOK);
}

void CALLBACK MsgBoxCallback(LPHELPINFO lpHelpInfo)
{

#ifdef _DEBUG
    TCHAR szBuffer[30];
    _stprintf(szBuffer,_T("AfxGetApp()->WinHelp:0x%x\n"),lpHelpInfo->dwContextId);OutputDebugString(szBuffer);
#endif

	AfxGetApp()->WinHelp(lpHelpInfo->dwContextId);
} 

// this version accepts a text string
UINT IisMessageBox(HWND hWnd, LPCTSTR szText, UINT nType, UINT nIDHelp = 0)
{
	MSGBOXPARAMS mbp;

	memset(&mbp, 0, sizeof mbp);

	mbp.cbSize = sizeof MSGBOXPARAMS; 
	mbp.hwndOwner = hWnd; 
	mbp.hInstance = AfxGetInstanceHandle(); 
	mbp.lpszText = szText; 

	// if you wanted to specify a different caption, here is where you do it
	CString cap;
	cap.LoadString(IDS_APP_NAME);
	mbp.lpszCaption = cap; 

	// if Help ID is not 0, then add a help button
	if (nIDHelp != 0)
	{
		mbp.dwStyle = nType | MB_HELP; 
	}
	else
	{
		mbp.dwStyle = nType; 
	}

	//  mbp.lpszIcon = ; // note, you could provide your own custom ICON here!

	mbp.dwContextHelpId = nIDHelp; 
	mbp.lpfnMsgBoxCallback = &MsgBoxCallback; 
//	mbp.dwLanguageId = 0x0409;
	
	return ::MessageBoxIndirect(&mbp); 
}

// this version accepts a resource string identifier
UINT IisMessageBox(HWND hWnd, UINT nIDText, UINT nType, UINT nIDHelp = 0)
{
	CString s;
	s.LoadString(nIDText);
	return IisMessageBox(hWnd, s, nType, nIDHelp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\supdlgs.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        supdlgs.h

   Abstract:
        Supporting dialogs definitions

   Author:
        Ronald Meijer (ronaldm)
		Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

UINT IisMessageBox(HWND hWnd, LPCTSTR szText, UINT nType, UINT nIDHelp);
UINT IisMessageBox(HWND hWnd, UINT nIDText, UINT nType, UINT nIDHelp);


class CUserAccountDlg : public CDialog
/*++

Class Description:

    User account dialog.  Present a user account/password and allow
    changing, browsing and checking the password

Public Interface:

    CUserAccountDlg : Constructor

--*/
{
//
// Construction
//
public:
    CUserAccountDlg(
        IN LPCTSTR lpstrServer,
        IN LPCTSTR lpstrUserName,
        IN LPCTSTR lpstrPassword,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
public:
    //{{AFX_DATA(CUserAccountDlg)
    enum { IDD = IDD_USER_ACCOUNT };
    CEdit   m_edit_UserName;
    CEdit   m_edit_Password;
    CString m_strUserName;
    //}}AFX_DATA

    CString m_strPassword;
//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CUserAccountDlg)
	protected:
    virtual void DoDataExchange(CDataExchange * pDX);
	//}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CUserAccountDlg)
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnButtonCheckPassword();
    afx_msg void OnChangeEditUsername();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CString m_strServer;
};



class CClearTxtDlg : public CDialog
/*++

Class Description:

    Dialog which displays the clear text warning

Public Interface:

    CClearTxtDlg : Constructor
    
--*/
{
public:
    //
    // Constructor
    //
    CClearTxtDlg(CWnd * pParent = NULL);

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CClearTxtDlg)
    enum { IDD = IDD_CLEARTEXTWARNING };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CClearTxtDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CClearTxtDlg)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};



class CIPAccessDescriptorListBox : public CHeaderListBox
/*++

Class Description:

    Listbox of CIPAccessDescriptor objects

Public Interface:

    CIPAccessDescriptorListBox : Constructor

    GetItem                  : Get CIPAccessDescriptor item at specified position
                               in the listbox
    AddItem                  : Add new CIPAccessDescriptor item to the listbox
    Initialize               : Initialize the listbox

--*/
{
    DECLARE_DYNAMIC(CIPAccessDescriptorListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;

//
// Constructor/Destructor
//
public:
    CIPAccessDescriptorListBox(
        IN BOOL fDomainsAllowed = FALSE
        );

//
// Interface
//
public:
    CIPAccessDescriptor * GetItem(
        IN UINT nIndex
        );

    int AddItem(
        IN const CIPAccessDescriptor * pItem
        );

    //
    // Return the singly selected item, or NULL
    // if 0, or more than one item is selected
    //
    CIPAccessDescriptor * GetSelectedItem(
        OUT int * pnSel = NULL
        );

    //
    // Return next selected listbox item (doesn't matter
    // if the listbox is single select or multi-select)
    //
    CIPAccessDescriptor * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & ds
        );

protected:
    BOOL m_fDomainsAllowed;
    CString m_strGranted;
    CString m_strDenied;
    CString m_strFormat;
};



class CAccessEntryListBox : public CRMCListBox
/*++

Class Description:

    Listbox of access entry objects.  Listbox may be
    single or multiselect.

Public Interface:

    CAccessEntryListBox     : Constructor

    AddToAccessList         : Add to list
    FillAccessListBox       : Fill listbox
    ResolveAccessList       : Resolve all SIDS in the container
    AddUserPermissions      : Add user permissions
    GetSelectedItem         : Get item if it's the only one selected,
                              or NULL.

--*/
{
    DECLARE_DYNAMIC(CAccessEntryListBox);

public:
    static const nBitmaps;  // Number of bitmaps

//
// Constructor
//
public:
    CAccessEntryListBox(
        IN int nTab = 0
        );

//
// Interface
//
public:
    //
    // Return the singly selected item, or NULL
    // if 0, or more than one item is selected
    //
    CAccessEntry * GetSelectedItem(
        OUT int * pnSel = NULL
        );

    //
    // Return next selected listbox item (doesn't matter
    // if the listbox is single select or multi-select)
    //
    CAccessEntry * GetNextSelectedItem(
        IN OUT int * pnStartingIndex
        );

    //
    // Get item at selection or NULL
    //
    CAccessEntry * GetItem(UINT nIndex);

//
// Interface to container
//
public:
    BOOL AddToAccessList(
        IN CWnd * pWnd,
        IN LPCTSTR lpstrServer,
        IN CObListPlus & obl
        );

    void FillAccessListBox(
        IN CObListPlus & obl
        );

protected:
    void ResolveAccessList(
        IN CObListPlus &obl
        );

    BOOL AddUserPermissions(
        IN LPCTSTR lpstrServer,
        IN CObListPlus &oblSID,
        IN CAccessEntry * newUser,
        IN ACCESS_MASK accPermissions
        );

//
// Interface to listbox
//
protected:
    int AddItem(CAccessEntry * pItem);
    void SetTabs(int nTab);

protected:
    virtual void DrawItemEx(CRMCListBoxDrawStruct & s);

private:
    int m_nTab;
};


class CDnsNameDlg : public CDialog
{
/*++

Class Description:

    DNS Name resolution dialog.  Enter a DNS name, and this will be
    resolved to an IP address.  Optionally set the value in associated
    ip control.

Public Interface:

    CDnsNameDlg   : Construct the dialog

    QueryIPValue  : Find out the resolved IP address (only set when OK
                    is pressed).

--*/
//
// Construction
//
public:
    //
    // Construct with associated IP address control
    //
    CDnsNameDlg(
        IN CIPAddressCtrl * pIpControl = NULL,
        IN CWnd * pParent = NULL
        );

    //
    // Construct with IP value
    //
    CDnsNameDlg(
        IN DWORD dwIPValue,
        IN CWnd * pParent = NULL
        );

    DWORD QueryIPValue() const;

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CDnsNameDlg)
    enum { IDD = IDD_DNS };
    CEdit   m_edit_DNSName;
    CButton m_button_OK;
    //}}AFX_DATA


//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CDnsNameDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CDnsNameDlg)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    afx_msg void OnChangeEditDnsName();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    DWORD FillIpControlFromName();
    DWORD FillNameFromIpValue();

private:
    CIPAddressCtrl * m_pIpControl;
    DWORD m_dwIPValue;
};



class CIPAccessDlg : public CDialog
/*++

Class Description:

    Access description editor dialog.  If constructed with a NULL access
    descriptor pointer, the access descriptor object will be allocated.
    Otherwise, the dialog will work with the given access descriptor

Public Interface:

    CIPAccessDlg : Constructor

--*/
{
//
// Construction
//
public:
    //
    // standard constructor
    //
    CIPAccessDlg(
        IN BOOL fDenyAccessMode,
        IN OUT CIPAccessDescriptor *& pAccess,
        IN CObListPlus * poblAccessList = NULL,
        IN CWnd * pParent = NULL,
        IN BOOL fAllowDomains = FALSE
        );

//
// Dialog Data
//
protected:
    //
    // Must match type order
    //
    enum
    {
        RADIO_SINGLE,
        RADIO_MULTIPLE,
        RADIO_DOMAIN,
    };

    //{{AFX_DATA(CIPAccessDlg)
    enum { IDD = IDD_IP_ACCESS };
    int     m_nStyle;
    CEdit   m_edit_Domain;
    CStatic m_static_IpAddress;
    CStatic m_static_SubnetMask;
    CButton m_button_DNS;
    CButton m_button_OK;
    //}}AFX_DATA

    CButton       m_radio_Domain;
    CIPAddressCtrl m_ipa_IPAddress;
    CIPAddressCtrl m_ipa_SubnetMask;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CIPAccessDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CIPAccessDlg)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    virtual void OnCancel();
    afx_msg void OnRadioMultiple();
    afx_msg void OnRadioSingle();
    afx_msg void OnRadioDomain();
    afx_msg void OnButtonDns();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void SetControlStates(
        IN int nStyle
        );

private:
    BOOL m_fNew;
    BOOL m_fDenyAccessMode;
    BOOL m_fAllowDomains;
    CComBSTR m_bstrIPAddress;
    CComBSTR m_bstrNetworkID;
    CComBSTR m_bstrDomainName;
    CIPAccessDescriptor *& m_pAccess;
    CObListPlus * m_poblAccessList;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CAccessEntryListBox::CAccessEntryListBox (
    IN int nTab
    )
{
    SetTabs(nTab);
}

inline void CAccessEntryListBox::SetTabs(
    IN int nTab
    )
{
    m_nTab = nTab;
}

inline CAccessEntry * CAccessEntryListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CAccessEntry *)GetItemDataPtr(nIndex);
}

inline int CAccessEntryListBox::AddItem(
    IN CAccessEntry * pItem
    )
{
    return AddString ((LPCTSTR)pItem);
}

inline CAccessEntry * CAccessEntryListBox::GetSelectedItem(
    OUT int * pnSel
    )
{
    return (CAccessEntry *)CRMCListBox::GetSelectedListItem(pnSel);
}

inline CAccessEntry * CAccessEntryListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CAccessEntry *)CRMCListBox::GetNextSelectedItem(pnStartingIndex);
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CIPAccessDescriptor *)GetItemDataPtr(nIndex);
}

inline int CIPAccessDescriptorListBox::AddItem(
    IN const CIPAccessDescriptor * pItem
    )
{
    return AddString((LPCTSTR)pItem);
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetSelectedItem(
    OUT int * pnSel
    )
{
    return (CIPAccessDescriptor *)CRMCListBox::GetSelectedListItem(pnSel);
}

inline CIPAccessDescriptor * CIPAccessDescriptorListBox::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CIPAccessDescriptor *)CRMCListBox::GetNextSelectedItem(pnStartingIndex);
}

inline DWORD CDnsNameDlg::QueryIPValue() const
{
    return m_dwIPValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\usersess.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        usersess.cpp

   Abstract:
        FTP User Sessions Dialog

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "ftpsht.h"
#include "fservic.h"
#include "usersess.h"

#include <lmerr.h>

HRESULT ImpersonateUser(LPCTSTR  pszUserName,
                        LPCTSTR  pszDomain,
                        LPCTSTR  pszPassword,
                        HANDLE  *pCurImpToken,
                        HANDLE  *pLoggedOnUserToken);
HRESULT UnImpersonateUser(HANDLE    hSavedImpToken,
                          HANDLE    hLoggedOnUser);


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Registry key name for this dialog
//
const TCHAR g_szRegKey[] = _T("User Sessions");

//
// User Sessions Listbox Column Definitions
//
static const ODL_COLUMN_DEF_EX BASED_CODE g_aColumns[] =
{
// ==================================================================================================
// Weight      Label          Sort Helper Function
// ==================================================================================================
    { 2, IDS_CONNECTED_USERS, (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByName        },
    { 1, IDS_FROM,            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByHostAddress },
    { 1, IDS_TIME,            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)&CFtpUserInfo::OrderByTime        },
};


#define NUM_COLUMNS (sizeof(g_aColumns) / sizeof(g_aColumns[0]))



CFtpUserInfo::CFtpUserInfo(LPIIS_USER_INFO_1 lpUserInfo)
/*++

Routine Description:

    Constructor

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    N/A

--*/
    : m_idUser(lpUserInfo->idUser),
      m_strUser(lpUserInfo->pszUser),
      m_fAnonymous(lpUserInfo->fAnonymous),
      //                    Network Byte Order
      //                              ||
      //                              \/
      m_iaHost(lpUserInfo->inetHost, TRUE),
      m_tConnect(lpUserInfo->tConnect)
{
}



int
CFtpUserInfo::OrderByName(
    const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by user name.  The CObjectPlus pointer 
    really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return ::lstrcmpi(QueryUserName(), pob->QueryUserName());
}



int
CFtpUserInfo::OrderByTime(
    const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by user connect time.  The CObjectPlus 
    pointer really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return QueryConnectTime() > pob->QueryConnectTime()
        ? +1
        : QueryConnectTime() == pob->QueryConnectTime()
            ? 0
            : -1;
}



int
CFtpUserInfo::OrderByHostAddress(
    const CObjectPlus * pobFtpUser
    ) const
/*++

Routine Description:

    Sorting helper function to sort by host address.  The CObjectPlus 
    pointer really refers to another CFtpUserInfo object

Arguments:

    LPIIS_USER_INFO_1 lpUserInfo : User info structure

Return Value:

    Sort return code (-1, 0, +1)

--*/
{
    const CFtpUserInfo * pob = (CFtpUserInfo *)pobFtpUser;
    ASSERT(pob != NULL);

    return QueryHostAddress().CompareItem(pob->QueryHostAddress());
}



IMPLEMENT_DYNAMIC(CFtpUsersListBox, CHeaderListBox);



//
// User listbox bitmaps
//
enum
{
    BMP_USER = 0,
    BMP_ANONYMOUS,

    //
    // Don't move this one
    //
    BMP_TOTAL
};

const int CFtpUsersListBox::nBitmaps = BMP_TOTAL;



CFtpUsersListBox::CFtpUsersListBox()
    : m_strTimeSep(_T(":")),
      CHeaderListBox(HLS_DEFAULT, g_szRegKey)
{
    //
    // Get intl time seperator
    //
    VERIFY(::GetLocaleInfo(
        ::GetUserDefaultLCID(), LOCALE_STIME, 
        m_strTimeSep.GetBuffer(10), 10));
}



void
CFtpUsersListBox::DrawItemEx(
    IN CRMCListBoxDrawStruct & ds
    )
/*++

Routine Description:

    Draw item.  This is called from the CRMCListBox base class

Arguments:

    CRMCListBoxDrawStruct & ds : Drawing structure

Return Value:

    None

--*/
{
    CFtpUserInfo * pFTPUser = (CFtpUserInfo *)ds.m_ItemData;
    ASSERT(pFTPUser != NULL);

    //
    // Display a user bitmap
    //
    DrawBitmap(ds, 0, pFTPUser->QueryAnonymous() ? BMP_ANONYMOUS : BMP_USER);
    ColumnText(ds, 0, TRUE, pFTPUser->QueryUserName());
    ColumnText(ds, 1, FALSE, pFTPUser->QueryHostAddress());

    DWORD dwTime = pFTPUser->QueryConnectTime();
    DWORD dwHours = dwTime / (60L * 60L);
    DWORD dwMinutes = (dwTime / 60L) % 60L;
    DWORD dwSeconds = dwTime % 60L;

    CString strTime;

    strTime.Format(
        _T("%d%s%02d%s%02d"),
        dwHours, (LPCTSTR)m_strTimeSep,
        dwMinutes, (LPCTSTR)m_strTimeSep,
        dwSeconds);

    ColumnText(ds, 2, FALSE, strTime);
}



/* virtual */
BOOL 
CFtpUsersListBox::Initialize()
/*++

Routine Description:

    Initialize the listbox.  Insert the columns as requested, and lay 
    them out appropriately

Arguments:

    None

Return Value:

    TRUE for succesful initialisation, FALSE otherwise

--*/
{
    if (!CHeaderListBox::Initialize())
    {
        return FALSE;
    }

    //
    // Build all columns
    //
    HINSTANCE hInst = AfxGetResourceHandle();
    for (int nCol = 0; nCol < NUM_COLUMNS; ++nCol)
    {
        InsertColumn(
            nCol, 
            g_aColumns[nCol].cd.nWeight, 
            g_aColumns[nCol].cd.nLabelID,
            hInst
            );
    }

    //
    // Try to set the widths from the stored registry value,
    // otherwise distribute according to column weights specified
    //
//    if (!SetWidthsFromReg())
//    {
        DistributeColumns();
//    }

    return TRUE;
}



CUserSessionsDlg::CUserSessionsDlg(
    LPCTSTR lpstrServerName,
    DWORD dwInstance,
    LPCTSTR pAdminName,
    LPCTSTR pAdminPassword,
    CWnd * pParent
    )
/*++

Routine Description:

    Constructor for FTP user sessions dialog

Arguments:

    LPCTSTR lpstrServerName : Server name to connect to
    CWnd * pParent          : Pointer to parent window

Return Value:

    N/A

--*/
    : m_list_Users(),
      m_ListBoxRes(IDB_USERS, m_list_Users.nBitmaps),
      m_oblFtpUsers(),
      m_strServerName(lpstrServerName),
      m_strAdminName(pAdminName),
      m_strAdminPassword(pAdminPassword),
      m_nSortColumn(0),
      m_dwInstance(dwInstance),
      m_hImpToken(INVALID_HANDLE_VALUE),
      m_hLogToken(INVALID_HANDLE_VALUE),
      CDialog(CUserSessionsDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CUserSessionsDlg)
    //}}AFX_DATA_INIT

    m_list_Users.AttachResources(&m_ListBoxRes);
    VERIFY(m_strTotalConnected.LoadString(IDS_USERS_TOTAL));
}



void 
CUserSessionsDlg::DoDataExchange(CDataExchange * pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUserSessionsDlg)
    DDX_Control(pDX, IDC_STATIC_NUM_CONNECTED, m_static_Total);
    DDX_Control(pDX, IDC_BUTTON_DISCONNECT_ALL, m_button_DisconnectAll);
    DDX_Control(pDX, IDC_BUTTON_DISCONNECT, m_button_Disconnect);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_LIST_USERS, m_list_Users);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CUserSessionsDlg, CDialog)
    //{{AFX_MSG_MAP(CUserSessionsDlg)
    ON_BN_CLICKED(IDC_BUTTON_DISCONNECT, OnButtonDisconnect)
    ON_BN_CLICKED(IDC_BUTTON_DISCONNECT_ALL, OnButtonDisconnectAll)
    ON_BN_CLICKED(IDC_BUTTON_REFRESH, OnButtonRefresh)
    ON_LBN_SELCHANGE(IDC_LIST_USERS, OnSelchangeListUsers)
    //}}AFX_MSG_MAP

    ON_NOTIFY_RANGE(HDN_ITEMCLICK, 0, 0xFFFF, OnHeaderItemClick)

END_MESSAGE_MAP()



DWORD
CUserSessionsDlg::SortUsersList()
/*++

Routine Description:

    Sort the list of ftp users on the current sorting key

Arguments:

    None

Return Value:

    ERROR return code

--*/
{
    ASSERT(m_nSortColumn >= 0 && m_nSortColumn < NUM_COLUMNS);

    BeginWaitCursor();              
    DWORD err = m_oblFtpUsers.Sort(
        (CObjectPlus::PCOBJPLUS_ORDER_FUNC)g_aColumns[m_nSortColumn].pSortFn);
    EndWaitCursor();

    return err;
}



HRESULT
CUserSessionsDlg::BuildUserList()
/*++

Routine Description:

    Call the FtpEnum api and build the list of currently connected users.

Arguments:

    None

Return Value:

    ERROR return code

--*/
{
    CError err;
    LPIIS_USER_INFO_1 lpUserInfo = NULL;
    DWORD dwCount = 0L;

    m_oblFtpUsers.RemoveAll();

    BeginWaitCursor();

    err = ::IISEnumerateUsers(
        (LPTSTR)(LPCTSTR)m_strServerName,
        1,
        INET_FTP_SVC_ID,
        m_dwInstance,
        &dwCount,
        (LPBYTE *)&lpUserInfo
        );

    EndWaitCursor();

    TRACEEOLID("IISEnumerateUsers returned " << err);

    if (err.Failed())
    {
        return err;
    }

    try
    {
        for (DWORD i = 0; i < dwCount; ++i)
        {
            m_oblFtpUsers.AddTail(new CFtpUserInfo(lpUserInfo++));
        }
    }
    catch(CMemoryException * e)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    SortUsersList();

    return err;
}



HRESULT
CUserSessionsDlg::DisconnectUser(CFtpUserInfo * pUserInfo)
/*++

Routine Description:

    Disconnect a single user

Arguments:

    CFtpUserInfo * pUserInfo : User to disconnect

Return Value:

    ERROR return code

--*/
{
    CError err(::IISDisconnectUser(
        (LPTSTR)(LPCTSTR)m_strServerName,
        INET_FTP_SVC_ID, 
        m_dwInstance, 
        pUserInfo->QueryUserID()
        ));

    if (err.Win32Error() == NERR_UserNotFound)
    {
        //
        // As long as he's gone now, that's alright
        //
        err.Reset();
    }

    return err;
}



void 
CUserSessionsDlg::UpdateTotalCount()
/*++

Routine Description:

    Update the count of total users

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;
    str.Format(m_strTotalConnected, m_oblFtpUsers.GetCount() );

    m_static_Total.SetWindowText(str);     
}



void
CUserSessionsDlg::FillListBox(CFtpUserInfo * pSelection)
/*++

Routine Description:

    Show the users in the listbox

Arguments:

    CFtpUserInfo * pSelection : Item to be selected or NULL

Return Value:

    None

--*/
{
    CObListIter obli(m_oblFtpUsers);
    const CFtpUserInfo * pUserEntry = NULL;

    m_list_Users.SetRedraw(FALSE);
    m_list_Users.ResetContent();
    int cItems = 0;

    for ( /**/ ; pUserEntry = (CFtpUserInfo *)obli.Next(); ++cItems)
    {
        m_list_Users.AddItem(pUserEntry);
    }

    if (pSelection)
    {
        //
        // Select the desired entry
        //
        m_list_Users.SelectItem(pSelection);
    }

    m_list_Users.SetRedraw(TRUE);

    //
    // Update the count text on the dialog
    //
    UpdateTotalCount();
}



HRESULT
CUserSessionsDlg::RefreshUsersList()
/*++

Routine Description:

    Rebuild the user list

Arguments:

    None

Return Value:

    Error return code

--*/
{
    CError err;

    //
    // Add some friendly error message overrides
    //
    err.AddOverride(EPT_S_NOT_REGISTERED,       IDS_ERR_RPC_NA);
    err.AddOverride(RPC_S_SERVER_UNAVAILABLE,   IDS_FTP_SERVICE_NOT_STARTED);
    err.AddOverride(RPC_S_UNKNOWN_IF,           IDS_FTP_SERVICE_NOT_STARTED);
    err.AddOverride(RPC_S_PROCNUM_OUT_OF_RANGE, IDS_ERR_INTERFACE);

	err = BuildUserList();

    if (!err.MessageBoxOnFailure())
    {
        FillListBox();
        SetControlStates();
    }

    return err;
}



void
CUserSessionsDlg::SetControlStates()
/*++

Routine Description:

    Set the connect/disconnect buttons depending on the selection state
    in the listbox.

Arguments:

    None

Return Value:

    None

--*/
{
    m_button_Disconnect.EnableWindow(m_list_Users.GetSelCount() > 0);
    m_button_DisconnectAll.EnableWindow(m_list_Users.GetCount() > 0);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void 
CUserSessionsDlg::OnButtonDisconnect() 
/*++

Routine Description:

    'Disconnect User' button has been pressed.  Disconnect the currently
    selected user.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for confirmation
    //
    if (!NoYesMessageBox(IDS_CONFIRM_DISCONNECT_USER))
    {
        //
        // Changed his mind
        //
        return;
    }

    CError err;
    m_list_Users.SetRedraw(FALSE);
    CWaitCursor wait;
    
    CFtpUserInfo * pUserEntry;
    int nSel = 0;
    BOOL fProblems = FALSE;

    while((pUserEntry = GetNextSelectedItem(&nSel)) != NULL)
    {
        err = DisconnectUser(pUserEntry);
        if (err.Failed())
        {
            ++fProblems;

            if (err.MessageBoxFormat(
                IDS_DISCONNECT_ERR,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2,
                NO_HELP_CONTEXT,
                (LPCTSTR)pUserEntry->QueryUserName()
                ) == IDYES)
            {
                //
                // Continue trying to delete
                //
                ++nSel;
                continue;
            }    
            else
            {
                break;
            }
        }
    
        m_oblFtpUsers.RemoveIndex(nSel);
        m_list_Users.DeleteString(nSel);

        //
        // Don't advance counter to account for offset
        //
    }

    m_list_Users.SetRedraw(TRUE);
    UpdateTotalCount();
    SetControlStates();

    if (!fProblems)
    {
        //
        // Ensure button not disabled
        //
        GetDlgItem(IDC_BUTTON_REFRESH)->SetFocus();
    }
}



void
CUserSessionsDlg::OnButtonDisconnectAll() 
/*++

Routine Description:

    'Disconnect All Users' button has been pressed.  Disconnect all users

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Ask for confirmation
    //
    if (!NoYesMessageBox(IDS_CONFIRM_DISCONNECT_ALL))
    {
        //
        // Changed his mind
        //
        return;
    }
    
    CObListIter obli(m_oblFtpUsers);
    CFtpUserInfo * pUserEntry;

    m_list_Users.SetRedraw(FALSE);
    CWaitCursor wait;
    int cItems = 0;

    CError err;
    int nSel = 0;
    BOOL fProblems = FALSE;

    for ( /**/; pUserEntry = (CFtpUserInfo *)obli.Next(); ++cItems)
    {
        err = DisconnectUser(pUserEntry);
        if (err.Failed())
        {
            ++fProblems;

            if (err.MessageBoxFormat(
                IDS_DISCONNECT_ERR,
                MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2,
                NO_HELP_CONTEXT,
                (LPCTSTR)pUserEntry->QueryUserName()
                ) == IDYES)
            {
                //
                // Continue trying to delete
                //
                ++nSel;
                continue;
            }    
            else
            {
                break;
            }
        }

        m_oblFtpUsers.RemoveIndex(nSel);
        m_list_Users.DeleteString(nSel);
    }

    m_list_Users.SetRedraw(TRUE);
    UpdateTotalCount();
    SetControlStates();

    if (!fProblems)
    {
        //
        // Ensure button not disabled
        //
        GetDlgItem(IDC_BUTTON_REFRESH)->SetFocus();
    }
}



void
CUserSessionsDlg::OnButtonRefresh() 
/*++

Routine Description:

    'Refresh' Button has been pressed.  Refresh the user list

Arguments:

    None

Return Value:

    None

--*/
{
    RefreshUsersList();
}



void 
CUserSessionsDlg::OnSelchangeListUsers() 
/*++

Routine Description:

    Respond to a change in selection in the user listbox

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void
CUserSessionsDlg::OnHeaderItemClick(
    IN  UINT nID,
    IN  NMHDR * pNMHDR,
    OUT LRESULT * plResult
    )
/*++

Routine Description:

    Header item has been clicked in the listbox.  Change the sort key
    as appropriate.

Arguments:

    None

Return Value:

    None

--*/
{
    HD_NOTIFY * pNotify = (HD_NOTIFY *)pNMHDR;
    TRACEEOLID("Header Button clicked.");

    //
    // Can't press a button out of range, surely...
    //
    ASSERT(pNotify->iItem < m_list_Users.QueryNumColumns());
    int nOldSortColumn = m_nSortColumn;
    m_nSortColumn = pNotify->iItem;

    if(m_nSortColumn != nOldSortColumn)
    {
        //
        // Rebuild the list
        //
        SortUsersList();
        CFtpUserInfo * pSelector = GetSelectedListItem();
        FillListBox(pSelector);
        SetControlStates();
    }

    //
    // Message Fully Handled
    //
    *plResult = 0;
}



BOOL 
CUserSessionsDlg::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    if (!m_strAdminName.IsEmpty())
    {
        CError err = ImpersonateUser(m_strAdminName, _T(""), m_strAdminPassword, &m_hImpToken, &m_hLogToken);
    }

    m_list_Users.Initialize();

    if (RefreshUsersList() != ERROR_SUCCESS)
    {
        EndDialog(IDCANCEL);
        return FALSE;
    }

    return TRUE;
}

void
CUserSessionsDlg::OnDestroy() 
{
    if (m_hImpToken != INVALID_HANDLE_VALUE || m_hLogToken != INVALID_HANDLE_VALUE)
    {
        UnImpersonateUser(m_hImpToken, m_hLogToken);
    }
}

HRESULT ImpersonateUser(LPCTSTR  pszUserName,
                        LPCTSTR  pszDomain,
                        LPCTSTR  pszPassword,
                        HANDLE  *pCurImpToken,
                        HANDLE  *pLoggedOnUserToken)
{
    HRESULT hr = S_OK;

    ASSERT(pCurImpToken);
    ASSERT(pLoggedOnUserToken);

    *pCurImpToken       = INVALID_HANDLE_VALUE;
    *pLoggedOnUserToken = INVALID_HANDLE_VALUE;

    // logon the user.  This creates an primary impersonation
    // token.  If this fails, an error will be returned.

    if (!LogonUser((LPTSTR)pszUserName,
                   (LPTSTR)pszDomain,
                   (LPTSTR)pszPassword,
                   LOGON32_LOGON_BATCH,
                   LOGON32_PROVIDER_DEFAULT,
                   pLoggedOnUserToken)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    // get the current impersonation token.  If an error occurs,
    // that is OK.  This just means that no impersonation on the
    // thread is occurring, so there is no need to do the RevertToSelf.

    else if (OpenThreadToken( GetCurrentThread(),
                              TOKEN_READ | TOKEN_IMPERSONATE,
                              TRUE,           
                              pCurImpToken)) {

           RevertToSelf();
    }

    // if everything's been successful so far, than call 
    // ImpersonateLoggedOnUser with the token created above.

    if (SUCCEEDED(hr)) {

        if (!ImpersonateLoggedOnUser(*pLoggedOnUserToken)) {

            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    // if there were failures, clean up any tokens that we created
    // or hold.

    if (FAILED(hr)) {

        // cleanup the LogonUser token

        if (*pLoggedOnUserToken != INVALID_HANDLE_VALUE) {
            CloseHandle(*pLoggedOnUserToken);
            *pLoggedOnUserToken = INVALID_HANDLE_VALUE;
        }

        // cleanup the token from the OpenThreadToken call

        if (*pCurImpToken != INVALID_HANDLE_VALUE) {
            HANDLE  hThread = GetCurrentThread();
            SetThreadToken(&hThread,
                           *pCurImpToken);
            CloseHandle(*pCurImpToken);
            *pCurImpToken = INVALID_HANDLE_VALUE;
        }
    }

    return hr;
}

HRESULT UnImpersonateUser(HANDLE hSavedImpToken, HANDLE hLoggedOnUser)
{
    // if there is an hSavedImpToken, then call SetThreadToken to
    // restore it.

    if (hSavedImpToken != INVALID_HANDLE_VALUE) 
    {
        HANDLE  hThread = GetCurrentThread();
        SetThreadToken(&hThread, hSavedImpToken);
        CloseHandle(hSavedImpToken);
    }

    // cleanup the LogonUser token

    if (hLoggedOnUser != INVALID_HANDLE_VALUE) 
    {
        CloseHandle(hLoggedOnUser);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\w3accts.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3accts.h

   Abstract:

        WWW Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __W3ACCTS_H__
#define __W3ACCTS_H__

class CW3AccountsPage : public CInetPropertyPage
/*++

Class Description:

    WWW Accounts property page

Public Interface:

    CW3AccountsPage     : Constructor
    ~CW3AccountsPage    : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3AccountsPage)

//
// Construction
//
public:
    CW3AccountsPage(CInetPropertySheet * pSheet = NULL);
    ~CW3AccountsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3AccountsPage)
    enum { IDD = IDD_ACCOUNTS };
    CButton m_button_RemoveAdministrator;
    CButton m_button_Add;
    //}}AFX_DATA

    CAccessEntryListBox m_list_Administrators;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3AccountsPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3AccountsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonDelete();
    afx_msg void OnSelchangeListAdministrators();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    BOOL SetAdminRemoveState();

private:
    CRMCListBoxResources m_ListBoxRes;
    CObListPlus          m_oblSID;
};

#endif // __W3ACCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\w3accts.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3accts.cpp

   Abstract:

        WWW Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "supdlgs.h"
#include "w3accts.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



IMPLEMENT_DYNCREATE(CW3AccountsPage, CInetPropertyPage)



CW3AccountsPage::CW3AccountsPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Accounts page constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet data

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3AccountsPage::IDD, pSheet),
      m_ListBoxRes(
        IDB_ACLUSERS,
        CAccessEntryListBox::nBitmaps
        ),
      m_oblSID()
{

#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

    m_list_Administrators.AttachResources(&m_ListBoxRes);

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CW3AccountsPage)
    //}}AFX_DATA_INIT

#endif // 0

}



CW3AccountsPage::~CW3AccountsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3AccountsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3AccountsPage)
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_RemoveAdministrator);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_LIST_ADMINISTRATORS, m_list_Administrators);

}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3AccountsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3AccountsPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_CBN_SELCHANGE(IDC_LIST_ADMINISTRATORS, OnSelchangeListAdministrators)
    //}}AFX_MSG_MAP

END_MESSAGE_MAP()




BOOL
CW3AccountsPage::SetAdminRemoveState()
/*++

Routine Description:

    Set the state of the remove button depending on the selection in the
    administrators listbox.  Remove is only enabled if ALL selected
    items are removable.

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled

--*/
{
    int nSel = 0;
    int cSelectedItems = 0;
    BOOL fAllDeletable = TRUE;
    CAccessEntry * pAccess;
    while ((pAccess  = m_list_Administrators.GetNextSelectedItem(&nSel)) != NULL)
    {
        ++cSelectedItems;

        if (!pAccess->IsDeletable())
        {
            fAllDeletable = FALSE;
            break;
        }

        ++nSel;
    }

    fAllDeletable = fAllDeletable && (cSelectedItems > 0);

    m_button_RemoveAdministrator.EnableWindow(
        fAllDeletable 
     && HasOperatorList()
     && HasAdminAccess()
        );

    return fAllDeletable;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CW3AccountsPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_list_Administrators.Initialize();

    CWaitCursor wait;


    //
    // Build the ACL list
    //
    CError err(BuildAclOblistFromBlob(
        ((CW3Sheet *)GetSheet())->GetInstanceProperties().m_acl, 
        m_oblSID
        ));

    err.MessageBoxOnFailure();
    m_list_Administrators.FillAccessListBox(m_oblSID);

    //
    // check if the operators controls are accessible
    //
    m_button_Add.EnableWindow(HasOperatorList());

    SetAdminRemoveState();

    return TRUE;
}



/* virtual */
HRESULT
CW3AccountsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Nothing to do..
    //
    return S_OK;
}



/* virtual */
HRESULT
CW3AccountsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    BOOL fUpdateData : If TRUE, control data has not yet been stored.  This
                       is the case when "apply" is pressed.

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 accounts page now...");

    //
    // Message crackers require m_ notation
    //
    CBlob m_acl;
    BOOL fAclDirty = BuildAclBlob(m_oblSID, m_acl);

    CError err;

    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CW3Sheet)
        if (fAclDirty)
        {
            STORE_INST_DATA_ON_SHEET(m_acl)
        }
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}



void
CW3AccountsPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}


void 
CW3AccountsPage::OnButtonAdd()
/*++

Routine Description:

    'Add' button has been pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_list_Administrators.AddToAccessList(
        this,
        QueryServerName(),
        m_oblSID
        ))
    {
        OnItemChanged();
    }

    SetAdminRemoveState();
}


void 
CW3AccountsPage::OnSelchangeListAdministrators()
/*++

Routine Description:

    Selection Change in admin list box handler

Arguments:

    None.

Return Value:

    None

--*/
{
    SetAdminRemoveState();
}



void 
CW3AccountsPage::OnButtonDelete()
/*

Routine Description:

    Delete all selected items in the list box

Arguments:

    None.

Return Value:

    None

--*/
{
    int nSel = 0;
    int cChanges = 0;
    CAccessEntry * pAccess;
    while ((pAccess  = m_list_Administrators.GetNextSelectedItem(&nSel)) != NULL)
    {
        //
        // Remove button should be disabled unless all selected
        // items are deletable
        //
        ASSERT(pAccess->IsDeletable());
        if (pAccess->IsDeletable())
        {
            ++cChanges;
            pAccess->FlagForDeletion();
            m_list_Administrators.DeleteString(nSel);

            //
            // Don't advance counter to account for shift
            //
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        OnItemChanged();
    }

    if (!SetAdminRemoveState())
    {
        m_button_Add.SetFocus();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\w3sht.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3sht.h

   Abstract:

        WWW Property Sheet Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __W3SHT_H__
#define __W3SHT_H__


#include "shts.h"

extern const LPCTSTR g_cszSvc;

//
// Helper function to determine if SSL is installed
// and enabled on the given server
//
DWORD
IsSSLEnabledOnServer(
    IN  CComAuthInfo * pAuthInfo,
    OUT BOOL & fInstalled,
    OUT BOOL & fEnabled
    );

//
// Helper function to see if a certificate is installed
//
BOOL
IsCertInstalledOnServer(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    );

#ifndef LOGGING_ENABLED
#define LOGGING_ENABLED
inline BOOL LoggingEnabled(
    IN DWORD dwLogType
    )
{
    return (dwLogType == MD_LOG_TYPE_ENABLED);
}
#endif

#ifndef ENABLE_LOGGING
#define ENABLE_LOGGING
inline void EnableLogging(
    OUT DWORD & dwLogType, 
    IN  BOOL fEnabled = TRUE
    )
{
    dwLogType = fEnabled ? MD_LOG_TYPE_ENABLED : MD_LOG_TYPE_DISABLED;
}
#endif


//
// Bandwidth definitions
//
#define INFINITE_BANDWIDTH      (0xffffffff)
#define INFINITE_CPU_RAW        (0xffffffff)
#define KILOBYTE                (1024L)
#define MEGABYTE                (1024L * KILOBYTE)
#define DEF_BANDWIDTH           (1 * MEGABYTE)
#define CPU_THROTTLING_FACTOR   (1000)
#define DEFAULT_CPU_PERCENTAGE  (10L)

//
// Some sanity values on max connections
//
#define INITIAL_MAX_CONNECTIONS  (      1000L)
// TODO: Check these limits
//#define UNLIMITED_CONNECTIONS    (2000000000L)
#define UNLIMITED_CONNECTIONS    (0xFFFFFFFF)
#define MAX_MAX_CONNECTIONS      (UNLIMITED_CONNECTIONS - 1L)

#define MAX_TIMEOUT              (0x7FFFFFFF)



class CW3InstanceProps : public CInstanceProps
/*++

Class Description:
    
    WWW Instance properties class

Public Interface:

    CW3InstanceProps        : Constructor

--*/
{
public:
    CW3InstanceProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Service Page
    //
    MP_DWORD         m_dwLogType;
    MP_CILong        m_nMaxConnections;
    MP_CILong        m_nConnectionTimeOut;
    MP_CStringListEx m_strlSecureBindings;

    //
    // Performance Page
    //
    MP_int           m_nServerSize;
    MP_BOOL          m_fUseKeepAlives;
    MP_BOOL          m_fLogUTF8;
    MP_BOOL          m_fEnableCPUAccounting;
    MP_DWORD         m_dwCPULimitLogEventRaw;
    MP_DWORD         m_dwCPULimitPriorityRaw;
    MP_DWORD         m_dwCPULimitPauseRaw;
    MP_DWORD         m_dwCPULimitProcStopRaw;
    MP_CILong        m_dwMaxBandwidth;
    MP_CILong        m_dwMaxGlobalBandwidth;
    BOOL             m_fUninstallPSHED;

    //
    // Operators Page
    //
    MP_CBlob         m_acl;

    //
    // Root dir page
    //
    //MP_BOOL          m_fFrontPage;

    //
    // Default Site page
    //
    MP_DWORD         m_dwDownlevelInstance;

    //
    // Certificate and CTL information
    //
    MP_CBlob         m_CertHash;
    MP_CString       m_strCertStoreName;
    MP_CString       m_strCTLIdentifier;
    MP_CString       m_strCTLStoreName;
};



class CW3DirProps : public CChildNodeProps
/*++

Class Description:

    WWW Directory Properties

Public Interface:

    CW3DirProps     : Constructor

--*/
{
public:
    //
    // Constructor
    //
    CW3DirProps(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMDPath
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Directory properties page
    //
    MP_CString       m_strUserName;
    MP_CString       m_strPassword;
    MP_CString       m_strDefaultDocument;
    MP_CString       m_strFooter;
    MP_CMaskedDWORD  m_dwDirBrowsing;
    MP_BOOL          m_fDontLog;
    MP_BOOL          m_fEnableFooter;
    MP_BOOL          m_fIndexed;

    //
    // HTTP Page
    //
    MP_CString       m_strExpiration;
    MP_CStringListEx m_strlCustomHeaders;

    //
    // Custom Errors
    //
    MP_CStringListEx m_strlCustomErrors;

    //
    // Security page
    //
    MP_DWORD         m_dwAuthFlags;
    MP_DWORD         m_dwSSLAccessPermissions;
    MP_CString       m_strBasicDomain;
    MP_CString       m_strRealm;
    MP_CString       m_strAnonUserName;
    MP_CString       m_strAnonPassword;
    MP_BOOL          m_fPasswordSync;
    MP_BOOL          m_fU2Installed;
    MP_BOOL          m_fUseNTMapper;
    MP_CBlob         m_ipl;
};



class CIISFilter : public CObjectPlus
/*++

Class Description:

    A single filter description

Public Interface:

    CIISFilter      : Constructors
    IsInitialized   : Check to see if the name is set.
    Write           : Write to the metabase.
    QueryResult     : Query result from metabase read
    QueryError      : Returns error as stored in metabase
    QueryName       : Returns filter name
    IsLoaded        : TRUE if filter is loaded
    IsUnloaded      : TRUE if filter is unloaded
    IsEnabled       : TRUE if filter is enabled
    Enable          : Enable filter
    IsDirty         : TRUE if filter values have changed
    IsFlaggedForDeletion : TRUE if filter should be deleted
  
--*/
{
//
// Constructors/Destructors
//
public:
    //
    // Null Constructor
    //
    CIISFilter();

    //
    // Read filter values using provided key
    //
    CIISFilter(
        IN CMetaKey * pKey,
        IN LPCTSTR lpszName
        );

    //
    // Copy constructor
    //
    CIISFilter(
        IN const CIISFilter & flt
        );

public:
    //
    // Sorting helper
    //
    int OrderByPriority(
        IN const CObjectPlus * pobAccess
        ) const;

    BOOL IsInitialized() const { return !m_strName.IsEmpty(); }

    //
    // Write using provided key
    //
    HRESULT Write(CMetaKey * pKey);

public:
    BOOL IsLoaded() const;
    BOOL IsUnloaded() const;
    BOOL IsEnabled() const { return m_fEnabled; }
    void Enable(BOOL fEnabled = TRUE);
    DWORD QueryError() const { return m_dwWin32Error; }
    HRESULT QueryResult() const { return m_hrResult; }

    //
    // Check to see if this item is marked as dirty
    //
    BOOL IsDirty() const { return m_fDirty; }

    //
    // Check to see if this item is flagged for deletion
    //
    BOOL IsFlaggedForDeletion() const { return m_fFlaggedForDeletion; }

    //
    // Set/reset the dirty flag
    //
    void Dirty(BOOL fDirty = TRUE);

    //
    // Flag this item for deletion
    //
    void FlagForDeletion();

    //
    // Get the name of this filter
    //
    LPCTSTR QueryName() const { return m_strName; }

//
// Meta Values
//
public:
    int         m_nPriority;
    int         m_nOrder;
    BOOL        m_fEnabled;
    DWORD       m_dwState;
    DWORD       m_dwWin32Error;
    HRESULT     m_hrResult;
    CString     m_strName;
    CString     m_strExecutable;

//
// State Values
//
private:
    BOOL        m_fDirty;
    BOOL        m_fFlaggedForDeletion;
    DWORD       m_dwFlags;
};



class CIISFilterList : public CMetaKey
/*++

Class Description:

    A list of filters

Public Interface:

    CIISFilterList      : Constructor

    BeginSearch         : Reset the iterator
    MoreFilters         : More items available in the list?
    GetNextFilter       : Get the next item in the list

--*/
{
public:
    CIISFilterList(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath
        /*
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance       = MASTER_INSTANCE
        */
        );

public:
    //
    // Write out the filter list
    //
    HRESULT WriteIfDirty();

//
// Acccess Functions
//
public:
    //DWORD QueryInstance() const { return m_dwInstance; }
    BOOL FiltersLoaded()  const { return m_fFiltersLoaded; }

    //
    // Load each filter in turn
    //
    HRESULT LoadAllFilters();

//
// Filter Access Functions
//
public:
    //
    // Reset the filter list iterator
    //
    void ResetEnumerator();

    int GetCount() const { return (int)m_oblFilters.GetCount(); }

    //
    // More filters available in the list? 
    //
    BOOL MoreFilters() const { return m_pos != NULL; }

    //
    // Return position of filter by index
    //
    POSITION GetFilterPositionByIndex(int nSel);

    //
    // Iterate to the next filter in the list
    //
    CIISFilter * GetNextFilter();

    //
    // Remove filter
    //
    void RemoveFilter(int nItem);

    //
    // Add new filter
    //
    void AddFilter(CIISFilter * pFilter);

    //
    // Exchange two filters in the list
    //
    BOOL ExchangePositions(
        IN  int nSel1, 
        IN  int nSel2, 
        OUT CIISFilter *& p1,
        OUT CIISFilter *& p2
        );

    //
    // See if at least one filter is dirty
    //
    BOOL HasDirtyFilter() const;

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const { return SUCCEEDED(m_hrResult); }
    virtual HRESULT QueryResult() const { return m_hrResult; }

protected:
    //
    // Build up order string from component list
    //
    LPCTSTR BuildFilterOrderString(
        OUT CString & strFilterOrder
        );

protected:
    //
    // Seperator string (one character)
    //
    static const LPCTSTR s_lpszSep;

private:
    BOOL     m_fFiltersLoaded;
    //DWORD    m_dwInstance;
    POSITION m_pos;
    HRESULT  m_hrResult;
    CString  m_strFilterOrder;
    CObListPlus m_oblFilters;
};


//
// W3 Property sheet
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CW3Sheet : public CInetPropertySheet
{
public:
    CW3Sheet(
        IN CComAuthInfo * pAuthInfo,
        IN LPCTSTR lpszMetaPath,
        IN DWORD   dwAttributes,
        IN CWnd *  pParentWnd  = NULL,
        IN LPARAM  lParam      = 0L,
        IN LONG_PTR    handle      = 0L,
        IN UINT    iSelectPage = 0
        );

    virtual ~CW3Sheet();

public:
    HRESULT QueryInstanceResult() const;
    HRESULT QueryDirectoryResult() const;
    CW3InstanceProps & GetInstanceProperties() { return *m_ppropInst; }
    CW3DirProps & GetDirectoryProperties() { return *m_ppropDir; }
    BOOL InCompatibilityMode() const { return m_fCompatMode; }

    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();

	HRESULT EnumAppPools(CMapStringToString& pools);
	HRESULT SetKeyType();
	HRESULT QueryDefaultPoolId(CString& id);
	enum
	{
        SHEET_TYPE_SERVER,
		SHEET_TYPE_SITE,
        SHEET_TYPE_VDIR,
        SHEET_TYPE_DIR,
		SHEET_TYPE_FILE
	};
    HRESULT SetSheetType(int fSheetType);

protected:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    //{{AFX_MSG(CW3Sheet)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

private:
    DWORD            m_fNew;
    DWORD            m_dwAttributes;
    BOOL             m_fCompatMode;
    CW3InstanceProps * m_ppropInst;
    CW3DirProps      * m_ppropDir;
    int              m_fSheetType;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CIISFilter::IsLoaded() const
{
    return m_dwState == MD_FILTER_STATE_LOADED;
}

inline BOOL CIISFilter::IsUnloaded() const
{
    return m_dwState == MD_FILTER_STATE_UNLOADED;
}

inline void CIISFilter::Enable(
    IN BOOL fEnabled
    )
{
    m_fEnabled = fEnabled;
}

inline void CIISFilter::Dirty(
    IN BOOL fDirty
    )
{
    m_fDirty = fDirty;
}

inline void CIISFilter::FlagForDeletion()
{
    m_fFlaggedForDeletion = TRUE;
}

inline void CIISFilterList::ResetEnumerator()
{
    m_pos = m_oblFilters.GetHeadPosition();
}

inline CIISFilter * CIISFilterList::GetNextFilter()
{
    return (CIISFilter *)m_oblFilters.GetNext(m_pos);
}

inline void CIISFilterList::RemoveFilter(int nItem)
{
    m_oblFilters.RemoveIndex(nItem);
}

inline void CIISFilterList::AddFilter(CIISFilter * pFilter)
{
    m_oblFilters.AddTail(pFilter);
}

//
// BUGBUG: Returns S_OK if object not present
//
inline HRESULT CW3Sheet::QueryInstanceResult() const 
{ 
    return m_ppropInst ? m_ppropInst->QueryResult() : S_OK;
}

inline HRESULT CW3Sheet::QueryDirectoryResult() const 
{ 
    return m_ppropDir ? m_ppropDir->QueryResult() : S_OK;
}


#endif // __W3SHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wdir.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wdir.cpp

   Abstract:
        WWW Directory (non-virtual) Properties Page

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        10/03/2001      sergeia     Created from wvdir.cpp / wfile.cpp
--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "w3sht.h"
#include "wdir.h"
#include "dirbrows.h"
#include "iisobj.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPCTSTR CvtPathToDosStyle(CString & strPath);

IMPLEMENT_DYNCREATE(CW3DirPage, CInetPropertyPage)

CW3DirPage::CW3DirPage(CInetPropertySheet * pSheet) 
    : CInetPropertyPage(CW3DirPage::IDD, pSheet, IDS_TAB_DIR),
      //
      // Assign the range of bits in m_dwAccessPermissions that
      // we manage.  This is important, because another page
      // manages other bits, and we don't want to screw up
      // the master value bits when our changes collide (it
      // will mark the original bits as dirty, because we're not
      // notified when the change is made...
      //
      m_dwBitRangePermissions(MD_ACCESS_EXECUTE | 
            MD_ACCESS_SCRIPT | 
            MD_ACCESS_WRITE  | 
            MD_ACCESS_SOURCE |
            MD_ACCESS_READ),
      m_dwBitRangeDirBrowsing(MD_DIRBROW_ENABLED),
      m_pApplication(NULL),
      m_fRecordChanges(TRUE),
      m_fCompatibilityMode(FALSE)
{
	VERIFY(m_strPrompt[RADIO_DIRECTORY].LoadString(IDS_PROMPT_DIR));
	VERIFY(m_strPrompt[RADIO_REDIRECT].LoadString(IDS_PROMPT_REDIRECT));
	VERIFY(m_strRemove.LoadString(IDS_BUTTON_REMOVE));
	VERIFY(m_strCreate.LoadString(IDS_BUTTON_CREATE));
	VERIFY(m_strEnable.LoadString(IDS_BUTTON_ENABLE));
	VERIFY(m_strDisable.LoadString(IDS_BUTTON_DISABLE));
	VERIFY(m_strWebFmt.LoadString(IDS_APPROOT_FMT));
}

CW3DirPage::~CW3DirPage()
{
	SAFE_DELETE(m_pApplication);
}

void 
CW3DirPage::DoDataExchange(CDataExchange * pDX)
{
	CInetPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CW3DirPage)
	//    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
	DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
	DDX_Control(pDX, IDC_RADIO_REDIRECT, m_radio_Redirect);

	DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
	DDX_Check(pDX, IDC_CHECK_AUTHOR, m_fAuthor);
	DDX_Control(pDX, IDC_CHECK_AUTHOR, m_check_Author);
	DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
	DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);    
	DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
	DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
	DDX_Check(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_fBrowsingAllowed);
	DDX_Control(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_check_DirBrowse);
	DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);
	DDX_Control(pDX, IDC_CHECK_LOG_ACCESS, m_check_LogAccess);
	DDX_Check(pDX, IDC_CHECK_INDEX, m_fIndexed);
	DDX_Control(pDX, IDC_CHECK_INDEX, m_check_Index);

	DDX_Control(pDX, IDC_EDIT_REDIRECT, m_edit_Redirect);
	DDX_Check(pDX, IDC_CHECK_CHILD, m_fChild);
	DDX_Check(pDX, IDC_CHECK_EXACT, m_fExact);
	DDX_Check(pDX, IDC_CHECK_PERMANENT, m_fPermanent);
	DDX_Control(pDX, IDC_CHECK_CHILD, m_check_Child);

	DDX_Control(pDX, IDC_STATIC_PATH_PROMPT, m_static_PathPrompt);

	DDX_Control(pDX, IDC_BUTTON_UNLOAD_APP, m_button_Unload);
	DDX_Control(pDX, IDC_BUTTON_CREATE_REMOVE_APP, m_button_CreateRemove);
	DDX_Control(pDX, IDC_APP_CONFIGURATION, m_button_Configuration);
	DDX_CBIndex(pDX, IDC_COMBO_PERMISSIONS, m_nPermissions);
	DDX_Control(pDX, IDC_COMBO_PERMISSIONS, m_combo_Permissions);
	DDX_Control(pDX, IDC_STATIC_PROTECTION, m_static_ProtectionPrompt);
	DDX_Control(pDX, IDC_COMBO_PROCESS, m_combo_Process);

	DDX_Control(pDX, IDC_EDIT_APPLICATION, m_edit_AppFriendlyName);
	DDX_Text(pDX, IDC_EDIT_APPLICATION, m_strAppFriendlyName);
	DDV_MinMaxChars(pDX, m_strAppFriendlyName, 0, MAX_PATH); /// ?
	//}}AFX_DATA_MAP

	if (pDX->m_bSaveAndValidate)
	{
		if (m_nPathType == RADIO_REDIRECT)
		{
			DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
			m_strRedirectPath.TrimLeft();
			DDV_MinMaxChars(pDX, m_strRedirectPath, 0, 2 * MAX_PATH);

			if (!IsRelURLPath(m_strRedirectPath) 
				&& !IsWildcardedRedirectPath(m_strRedirectPath)
				&& !IsURLName(m_strRedirectPath))
			{
				::AfxMessageBox(IDS_BAD_URL_PATH);
				pDX->Fail();
			}
		}
		else // Local directory
		{
			m_strRedirectPath.Empty();
		}
	}
	else
	{
		DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
	}
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3DirPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3DirPage)
    ON_BN_CLICKED(IDC_CHECK_AUTHOR, OnCheckAuthor)
    ON_BN_CLICKED(IDC_CHECK_READ, OnCheckRead)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnCheckWrite)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_REDIRECT, OnRadioRedirect)

    ON_EN_CHANGE(IDC_EDIT_REDIRECT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_INDEX, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_CHILD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_EXACT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_PERMANENT, OnItemChanged)

    ON_BN_CLICKED(IDC_BUTTON_CREATE_REMOVE_APP, OnButtonCreateRemoveApp)
    ON_BN_CLICKED(IDC_BUTTON_UNLOAD_APP, OnButtonUnloadApp)
    ON_BN_CLICKED(IDC_APP_CONFIGURATION, OnButtonConfiguration)
    ON_CBN_SELCHANGE(IDC_COMBO_PERMISSIONS, OnSelchangeComboPermissions)
    ON_CBN_SELCHANGE(IDC_COMBO_PROCESS, OnSelchangeComboProcess)
    ON_EN_CHANGE(IDC_EDIT_APPLICATION, OnItemChanged)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



void
CW3DirPage::ChangeTypeTo(int nNewType)
{
	int nOldType = m_nPathType;
	m_nPathType = nNewType;

	if (nOldType == m_nPathType)
	{
		return;
	}

	OnItemChanged();
	SetStateByType();

	int nID = -1;
	CEdit * pPath = NULL;
	LPCTSTR lpKeepPath = NULL;

	switch(m_nPathType)
	{
	case RADIO_DIRECTORY:
		break;
	case RADIO_REDIRECT:
		if (!m_strRedirectPath.IsEmpty())
		{
			//
			// The old path info is acceptable, propose it
			// as a default
			//
			lpKeepPath =  m_strRedirectPath;
		}

		nID = IDS_REDIRECT_MASK;
		pPath = &m_edit_Redirect;
		break;
	default:
		ASSERT(FALSE);
		return;
	}

	//
	// Load mask resource, and display
	// this in the directory
	//
	if (pPath != NULL)
	{
		if (lpKeepPath != NULL)
		{
			pPath->SetWindowText(lpKeepPath);
		}
		else
		{
			CString str;
			VERIFY(str.LoadString(nID));
			pPath->SetWindowText(str);
		}
		pPath->SetSel(0,-1);
		pPath->SetFocus();
	}
}



void 
CW3DirPage::ShowControl(CWnd * pWnd, BOOL fShow)
{
	ASSERT(pWnd != NULL);
	pWnd->EnableWindow(fShow);
	pWnd->ShowWindow(fShow ? SW_SHOW : SW_HIDE);
}

void
CW3DirPage::SetStateByType()
/*++

Routine Description:

    Set the state of the dialog by the path type currently selected

Arguments:

    None

Return Value:

    None

--*/
{
	BOOL fShowDirFlags;
	BOOL fShowRedirectFlags;
	BOOL fShowDAV;

	switch(m_nPathType)
	{
	case RADIO_DIRECTORY:
		ShowControl(&m_edit_Path, fShowDirFlags = TRUE);
		m_edit_Path.EnableWindow(FALSE);
		ShowControl(&m_edit_Redirect, fShowRedirectFlags = FALSE);
		fShowDAV = TRUE;
		break;
	case RADIO_REDIRECT:
		ShowControl(&m_edit_Path, fShowDirFlags = FALSE);
		ShowControl(&m_edit_Redirect, fShowRedirectFlags = TRUE);
		fShowDAV = FALSE;
		break;
	default:
		ASSERT(FALSE && "Invalid Selection");
		return;
	}

	ShowControl(IDC_CHECK_READ, fShowDirFlags);
	ShowControl(IDC_CHECK_WRITE, fShowDirFlags);
	ShowControl(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, fShowDirFlags);
	ShowControl(IDC_CHECK_INDEX, fShowDirFlags);
	ShowControl(IDC_CHECK_LOG_ACCESS, fShowDirFlags);
	ShowControl(IDC_CHECK_AUTHOR, fShowDirFlags);
	ShowControl(IDC_STATIC_DIRFLAGS_LARGE, fShowDirFlags);
	ShowControl(IDC_STATIC_APPLICATION_SETTINGS, fShowDirFlags);
	ShowControl(IDC_STATIC_APP_PROMPT, fShowDirFlags);
	ShowControl(&m_edit_AppFriendlyName, fShowDirFlags);
	ShowControl(IDC_STATIC_SP_PROMPT, fShowDirFlags);
	ShowControl(IDC_STATIC_PERMISSIONS, fShowDirFlags);
	ShowControl(IDC_COMBO_PERMISSIONS, fShowDirFlags);
	ShowControl(IDC_STATIC_PROTECTION, fShowDirFlags);
	ShowControl(IDC_COMBO_PROCESS, fShowDirFlags);
	ShowControl(IDC_BUTTON_CREATE_REMOVE_APP, fShowDirFlags);
	ShowControl(IDC_APP_CONFIGURATION, fShowDirFlags);
	ShowControl(IDC_BUTTON_UNLOAD_APP, fShowDirFlags);
	ShowControl(IDC_STATIC_STARTING_POINT, fShowDirFlags);
	ShowControl(IDC_STATIC_APPLICATIONS, fShowDirFlags);

	ShowControl(IDC_CHECK_EXACT, fShowRedirectFlags);
	ShowControl(IDC_CHECK_CHILD, fShowRedirectFlags);
	ShowControl(IDC_CHECK_PERMANENT, fShowRedirectFlags);
	ShowControl(IDC_STATIC_REDIRECT_PROMPT, fShowRedirectFlags);
	ShowControl(IDC_STATIC_REDIRFLAGS, fShowRedirectFlags);
	ShowControl(&m_check_Author, fShowDAV);

	//
	// Enable/Disable must come after the showcontrols
	//
	m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);

	SetApplicationState();
}



void
CW3DirPage::SaveAuthoringState()
{
	if (m_check_Write.m_hWnd)
	{
		//
		// Controls initialized -- store live data
		//
		m_fOriginalWrite = m_check_Write.GetCheck() > 0;
		m_fOriginalRead = m_check_Read.GetCheck() > 0;
	}
	else
	{
		//
		// Controls not yet initialized, store original data
		//
		m_fOriginalWrite = m_fWrite;
		m_fOriginalRead = m_fRead;
	}
}

void
CW3DirPage::RestoreAuthoringState()
{
	m_fWrite = m_fOriginalWrite;
	m_fRead = m_fOriginalRead;
}

void 
CW3DirPage::SetAuthoringState(BOOL fAlterReadAndWrite)
{
	if (fAlterReadAndWrite)
	{
		if (m_fAuthor)
		{
			//
			// Remember previous setting to undo
			// this thing.
			//
			SaveAuthoringState();
			m_fRead = m_fWrite = TRUE;
		}
		else
		{
			//
			// Restore previous defaults
			//
			RestoreAuthoringState();
		}

		m_check_Read.SetCheck(m_fRead);
		m_check_Write.SetCheck(m_fWrite);
	}

	m_check_Author.EnableWindow((m_fRead || m_fWrite) 
		&& HasAdminAccess() 
		&& HasDAV()
		);

	//    m_check_Read.EnableWindow(!m_fAuthor && HasAdminAccess());
	//    m_check_Write.EnableWindow(!m_fAuthor && HasAdminAccess());
}

void 
CW3DirPage::SetPathType()
{
	if (!m_strRedirectPath.IsEmpty())
	{
		m_nPathType = RADIO_REDIRECT;
		m_radio_Dir.SetCheck(0);
		m_radio_Redirect.SetCheck(1);
	}
	else
	{
		m_nPathType = RADIO_DIRECTORY;
		m_radio_Redirect.SetCheck(0);
		m_radio_Dir.SetCheck(1);
	}

	m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
}


//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3DirPage::OnItemChanged()
{
	if (m_fRecordChanges)
	{
		SetModified(TRUE);
	}
}

BOOL 
CW3DirPage::OnInitDialog() 
{
	CInetPropertyPage::OnInitDialog();

	m_fCompatibilityMode = ((CW3Sheet *)GetSheet())->InCompatibilityMode();
	// Disable/hide irrelevant items
	GetDlgItem(IDC_RADIO_UNC)->EnableWindow(FALSE);
	ShowControl(GetDlgItem(IDC_BUTTON_CONNECT_AS), FALSE);
	ShowControl(GetDlgItem(IDC_BUTTON_BROWSE), FALSE);
	ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_SMALL), FALSE);

	// Set appropriate prompt
	CString str;
	VERIFY(str.LoadString(IDS_RADIO_DIR));
	m_radio_Dir.SetWindowText(str);
	//
	// Fill permissions combo box.
	//
	AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_NONE);
	AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_SCRIPT);
	AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_EXECUTE);
	m_combo_Permissions.SetCurSel(m_nPermissions);

	ASSERT(m_pApplication != NULL);

	if (m_fCompatibilityMode)
	{
		m_nSelInProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_INPROC);
		if (m_pApplication->SupportsPooledProc())
		{
			m_nSelPooledProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_POOLEDPROC); 
		}
		else
		{
			m_nSelPooledProc = -1; // N/A
		}
		m_nSelOutOfProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_OUTPROC);
	}
	else
	{
		CString buf;
		buf.LoadString(IDS_APPLICATION_POOL);
		m_static_ProtectionPrompt.SetWindowText(buf);

		CMapStringToString pools;
		CError err = ((CW3Sheet *)GetSheet())->EnumAppPools(pools);
		int idx_sel = CB_ERR;
		int idx_def = CB_ERR;
		if (err.Succeeded())
		{
			ASSERT(pools.GetCount() > 0);
			POSITION pos = pools.GetStartPosition();
			CString pool_id, pool_name;
			while (pos != NULL)
			{
				pools.GetNextAssoc(pos, pool_name, pool_id);
				int idx = m_combo_Process.AddString(pool_name);
				m_combo_Process.SetItemDataPtr(idx, StrDup(pool_id));
				if (0 == m_pApplication->m_strAppPoolId.CompareNoCase(pool_id))
				{
					idx_sel = idx;
				}
				if (0 == buf.CompareNoCase(pool_id))
				{
					idx_def = idx;
				}
			}
		}
		// select the app pool which has an id the same as in current application
		// It could be new app created in compatibility mode, no app pool is default app pool
		if (CB_ERR == idx_sel)
		{
			idx_sel = idx_def;
		}
		m_combo_Process.SetCurSel(idx_sel);
	}
	// It is enough to set file alias once -- we cannot change it here
	CString buf1, buf2, strAlias;
	CMetabasePath::GetRootPath(m_strFullMetaPath, buf1, &buf2);
	strAlias = _T("\\");
	strAlias += buf2;
	CvtPathToDosStyle(strAlias);
	m_edit_Path.SetWindowText(strAlias);

	SetPathType();
	SetStateByType();
	SetAuthoringState(FALSE);

	return TRUE;  
}

void
CW3DirPage::OnDestroy()
{
	int count = m_combo_Process.GetCount();
	if (count != CB_ERR)
	{
		for (int i = 0; i < count; i++)
		{
			void * p = m_combo_Process.GetItemDataPtr(i);
			LocalFree(p);
			m_combo_Process.SetItemDataPtr(i, NULL);
		}
	}
}

/* virtual */
HRESULT
CW3DirPage::FetchLoadedValues()
{
	CError err;

	BEGIN_META_DIR_READ(CW3Sheet)
	//
		// Use m_ notation because the message crackers require it
		//
		BOOL  m_fDontLog;

	FETCH_DIR_DATA_FROM_SHEET(m_strFullMetaPath);
	FETCH_DIR_DATA_FROM_SHEET(m_strRedirectPath);
	FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
	FETCH_DIR_DATA_FROM_SHEET(m_dwDirBrowsing);
	FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);
	FETCH_DIR_DATA_FROM_SHEET(m_fIndexed);
	FETCH_DIR_DATA_FROM_SHEET(m_fExact);
	FETCH_DIR_DATA_FROM_SHEET(m_fChild);
	FETCH_DIR_DATA_FROM_SHEET(m_fPermanent);

	m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
	m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
	m_fAuthor = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SOURCE);
	m_fBrowsingAllowed = IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_ENABLED);
	m_fLogAccess = !m_fDontLog;

	SaveAuthoringState();

	if (!m_fIsAppRoot)
	{
		m_dwAppState = APPSTATUS_NOTDEFINED;
	}
	FETCH_DIR_DATA_FROM_SHEET(m_strUserName);
	FETCH_DIR_DATA_FROM_SHEET(m_strPassword);
	FETCH_DIR_DATA_FROM_SHEET(m_strAlias);

	END_META_DIR_READ(err)

	m_nPermissions = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_EXECUTE)
	? COMBO_EXECUTE : IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SCRIPT)
	? COMBO_SCRIPT : COMBO_NONE;

	BeginWaitCursor();
	m_pApplication = new CIISApplication(QueryAuthInfo(), QueryMetaPath());
	err = m_pApplication != NULL
		? m_pApplication->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

	if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
	{
		//
		// No app information; that's ok in cases of file system directories
		// that don't exist in the metabase yet.
		//
		err.Reset();
	}

	if (err.Succeeded())
	{
		//
		// CODEWORK: RefreshAppState should be split up into two
		// different methods: one that fetches the data, and one
		// that moves the data to the UI controls on this page.
		//
		RefreshAppState();
	}

	EndWaitCursor();

	return err;
}


DWORD 
CW3DirPage::GetAppStateFromComboSelection() const
/*++

Routine Description:

    Get the app state DWORD that coresponds to the current combo
    box list selection

Arguments:

    None

Return Value:

    App state DWORD or 0xffffffff;

--*/
{
	int nSel = m_combo_Process.GetCurSel();

	if (nSel == m_nSelOutOfProc)
	{
		return CWamInterface::APP_OUTOFPROC;
	}

	if (nSel == m_nSelPooledProc)
	{
		ASSERT(m_pApplication->SupportsPooledProc());
		return CWamInterface::APP_POOLEDPROC;
	}

	if (nSel == m_nSelInProc)
	{
		return CWamInterface::APP_INPROC;
	}

	ASSERT(FALSE && "Invalid application state");

	return 0xffffffff;
}


/* virtual */
HRESULT
CW3DirPage::SaveInfo()
{
	ASSERT(IsDirty());

	CError err;

	SET_FLAG_IF(m_fBrowsingAllowed, m_dwDirBrowsing, MD_DIRBROW_ENABLED);
	SET_FLAG_IF(m_fRead, m_dwAccessPerms,   MD_ACCESS_READ);
	SET_FLAG_IF(m_fWrite, m_dwAccessPerms,  MD_ACCESS_WRITE);
	SET_FLAG_IF(m_fAuthor, m_dwAccessPerms, MD_ACCESS_SOURCE);
    SET_FLAG_IF((m_nPermissions == COMBO_EXECUTE), m_dwAccessPerms, MD_ACCESS_EXECUTE);
    //
    // script is set on EXECUTE as well "Execute (including script)"
    //
    SET_FLAG_IF(((m_nPermissions == COMBO_SCRIPT) || (m_nPermissions == COMBO_EXECUTE)), 
        m_dwAccessPerms, MD_ACCESS_SCRIPT);

	BOOL m_fDontLog = !m_fLogAccess;

	BeginWaitCursor();

	if (m_fCompatibilityMode)
	{
		DWORD dwAppProtection = GetAppStateFromComboSelection();
		if (dwAppProtection != m_dwAppProtection && m_fAppEnabled)
		{
			//
			// Isolation state has changed; recreate the application
			//
			CError err2(m_pApplication->RefreshAppState());
			if (err2.Succeeded())
			{
				err2 = m_pApplication->Create(m_strAppFriendlyName, dwAppProtection);
				//
				// Remember the new state, so we don't do this again
				// the next time the guy hits "apply"
				//
				if (err2.Succeeded())
				{
					m_dwAppProtection = dwAppProtection;
				}
			}

			err2.MessageBoxOnFailure();
		}
	}

	BEGIN_META_DIR_WRITE(CW3Sheet)
	INIT_DIR_DATA_MASK(m_dwAccessPerms, m_dwBitRangePermissions)
	INIT_DIR_DATA_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)

	STORE_DIR_DATA_ON_SHEET(m_fDontLog)
	STORE_DIR_DATA_ON_SHEET(m_fIndexed)
	STORE_DIR_DATA_ON_SHEET(m_fChild);
	STORE_DIR_DATA_ON_SHEET(m_fExact);
	STORE_DIR_DATA_ON_SHEET(m_fPermanent);
	//
	// CODEWORK: Not an elegant solution
	//
	pSheet->GetDirectoryProperties().MarkRedirAsInherit(!m_fChild);
	STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
	STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
	STORE_DIR_DATA_ON_SHEET(m_dwDirBrowsing)
	END_META_DIR_WRITE(err)

	if (err.Succeeded() && m_pApplication->IsEnabledApplication())
	{
		err = m_pApplication->WriteFriendlyName(m_strAppFriendlyName);
		if (!m_fCompatibilityMode)
		{
			// get app pool id from the combo, 
			// check if it was changed and reassign to application
			// get app pool id from the combo, 
			// check if it was changed and reassign to application
			CString id;
			int idx = m_combo_Process.GetCurSel();
			ASSERT(idx != CB_ERR);
			id = (LPCTSTR)m_combo_Process.GetItemDataPtr(idx);
			m_pApplication->WritePoolId(id);
		}
	}

	if (err.Succeeded())
	{
		SaveAuthoringState();
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
	}

	EndWaitCursor();

	return err;
}

void
CW3DirPage::RefreshAppState()
{
	ASSERT(m_pApplication != NULL);

	CError err(m_pApplication->RefreshAppState());

	if (err.Failed())
	{
		m_dwAppState = APPSTATUS_NOTDEFINED;    

		if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
		{
			//
			// Ignore this error, it really just means the path 
			// doesn't exist in the metabase, which is true for most
			// file and directory properties, and not an error
			// condition.
			//
			err.Reset();
		}
	}
	else
	{
		m_dwAppState = m_pApplication->QueryAppState();
	}

	if (err.Succeeded())
	{
		//
		// Get metabase information
		//
		m_strAppRoot = m_pApplication->m_strAppRoot;
		m_dwAppProtection = m_pApplication->m_dwProcessProtection;
		m_strAppFriendlyName = m_pApplication->m_strFriendlyName;
		m_fIsAppRoot 
			= (m_strFullMetaPath.CompareNoCase(m_strAppRoot) == 0);
	}
	else
	{
		//
		// Display error information
		//
		err.MessageBoxFormat(IDS_ERR_APP, MB_OK, NO_HELP_CONTEXT);
	}
}

CString&
CW3DirPage::FriendlyAppRoot(LPCTSTR lpAppRoot, CString& strFriendly)
{
	if (lpAppRoot != NULL && *lpAppRoot != 0)
	{
		strFriendly.Empty();

		CInstanceProps prop(QueryAuthInfo(), lpAppRoot);
		HRESULT hr = prop.LoadData();

		if (SUCCEEDED(hr))
		{
			CString root, tail;
			strFriendly.Format(m_strWebFmt, prop.GetDisplayText(root));
			CMetabasePath::GetRootPath(lpAppRoot, root, &tail);
			if (!tail.IsEmpty())
			{
				//
				// Add rest of dir path
				//
				strFriendly += _T("/");
				strFriendly += tail;
			}

			//
			// Now change forward slashes in the path to backward slashes
			//
			CvtPathToDosStyle(strFriendly);

			return strFriendly;
		}
	}    
	//
	// Bogus
	//    
	VERIFY(strFriendly.LoadString(IDS_APPROOT_UNKNOWN));

	return strFriendly;
}

void
CW3DirPage::SetApplicationState()
{
	//
	// SetWindowText causes a dirty marker
	//
	BOOL fOld = m_fRecordChanges;
	m_fRecordChanges = FALSE;
	m_fAppEnabled = FALSE;
	if (m_pApplication != NULL)
	{
		m_pApplication->RefreshAppState();
		m_fAppEnabled = m_fIsAppRoot && m_pApplication->IsEnabledApplication();
	}
	BOOL fVisible = m_nPathType == RADIO_DIRECTORY;

	m_button_CreateRemove.EnableWindow(fVisible && HasAdminAccess());
	m_button_CreateRemove.SetWindowText(m_fAppEnabled ? m_strRemove : m_strCreate);
	m_static_ProtectionPrompt.EnableWindow(fVisible && m_fAppEnabled && HasAdminAccess());

	if (m_fCompatibilityMode)
	{
		//
		// Set selection in combo box to match current app state
		//
		int nSel = -1;

		switch(m_dwAppProtection)
		{
		case CWamInterface::APP_INPROC:
			nSel = m_nSelInProc;
			break;
		case CWamInterface::APP_POOLEDPROC:
			ASSERT(m_pApplication->SupportsPooledProc());
			nSel = m_nSelPooledProc;
			break;
		case CWamInterface::APP_OUTOFPROC:
			nSel = m_nSelOutOfProc;
			break;
		default:
			ASSERT("Bogus app protection level");
		}

		ASSERT(nSel >= 0);
		m_combo_Process.SetCurSel(nSel);
	}
	else
	{
	}

	m_combo_Process.EnableWindow(fVisible && m_fAppEnabled && HasAdminAccess());
	GetDlgItem(IDC_STATIC_PERMISSIONS)->EnableWindow(fVisible && HasAdminAccess());
	m_combo_Permissions.EnableWindow(fVisible && HasAdminAccess());
	GetDlgItem(IDC_STATIC_APP_PROMPT)->EnableWindow(fVisible && m_fIsAppRoot && HasAdminAccess());
	m_edit_AppFriendlyName.EnableWindow(fVisible && m_fIsAppRoot && HasAdminAccess());
	m_button_Configuration.EnableWindow(fVisible && m_fAppEnabled);

	//
	// Write out the verbose starting point.  
	//
	CString str;
	FriendlyAppRoot(m_strAppRoot, str);
	CWnd * pWnd = CWnd::FromHandle(GetDlgItem(IDC_STATIC_STARTING_POINT)->m_hWnd);
	FitPathToControl(*pWnd, str);

	m_edit_AppFriendlyName.SetWindowText(m_strAppFriendlyName);
	m_button_Unload.EnableWindow(fVisible && m_dwAppState == APPSTATUS_RUNNING);

	//
	// Restore (see note on top)
	//
	m_fRecordChanges = fOld;
}

void
CW3DirPage::OnCheckRead() 
{
	m_fRead = !m_fRead;
	SetAuthoringState(FALSE);
	OnItemChanged();
}

void
CW3DirPage::OnCheckWrite() 
{
	m_fWrite = !m_fWrite;
	if (!CheckWriteAndExecWarning())
	{
		//
		// Undo
		//
		m_fWrite = FALSE;
		m_check_Write.SetCheck(m_fWrite);
	}
	else
	{
		SetAuthoringState(FALSE);
		OnItemChanged();
	}
}

void 
CW3DirPage::OnCheckAuthor() 
{
	m_fAuthor = !m_fAuthor;
	SetAuthoringState(FALSE);
	if (!CheckWriteAndExecWarning())
	{
		//
		// Undo -- set script instead
		//
		m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
	}
	OnItemChanged();
}

void 
CW3DirPage::OnRadioDir() 
{
	ChangeTypeTo(RADIO_DIRECTORY);
}

void 
CW3DirPage::OnRadioRedirect() 
{
	ChangeTypeTo(RADIO_REDIRECT);
}

void 
CW3DirPage::OnButtonCreateRemoveApp() 
{
	BeginWaitCursor();

	CError err(m_pApplication->RefreshAppState());

	if (m_fAppEnabled)
	{
		//
		// App currently exists -- delete it
		//
		err = m_pApplication->Delete();
	}
	else
	{
		CString strAppName = m_strAlias;
		DWORD dwAppProtState = 
			m_pApplication->SupportsPooledProc() ? 
			CWamInterface::APP_POOLEDPROC : CWamInterface::APP_INPROC;

		if (m_fCompatibilityMode)
		{
			//
			// Attempt to create a pooled-proc by default;  failing
			// that if it's not supported, create it in proc
			//
			err = m_pApplication->Create(strAppName, dwAppProtState);
		}
		else
		{
			CString pool;
			err = ((CW3Sheet *)GetSheet())->QueryDefaultPoolId(pool);
			if (err.Succeeded())
			{
				err = m_pApplication->CreatePooled(strAppName, dwAppProtState, pool, FALSE);
			}
		}
	}

	if (err.Succeeded())
	{
		RefreshAppState();
		NotifyMMC();  
	}

	//
	// Move app data to the controls
	//
	UpdateData(FALSE);

	EndWaitCursor();    

	ASSERT(err.Succeeded());
	err.MessageBoxOnFailure();    
	if (err.Succeeded())
	{
		SetApplicationState();
		OnItemChanged();
	}
}

#include "..\AppConfig\AppConfig.h"
extern CInetmgrApp theApp;

void 
CW3DirPage::OnButtonConfiguration() 
/*++

Routine Description:

    Pass on "configuration" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
	IIISAppConfig * pAppConfig = NULL;
	CLSID clsID;
	HRESULT hr;

	if (  SUCCEEDED(hr = CLSIDFromProgID(OLESTR("AppConfig.IISAppConfig"), &clsID))
		&& SUCCEEDED(hr = ::CoCreateInstance(clsID, 
		NULL, 
		CLSCTX_ALL, 
		__uuidof(IIISAppConfig), 
		(void **)&pAppConfig)))
	{
		pAppConfig->put_ComputerName((LPTSTR)(LPCTSTR)QueryServerName());
		pAppConfig->put_MetaPath((LPTSTR)QueryMetaPath());
		pAppConfig->put_HelpPath((LPTSTR)theApp.m_pszHelpFilePath);
		pAppConfig->put_UserName((LPTSTR)(LPCTSTR)m_strUserName);
		pAppConfig->put_UserPassword((LPTSTR)(LPCTSTR)m_strPassword);
		DWORD version = MAKELONG(
			GetSheet()->QueryMajorVersion(),
			GetSheet()->QueryMinorVersion());
		pAppConfig->put_ServiceVersion(version);
		BOOL mode = ((CW3Sheet *)GetSheet())->InCompatibilityMode();
		pAppConfig->put_ServiceCompatMode(mode);
		pAppConfig->Run();
		pAppConfig->Release();
		OnItemChanged();
	}
}

void 
CW3DirPage::OnSelchangeComboProcess() 
{
	OnItemChanged();
}

void 
CW3DirPage::OnSelchangeComboPermissions() 
{
	m_nPermissions = m_combo_Permissions.GetCurSel();
	ASSERT(m_nPermissions >= COMBO_NONE && m_nPermissions <= COMBO_EXECUTE);

	if (!CheckWriteAndExecWarning())
	{
		//
		// Undo -- set script instead
		//
		m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
	}

	OnItemChanged();
}

void 
CW3DirPage::OnButtonUnloadApp() 
{
}

BOOL
CW3DirPage::CheckWriteAndExecWarning()
{
	if (m_nPermissions == COMBO_EXECUTE && m_fWrite)
	{
		if (::AfxMessageBox(IDS_WRN_WRITE_EXEC, MB_YESNO | MB_DEFBUTTON2 ) != IDYES)
		{
			return FALSE;
		}
	}

	OnItemChanged();

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\w3sht.cpp ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        w3sht.cpp

   Abstract:

        WWW Property Sheet

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "shts.h"
#include "w3sht.h"
#include "iisfilt.h"
#include "fltdlg.h"
#include "iisobj.h"

// from pshed.cpp
HRESULT CallINetCfg(BOOL Install);

//
// Help IDs
//
#define HIDD_DIRECTORY_PROPERTIES       (IDD_WEB_DIRECTORY_PROPERTIES + 0x20000)
#define HIDD_HOME_DIRECTORY_PROPERTIES  (HIDD_DIRECTORY_PROPERTIES + 0x20000)
#define HIDD_FS_DIRECTORY_PROPERTIES    (HIDD_DIRECTORY_PROPERTIES + 0x20001)
#define HIDD_FS_FILE_PROPERTIES         (HIDD_DIRECTORY_PROPERTIES + 0x20002)


//
// Metabase node ID
//
const LPCTSTR g_cszSvc =            _T("W3SVC");
const LPCTSTR g_cszFilters =        _T("Filters");
const LPCTSTR g_cszSSLKeys =        _T("SSLKeys");



//
// Helper Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL
IsCertInstalledOnServer(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Check to see if a certificate is installed on this virtual server.
    This routine only checks that the cert metabase key was read in.

    by boydm

Arguments:

    None

Return Value:

    TRUE if a certificate are installed, FALSE otherwise

--*/
{
    CError err;
    BOOL fCertInstalled = FALSE;
    CW3InstanceProps * ppropInst;
    CString strNewPath;

    //
    // Get the instance properties
    //
    CMetabasePath::GetInstancePath(lpszMDPath,strNewPath);
    ppropInst = new CW3InstanceProps(pAuthInfo, strNewPath);

    //
    // If it succeeded, load the data, then check the answer
    //
    if (ppropInst)
    {
        err = ppropInst->LoadData();

        if (err.Succeeded())
        {
            fCertInstalled = !(MP_V(ppropInst->m_CertHash).IsEmpty());
        }
    }

    //
    // Clean up since we don't really need the ppropInst after this.
    //
    if (ppropInst)
    {
        delete ppropInst;
        ppropInst = NULL;
    }

    //
    // if that test failed. we want to check the metabase key itself
    // since the above check is all cached information and won't reflect
    // any certificates which are removed/added via scripts, while mmc is open
    // 
    if (!fCertInstalled)
    {
	    CMetaKey key(pAuthInfo,strNewPath,METADATA_PERMISSION_READ);
	    if (key.Succeeded())
        {
		    CBlob hash;
		    if (SUCCEEDED(key.QueryValue(MD_SSL_CERT_HASH, hash)))
            {
                fCertInstalled = TRUE;
            }
        }
    }

    //
    // If that test failed, we may be admining a downlevel IIS4 machine.
    // Unfortunately  we can't tell by examining the capability bits, 
    // so look to see if the old certs are there.
    // 
    if (!fCertInstalled)
    {
        CString         strKey;
        CMetaEnumerator me(pAuthInfo, CMetabasePath(SZ_MBN_WEB));
        HRESULT err = me.Next(strKey, g_cszSSLKeys);
        fCertInstalled = SUCCEEDED(err);
    }

    return fCertInstalled;
}



//
// CW3InstanceProps implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CW3InstanceProps::CW3InstanceProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    Constructor for WWW instance properties

Arguments:

    CComAuthInfo * pAuthInfo        : COM Authentication info
    LPCTSTR lpszMDPath              : MD Path

Return Value:

    None.

--*/
    : CInstanceProps(pAuthInfo, lpszMDPath, 80U),
      /**/
      m_nMaxConnections(INITIAL_MAX_CONNECTIONS),
      m_nConnectionTimeOut((LONG)900L),
      m_strlSecureBindings(),
      m_dwLogType(MD_LOG_TYPE_DISABLED),
      /**/
      m_fUseKeepAlives(TRUE),
      m_fEnableCPUAccounting(FALSE),
      m_nServerSize(MD_SERVER_SIZE_MEDIUM),
      m_dwMaxBandwidth(INFINITE_BANDWIDTH),
      /**/
      m_dwCPULimitLogEventRaw(INFINITE_CPU_RAW),
      m_dwCPULimitPriorityRaw(0),
      m_dwCPULimitPauseRaw(0),
      m_dwCPULimitProcStopRaw(0),
      /**/
      m_acl(),
      /**/
      m_dwDownlevelInstance(1),
      m_CertHash()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CW3InstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CInstanceProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      HANDLE_META_RECORD(MD_MAX_GLOBAL_CONNECTIONS, m_nMaxConnections)
      HANDLE_META_RECORD(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      HANDLE_META_RECORD(MD_SECURE_BINDINGS,     m_strlSecureBindings)
      HANDLE_META_RECORD(MD_LOG_TYPE,            m_dwLogType)
      HANDLE_META_RECORD(MD_SERVER_SIZE,         m_nServerSize)
      HANDLE_META_RECORD(MD_ALLOW_KEEPALIVES,    m_fUseKeepAlives)
      HANDLE_META_RECORD(MD_MAX_BANDWIDTH,       m_dwMaxBandwidth)
      HANDLE_META_RECORD(MD_MAX_GLOBAL_BANDWIDTH,m_dwMaxGlobalBandwidth)
      HANDLE_META_RECORD(MD_GLOBAL_LOG_IN_UTF_8, m_fLogUTF8)
      HANDLE_META_RECORD(MD_CPU_LIMITS_ENABLED,  m_fEnableCPUAccounting)
      HANDLE_META_RECORD(MD_CPU_LIMIT_LOGEVENT,  m_dwCPULimitLogEventRaw)
      HANDLE_META_RECORD(MD_CPU_LIMIT_PRIORITY,  m_dwCPULimitPriorityRaw)
      HANDLE_META_RECORD(MD_CPU_LIMIT_PAUSE,     m_dwCPULimitPauseRaw)
      HANDLE_META_RECORD(MD_CPU_LIMIT_PROCSTOP,  m_dwCPULimitProcStopRaw)
      HANDLE_META_RECORD(MD_ADMIN_ACL,           m_acl)
      HANDLE_META_RECORD(MD_DOWNLEVEL_ADMIN_INSTANCE, m_dwDownlevelInstance);
      HANDLE_META_RECORD(MD_SSL_CERT_HASH,       m_CertHash)
      HANDLE_META_RECORD(MD_SSL_CERT_STORE_NAME, m_strCertStoreName)
      HANDLE_META_RECORD(MD_SSL_CTL_IDENTIFIER,  m_strCTLIdentifier)
      HANDLE_META_RECORD(MD_SSL_CTL_STORE_NAME,  m_strCTLStoreName)
    END_PARSE_META_RECORDS
    if (CMetabasePath::IsMasterInstance(QueryMetaRoot()))
	{
		m_dwMaxBandwidth = m_dwMaxGlobalBandwidth;
	}
}



/* virtual */
HRESULT
CW3InstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CInstanceProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    BEGIN_META_WRITE()
      META_WRITE(MD_MAX_GLOBAL_CONNECTIONS, m_nMaxConnections)
      META_WRITE(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      META_WRITE(MD_SECURE_BINDINGS,     m_strlSecureBindings)
      META_WRITE(MD_LOG_TYPE,            m_dwLogType)
      META_WRITE(MD_SERVER_SIZE,         m_nServerSize)
      META_WRITE(MD_ALLOW_KEEPALIVES,    m_fUseKeepAlives)
      META_WRITE(MD_GLOBAL_LOG_IN_UTF_8, m_fLogUTF8)
	  if (CMetabasePath::IsMasterInstance(QueryMetaRoot()))
	  {
		 META_WRITE(MD_MAX_GLOBAL_BANDWIDTH,m_dwMaxBandwidth)
	  }
	  else
	  {
		 META_WRITE(MD_MAX_BANDWIDTH,       m_dwMaxBandwidth)
	  }
      META_WRITE(MD_CPU_LIMITS_ENABLED,  m_fEnableCPUAccounting)
      META_WRITE(MD_CPU_LIMIT_LOGEVENT,  m_dwCPULimitLogEventRaw)
      META_WRITE(MD_CPU_LIMIT_PRIORITY,  m_dwCPULimitPriorityRaw)
      META_WRITE(MD_CPU_LIMIT_PAUSE,     m_dwCPULimitPauseRaw)
      META_WRITE(MD_CPU_LIMIT_PROCSTOP,  m_dwCPULimitProcStopRaw)
      META_WRITE(MD_ADMIN_ACL,           m_acl)
      META_WRITE(MD_DOWNLEVEL_ADMIN_INSTANCE, m_dwDownlevelInstance);
      //META_WRITE(MD_SSL_CERT_HASH,       m_CertHash)
      //META_WRITE(MD_SSL_CERT_STORE_NAME, m_strCertStoreName)
      META_WRITE(MD_SSL_CTL_IDENTIFIER,  m_strCTLIdentifier)
      META_WRITE(MD_SSL_CTL_STORE_NAME,  m_strCTLStoreName)
    END_META_WRITE(err);

    if (err.Succeeded())
    {
        if (m_dwMaxBandwidth == INFINITE_BANDWIDTH && m_fUninstallPSHED)
        {
            err = CallINetCfg(FALSE);
        }
        else if (m_dwMaxBandwidth != INFINITE_BANDWIDTH)
        {
            err = CallINetCfg(TRUE);
        }
    }
    return err;
}



//
// CW3DirProps Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CW3DirProps::CW3DirProps(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMDPath
    )
/*++

Routine Description:

    WWW Directory Properties Constructor

Arguments:

    CComAuthInfo * pAuthInfo        : COM Authentication info
    LPCTSTR lpszMDPath              : MD Path

Return Value:

    N/A

--*/
    : CChildNodeProps(
        pAuthInfo,
        lpszMDPath,
        WITH_INHERITANCE,
        FALSE               // Complete information
        ),
      /**/
      m_strUserName(),
      m_strPassword(),
      m_strDefaultDocument(),
      m_strFooter(),
      m_dwDirBrowsing(0L),
      m_fEnableFooter(FALSE),
      m_fDontLog(FALSE),
      m_fIndexed(FALSE),
      /**/
      m_strExpiration(),
      m_strlCustomHeaders(),
      /**/
      m_strlCustomErrors(),
      /**/
      m_strAnonUserName(),
      m_strAnonPassword(),
      m_fPasswordSync(TRUE),
      m_fU2Installed(FALSE),
      m_fUseNTMapper(FALSE),
      m_dwAuthFlags(MD_AUTH_ANONYMOUS),
      m_dwSSLAccessPermissions(0L),
      m_strBasicDomain(),
      m_strRealm(),
      m_ipl()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CW3DirProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CChildNodeProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,  m_pbMDData)
      //
      // VDir Page
      //
      HANDLE_META_RECORD(MD_VR_USERNAME,        m_strUserName)
      HANDLE_META_RECORD(MD_VR_PASSWORD,        m_strPassword)
      HANDLE_META_RECORD(MD_DEFAULT_LOAD_FILE,  m_strDefaultDocument);
      HANDLE_META_RECORD(MD_FOOTER_ENABLED,     m_fEnableFooter);
      HANDLE_META_RECORD(MD_FOOTER_DOCUMENT,    m_strFooter);
      HANDLE_META_RECORD(MD_DIRECTORY_BROWSING, m_dwDirBrowsing);
      HANDLE_META_RECORD(MD_DONT_LOG,           m_fDontLog);
      HANDLE_META_RECORD(MD_IS_CONTENT_INDEXED, m_fIndexed);
      //
      // HTTP Page
      //
      HANDLE_META_RECORD(MD_HTTP_EXPIRES,       m_strExpiration);
      HANDLE_META_RECORD(MD_HTTP_CUSTOM,        m_strlCustomHeaders);
      //
      // Custom Errors
      //
      HANDLE_META_RECORD(MD_CUSTOM_ERROR,       m_strlCustomErrors);
      //
      // Security page
      //
      HANDLE_META_RECORD(MD_AUTHORIZATION,        m_dwAuthFlags);
      HANDLE_META_RECORD(MD_SSL_ACCESS_PERM,      m_dwSSLAccessPermissions);
      HANDLE_META_RECORD(MD_DEFAULT_LOGON_DOMAIN, m_strBasicDomain);
      HANDLE_META_RECORD(MD_REALM,                m_strRealm);
      HANDLE_META_RECORD(MD_ANONYMOUS_USER_NAME,  m_strAnonUserName)
      HANDLE_META_RECORD(MD_ANONYMOUS_PWD,        m_strAnonPassword)
      HANDLE_META_RECORD(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
      HANDLE_META_RECORD(MD_U2_AUTH,              m_fU2Installed)
      HANDLE_META_RECORD(MD_SSL_USE_DS_MAPPER,    m_fUseNTMapper);
      HANDLE_META_RECORD(MD_IP_SEC,               m_ipl);
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CW3DirProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CChildNodeProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    //
    // CODEWORK: Consider DDX/DDV like methods which do both
    // ParseFields and WriteDirtyProps in a single method.  Must
    // take care not to write data which should only be read, not
    // written
    //
    BEGIN_META_WRITE()
      //
      // VDir Page
      //
      META_WRITE(MD_VR_USERNAME,           m_strUserName)
      META_WRITE(MD_VR_PASSWORD,           m_strPassword)
      META_WRITE(MD_DEFAULT_LOAD_FILE,     m_strDefaultDocument)
      META_WRITE(MD_FOOTER_ENABLED,        m_fEnableFooter)
      META_WRITE(MD_FOOTER_DOCUMENT,       m_strFooter)
      META_WRITE(MD_DIRECTORY_BROWSING,    m_dwDirBrowsing)
      META_WRITE(MD_DONT_LOG,              m_fDontLog)
      META_WRITE(MD_IS_CONTENT_INDEXED,    m_fIndexed)
      //
      // HTTP Page
      //
      META_WRITE(MD_HTTP_EXPIRES,          m_strExpiration)
      META_WRITE(MD_HTTP_CUSTOM,           m_strlCustomHeaders)
      //
      // Custom Errors
      //
      META_WRITE(MD_CUSTOM_ERROR,          m_strlCustomErrors)
      //
      // Security page
      //
      META_WRITE(MD_AUTHORIZATION,         m_dwAuthFlags)
      META_WRITE(MD_SSL_ACCESS_PERM,       m_dwSSLAccessPermissions)
      META_WRITE(MD_REALM,                 m_strRealm)
      META_WRITE(MD_DEFAULT_LOGON_DOMAIN,  m_strBasicDomain)
      META_WRITE(MD_ANONYMOUS_USER_NAME,   m_strAnonUserName)
      META_WRITE(MD_ANONYMOUS_PWD,         m_strAnonPassword)
      META_WRITE(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
      META_WRITE(MD_SSL_USE_DS_MAPPER,     m_fUseNTMapper)
      META_WRITE(MD_IP_SEC,                m_ipl)
    END_META_WRITE(err);

    return err;
}



//
// CIISFilter Implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISFilter::CIISFilter()
/*++

Routine Description:

    Filter contructor for a new filter

Arguments:

    None

Return Value:

    N/A

--*/
    : CObjectPlus(),
      m_strName(),

      //
      // Default Values
      //
      m_strExecutable(),
      m_nPriority(FLTR_PR_INVALID),
      m_nOrder(-1),
      m_dwState(MD_FILTER_STATE_UNLOADED),
      m_dwFlags(0L),
      m_hrResult(S_OK),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fEnabled(TRUE),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
}



CIISFilter::CIISFilter(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Fully defined constructor

Arguments:

    CMetaKey * pKey         : Open key to read from
    LPCTSTR lpszName        : Name of the filter

Return Value:

    N/A

--*/
    : m_strName(lpszName),
      //
      // Default Values
      //
      m_strExecutable(),
      m_nPriority(FLTR_PR_INVALID),
      m_nOrder(-1),
      m_dwState(MD_FILTER_STATE_UNLOADED),
      m_dwFlags(0L),
      m_hrResult(S_OK),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fEnabled(TRUE),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
    ASSERT(pKey != NULL);

    m_hrResult = pKey->QueryValue(
        MD_FILTER_IMAGE_PATH, 
        m_strExecutable,
        NULL,
        m_strName
        );

    pKey->QueryValue(MD_FILTER_ENABLED, m_fEnabled, NULL, m_strName);
    pKey->QueryValue(MD_FILTER_STATE,   m_dwState,  NULL, m_strName);
    pKey->QueryValue(MD_FILTER_FLAGS,   m_dwFlags,  NULL, m_strName);
    
    if (m_dwFlags & SF_NOTIFY_ORDER_HIGH)
    {
        m_nPriority = FLTR_PR_HIGH;
    }
    else if (m_dwFlags & SF_NOTIFY_ORDER_MEDIUM)
    {
        m_nPriority = FLTR_PR_MEDIUM;
    }
    else if (m_dwFlags & SF_NOTIFY_ORDER_LOW)
    {
        m_nPriority = FLTR_PR_LOW;
    }
    else
    {
        m_nPriority = FLTR_PR_INVALID;
    }
}



CIISFilter::CIISFilter(
    IN const CIISFilter & flt
    )
/*++

Routine Description:

    Copy Constructor

Arguments:

    const CIISFilter & flt : Source filter object

Return Value:

    N/A

--*/
    : m_strName(flt.m_strName),
      m_strExecutable(flt.m_strExecutable),
      m_nPriority(flt.m_nPriority),
      m_nOrder(flt.m_nOrder),
      m_hrResult(flt.m_hrResult),
      m_dwState(flt.m_dwState),
      m_dwFlags(flt.m_dwFlags),
      m_dwWin32Error(flt.m_dwWin32Error),
      m_fEnabled(flt.m_fEnabled),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
}



HRESULT
CIISFilter::Write(
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Write the current value to the metabase

Arguments:

    CMetaKey * pKey      : Open key

Return Value:

    HRESULT

--*/
{
    ASSERT(pKey != NULL);

    CError err;

    CString strKey(_T("IIsFilter"));
    err = pKey->SetValue(MD_KEY_TYPE, strKey, NULL, QueryName());

    if (err.Succeeded())
    {
        err = pKey->SetValue(
            MD_FILTER_IMAGE_PATH, 
            m_strExecutable, 
            NULL, 
            QueryName()
            );
    }

    return err;    
}



int
CIISFilter::OrderByPriority(
    IN const CObjectPlus * pobAccess
    ) const
/*++

Routine Description:

    Compare two filters against each other, and sort on priority first, and
    order secondarily.

Arguments:

    const CObjectPlus * pobAccess : This really refers to another
                                    CIISFilter to be compared to.

Return Value:

    Sort (+1, 0, -1) return value

--*/
{
    const CIISFilter * pob = (CIISFilter *)pobAccess;

    if (pob->m_nPriority != m_nPriority)
    {
        return pob->m_nPriority - m_nPriority;
    }

    //
    // Sort by order in reverse order
    //
    return m_nOrder - pob->m_nOrder;
}



//
// Static initialization
//
const LPCTSTR CIISFilterList::s_lpszSep = _T(",");



//
// CIISFilterList implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CIISFilterList::CIISFilterList(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMetaPath
    )
/*++

Routine Description:

    Constructor for filter list

Arguments:

    LPCTSTR lpszServerName     : Server name
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)

Return Value:

    N/A

--*/
    : CMetaKey(
        pAuthInfo,
        CMetabasePath(FALSE, lpszMetaPath, g_cszFilters),
        METADATA_PERMISSION_READ
        ),
      m_hrResult(S_OK),
      m_strFilterOrder(),
      m_fFiltersLoaded(FALSE)
{
    m_hrResult = CMetaKey::QueryResult();

    if (SUCCEEDED(m_hrResult))
    {
        m_hrResult = QueryValue(MD_FILTER_LOAD_ORDER, m_strFilterOrder);
    }
    
    if (    m_hrResult == CError::HResult(ERROR_PATH_NOT_FOUND)
        ||  m_hrResult == MD_ERROR_DATA_NOT_FOUND
        )
    {
        //
        // Harmless
        //
        m_hrResult = S_OK;
    }    

    if (IsOpen())
    {
        Close();
    }
}



HRESULT
CIISFilterList::LoadAllFilters()
/*++

Routine Description:

    Loop through the filter order string, and load information
    about each filter in turn.

Arguments:

    None.

Return Value:

    HRESULT.  The first error stops filter loading.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    if (m_fFiltersLoaded)
    {
        //
        // Already done
        //
        return S_OK;
    }

    int cItems = 0;
    CError err(ReOpen(METADATA_PERMISSION_READ));

    if (err.Failed())
    {
        return err;
    }

    try
    {
        CString strSrc(m_strFilterOrder);
        LPTSTR lp = strSrc.GetBuffer(0);
        while (isspace(*lp) || *lp == (TCHAR)s_lpszSep)
            lp++;
        lp = _tcstok(lp, s_lpszSep);

        int nOrder = 0;

        while (lp)
        {
            CString str(lp);
            str.TrimLeft();
            str.TrimRight();

            TRACEEOLID("Adding filter: " << str);

            CIISFilter * pFilter = new CIISFilter(this, str);
            err = pFilter->QueryResult();

            if (err.Failed())
            {
                break;
            }

            pFilter->m_nOrder = nOrder++;
            m_oblFilters.AddTail(pFilter);

            lp = _tcstok(NULL, s_lpszSep);
            ++cItems;
        }

        //
        // Sort filters list
        //
        m_oblFilters.Sort(
            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)
            &CIISFilter::OrderByPriority
            );
    }
    catch(CMemoryException * e)
    {
        e->Delete();
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    m_fFiltersLoaded = err.Succeeded();

    if (IsOpen())
    {
        Close();
    }

    return err;    
}



HRESULT
CIISFilterList::WriteIfDirty()
/*++

Routine Description:

    Write all the changes in the filters list to the metabase

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
    CError err;

    CString strNewOrder;
    VERIFY(BuildFilterOrderString(strNewOrder));

    //
    // Check to see if this new list is different
    //
    if (!strNewOrder.CompareNoCase(m_strFilterOrder) && !HasDirtyFilter())
    {
        //
        // The priority list hasn't changed, and no filter is marked
        // as dirty, so all done.
        //
        return err;
    }

    //
    // It's dirty -- save it
    //
    do
    {
        err = ReOpen(METADATA_PERMISSION_WRITE);

        if (err.Failed())
        {
            if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
            {
                //
                // Path didn't exist yet, create it and reopen
                // it.
                //
                err = CreatePathFromFailedOpen();

                if (err.Succeeded())
                {
                    err = ReOpen(METADATA_PERMISSION_WRITE);
                }
            }

            if (err.Failed())
            {
                break;
            }
        }

        //
        // Delete deleted filters
        //
        POSITION pos1, pos2;

        for (pos1 = m_oblFilters.GetHeadPosition(); (pos2 = pos1) != NULL; )
        {
            CIISFilter * pFilter = (CIISFilter *)m_oblFilters.GetNext(pos1);
            ASSERT(pFilter != NULL);

            if (pFilter->IsFlaggedForDeletion())
            {
                TRACEEOLID("Deleting filter " << pFilter->QueryName());
                err = DeleteKey(pFilter->QueryName());

                if (err.Failed())
                {
                    break;
                }

                m_oblFilters.RemoveAt(pos2);
            }
        }

        if (err.Failed())
        {
            break;
        }

        //
        // Two passes are necessary, because the filter may
        // have been re-added after it was deleted from the
        // list as new entry.  This could be somewhat improved
        //
        ResetEnumerator();

        while(MoreFilters())
        {
            CIISFilter * pFilter = GetNextFilter();
            ASSERT(pFilter != NULL);

            if (pFilter->IsDirty())
            {
                TRACEEOLID("Writing filter " << pFilter->QueryName());
                err = pFilter->Write(this);

                if (err.Failed())
                {
                    break;
                }

                pFilter->Dirty(FALSE);
            }
        }

        if (err.Failed())
        {
            break;
        }

        //
        // Write the new filter load order
        //
        err = SetValue(MD_FILTER_LOAD_ORDER, strNewOrder);

        if (err.Failed())
        {
            break;
        }

        CString strKey(_T("IIsFilters"));
        err = SetValue(MD_KEY_TYPE, strKey);
        err = SetValue(MD_FILTER_LOAD_ORDER, strNewOrder);

        m_strFilterOrder = strNewOrder;
    }
    while(FALSE);

    if (IsOpen())
    {
        Close();
    }

    return err;
}



POSITION
CIISFilterList::GetFilterPositionByIndex(
    IN  int nSel
    )
/*++

Routine Description:

    Return the position of a filter object by index, skipping filters
    marked for deletion.

Arguments:

    int nSel        - 0 based index into the list

Return Value:

    The POSITION into the filters ObList of the filter at the index
    specified, or NULL if the filter is not found.

--*/
{
    int nIndex = -1;
    CIISFilter * pFilter;
    POSITION pos, 
             posReturn = NULL;

    pos = m_oblFilters.GetHeadPosition();

    while(pos && nIndex < nSel)
    {
        posReturn = pos;
        pFilter = (CIISFilter *)m_oblFilters.GetNext(pos);

        //
        // Skipping deleted filters
        //
        if (!pFilter->IsFlaggedForDeletion())
        {
            ++nIndex;
        }
    }
    
    return posReturn;
}



BOOL
CIISFilterList::ExchangePositions(
    IN  int nSel1,
    IN  int nSel2,
    OUT CIISFilter *& p1,
    OUT CIISFilter *& p2
    )
/*++

Routine Description:

    Exchange the positions of two filters in the list

Arguments:

    int nSel1           : Item 1
    int nSel2           : Item 2
    CIISFilter *& p1    : Returns the item moved to position 1
    CIISFilter *& p2    : Returns the item moved to position 2

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    //
    // Fetch filters at the two positions (deleted filters are
    // skipped in the index count)
    //
    POSITION pos1 = GetFilterPositionByIndex(nSel1);
    POSITION pos2 = GetFilterPositionByIndex(nSel2);
    p1 = pos2 ? (CIISFilter *)m_oblFilters.GetAt(pos2) : NULL;
    p2 = pos1 ? (CIISFilter *)m_oblFilters.GetAt(pos1) : NULL;

    if (!p1 || !p2)
    {
        TRACEEOLID("Invalid internal state -- filter exchange impossible");        
        ASSERT(FALSE);

        return FALSE;
    }

    TRACEEOLID("Filter (1) name is " << p1->m_strName);
    TRACEEOLID("Filter (2) name is " << p2->m_strName);

    //
    // Exchange
    //
    m_oblFilters.SetAt(pos1, p1);
    m_oblFilters.SetAt(pos2, p2);

    //
    // Success
    //
    return TRUE;
}



LPCTSTR
CIISFilterList::BuildFilterOrderString(
    OUT CString & strFilterOrder
    )
/*++

Routine Description:

    Convert the oblist of filters to a single filter order string
    fit to be stuffed into the metabase

Arguments:

    CString & strFilterOrder        : Output to receive the order string

Return Value:

    A pointer to the new filter order string.

--*/
{
    BOOL fFirst = TRUE;
    POSITION pos = m_oblFilters.GetHeadPosition();

    strFilterOrder.Empty();

    while(pos)
    {
        CIISFilter * pFlt = (CIISFilter *)m_oblFilters.GetNext(pos);

        if (!pFlt->IsFlaggedForDeletion())
        {
            if (!fFirst)
            {
                strFilterOrder += s_lpszSep;
            }
            else
            {
                fFirst = FALSE;
            }

            strFilterOrder += pFlt->m_strName;
        }
    }

    return (LPCTSTR)strFilterOrder;
}



BOOL
CIISFilterList::HasDirtyFilter() const
/*++

Routine Description:

    Go through the list of filters, and return TRUE if any filter
    in the list is dirty or flagged for deletion

Arguments:

    None

Return Value:

    TRUE if any filter is dirty or flagged for deletion.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    POSITION pos = m_oblFilters.GetHeadPosition();

    while(pos)
    {
        CIISFilter * pFilter = (CIISFilter *)m_oblFilters.GetNext(pos);

        if (pFilter->IsFlaggedForDeletion() || pFilter->IsDirty())
        {
            return TRUE;
        }
    }

    return FALSE;
}



//
// CW3Sheet implementation
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



CW3Sheet::CW3Sheet(
    IN CComAuthInfo * pAuthInfo,
    IN LPCTSTR lpszMetaPath,
    IN DWORD   dwAttributes,
    IN CWnd *  pParentWnd,          OPTIONAL
    IN LPARAM  lParam,              OPTIONAL
    IN LONG_PTR    handle,              OPTIONAL
    IN UINT    iSelectPage          
    )
/*++

Routine Description:

    WWW Property sheet constructor

Arguments:

    CComAuthInfo * pAuthInfo  : Authentication information
    LPCTSTR lpszMetPath       : Metabase path
    DWORD   dwAttributes      : File attributes
    CWnd * pParentWnd         : Optional parent window
    LPARAM lParam             : MMC Console parameter
    LONG_PTR handle           : MMC Console handle
    UINT iSelectPage          : Initial page to be selected

Return Value:

    N/A

--*/
    : CInetPropertySheet(
        pAuthInfo,
        lpszMetaPath,
        pParentWnd,
        lParam,
        handle,
        iSelectPage
        ),
      m_ppropInst(NULL),
      m_ppropDir(NULL),
      m_fNew(FALSE),
      m_dwAttributes(dwAttributes),
	  m_fCompatMode(FALSE)
{
}



CW3Sheet::~CW3Sheet()
/*++

Routine Description:

    Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    FreeConfigurationParameters();
}


HRESULT
CW3Sheet::SetKeyType()
{
	CError err;

	CIISObject * pNode = (CIISObject *)GetParameter();
	ASSERT(pNode != NULL);
	if (pNode == NULL)
	{
		return E_FAIL;
	}
	CMetaKey mk(QueryAuthInfo(), m_ppropDir->QueryMetaRoot(), METADATA_PERMISSION_WRITE);
	err = mk.QueryResult();
	if (err.Succeeded())
	{
		err = mk.SetValue(MD_KEY_TYPE, CString(pNode->GetKeyType(m_ppropDir->QueryMetaRoot())));
	}
	else if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
	{
		err.Reset();
	}
	return err;
}


HRESULT
CW3Sheet::SetSheetType(int fSheetType)
{
    m_fSheetType = fSheetType;
	return S_OK;
}


void
CW3Sheet::WinHelp(
    IN DWORD dwData,
    IN UINT nCmd
    )
/*++

Routine Description:

    WWW Property sheet help handler

Arguments:

    DWORD dwData            : WinHelp data (dialog ID)
    UINT nCmd               : WinHelp command

Return Value:

    None

Notes:

    Replace the dialog ID if this is the directory tab.  We have
    different help depending on virtual directory, home, file, directory.

--*/
{
    if (dwData == HIDD_DIRECTORY_PROPERTIES)
    {
        if (m_fSheetType == SHEET_TYPE_FILE)
        {
            dwData = HIDD_FS_FILE_PROPERTIES;
        }
        else if (m_fSheetType == SHEET_TYPE_DIR)
        {
            dwData = HIDD_FS_DIRECTORY_PROPERTIES;
        }
        else if (m_fSheetType == SHEET_TYPE_VDIR)
        {
            dwData = HIDD_DIRECTORY_PROPERTIES;
        }
        else if (m_fSheetType == SHEET_TYPE_SERVER)
        {
            dwData = HIDD_HOME_DIRECTORY_PROPERTIES;
        }
        else if  (m_fSheetType == SHEET_TYPE_SITE)
        {
            dwData = HIDD_HOME_DIRECTORY_PROPERTIES;
		}
        else
        {
            ASSERT(m_ppropDir != NULL);
            if (!::lstrcmpi(m_ppropDir->m_strAlias, g_cszRoot))
            {
                //
                // It's a home virtual directory -- change the ID
                //
                dwData = HIDD_HOME_DIRECTORY_PROPERTIES;
            }
        }

    }

    CInetPropertySheet::WinHelp(dwData, nCmd);
}



/* virtual */ 
HRESULT 
CW3Sheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Load base properties
    //
    CError err(CInetPropertySheet::LoadConfigurationParameters());

    if (err.Failed())
    {
        return err;
    }

    if (m_ppropInst == NULL)
    {
        //
        // First call -- load values
        //
        ASSERT(m_ppropDir == NULL);

        m_ppropInst = new CW3InstanceProps(QueryAuthInfo(), QueryInstancePath());
        m_ppropDir  = new CW3DirProps(QueryAuthInfo(), QueryDirectoryPath());

        if (!m_ppropInst || !m_ppropDir)
        {
            TRACEEOLID("LoadConfigurationParameters: OOM");
            SAFE_DELETE(m_ppropDir);
            SAFE_DELETE(m_ppropInst);

            err = ERROR_NOT_ENOUGH_MEMORY;
            return err;
        }

        err = m_ppropInst->LoadData();

        if (err.Succeeded())
        {
           err = m_ppropDir->LoadData();
		   if (err.Succeeded() && QueryMajorVersion() >= 6)
		   {
			   CMetaKey mk(QueryAuthInfo(), QueryServicePath(), METADATA_PERMISSION_READ);
			   err = mk.QueryResult();
			   if (err.Succeeded())
			   {
				   err = mk.QueryValue(MD_GLOBAL_STANDARD_APP_MODE_ENABLED, m_fCompatMode);
			   }
		   }
		   else if (err.Succeeded())
		   {
			   // We will enable this for IIS5.1 and lower
			   m_fCompatMode = TRUE;
		   }

        }
    }

    return err;
}



/* virtual */ 
void 
CW3Sheet::FreeConfigurationParameters()
/*++

Routine Description:

    Clean up configuration data

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Base class
    //
    CInetPropertySheet::FreeConfigurationParameters();

    ASSERT(m_ppropInst != NULL);
    ASSERT(m_ppropDir  != NULL);

    SAFE_DELETE(m_ppropInst);
    SAFE_DELETE(m_ppropDir);
}



DWORD
IsSSLEnabledOnServer(
    IN CComAuthInfo * pAuthInfo,
    OUT BOOL & fInstalled,
    OUT BOOL & fEnabled
    )
/*++

Routine Description:

   Determine if SSL is installed on the server.

Arguments:

    LPCTSTR lpszServer      : Server name
    BOOL & fInstalled       : Returns TRUE if SSL is installed
    BOOL & fEnabled         : Returns TRUE if SSL is enabled

Return Value:

    Error return code.


--*/
{
/*
    LPW3_CONFIG_INFO lp = NULL;
    CString str;
    DWORD err = ::W3GetAdminInformation((LPTSTR)lpszServer, &lp);
    if (err != ERROR_SUCCESS)
    {
        TRACEEOLID("Failed to determine if SSL is installed");

        return err;
    }

    fInstalled = (lp->dwEncCaps & ENC_CAPS_NOT_INSTALLED) == 0;
    fEnabled = (lp->dwEncCaps & ENC_CAPS_DISABLED) == 0;

    NETAPIBUFFERFREE(lp);

*/

    //
    // Above doesn't work for Beta I -- hack to assume true.
    //
    fInstalled = fEnabled = TRUE;

    return ERROR_SUCCESS;
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3Sheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


HRESULT
CW3Sheet::EnumAppPools(CMapStringToString& pools)
{
	CError err;
    CIISMBNode * p = (CIISMBNode *)GetParameter();
    ASSERT(p != NULL);
    CIISMachine * pMachine = p->GetOwner();
    ASSERT(pMachine != NULL);
    IConsoleNameSpace2 * pConsole 
           = (IConsoleNameSpace2 *)pMachine->GetConsoleNameSpace();
    ASSERT(pConsole != NULL);
    // Get machine handle from pOwner
    // then find handle to app pools container
    // and use cookie from this node to enumerate pools
    HSCOPEITEM hChild = NULL, hCurrent;
    LONG_PTR cookie;
    CIISMBNode * pNode = NULL;
    err = pConsole->GetChildItem(pMachine->QueryScopeItem(), &hChild, &cookie);
    while (err.Succeeded() && hChild != NULL)
    {
		pNode = (CIISMBNode *)cookie;
        ASSERT(pNode != NULL);
        if (lstrcmpi(pNode->GetNodeName(), SZ_MBN_APP_POOLS) == 0)
        {
			break;
        }
        hCurrent = hChild;
        err = pConsole->GetNextItem(hCurrent, &hChild, &cookie);
    }
    CAppPoolsContainer * pCont = (CAppPoolsContainer *)pNode;
    // expand container to enumerate pools
    err = pConsole->Expand(pCont->QueryScopeItem());
	// MMC returns Incorrect function error (0x80070001) instead of S_FALSE
//	if (err == S_FALSE)
//	{
		// already expanded
		err.Reset();
//	}
    if (err.Succeeded())
    {
		pConsole->GetChildItem(pCont->QueryScopeItem(), &hChild, &cookie);
		CAppPoolNode * pPool;
		while (err.Succeeded() && hChild != NULL)
		{
			pPool = (CAppPoolNode *)cookie;
            ASSERT(pPool != NULL);
			pools.SetAt(pPool->QueryDisplayName(), pPool->QueryNodeName());
            hCurrent = hChild;
            err = pConsole->GetNextItem(hCurrent, &hChild, &cookie);
		}
    }

	err.Reset();

	return err;
}

HRESULT
CW3Sheet::QueryDefaultPoolId(CString& id)
{
	CError err;
    CIISMBNode * p = (CIISMBNode *)GetParameter();
    ASSERT(p != NULL);
    CIISMachine * pMachine = p->GetOwner();
    ASSERT(pMachine != NULL);
    IConsoleNameSpace2 * pConsole 
           = (IConsoleNameSpace2 *)pMachine->GetConsoleNameSpace();
    ASSERT(pConsole != NULL);
    // Get machine handle from pOwner
    // then find handle to app pools container
    // and use cookie from this node to enumerate pools
    HSCOPEITEM hChild = NULL, hCurrent;
    LONG_PTR cookie;
    CIISMBNode * pNode = NULL;
    err = pConsole->GetChildItem(pMachine->QueryScopeItem(), &hChild, &cookie);
    while (err.Succeeded() && hChild != NULL)
    {
		pNode = (CIISMBNode *)cookie;
        ASSERT(pNode != NULL);
        if (lstrcmpi(pNode->GetNodeName(), SZ_MBN_APP_POOLS) == 0)
        {
			break;
        }
        hCurrent = hChild;
        err = pConsole->GetNextItem(hCurrent, &hChild, &cookie);
    }
    CAppPoolsContainer * pCont = (CAppPoolsContainer *)pNode;
	ASSERT(pCont != NULL);
	return pCont->QueryDefaultPoolId(id);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wdir.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wdir.h

   Abstract:
        WWW Directory (non-virtual) Properties Page Definitions

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __WDIR_H__
#define __WDIR__H_ 


class CW3DirPage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CW3DirPage)

//
// Constructor/Destructor
//
public:
    CW3DirPage(CInetPropertySheet * pSheet = NULL);
    ~CW3DirPage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_DIRECTORY,
        RADIO_REDIRECT,
    };

    enum
    {
        COMBO_NONE,
        COMBO_SCRIPT,
        COMBO_EXECUTE,
    };

    //{{AFX_DATA(CW3DirectoryPage)
    enum { IDD = IDD_WEB_DIRECTORY_PROPERTIES };
	// Path type
    int     m_nPathType;
    CButton m_radio_Dir;
    CButton m_radio_Redirect;
	// Local path
    CEdit   m_edit_Path;
	// permissions flags
    BOOL    m_fAuthor;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fBrowsingAllowed;
    BOOL    m_fLogAccess;
    BOOL    m_fIndexed;
	// permission buttons
    CButton m_check_Author;
    CButton m_check_Read;
    CButton m_check_Write;
    CButton m_check_DirBrowse;
	CButton m_check_LogAccess;
    CButton m_check_Index;
	// Redirection
    CEdit   m_edit_Redirect;
    CString m_strRedirectPath;
	// permissions
    BOOL    m_fChild;
    BOOL    m_fExact;
    BOOL    m_fPermanent;
	// permission buttons
    CButton m_check_Child;

//    CStatic m_static_Path;
    CStatic m_static_PathPrompt;

	// Application config controls
    CButton m_button_Unload;
    CButton m_button_CreateRemove;
    CButton m_button_Configuration;
    CString m_strAppFriendlyName;
    CEdit m_edit_AppFriendlyName;
    CString m_strAppRoot;
    CString m_strAlias;

    int m_nPermissions;
    CComboBox m_combo_Permissions;
    CComboBox m_combo_Process;

    CStatic m_static_ProtectionPrompt;
    //}}AFX_DATA

    
//    DWORD m_dwAccessPermissions;
    DWORD m_dwBitRangePermissions;
    DWORD m_dwBitRangeDirBrowsing;
    DWORD m_dwAccessPerms;
    DWORD m_dwDirBrowsing;
    DWORD m_dwAppProtection;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3DirPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3DirPage)
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckRead();
    afx_msg void OnCheckWrite();
    afx_msg void OnCheckAuthor();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioRedirect();
    afx_msg void OnButtonCreateRemoveApp();
    afx_msg void OnButtonUnloadApp();
    afx_msg void OnButtonConfiguration();
    afx_msg void OnSelchangeComboPermissions();
    afx_msg void OnSelchangeComboProcess();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void ShowControl(CWnd * pWnd, BOOL fShow);
    void ShowControl(UINT nID, BOOL fShow);
    void SetStateByType();
    void SetPathType();
    void SetAuthoringState(BOOL fAlterReadAndWrite = TRUE);
    void RefreshAppState();
    void ChangeTypeTo(int nNewType);
    int AddStringToComboBox(CComboBox & combo, UINT nID);
    BOOL CheckWriteAndExecWarning();
    DWORD GetAppStateFromComboSelection()  const;

protected:
    //
    // Remember/restore settings.
    //
    void SaveAuthoringState();
    void RestoreAuthoringState();
	void SetApplicationState();
    CString& FriendlyAppRoot(LPCTSTR lpAppRoot, CString& strStartingPoint);

private:
    BOOL  m_fCompatibilityMode;
    BOOL  m_fOriginalRead;
    BOOL  m_fOriginalWrite;
    BOOL  m_fRecordChanges;  
    BOOL  m_fAppEnabled;
    BOOL  m_fIsAppRoot;
    DWORD m_dwAppState;
    CString m_strRemove;
    CString m_strCreate;
    CString m_strEnable;
    CString m_strDisable;
    CString m_strWebFmt;
    CString m_strFullMetaPath;
    CString m_strPrompt[2];
    CString m_strUserName;
    CString m_strPassword;
    CIISApplication * m_pApplication;
    int m_nSelInProc;
    int m_nSelPooledProc;
    int m_nSelOutOfProc;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void 
CW3DirPage::ShowControl(UINT nID, BOOL fShow)
{
    ASSERT(nID > 0);
    ShowControl(GetDlgItem(nID), fShow);
}

inline int
CW3DirPage::AddStringToComboBox(CComboBox & combo, UINT nID)
{
    CString str;
    VERIFY(str.LoadString(nID));
    return combo.AddString(str);
}

#endif // __WFILE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\usersess.h ===
/*++

   Copyright    (c)    1994-1999    Microsoft Corporation

   Module  Name :

        usersess.h

   Abstract:

        FTP User Sessions Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __USERSESS_H__
#define __USERSESS_H__


class CFtpUserInfo : public CObjectPlus
/*++

Class Description:

    Connected FTP User object

Public Interface:

    CFtpUserInfo     : Constructor

    QueryUserID      : Get the user's ID code
    QueryAnonymous   : Return TRUE if the user logged on anonymously
    QueryHostAddress : Get the user's IP Address
    QueryConnectTime : Get the user's connect time
    QueryUserName    : Get the user's name
    OrderByName      : Sort helper
    OrderByTime      : Sort helper
    OrderByMachine   : Sort helper

--*/
{
//
// Construction
//
public:
    CFtpUserInfo(
        IN LPIIS_USER_INFO_1 lpUserInfo
        );

//
// Access Functions
//
public:
    DWORD QueryUserID() const { return m_idUser; }
    BOOL QueryAnonymous() const { return m_fAnonymous; }
    CIPAddress QueryHostAddress() const { return m_iaHost; }
    DWORD QueryConnectTime() const { return m_tConnect; }
    LPCTSTR QueryUserName() const { return m_strUser; }

//
// Sorting Helper Functions
//
public:
    int OrderByName(
        IN const CObjectPlus * pobFtpUser
        ) const;

    int OrderByTime(
        IN const CObjectPlus * pobFtpUser
        ) const;

    int OrderByHostAddress(
        IN const CObjectPlus * pobFtpUser
        ) const;

//
// Private Data
//
private:
    BOOL    m_fAnonymous;
    DWORD   m_idUser;
    DWORD   m_tConnect;
    CString m_strUser;
    CIPAddress m_iaHost;
};



class CFtpUsersListBox : public CHeaderListBox
{
/*++

Class Description:

    Listbox of CFtpUserInfo objects

Public Interface:

    CFtpUsersListBox : Constructor

    GetItem          : Get FtpUserInfo object
    AddItem          : Add FtpUserInfo object
    Initialize       : Initialize the listbox

--*/
    DECLARE_DYNAMIC(CFtpUsersListBox);

public:
    //
    // Number of bitmaps
    //
    static const nBitmaps;  

//
// Constructor/Destructor
//
public:
    CFtpUsersListBox();

//
// Access
//
public:
    CFtpUserInfo * GetItem(
        IN UINT nIndex
        );

    int AddItem(
        IN const CFtpUserInfo * pItem
        );

    virtual BOOL Initialize();

protected:
    virtual void DrawItemEx(
        IN CRMCListBoxDrawStruct & ds
        );

protected:
    CString m_strTimeSep;
};



class CUserSessionsDlg : public CDialog
{
/*++

Class Description:

    FTP User sessions dialog

Public Interface:

    CUserSessionsDlg : Constructor

--*/
//
// Construction
//
public:
    //
    // Standard Constructor
    //
    CUserSessionsDlg(
        LPCTSTR lpServerName,
        DWORD dwInstance,
        LPCTSTR pAdminName,
        LPCTSTR pAdminPassword,
        CWnd * pParent = NULL
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CUserSessionsDlg)
    enum { IDD = IDD_USER_SESSIONS };
    CStatic m_static_Total;
    CButton m_button_DisconnectAll;
    CButton m_button_Disconnect;
    //}}AFX_DATA

    CFtpUsersListBox m_list_Users;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CUserSessionsDlg)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CUserSessionsDlg)
    afx_msg void OnButtonDisconnect();
    afx_msg void OnButtonDisconnectAll();
    afx_msg void OnButtonRefresh();
    afx_msg void OnSelchangeListUsers();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnHeaderItemClick(UINT nID, NMHDR *pNMHDR, LRESULT *lResult);

    DECLARE_MESSAGE_MAP()

    int QuerySortColumn() const { return m_nSortColumn; }

    DWORD SortUsersList();
    HRESULT RefreshUsersList();
    HRESULT DisconnectUser(CFtpUserInfo * pUserInfo);
    HRESULT BuildUserList();
    CFtpUserInfo * GetSelectedListItem(int * pnSel = NULL);
    CFtpUserInfo * GetNextSelectedItem(int * pnStartingIndex);
    void FillListBox(CFtpUserInfo * pSelection = NULL);

    void SetControlStates();
    void UpdateTotalCount();

private:
    int m_nSortColumn;
    DWORD m_dwInstance;
    CString m_strServerName;
    CString m_strAdminName;
    CString m_strAdminPassword;
    HANDLE m_hImpToken, m_hLogToken;
    CString m_strTotalConnected;
    CObListPlus m_oblFtpUsers;
    CRMCListBoxResources m_ListBoxRes;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline CFtpUserInfo * CFtpUsersListBox::GetItem(
    IN UINT nIndex
    )
{
    return (CFtpUserInfo *)GetItemDataPtr(nIndex);
}

inline int CFtpUsersListBox::AddItem(
    IN const CFtpUserInfo * pItem
    )
{
    return AddString((LPCTSTR)pItem);
}

inline CFtpUserInfo * CUserSessionsDlg::GetSelectedListItem(
    OUT int * pnSel
    )
{
    return (CFtpUserInfo *)m_list_Users.GetSelectedListItem(pnSel);
}

inline CFtpUserInfo * CUserSessionsDlg::GetNextSelectedItem(
    IN OUT int * pnStartingIndex
    )
{
    return (CFtpUserInfo *)m_list_Users.GetNextSelectedItem(pnStartingIndex);
}



#endif // __USERSESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wfile.h ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wfile.h

   Abstract:
        WWW File Properties Page Definitions

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#ifndef __WFILE_H__
#define __WFILE__H_ 


class CW3FilePage : public CInetPropertyPage
{
    DECLARE_DYNCREATE(CW3FilePage)

//
// Constructor/Destructor
//
public:
    CW3FilePage(CInetPropertySheet * pSheet = NULL);
    ~CW3FilePage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_DIRECTORY,
        RADIO_REDIRECT,
    };

    //{{AFX_DATA(CW3DirectoryPage)
    enum { IDD = IDD_WEB_FILE_PROPERTIES };
    int     m_nPathType;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fAuthor;
    BOOL    m_fLogAccess;
//    BOOL    m_fChild;
    BOOL    m_fExact;
    BOOL    m_fPermanent;
    CString m_strRedirectPath;
    CEdit   m_edit_Path;
    CEdit   m_edit_Redirect;
//    CStatic m_static_Path;
    CStatic m_static_PathPrompt;
    CButton m_radio_Dir;
    CButton m_check_Author;
//    CButton m_check_Child;
//    CButton m_check_DirBrowse;
//    CButton m_check_Index;
    CButton m_check_Write;
    CButton m_check_Read;
    //}}AFX_DATA

    
//    DWORD m_dwAccessPermissions;
    DWORD m_dwBitRangePermissions;
    DWORD m_dwAccessPerms;
    CButton m_radio_Redirect;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3FilePage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3FilePage)
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckRead();
    afx_msg void OnCheckWrite();
    afx_msg void OnCheckAuthor();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioRedirect();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void ShowControl(CWnd * pWnd, BOOL fShow);
    void ShowControl(UINT nID, BOOL fShow);
    void SetStateByType();
    void SetPathType();
    void SetAuthoringState(BOOL fAlterReadAndWrite = TRUE);
    void ChangeTypeTo(int nNewType);

protected:
    //
    // Remember/restore settings.
    //
    void SaveAuthoringState();
    void RestoreAuthoringState();

private:
    BOOL  m_fOriginalRead;
    BOOL  m_fOriginalWrite;
    DWORD m_dwAttributes;
    CString m_strFullMetaPath;
    CString m_strPrompt[2];
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CW3FilePage::ShowControl(UINT nID, BOOL fShow)
{
    ASSERT(nID > 0);
    ShowControl(GetDlgItem(nID), fShow);
}

#endif // __WFILE__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\webaddnew.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        WebAddNew.cpp

   Abstract:
        Implementation for classes used in creation of new Web site and virtual directory

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        12/12/2000       sergeia     Initial creation

--*/
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "iisobj.h"
#include "wizard.h"
#include "w3sht.h"
#include "WebAddNew.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW

#define DEF_PORT        (80)
#define DEF_SSL_PORT   (443)
#define MAX_ALIAS_NAME (240)        // Ref Bug 241148

HRESULT
RebindInterface(OUT IN CMetaInterface * pInterface,
    OUT BOOL * pfContinue, IN  DWORD dwCancelError);


HRESULT
CIISMBNode::AddWebSite(
    const CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type,
    DWORD * inst
    )
{
   CWebWizSettings ws(
      dynamic_cast<CMetaKey *>(QueryInterface()),
      QueryMachineName()
      );
   ws.m_fNewSite = TRUE;
   CIISWizardSheet sheet(
      IDB_WIZ_WEB_LEFT, IDB_WIZ_WEB_HEAD);
   CIISWizardBookEnd pgWelcome(
        IDS_WEB_NEW_SITE_WELCOME, 
        IDS_WEB_NEW_SITE_WIZARD, 
        IDS_WEB_NEW_SITE_BODY
        );
   CWebWizDescription  pgDescr(&ws);
   CWebWizBindings     pgBindings(&ws);
   CWebWizPath         pgHome(&ws, FALSE);
   CWebWizUserName     pgUserName(&ws, FALSE);
   CWebWizPermissions  pgPerms(&ws, FALSE);
   CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_WEB_NEW_SITE_SUCCESS,
        IDS_WEB_NEW_SITE_FAILURE,
        IDS_WEB_NEW_SITE_WIZARD
        );
   sheet.AddPage(&pgWelcome);
   sheet.AddPage(&pgDescr);
   sheet.AddPage(&pgBindings);
   sheet.AddPage(&pgHome);
   sheet.AddPage(&pgUserName);
   sheet.AddPage(&pgPerms);
   sheet.AddPage(&pgCompletion);

   if (sheet.DoModal() == IDCANCEL)
   {
      return CError::HResult(ERROR_CANCELLED);
   }
   if (inst != NULL && SUCCEEDED(ws.m_hrResult))
   {
      *inst = ws.m_dwInstance;
   }

   return ws.m_hrResult;
}

HRESULT
CIISMBNode::AddWebVDir(
    const CSnapInObjectRootBase * pObj,
    DATA_OBJECT_TYPES type,
    CString& alias
    )
{
   CWebWizSettings ws(
      dynamic_cast<CMetaKey *>(QueryInterface()),
      QueryMachineName()
      );
   CComBSTR path;
   BuildMetaPath(path);
   ws.m_strParent = path;
   ws.m_fNewSite = FALSE;
   CIISWizardSheet sheet(
      IDB_WIZ_WEB_LEFT, IDB_WIZ_WEB_HEAD);
   CIISWizardBookEnd pgWelcome(
        IDS_WEB_NEW_VDIR_WELCOME, 
        IDS_WEB_NEW_VDIR_WIZARD, 
        IDS_WEB_NEW_VDIR_BODY
        );
   CWebWizAlias        pgAlias(&ws);
   CWebWizPath         pgHome(&ws, TRUE);
   CWebWizUserName     pgUserName(&ws, TRUE);
   CWebWizPermissions  pgPerms(&ws, TRUE);
   CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_WEB_NEW_VDIR_SUCCESS,
        IDS_WEB_NEW_VDIR_FAILURE,
        IDS_WEB_NEW_VDIR_WIZARD
        );
   sheet.AddPage(&pgWelcome);
   sheet.AddPage(&pgAlias);
   sheet.AddPage(&pgHome);
   sheet.AddPage(&pgUserName);
   sheet.AddPage(&pgPerms);
   sheet.AddPage(&pgCompletion);

   if (sheet.DoModal() == IDCANCEL)
   {
      return CError::HResult(ERROR_CANCELLED);
   }
   if (SUCCEEDED(ws.m_hrResult))
   {
       alias = ws.m_strAlias;
   }

   return ws.m_hrResult;
}

CWebWizSettings::CWebWizSettings(
        IN CMetaKey * pMetaKey,
        IN LPCTSTR lpszServerName,     
        IN DWORD   dwInstance,
        IN LPCTSTR lpszParent
        )
/*++

Routine Description:

    Web Wizard Constructor

Arguments:

    HANDLE  hServer      : Server handle
    LPCTSTR lpszService  : Service name
    DWORD   dwInstance   : Instance number
    LPCTSTR lpszParent   : Parent path

Return Value:

    N/A

--*/
    : m_hrResult(S_OK),
      m_pKey(pMetaKey),
      m_fUNC(FALSE),
      m_fRead(FALSE),
      m_fWrite(FALSE),
      m_fAllowAnonymous(TRUE),
      m_fDirBrowsing(FALSE),
      m_fScript(FALSE),
      m_fExecute(FALSE),
      m_dwInstance(dwInstance)
{
    ASSERT(lpszServerName != NULL);

    m_strServerName = lpszServerName;
    m_fLocal = IsServerLocal(m_strServerName);
    m_strService = SZ_MBN_WEB;

    if (lpszParent)
    {
        m_strParent = lpszParent;
    }
}




//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizDescription, CIISWizardPage)



CWebWizDescription::CWebWizDescription(
    IN OUT CWebWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizDescription::IDD,
        IDS_WEB_NEW_SITE_WIZARD,
        HEADER_PAGE
        ),
    m_pSettings(pwsSettings)
{

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CWebWizDescription)
    m_strDescription = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}



CWebWizDescription::~CWebWizDescription()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CWebWizDescription::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizDescription)
    DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_edit_Description);
    //}}AFX_DATA_MAP
}



void
CWebWizDescription::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Description.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



LRESULT
CWebWizDescription::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(
        m_edit_Description, 
        m_pSettings->m_strDescription, 
        1, 
        MAX_PATH
        ))
    {
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizDescription, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizDescription)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnChangeEditDescription)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CWebWizDescription::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void 
CWebWizDescription::OnChangeEditDescription() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizBindings, CIISWizardPage)



CWebWizBindings::CWebWizBindings(
    IN OUT CWebWizSettings * pwsSettings,
    IN DWORD   dwInstance
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizBindings::IDD, IDS_WEB_NEW_SITE_WIZARD, HEADER_PAGE
        ),
      m_pSettings(pwsSettings),
      m_iaIpAddress(),
      m_oblIpAddresses(),
      m_dwInstance(dwInstance)
{
    //{{AFX_DATA_INIT(CWebWizBindings)
    m_nIpAddressSel = -1;
    m_nTCPPort = DEF_PORT;
    m_nSSLPort = DEF_SSL_PORT;
    m_strDomainName = _T("");
    //}}AFX_DATA_INIT
    BeginWaitCursor();
    m_fCertInstalled = ::IsCertInstalledOnServer(
        m_pSettings->m_pKey->QueryAuthInfo(), 
        CMetabasePath(
            m_pSettings->m_strService,
            m_pSettings->m_dwInstance,
            m_pSettings->m_strParent,
            m_pSettings->m_strAlias
            )
        );
    EndWaitCursor();
}



CWebWizBindings::~CWebWizBindings()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CWebWizBindings::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizBindings)
    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
    DDV_MinMaxUInt(pDX, m_nTCPPort, 1, 65535);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
    DDX_Text(pDX, IDC_EDIT_DOMAIN_NAME, m_strDomainName);
    DDV_MaxChars(pDX, m_strDomainName, MAX_PATH);
    //}}AFX_DATA_MAP

    if (m_fCertInstalled)
    {
        DDX_Text(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort);
        DDV_MinMaxUInt(pDX, m_nSSLPort, 1, 65535);
    }

    //
    // Check for dup port right after DDXV of SSL port -- because focus will
    // be set appropriately.  Don't change!
    //
    if (pDX->m_bSaveAndValidate && m_nTCPPort == m_nSSLPort)
    {
        ::AfxMessageBox(IDS_TCP_SSL_PART);
        pDX->Fail();    
    }

    DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

    if (pDX->m_bSaveAndValidate)
    {
        if (!FetchIpAddressFromCombo(
            m_combo_IpAddresses,
            m_oblIpAddresses,
            m_iaIpAddress
            ))
        {
            pDX->Fail();
        }

        //
        // Build with empty host header
        //
        CInstanceProps::BuildBinding(
            m_pSettings->m_strBinding, 
            m_iaIpAddress, 
            m_nTCPPort, 
            m_strDomainName
            );

        if (m_fCertInstalled)
        {
            CInstanceProps::BuildSecureBinding(
                m_pSettings->m_strSecureBinding, 
                m_iaIpAddress, 
                m_nSSLPort
                );
        }
        else
        {
            m_pSettings->m_strSecureBinding.Empty();
        }
    }
}




void
CWebWizBindings::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
    
    BeginWaitCursor();
    m_fCertInstalled = ::IsCertInstalledOnServer(
        m_pSettings->m_pKey->QueryAuthInfo(), 
        CMetabasePath(
            m_pSettings->m_strService,
            m_pSettings->m_dwInstance,
            m_pSettings->m_strParent,
            m_pSettings->m_strAlias
            )
        );
    EndWaitCursor();

    GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(m_fCertInstalled);
    GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(m_fCertInstalled);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizBindings, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizBindings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizBindings::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_pSettings->m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();
    
    return TRUE;
}



BOOL 
CWebWizBindings::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizAlias, CIISWizardPage)



CWebWizAlias::CWebWizAlias(
    IN OUT CWebWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizAlias::IDD,
        IDS_WEB_NEW_VDIR_WIZARD,
        HEADER_PAGE
        ),
      m_pSettings(pwsSettings)
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CWebWizAlias)
    //}}AFX_DATA_INIT

#endif // 0
}



CWebWizAlias::~CWebWizAlias()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CWebWizAlias::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizAlias)
    DDX_Control(pDX, IDC_EDIT_ALIAS, m_edit_Alias);
    //}}AFX_DATA_MAP
}



LRESULT
CWebWizAlias::OnWizardNext() 
/*++

Routine Description:

    prevent the / and \ characters from being in the alias name

Arguments:

    None

Return Value:

    None

--*/
{
    if (!ValidateString(
        m_edit_Alias, 
        m_pSettings->m_strAlias, 
        1, 
        MAX_ALIAS_NAME
        ))
    {
        return -1;
    }

    //
    // Find the illegal characters. If they exist tell 
    // the user and don't go on.
    //
    if (m_pSettings->m_strAlias.FindOneOf(_T("/\\?*")) >= 0)
    {
        AfxMessageBox(IDS_ILLEGAL_ALIAS_CHARS);
        m_edit_Alias.SetFocus();
        m_edit_Alias.SetSel(0, -1);

        //
        // prevent the wizard page from changing
        //
        return -1;
    }

    //
    // Allow the wizard to continue
    //
    return CIISWizardPage::OnWizardNext();
}



void
CWebWizAlias::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Alias.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizAlias, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizAlias)
    ON_EN_CHANGE(IDC_EDIT_ALIAS, OnChangeEditAlias)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizAlias::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void 
CWebWizAlias::OnChangeEditAlias() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



//
// New Virtual Directory Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizPath, CIISWizardPage)



CWebWizPath::CWebWizPath(
    IN OUT CWebWizSettings * pwsSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE for a VDIR, FALSE for an instance

Return Value:

    None

--*/
    : CIISWizardPage(
        (bVDir ? IDD_WEB_NEW_DIR_PATH : IDD_WEB_NEW_INST_HOME),
        (bVDir ? IDS_WEB_NEW_VDIR_WIZARD : IDS_WEB_NEW_SITE_WIZARD),
        HEADER_PAGE
        ),
      m_pSettings(pwsSettings)
{
#if 0 // Keep ClassWizard happy

    //{{AFX_DATA_INIT(CWebWizPath)
    //}}AFX_DATA_INIT

#endif // 0
}



CWebWizPath::~CWebWizPath()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CWebWizPath::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizPath)
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Check(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_pSettings->m_fAllowAnonymous);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_PATH, m_pSettings->m_strPath);
    DDV_MaxChars(pDX, m_pSettings->m_strPath, MAX_PATH);
}



void 
CWebWizPath::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Path.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizPath, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizPath)
    ON_EN_CHANGE(IDC_EDIT_PATH, OnChangeEditPath)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizPath::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



LRESULT 
CWebWizPath::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(m_edit_Path, m_pSettings->m_strPath, 1, MAX_PATH))
    {
        return -1;
    }
    if (!PathIsValid(m_pSettings->m_strPath))
    {
        m_edit_Path.SetSel(0,-1);
        m_edit_Path.SetFocus();
        ::AfxMessageBox(IDS_ERR_BAD_PATH);
    }

    m_pSettings->m_fUNC = IsUNCName(m_pSettings->m_strPath);

    if (!m_pSettings->m_fUNC)
    {
        if (!IsFullyQualifiedPath(m_pSettings->m_strPath)
         && !IsDevicePath(m_pSettings->m_strPath)
           )
        {
            m_edit_Path.SetSel(0,-1);
            m_edit_Path.SetFocus();
            ::AfxMessageBox(IDS_ERR_BAD_PATH);

            return -1;
        }

        if (m_pSettings->m_fLocal)
        {
            DWORD dwAttr = GetFileAttributes(m_pSettings->m_strPath);

            if (dwAttr == 0xffffffff || 
               (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                m_edit_Path.SetSel(0,-1);
                m_edit_Path.SetFocus();
                ::AfxMessageBox(IDS_ERR_PATH_NOT_FOUND);

                return -1;
            }
        }
    }

    return CIISWizardPage::OnWizardNext();
}

void 
CWebWizPath::OnChangeEditPath() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CWebWizPath * pThis = (CWebWizPath *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CWebWizPath::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}


void 
CWebWizPath::OnButtonBrowse() 
/*++

Routine Description:

    Handle 'browsing' for directory path -- local system only

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(m_pSettings->m_fLocal);

   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Path.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         m_strBrowseTitle.LoadString(m_pSettings->m_fNewSite ? 
            IDS_WEB_NEW_SITE_WIZARD : IDS_WEB_NEW_VDIR_WIZARD);
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strBrowseTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_edit_Path.SetWindowText(str);
       SetControlStates();
   }
}



BOOL 
CWebWizPath::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    m_button_Browse.EnableWindow(m_pSettings->m_fLocal);
    
    return TRUE;  
}



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizUserName, CIISWizardPage)



CWebWizUserName::CWebWizUserName(
    IN OUT CWebWizSettings * pwsSettings,    
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is for a vdir,
                                  FALSE if this is an instance

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizUserName::IDD,
        (bVDir ? IDS_WEB_NEW_VDIR_WIZARD : IDS_WEB_NEW_SITE_WIZARD),
        HEADER_PAGE,
        (bVDir ? USE_DEFAULT_CAPTION : IDS_WEB_NEW_SITE_SECURITY_TITLE),
        (bVDir ? USE_DEFAULT_CAPTION : IDS_WEB_NEW_SITE_SECURITY_SUBTITLE)
        ),
      m_pSettings(pwsSettings)
{

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CWebWizUserName)
    //}}AFX_DATA_INIT

#endif // 0
}



CWebWizUserName::~CWebWizUserName()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CWebWizUserName::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizUserName)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_pSettings->m_strUserName);
    DDV_MaxChars(pDX, m_pSettings->m_strUserName, UNLEN);

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_pSettings->m_strUserName.TrimLeft();
    while (*m_pSettings->m_strUserName == '\\')
    {
        m_pSettings->m_strUserName = m_pSettings->m_strUserName.Mid(2);
    }

    DDX_Password(pDX, IDC_EDIT_PASSWORD, m_pSettings->m_strPassword, g_lpszDummyPassword);
    DDV_MaxChars(pDX, m_pSettings->m_strPassword, PWLEN);
}



void 
CWebWizUserName::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_UserName.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizUserName, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizUserName)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizUserName::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    if (!m_pSettings->m_fUNC)
    {
        return 0;
    }

    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



BOOL
CWebWizUserName::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    return TRUE;  
}



LRESULT
CWebWizUserName::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(
        m_edit_UserName, 
        m_pSettings->m_strUserName, 
        1, 
        UNLEN
        ))
    {
        return -1;
    }
    
    return CIISWizardPage::OnWizardNext();
}



void
CWebWizUserName::OnButtonBrowseUsers() 
/*++

Routine Description:

    'browse' for users handler

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(m_pSettings->m_strServerName, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}



void
CWebWizUserName::OnChangeEditUsername() 
/*++

Routine Description:

    'edit change' in user name notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_edit_Password.SetWindowText(_T(""));
    SetControlStates();
}



void 
CWebWizUserName::OnButtonCheckPassword() 
/*++

Routine Description:

    'Check Password' has been pressed.  Try to validate
    the password that has been entered

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(CComAuthInfo::VerifyUserPassword(
        m_pSettings->m_strUserName, 
        m_pSettings->m_strPassword
        ));

    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}




//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CWebWizPermissions, CIISWizardPage)



CWebWizPermissions::CWebWizPermissions(
    IN OUT CWebWizSettings * pwsSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is a vdir page, 
                                  FALSE for instance

Return Value:

    None

--*/
    : CIISWizardPage(
        CWebWizPermissions::IDD,
        (bVDir ? IDS_WEB_NEW_VDIR_WIZARD : IDS_WEB_NEW_SITE_WIZARD),
        HEADER_PAGE,
        (bVDir ? USE_DEFAULT_CAPTION : IDS_WEB_NEW_SITE_PERMS_TITLE),
        (bVDir ? USE_DEFAULT_CAPTION : IDS_WEB_NEW_SITE_PERMS_SUBTITLE)
        ),
      m_bVDir(bVDir),
      m_pSettings(pwsSettings)
{
    //{{AFX_DATA_INIT(CWebWizPermissions)
    //}}AFX_DATA_INIT

    m_pSettings->m_fDirBrowsing = FALSE;
    m_pSettings->m_fRead = TRUE;
    m_pSettings->m_fScript = TRUE;
    m_pSettings->m_fWrite = FALSE;
    m_pSettings->m_fExecute = FALSE;
}



CWebWizPermissions::~CWebWizPermissions()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



void 
CWebWizPermissions::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CWebWizPermissions)
    //}}AFX_DATA_MAP

    DDX_Check(pDX, IDC_CHECK_DIRBROWS, m_pSettings->m_fDirBrowsing);
    DDX_Check(pDX, IDC_CHECK_READ, m_pSettings->m_fRead);
    DDX_Check(pDX, IDC_CHECK_SCRIPT, m_pSettings->m_fScript);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_pSettings->m_fWrite);
    DDX_Check(pDX, IDC_CHECK_EXECUTE, m_pSettings->m_fExecute);
}



void
CWebWizPermissions::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CWebWizPermissions, CIISWizardPage)
    //{{AFX_MSG_MAP(CWebWizPermissions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CWebWizPermissions::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();

    return CIISWizardPage::OnSetActive();
}



LRESULT
CWebWizPermissions::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Complete the wizard

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!UpdateData(TRUE))
    {
        return -1;
    }

    ASSERT(m_pSettings != NULL);

    CWaitCursor wait;

    //
    // Build permissions DWORD
    //
    DWORD dwPermissions = 0L;
    DWORD dwAuthFlags = MD_AUTH_NT;
    DWORD dwDirBrowsing =
        MD_DIRBROW_SHOW_DATE |
        MD_DIRBROW_SHOW_TIME |
        MD_DIRBROW_SHOW_SIZE |
        MD_DIRBROW_SHOW_EXTENSION |
        MD_DIRBROW_LONG_DATE |
        MD_DIRBROW_LOADDEFAULT;

	if (m_pSettings->m_fWrite && m_pSettings->m_fExecute)
	{
		if (IDNO == ::AfxMessageBox(IDS_EXECUTE_AND_WRITE_WARNING, MB_YESNO))
			return -1;
	}
    SET_FLAG_IF(m_pSettings->m_fRead, dwPermissions, MD_ACCESS_READ);
    SET_FLAG_IF(m_pSettings->m_fWrite, dwPermissions, MD_ACCESS_WRITE);
    SET_FLAG_IF(m_pSettings->m_fScript || m_pSettings->m_fExecute,
        dwPermissions, MD_ACCESS_SCRIPT);
    SET_FLAG_IF(m_pSettings->m_fExecute, dwPermissions, MD_ACCESS_EXECUTE);
    SET_FLAG_IF(m_pSettings->m_fDirBrowsing, dwDirBrowsing, MD_DIRBROW_ENABLED);
    SET_FLAG_IF(m_pSettings->m_fAllowAnonymous, dwAuthFlags, MD_AUTH_ANONYMOUS);

    if (m_bVDir)
    {
        //
        // First see if by any chance this name already exists
        //
        CError err;
        BOOL fRepeat;
        CMetabasePath target(FALSE, 
            m_pSettings->m_strParent, m_pSettings->m_strAlias);
        CChildNodeProps node(
            m_pSettings->m_pKey->QueryAuthInfo(),
            target);

        do
        {
            fRepeat = FALSE;

            err = node.LoadData();
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);

        if (err.Succeeded())
        {
            BOOL fNotUnique = TRUE;
            //
            // If the item existed without a VrPath, we'll just blow it
            // away, as a vdir takes presedence over a directory/file.
            //
            if (node.GetPath().IsEmpty())
            {
                err = CChildNodeProps::Delete(
                    m_pSettings->m_pKey,
                    m_pSettings->m_strParent,
                    m_pSettings->m_strAlias
                    );
                fNotUnique = !err.Succeeded();
            }
            //
            // This one already exists and exists as a virtual
            // directory, so away with it.
            //
            if (fNotUnique)
            {
                ::AfxMessageBox(IDS_ERR_ALIAS_NOT_UNIQUE);
                return IDD_WEB_NEW_DIR_ALIAS;
            }
        }

        //
        // Create new vdir
        //
        do
        {
            fRepeat = FALSE;
            err = CChildNodeProps::Add(
                m_pSettings->m_pKey,
                m_pSettings->m_strParent,
                m_pSettings->m_strAlias,      // Desired alias name
                m_pSettings->m_strAlias,      // Name returned here (may differ)
                &dwPermissions,                 // Permissions
                &dwDirBrowsing,                 // dir browsing
                m_pSettings->m_strPath,       // Physical path of this directory
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strUserName : NULL),
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strPassword : NULL),
                TRUE                            // Name must be unique
                );
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);

        m_pSettings->m_hrResult = err;

        //
        // Create an (in-proc) application on the new directory if
        // script or execute was requested.
        //
        if (SUCCEEDED(m_pSettings->m_hrResult))
        {
            if (m_pSettings->m_fExecute || m_pSettings->m_fScript)
            {
                CMetabasePath app_path(FALSE, 
                    m_pSettings->m_strParent, m_pSettings->m_strAlias);
                CIISApplication app(
                    m_pSettings->m_pKey->QueryAuthInfo(), app_path);
                m_pSettings->m_hrResult = app.QueryResult();

                //
                // This would make no sense...
                //
                ASSERT(!app.IsEnabledApplication());
        
                if (SUCCEEDED(m_pSettings->m_hrResult))
                {
                    //
                    // Attempt to create a pooled-proc by default;  failing
                    // that if it's not supported, create it in proc
                    //
                    DWORD dwAppProtState = app.SupportsPooledProc()
                        ? CWamInterface::APP_POOLEDPROC
                        : CWamInterface::APP_INPROC;

                    m_pSettings->m_hrResult = app.Create(
                        m_pSettings->m_strAlias, 
                        dwAppProtState
                        );
                }
            }
        }
    }
    else
    {
        //
        // Create new instance
        //
        CError err;
        BOOL fRepeat;

        do
        {
            fRepeat = FALSE;

            err = CInstanceProps::Add(
                m_pSettings->m_pKey,
                m_pSettings->m_strService,    // Service name
                m_pSettings->m_strPath,       // Physical path of this directory
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strUserName : NULL),
                (m_pSettings->m_fUNC ? (LPCTSTR)m_pSettings->m_strPassword : NULL),
                m_pSettings->m_strDescription,
                m_pSettings->m_strBinding,
                m_pSettings->m_strSecureBinding,
                &dwPermissions,
                &dwDirBrowsing,                 // dir browsing
                &dwAuthFlags,                   // Auth flags
                &m_pSettings->m_dwInstance
                );
            if (err.Win32Error() == RPC_S_SERVER_UNAVAILABLE)
            {
                err = RebindInterface(
                    m_pSettings->m_pKey,
                    &fRepeat,
                    ERROR_CANCELLED
                    );
            }
        } while (fRepeat);

        m_pSettings->m_hrResult = err;

        if (SUCCEEDED(m_pSettings->m_hrResult))
        {
            //
            // Create an (in-proc) application on the new instance's home root
            //
            CMetabasePath app_path(SZ_MBN_WEB, 
                m_pSettings->m_dwInstance,
                SZ_MBN_ROOT);
            CIISApplication app(
                m_pSettings->m_pKey->QueryAuthInfo(), 
                app_path
                );

            m_pSettings->m_hrResult = app.QueryResult();

            //
            // This would make no sense...
            //
            ASSERT(!app.IsEnabledApplication());
        
            if (SUCCEEDED(m_pSettings->m_hrResult))
            {
                //
                // Create in-proc
                //
                CString strAppName;
                VERIFY(strAppName.LoadString(IDS_DEF_APP));

                //
                // Attempt to create a pooled-proc by default;  failing
                // that if it's not supported, create it in proc
                //
                DWORD dwAppProtState = app.SupportsPooledProc()
                    ? CWamInterface::APP_POOLEDPROC
                    : CWamInterface::APP_INPROC;

                m_pSettings->m_hrResult = app.Create(
                    strAppName, 
                    dwAppProtState
                    );
            }
        }
    }
    
    return CIISWizardPage::OnWizardNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wiztempl.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :

        WizTempl.h

   Abstract:

        Template for wizard pages

   Author:

        Sergei Antonov (sergeia)

   Project:

        Internet Services Manager

   Revision History:

        11/9/2000       sergeia     Initial creation

--*/
#ifndef _WIZTEMPL_H
#define _WIZTEMPL_H

#ifndef _PRSHT_H_
	#error WizTempl.h requires prsht.h to be included first
#endif

#pragma comment(lib, "comctl32.lib")

template <class T>
class CWizardPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE	m_psp;
	HPROPSHEETPAGE	m_hpsp;
	CComBSTR		m_bstrTitle;
	CComBSTR		m_bstrSubTitle;


	operator PROPSHEETPAGE*() { return &m_psp; }

	CWizardPageImpl(
		IN bool			i_bShowHeader
		)
		:m_hpsp(NULL)
	{
		
		ZeroMemory(&m_psp, sizeof m_psp);

		m_psp.dwSize = sizeof m_psp;
		m_psp.hInstance = _Module.GetResourceInstance();

		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		
		m_psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
		m_psp.pfnCallback = T::PropPageCallback;
		
		if ( false == i_bShowHeader)
		{
			m_psp.dwFlags |= PSP_HIDEHEADER;
		}

		m_psp.lParam = (LPARAM)this;
	}


	void SetHeaderTitle(
		IN LPCTSTR		i_lpszHeaderTitle
		)
	{
		m_psp.dwFlags |= PSP_USEHEADERTITLE;	// Header title. Wizard 97
		m_bstrTitle = i_lpszHeaderTitle;
		m_psp.pszHeaderTitle = m_bstrTitle;
	}


	void SetHeaderSubTitle(
		IN LPCTSTR		i_lpszHeaderSubTitle
		)
	{
		m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;	// Header sub title. Wizard 97
		m_bstrSubTitle = i_lpszHeaderSubTitle;
		m_psp.pszHeaderSubTitle = m_bstrSubTitle;
	}

	static UINT CALLBACK PropPageCallback(
		HWND	hWnd, 
		UINT	uMsg, 
		LPPROPSHEETPAGE ppsp
		)
	{
		if(uMsg == PSPCB_CREATE)
		{
			_ASSERTE(hWnd == NULL);
			CDialogImplBase* pPage = (CDialogImplBase*)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		else if(uMsg == PSPCB_RELEASE)
		{
			CWizardPageImpl* pPage = (CWizardPageImpl*)ppsp->lParam;
			pPage->Delete();
		}

		return 1;
	}

	virtual HPROPSHEETPAGE Create()
	{
		return (m_hpsp = ::CreatePropertySheetPage(&m_psp));
	}

							// Implement this in derived class to do clean up when property
							// Page is closed.
	virtual void Delete()
	{
		return;
	}

	virtual BOOL EndDialog(int)
	{
		// Calling ::EndDialog will close the whole sheet
		_ASSERTE(FALSE);
		return FALSE;
	}


	BEGIN_MSG_MAP(CWizardPageImpl<T>)
		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
	END_MSG_MAP()


	LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		_ASSERTE(::IsWindow(m_hWnd));

		NMHDR*		pNMHDR = (NMHDR*)lParam;
		_ASSERT(NULL != pNMHDR);
		if (NULL == pNMHDR)
		{
			bHandled = FALSE;
			return 1;
		}


		// Ignore messages not from the page/sheet itself
		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
		{
			bHandled = FALSE;
			return 1;
		}

		T*			pT = (T*)this;
		LRESULT		lResult = 0;
		
		
		switch(pNMHDR->code)	// Used to call actual methods
		{
		case PSN_SETACTIVE:
			lResult = pT->OnSetActive() ? 0 : -1;
			break;

		case PSN_KILLACTIVE:
			lResult = !pT->OnKillActive();
			break;

		case PSN_RESET:
			pT->OnReset();
			break;

		case PSN_QUERYCANCEL:
			lResult = !pT->OnQueryCancel();
			break;

		case PSN_WIZNEXT:
			lResult = !pT->OnWizardNext();
			break;

		case PSN_WIZBACK:
			lResult = !pT->OnWizardBack();
			break;

		case PSN_WIZFINISH:
			lResult = !pT->OnWizardFinish();
			break;

		case PSN_HELP:
			lResult = pT->OnHelp();
			break;

		case PSN_APPLY:
			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
			break;

		default:
			bHandled = FALSE;	// not handled
		}

		return lResult;
	}

	BOOL OnSetActive()
	{
		return TRUE;
	}

	BOOL OnKillActive()
	{
		return TRUE;
	}

	void OnReset()
	{
	}

	BOOL OnQueryCancel()
	{
		return TRUE;    // ok to cancel
	}
	
	BOOL OnWizardBack()
	{
		return TRUE;
	}
	
	BOOL OnWizardNext()
	{
		return TRUE;
	}
	
	BOOL OnWizardFinish()
	{
		return TRUE;
	}
	
	BOOL OnHelp()
	{
		return TRUE;
	}

	BOOL OnApply()
	{
		return TRUE;
	}

};


#endif //_WIZTEMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wfile.cpp ===
/*++

   Copyright    (c)    1994-2001    Microsoft Corporation

   Module  Name :
        wfile.cpp

   Abstract:
        WWW File Properties Page

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        27/02/2001      sergeia     Created from wvdir.cpp
--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "w3sht.h"
#include "wfile.h"
#include "dirbrows.h"
#include "iisobj.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPCTSTR CvtPathToDosStyle(CString & strPath);

IMPLEMENT_DYNCREATE(CW3FilePage, CInetPropertyPage)

CW3FilePage::CW3FilePage(CInetPropertySheet * pSheet) 
    : CInetPropertyPage(CW3FilePage::IDD, pSheet, IDS_TAB_FILE),
      //
      // Assign the range of bits in m_dwAccessPermissions that
      // we manage.  This is important, because another page
      // manages other bits, and we don't want to screw up
      // the master value bits when our changes collide (it
      // will mark the original bits as dirty, because we're not
      // notified when the change is made...
      //
      m_dwBitRangePermissions(MD_ACCESS_EXECUTE | 
            MD_ACCESS_SCRIPT | 
            MD_ACCESS_WRITE  | 
            MD_ACCESS_SOURCE |
            MD_ACCESS_READ)
{
    VERIFY(m_strPrompt[RADIO_DIRECTORY].LoadString(IDS_PROMPT_DIR));
    VERIFY(m_strPrompt[RADIO_REDIRECT].LoadString(IDS_PROMPT_REDIRECT));
}

CW3FilePage::~CW3FilePage()
{
}

void 
CW3FilePage::DoDataExchange(CDataExchange * pDX)
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3FilePage)
//    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
    DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
    DDX_Control(pDX, IDC_RADIO_REDIRECT, m_radio_Redirect);
    DDX_Check(pDX, IDC_CHECK_AUTHOR, m_fAuthor);
    DDX_Control(pDX, IDC_CHECK_AUTHOR, m_check_Author);
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);    
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);

    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Control(pDX, IDC_EDIT_REDIRECT, m_edit_Redirect);

    DDX_Control(pDX, IDC_STATIC_PATH_PROMPT, m_static_PathPrompt);
//    DDX_Control(pDX, IDC_CHECK_CHILD, m_check_Child);
    //}}AFX_DATA_MAP


//    DDX_Check(pDX, IDC_CHECK_CHILD, m_fChild);
    DDX_Check(pDX, IDC_CHECK_EXACT, m_fExact);
    DDX_Check(pDX, IDC_CHECK_PERMANENT, m_fPermanent);

    if (pDX->m_bSaveAndValidate)
    {
        if (m_nPathType == RADIO_REDIRECT)
        {
            DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
            m_strRedirectPath.TrimLeft();
            DDV_MinMaxChars(pDX, m_strRedirectPath, 0, 2 * MAX_PATH);

            if (!IsRelURLPath(m_strRedirectPath) 
             && !IsWildcardedRedirectPath(m_strRedirectPath)
             && !IsURLName(m_strRedirectPath))
            {
                ::AfxMessageBox(IDS_BAD_URL_PATH);
                pDX->Fail();
            }
        }
        else // Local directory
        {
            m_strRedirectPath.Empty();
        }
    }
    else
    {
        DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
    }
}

//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3FilePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3FilePage)
    ON_BN_CLICKED(IDC_CHECK_READ, OnCheckRead)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnCheckWrite)
    ON_BN_CLICKED(IDC_CHECK_AUTHOR, OnCheckAuthor)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_REDIRECT, OnRadioRedirect)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_REDIRECT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
//    ON_BN_CLICKED(IDC_CHECK_CHILD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_EXACT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_PERMANENT, OnItemChanged)

END_MESSAGE_MAP()



void
CW3FilePage::ChangeTypeTo(int nNewType)
{
    int nOldType = m_nPathType;
    m_nPathType = nNewType;

    if (nOldType == m_nPathType)
    {
        return;
    }

    OnItemChanged();
    SetStateByType();

    int nID = -1;
    CEdit * pPath = NULL;
    LPCTSTR lpKeepPath = NULL;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        break;

    case RADIO_REDIRECT:
        if (!m_strRedirectPath.IsEmpty())
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath =  m_strRedirectPath;
        }

        nID = IDS_REDIRECT_MASK;
        pPath = &m_edit_Redirect;
        break;

    default:
        ASSERT(FALSE);
        return;
    }

    //
    // Load mask resource, and display
    // this in the directory
    //
    if (pPath != NULL)
    {
        if (lpKeepPath != NULL)
        {
            pPath->SetWindowText(lpKeepPath);
        }
        else
        {
            CString str;
            VERIFY(str.LoadString(nID));
            pPath->SetWindowText(str);
        }
        pPath->SetSel(0,-1);
        pPath->SetFocus();
    }
}



void 
CW3FilePage::ShowControl(CWnd * pWnd, BOOL fShow)
{
    ASSERT(pWnd != NULL);
	pWnd->EnableWindow(fShow);
	pWnd->ShowWindow(fShow ? SW_SHOW : SW_HIDE);
}

void
CW3FilePage::SetStateByType()
/*++

Routine Description:

    Set the state of the dialog by the path type currently selected

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL fShowDirFlags;
    BOOL fShowRedirectFlags;
    BOOL fShowDAV;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        ShowControl(&m_edit_Path, fShowDirFlags = TRUE);
		m_edit_Path.EnableWindow(FALSE);
        ShowControl(&m_edit_Redirect, fShowRedirectFlags = FALSE);
        fShowDAV = TRUE;
        break;

    case RADIO_REDIRECT:
        ShowControl(&m_edit_Path, fShowDirFlags = FALSE);
        ShowControl(&m_edit_Redirect, fShowRedirectFlags = TRUE);
        fShowDAV = FALSE;
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
        return;
    }

    ShowControl(GetDlgItem(IDC_CHECK_READ), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_WRITE), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_LOG_ACCESS), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_AUTHOR), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_SMALL), fShowDirFlags);

    ShowControl(IDC_CHECK_EXACT, fShowRedirectFlags);
    ShowControl(IDC_CHECK_CHILD, fShowRedirectFlags);
	if (fShowRedirectFlags)
	{
		GetDlgItem(IDC_CHECK_CHILD)->EnableWindow(FALSE);
	}
    ShowControl(IDC_CHECK_PERMANENT, fShowRedirectFlags);
    ShowControl(IDC_STATIC_REDIRECT_PROMPT, fShowRedirectFlags);
    ShowControl(IDC_STATIC_REDIRFLAGS, fShowRedirectFlags);
    ShowControl(&m_check_Author, fShowDAV);

    //
    // Enable/Disable must come after the showcontrols
    //
    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
}



void
CW3FilePage::SaveAuthoringState()
{
    if (m_check_Write.m_hWnd)
    {
        //
        // Controls initialized -- store live data
        //
        m_fOriginalWrite = m_check_Write.GetCheck() > 0;
        m_fOriginalRead = m_check_Read.GetCheck() > 0;
    }
    else
    {
        //
        // Controls not yet initialized, store original data
        //
        m_fOriginalWrite = m_fWrite;
        m_fOriginalRead = m_fRead;
    }
}

void
CW3FilePage::RestoreAuthoringState()
{
    m_fWrite = m_fOriginalWrite;
    m_fRead = m_fOriginalRead;
}

void 
CW3FilePage::SetAuthoringState(BOOL fAlterReadAndWrite)
{
    if (fAlterReadAndWrite)
    {
        if (m_fAuthor)
        {
            //
            // Remember previous setting to undo
            // this thing.
            //
            SaveAuthoringState();
            m_fRead = m_fWrite = TRUE;
        }
        else
        {
            //
            // Restore previous defaults
            //
            RestoreAuthoringState();
        }

        m_check_Read.SetCheck(m_fRead);
        m_check_Write.SetCheck(m_fWrite);
    }

    m_check_Author.EnableWindow((m_fRead || m_fWrite) 
		&& HasAdminAccess() 
		&& HasDAV()
        );

//    m_check_Read.EnableWindow(!m_fAuthor && HasAdminAccess());
//    m_check_Write.EnableWindow(!m_fAuthor && HasAdminAccess());
}

void 
CW3FilePage::SetPathType()
{
    if (!m_strRedirectPath.IsEmpty())
    {
        m_nPathType = RADIO_REDIRECT;
        m_radio_Dir.SetCheck(0);
        m_radio_Redirect.SetCheck(1);
    }
    else
    {
        m_nPathType = RADIO_DIRECTORY;
        m_radio_Redirect.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }

    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
}


//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3FilePage::OnItemChanged()
{
    SetModified(TRUE);
}

BOOL 
CW3FilePage::OnInitDialog() 
{
    CInetPropertyPage::OnInitDialog();

    SetPathType();
    SetStateByType();
    SetAuthoringState(FALSE);

	// It is enough to set file alias once -- we cannot change it here
    CString buf1, buf2, strAlias;
	CMetabasePath::GetRootPath(m_strFullMetaPath, buf1, &buf2);

	strAlias += _T("\\");
	strAlias += buf2;
    CvtPathToDosStyle(strAlias);
	m_edit_Path.SetWindowText(strAlias);

    return TRUE;  
}



/* virtual */
HRESULT
CW3FilePage::FetchLoadedValues()
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        //
        // Use m_ notation because the message crackers require it
        //
        BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strFullMetaPath);
        FETCH_DIR_DATA_FROM_SHEET(m_strRedirectPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);
        FETCH_DIR_DATA_FROM_SHEET(m_fExact);
        FETCH_DIR_DATA_FROM_SHEET(m_fPermanent);

        m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
        m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
        m_fAuthor = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SOURCE);
        m_fLogAccess = !m_fDontLog;

        SaveAuthoringState();
    END_META_DIR_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3FilePage::SaveInfo()
{
    ASSERT(IsDirty());

    CError err;

    SET_FLAG_IF(m_fRead, m_dwAccessPerms,   MD_ACCESS_READ);
    SET_FLAG_IF(m_fWrite, m_dwAccessPerms,  MD_ACCESS_WRITE);
    SET_FLAG_IF(m_fAuthor, m_dwAccessPerms, MD_ACCESS_SOURCE);
    BOOL m_fDontLog = !m_fLogAccess;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        INIT_DIR_DATA_MASK(m_dwAccessPerms, m_dwBitRangePermissions)

        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_fExact);
        STORE_DIR_DATA_ON_SHEET(m_fPermanent);
        //
        // CODEWORK: Not an elegant solution
        //
//        pSheet->GetDirectoryProperties().MarkRedirAsInherit(!m_fChild);
        STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
    END_META_DIR_WRITE(err)

    if (err.Succeeded())
    {
        SaveAuthoringState();
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
    }

    EndWaitCursor();

    return err;
}

void
CW3FilePage::OnCheckRead() 
{
    m_fRead = !m_fRead;
    SetAuthoringState(FALSE);
    OnItemChanged();
}

void
CW3FilePage::OnCheckWrite() 
{
    m_fWrite = !m_fWrite;
    SetAuthoringState(FALSE);
    OnItemChanged();
}

void 
CW3FilePage::OnCheckAuthor() 
{
    m_fAuthor = !m_fAuthor;
    SetAuthoringState(FALSE);
    OnItemChanged();
}

void 
CW3FilePage::OnRadioDir() 
{
    ChangeTypeTo(RADIO_DIRECTORY);
}

void 
CW3FilePage::OnRadioRedirect() 
{
    ChangeTypeTo(RADIO_REDIRECT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\webaddnew.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        WebAddNew.cpp

   Abstract:
        Classes for new Web site and virtual directory creation

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        12/12/2000       sergeia     Initial creation

--*/

#ifndef _WEB_NEW_WIZARD_H
#define _WEB_NEW_WIZARD_H


class CWebWizSettings : public CObjectPlus
/*++

Class Description:

    Web Wizard settings intended to pass along from page
    to page

--*/
{
//
// Constructor/Destructor
//
public:
    CWebWizSettings(
        IN CMetaKey * pMetaKey,
        IN LPCTSTR lpszServerName,     
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN LPCTSTR lpszParent   = NULL
        );

//
// Public Properties
//
public:
    BOOL    m_fLocal;
    BOOL    m_fUNC;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fAllowAnonymous;
    BOOL    m_fDirBrowsing;
    BOOL    m_fScript;
    BOOL    m_fExecute;
    BOOL    m_fNewSite;
    DWORD   m_dwInstance;
    CString m_strService;
    CString m_strParent;
    CString m_strServerName;
    CString m_strDescription;
    CString m_strBinding;
    CString m_strSecureBinding;
    CString m_strAlias;
    CString m_strPath;
    CString m_strUserName;
    CString m_strPassword;
    HRESULT m_hrResult;
    CMetaKey * m_pKey;
};



//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CWebWizDescription : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizDescription)

//
// Construction
//
public:
    CWebWizDescription(CWebWizSettings * pwsSettings = NULL);
    ~CWebWizDescription();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizDescription)
    enum { IDD = IDD_WEB_NEW_INST_DESCRIPTION };
    CEdit   m_edit_Description;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizDescription)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizDescription)
    afx_msg void OnChangeEditDescription();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CWebWizSettings * m_pSettings;
};


//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CWebWizBindings : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizBindings)

//
// Construction
//
public:
    CWebWizBindings(
        IN CWebWizSettings * pwsSettings = NULL,
        IN DWORD dwInstance = MASTER_INSTANCE
        );

    ~CWebWizBindings();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizBindings)
    enum { IDD = IDD_WEB_NEW_INST_BINDINGS };
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    UINT        m_nSSLPort;
    CString     m_strDomainName;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    BOOL        m_fCertInstalled;
    CIPAddress  m_iaIpAddress;
    CObListPlus m_oblIpAddresses;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizBindings)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizBindings)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    DWORD m_dwInstance;
    CWebWizSettings * m_pSettings;
};



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CWebWizAlias : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizAlias)

//
// Construction
//
public:
    CWebWizAlias(CWebWizSettings * pwsSettings = NULL);
    ~CWebWizAlias();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizAlias)
    enum { IDD = IDD_WEB_NEW_DIR_ALIAS };
    CEdit   m_edit_Alias;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizAlias)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizAlias)
    afx_msg void OnChangeEditAlias();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CWebWizSettings * m_pSettings;
};



//
// Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CWebWizPath : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizPath)

//
// Construction
//
public:
    CWebWizPath(
        IN CWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CWebWizPath();

    int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);
//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizPath)
    enum { IDD = -1 };
    CButton m_button_Browse;
    CEdit   m_edit_Path;
    //}}AFX_DATA


//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizPath)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizPath)
    afx_msg void OnChangeEditPath();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CWebWizSettings * m_pSettings;
    LPTSTR m_pPathTemp;
    CString m_strBrowseTitle;
};



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CWebWizUserName : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizUserName)

//
// Construction
//
public:
    CWebWizUserName(
        IN CWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CWebWizUserName();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizUserName)
    enum { IDD = IDD_WEB_NEW_USER_PASSWORD };
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizUserName)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizUserName)
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnChangeEditUsername();
    afx_msg void OnButtonCheckPassword();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CWebWizSettings * m_pSettings;
};



//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CWebWizPermissions : public CIISWizardPage
{
    DECLARE_DYNCREATE(CWebWizPermissions)

//
// Construction
//
public:
    CWebWizPermissions(
        IN CWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir           = TRUE
        );

    ~CWebWizPermissions();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CWebWizPermissions)
    enum { IDD = IDD_WEB_NEW_PERMS };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CWebWizPermissions)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CWebWizPermissions)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    BOOL m_bVDir;
    CWebWizSettings * m_pSettings;
};

#endif   //_WEB_NEW_WIZARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wsecure.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        security.h

   Abstract:

        WWW Security Property Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/
#ifndef __WSECURITY_H__
#define __WSECURITY_H__

//{{AFX_INCLUDES()
#include "certauth.h"
#include "certmap.h"
#include "certwiz.h"
//}}AFX_INCLUDES

class CW3SecurityPage : public CInetPropertyPage
/*++

Class Description:

    WWW Security property page

Public Interface:

    CW3SecurityPage     : Constructor
    ~CW3SecurityPage    : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3SecurityPage)

//
// Construction
//
public:
    CW3SecurityPage(
        IN CInetPropertySheet * pSheet = NULL,
        IN BOOL  fHome                 = FALSE,
        IN DWORD dwAttributes          = 0L
        );

    ~CW3SecurityPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3SecurityPage)
    enum { IDD = IDD_DIRECTORY_SECURITY };
    BOOL    m_fUseNTMapper;
    CStatic m_icon_Secure;
    CStatic m_static_SSLPrompt;
    CButton m_check_EnableDS;
    CButton m_button_GetCertificates;
    CButton m_button_ViewCertificates;
    CButton m_button_Communications;
    //}}AFX_DATA

    CCertWiz    m_ocx_CertificateAuthorities;

    DWORD       m_dwAuthFlags;
    DWORD       m_dwSSLAccessPermissions;
    CString     m_strBasicDomain;
    CString     m_strRealm;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3SecurityPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3SecurityPage)
    afx_msg void OnButtonAuthentication();
    afx_msg void OnButtonCommunications();
    afx_msg void OnButtonIpSecurity();
    afx_msg void OnButtonGetCertificates();
    afx_msg void OnButtonViewCertificates();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    BOOL FetchSSLState();
    void SetSSLControlState();

    LPCTSTR QueryInstanceMetaPath();

//
// Sheet Access
//
protected:
    CBlob & GetIPL() { return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().m_ipl; }

private:
    BOOL        m_fIpDirty;
    BOOL        m_fDefaultGranted;
    BOOL        m_fOldDefaultGranted;
    BOOL        m_fPasswordSync;
	BOOL		m_fPasswordSyncInitial;
    BOOL        m_fCertInstalled;
    BOOL        m_fU2Installed;
    BOOL        m_fHome;
    CString     m_strAnonUserName;
    CString     m_strAnonPassword;
    CObListPlus m_oblAccessList;
    //
    // Certificate and CTL information
    //
    CBlob       m_CertHash;
    CString     m_strCertStoreName;
    CString     m_strCTLIdentifier;
    CString     m_strCTLStoreName;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline LPCTSTR CW3SecurityPage::QueryInstanceMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}

#endif // __SECURITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wservic.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wservic.cpp

   Abstract:

        WWW Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetmgrapp.h"
#include "inetprop.h"
#include "shts.h"
#include "w3sht.h"
#include "wservic.h"
#include "mmmdlg.h"
#include "iisobj.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Values for PWS
//
#define LIMITED_CONNECTIONS_MIN    (10)
#define LIMITED_CONNECTIONS_MAX    (40)



//
// Default SSL port
//
#define DEFAULT_SSL_PORT            (441)



IMPLEMENT_DYNCREATE(CW3ServicePage, CInetPropertyPage)




CW3ServicePage::CW3ServicePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW service page

Arguments:

    CInetPropertySheet * pSheet : Property sheet object

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3ServicePage::IDD, pSheet),
      m_nSSLPort(DEFAULT_SSL_PORT),
      m_nTCPPort(80),
      m_iSSL(-1),
      m_iaIpAddress(NULL_IP_ADDRESS),
      m_strDomainName(),
      m_fLogUTF8(FALSE)
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CW3ServicePage)
    m_nUnlimited = RADIO_LIMITED;
    m_nIpAddressSel = -1;
    m_nTCPPort = 80;
    m_fEnableLogging = FALSE;
    m_fUseKeepAlives = FALSE;
    m_strComment = _T("");
    m_strDomainName = _T("");
    m_nSSLPort = DEFAULT_SSL_PORT;
    //}}AFX_DATA_INIT

    m_iaIpAddress = (LONG)0L;
    m_nMaxConnections = 50;
    m_nVisibleMaxConnections = 50;
    m_nConnectionTimeOut = 600;
    m_nSSLPort = DEFAULT_SSL_PORT;
    m_fUnlimitedConnections = FALSE;

#endif // 0

}



CW3ServicePage::~CW3ServicePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}




void
CW3ServicePage::GetTopBinding()
/*++

Routine Description:

    Get the first binding information in the list

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Show primary values;
    //
    ASSERT(m_strlBindings.GetCount() > 0
       || IS_MASTER_INSTANCE(QueryInstance()));

    if (m_strlBindings.GetCount() > 0)
    {
        CString & strBinding = m_strlBindings.GetHead();
        CInstanceProps::CrackBinding(
            strBinding,
            m_iaIpAddress,
            m_nTCPPort,
            m_strDomainName
            );

        //
        // Find SSL port that is bound to this IP address
        //
        m_iSSL = CInstanceProps::FindMatchingSecurePort(
            m_strlSecureBindings,
            m_iaIpAddress,
            m_nSSLPort
            );
    }
}



BOOL
CW3ServicePage::StoreTopBinding()
/*++

Routine Description:

    Take values from the dialog, and put them into the top level
    binding string.

Arguments:

    None

Return Value:

    TRUE if the values are correct, FALSE otherwise.

--*/
{
    if (!FetchIpAddressFromCombo(
        m_combo_IpAddresses,
        m_oblIpAddresses,
        m_iaIpAddress
        ))
    {
        //
        // Because UpdateData() is called before this, this should NEVER fail
        //
        ASSERT(FALSE);
        return FALSE;
    }

    CString strBinding;
    ASSERT(m_nTCPPort > 0);

    if (m_nTCPPort == m_nSSLPort)
    {
        //
        // TCP port and SSL port cannot be the same
        //
        ::AfxMessageBox(IDS_TCP_SSL_PART);
        return FALSE;
    }

    CInstanceProps::BuildBinding(
        strBinding,
        m_iaIpAddress,
        m_nTCPPort,
        m_strDomainName
        );

    //
    // Check binding ok
    //
    if (m_strlBindings.GetCount() > 0)
    {
        if (!IsBindingUnique(strBinding, m_strlBindings, 0))
        {
            ::AfxMessageBox(IDS_ERR_BINDING);
            return FALSE;
        }

        m_strlBindings.SetAt(m_strlBindings.GetHeadPosition(), strBinding);
    }
    else
    {
        m_strlBindings.AddTail(strBinding);
    }

    //
    // Now do the same for the SSL binding
    //
    if (m_fCertInstalled)
    {
        if (m_nSSLPort > 0)
        {
            CInstanceProps::BuildSecureBinding(
                strBinding,
                m_iaIpAddress,
                m_nSSLPort
                );

            if (m_strlSecureBindings.GetCount() > 0)
            {
                if (IsBindingUnique(strBinding, m_strlSecureBindings, m_iSSL))
                {
                    //
                    // Find its place
                    //
                    if (m_iSSL != -1)
                    {
                        //
                        // Replace selected entry
                        //
                        m_strlSecureBindings.SetAt(
                            m_strlSecureBindings.FindIndex(m_iSSL),
                            strBinding
                            );
                    }
                    else
                    {
                        //
                        // Add to end of list
                        //
                        ASSERT(!m_strlSecureBindings.IsEmpty());
                        m_strlSecureBindings.AddTail(strBinding);
                        m_iSSL = (int)m_strlSecureBindings.GetCount() - 1;
                    }
                }
                else
                {
                    //
                    // Entry already existed in the list.  This is OK, just
                    // delete the current entry rather than bothering
                    // to change it.
                    //
                    ASSERT(m_iSSL != -1);
                    if (m_iSSL != -1)
                    {
                        m_strlSecureBindings.RemoveAt(
                            m_strlSecureBindings.FindIndex(m_iSSL)
                            );
                        m_iSSL = CInstanceProps::FindMatchingSecurePort(
                            m_strlSecureBindings,
                            m_iaIpAddress,
                            m_nSSLPort
                            );
                        ASSERT(m_iSSL != -1);
                    }
                }
            }
            else
            {
                //
                // List of secure bindings was empty, add new entry
                //
                m_strlSecureBindings.AddTail(strBinding);
                m_iSSL = 0;
            }
        }
        else
        {
            //
            // Delete the secure binding if it did exist
            //
            if (m_iSSL != -1)
            {
                m_strlSecureBindings.RemoveAt(
                    m_strlSecureBindings.FindIndex(m_iSSL)
                    );
                m_iSSL = -1;
            }
        }
    }

    return TRUE;
}



void
CW3ServicePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store Control Data

Arguments:

    CDataExchange * pDX : Data exchange object

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    if (!pDX->m_bSaveAndValidate)
    {
        m_fEnableLogging = LoggingEnabled(m_dwLogType);
    }

    //{{AFX_DATA_MAP(CW3ServicePage)
//    DDX_Control(pDX, IDC_RADIO_UNLIMITED, m_radio_Unlimited);
    DDX_Control(pDX, IDC_BUTTON_PROPERTIES, m_button_LogProperties);
//    DDX_Control(pDX, IDC_STATIC_CONNECTIONS, m_static_Connections);
    DDX_Control(pDX, IDC_STATIC_LOG_PROMPT, m_static_LogPrompt);
    DDX_Control(pDX, IDC_EDIT_SSL_PORT, m_edit_SSLPort);
    DDX_Control(pDX, IDC_EDIT_TCP_PORT, m_edit_TCPPort);
//    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxConnections);
    DDX_Control(pDX, IDC_COMBO_LOG_FORMATS, m_combo_LogFormats);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESS, m_combo_IpAddresses);
//    DDX_Radio(pDX, IDC_RADIO_UNLIMITED, m_nUnlimited);
    DDX_Check(pDX, IDC_CHECK_USE_KEEPALIVE, m_fUseKeepAlives);
    DDX_Check(pDX, IDC_CHECK_ENABLE_LOGGING, m_fEnableLogging);
    DDX_Text(pDX, IDC_EDIT_COMMENT, m_strComment);
    DDV_MinMaxChars(pDX, m_strComment, 0, MAX_PATH);
    DDX_Control(pDX, IDC_LOG_UTF8, m_button_LogUTF8);
    DDX_Check(pDX, IDC_LOG_UTF8, m_fLogUTF8);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate && !FetchIpAddressFromCombo(
        m_combo_IpAddresses,
        m_oblIpAddresses,
        m_iaIpAddress
        ))
    {
        pDX->Fail();
    }

//    if (!pDX->m_bSaveAndValidate || !m_fUnlimitedConnections )
//    {
//        DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_nVisibleMaxConnections);
//    }
#if 0
    if (Has10ConnectionLimit())
    {
        //
        // Special validation for unlimited connections.  We use a bogus
        // numeric check for data validation.  Number adjustment happens
        // later.
        //
        if (pDX->m_bSaveAndValidate &&
            (m_nVisibleMaxConnections < 0
                || m_nVisibleMaxConnections > UNLIMITED_CONNECTIONS))
        {
            TCHAR szMin[32];
            TCHAR szMax[32];
            wsprintf(szMin, _T("%ld"), 0);
            wsprintf(szMax, _T("%ld"), 40);
            CString prompt;
            ::AfxFormatString2(prompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
            ::AfxMessageBox(prompt, MB_ICONEXCLAMATION);
            prompt.Empty();
            pDX->Fail();
        }
    }
    else
    {
        DDV_MinMaxDWord(pDX, m_nVisibleMaxConnections, 0, UNLIMITED_CONNECTIONS);
    }
#endif
    DDX_Text(pDX, IDC_EDIT_CONNECTION_TIMEOUT, m_nConnectionTimeOut);
    DDV_MinMaxLong(pDX, m_nConnectionTimeOut, 0, MAX_TIMEOUT);

    //
    // Port DDXV must be done just prior to storetopbinding,
    // so as to activate the right control in case of
    // failure
    //
    if (m_fCertInstalled && !IS_MASTER_INSTANCE(QueryInstance()))
    {
        DDXV_UINT(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort, 0, 65535);
    }

    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
    if (!IS_MASTER_INSTANCE(QueryInstance()))
    {
        DDV_MinMaxUInt(pDX, m_nTCPPort, 1, 65535);
    }

    if (pDX->m_bSaveAndValidate)
    {
        if (!IS_MASTER_INSTANCE(QueryInstance()))
        {
            if (!StoreTopBinding())
            {
                pDX->Fail();
            }
        }

        EnableLogging(m_dwLogType, m_fEnableLogging);
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CW3ServicePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3ServicePage)
//    ON_BN_CLICKED(IDC_RADIO_LIMITED, OnRadioLimited)
//    ON_BN_CLICKED(IDC_RADIO_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_LOGGING, OnCheckEnableLogging)
    ON_BN_CLICKED(IDC_BUTTON_ADVANCED, OnButtonAdvanced)
    ON_BN_CLICKED(IDC_BUTTON_PROPERTIES, OnButtonProperties)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_BN_CLICKED(IDC_CHECK_USE_KEEPALIVE, OnItemChanged)
    ON_BN_CLICKED(IDC_LOG_UTF8, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_TCP_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_CONNECTION_TIMEOUT, OnItemChanged)
//    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_IP_ADDRESS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_SSL_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME, OnItemChanged)
    ON_CBN_EDITCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_LOG_FORMATS, OnItemChanged)

END_MESSAGE_MAP()



void
CW3ServicePage::SetControlStates()
/*++

Routine Description:

    Set control states depending on the currently selected items

Arguments:

    None

Return Value:

    None.

--*/
{
//    if (m_edit_MaxConnections.m_hWnd)
//    {
//        m_edit_MaxConnections.EnableWindow(!m_fUnlimitedConnections);
//        m_static_Connections.EnableWindow(!m_fUnlimitedConnections);
//    }
}



void
CW3ServicePage::SetLogState()
/*++

Routine Description:

    Enable/disable logging controls depending on whether logging
    is enabled or not.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_LogPrompt.EnableWindow(m_fEnableLogging);
    m_combo_LogFormats.EnableWindow(m_fEnableLogging);
    m_button_LogProperties.EnableWindow(m_fEnableLogging);
    m_button_LogUTF8.EnableWindow(m_fEnableLogging);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CW3ServicePage::OnSetActive()
/*++

Routine Description:

    Property page is getting activation notification

Arguments:

    None

Return Value:

    TRUE to activate the page, FALSE otherwise.

--*/
{
    //
    // No certificates, no SSL
    //
    BeginWaitCursor();
    m_fCertInstalled = IsCertInstalledOnServer(QueryAuthInfo(), QueryMetaPath());
    EndWaitCursor();

    GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(
        m_fCertInstalled
     && !IS_MASTER_INSTANCE(QueryInstance())
     && HasAdminAccess()
        );

    GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(
        m_fCertInstalled
     && !IS_MASTER_INSTANCE(QueryInstance())
     && HasAdminAccess()
        );

    return CInetPropertyPage::OnSetActive();
}



BOOL
CW3ServicePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CInetPropertyPage::OnInitDialog();

    //
    // Take our direction from a phony button
    //
    CRect rc(0, 0, 0, 0);

    VERIFY(m_ocx_LogProperties.Create(
        _T("LogUI"),
        WS_BORDER,
        rc,
        this,
        IDC_LOGUICTRL
        ));

//    m_radio_Unlimited.EnableWindow(!Has10ConnectionLimit());

    //
    // Initialize the logging ocx
    //
    m_ocx_LogProperties.SetAdminTarget(QueryServerName(), QueryMetaPath());
    m_ocx_LogProperties.SetComboBox(m_combo_LogFormats.m_hWnd);

    //
    // Disable non heritable properties for master instance
    // or operator
    //
    if (IS_MASTER_INSTANCE(QueryInstance()) || !HasAdminAccess())
    {
        GetDlgItem(IDC_STATIC_IP_ADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_COMBO_IP_ADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON_ADVANCED)->EnableWindow(FALSE);
		GetDlgItem(IDC_STATIC_DESCRIPTION)->EnableWindow(FALSE);
		GetDlgItem(IDC_EDIT_COMMENT)->EnableWindow(FALSE);
    }
    m_button_LogUTF8.ShowWindow(
        GetSheet()->IsMasterInstance() &&
        GetSheet()->QueryMajorVersion() >= 6 ? SW_SHOW : SW_HIDE);

    {
        CWaitCursor wait;

        PopulateComboWithKnownIpAddresses(
            QueryServerName(),
            m_combo_IpAddresses,
            m_iaIpAddress,
            m_oblIpAddresses,
            m_nIpAddressSel
            );
    }

    SetControlStates();
    SetLogState();

    return TRUE;
}



/* virtual */
HRESULT
CW3ServicePage::FetchLoadedValues()
/*++

Routine Description:

    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    m_fCertInstalled = ::IsCertInstalledOnServer(QueryAuthInfo(), QueryMetaPath());

    BEGIN_META_INST_READ(CW3Sheet)
        FETCH_INST_DATA_FROM_SHEET(m_fUseKeepAlives);
//        FETCH_INST_DATA_FROM_SHEET(m_nMaxConnections);
        FETCH_INST_DATA_FROM_SHEET(m_nConnectionTimeOut);
        FETCH_INST_DATA_FROM_SHEET(m_strComment);
        FETCH_INST_DATA_FROM_SHEET(m_dwLogType);
        FETCH_INST_DATA_FROM_SHEET(m_strlBindings);
        FETCH_INST_DATA_FROM_SHEET(m_strlSecureBindings);
        FETCH_INST_DATA_FROM_SHEET(m_fLogUTF8);
        m_fLogUTF8_Init = m_fLogUTF8;
        GetTopBinding();
#if 0
        m_fUnlimitedConnections =
            ((ULONG)(LONG)m_nMaxConnections >= UNLIMITED_CONNECTIONS);

        if (Has10ConnectionLimit())
        {
            m_fUnlimitedConnections = FALSE;
            if ((LONG)m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
            {
                m_nMaxConnections = LIMITED_CONNECTIONS_MAX;
            }
        }
        //
        // Set the visible max connections edit field, which
        // may start out with a default value
        //
        m_nVisibleMaxConnections = m_fUnlimitedConnections
            ? INITIAL_MAX_CONNECTIONS
            : m_nMaxConnections;

        //
        // Set radio value
        //
        m_nUnlimited = m_fUnlimitedConnections ? RADIO_UNLIMITED : RADIO_LIMITED;
#endif
        m_nOldTCPPort = m_nTCPPort;
    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3ServicePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    BOOL fUpdateData : If TRUE, control data has not yet been stored.  This
                       is the case when "apply" is pressed.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 service page now...");

    CError err;
#if 0
    m_nMaxConnections = m_fUnlimitedConnections
        ? UNLIMITED_CONNECTIONS
        : m_nVisibleMaxConnections;

    //
    // Check to make sure we're not violating the license
    // agreement
    //
    if (Has10ConnectionLimit())
    {
        if (m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
        {
            ::AfxMessageBox(IDS_CONNECTION_LIMIT);
            m_nMaxConnections = LIMITED_CONNECTIONS_MIN;
        }
        else if (m_nMaxConnections >  LIMITED_CONNECTIONS_MIN
              && m_nMaxConnections <= LIMITED_CONNECTIONS_MAX)
        {
            ::AfxMessageBox(IDS_WRN_CONNECTION_LIMIT);
        }
    }
#endif
    m_ocx_LogProperties.ApplyLogSelection();
	BOOL fUpdateNode = FALSE;

    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CW3Sheet)
        STORE_INST_DATA_ON_SHEET(m_fUseKeepAlives);
//        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
        STORE_INST_DATA_ON_SHEET(m_nConnectionTimeOut);
        STORE_INST_DATA_ON_SHEET(m_strComment);
		fUpdateNode = MP_D(((CW3Sheet *)GetSheet())->GetInstanceProperties().m_strComment);
        STORE_INST_DATA_ON_SHEET(m_dwLogType);
        STORE_INST_DATA_ON_SHEET(m_strlBindings);
        STORE_INST_DATA_ON_SHEET(m_strlSecureBindings);
        STORE_INST_DATA_ON_SHEET(m_fLogUTF8);
        if (m_fLogUTF8_Init != m_fLogUTF8)
        {
           GetSheet()->SetRestartRequired(TRUE);
        }
    END_META_INST_WRITE(err)

	if (err.Succeeded() && fUpdateNode)
	{
		NotifyMMC();
	}

    EndWaitCursor();

    return err;
}



void
CW3ServicePage::OnItemChanged()
/*++

Routine Description

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    SetModified(TRUE);
}


#if 0
void
CW3ServicePage::OnRadioLimited()
/*++

Routine Description:

    'limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = FALSE;
    SetControlStates();
    m_edit_MaxConnections.SetSel(0,-1);
    m_edit_MaxConnections.SetFocus();
    OnItemChanged();
}



void
CW3ServicePage::OnRadioUnlimited()
/*++

Routine Description:

    'unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = TRUE;
    OnItemChanged();
}
#endif


void
CW3ServicePage::ShowTopBinding()
/*++

Routine Description:

    Put information about the top level binding in the dialog controls

Arguments:

    None

Return Value:

    None

--*/
{
    BeginWaitCursor();
    GetTopBinding();
    PopulateComboWithKnownIpAddresses(
        QueryServerName(),
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();

    CString strTCPPort, strSSLPort;
    if (m_nTCPPort)
    {
        strTCPPort.Format(_T("%ld"), m_nTCPPort);
    }
    if (m_nSSLPort)
    {
        strSSLPort.Format(_T("%ld"), m_nSSLPort);
    }

    m_edit_TCPPort.SetWindowText(strTCPPort);
    m_edit_SSLPort.SetWindowText(strSSLPort);
}



void
CW3ServicePage::OnButtonAdvanced()
/*++

Routine Description:

    'advanced' button handler -- bring up the bindings dialog

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CMMMDlg dlg(
        QueryServerName(),
        QueryInstance(),
        QueryAuthInfo(),
        QueryMetaPath(),
        m_strlBindings,
        m_strlSecureBindings,
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        //
        // Get information about the top level binding
        //
        m_strlBindings.RemoveAll();
        m_strlSecureBindings.RemoveAll();
        m_strlBindings.AddTail(&(dlg.GetBindings()));
        m_strlSecureBindings.AddTail(&(dlg.GetSecureBindings()));
        ShowTopBinding();
        OnItemChanged();
    }
}



void
CW3ServicePage::OnCheckEnableLogging()
/*++

Routine Description:

    'enable logging' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableLogging = !m_fEnableLogging;
    SetLogState();
    OnItemChanged();
}



void
CW3ServicePage::OnButtonProperties()
/*++

Routine Description:

    Pass on "log properties" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());
    m_ocx_LogProperties.DoClick();
}



void
CW3ServicePage::OnDestroy()
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();

    if (m_ocx_LogProperties.m_hWnd)
    {
        m_ocx_LogProperties.Terminate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wsecure.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        security.cpp

   Abstract:

        WWW Security Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "w3sht.h"
#include "wincrypt.h"
#include "resource.h"
#include "wsecure.h"
#include "authent.h"
#include "seccom.h"
#include "ipdomdlg.h"

#include "cryptui.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CW3SecurityPage property page
//
IMPLEMENT_DYNCREATE(CW3SecurityPage, CInetPropertyPage)



CW3SecurityPage::CW3SecurityPage(
    IN CInetPropertySheet * pSheet,
    IN BOOL  fHome,
    IN DWORD dwAttributes
    )
/*++

Routine Description:

    Constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet object
    BOOL fHome                  : TRUE if this is a home directory
    DWORD dwAttributes          : Attributes

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3SecurityPage::IDD, pSheet,
        IS_FILE(dwAttributes)
            ? IDS_TAB_FILE_SECURITY
            : IDS_TAB_DIR_SECURITY
            ),
      m_oblAccessList(),
      m_fU2Installed(FALSE),
      m_fIpDirty(FALSE),
      m_fHome(fHome),
      //
      // By default, we grant access
      //
      m_fOldDefaultGranted(TRUE),
      m_fDefaultGranted(TRUE)   
{

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CW3SecurityPage)
    m_fUseNTMapper = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

}


CW3SecurityPage::~CW3SecurityPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CW3SecurityPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3SecurityPage)
    DDX_Check(pDX, IDC_CHECK_ENABLE_DS, m_fUseNTMapper);
    DDX_Control(pDX, IDC_ICON_SECURE, m_icon_Secure);
    DDX_Control(pDX, IDC_STATIC_SSL_PROMPT, m_static_SSLPrompt);
    DDX_Control(pDX, IDC_CHECK_ENABLE_DS, m_check_EnableDS);
    DDX_Control(pDX, IDC_BUTTON_GET_CERTIFICATES, m_button_GetCertificates);
    DDX_Control(pDX, IDC_VIEW_CERTIFICATE, m_button_ViewCertificates);
    DDX_Control(pDX, IDC_BUTTON_COMMUNICATIONS, m_button_Communications);
    //}}AFX_DATA_MAP
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3SecurityPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3SecurityPage)
    ON_BN_CLICKED(IDC_BUTTON_AUTHENTICATION, OnButtonAuthentication)
    ON_BN_CLICKED(IDC_BUTTON_COMMUNICATIONS, OnButtonCommunications)
    ON_BN_CLICKED(IDC_BUTTON_IP_SECURITY, OnButtonIpSecurity)
    ON_BN_CLICKED(IDC_BUTTON_GET_CERTIFICATES, OnButtonGetCertificates)
    ON_BN_CLICKED(IDC_VIEW_CERTIFICATE, OnButtonViewCertificates)
    //}}AFX_MSG_MAP

    ON_BN_CLICKED(IDC_CHECK_ENABLE_DS, OnItemChanged)

END_MESSAGE_MAP()



/* virtual */
HRESULT
CW3SecurityPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    BEGIN_META_DIR_READ(CW3Sheet)
        FETCH_DIR_DATA_FROM_SHEET(m_dwAuthFlags);
        FETCH_DIR_DATA_FROM_SHEET(m_dwSSLAccessPermissions);
        FETCH_DIR_DATA_FROM_SHEET(m_strBasicDomain);
        FETCH_DIR_DATA_FROM_SHEET(m_strRealm);
        FETCH_DIR_DATA_FROM_SHEET(m_strAnonUserName);
        FETCH_DIR_DATA_FROM_SHEET(m_strAnonPassword);
        FETCH_DIR_DATA_FROM_SHEET(m_fPasswordSync);
        FETCH_DIR_DATA_FROM_SHEET(m_fU2Installed);        
        FETCH_DIR_DATA_FROM_SHEET(m_fUseNTMapper);
    END_META_DIR_READ(err)
	m_fPasswordSyncInitial = m_fPasswordSync;
    //
    // First we need to read in the hash and the name of the store. If either
    // is not there then there is no certificate.
    //
    BEGIN_META_INST_READ(CW3Sheet)
// BUGBUG we are not fetching the hash right now because it needs a new
// copy constructor. Otherwise it does a bitwise copy of the pointer value.
// Then this one desctructs, freeing the pointer. Then the other one desctucts
// freeing it again.
//        FETCH_INST_DATA_FROM_SHEET(m_CertHash);
        FETCH_INST_DATA_FROM_SHEET(m_strCertStoreName);
        FETCH_INST_DATA_FROM_SHEET(m_strCTLIdentifier);
        FETCH_INST_DATA_FROM_SHEET(m_strCTLStoreName);
    END_META_INST_READ(err) 

    //
    // Build the IPL list
    //
    err = BuildIplOblistFromBlob(
        GetIPL(),
        m_oblAccessList,
        m_fDefaultGranted
        );

    m_fOldDefaultGranted = m_fDefaultGranted;

    return err;
}



/* virtual */
HRESULT
CW3SecurityPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 security page now...");

    CError err;

    //
    // Check to see if the ip access list needs saving.
    //
    BOOL fIplDirty = m_fIpDirty || (m_fOldDefaultGranted != m_fDefaultGranted);

    //
    // Use m_ notation because the message crackers require it
    //
    CBlob m_ipl;

    if (fIplDirty)
    {
        BuildIplBlob(m_oblAccessList, m_fDefaultGranted, m_ipl);
    }

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_dwSSLAccessPermissions)
        STORE_DIR_DATA_ON_SHEET(m_dwAuthFlags)
        STORE_DIR_DATA_ON_SHEET(m_strBasicDomain)
        STORE_DIR_DATA_ON_SHEET(m_strRealm)

        if (fIplDirty)
        {
            STORE_DIR_DATA_ON_SHEET(m_ipl)
        }
        STORE_DIR_DATA_ON_SHEET(m_strAnonUserName)
        STORE_DIR_DATA_ON_SHEET(m_fPasswordSync)
        STORE_DIR_DATA_ON_SHEET(m_fUseNTMapper)
        if (m_fPasswordSync != m_fPasswordSyncInitial && m_fPasswordSync)
        {
            FLAG_DIR_DATA_FOR_DELETION(MD_ANONYMOUS_PWD);
        }
        else
        {
            STORE_DIR_DATA_ON_SHEET(m_strAnonPassword);
        }
    END_META_DIR_WRITE(err)

    if (err.Succeeded())
    {
        BEGIN_META_INST_WRITE(CW3Sheet)
            if ( m_strCTLIdentifier.IsEmpty() )
            {
                FLAG_INST_DATA_FOR_DELETION( MD_SSL_CTL_IDENTIFIER )
            }
            else
            {
                STORE_INST_DATA_ON_SHEET(m_strCTLIdentifier)
            }

            if ( m_strCTLStoreName.IsEmpty() )
            {
                FLAG_INST_DATA_FOR_DELETION( MD_SSL_CTL_STORE_NAME )
            }
            else
            {
                STORE_INST_DATA_ON_SHEET(m_strCTLStoreName)
            }
        END_META_INST_WRITE(err)
    }

    EndWaitCursor();

    if (err.Succeeded())
    {
        m_fIpDirty = FALSE;
        m_fOldDefaultGranted = m_fDefaultGranted;
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
    }

    return err;
}



BOOL
CW3SecurityPage::FetchSSLState()
/*++

Routine Description:

    Obtain the state of the dialog depending on whether certificates
    are installed or not.

Arguments:

    None

Return Value:

    TRUE if certificates are installed, FALSE otherwise

--*/
{
    BeginWaitCursor();
    m_fCertInstalled = ::IsCertInstalledOnServer(
        QueryAuthInfo(), 
        QueryMetaPath()
        );
    EndWaitCursor();

    return m_fCertInstalled;
}



void
CW3SecurityPage::SetSSLControlState()
/*++

Routine Description:

    Enable/disable supported controls depending on what's installed.
    Only available on non-master instance nodes.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_SSLPrompt.EnableWindow(!IsMasterInstance());
    m_button_GetCertificates.EnableWindow(
        !IsMasterInstance() 
     && m_fHome 
     && IsLocal() 
        );
    m_button_Communications.EnableWindow(
        !IsMasterInstance() 
     && IsSSLSupported() 
     && FetchSSLState()
        );
    m_button_ViewCertificates.EnableWindow(m_fCertInstalled);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CW3SecurityPage::OnSetActive() 
/*++

Routine Description:

    Page got activated -- set the SSL state depending on whether a
    certificate is installed or not.

Arguments:

    None

Return Value:

    TRUE to activate the page, FALSE otherwise.

--*/
{
    //
    // Enable/disable ssl controls
    //
    SetSSLControlState();
    
    return CInetPropertyPage::OnSetActive();
}



BOOL 
CW3SecurityPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Initialize certificate authorities ocx
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_CertificateAuthorities.Create(
        _T("CertWiz"),
        WS_BORDER,
        rc,
        this,
        IDC_APPSCTRL
        );

    GetDlgItem(IDC_GROUP_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_STATIC_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_BUTTON_IP_SECURITY)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_BUTTON_AUTHENTICATION)->EnableWindow(!m_fU2Installed);

    //
    // Configure for either master or non-master display.
    //
    m_check_EnableDS.ShowWindow(IsMasterInstance() ? SW_SHOW : SW_HIDE);
    m_check_EnableDS.EnableWindow(
        HasAdminAccess() 
     && IsMasterInstance() 
     && HasNTCertMapper()
        );

#define SHOW_NON_MASTER(x)\
   (x).ShowWindow(IsMasterInstance() ? SW_HIDE : SW_SHOW)
    
    SHOW_NON_MASTER(m_static_SSLPrompt);
    SHOW_NON_MASTER(m_icon_Secure);
    SHOW_NON_MASTER(m_button_GetCertificates);
    SHOW_NON_MASTER(m_button_Communications);
    SHOW_NON_MASTER(m_button_ViewCertificates);

#undef SHOW_NON_MASTER

    return TRUE;  
}



void 
CW3SecurityPage::OnButtonAuthentication() 
/*++

Routine Description:

    'Authentication' button hander

Arguments:

    None

Return Value:

    None

--*/
{
    CAuthenticationDlg dlg(
        QueryServerName(), 
        QueryInstance(), 
        m_strBasicDomain,
        m_strRealm,
        m_dwAuthFlags, 
        m_dwSSLAccessPermissions, 
        m_strAnonUserName,
        m_strAnonPassword,
        m_fPasswordSync,
        HasAdminAccess(),
        HasDigest(),
        this
        );

    DWORD dwOldAccess = m_dwSSLAccessPermissions;
    DWORD dwOldAuth = m_dwAuthFlags;
    CString strOldDomain = m_strBasicDomain;
    CString strOldRealm = m_strRealm;
    CString strOldUserName = m_strAnonUserName;
    CString strOldPassword = m_strAnonPassword;
    BOOL fOldPasswordSync = m_fPasswordSync;

    if (dlg.DoModal() == IDOK)
    {
        //
        // See if anything has changed
        //
        if (dwOldAccess != m_dwSSLAccessPermissions 
            || dwOldAuth != m_dwAuthFlags
            || m_strBasicDomain != strOldDomain
            || m_strRealm != strOldRealm
            || m_strAnonUserName != strOldUserName 
            || m_strAnonPassword != strOldPassword
            || m_fPasswordSync != fOldPasswordSync
            )
        {
            //
            // Mark as dirty
            //
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonCommunications() 
/*++

Routine Description:

    'Communications' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Prep the flag for if we can edit CTLs or not
    //
    BOOL fEditCTLs = IsMasterInstance() || m_fHome;

    //
    // Prep the communications dialog
    //
    CSecCommDlg dlg(
        QueryServerName(), 
        QueryInstanceMetaPath(), 
        m_strBasicDomain,
        m_dwAuthFlags, 
        QueryAuthInfo(),
        m_dwSSLAccessPermissions, 
        IsMasterInstance(),
        IsSSLSupported(), 
        IsSSL128Supported(),
        m_fU2Installed,
        m_strCTLIdentifier,
        m_strCTLStoreName,
        fEditCTLs,
        IsLocal(),
        this
        );

    DWORD dwOldAccess = m_dwSSLAccessPermissions;
    DWORD dwOldAuth = m_dwAuthFlags;

    if (dlg.DoModal() == IDOK)
    {
        //
        // See if anything has changed
        //
        if (dwOldAccess != m_dwSSLAccessPermissions 
            || dwOldAuth != m_dwAuthFlags
            )
        {
            //
            // Mark as dirty
            //
            OnItemChanged();
        }

        //
        // See if the CTL information has changed
        //
        if (dlg.m_bCTLDirty)
        {
            m_strCTLIdentifier = dlg.m_strCTLIdentifier;
            m_strCTLStoreName = dlg.m_strCTLStoreName;
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonIpSecurity() 
/*++

Routine Description:

    'tcpip' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CIPDomainDlg dlg(
        m_fIpDirty,
        m_fDefaultGranted,
        m_fOldDefaultGranted,
        m_oblAccessList, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        //
        // Rebuild the list.  Temporarily reset ownership, otherwise
        // RemoveAll() will destroy the pointers which are shared with the
        // new list.
        //
        BOOL fOwn = m_oblAccessList.SetOwnership(FALSE);
        m_oblAccessList.RemoveAll();
        m_oblAccessList.AddTail(&dlg.GetAccessList());
        m_oblAccessList.SetOwnership(fOwn);

        if (m_fIpDirty || m_fOldDefaultGranted != m_fDefaultGranted)
        {
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonGetCertificates() 
/*++

Routine Description:

    "get certicate" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_ocx_CertificateAuthorities.SetMachineName(QueryServerName());
    m_ocx_CertificateAuthorities.SetServerInstance(QueryInstanceMetaPath());
    m_ocx_CertificateAuthorities.DoClick();

    //
    // There may now be a certificate. See if we should enable the edit button.
    //
    SetSSLControlState();
}


void 
CW3SecurityPage::OnButtonViewCertificates() 
/*++

Routine Description:

    "view certicate" button handler

Arguments:

    None

Return Value:

    None

--*/
{
   HCERTSTORE hStore = NULL;
   PCCERT_CONTEXT pCert = NULL;
   CMetaKey key(QueryAuthInfo(),
            QueryInstanceMetaPath(),
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				METADATA_MASTER_ROOT_HANDLE);
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM,
                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
           		    NULL,
                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                    store_name
                    );
            if (hStore != NULL)
            {
				// Now we need to find cert by hash
				CRYPT_HASH_BLOB crypt_hash;
				crypt_hash.cbData = hash.GetSize();
				crypt_hash.pbData = hash.GetData();
				pCert = CertFindCertificateInStore(hStore, 
					X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
					0, CERT_FIND_HASH, (LPVOID)&crypt_hash, NULL);
            }
        }
    }
	if (pCert)
	{
		BOOL fPropertiesChanged;
		CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
		HCERTSTORE hCertStore = ::CertDuplicateStore(hStore);
		::ZeroMemory (&vcs, sizeof (vcs));
		vcs.dwSize = sizeof (vcs);
		vcs.hwndParent = GetParent()->GetSafeHwnd();
		vcs.dwFlags = 0;
		vcs.cStores = 1;
		vcs.rghStores = &hCertStore;
		vcs.pCertContext = pCert;
		::CryptUIDlgViewCertificate(&vcs, &fPropertiesChanged);
		::CertCloseStore (hCertStore, 0);
	}
    else
    {
    }
    if (pCert != NULL)
        ::CertFreeCertificateContext(pCert);
    if (hStore != NULL)
        ::CertCloseStore(hStore, 0);
}

void
CW3SecurityPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wservic.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wservic.h

   Abstract:

        WWW Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//{{AFX_INCLUDES()
#include "logui.h"
//}}AFX_INCLUDES

class CW3Sheet;

class CW3ServicePage : public CInetPropertyPage
/*++

Class Description:

    WWW Service Page 

Public Interface:

    CW3ServicePage      : Constructor
    ~CW3ServicePage     : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3ServicePage)

//
// Construction
//
public:
    CW3ServicePage(IN CInetPropertySheet * pSheet = NULL);
    ~CW3ServicePage();

//
// Dialog Data
//
protected:
    //
    //  Radio button IDs for unlimited radio control
    //
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CW3ServicePage)
    enum { IDD = IDD_WEB_SERVICE };
//    int         m_nUnlimited;
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    BOOL        m_fUseKeepAlives;
    BOOL        m_fEnableLogging;
    CString     m_strComment;
    CString     m_strDomainName;
    CEdit       m_edit_SSLPort;
    CEdit       m_edit_TCPPort;
//    CEdit       m_edit_MaxConnections;
//    CButton     m_radio_Unlimited;
    CButton     m_button_LogProperties;
    CButton     m_button_LogUTF8;
    CStatic     m_static_SSLPort;
//    CStatic     m_static_Connections;
    CStatic     m_static_LogPrompt;
    CComboBox   m_combo_LogFormats;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    int         m_iSSL;
//    BOOL        m_fUnlimitedConnections;
    BOOL        m_fLogUTF8;
    BOOL        m_fLogUTF8_Init;
    UINT        m_nOldTCPPort;
    UINT        m_nSSLPort;
    CILong      m_nConnectionTimeOut;
//    CILong      m_nMaxConnections;
//    CILong      m_nVisibleMaxConnections;
    CLogUI      m_ocx_LogProperties;
    CIPAddress  m_iaIpAddress;
    DWORD       m_dwLogType;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3ServicePage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3ServicePage)
    virtual BOOL OnInitDialog();
//    afx_msg void OnRadioLimited();
//    afx_msg void OnRadioUnlimited();
    afx_msg void OnCheckEnableLogging();
    afx_msg void OnButtonAdvanced();
    afx_msg void OnButtonProperties();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    void SetLogState();
    void GetTopBinding();
    void ShowTopBinding();
    BOOL StoreTopBinding();
    LPCTSTR QueryMetaPath();

//
// Access to the sheet data
//
protected:
    BOOL          m_fCertInstalled;
    CObListPlus   m_oblIpAddresses;
    CStringListEx m_strlBindings;
    CStringListEx m_strlSecureBindings;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline LPCTSTR CW3ServicePage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wvdir.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        vdir.h

   Abstract:

        WWW Directory Properties Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __WVDIR_H__
#define __WVDIR__H_ 



//{{AFX_INCLUDES()
//#include "apps.h"
//}}AFX_INCLUDES

class CW3DirectoryPage : public CInetPropertyPage
/*++

Class Description:

    WWW Virtual Directory Page.

Public Interface:

    CW3DirectoryPage    : Constructor
    ~CW3DirectoryPage   : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3DirectoryPage)

//
// Constructor/Destructor
//
public:
    CW3DirectoryPage(
        IN CInetPropertySheet * pSheet = NULL, 
        IN BOOL fHome                  = FALSE,
        IN DWORD dwAttributes          = FILE_ATTRIBUTE_VIRTUAL_DIRECTORY
        );

    ~CW3DirectoryPage();

	int BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam);

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_DIRECTORY,
        RADIO_NETDIRECTORY,
        RADIO_REDIRECT,
    };

    enum
    {
        COMBO_NONE,
        COMBO_SCRIPT,
        COMBO_EXECUTE,
    };

    //{{AFX_DATA(CW3DirectoryPage)
    enum { IDD = IDD_WEB_DIRECTORY_PROPERTIES };
    CStatic m_static_ProtectionPrompt;
    CStatic m_static_PermissionsPrompt;
    int     m_nPathType;
    int     m_nPermissions;
    BOOL    m_fBrowsingAllowed;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fAuthor;
    BOOL    m_fLogAccess;
    BOOL    m_fIndexed;
    BOOL    m_fChild;
    BOOL    m_fExact;
    BOOL    m_fPermanent;
    CString m_strPath;
    CString m_strRedirectPath;
    CString m_strAppFriendlyName;
    CEdit   m_edit_Footer;
    CEdit   m_edit_Path;
    CEdit   m_edit_Redirect;
    CEdit   m_edit_AppFriendlyName;
    CStatic m_static_AppPrompt;
    CStatic m_static_Path;
    CStatic m_static_PathPrompt;
    CStatic m_static_AliasPrompt;
    CStatic m_static_Alias;
    CStatic m_static_StartingPoint;
    CButton m_button_Unload;
    CButton m_button_CreateRemove;
    CButton m_button_Browse;
    CButton m_button_ConnectAs;
    CButton m_button_Configuration;
    CButton m_radio_Dir;
    CButton m_check_Author;
    CButton m_check_Child;
    CButton m_check_DirBrowse;
    CButton m_check_Index;
    CButton m_check_Write;
    CButton m_check_Read;
    CComboBox m_combo_Permissions;
    CComboBox m_combo_Process;
    //}}AFX_DATA

    
    BOOL  m_fOriginallyUNC;
    BOOL  m_fLoaded;
    DWORD m_dwAppState;
    DWORD m_dwAppProtection;
    DWORD m_dwAccessPermissions;
    DWORD m_dwDirBrowsing;
    DWORD m_dwBitRangePermissions;
    DWORD m_dwAccessPerms;
    DWORD m_dwBitRangeDirBrowsing;
    CString m_strAlias;
    CString m_strAppRoot;
    CButton m_radio_Unc;
    CButton m_radio_Redirect;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3DirectoryPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3DirectoryPage)
    afx_msg void OnButtonBrowse();
    afx_msg void OnButtonConnectAs();
    afx_msg void OnButtonCreateRemoveApp();
    afx_msg void OnButtonUnloadApp();
    afx_msg void OnButtonConfiguration();
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckRead();
    afx_msg void OnCheckWrite();
    afx_msg void OnCheckAuthor();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioRedirect();
    afx_msg void OnRadioUnc();
    afx_msg void OnSelchangeComboPermissions();
    afx_msg void OnSelchangeComboProcess();
    afx_msg void OnDestroy();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void ShowControl(
        IN CWnd * pWnd,
        IN BOOL fShow
        );

    void ShowControl(
        IN UINT nID,
        IN BOOL fShow
        );

    int AddStringToComboBox(
        IN CComboBox & combo,
        IN UINT nID
        );

    int   SetComboSelectionFromAppState(DWORD dwAppState);
    DWORD GetAppStateFromComboSelection()  const;
    BOOL  ShowProcOptionsForThisAppState(
        IN DWORD dwAppProtection
        ) const;
    
    void SetStateByType();
    void SetPathType();
    void SetPathType(LPCTSTR lpstrPath);
    void SetApplicationState();
    void SetState();
    void SetAuthoringState(BOOL fAlterReadAndWrite = TRUE);
    void RefreshAppState();
    void ChangeTypeTo(int nNewType);
    BOOL BrowseUser();
    BOOL CheckWriteAndExecWarning();
    LPCTSTR QueryMetaPath();

    CString & FriendlyAppRoot(
        IN LPCTSTR lpAppRoot,
        OUT CString & strStartingPoint
        );

    BOOL IsHome() const { return m_fHome; }

//
// Sheet Data Access
//
protected:
    BOOL IsVroot() const { return IS_VROOT(m_dwAttributes); }
    BOOL IsDir() const { return IS_DIR(m_dwAttributes); }
    BOOL IsFile() const { return IS_FILE(m_dwAttributes); }

protected:
    //
    // Remember/restore settings.
    //
    void SaveAuthoringState();
    void RestoreAuthoringState();

private:
    int   m_nSelInProc;
    int   m_nSelPooledProc;
    int   m_nSelOutOfProc;
    BOOL  m_fHome;
    BOOL  m_fRecordChanges;  
    BOOL  m_fAppEnabled;
    BOOL  m_fIsAppRoot;
    BOOL  m_fParentEnabled;
    BOOL  m_fOriginalBrowsingAllowed;
    BOOL  m_fOriginalRead;
    BOOL  m_fOriginalWrite;
    BOOL  m_fCompatibilityMode;
    DWORD m_dwAttributes;
    CString m_strMetaRoot;
    CString m_strOldPath;
    CString m_strUserName;
    CString m_strPassword;
    CString m_strRemove;
    CString m_strCreate;
    CString m_strEnable;
    CString m_strDisable;
    CString m_strWebFmt;
    CString m_strPrompt[3];
    CIISApplication * m_pApplication;
	LPTSTR m_pPathTemp;
	CString m_strBrowseTitle;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CW3DirectoryPage::ShowControl(
    IN UINT nID,
    IN BOOL fShow
    )
{
    ASSERT(nID > 0);
    ShowControl(GetDlgItem(nID), fShow);
}

inline LPCTSTR CW3DirectoryPage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().QueryMetaRoot();
}

inline BOOL CW3DirectoryPage::ShowProcOptionsForThisAppState(
    IN DWORD dwAppProtection
    ) const
{
    return dwAppProtection == CWamInterface::APP_OUTOFPROC 
        || IsMasterInstance();
}

#endif // __WVDIR__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\snapin\wvdir.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        wvdir.cpp

   Abstract:
        WWW Directory Properties Page

   Author:
        Ronald Meijer (ronaldm)
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:
        11/15/2000      sergeia     Added the mess of application pools for iis6
        03/01/2001      sergeia     Split dialog for file system objects. Now this source
                                    works for sites and vdirs only
--*/
#include "stdafx.h"
#include "resource.h"
#include "common.h"
#include "inetprop.h"
#include "InetMgrApp.h"
#include "supdlgs.h"
#include "shts.h"
#include "w3sht.h"
#include "wvdir.h"
#include "dirbrows.h"
#include "iisobj.h"

#include <lmcons.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Directory Properties Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

LPCTSTR 
CvtPathToDosStyle(CString & strPath)
{
    //
    // Get a pointer to the string data without increasing the buffer
    //
    for (LPTSTR lp = strPath.GetBuffer(1); *lp; ++lp)
    {
        if (*lp == _T('/'))
        {
            *lp = _T('\\');
        }
    }
    strPath.ReleaseBuffer();

    return strPath;
}

IMPLEMENT_DYNCREATE(CW3DirectoryPage, CInetPropertyPage)



CW3DirectoryPage::CW3DirectoryPage(
    CInetPropertySheet * pSheet,
    BOOL fHome,
    DWORD dwAttributes
    ) 
/*++

Routine Description:

    Constructor for directory property page

Arguments:

    CInetPropertySheet * pSheet : Sheet pointer
    BOOL fHome                  : TRUE if this is a home directory
    DWORD dwAttributes          : Attributes of the  directory/file/vroot

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3DirectoryPage::IDD, pSheet, 
		fHome ? IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY),
      //
      // Assign the range of bits in m_dwAccessPermissions that
      // we manage.  This is important, because another page
      // manages other bits, and we don't want to screw up
      // the master value bits when our changes collide (it
      // will mark the original bits as dirty, because we're not
      // notified when the change is made...
      //
      m_dwBitRangePermissions(MD_ACCESS_EXECUTE | 
            MD_ACCESS_SCRIPT | 
            MD_ACCESS_WRITE  | 
            MD_ACCESS_SOURCE |
            MD_ACCESS_READ),
      m_dwBitRangeDirBrowsing(MD_DIRBROW_ENABLED),
      m_fHome(fHome),
      m_fRecordChanges(TRUE),
      m_strMetaRoot(),
      m_pApplication(NULL),
      m_fOriginallyUNC(FALSE),
      m_fCompatibilityMode(FALSE)
{
    VERIFY(m_strPrompt[RADIO_DIRECTORY].LoadString(IDS_PROMPT_DIR));
    VERIFY(m_strPrompt[RADIO_NETDIRECTORY].LoadString(IDS_PROMPT_UNC));
    VERIFY(m_strPrompt[RADIO_REDIRECT].LoadString(IDS_PROMPT_REDIRECT));
    VERIFY(m_strRemove.LoadString(IDS_BUTTON_REMOVE));
    VERIFY(m_strCreate.LoadString(IDS_BUTTON_CREATE));
    VERIFY(m_strEnable.LoadString(IDS_BUTTON_ENABLE));
    VERIFY(m_strDisable.LoadString(IDS_BUTTON_DISABLE));
    VERIFY(m_strWebFmt.LoadString(IDS_APPROOT_FMT));
}



CW3DirectoryPage::~CW3DirectoryPage()
{
    SAFE_DELETE(m_pApplication);
}



void 
CW3DirectoryPage::DoDataExchange(CDataExchange * pDX)
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3DirectoryPage)
    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
    DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
    DDX_Control(pDX, IDC_RADIO_REDIRECT, m_radio_Redirect);
    DDX_Control(pDX, IDC_RADIO_UNC, m_radio_Unc);

    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Check(pDX, IDC_CHECK_AUTHOR, m_fAuthor);
    DDX_Control(pDX, IDC_CHECK_AUTHOR, m_check_Author);
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);    
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Check(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_fBrowsingAllowed);
    DDX_Control(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_check_DirBrowse);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);
    DDX_Check(pDX, IDC_CHECK_INDEX, m_fIndexed);
    DDX_Control(pDX, IDC_CHECK_INDEX, m_check_Index);

    DDX_Control(pDX, IDC_EDIT_REDIRECT, m_edit_Redirect);
    DDX_Control(pDX, IDC_BUTTON_CONNECT_AS, m_button_ConnectAs);
    DDX_Check(pDX, IDC_CHECK_CHILD, m_fChild);
    DDX_Control(pDX, IDC_CHECK_CHILD, m_check_Child);
    DDX_Check(pDX, IDC_CHECK_EXACT, m_fExact);
    DDX_Check(pDX, IDC_CHECK_PERMANENT, m_fPermanent);

    DDX_Control(pDX, IDC_STATIC_PATH_PROMPT, m_static_PathPrompt);

    DDX_Control(pDX, IDC_STATIC_PERMISSIONS, m_static_PermissionsPrompt);
    DDX_CBIndex(pDX, IDC_COMBO_PERMISSIONS, m_nPermissions);
    DDX_Control(pDX, IDC_COMBO_PERMISSIONS, m_combo_Permissions);

    DDX_Control(pDX, IDC_STATIC_APP_PROMPT, m_static_AppPrompt);
    DDX_Text(pDX, IDC_EDIT_APPLICATION, m_strAppFriendlyName);
    DDV_MinMaxChars(pDX, m_strAppFriendlyName, 0, MAX_PATH); /// ?
    DDX_Control(pDX, IDC_EDIT_APPLICATION, m_edit_AppFriendlyName);

    DDX_Control(pDX, IDC_STATIC_STARTING_POINT, m_static_StartingPoint);
    DDX_Control(pDX, IDC_STATIC_PROTECTION, m_static_ProtectionPrompt);
    DDX_Control(pDX, IDC_BUTTON_UNLOAD_APP, m_button_Unload);
    DDX_Control(pDX, IDC_BUTTON_CREATE_REMOVE_APP, m_button_CreateRemove);
    DDX_Control(pDX, IDC_APP_CONFIGURATION, m_button_Configuration);

    DDX_Control(pDX, IDC_COMBO_PROCESS, m_combo_Process);
    //}}AFX_DATA_MAP



    if (pDX->m_bSaveAndValidate)
    {
        //
        // Make sure all field names are correct
        //
        if (m_nPathType == RADIO_NETDIRECTORY)
        {   
            DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
            m_strPath.TrimLeft();
            DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);

            if (!PathIsValid(m_strPath) || !PathIsUNC(m_strPath))
            {
                ::AfxMessageBox(IDS_BAD_UNC_PATH);
                pDX->PrepareEditCtrl(IDS_BAD_UNC_PATH);
                pDX->Fail();
            }

            m_strRedirectPath.Empty();

        /*

            ISSUE: Don't need username/password?

            if (m_strUserName.IsEmpty())
            {
                ::AfxMessageBox(IDS_ERR_NO_USERNAME);

                if (!BrowseUser())
                {
                    pDX->Fail();
                }
            }
        */
        }
        else if (m_nPathType == RADIO_REDIRECT)
        {
            DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
            m_strRedirectPath.TrimLeft();
            DDV_MinMaxChars(pDX, m_strRedirectPath, 0, 2 * MAX_PATH);

            if (!IsRelURLPath(m_strRedirectPath) 
             && !IsWildcardedRedirectPath(m_strRedirectPath)
             && !IsURLName(m_strRedirectPath))
            {
                ::AfxMessageBox(IDS_BAD_URL_PATH);
                pDX->Fail();
            }
        }
        else // Local directory
        {
            ASSERT(m_nPathType == RADIO_DIRECTORY);
            m_strRedirectPath.Empty();

            DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
            m_strPath.TrimLeft();

            if (!IsMasterInstance())
            {
                DDV_MinMaxChars(pDX, m_strPath, 1, MAX_PATH);
            }
            else
            {
                if (m_strPath.IsEmpty())
                {
                    //
                    // No additional validation necc. on master
                    // instance.
                    //
                    return;
                }
            }

            if (    !PathIsValid(m_strPath) 
                ||  (PathIsRelative(m_strPath) && !IsDevicePath(m_strPath))
                )
            {
                ::AfxMessageBox(IDS_ERR_INVALID_PATH);
                pDX->PrepareEditCtrl(IDC_EDIT_PATH);
                pDX->Fail();
            }

            if (IsLocal())
            {
                if (!PathIsDirectory(m_strPath))
                {
                    ::AfxMessageBox(IDS_ERR_PATH_NOT_FOUND);
                    pDX->PrepareEditCtrl(IDC_EDIT_PATH);
                    pDX->Fail();
                }
            }
        }
    }
    else
    {
        DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
        DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
        DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);
	}
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3DirectoryPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3DirectoryPage)
    ON_BN_CLICKED(IDC_CHECK_AUTHOR, OnCheckAuthor)
    ON_BN_CLICKED(IDC_CHECK_READ, OnCheckRead)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnCheckWrite)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_REDIRECT, OnRadioRedirect)
    ON_BN_CLICKED(IDC_RADIO_UNC, OnRadioUnc)

    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_CONNECT_AS, OnButtonConnectAs)
    ON_BN_CLICKED(IDC_BUTTON_CREATE_REMOVE_APP, OnButtonCreateRemoveApp)
    ON_BN_CLICKED(IDC_BUTTON_UNLOAD_APP, OnButtonUnloadApp)
    ON_BN_CLICKED(IDC_APP_CONFIGURATION, OnButtonConfiguration)
    ON_CBN_SELCHANGE(IDC_COMBO_PERMISSIONS, OnSelchangeComboPermissions)
    ON_CBN_SELCHANGE(IDC_COMBO_PROCESS, OnSelchangeComboProcess)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PATH, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_REDIRECT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_APPLICATION, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
//    ON_BN_CLICKED(IDC_CHECK_SCRIPT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_CHILD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_EXACT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_PERMANENT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_INDEX, OnItemChanged)

END_MESSAGE_MAP()



void
CW3DirectoryPage::RefreshAppState()
/*++

Routine Description:

    Refresh app state parameters

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_pApplication != NULL);

    CError err(m_pApplication->RefreshAppState());

    if (err.Failed())
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;    

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Ignore this error, it really just means the path 
            // doesn't exist in the metabase, which is true for most
            // file and directory properties, and not an error
            // condition.
            //
            err.Reset();
        }
    }
    else
    {
        m_dwAppState = m_pApplication->QueryAppState();
    }

    if (err.Succeeded())
    {
        //
        // Get metabase information
        //
        m_strAppRoot = m_pApplication->m_strAppRoot;
        m_dwAppProtection = m_pApplication->m_dwProcessProtection;
        m_strAppFriendlyName = m_pApplication->m_strFriendlyName;
        m_fIsAppRoot = m_strMetaRoot.CompareNoCase(
            CMetabasePath::CleanMetaPath(m_strAppRoot)) == 0;
    }
    else
    {
        //
        // Display error information
        //
        err.MessageBoxFormat(IDS_ERR_APP, MB_OK, NO_HELP_CONTEXT);
    }
}



CString &
CW3DirectoryPage::FriendlyAppRoot(LPCTSTR lpAppRoot, CString & strFriendly)
/*++

Routine Description:

    Convert the metabase app root path to a friendly display name
    format.

Arguments:

    LPCTSTR lpAppRoot           : App root
    CString & strFriendly       : Output friendly app root format

Return Value:

    Reference to the output string

Notes:

    App root must have been cleaned from WAM format prior
    to calling this function (see first ASSERT below)

--*/
{
    if (lpAppRoot != NULL && *lpAppRoot != 0)
    {
        //
        // Make sure we cleaned up WAM format
        //
        ASSERT(*lpAppRoot != _T('/'));
        strFriendly.Empty();

        CInstanceProps prop(QueryAuthInfo(), lpAppRoot);
        HRESULT hr = prop.LoadData();

        if (SUCCEEDED(hr))
        {
            CString root, tail;
            strFriendly.Format(
                    m_strWebFmt, 
                    prop.GetDisplayText(root)
                    );
            CMetabasePath::GetRootPath(lpAppRoot, root, &tail);
            if (!tail.IsEmpty())
            {
                //
                // Add rest of dir path
                //
                strFriendly += _T("/");
                strFriendly += tail;
            }

            //
            // Now change forward slashes in the path to backward slashes
            //
            CvtPathToDosStyle(strFriendly);

            return strFriendly;
        }
    }    
    //
    // Bogus
    //    
    VERIFY(strFriendly.LoadString(IDS_APPROOT_UNKNOWN));

    return strFriendly;
}



int   
CW3DirectoryPage::SetComboSelectionFromAppState(DWORD dwAppState)
/*++

Routine Description:

    Set the protection combo box current selection from the 
    app state DWORD

Arguments:

    DWORD  dwAppState       : Application State

Return Value:

    Combo selection ID

--*/
{
    int nSel = -1;

    switch(dwAppState)
    {
    case CWamInterface::APP_INPROC:
        nSel = m_nSelInProc;
        break;

    case CWamInterface::APP_POOLEDPROC:
        ASSERT(m_pApplication->SupportsPooledProc());
        nSel = m_nSelPooledProc;
        break;

    case CWamInterface::APP_OUTOFPROC:
        nSel = m_nSelOutOfProc;
        break;

    default:
        ASSERT("Bogus app protection level");
    }

    ASSERT(nSel >= 0);
    m_combo_Process.SetCurSel(nSel);

    return nSel;
}



DWORD 
CW3DirectoryPage::GetAppStateFromComboSelection() const
/*++

Routine Description:

    Get the app state DWORD that coresponds to the current combo
    box list selection

Arguments:

    None

Return Value:

    App state DWORD or 0xffffffff;

--*/
{
    int nSel = m_combo_Process.GetCurSel();

    if (nSel == m_nSelOutOfProc)
    {
        return CWamInterface::APP_OUTOFPROC;
    }

    if (nSel == m_nSelPooledProc)
    {
        ASSERT(m_pApplication->SupportsPooledProc());
        return CWamInterface::APP_POOLEDPROC;
    }

    if (nSel == m_nSelInProc)
    {
        return CWamInterface::APP_INPROC;
    }

    ASSERT(FALSE && "Invalid application state");

    return 0xffffffff;
}
 


void
CW3DirectoryPage::SetApplicationState()
/*++

Routine Description:

    Set application control state

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // SetWindowText causes a dirty marker
    //
    BOOL fOld = m_fRecordChanges;
    m_fRecordChanges = FALSE;
    m_fParentEnabled = !m_strAppRoot.IsEmpty();
    m_fAppEnabled = FALSE;

    if (m_pApplication != NULL)
    {
        m_pApplication->RefreshAppState();
        m_fAppEnabled = m_fIsAppRoot && m_pApplication->IsEnabledApplication();
    }
	BOOL fVisible = (
		m_nPathType == RADIO_DIRECTORY || m_nPathType == RADIO_NETDIRECTORY);

    m_button_CreateRemove.EnableWindow(fVisible && !IsMasterInstance() && HasAdminAccess());
    m_button_CreateRemove.SetWindowText(m_fAppEnabled ? m_strRemove : m_strCreate);
    
    m_static_ProtectionPrompt.EnableWindow(fVisible && 
        m_fAppEnabled && !IsMasterInstance() && HasAdminAccess());

    //
    // Set selection in combo box to match current app state
    //
    if (m_fCompatibilityMode)
    {
        SetComboSelectionFromAppState(m_dwAppProtection);
    }

    m_combo_Process.EnableWindow(fVisible && 
        m_fAppEnabled && !IsMasterInstance() && HasAdminAccess());
    m_static_PermissionsPrompt.EnableWindow(fVisible && HasAdminAccess());
    m_combo_Permissions.EnableWindow(fVisible && HasAdminAccess());

    m_static_AppPrompt.EnableWindow(fVisible && m_fIsAppRoot && HasAdminAccess());
    m_edit_AppFriendlyName.EnableWindow(fVisible && m_fIsAppRoot && HasAdminAccess());
    m_button_Configuration.EnableWindow(fVisible && (m_fAppEnabled || IsMasterInstance()));

    //
    // Write out the verbose starting point.  
    //
    CString str;
   if (IsMasterInstance())
	{
		VERIFY(str.LoadString(IDS_WEB_MASTER));
	}
	else
	{
		FriendlyAppRoot(m_strAppRoot, str);
	}
   FitPathToControl(m_static_StartingPoint, str);

    m_edit_AppFriendlyName.SetWindowText(m_strAppFriendlyName);
    m_button_Unload.EnableWindow(fVisible && m_dwAppState == APPSTATUS_RUNNING);

    //
    // Restore (see note on top)
    //
    m_fRecordChanges = fOld;
}



void
CW3DirectoryPage::ChangeTypeTo(int nNewType)
/*++

Routine Description

    Change the directory type

Arguments:

    int nNewType    : New radio value

Return Value:

    None

--*/
{
    int nOldType = m_nPathType;
    m_nPathType = nNewType;

    if (nOldType == m_nPathType)
    {
        return;
    }

    OnItemChanged();
    SetStateByType();

    int nID = -1;
    CEdit * pPath = NULL;
    LPCTSTR lpKeepPath = NULL;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        if (!PathIsUNC(m_strPath) && (!PathIsRelative(m_strPath) || IsDevicePath(m_strPath)))
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath = m_strPath;
        }
        nID = IDS_DIRECTORY_MASK;
        pPath = &m_edit_Path;
        break;

    case RADIO_NETDIRECTORY:
        if (PathIsUNC(m_strPath))
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath = m_strPath;
        }
        nID = IDS_UNC_MASK;
        pPath = &m_edit_Path;
        break;

    case RADIO_REDIRECT:
        if (!m_strRedirectPath.IsEmpty())
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath =  m_strRedirectPath;
        }

        nID = IDS_REDIRECT_MASK;
        pPath = &m_edit_Redirect;
        break;

    default:
        ASSERT(FALSE);
        return;
    }

    //
    // Load mask resource, and display
    // this in the directory
    //
    if (pPath != NULL)
    {
        if (lpKeepPath != NULL)
        {
            pPath->SetWindowText(lpKeepPath);
        }
        else
        {
            CString str;
            VERIFY(str.LoadString(nID));
            pPath->SetWindowText(str);
        }
        pPath->SetSel(0,-1);
        pPath->SetFocus();
    }
}



void 
CW3DirectoryPage::ShowControl(CWnd * pWnd, BOOL fShow)
{
    ASSERT(pWnd != NULL);
	pWnd->EnableWindow(fShow);
	pWnd->ShowWindow(fShow ? SW_SHOW : SW_HIDE);
}



int
CW3DirectoryPage::AddStringToComboBox(CComboBox & combo, UINT nID)
{
    CString str;

    VERIFY(str.LoadString(nID));
    return combo.AddString(str);
}



void
CW3DirectoryPage::SetStateByType()
{
    BOOL fShowDirFlags;
    BOOL fShowLargeDirGroup;
    BOOL fShowRedirectFlags;
    BOOL fShowApp;
    BOOL fShowIndex;
    BOOL fShowDirBrowse;
    BOOL fShowDAV;
    BOOL fEnableChild;
    BOOL fEnableBrowse;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        ShowControl(&m_button_ConnectAs, FALSE);
        ShowControl(&m_button_Browse, TRUE);
        ShowControl(&m_edit_Path, TRUE);
        ShowControl(&m_edit_Redirect, FALSE);
        fShowDirFlags = TRUE;
        fShowLargeDirGroup = TRUE;
        fShowRedirectFlags = FALSE;
        fShowApp = TRUE;
        fShowIndex = TRUE;
        fShowDirBrowse = TRUE;
        fShowDAV = TRUE;
        fEnableChild = FALSE;
        fEnableBrowse = IsLocal() && !IsMasterInstance() && HasAdminAccess();
        break;

    case RADIO_NETDIRECTORY:
        ShowControl(&m_button_ConnectAs, TRUE);
        ShowControl(&m_button_Browse, FALSE);
        ShowControl(&m_edit_Path, TRUE);
        ShowControl(&m_edit_Redirect, FALSE);
        fShowDirFlags = TRUE;
        fShowLargeDirGroup = TRUE;
        fShowRedirectFlags = FALSE;
        fShowApp = TRUE;
        fShowIndex = TRUE;
        fShowDirBrowse = TRUE;
        fShowDAV = TRUE;
        fEnableChild = FALSE;
        fEnableBrowse = FALSE;
        break;

    case RADIO_REDIRECT:
        ShowControl(&m_button_ConnectAs, FALSE);
        ShowControl(&m_button_Browse, FALSE);
        ShowControl(&m_edit_Path, FALSE);
        ShowControl(&m_edit_Redirect, TRUE);
        fShowDirFlags = FALSE;
        fShowRedirectFlags = TRUE;
        fShowApp = FALSE;
        fShowDAV = FALSE;
        fShowIndex = FALSE;
        fShowDirBrowse = FALSE;
        fEnableChild = TRUE;
        fEnableBrowse = FALSE;
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
        return;
    }

    ShowControl(GetDlgItem(IDC_CHECK_READ), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_WRITE), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_LOG_ACCESS), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_INDEX), fShowDirFlags);
    ShowControl(GetDlgItem(IDC_CHECK_AUTHOR), fShowDirFlags);

    ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_LARGE),
        fShowDirFlags && fShowLargeDirGroup);
    ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_SMALL),
        fShowDirFlags && !fShowLargeDirGroup);

    ShowControl(IDC_CHECK_EXACT, fShowRedirectFlags);
    ShowControl(IDC_CHECK_CHILD, fShowRedirectFlags);
    ShowControl(IDC_CHECK_PERMANENT, fShowRedirectFlags);
    ShowControl(IDC_STATIC_REDIRECT_PROMPT, fShowRedirectFlags);
    ShowControl(IDC_STATIC_REDIRFLAGS, fShowRedirectFlags);

    ShowControl(IDC_STATIC_APPLICATIONS, fShowApp);
    ShowControl(IDC_STATIC_APP_PROMPT, fShowApp);
    ShowControl(IDC_EDIT_APPLICATION, fShowApp);
    ShowControl(IDC_STATIC_STARTING_POINT, fShowApp);
    ShowControl(IDC_STATIC_SP_PROMPT, fShowApp);
    ShowControl(IDC_COMBO_PROCESS, fShowApp);
    ShowControl(IDC_STATIC_PERMISSIONS, fShowApp);
    ShowControl(IDC_BUTTON_CREATE_REMOVE_APP, fShowApp);
    ShowControl(IDC_BUTTON_UNLOAD_APP, fShowApp);
    ShowControl(IDC_APP_CONFIGURATION, fShowApp);
    ShowControl(IDC_STATIC_APPLICATION_SETTINGS, fShowApp);
    ShowControl(IDC_COMBO_PERMISSIONS, fShowApp);
    ShowControl(IDC_STATIC_PROTECTION, fShowApp);

    ShowControl(&m_check_Author, fShowDAV);
    ShowControl(&m_check_DirBrowse, fShowDirBrowse);
    ShowControl(&m_check_Index, fShowIndex);

    //
    // Enable/Disable must come after the showcontrols
    //
    m_button_Browse.EnableWindow(fEnableBrowse);
    m_check_Child.EnableWindow(fEnableChild);
    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);

    SetApplicationState();
}



void
CW3DirectoryPage::SaveAuthoringState()
/*++

Routine Description:

    Save authoring state

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_check_Write.m_hWnd)
    {
        //
        // Controls initialized -- store live data
        //
        m_fOriginalWrite = m_check_Write.GetCheck() > 0;
        m_fOriginalRead = m_check_Read.GetCheck() > 0;
    }
    else
    {
        //
        // Controls not yet initialized, store original data
        //
        m_fOriginalWrite = m_fWrite;
        m_fOriginalRead = m_fRead;
    }
}



void
CW3DirectoryPage::RestoreAuthoringState()
/*++

Routine Description:

    Restore the authoring state

Arguments:

    None

Return Value:

    None

--*/
{
    m_fWrite = m_fOriginalWrite;
    m_fRead = m_fOriginalRead;
}



void 
CW3DirectoryPage::SetAuthoringState(
    BOOL fAlterReadAndWrite
    )
/*++

Routine Description:

    Set authoring state

Arguments:

    None

Return Value:

    None

--*/
{
    if (fAlterReadAndWrite)
    {
        if (m_fAuthor)
        {
            //
            // Remember previous setting to undo
            // this thing.
            //
            SaveAuthoringState();
            m_fRead = m_fWrite = TRUE;
        }
        else
        {
            //
            // Restore previous defaults
            //
            RestoreAuthoringState();
        }

        m_check_Read.SetCheck(m_fRead);
        m_check_Write.SetCheck(m_fWrite);
    }

    m_check_Author.EnableWindow(
        (m_fRead || m_fWrite) && 
        HasAdminAccess() &&
        HasDAV()
        );

//    m_check_Read.EnableWindow(!m_fAuthor && HasAdminAccess());
//    m_check_Write.EnableWindow(!m_fAuthor && HasAdminAccess());
}



void 
CW3DirectoryPage::SetPathType()
/*++

Routine Description:

    Set path type from given path

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_strRedirectPath.IsEmpty())
    {
        m_nPathType = RADIO_REDIRECT;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(0);
        m_radio_Redirect.SetCheck(1);
    }
    else
    {
        m_radio_Redirect.SetCheck(0);
        SetPathType(m_strPath);
    }

    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
}


void 
CW3DirectoryPage::SetPathType(LPCTSTR lpstrPath)
/*++

Routine Description:

    Set path type from given path

Arguments:

    LPCTSTR lpstrPath       : Path string

Return Value:

    None

--*/
{
    if (PathIsUNC(lpstrPath))
    {
        m_nPathType = RADIO_NETDIRECTORY;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(1);
    }
    else
    {
        m_nPathType = RADIO_DIRECTORY;
        m_radio_Unc.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }
}



BOOL
CW3DirectoryPage::BrowseUser()
/*++

Routine Description:

    Browse for username/password

Arguments:

    None

Return Value:

    TRUE if one was selected, FALSE otherwise.

--*/
{
    CUserAccountDlg dlg(
        QueryServerName(), 
        m_strUserName, 
        m_strPassword, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        m_strUserName = dlg.m_strUserName;
        m_strPassword = dlg.m_strPassword;
        OnItemChanged();

        return TRUE;
    }

    return FALSE;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3DirectoryPage::OnItemChanged()
/*++

Routine Description:

    Handle change in data on the item

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fRecordChanges)
    {
        SetModified(TRUE);
    }
}


static int CALLBACK 
FileChooserCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
   CW3DirectoryPage * pThis = (CW3DirectoryPage *)lpData;
   ASSERT(pThis != NULL);
   return pThis->BrowseForFolderCallback(hwnd, uMsg, lParam);
}

int 
CW3DirectoryPage::BrowseForFolderCallback(HWND hwnd, UINT uMsg, LPARAM lParam)
{
   switch (uMsg)
   {
   case BFFM_INITIALIZED:
      ASSERT(m_pPathTemp != NULL);
      if (::PathIsNetworkPath(m_pPathTemp))
         return 0;
      while (!::PathIsDirectory(m_pPathTemp))
      {
         if (0 == ::PathRemoveFileSpec(m_pPathTemp) && !::PathIsRoot(m_pPathTemp))
         {
            return 0;
         }
         DWORD attr = GetFileAttributes(m_pPathTemp);
         if ((attr & FILE_ATTRIBUTE_READONLY) == 0)
            break;
      }
      ::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)m_pPathTemp);
      break;
   case BFFM_SELCHANGED:
      {
         LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
         TCHAR path[MAX_PATH];
         if (SHGetPathFromIDList(pidl, path))
         {
            ::SendMessage(hwnd, BFFM_ENABLEOK, 0, !PathIsNetworkPath(path));
         }
      }
      break;
   case BFFM_VALIDATEFAILED:
      break;
   }
   return 0;
}


void 
CW3DirectoryPage::OnButtonBrowse() 
/*++

Routine Description:

    "Browse" button handler

Arguments:

    None

Return Value:

    None

--*/
{
   ASSERT(IsLocal());
   BOOL bRes = FALSE;
   HRESULT hr;
   CString str;
   m_edit_Path.GetWindowText(str);

   if (SUCCEEDED(hr = CoInitialize(NULL)))
   {
      LPITEMIDLIST  pidl = NULL;
      if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_DRIVES, NULL, 0, &pidl)))
      {
         LPITEMIDLIST pidList = NULL;
         BROWSEINFO bi;
         TCHAR buf[MAX_PATH];
         ZeroMemory(&bi, sizeof(bi));
         int drive = PathGetDriveNumber(str);
         if (GetDriveType(PathBuildRoot(buf, drive)) == DRIVE_FIXED)
         {
            StrCpy(buf, str);
         }
         else
         {
             buf[0] = 0;
         }
         m_strBrowseTitle.LoadString(IsHome() ? 
            IDS_TAB_HOME_DIRECTORY : IDS_TAB_VIRTUAL_DIRECTORY);
         
         bi.hwndOwner = m_hWnd;
         bi.pidlRoot = pidl;
         bi.pszDisplayName = m_pPathTemp = buf;
         bi.lpszTitle = m_strBrowseTitle;
         bi.ulFlags |= BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS/* | BIF_EDITBOX*/;
         bi.lpfn = FileChooserCallback;
         bi.lParam = (LPARAM)this;

         pidList = SHBrowseForFolder(&bi);
         if (  pidList != NULL
            && SHGetPathFromIDList(pidList, buf)
            )
         {
            str = buf;
            bRes = TRUE;
         }
         IMalloc * pMalloc;
         VERIFY(SUCCEEDED(SHGetMalloc(&pMalloc)));
         if (pidl != NULL)
            pMalloc->Free(pidl);
         pMalloc->Release();
      }
      CoUninitialize();
   }

   if (bRes)
   {
       m_edit_Path.SetWindowText(str);
	   m_strPath = str;
       SetPathType();
       OnItemChanged();
   }
}



BOOL 
CW3DirectoryPage::OnSetActive() 
/*++

Routine Description:

    Page has become active.  Dismiss if we're in an inconsistent state

Arguments:

    None

Return Value:

    TRUE to proceed, FALSE to dismiss.

--*/
{
    if (m_pApplication == NULL)
    {
        return FALSE;
    }

    return CInetPropertyPage::OnSetActive();
}



BOOL 
CW3DirectoryPage::OnInitDialog() 
{
    CInetPropertyPage::OnInitDialog();

    m_fCompatibilityMode = ((CW3Sheet *)GetSheet())->InCompatibilityMode();

    CString str;
    VERIFY(str.LoadString(IDS_RADIO_VDIR));
    m_radio_Dir.SetWindowText(str);

    //
    // Fill permissions combo box.
    //
    AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_NONE);
    AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_SCRIPT);
    AddStringToComboBox(m_combo_Permissions, IDS_PERMISSIONS_EXECUTE);
    m_combo_Permissions.SetCurSel(m_nPermissions);

    if (m_fCompatibilityMode)
    {
        m_nSelInProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_INPROC);
        if (m_pApplication->SupportsPooledProc())
        {
            m_nSelPooledProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_POOLEDPROC); 
        }
        else
        {
            m_nSelPooledProc = -1; // N/A
        }
        m_nSelOutOfProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_OUTPROC);
    }
    else
    {
       CString buf;
       buf.LoadString(IDS_APPLICATION_POOL);
       m_static_ProtectionPrompt.SetWindowText(buf);

	   CMapStringToString pools;
	   CError err = ((CW3Sheet *)GetSheet())->EnumAppPools(pools);
	   int idx_sel = CB_ERR;
       int idx_def = CB_ERR;
	   err = ((CW3Sheet *)GetSheet())->QueryDefaultPoolId(buf);
	   if (err.Succeeded())
       {
	      ASSERT(pools.GetCount() > 0);
		  POSITION pos = pools.GetStartPosition();
		  CString pool_id, pool_name;
		  while (pos != NULL)
          {
		     pools.GetNextAssoc(pos, pool_name, pool_id);
			 int idx = m_combo_Process.AddString(pool_name);
			 m_combo_Process.SetItemDataPtr(idx, StrDup(pool_id));
			 if (0 == m_pApplication->m_strAppPoolId.CompareNoCase(pool_id))
             {
			    idx_sel = idx;
             }
             if (0 == buf.CompareNoCase(pool_id))
             {
                 idx_def = idx;
             }
          }
       }
	   // select the app pool which has an id the same as in current application
       // It could be new app created in compatibility mode, no app pool is default app pool
       if (CB_ERR == idx_sel)
       {
           idx_sel = idx_def;
       }
	   m_combo_Process.SetCurSel(idx_sel);
    }
    //
    // Selection will be set later...
    //
    SetPathType();
    SetStateByType();
    SetAuthoringState(FALSE);

    TRACEEOLID(m_strMetaRoot);

    //
    // Some items not available on master instance, or if no admin
    // access exists
    //
    BOOL fOkToDIR = TRUE;
    BOOL fOkToUNC = TRUE;

    if (!HasAdminAccess())
    {
        //
        // If not an admin, operator cannot change
        // the path, he can only cancel a redirect 
        // by going back to the path it had before.
        // 
        fOkToDIR = !PathIsRelative(m_strPath) || IsDevicePath(m_strPath);
        fOkToUNC = PathIsUNC(m_strPath);
    }

    GetDlgItem(IDC_STATIC_PATH_TYPE)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_RADIO_DIR)->EnableWindow(!IsMasterInstance() && fOkToDIR);
    GetDlgItem(IDC_RADIO_UNC)->EnableWindow(!IsMasterInstance() && fOkToUNC);
    GetDlgItem(IDC_RADIO_REDIRECT)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_STATIC_PATH_PROMPT)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_EDIT_PATH)->EnableWindow(!IsMasterInstance() && HasAdminAccess());
//    GetDlgItem(IDC_BUTTON_EDIT_PATH_TYPE)->EnableWindow(!IsMasterInstance());

    //SetApplicationState();
    m_fOriginallyUNC = (m_nPathType == RADIO_NETDIRECTORY);
    //
    // All changes from here on out need to be reflected.
    //
    m_fRecordChanges = TRUE;

    return TRUE;  
}


void
CW3DirectoryPage::OnDestroy()
{
    int count = m_combo_Process.GetCount();
    if (count != CB_ERR)
    {
        for (int i = 0; i < count; i++)
        {
            void * p = m_combo_Process.GetItemDataPtr(i);
            LocalFree(p);
            m_combo_Process.SetItemDataPtr(i, NULL);
        }
    }
}


/* virtual */
HRESULT
CW3DirectoryPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    m_strMetaRoot = QueryMetaPath();

    BEGIN_META_DIR_READ(CW3Sheet)
        //
        // Use m_ notation because the message crackers require it
        //
        BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strAlias);
        FETCH_DIR_DATA_FROM_SHEET(m_strUserName);
        FETCH_DIR_DATA_FROM_SHEET(m_strPassword);
        FETCH_DIR_DATA_FROM_SHEET(m_strPath);
        FETCH_DIR_DATA_FROM_SHEET(m_strRedirectPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_dwDirBrowsing);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);
        FETCH_DIR_DATA_FROM_SHEET(m_fIndexed);
        FETCH_DIR_DATA_FROM_SHEET(m_fExact);
        FETCH_DIR_DATA_FROM_SHEET(m_fChild);
        FETCH_DIR_DATA_FROM_SHEET(m_fPermanent);

        m_fBrowsingAllowed = IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_ENABLED);
        m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
        m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
        m_fAuthor = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SOURCE);
        m_fLogAccess = !m_fDontLog;

        SaveAuthoringState();

        if (!m_fIsAppRoot)
        {
            m_dwAppState = APPSTATUS_NOTDEFINED;
        }

    END_META_DIR_READ(err)

    m_nPermissions = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_EXECUTE)
        ? COMBO_EXECUTE : IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SCRIPT)
            ? COMBO_SCRIPT : COMBO_NONE;

    //
    // Make sure we were passed the right home directory
    // flag
    //
    ASSERT(IsMasterInstance() 
         || (m_fHome && !::lstrcmp(m_strAlias, g_cszRoot))
         || (!m_fHome && ::lstrcmp(m_strAlias, g_cszRoot))
         );

    TRACEEOLID(QueryMetaPath());

    BeginWaitCursor();
    m_pApplication = new CIISApplication(QueryAuthInfo(), QueryMetaPath());
    err = m_pApplication != NULL
        ? m_pApplication->QueryResult() : ERROR_NOT_ENOUGH_MEMORY;

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // No app information; that's ok in cases of file system directories
        // that don't exist in the metabase yet.
        //
        err.Reset();
    }
    EndWaitCursor();

    if (err.Succeeded())
    {
        //
        // CODEWORK: RefreshAppState should be split up into two
        // different methods: one that fetches the data, and one
        // that moves the data to the UI controls on this page.
        //
        RefreshAppState();
    }
    
    return err;
}



/* virtual */
HRESULT
CW3DirectoryPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 virtual directory page now...");

    CError err;

    SET_FLAG_IF(m_fBrowsingAllowed, m_dwDirBrowsing, MD_DIRBROW_ENABLED);
    SET_FLAG_IF(m_fRead, m_dwAccessPerms,   MD_ACCESS_READ);
    SET_FLAG_IF(m_fWrite, m_dwAccessPerms,  MD_ACCESS_WRITE);
    SET_FLAG_IF(m_fAuthor, m_dwAccessPerms, MD_ACCESS_SOURCE);
    SET_FLAG_IF((m_nPermissions == COMBO_EXECUTE), m_dwAccessPerms, MD_ACCESS_EXECUTE);
    //
    // script is set on EXECUTE as well "Execute (including script)"
    //
    SET_FLAG_IF(((m_nPermissions == COMBO_SCRIPT) || (m_nPermissions == COMBO_EXECUTE)), 
        m_dwAccessPerms, MD_ACCESS_SCRIPT);
    BOOL m_fDontLog = !m_fLogAccess;
    BOOL fUNC = (m_nPathType == RADIO_NETDIRECTORY);

    if (m_fCompatibilityMode)
    {
        DWORD dwAppProtection = GetAppStateFromComboSelection();
        if (dwAppProtection != m_dwAppProtection && m_fAppEnabled)
        {
            //
            // Isolation state has changed; recreate the application
            //
            CError err2(m_pApplication->RefreshAppState());
            if (err2.Succeeded())
            {
                err2 = m_pApplication->Create(m_strAppFriendlyName, dwAppProtection);
                //
                // Remember the new state, so we don't do this again
                // the next time the guy hits "apply"
                //
                if (err2.Succeeded())
                {
                    m_dwAppProtection = dwAppProtection;
                }
            }

            err2.MessageBoxOnFailure();
        }
    }

    BOOL fUserNameWritten = FALSE;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        INIT_DIR_DATA_MASK(m_dwAccessPerms, m_dwBitRangePermissions)
        INIT_DIR_DATA_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)

        if (fUNC)      
        {
            STORE_DIR_DATA_ON_SHEET(m_strUserName);
            STORE_DIR_DATA_ON_SHEET(m_strPassword);
        }
        else
        {
            if (m_fOriginallyUNC)
            {
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_USERNAME)
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_PASSWORD)
            }
        }
        STORE_DIR_DATA_ON_SHEET(m_strPath)
        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_fIndexed)
        STORE_DIR_DATA_ON_SHEET(m_fChild);
        STORE_DIR_DATA_ON_SHEET(m_fExact);
        STORE_DIR_DATA_ON_SHEET(m_fPermanent);
        //
        // CODEWORK: Not an elegant solution
        //
        if (m_nPathType == RADIO_REDIRECT)
        {
            pSheet->GetDirectoryProperties().MarkRedirAsInherit(!m_fChild);
            STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
        }
        else
        {
            CString buf = m_strRedirectPath;
            m_strRedirectPath.Empty();
            STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
            m_strRedirectPath = buf;
        }
        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
        STORE_DIR_DATA_ON_SHEET(m_dwDirBrowsing)
    END_META_DIR_WRITE(err)

    if (err.Succeeded() && m_pApplication->IsEnabledApplication())
    {
        err = m_pApplication->WriteFriendlyName(m_strAppFriendlyName);
        if (!m_fCompatibilityMode)
        {
            // get app pool id from the combo, 
            // check if it was changed and reassign to application
            CString id;
            int idx = m_combo_Process.GetCurSel();
            ASSERT(idx != CB_ERR);
            id = (LPCTSTR)m_combo_Process.GetItemDataPtr(idx);
            m_pApplication->WritePoolId(id);
        }
    }

    if (err.Succeeded())
    {
        //
        // Save Defaults
        //
        SaveAuthoringState();
		err = ((CW3Sheet *)GetSheet())->SetKeyType();
        NotifyMMC();
    }

    EndWaitCursor();

    return err;
}



BOOL
CW3DirectoryPage::CheckWriteAndExecWarning()
{
    if (m_nPermissions == COMBO_EXECUTE && m_fWrite)
    {
        if (::AfxMessageBox(IDS_WRN_WRITE_EXEC, MB_YESNO | MB_DEFBUTTON2 ) != IDYES)
        {
            return FALSE;
        }
    }

    OnItemChanged();

    return TRUE;
}



void
CW3DirectoryPage::OnCheckRead() 
{
    m_fRead = !m_fRead;
    SetAuthoringState(FALSE);
    OnItemChanged();
}



void
CW3DirectoryPage::OnCheckWrite() 
{
    m_fWrite = !m_fWrite;

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo
        //
        m_fWrite = FALSE;
        m_check_Write.SetCheck(m_fWrite);
    }
    else
    {
        SetAuthoringState(FALSE);
        OnItemChanged();
    }
}



void 
CW3DirectoryPage::OnCheckAuthor() 
{
    m_fAuthor = !m_fAuthor;
    SetAuthoringState(FALSE);

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo -- set script instead
        //
        m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
    }

    OnItemChanged();
}



void 
CW3DirectoryPage::OnSelchangeComboPermissions() 
{
    m_nPermissions = m_combo_Permissions.GetCurSel();
    ASSERT(m_nPermissions >= COMBO_NONE && m_nPermissions <= COMBO_EXECUTE);

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo -- set script instead
        //
        m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
    }

    OnItemChanged();
}



void 
CW3DirectoryPage::OnButtonConnectAs() 
{
    BrowseUser();
}



void 
CW3DirectoryPage::OnRadioDir() 
{
    ChangeTypeTo(RADIO_DIRECTORY);
}



void 
CW3DirectoryPage::OnRadioUnc() 
{
    ChangeTypeTo(RADIO_NETDIRECTORY);
}

void 
CW3DirectoryPage::OnRadioRedirect() 
{
    ChangeTypeTo(RADIO_REDIRECT);
}

void 
CW3DirectoryPage::OnButtonCreateRemoveApp() 
{
    BeginWaitCursor();

    CError err(m_pApplication->RefreshAppState());

    if (m_fAppEnabled)
    {
        //
        // App currently exists -- delete it
        //
        err = m_pApplication->Delete();
    }    
    else
    {
        //
        // Create new app in-proc
        //
        CString strAppName;

        if (m_fHome)
        {
            //
            // Use default name for application name
            //
            VERIFY(strAppName.LoadString(IDS_DEF_APP));
        }
        else
        {
            //
            // Use name of the virtual directory for the
            // application name
            //
            strAppName = m_strAlias;
        }

        //
        // Attempt to create a pooled-proc by default;  failing
        // that if it's not supported, create it in proc
        //
        DWORD dwAppProtState = 
            m_pApplication->SupportsPooledProc() ? 
                CWamInterface::APP_POOLEDPROC : CWamInterface::APP_INPROC;
        err = m_pApplication->Create(strAppName, dwAppProtState);
    }

    if (err.Succeeded())
    {
        RefreshAppState();
        NotifyMMC();  
    }

    //
    // Move app data to the controls
    //
    UpdateData(FALSE);

    EndWaitCursor();    

    err.MessageBoxOnFailure();    
    SetApplicationState();
}



void 
CW3DirectoryPage::OnButtonUnloadApp() 
{
    ASSERT(m_dwAppState == APPSTATUS_RUNNING);

    BeginWaitCursor();
    CError err(m_pApplication->RefreshAppState());

    if (err.Succeeded())
    {
        if (m_dwAppProtection == CWamInterface::APP_POOLEDPROC)
        {
            //
            // Warn that everything in its process will get unloaded
            //
            if (!NoYesMessageBox(IDS_WRN_UNLOAD_POOP))
            {
                //
                // Chickened out
                //
                return;
            }
        }

        err = m_pApplication->Unload();
    }

    err.MessageBoxOnFailure();
    RefreshAppState();
    EndWaitCursor();    

    //
    // Ensure that an enabled button will have focus.
    //
    m_button_CreateRemove.SetFocus();

    SetApplicationState();
}

#include "..\AppConfig\AppConfig.h"
extern CInetmgrApp theApp;
void 
CW3DirectoryPage::OnButtonConfiguration() 
{
   IIISAppConfig * pAppConfig = NULL;
   CLSID clsID;
   HRESULT hr;

   if (  SUCCEEDED(hr = CLSIDFromProgID(OLESTR("AppConfig.IISAppConfig"), &clsID))
      && SUCCEEDED(hr = ::CoCreateInstance(clsID, NULL, CLSCTX_ALL, 
            __uuidof(IIISAppConfig), (void **)&pAppConfig)))
   {
	  CComAuthInfo * pAuth = QueryAuthInfo();
	  ASSERT(pAuth != NULL);
      pAppConfig->put_ComputerName(pAuth->QueryServerName());
      pAppConfig->put_MetaPath((LPTSTR)QueryMetaPath());
      pAppConfig->put_HelpPath((LPTSTR)theApp.m_pszHelpFilePath);
      pAppConfig->put_UserName(pAuth->QueryUserName());
      pAppConfig->put_UserPassword(pAuth->QueryPassword());
      DWORD version = MAKELONG(
          GetSheet()->QueryMajorVersion(),
          GetSheet()->QueryMinorVersion());
      pAppConfig->put_ServiceVersion(version);
      BOOL mode = ((CW3Sheet *)GetSheet())->InCompatibilityMode();
      pAppConfig->put_ServiceCompatMode(mode);
      pAppConfig->Run();
      pAppConfig->Release();
   }
}

void 
CW3DirectoryPage::OnSelchangeComboProcess() 
{
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\ssltools\backup.cpp ===
#include "stdafx.h"

#ifndef _CHICAGO_

// this file is always compile UNICODE in the library - so the conversions work out right

//
//Local includes
//
#include "certupgr.h"

#define		BACKUP_ID	'KRBK'

//------------------------------------------------------------------------------
void ReadWriteDWORD( HANDLE hFile, DWORD *pDword, BOOL fRead );
void ReadWriteString( HANDLE hFile, LPTSTR* ppsz, BOOL fRead );
void ReadWriteBlob( HANDLE hFile, PVOID pBlob, DWORD cbBlob, BOOL fRead );

//-------------------------------------------------------------------------
PCCERT_CONTEXT ImportKRBackupToCAPIStore_A(
                        PCHAR pszFileName,          // path of the file
                        PCHAR pszPassword,          // ANSI password
                        PCHAR pszCAPIStore )        // name of the capi store
    {
    PCCERT_CONTEXT  pCert = NULL;

    // prep the wide strings
    PWCHAR  pszwFileName = NULL;
    PWCHAR  pszwCAPIStore = NULL;
    DWORD   lenFile = (strlen(pszFileName)+1) * sizeof(TCHAR);
    DWORD   lenStore = (strlen(pszCAPIStore)+1) * sizeof(TCHAR);
    pszwFileName = (PWCHAR)GlobalAlloc( GPTR, lenFile );
    pszwCAPIStore = (PWCHAR)GlobalAlloc( GPTR, lenStore );
    if ( !pszwFileName || !pszwCAPIStore )
        goto cleanup;

    // convert the strings
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszFileName, -1, pszwFileName, lenFile );
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszCAPIStore, -1, pszwCAPIStore, lenStore );

    // do the real call
    pCert = ImportKRBackupToCAPIStore_W( pszwFileName, pszPassword, pszwCAPIStore );
    
cleanup:
    // preserve the last error state
    DWORD   err = GetLastError();

    // clean up the strings
    if ( pszwFileName )
        GlobalFree( pszwFileName );
    if ( pszwCAPIStore )
        GlobalFree( pszwCAPIStore );

    // reset the last error state
    SetLastError( err );

    // return the cert
    return pCert;
    }

//-------------------------------------------------------------------------
// Import old-style keyring backup file
PCCERT_CONTEXT ImportKRBackupToCAPIStore_W(
                            PWCHAR ptszFileName,        // path of the file
                            PCHAR pszPassword,          // ANSI password
                            PWCHAR pszCAPIStore )       // name of the capi store
    {
    PCCERT_CONTEXT  pCertContext = NULL;
	DWORD	        dword;
    LPTSTR          psz = NULL;

    // prep the file name
    HANDLE          hFile = NULL;

    // This code is originally from KeyRing. The fImport controlled whether it was reading
    // or writing the file. In this case, we are always and only reading it. so....
    const BOOL    fImport = TRUE;

    // also, this was a method on a class. The appropriate member variables are now here
    PVOID   pPrivateKey = NULL;
    DWORD   cbPrivateKey;
    PVOID   pCertificate = NULL;
    DWORD   cbCertificate;
    PVOID   pRequest = NULL;
    DWORD   cbRequest = 0;
	CString	szName;

    // open the file
    hFile = CreateFile(
            ptszFileName,               // pointer to name of the file  
            GENERIC_READ,               // access (read-write) mode  
            FILE_SHARE_READ,            // share mode  
            NULL,                       // pointer to security attributes  
            OPEN_EXISTING,              // how to create  
            FILE_ATTRIBUTE_NORMAL,      // file attributes  
            NULL                        // handle to file with attributes to copy  
            );
    if ( hFile == INVALID_HANDLE_VALUE )
        return NULL;

	// do the backup id
	dword = BACKUP_ID;
	ReadWriteDWORD( hFile, &dword, fImport );

	// check the backup id
	if ( dword != BACKUP_ID )
		{
        goto cleanup;
		}

	// start with the name of the key
	ReadWriteString( hFile, &psz, fImport );

    // we aren't using the name for now, so throw it away.....
    if ( psz )
        GlobalFree( psz );
    psz = NULL;

	// now the private key data size
	ReadWriteDWORD( hFile, &cbPrivateKey, fImport );

	// make a private key data pointer if necessary
	if ( fImport && cbPrivateKey )
		{
		pPrivateKey = GlobalAlloc( GPTR, cbPrivateKey );
		if ( !pPrivateKey )
            {
            goto cleanup;
            }
		}
	
	// use the private key pointer
	if ( cbPrivateKey )
		ReadWriteBlob( hFile, pPrivateKey, cbPrivateKey, fImport );


	// now the certificate
	ReadWriteDWORD( hFile, &cbCertificate, fImport );

	// make a data pointer if necessary
	if ( fImport && cbCertificate )
		{
		pCertificate = GlobalAlloc( GPTR, cbCertificate );
		if ( !pCertificate )
            {
            goto cleanup;
            }
		}
	
	// use the public key pointer
	if ( cbCertificate )
		ReadWriteBlob( hFile, pCertificate, cbCertificate, fImport );


	// now the request - if there is one
	ReadWriteDWORD( hFile, &cbRequest, fImport );

	// make a data pointer if necessary
	if ( fImport && cbRequest )
		{
		pRequest = GlobalAlloc( GPTR, cbRequest );
		if ( !pRequest )
            {
            goto cleanup;
            }
		}
	
	// use the request pointer
	if ( cbRequest )
		ReadWriteBlob( hFile, pRequest, cbRequest, fImport );


    // finally, do the CAPI conversion here
    pCertContext = CopyKRCertToCAPIStore(
                        pPrivateKey, cbPrivateKey,
                        pCertificate, cbCertificate,
                        pRequest, cbRequest,
                        pszPassword,
                        pszCAPIStore);

    // clean up
cleanup:
    if ( hFile )
        CloseHandle( hFile );
    if ( pPrivateKey )
        GlobalFree( pPrivateKey );
    if ( pCertificate )
        GlobalFree( pCertificate );
    if ( pRequest )
        GlobalFree( pRequest );

    // return the context
    return pCertContext;
    }




// file utilities
//---------------------------------------------------------------------------
void ReadWriteDWORD( HANDLE hFile, DWORD *pDword, BOOL fRead )
	{
	// read it or write it
    ReadWriteBlob( hFile, pDword, sizeof(DWORD), fRead );
	}

//---------------------------------------------------------------------------
// remember - we are only and always reading - never writing.......
void ReadWriteString( HANDLE hFile, LPTSTR* ppsz, BOOL fRead )
	{
	// get the length of the string
	DWORD	cbLength = 0;
	ReadWriteDWORD(hFile,&cbLength,fRead );

    // allocate the buffer for the new string - it is the responsibility
    // of the caller to ensure that ppsz is not pointing to something that
    // needs to be freed.
    if ( fRead )
        {
        *ppsz = (LPTSTR)GlobalAlloc( GPTR, cbLength+1 );
        ASSERT( *ppsz );
        if ( !*ppsz )
            AfxThrowMemoryException();
        }

	// read or write the string
	ReadWriteBlob(hFile, *ppsz, cbLength+1, fRead);
	}

/* #pragma INTRINSA suppress=all */

//---------------------------------------------------------------------------
void ReadWriteBlob( HANDLE hFile, PVOID pBlob, DWORD cbBlob, BOOL fRead )
	{
	// read it or write it 
    // - always read it here this isn't keyring anymore
    ReadFile(
            hFile,              // handle of file to read
            pBlob,              // address of buffer that receives data
            cbBlob,             // number of bytes to read
            &cbBlob,            // address of number of bytes read
            NULL                // address of structure for data
            ); 
	}





#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\ssltools\certupgr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    certupgr.cxx

Abstract:

    Functions used in upgrading server certs from K2 [server cert in metabase] to
    Avalanche [server cert in CAPI store].

Author:

    Alex Mallet (amallet)    07-Dec-1997
    Boyd Multerer (boydm)    20-Jan-1998        Converted to be useful in setup

--*/

#include "stdafx.h"
#include <objbase.h>

#ifndef _CHICAGO_


#include "oidenc.h"


// keyring include
//#include "intrlkey.h"
// This stuff below is moved from above include
#define REQUEST_HEADER_K2B2VERSION  0x0101

#define REQUEST_HEADER_IDENTIFIER	'RHDR'
#define REQUEST_HEADER_CURVERSION	0x0101



typedef struct _KeyRequestHeader
	{
	DWORD	Identifier;				// must be 'RHDR'
	DWORD	Version;				// version of header record
	DWORD	cbSizeOfHeader;			// byte count of header. Afterwards is the request.
	DWORD	cbRequestSize;			// size of the request that follows
	BOOL	fReqSentToOnlineCA;
    LONG    longRequestID;
	BOOL	fWaitingForApproval;
	char	chCA[MAX_PATH];
	} KeyRequestHeader, *LPREQUEST_HEADER;
///--- end of #include "intrlkey.h"

//
//Local includes
//
#include "certupgr.h"
//#include "certtools.h"


// The below define is in some interal schannel header file. John Banes
// told me to just redefine it below as such........ - Boyd
LPCSTR SGC_KEY_SALT  =  "SGCKEYSALT";


// prototypes
BOOL DecodeAndImportPrivateKey( PBYTE pbEncodedPrivateKey IN,
                                DWORD cbEncodedPrivateKey IN,
                                PCHAR pszPassword IN,
                                PWCHAR pszKeyContainerIN,
                                CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo );
BOOL UpdateCSPInfo( PCCERT_CONTEXT pcCertContext );


BOOL FImportAndStoreRequest( PCCERT_CONTEXT pCert, PVOID pbPKCS10req, DWORD cbPKCS10req );

//-------------------------------------------------------------------------
PCCERT_CONTEXT CopyKRCertToCAPIStore_A( PVOID pbPrivateKey, DWORD cbPrivateKey,
                            PVOID pbPublicKey, DWORD cbPublicKey,
                            PVOID pbPKCS10req, DWORD cbPKCS10req,
                            PCHAR pszPassword,
                            PCHAR pszCAPIStore)
    {
    PCCERT_CONTEXT  pCert = NULL;

    // prep the wide strings
    PWCHAR  pszwCAPIStore = NULL;
    DWORD   lenStore = (strlen(pszCAPIStore)+1) * sizeof(WCHAR);
    pszwCAPIStore = (PWCHAR)GlobalAlloc( GPTR, lenStore );
    if ( !pszwCAPIStore )
        goto cleanup;

    // convert the strings
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszCAPIStore, -1, pszwCAPIStore, lenStore );

    // do the real call
    pCert = CopyKRCertToCAPIStore_W(
                            pbPrivateKey, cbPrivateKey,
                            pbPublicKey, cbPublicKey,
                            pbPKCS10req, cbPKCS10req,
                            pszPassword,
                            pszwCAPIStore );

cleanup:
    // preserve the last error state
    DWORD   err = GetLastError();

    // clean up the strings
    if ( pszwCAPIStore )
        GlobalFree( pszwCAPIStore );

    // reset the last error state
    SetLastError( err );

    // return the cert
    return pCert;
    }

//--------------------------------------------------------------------------------------------
// Copies an old Key-Ring style cert to the CAPI store. This cert comes in as two binaries and a password.
PCCERT_CONTEXT CopyKRCertToCAPIStore_W( PVOID pbPrivateKey, DWORD cbPrivateKey,
                            PVOID pbPublicKey, DWORD cbPublicKey,
                            PVOID pbPKCS10req, DWORD cbPKCS10req,
                            PCHAR pszPassword,
                            PWCHAR pszCAPIStore)
/*++

Routine Description:

    Upgrades K2 server certs to Avalanche server certs - reads server cert out of K2
    metabase, creates cert context and stores it in CAPI2 "MY" store and writes
    relevant information back to metabase.

Arguments:

    pMDObject - pointer to Metabase object 
    pszOldMBPath - path to where server cert is stored in old MB, relative to SSL_W3_KEYS_MD_PATH
    pszNewMBPath - fully qualified path to where server cert info should be stored in new MB

Returns:

    BOOL indicating success/failure

--*/
    {
    BOOL        fSuccess = FALSE;

    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pcCertContext = NULL;
    LPOLESTR    polestr = NULL;


    // start by opening the CAPI store that we will be saving the certificate into
    hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                pszCAPIStore );
    if ( !hStore )
        {
//        iisDebugOut((_T("Error 0x%x calling CertOpenStore \n"), GetLastError());
        goto EndUpgradeServerCert;
        }


    // at this point we check to see if a certificate was passed in. If none was, then we need
    // to create a dummy-temporary certificate that markes the private key as incomplete. That
    // way, then the real certificate comes back from verisign the regular tools can be used
    // to complete the key.
    //CertCreateSelfSignCertificate()


    //
    //Create cert context to be stored in CAPI store
    //
    pbPublicKey = (PVOID)((PBYTE)pbPublicKey + CERT_DER_PREFIX);
    cbPublicKey -= CERT_DER_PREFIX;
    pcCertContext = CertCreateCertificateContext( X509_ASN_ENCODING, (PUCHAR)pbPublicKey, cbPublicKey);
    if ( pcCertContext )
        {

        // the private key gets stored in a seperate location from the certificate and gets referred to
        // by the certificate. We should try to pick a unique name so that some other cert won't step
        // on it by accident. There is no formal format for this name whatsoever. Some groups use a
        // human-readable string, some use a hash of the cert, and some use a GUID string. All are valid
        // although for generated certs the hash or the GUID are probably better.

        // get the 128 big md5 hash of the cert for the name
        DWORD dwHashSize;
        BOOL    fHash;

        BYTE MD5Hash[16];                // give it some extra size
        dwHashSize = sizeof(MD5Hash);
        fHash = CertGetCertificateContextProperty( pcCertContext,
                            CERT_MD5_HASH_PROP_ID,
                            (VOID *) MD5Hash,
                            &dwHashSize );

        // Since the MD5 hash is the same size as a guid, we can use the guid utilities to make a
        // nice string out of it.
        HRESULT     hresult;
        hresult = StringFromCLSID( (REFCLSID)MD5Hash, &polestr );

        //
        // Now decode private key blob and import it into CAPI1 private key
        //
        CRYPT_KEY_PROV_INFO CryptKeyProvInfo;

        if ( DecodeAndImportPrivateKey( (PUCHAR)pbPrivateKey, cbPrivateKey, pszPassword,
                                        polestr, &CryptKeyProvInfo ) )
            {
            //
            // Add the private key to the cert context
            //
            BOOL    f;
            f = CertSetCertificateContextProperty( pcCertContext, CERT_KEY_PROV_INFO_PROP_ID, 
                                                    0, &CryptKeyProvInfo );
            f = UpdateCSPInfo( pcCertContext );
            if ( f )
                {
                //
                // Store it in the provided store
                //
                if ( CertAddCertificateContextToStore( hStore, pcCertContext,
                                                       CERT_STORE_ADD_REPLACE_EXISTING, NULL ) )
                    {
                    fSuccess = TRUE;

                    // Write out the original request as a property on the cert
                    FImportAndStoreRequest( pcCertContext, pbPKCS10req, cbPKCS10req );
                    }
                else
                    {
//                    iisDebugOut((_T("Error 0x%x calling CertAddCertificateContextToStore"), GetLastError());
                    }
                }
            else
                {
//                iisDebugOut((_T("Error 0x%x calling CertSetCertificateContextProperty"), GetLastError());
                }
            }
        }
    else
        {
//        iisDebugOut((_T("Error 0x%x calling CertCreateCertificateContext"), GetLastError());
        }

    //
    //Cleanup that's done only on failure
    //
    if ( !fSuccess )
        {
        if ( pcCertContext )
            {
            CertFreeCertificateContext( pcCertContext );
            }
        pcCertContext = NULL;
        }

EndUpgradeServerCert:
    // cleanup
    if ( hStore )
        CertCloseStore ( hStore, 0 );

    if ( polestr )
        CoTaskMemFree( polestr );


    // return the answer
    return pcCertContext;
    }


//--------------------------------------------------------------------------------------------
BOOL UpdateCSPInfo( PCCERT_CONTEXT pcCertContext )
    {
    BYTE                    cbData[1000];
    CRYPT_KEY_PROV_INFO*    pProvInfo = (CRYPT_KEY_PROV_INFO *) cbData;
    DWORD                   dwFoo = 1000;
    BOOL                    fSuccess = TRUE;

    if ( ! CertGetCertificateContextProperty( pcCertContext,
                                              CERT_KEY_PROV_INFO_PROP_ID,
                                              pProvInfo,
                                              &dwFoo ) )
        {
        fSuccess = FALSE;
//        iisDebugOut((_T("Fudge. failed to get property : 0x%x"), GetLastError());
        }
    else
        {
        pProvInfo->dwProvType = PROV_RSA_SCHANNEL;
        pProvInfo->pwszProvName = NULL;
        if ( !CertSetCertificateContextProperty( pcCertContext,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 0,
                                                 pProvInfo ) )
            {
            fSuccess = FALSE;
//            iisDebugOut((_T("Fudge. failed to set property : 0x%x"), GetLastError());
            }
        }

    // return success
    return fSuccess;
    }

//--------------------------------------------------------------------------------------------
BOOL DecodeAndImportPrivateKey( PBYTE pbEncodedPrivateKey IN,
                                DWORD cbEncodedPrivateKey IN,
                                PCHAR pszPassword IN,
                                PWCHAR pszKeyContainer IN,
                                CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo )
    
/*++

Routine Description:

    Converts the private key stored in the metabase, in Schannel-internal format,
    into a key that can be imported via CryptImportKey() to create a CAP1 key blob.

Arguments:

    pbEncodedPrivateKey - pointer to [encoded] private key
    cbEncodedPrivateKey - size of encoded private key blob
    pszPassword - password used to encode private key
    pszKeyContainer - container name for private key
    pCryptKeyProvInfo - pointer to CRYPT_KEY_PROV_INFO structure filled in on success

Returns:

   BOOL indicating success/failure

--*/
    {
    BOOL fSuccess = FALSE;
    DWORD cbPassword = strlen(pszPassword);
    PPRIVATE_KEY_FILE_ENCODE pPrivateFile = NULL;
    DWORD                    cbPrivateFile = 0;
    MD5_CTX md5Ctx;
    struct RC4_KEYSTRUCT rc4Key;
    DWORD i;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hPrivateKey = NULL;
    DWORD cbDecodedPrivateKey = 0;
    PBYTE pbDecodedPrivateKey = NULL;

	DWORD err;
    //
    //HACK HACK HACK - need to make sure Schannel is initialized, so it registers
    //its custom decoders, which we make use of in the following code. So, make a 
    //bogus call to an Schannel function

    // Note: on NT5, the AcquireCredentialsHandle operates in the lsass process and
    // thus will not properly initialize the stuff we need in our process. Thus we
    // call SslGenerateRandomBits instead.
    //
    DWORD   dw;
    SslGenerateRandomBits( (PUCHAR)&dw, sizeof(dw) );

    // We have to do a little fixup here.  Old versions of
    // schannel wrote the wrong header data into the ASN
    // for private key files, so we must fix the size data.
    pbEncodedPrivateKey[2] = (BYTE) (((cbEncodedPrivateKey - 4) & 0xFF00) >> 8); //Get MSB
    pbEncodedPrivateKey[3] = (BYTE) ((cbEncodedPrivateKey - 4) & 0xFF); //Get LSB

    //
    // ASN.1 decode the private key.
    //

    //
    // Figure out the size of the buffer needed
    //
    if( !CryptDecodeObject(X509_ASN_ENCODING,
                           szPrivateKeyFileEncode,
                           pbEncodedPrivateKey,
                           cbEncodedPrivateKey,
                           0,
                           NULL,
                           &cbPrivateFile) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }

    pPrivateFile = (PPRIVATE_KEY_FILE_ENCODE) LocalAlloc( LPTR, cbPrivateFile );

    if(pPrivateFile == NULL)
        {
        SetLastError( ERROR_OUTOFMEMORY );
        goto EndDecodeKey;
        }

    //
    // Actually fill in the buffer
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyFileEncode,
                            pbEncodedPrivateKey,
                            cbEncodedPrivateKey,
                            0,
                            pPrivateFile,
                            &cbPrivateFile ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }

    //
    // Decrypt the decoded private key using the password.
    //
    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, (PBYTE) pszPassword, cbPassword);
    MD5Final(&md5Ctx);

    rc4_key( &rc4Key, 16, md5Ctx.digest );
//    memset( &md5Ctx, 0, sizeof(md5Ctx) );

    rc4( &rc4Key, 
         pPrivateFile->EncryptedBlob.cbData,
         pPrivateFile->EncryptedBlob.pbData );



    //
    // Build a PRIVATEKEYBLOB from the decrypted private key.
    //

    //
    // Figure out size of buffer needed
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyInfoEncode,
                            pPrivateFile->EncryptedBlob.pbData,
                            pPrivateFile->EncryptedBlob.cbData,
                            0,
                            NULL,
                            &cbDecodedPrivateKey ) )
        {
            // NOTE: This stuff is complicated!!! The following code came
            // from John Banes. Heck this whole routine pretty much came
            // from John Banes. -- Boyd

            // Maybe this was a SGC style key.
            // Re-encrypt it, and build the SGC decrypting
            // key, and re-decrypt it.
            BYTE md5Digest[MD5DIGESTLEN];

            rc4_key(&rc4Key, 16, md5Ctx.digest);
            rc4(&rc4Key,
                pPrivateFile->EncryptedBlob.cbData,
                pPrivateFile->EncryptedBlob.pbData);
            CopyMemory(md5Digest, md5Ctx.digest, MD5DIGESTLEN);

            MD5Init(&md5Ctx);
            MD5Update(&md5Ctx, md5Digest, MD5DIGESTLEN);
            MD5Update(&md5Ctx, (PUCHAR)SGC_KEY_SALT, strlen(SGC_KEY_SALT));
            MD5Final(&md5Ctx);
            rc4_key(&rc4Key, 16, md5Ctx.digest);
            rc4(&rc4Key,
                pPrivateFile->EncryptedBlob.cbData,
                pPrivateFile->EncryptedBlob.pbData);

            // Try again...
            if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szPrivateKeyInfoEncode,
                          pPrivateFile->EncryptedBlob.pbData,
                          pPrivateFile->EncryptedBlob.cbData,
                          0,
                          NULL,
                          &cbDecodedPrivateKey))
            {
                ZeroMemory(&md5Ctx, sizeof(md5Ctx));
                err = GetLastError();
		        goto EndDecodeKey;
            }
        
        
        }

    pbDecodedPrivateKey = (PBYTE) LocalAlloc( LPTR, cbDecodedPrivateKey );

    if( pbDecodedPrivateKey == NULL )
        {
        SetLastError( ERROR_OUTOFMEMORY );
        goto EndDecodeKey;
        }

    //
    // Actually fill in the buffer
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyInfoEncode,
                            pPrivateFile->EncryptedBlob.pbData,
                            pPrivateFile->EncryptedBlob.cbData,
                            0,
                            pbDecodedPrivateKey,
                            &cbDecodedPrivateKey ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }


    // On NT 4 the ff holds true : <- from Alex Mallet
    // Although key is going to be used for key exchange, mark it as being
    // used for signing, because only 512-bit key exchange keys are supported 
    // in the non-domestic rsabase.dll, whereas signing keys can be up to
    // 2048 bits.
    //
    // On NT 5, PROV_RSA_FULL should be changed to PROV_RSA_SCHANNEL, and 
    // aiKeyAlg to CALG_RSA_KEYX, because PROV_RSA_SCHANNEL, which is only
    // installed on NT 5, supports 1024-bit private keys for key exchange
    //
    // On NT4, Schannel doesn't care whether a key is marked for signing or exchange,
    // but on NT5 it does, so aiKeyAlg must be set appropriately
    //
    ((BLOBHEADER *) pbDecodedPrivateKey)->aiKeyAlg = CALG_RSA_KEYX;

    //
    // Clean out the key container, pszKeyContainer
    //

    CryptAcquireContext(&hProv,
                        pszKeyContainer,
                        NULL,
                        PROV_RSA_SCHANNEL,
                        CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET);
    //
    // Create a CryptoAPI key container in which to store the key.
    //
    if( !CryptAcquireContext( &hProv,
                              pszKeyContainer,
                              NULL,
                              PROV_RSA_SCHANNEL,
                              CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET))
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x calling CryptAcquireContext"), err);
        goto EndDecodeKey;
        }

    //
    // Import the private key blob into the key container.
    //
    if( !CryptImportKey( hProv,
                         pbDecodedPrivateKey,
                         cbDecodedPrivateKey,
                         0, 
                         CRYPT_EXPORTABLE, //so we can export it later
                         &hPrivateKey ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x importing PRIVATEKEYBLOB"), err);
        goto EndDecodeKey;
        }

    
    //
    // Fill in the CRYPT_KEY_PROV_INFO structure, with the same parameters we 
    // used in the call to CryptAcquireContext() above
    //

    //
    // container name in the structure is a unicode string, so we need to convert
    //

    if ( pszKeyContainer != NULL )
        {
        // point the key container name to the passed in string
        // WARNING: this does not actually copy the string, just the pointer
        // to it. So the strings needs to remain valid until the ProvInfo is commited.
        pCryptKeyProvInfo->pwszContainerName = pszKeyContainer;
        }
    else
        {
        pCryptKeyProvInfo->pwszContainerName = NULL;
        }

    pCryptKeyProvInfo->pwszProvName = NULL;
    pCryptKeyProvInfo->dwProvType = PROV_RSA_FULL;
    pCryptKeyProvInfo->dwFlags = 0x20;              // allow the cert to be exchanged
    pCryptKeyProvInfo->cProvParam = 0;
    pCryptKeyProvInfo->rgProvParam = NULL;
    pCryptKeyProvInfo->dwKeySpec = AT_KEYEXCHANGE;  // allow the cert to be exchanged

    fSuccess = TRUE;

EndDecodeKey:

    //
    // Clean-up that happens regardless of success/failure
    //
    if ( pPrivateFile )
        {
        LocalFree( pPrivateFile );
        }

    if ( pbDecodedPrivateKey )
        {
        LocalFree( pbDecodedPrivateKey );
        }

    if ( hPrivateKey )
        {
        CryptDestroyKey( hPrivateKey );
        }

    if ( hProv )
        {
        CryptReleaseContext( hProv, 0 ); 
        }

    return fSuccess;


    } //DecodeAndImportPrivateKey


//--------------------------------------------------------------------------------------------
/*++

Routine Description:

    Takes an incoming PKCS10 request and saves it as a property attached to the key. It also
    checks if the request is in the old internal Keyring format or not......

Arguments:

    pCert - CAPI certificate context pointer for the cert to save the request on
    pbPKCS10req - pointer to the request
    cbPKCS10req - size of the request

Returns:

   BOOL indicating success/failure

--*/
BOOL FImportAndStoreRequest( PCCERT_CONTEXT pCert, PVOID pbPKCS10req, DWORD cbPKCS10req )
{
    BOOL    f;
    DWORD   err;

    // if any NULLS are passed in, fail gracefully
    if ( !pCert || !pbPKCS10req || !cbPKCS10req )
        return FALSE;

    // first, check if the incoming request is actually pointing to an old KeyRing internal
    // request format. That just means that the real request is actuall slightly into
    // the block. The way you tell is by testing the first DWORD to see it
    // is REQUEST_HEADER_IDENTIFIER
    // start by seeing if this is a new style key request
    LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pbPKCS10req;
    if ( pHeader->Identifier == REQUEST_HEADER_IDENTIFIER )
        {
        // update the request pointer and data count
            pbPKCS10req = (PBYTE)pbPKCS10req + pHeader->cbSizeOfHeader;
            cbPKCS10req = pHeader->cbRequestSize;
        }

    // now save the request onto the key
	CRYPT_DATA_BLOB dataBlob;
    ZeroMemory( &dataBlob, sizeof(dataBlob) );
    dataBlob.pbData = (PBYTE)pbPKCS10req;           // pointer to blob data
    dataBlob.cbData = cbPKCS10req;                  // blob length info
	f = CertSetCertificateContextProperty(
        pCert, 
        CERTWIZ_REQUEST_PROP_ID,
        0,
        &dataBlob
        );
    err = GetLastError();

/*
    HRESULT hRes = CertTool_SetBinaryBlobProp(
                    pCert,                  // cert context to set the prop on
                    pbPKCS10req,            // pointer to blob data
                    cbPKCS10req,            // blob length info
                    CERTWIZ_REQUEST_PROP_ID,// property ID for context
                    TRUE                   // the request is already encoded
                    );
*/

    return f;
}



#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\ssltools\certupgr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   certupgr.hxx

Abstract:

    Declarations for functions used to upgrade K2 server certs to Avalanche server certs

Author:

    Alex Mallet (amallet)    02-Dec-1997
    Boyd Multerer (boydm)    20-Jan-1998

--*/

#ifndef _CERTUPGR_H_
#define _CERTUPGR_H_

#define CERT_DER_PREFIX		17

#define CERTWIZ_REQUEST_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1001)


#ifdef UNICODE
    #define ImportKRBackupToCAPIStore   ImportKRBackupToCAPIStore_W
    #define CopyKRCertToCAPIStore       CopyKRCertToCAPIStore_W
#else
    #define ImportKRBackupToCAPIStore   ImportKRBackupToCAPIStore_A
    #define CopyKRCertToCAPIStore       CopyKRCertToCAPIStore_A
#endif

// NOTE: In both the below routines the password must always be ANSI.

// NOTE: The PCCERT_CONTEXT that is returned from the below routines MUST be freed
// via the CAPI call CertFreeCertificateContext(). Otherwise you will be leaking.

//----------------------------------------------------------------
// given a path to an old keyring style backup file, this reads in the public and private
// key information and, using the passed-in password, imports it into the specified
// CAPI store.
PCCERT_CONTEXT ImportKRBackupToCAPIStore_A(
                            PCHAR ptszFileName,         // path of the file
                            PCHAR pszPassword,          // ANSI password
                            PCHAR pszCAPIStore );       // name of the capi store

PCCERT_CONTEXT ImportKRBackupToCAPIStore_W(
                            PWCHAR ptszFileName,        // path of the file
                            PCHAR pszPassword,          // ANSI password
                            PWCHAR pszCAPIStore );      // name of the capi store

//----------------------------------------------------------------
// given a path to an old keyring style backup file, this reads in the public and private
// key information and, using the passed-in password, imports it into the specified
// CAPI store.
// ptszFilePath:    Pointer to the path of the file to be imported
// pszPassword:     Pointer to the password.        MUST BE ANSI 
// ptszPassword:     Pointer to the CAPI store name.
PCCERT_CONTEXT CopyKRCertToCAPIStore_A(
                            PVOID pbPrivateKey, DWORD cbPrivateKey,     // private key info
                            PVOID pbPublicKey, DWORD cbPublicKey,       // public key info
                            PVOID pbPKCS10req, DWORD cbPKCS10req,       // the pkcs10 request
                            PCHAR pszPassword,                          // ANSI password
                            PCHAR pszCAPIStore );                       // name of the capi store

PCCERT_CONTEXT CopyKRCertToCAPIStore_W(
                            PVOID pbPrivateKey, DWORD cbPrivateKey,     // private key info
                            PVOID pbPublicKey, DWORD cbPublicKey,       // public key info
                            PVOID pbPKCS10req, DWORD cbPKCS10req,       // the pkcs10 request
                            PCHAR pszPassword,                          // ANSI password
                            PWCHAR pszCAPIStore );                      // name of the capi store

#endif // _CERTUPGR_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_)
#define AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__68FE5B2F_C6EC_488B_9A00_92317D14F33D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\ssltools\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#include <tchar.h>
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
}
#include <afxwin.h>
#include <afxext.h>
#include <afxcoll.h>
#include <afxcmn.h>

extern "C"
{
#include <ntsam.h>
#include <lm.h>
#include <lmerr.h>
}

//#include <dbgutil.h>
//#include <assert.h>

extern "C"
    {
    #include <md5.h>
    #include <rc4.h>
    #include <wincrypt.h>

    #define SECURITY_WIN32
    #include <sspi.h>
    #include <ntsecapi.h>
    #include <spseal.h>
    #include <schnlsp.h>
    }

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\editalias.h ===
// EditAlias.h : Declaration of the CEditAlias

#ifndef __EDITALIAS_H_
#define __EDITALIAS_H_

#include "resource.h"       // main symbols
#include "common.h"

// These constants depend on dialog layout
#define APP_PERM_NONE      0
#define APP_PERM_SCRIPTS   1
#define APP_PERM_EXECUTE   2

/////////////////////////////////////////////////////////////////////////////
// CEditAlias
class CEditAlias : 
	public CDialogImpl<CEditAlias>,
   public CWinDataExchange<CEditAlias>
{
public:
   CEditAlias() :
      m_read(FALSE),
      m_write(FALSE),
      m_source(FALSE),
      m_browse(FALSE),
      m_appcontrol(APP_PERM_NONE),
      m_pRootKey(NULL)
	{
	}

	~CEditAlias()
	{
	}

	enum { IDD = IDD_EDIT_ALIAS };

BEGIN_MSG_MAP_EX(CEditAlias)
	MSG_WM_INITDIALOG(OnInitDialog)
	COMMAND_ID_HANDLER_EX(IDOK, OnOK)
	COMMAND_ID_HANDLER_EX(IDCANCEL, OnCancel)
//   COMMAND_ID_HANDLER_EX(IDC_READ, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_WRITE, OnPermissions)
//   COMMAND_ID_HANDLER_EX(IDC_FULLCONTROL, OnPermissions)
//   COMMAND_ID_HANDLER_EX(IDC_DIRBROWSE, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_SCRIPTS_PERMS, OnPermissions)
   COMMAND_ID_HANDLER_EX(IDC_EXECUTE_PERMS, OnPermissions)
   COMMAND_HANDLER_EX(IDC_ALIAS, EN_CHANGE, OnAliasChange)
END_MSG_MAP()

	LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
	void OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl);
	void OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnPermissions(WORD wNotifyCode, WORD wID, HWND hWndCtrl);
   void OnAccess(WORD wNotifyCode, WORD wID, HWND hWndCtrl);
   void OnAliasChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);

   BEGIN_DDX_MAP(CEditAlias)
      DDX_TEXT(IDC_PATH, m_path)
      DDX_TEXT(IDC_ALIAS, m_alias)
      DDX_CHECK(IDC_READ, m_read)
      DDX_CHECK(IDC_WRITE, m_write)
      DDX_CHECK(IDC_FULLCONTROL, m_source)
      DDX_CHECK(IDC_DIRBROWSE, m_browse)
      DDX_RADIO(IDC_NONE_PERMS, m_appcontrol)
   END_DDX_MAP()

   TCHAR m_path[MAX_PATH], m_alias[MAX_PATH];
   CString m_prev_alias;
//   CMetabasePath m_root;
   CString m_instance;
   BOOL  m_read, 
         m_write, 
         m_source,
         m_browse, 
         m_appcontrol, 
         m_new;
   BOOL  m_in_init;
//   CToolTipCtrl m_tool_tip;
   CMetaKey * m_pRootKey;
};

#endif //__EDITALIAS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "w3ext_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\ssltools\oidenc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.h
//
//  Contents:   Schannel context declarations.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#ifndef __OIDENC_H__
#define __OIDENC_H__

#define szPublicTag   ".public"
#define szParamTag    ".params"
#define szPrivateTag  ".private"

#define MAX_OID_SIZE  64

#define szOID_DH  szOID_PKCS_3 ".1"


#define szOID_DH_Public szOID_DH szPublicTag
#define szOID_DH_Params szOID_DH szParamTag

#define szOID_RSA_RSA_Public szOID_RSA_RSA szPublicTag


#define szOID_INFOSEC_mosaicUpdatedSig_Public  szOID_INFOSEC_mosaicUpdatedSig  szPublicTag
#define szOID_INFOSEC_mosaicUpdatedSig_Params  szOID_INFOSEC_mosaicUpdatedSig  szParamTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Public szOID_INFOSEC_mosaicKMandUpdSig szPublicTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Params szOID_INFOSEC_mosaicKMandUpdSig szParamTag

#define szOID_DSA_Public szOID_OIWSEC_dsa szPublicTag
#define szOID_DSA_Params szOID_OIWSEC_dsa szParamTag

#define szOID_RSA_ENCRYPT_RC4_MD5  szOID_RSA_ENCRYPT ".4"


#define szPrivateKeyFileEncode "PrivateKeyFileEncode"
#define szPrivateKeyInfoEncode "PrivateKeyInfoEncode"

#ifndef X509_ENHANCED_KEY_USAGE
#define X509_ENHANCED_KEY_USAGE             ((LPCSTR) 36)

typedef struct _CTL_USAGE {
    DWORD               cUsageIdentifier;
    LPSTR               *rgpszUsageIdentifier;      // array of pszObjId
} CTL_USAGE, *PCTL_USAGE,
  CERT_ENHKEY_USAGE, *PCERT_ENHKEY_USAGE;


#endif

#ifndef szOID_ENHANCED_KEY_USAGE
#define szOID_ENHANCED_KEY_USAGE        "2.5.29.37"
#endif

#ifndef szOID_SERVER_GATED_CRYPTO
#define szOID_SERVER_GATED_CRYPTO       "1.3.6.1.4.1.311.10.3.3"
#endif

#define szOID_NETSCAPE_SGC              "2.16.840.1.113730.4.1"


BOOL
WINAPI
InitSchannelOSS(
        HMODULE hModule);

typedef struct _PRIVATE_KEY_FILE_ENCODE
{
    CRYPT_BIT_BLOB              EncryptedBlob;
    CRYPT_ALGORITHM_IDENTIFIER  Alg; 
} PRIVATE_KEY_FILE_ENCODE, *PPRIVATE_KEY_FILE_ENCODE;


#endif // __OIDENC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\propshellext.cpp ===
// PropShellExt.cpp : Implementation of CW3extApp and DLL registration.

#include "stdafx.h"
#include "w3ext.h"
#include "PropShellExt.h"

/////////////////////////////////////////////////////////////////////////////
//
// IShellExtInit Implementation.

STDMETHODIMP 
CPropShellExt::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID)
{
   if (pDataObj == NULL)
   {
      ATLASSERT(FALSE);
      return (E_INVALIDARG);
   }
   FORMATETC f = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
   STGMEDIUM m;
   HRESULT hr = pDataObj->GetData(&f, &m);
   if (FAILED(hr))
   {
      return(hr);
   }
   if (1 == DragQueryFile((HDROP)m.hGlobal, (UINT)(-1), NULL,0))
   {
      TCHAR szFileName[MAX_PATH];
      DragQueryFile((HDROP)m.hGlobal, 0, szFileName, sizeof(szFileName) / sizeof(TCHAR));
      SHFILEINFO shfi;
      SHGetFileInfo(szFileName, 0, &shfi, sizeof(SHFILEINFO), SHGFI_ATTRIBUTES);
      if (  (shfi.dwAttributes & (SFGAO_LINK | SFGAO_REMOVABLE)) == 0
         && (shfi.dwAttributes & SFGAO_FILESYSTEM) != 0
         )
      {
         int drive_number, drive_type;
         TCHAR szRoot[4];
         if (  -1 != (drive_number = PathGetDriveNumber(szFileName))
            && NULL != PathBuildRoot(szRoot, drive_number)
            && DRIVE_REMOTE != (drive_type = GetDriveType(szRoot))
            && DRIVE_NO_ROOT_DIR != drive_type
            )
         {
            StrCpy(m_szFileName, szFileName);
         }
         else
         {
            hr = E_FAIL;
         }
      }
      else
      {
         hr = E_FAIL;
      }
   }
   ReleaseStgMedium(&m);
   return hr;
}


STDMETHODIMP 
CPropShellExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
   // We only add the page if the user has admin priviliges in the metabase.
   // The only way to check it now is to try to write something.
   // Test key is /LM/W3SVC.
   CMetabasePath path(SZ_MBN_WEB);
   CMetaKey key(LOCAL_KEY, path,
      METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE
      );
   if (key.Succeeded() && SUCCEEDED(key.SetValue(MD_ISM_ACCESS_CHECK, 0x0000FFFF)))
   {
      m_psW3ShellExtProp.SetParentExt(this);
      HPROPSHEETPAGE hpage = m_psW3ShellExtProp.Create();
      ASSERT(hpage != NULL);
      if (NULL != hpage)
      {
         AddRef();
         if (!lpfnAddPage(hpage, lParam))
         {
            DestroyPropertySheetPage(hpage);
         }
      }
   }
   return key.QueryResult();
}


STDMETHODIMP 
CPropShellExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
   return E_FAIL;
}

BOOL
RecursiveCheckVRoots(CMetaEnumerator& en, LPCTSTR meta_path, LPCTSTR folder_path)
{
   BOOL shared = FALSE;
   CString vrpath;
   BOOL bInheritOverride = FALSE;
   if (SUCCEEDED(en.QueryValue(MD_VR_PATH, vrpath, &bInheritOverride, meta_path)))
   {
      if (vrpath.CompareNoCase(folder_path) == 0)
      {
         return TRUE;
      }
   }
   CString vdir;
   while (SUCCEEDED(en.Next(vdir, meta_path)) && !shared)
   {
      CString next_vdir;
      if (meta_path != NULL)
         next_vdir += meta_path;
      next_vdir += vdir;
      next_vdir += SZ_MBN_SEP_STR;
      en.Push();
      en.Reset();
      shared = RecursiveCheckVRoots(en, next_vdir, folder_path);
      en.Pop();
   }
   return shared;
}

BOOL IsFolderShared(LPCTSTR path)
{
   BOOL shared = FALSE;
   CMetaEnumerator en(LOCAL_KEY, CMetabasePath(SZ_MBN_WEB));
   if (en.Succeeded())
   {
      DWORD di;
      int i = -1;
      CString inst;
      HRESULT hr = S_OK;
      while (SUCCEEDED(hr) && !shared)
      {
         if (SUCCEEDED(hr = en.Next(di, inst)))
         {
            CMetabasePath meta_path(TRUE, SZ_MBN_WEB, inst, SZ_MBN_ROOT);
            CMetaEnumerator en(LOCAL_KEY, meta_path);
            ASSERT(en.Succeeded());
            if (en.Succeeded())
            {
               shared = RecursiveCheckVRoots(en, NULL, path);
            }
         }
      }
   }
   return shared;
}


UINT
CPropShellExt::CopyCallback(
        HWND hwnd,          
        UINT wFunc,         
        UINT wFlags,        
        LPCTSTR pszSrcFile,  
        DWORD dwSrcAttribs, 
        LPCTSTR pszDestFile, 
        DWORD dwDestAttribs 
        )
{
    UINT rc = IDYES;
    if ((dwSrcAttribs & FILE_ATTRIBUTE_DIRECTORY) != 0)
    {
        switch (wFunc)
        {
        case FO_DELETE:
        case FO_MOVE:
        case FO_RENAME:
           if (IsFolderShared(pszSrcFile))
           {
              CString cap, msg;
              cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
              msg.Format(_Module.GetResourceInstance(), IDS_CONFIRM_OPERATION, pszSrcFile);
              rc = MessageBox(hwnd, msg, cap, MB_YESNOCANCEL|MB_ICONQUESTION);
           }
           break;
        }
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\editalias.cpp ===
// EditAlias.cpp : Implementation of CEditAlias
#include "stdafx.h"
#include "W3PropPage.h"
#include "w3ext.h"
#include "PropShellExt.h"
#include "EditAlias.h"

/////////////////////////////////////////////////////////////////////////////
// CEditAlias

#define TOOLTIP_READ_PERMISSIONS      1000

LRESULT 
CEditAlias::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   CMetabasePath path(TRUE, SZ_MBN_WEB, m_instance, SZ_MBN_ROOT, m_new ? NULL : m_alias);
   CMetaKey mk(LOCAL_KEY, path);
   DWORD flags;
   m_prev_alias = m_alias;
   if (SUCCEEDED(mk.QueryValue(MD_ACCESS_PERM, flags)))
   {
      m_read = ((flags & MD_ACCESS_READ) != 0);
      m_write = ((flags & MD_ACCESS_WRITE) != 0);
      m_source = ((flags & MD_ACCESS_SOURCE) != 0);

      if (!m_new)
      {
         if ((flags & MD_ACCESS_EXECUTE) != 0)
            m_appcontrol = APP_PERM_EXECUTE;
         else if ((flags & MD_ACCESS_SCRIPT) != 0)
            m_appcontrol = APP_PERM_SCRIPTS;
      }
      else
         m_appcontrol = APP_PERM_SCRIPTS;
   }
   else
   {
      EndDialog(0);
   }
   if (SUCCEEDED(mk.QueryValue(MD_DIRECTORY_BROWSING, flags)))
   {
      m_browse = ((flags & MD_DIRBROW_ENABLED) != 0);
   }
   else
   {
      EndDialog(0);
   }
   ::EnableWindow(GetDlgItem(IDOK), m_alias[0] != 0);
   m_in_init = TRUE;
   DoDataExchange();
   m_in_init = FALSE;

//   if (NULL != m_tool_tip.Create(hDlg))
//   {
//      RECT rc;
//      ::GetWindowRect(GetDlgItem(IDC_READ), &rc);
//      ScreenToClient(&rc);
//      m_tool_tip.AddTool(hDlg, 
//         _T("Users could read this directory"),
//         &rc, TOOLTIP_READ_PERMISSIONS
//         );
//   }
   return 1;
}

void 
CEditAlias::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CError err;
   DWORD app_state = 0;
   BOOL bRenamed = FALSE;
   DoDataExchange(TRUE);
   CMetabasePath alias(FALSE, m_alias);
   CMetabasePath::CleanMetaPath(alias);
   if (alias.QueryMetaPath()[0] == 0)
   {
      CString cap, msg;
      cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
      msg.Format(_Module.GetResourceInstance(), IDS_BAD_ALIAS, m_alias);
      MessageBox(msg, cap);
      ::SetFocus(GetDlgItem(IDC_ALIAS));
      SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
      return;
   }
   CMetabasePath path(TRUE, SZ_MBN_WEB, m_instance, 
      SZ_MBN_ROOT, alias.QueryMetaPath());
   CMetabasePath::CleanMetaPath(path);
   CMetabasePath parent(path);
   CString sub_alias;
   CMetabasePath::GetLastNodeName(path, sub_alias);
   CMetabasePath::ConvertToParentPath(parent);
   CWaitCursor wait;
   do 
   {
      if (!m_new)
      {
         if (m_prev_alias.Compare(m_alias) != 0)
         {
            CMetabasePath prev_path(TRUE, SZ_MBN_WEB, m_instance, SZ_MBN_ROOT, m_prev_alias);
            CIISApplication app(NULL, prev_path);
            err = app.QueryResult();
            BREAK_ON_ERR_FAILURE(err)
            app_state = app.QueryAppState();
            err = app.Delete();
            BREAK_ON_ERR_FAILURE(err)
            CString str;
            CMetabasePath::GetLastNodeName(prev_path, str);
            CMetabasePath::ConvertToParentPath(prev_path);
            CMetaKey mk_prev(LOCAL_KEY, prev_path, METADATA_PERMISSION_WRITE);
            err = mk_prev.DeleteKey(str);
            BREAK_ON_ERR_FAILURE(err)
            bRenamed = TRUE;
         }
      }
      //make sure the parent is there
      CMetaKey mk(LOCAL_KEY, parent, METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE);
      err = mk.QueryResult();
      if (err.Failed())
	   {
         if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
         {
            CString caption, msg;
            caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
            msg.LoadString(_Module.GetResourceInstance(), IDS_NO_PARENT);
	         MessageBox (msg, caption, MB_OK);
            ::SetFocus(GetDlgItem(IDC_ALIAS));
            SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
            break;
         }
         err.MessageBox();
         break;
	   }
      // if we are editing, delete previous vdir and application
      if (m_new)
      {
         // check if this alias is already available
         err = mk.DoesPathExist(sub_alias);
         if (err.Succeeded())
         {
            CString caption, fmt, msg;
            caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
            fmt.LoadString(_Module.GetResourceInstance(), IDS_ALIAS_IS_TAKEN);
            msg.Format(fmt, path.QueryMetaPath());
            MessageBox (msg, caption, MB_OK);
            ::SetFocus(GetDlgItem(IDC_ALIAS));
            SendDlgItemMessage(IDC_ALIAS, EM_SETSEL, 0, -1);
            err = E_FAIL;
            break;
         }
         err = S_OK;
      }
      if (err.Succeeded())
      {
         if (m_new || bRenamed)
         {
            err = mk.AddKey(sub_alias);
            BREAK_ON_ERR_FAILURE(err)
            err = mk.SetValue(MD_KEY_TYPE, CString(_T("IIsWebVirtualDir")), NULL, sub_alias);
            BREAK_ON_ERR_FAILURE(err)
            err = mk.SetValue(MD_VR_PATH, CString(m_path), NULL, sub_alias);
            BREAK_ON_ERR_FAILURE(err)
         }
      }
      // apply permissions
      DWORD flags;
      mk.QueryValue(MD_ACCESS_PERM, flags, NULL, sub_alias);
      flags &= ~(MD_ACCESS_READ|MD_ACCESS_WRITE|MD_ACCESS_SOURCE|MD_ACCESS_SCRIPT|MD_ACCESS_EXECUTE);
      flags |= m_read ? MD_ACCESS_READ : 0;
      flags |= m_write ? MD_ACCESS_WRITE : 0;
      flags |= m_source ? MD_ACCESS_SOURCE : 0;
      if (m_appcontrol == APP_PERM_SCRIPTS)
         flags |= MD_ACCESS_SCRIPT;
      else if (m_appcontrol == APP_PERM_EXECUTE)
         flags |= MD_ACCESS_SCRIPT|MD_ACCESS_EXECUTE;
      mk.SetValue(MD_ACCESS_PERM, flags, NULL, sub_alias);
      
      mk.QueryValue(MD_DIRECTORY_BROWSING, flags, NULL, sub_alias);
      flags &= ~MD_DIRBROW_ENABLED;
      flags |= m_browse ? MD_DIRBROW_ENABLED : 0;
      err = mk.SetValue(MD_DIRECTORY_BROWSING, flags, NULL, sub_alias);
      BREAK_ON_ERR_FAILURE(err)
      if (m_new)
      {
          DWORD dwAuthFlags;
          err = mk.QueryValue(MD_AUTHORIZATION, dwAuthFlags, NULL, sub_alias);
          BREAK_ON_ERR_FAILURE(err)
          dwAuthFlags &= ~(MD_AUTH_BASIC|MD_AUTH_ANONYMOUS|MD_AUTH_MD5);
          dwAuthFlags |= MD_AUTH_NT;
          err = mk.SetValue(MD_AUTHORIZATION, dwAuthFlags, NULL, sub_alias);
          BREAK_ON_ERR_FAILURE(err)
      }
   } while (FALSE);
   if (err.Succeeded())
   {
       do
       {
           CIISApplication app(NULL, path);
           err = app.QueryResult();
           BREAK_ON_ERR_FAILURE(err)
           err = app.Create(NULL, 
               app_state ? app_state : CWamInterface::APP_POOLEDPROC);
           BREAK_ON_ERR_FAILURE(err)
           EndDialog(wID);
       } while (FALSE);
   }
}

void 
CEditAlias::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   EndDialog(wID);
}

void 
CEditAlias::OnPermissions(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   if (!m_in_init)
   {
      DoDataExchange(TRUE);
      if (m_write && m_appcontrol > 0)
      {
         CString caption, msg;
         VERIFY(caption.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE));
         VERIFY(msg.LoadString(_Module.GetResourceInstance(), IDS_WRITEEXECUTE_DANGER));
	      if (IDNO == MessageBox(msg, caption, MB_YESNO | MB_ICONEXCLAMATION))
         {
            CheckDlgButton(wID, 0);
            if (wID != IDC_WRITE)
            {
               CheckDlgButton(IDC_NONE_PERMS, 1);
            }
         }
      }
   }
}

void 
CEditAlias::OnAliasChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   if (!m_in_init)
   {
      DoDataExchange(TRUE);
      ::EnableWindow(GetDlgItem(IDOK), m_alias[0] != 0);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by w3ext.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROPSHELLEXT_DESC           101
#define IDR_PROP_SHELL_EXT              102
#define IDS_SERVICE_NAME                102
#define IDD_W3PROPERTY_PAGE             103
#define IDS_PAGE_TITLE                  103
#define IDS_DEFAULT_SERVER_COMMENT      104
#define IDS_NO_PARENT                   105
#define IDS_WRITEEXECUTE_DANGER         106
#define IDS_ALIAS_IS_TAKEN              107
#define IDS_CONFIRM_REMOVE              108
#define IDS_CONFIRM_REMOVE_ALL          109
#define IDI_ICON_WEB_SERVICE            110
#define IDS_BAD_ALIAS                   110
#define IDI_ICON_IIS                    111
#define IDS_CONFIRM_OPERATION           111
#define IDC_ICON_WEB_SERVICE            201
#define IDC_STATIC_STATUS               202
#define IDD_EDIT_ALIAS                  202
#define IDC_STATIC_SHARE_ON             203
#define IDC_COMBO_SERVER                204
#define IDC_SHARE_OFF                   205
#define IDC_SHARE_ON                    206
#define IDC_STATIC_ALIAS_TITLE          207
#define IDC_LIST                        208
#define IDC_ADD                         209
#define IDC_EDIT                        210
#define IDC_REMOVE                      211
#define IDC_STATIC_ICON_IIS             212
#define IDC_ALIAS                       213
#define IDC_READ                        214
#define IDC_WRITE                       215
#define IDC_FULLCONTROL                 216
#define IDC_DIRBROWSE                   217
#define IDC_NONE_PERMS                  218
#define IDC_SCRIPTS_PERMS               219
#define IDC_EXECUTE_PERMS               220
#define IDC_PATH                        221

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         207
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED_)
#define AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
#include <prsht.h>
#include <shfusion.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define _WTL_NO_CSTRING

#include <shellapi.h>
#include <shlobj.h>
#include <shlguid.h>
#include <shlwapi.h>

#include <comdef.h>
#include <atlwin.h>
#include <atlapp.h>
#include <atlmisc.h>
#include <atlctrls.h>
#include <atlctrlx.h>
#include <atlddx.h>
#include <atlcrack.h>

#include <map>
#include <list>
#include <stack>
#include <set>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B383AFD_7CF2_4980_86E3_909175F77CC6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\propshellext.h ===
// PropShellExt.h: Definition of the CPropShellExt class
//
//////////////////////////////////////////////////////////////////////

#if !defined(_PROPSHELLEXT_H)
#define _PROPSHELLEXT_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "common.h"
#include "mdkeys.h"
#include "W3PropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CPropShellExt

typedef ICopyHook IShellCopyHook;

class CPropShellExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropShellExt,&CLSID_PropShellExt>,
	public IShellExtInit,
	public IShellPropSheetExt,
    public ICopyHook
{
public:
   CPropShellExt()
   {
   }

BEGIN_COM_MAP(CPropShellExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
    COM_INTERFACE_ENTRY_IID(IID_IShellCopyHook, ICopyHook)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPropShellExt) 

DECLARE_REGISTRY_RESOURCEID(IDR_PROP_SHELL_EXT)

public:
   // IShellExtInit Methods
   STDMETHOD(Initialize)(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj, HKEY hKeyID );

   //IShellPropSheetExt methods
   STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
   STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

   //ICopyHook methods
   STDMETHODIMP_(UINT) CopyCallback(
        HWND hwnd,          
        UINT wFunc,         
        UINT wFlags,        
        LPCTSTR pszSrcFile,  
        DWORD dwSrcAttribs, 
        LPCTSTR pszDestFile, 
        DWORD dwDestAttribs 
        );

//   const CComAuthInfo * GetAuthentication() const
//   {
//      return &m_auth;
//   }
   LPCTSTR GetPath()
   {
      return m_szFileName;
   }

private:
   TCHAR m_szFileName[MAX_PATH];
//   CComAuthInfo m_auth;
	CW3PropPage m_psW3ShellExtProp;
};

#endif // !defined(_PROPSHELLEXT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\w3ext.cpp ===
// w3ext.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for w3ext.idl by adding the following 
//      files to the Outputs.
//          w3ext_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f w3extps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "w3ext.h"
#include "dlldatax.h"

#include "w3ext_i.c"
#include "PropShellExt.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
   OBJECT_ENTRY(CLSID_PropShellExt, CPropShellExt)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_W3EXTLib);
        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModule(hInstance);
//        SHFusionInitialize(NULL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
       SHFusionUninitialize ();
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\w3proppage.cpp ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        W3PropPage.cpp

   Abstract:
        IIS Shell extension PropertyPage class implementation

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/
#include "stdafx.h"
#include "W3PropPage.h"
#include "w3ext.h"
#include "PropShellExt.h"
#include "EditAlias.h"

#define SZ_SERVER_KEYTYPE     _T("IIsWebServer")

/////////////////////////////////////////////////////////////////////////////
// CW3PropPage

LRESULT 
CW3PropPage::OnInitDialog(HWND hDlg, LPARAM lParam)
{
   // subclass dialog controls
   DoDataExchange();

   ASSERT(m_pParentExt != NULL);
   CMetaEnumerator en(LOCAL_KEY, CMetabasePath(SZ_MBN_WEB));
   ASSERT(en.Succeeded());
   if (en.Succeeded())
   {
      DWORD di;
      int i = -1;
      CString inst;
      HRESULT hr = S_OK;
      while (SUCCEEDED(hr))
      {
         if (SUCCEEDED(hr = en.Next(di, inst)))
         {
            CString cmt;
            if (SUCCEEDED(hr = en.QueryValue(MD_SERVER_COMMENT, cmt, NULL, inst)))
            {
               if (cmt.IsEmpty())
               {
                  cmt.Format(_Module.GetResourceInstance(), 
                     IDS_DEFAULT_SERVER_COMMENT, di);
               }
               if (CB_ERR != (i = m_servers_list.AddString(cmt)))
               {
                  m_servers_list.SetItemDataPtr(i, StrDup(inst));
               }
            }
         }
      }
      if (i >= 0)
         m_servers_list.SetCurSel(0);

      m_ShareThis = 0;

      // Fill shares list box for selected server
      OnServerChange(0, 0, NULL);
   }
   return 1;
}

void 
CW3PropPage::OnDestroy()
{
   ATLTRACE("In OnDestroy handler\n");
//   DebugBreak();
}

HRESULT GetKeyNames(CMetaEnumerator& en, std::set<CString>& keys)
{
   CString key;
   HRESULT hr;
   if (SUCCEEDED(hr = en.Next(key)))
   {
      keys.insert(key);
   }
   return hr;
}

void 
CW3PropPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CEditAlias dlg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   dlg.m_instance = p;
   p = m_pParentExt->GetPath();
   ::StrCpy(dlg.m_path, p);
   dlg.m_new = TRUE;
   if (p == PathFindFileName(p))
   {
      /* No file name -- could be root directory like c:\ */
      dlg.m_alias[0] = 0;
   }
   else
   {
      TCHAR buf[MAX_PATH];

      StrCpy(buf, PathFindFileName(p));
      PathMakePretty(buf);
      StrCpy(dlg.m_alias, buf);
      // Now we need to generate unique prompt for this new alias
      CMetaEnumerator en(LOCAL_KEY, 
         CMetabasePath(TRUE, SZ_MBN_WEB, dlg.m_instance, SZ_MBN_ROOT));
      ASSERT(en.Succeeded());
      if (en.Succeeded())
      {
         std::set<CString> keys;
         if (SUCCEEDED(GetKeyNames(en, keys)) && !keys.empty())
         {
            int i = 0;
            while (keys.find(buf) != keys.end())
            {
               wsprintf(buf, _T("%s%d"), dlg.m_alias, ++i);
            }
            StrCpy(dlg.m_alias, buf);
         }
      }
   }
   if (IDOK == dlg.DoModal())
   {
      OnServerChange(0, 0, NULL);
      ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
   }
}

void 
CW3PropPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CString cap, msg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
   index = m_share_list.GetCurSel();
   TCHAR buf[MAX_PATH];
   m_share_list.GetText(index, buf);
   msg.Format(_Module.GetResourceInstance(), IDS_CONFIRM_REMOVE, buf);
   CError err;
   if (IDYES == MessageBox(msg, cap, MB_YESNO|MB_ICONQUESTION))
   {
      CWaitCursor wait;

      do 
      {
         CIISApplication app(NULL, CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT, buf));
         err = app.QueryResult();
         BREAK_ON_ERR_FAILURE(err)
         err = app.Delete(TRUE);
      } while (FALSE);
      if (err.Succeeded())
      {
         CMetaKey mk(LOCAL_KEY, 
            CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT),
            METADATA_PERMISSION_WRITE);
         err = mk.DeleteKey(buf);
         if (err.Succeeded())
         {
            m_share_list.DeleteString(index);
            int count = m_share_list.GetCount();
            m_ShareThis = count > 0 ? 1 : 0;
            if (m_ShareThis)
            {
               m_share_list.SetCurSel(index >= count ? count - 1 : index);
            }
            EnableOnShare();
            CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
            CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
            ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
         }
         else
         {
            err.MessageBox();
         }
      }
      else
      {
         err.MessageBox();
      }
   }
}

void 
CW3PropPage::OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   CEditAlias dlg;
   int index = m_servers_list.GetCurSel();
   LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
   dlg.m_instance = p;
   p = m_pParentExt->GetPath();
   ::StrCpy(dlg.m_path, p);
   index = m_share_list.GetCurSel();
   TCHAR buf[MAX_PATH];
   m_share_list.GetText(index, buf);
   ::StrCpy(dlg.m_alias, buf);
   dlg.m_new = FALSE;
   if (IDOK == dlg.DoModal())
   {
      OnServerChange(0, 0, NULL);
      ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
   }
}

void 
CW3PropPage::OnServerChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   // get selected server instance number
   int index = m_servers_list.GetCurSel();
   if (LB_ERR != index)
   {
      LPTSTR p = (LPTSTR)m_servers_list.GetItemDataPtr(index);
      CMetabasePath path(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT);
      CMetaEnumerator en(LOCAL_KEY, path);
      ASSERT(en.Succeeded());
      m_share_list.ResetContent();
      if (en.Succeeded())
      {
         RecurseVDirs(en, NULL);
      }
      m_ShareThis = m_share_list.GetCount() > 0 ? 1 : 0;
   }
   if (m_ShareThis)
   {
      m_share_list.SetCurSel(0);
   }
   EnableOnShare();
   CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
   CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
   ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
}

void
CW3PropPage::RecurseVDirs(CMetaEnumerator& en, LPCTSTR path)
{
   CString vrpath;
   BOOL bInheritOverride = FALSE;
   if (SUCCEEDED(en.QueryValue(MD_VR_PATH, vrpath, &bInheritOverride, path)))
   {
      if (vrpath.CompareNoCase(m_pParentExt->GetPath()) == 0)
      {
         CMetabasePath mpath(FALSE, path);
         CMetabasePath::CleanMetaPath(mpath);
         m_share_list.AddString(path == NULL ? 
            SZ_MBN_SEP_STR : mpath.QueryMetaPath());
      }
   }
   CString vdir;
   while (SUCCEEDED(en.Next(vdir, path)))
   {
      CString next_vdir;
      if (path != NULL)
         next_vdir += path;
      next_vdir += vdir;
      next_vdir += SZ_MBN_SEP_STR;
      en.Push();
      en.Reset();
      RecurseVDirs(en, next_vdir);
      en.Pop();
   }
}

void 
CW3PropPage::OnShareYesNo(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
   int count = m_share_list.GetCount();
   m_ShareThis = IsDlgButtonChecked(IDC_SHARE_ON);
   if (m_ShareThis)
   {
      if (count <= 0)
      {
         OnAdd(0, 0, NULL);
         m_ShareThis = (m_share_list.GetCount() > 0);
      }
   }
   else
   {
      if (count > 0)
      {
         CString cap, msg;
         int index = m_servers_list.GetCurSel();
         LPCTSTR p = (LPCTSTR)m_servers_list.GetItemData(index);
         cap.LoadString(_Module.GetResourceInstance(), IDS_PAGE_TITLE);
         msg.LoadString(_Module.GetResourceInstance(), IDS_CONFIRM_REMOVE_ALL);
         CError err;
         if (IDYES == MessageBox(msg, cap, MB_YESNO))
         {
            CWaitCursor wait;
            TCHAR alias[MAX_PATH];
            int del_idx = 0;
            for (index = 0; err.Succeeded() && index < count; index++)
            {
               m_share_list.GetText(del_idx, alias);
               if (0 == StrCmp(alias, SZ_MBN_SEP_STR))
               {
                   // Do not remove sites! Skip it.
                   del_idx++;
                   continue;
               }
               do 
               {
                  CIISApplication app(NULL, CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT, alias));
                  err = app.QueryResult();
                  BREAK_ON_ERR_FAILURE(err)
                  err = app.Delete(TRUE);
                  BREAK_ON_ERR_FAILURE(err)
                  CMetaKey mk(LOCAL_KEY, 
                     CMetabasePath(TRUE, SZ_MBN_WEB, p, SZ_MBN_ROOT),
                     METADATA_PERMISSION_WRITE);
                  err = mk.DeleteKey(alias);
                  BREAK_ON_ERR_FAILURE(err)
               } while (FALSE);
               BREAK_ON_ERR_FAILURE(err)
               m_share_list.DeleteString(del_idx);
            }
            if (err.Failed() || del_idx > 0)
            {
// BUGBUG: we have AV when preparing message box text here
//               err.MessageBox();
               m_ShareThis = TRUE;
            }
         }
         else
         {
            m_ShareThis = TRUE;
         }
      }
   }
   CheckDlgButton(IDC_SHARE_ON, m_ShareThis);
   CheckDlgButton(IDC_SHARE_OFF, !m_ShareThis);
   EnableOnShare();
   ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
}

void
CW3PropPage::EnableOnShare()
{
   m_share_list.EnableWindow(m_ShareThis);
   ::EnableWindow(GetDlgItem(IDC_ADD), m_ShareThis);
   ::EnableWindow(GetDlgItem(IDC_EDIT), m_ShareThis 
      && m_share_list.GetCurSel() != LB_ERR);
   ::EnableWindow(GetDlgItem(IDC_REMOVE), m_ShareThis
      && m_share_list.GetCurSel() != LB_ERR);
   if (m_ShareThis)
   {
       EnableEditRemove();
   }
}

void 
CW3PropPage::OnVDirChange(WORD wNotifyCode, WORD wID, HWND hWndCtl)
{
    EnableEditRemove();
}

void
CW3PropPage::EnableEditRemove()
{
    // We are disabling Edit and Remove buttons when user
    // select root alias, i.e. user cannot delete or edit sites
    int index = m_share_list.GetCurSel();
    BOOL bEnable = index != LB_ERR;
    if (bEnable)
    {
        TCHAR alias[MAX_PATH];
        m_share_list.GetText(index, alias);
        bEnable = (0 != StrCmp(alias, SZ_MBN_SEP_STR));
    }
    ::EnableWindow(GetDlgItem(IDC_EDIT), bEnable);
    ::EnableWindow(GetDlgItem(IDC_REMOVE), bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\w3ext\w3proppage.h ===
/*++

   Copyright    (c)    1994-2000    Microsoft Corporation

   Module  Name :
        W3PropPage.h

   Abstract:
        IIS Shell extension PropertyPage class definition

   Author:
        Sergei Antonov (sergeia)

   Project:
        Internet Services Manager

   Revision History:

--*/

#ifndef __W3PROPPAGE_H_
#define __W3PROPPAGE_H_

#include "resource.h"       // main symbols

class CPropShellExt;
class CMetaEnumerator;

#define LOCAL_KEY    ((CComAuthInfo *)NULL)

template <class T, bool bAutoDelete = true>
class CShellExtPropertyPageImpl : public CDialogImplBase
{
public:
	PROPSHEETPAGE m_psp;

	operator PROPSHEETPAGE*() { return &m_psp; }

// Construction
	CShellExtPropertyPageImpl(LPCTSTR lpszTitle = NULL)
	{
		// initialize PROPSHEETPAGE struct
		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
		m_psp.dwSize = sizeof(PROPSHEETPAGE);
		m_psp.dwFlags = PSP_USECALLBACK | PSP_USEREFPARENT | PSP_DEFAULT;
		m_psp.hInstance = _Module.GetResourceInstance();
		m_psp.pszTemplate = MAKEINTRESOURCE(T::IDD);
		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
		m_psp.pfnCallback = T::PropPageCallback;
        m_psp.pcRefParent = reinterpret_cast<UINT *>(&_Module.m_nLockCnt);
        m_psp.lParam = reinterpret_cast<LPARAM>(this);

		if(lpszTitle != NULL)
		{
			m_psp.pszTitle = lpszTitle;
			m_psp.dwFlags |= PSP_USETITLE;
		}
	}

	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
	{
		ATLASSERT(hWnd == NULL);
		if(uMsg == PSPCB_CREATE || uMsg == PSPCB_ADDREF)
		{
			CDialogImplBase * pPage = (CDialogImplBase *)ppsp->lParam;
			_Module.AddCreateWndData(&pPage->m_thunk.cd, pPage);
		}
		if (bAutoDelete && uMsg == PSPCB_RELEASE)
		{
			T * pPage = (T *)ppsp->lParam;
			delete pPage;
		}

		return 1;
	}

	HPROPSHEETPAGE Create()
	{
		return ::CreatePropertySheetPage(&m_psp);
	}

	BOOL EndDialog(int)
	{
		// do nothing here, calling ::EndDialog will close the whole sheet
		ATLASSERT(FALSE);
		return FALSE;
	}
};

class CComboBoxExch : public CWindowImpl<CComboBoxExch, CComboBox>
{
public:
   BEGIN_MSG_MAP_EX(CComboBoxExch)
   END_MSG_MAP()
};

class CListBoxExch : public CWindowImpl<CListBoxExch, CListBox>
{
public:
   BEGIN_MSG_MAP_EX(CListBoxExch)
   END_MSG_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CW3PropPage

// We cannot make this class autodelete -- we are storing instance of this page 
// inside of shell extension module
//
class CW3PropPage : 
   public CShellExtPropertyPageImpl<CW3PropPage, false>,
   public CWinDataExchange<CW3PropPage>
{
public:
   CW3PropPage() :
      CShellExtPropertyPageImpl<CW3PropPage, false>(MAKEINTRESOURCE(IDS_PAGE_TITLE)),
      m_pParentExt(NULL)
	{
	}

	~CW3PropPage()
	{
	}

	enum { IDD = IDD_W3PROPERTY_PAGE };

BEGIN_MSG_MAP_EX(CW3PropPage)
   MSG_WM_INITDIALOG(OnInitDialog)
   MSG_WM_DESTROY(OnDestroy)
   COMMAND_ID_HANDLER_EX(IDC_ADD, OnAdd)
   COMMAND_ID_HANDLER_EX(IDC_REMOVE, OnRemove)
   COMMAND_ID_HANDLER_EX(IDC_EDIT, OnEdit)
   COMMAND_HANDLER_EX(IDC_COMBO_SERVER, CBN_SELCHANGE, OnServerChange)
   COMMAND_HANDLER_EX(IDC_SHARE_OFF, BN_CLICKED, OnShareYesNo)
   COMMAND_HANDLER_EX(IDC_SHARE_ON, BN_CLICKED, OnShareYesNo)
   COMMAND_HANDLER_EX(IDC_LIST, LBN_SELCHANGE, OnVDirChange)
   COMMAND_HANDLER_EX(IDC_LIST, LBN_DBLCLK, OnEdit)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(HWND hDlg, LPARAM lParam);
   void OnDestroy();
   void OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnServerChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnShareYesNo(WORD wNotifyCode, WORD wID, HWND hWndCtl);
   void OnVDirChange(WORD wNotifyCode, WORD wID, HWND hWndCtl);

   BEGIN_DDX_MAP(CW3PropPage)
      DDX_CONTROL(IDC_COMBO_SERVER, m_servers_list)
      DDX_CONTROL(IDC_LIST, m_share_list)
   END_DDX_MAP()

   void SetParentExt(CPropShellExt * pExt)
   {
      m_pParentExt = pExt;
   }

protected:
   void RecurseVDirs(CMetaEnumerator& en, LPCTSTR path);
   void EnableOnShare();
   void EnableEditRemove();

protected:
   CComboBoxExch m_servers_list;
   CListBoxExch m_share_list;
   BOOL m_ShareThis;
   CPropShellExt * m_pParentExt;
};

#endif //__W3PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\adminacl.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    adminacl.cpp

Abstract:

    Contains implementation of CAdminACL

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#define REF

#include "iisprov.h"
#include "adminacl.h"
#include <adserr.h>

CAdminACL::CAdminACL()
{
    m_pADs  = NULL;
    m_pSD   = NULL;
    m_pDACL = NULL;
}

CAdminACL::~CAdminACL()
{
    CloseSD();
}

void CAdminACL::CloseSD()
{
    if(m_pDACL)
    {
        m_pDACL->Release();
        m_pDACL = NULL;
    }

    if(m_pSD)
    {
        m_pSD->Release();
        m_pSD = NULL;
    }

    if(m_pADs)
    {
        m_pADs->Release();
        m_pADs = NULL;
    }
}

HRESULT CAdminACL::GetObjectAsync(
    IWbemClassObject* pObj,
    ParsedObjectPath* pParsedObject,
    WMI_CLASS*        pWMIClass)
{
    DBG_ASSERT(m_pSD);
    DBG_ASSERT(m_pDACL);

    HRESULT hr = S_OK;

    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL )
    {
        hr = PopulateWmiAdminACL(pObj);
    }
    else if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE )
    {
        _bstr_t bstrTrustee;
        GetTrustee(pObj, pParsedObject, bstrTrustee); 
        CACEEnumOperation_FindAndReturn op(this, pObj, bstrTrustee);
        hr = EnumACEsAndOp(REF op);
    }
    else
    {
        DBG_ASSERT(false && "Only valid on AdminACL and AdminACE classes");
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CAdminACL::EnumerateACEsAndIndicate(
    BSTR             i_bstrNameValue,
    CWbemServices&   i_refNamespace,
    IWbemObjectSink& i_refWbemObjectSink)
{
    DBG_ASSERT(m_pSD);
    DBG_ASSERT(m_pDACL);

    CACEEnumOperation_IndicateAll op(
        i_bstrNameValue,
        REF i_refNamespace, 
        REF i_refWbemObjectSink);
    return EnumACEsAndOp(REF op);
}

HRESULT CAdminACL::DeleteObjectAsync(
    ParsedObjectPath* pParsedObject)
{
    HRESULT hr = S_OK;
    _bstr_t bstrTrustee;

    //
    // get the trustee from key
    //
    GetTrustee(NULL, pParsedObject, bstrTrustee); 

    //
    // remove the ACE
    //
    DBG_ASSERT(m_pDACL);
    CACEEnumOperation_FindAndRemove op(this, bstrTrustee);
    hr = EnumACEsAndOp(REF op);

    //
    // set the modified AdminACL back into the metabase
    //
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}

HRESULT CAdminACL::PutObjectAsync(
    IWbemClassObject* pObj,
    ParsedObjectPath* pParsedObject,
    WMI_CLASS*        pWMIClass)
{
    DBG_ASSERT(m_pSD);
    DBG_ASSERT(m_pDACL);

    HRESULT hr = S_OK;

    if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL )
    {
        hr = SetADSIAdminACL(pObj);
    }
    else if( pWMIClass->pkt == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE )
    {
        _bstr_t bstrTrustee;
        GetTrustee(NULL, pParsedObject, bstrTrustee);

        CACEEnumOperation_FindAndUpdate op(this, pObj, bstrTrustee);
        hr = EnumACEsAndOp(REF op);
        if(hr == WBEM_E_NOT_FOUND)
        {
            hr = AddACE(pObj, bstrTrustee);
        }
    }
    else
    {
        DBG_ASSERT(false && "Only valid on AdminACL and AdminACE");
        hr = E_INVALIDARG;
    }

    // set the modified AdminACL back into the metabase
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}

HRESULT CAdminACL::PopulateWmiAdminACL(
    IWbemClassObject* pObj
    )
{
    VARIANT     vt;
    HRESULT     hr = S_OK;

    // Owner
    vt.vt = VT_BSTR;
    hr = m_pSD->get_Owner(&vt.bstrVal);
    if(SUCCEEDED(hr))
    {
        hr = pObj->Put(L"Owner", 0, &vt, 0);
        VariantClear(&vt);
    }

    // Group
    vt.vt = VT_BSTR;
    if(SUCCEEDED(hr))
       hr = m_pSD->get_Group(&vt.bstrVal);
    if(SUCCEEDED(hr))
    {
        hr = pObj->Put(L"Group", 0, &vt, 0);
        VariantClear(&vt);
    }
    
    // ControlFlags
    vt.vt = VT_I4;
    if(SUCCEEDED(hr))
        hr = m_pSD->get_Control(&vt.lVal);
    if(SUCCEEDED(hr))
    {
        hr = pObj->Put(L"ControlFlags", 0, &vt, 0);
        VariantClear(&vt);
    }

    return hr;
}

HRESULT CAdminACL::SetADSIAdminACL(
    IWbemClassObject* pObj
    )
{
    VARIANT     vt;
    HRESULT     hr;

    // Owner
    hr = pObj->Get(L"Owner", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = m_pSD->put_Owner(vt.bstrVal);
    VariantClear(&vt);

    // Owner
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"Group", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = m_pSD->put_Group(vt.bstrVal);
    VariantClear(&vt);

    // ControlFlags
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"ControlFlags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = m_pSD->put_Control(vt.lVal); 
    VariantClear(&vt);

    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
    }
    return hr;
}

HRESULT CAdminACL::OpenSD(
    LPCWSTR wszMbPath)
{
    DBG_ASSERT(wszMbPath);

    CComVariant svar;
    HRESULT     hr    = S_OK;

    // close SD interface first
    CloseSD();

    CComBSTR sbstrAdsPath;
    hr = GetAdsPath(wszMbPath, &sbstrAdsPath);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    // get m_pADs
    hr = ADsGetObject(
         sbstrAdsPath,
         IID_IADs,
         (void**)&m_pADs
         );
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }
     
    // get m_pSD
    hr = m_pADs->Get(L"AdminACL",&svar);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        if(hr == E_ADS_PROPERTY_NOT_SUPPORTED)
        {
            //
            // Do this, so WMI does not fail query operations.
            //
            hr = WBEM_E_NOT_FOUND;
        }
        return hr;
    }
    
    hr = V_DISPATCH(&svar)->QueryInterface(
        IID_IADsSecurityDescriptor,
        (void**)&m_pSD
        );
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    // get m_pDACL
    CComPtr<IDispatch> spDisp;
    hr = m_pSD->get_DiscretionaryAcl(&spDisp);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    hr = spDisp->QueryInterface(
       IID_IADsAccessControlList, 
       (void**)&m_pDACL
       );
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }
    
    return hr;
}


HRESULT CAdminACL::SetSD()
{
    VARIANT    var;
    HRESULT    hr    = S_OK;
    IDispatch* pDisp = NULL;

    // put m_pDACL
    hr = m_pDACL->QueryInterface(
       IID_IDispatch, 
       (void**)&pDisp
       );
    if(FAILED(hr))
        return hr;

    hr = m_pSD->put_DiscretionaryAcl(pDisp);
    pDisp->Release();
    if(FAILED(hr))
       return hr;

    //
    // put AdminACL
    //
    hr = m_pSD->QueryInterface(
        IID_IDispatch,
        (void**)&pDisp
        );
    if(FAILED(hr))
       return hr;

    var.vt = VT_DISPATCH;
    var.pdispVal = pDisp;
    hr = m_pADs->Put(L"AdminACL",var);  // pDisp will be released by this call Put().
    if(FAILED(hr))
       return hr;

    //
    // Commit the change to the active directory
    //
    hr = m_pADs->SetInfo();

    return hr;
}

HRESULT CAdminACL::GetAdsPath(
    LPCWSTR     i_wszMbPath,
    BSTR*       o_pbstrAdsPath)
{
    DBG_ASSERT(i_wszMbPath);
    DBG_ASSERT(o_pbstrAdsPath);
    DBG_ASSERT(*o_pbstrAdsPath == NULL);

    CComBSTR sbstr(L"IIS://LocalHost");
    if(sbstr.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // trim the first three characters "/LM"
    //
    sbstr += (i_wszMbPath+3);
    if(sbstr.m_str == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // Set out params if everything succeeds
    //
    *o_pbstrAdsPath = sbstr.Detach();
    return S_OK;
}

HRESULT CAdminACL::EnumACEsAndOp(
    CACEEnumOperation_Base&  refOp)
/*++

Synopsis: 
    This enumerates all the aces for the current acl.

Arguments: [refOp] - Implements Do, and Done.  It is okay if Do throws exceptions.
                     This function will cleanup correctly.
           
Return Value: 

--*/
{
    HRESULT                         hr = S_OK;
    CComVariant                     var;
    CComPtr<IEnumVARIANT>           spEnum;
    ULONG                           lFetch;
    CComPtr<IADsAccessControlEntry> spACE;

    hr = GetACEEnum(&spEnum);
    if ( FAILED(hr) )
        return hr;

    //
    // Enumerate ACEs
    //
    hr = spEnum->Next( 1, &var, &lFetch );
    while( hr == S_OK )
    {
        if (lFetch == 1)
        {
            if (VT_DISPATCH != V_VT(&var))
            {
                hr = E_UNEXPECTED;
                break;
            }

            //
            // Get the individual ACE
            //
            hr = V_DISPATCH(&var)->QueryInterface(
                IID_IADsAccessControlEntry, 
                (void**)&spACE);

            if ( SUCCEEDED(hr) )
            {
                hr = refOp.Do(spACE);
                if(FAILED(hr))
                {
                    DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
                    return hr;
                }
                if(refOp.Done() == CACEEnumOperation_Base::eDONE_YES)
                {
                    break;
                }
                spACE = NULL;
           }
        }
        var.Clear();

        hr = spEnum->Next( 1, &var, &lFetch );
        if(hr == S_FALSE && refOp.Done() == CACEEnumOperation_Base::eDONE_NO)
        {
            hr = WBEM_E_NOT_FOUND;
            DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
            return hr;
        }
    }

    return hr;
}

void CAdminACL::GetTrustee(
    IWbemClassObject* pObj,
    ParsedObjectPath* pPath,    
    _bstr_t&          bstrTrustee 
    )
/*++

Synopsis: 
    parse ParsedObjectPath to get the Trustee key

Arguments: [pObj] - 
           [pPath] - 
           [bstrTrustee] - 
           
--*/
{
    KeyRef* pkr;
    WCHAR*  pszKey = L"Trustee";

    pkr = CUtils::GetKey(pPath, pszKey);
    if(pkr->m_vValue.vt == VT_BSTR && pkr->m_vValue.bstrVal != NULL)
    {
        bstrTrustee = pkr->m_vValue;
    }
    else
    {
        THROW_ON_ERROR(WBEM_E_INVALID_OBJECT);
    }

    if (pObj)
    {
        _bstr_t bstr = pkr->m_pName;
        HRESULT hr = pObj->Put(bstr, 0, &pkr->m_vValue, 0);
        THROW_ON_ERROR(hr);
    }
}


HRESULT CAdminACL::GetACEEnum(
    IEnumVARIANT** pEnum)
{
    HRESULT hr = S_OK;
    LPUNKNOWN  pUnk = NULL;

    DBG_ASSERT(pEnum);

    if(*pEnum)
    {
        (*pEnum)->Release();
    }

    hr = m_pDACL->get__NewEnum( &pUnk );
    if ( SUCCEEDED(hr) )
    {
        hr = pUnk->QueryInterface( IID_IEnumVARIANT, (void**) pEnum );
    }

    return hr;
}

HRESULT CAdminACL::AddACE(
    IWbemClassObject* pObj,
    _bstr_t& bstrTrustee
    )
/*++

Synopsis: 
    Add an ACE.

Arguments: [pObj] - 
           [bstrTrustee] - 
           
Return Value: 

--*/
{
    HRESULT hr = m_pDACL->put_AclRevision(ADS_SD_REVISION_DS);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    // create a ACE
    IADsAccessControlEntry* pACE = NULL; 
    hr = NewACE(
        pObj,
        bstrTrustee,
        &pACE);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed, hr: 0x%x\n", hr));
        return hr;
    }

    // add the ACE
    IDispatch* pDisp = NULL;
    hr = pACE->QueryInterface(IID_IDispatch,(void**)&pDisp);
    if(SUCCEEDED(hr))
    {
        hr = m_pDACL->AddAce(pDisp);
        pDisp->Release();
    }

    pACE->Release();

    return hr;
}

HRESULT CAdminACL::NewACE(
    IWbemClassObject* pObj,
    _bstr_t& bstrTrustee,
    IADsAccessControlEntry** ppACE
    )
/*++

Synopsis: 
    function to create an ACE

Arguments: [pObj] - 
           [bstrTrustee] - 
           [ppACE] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(ppACE);

    HRESULT hr = CoCreateInstance(
        CLSID_AccessControlEntry,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IADsAccessControlEntry,
        (void**)ppACE);

    //
    // Trustee
    //
    if(SUCCEEDED(hr))
        hr = (*ppACE)->put_Trustee(bstrTrustee); 

    if(SUCCEEDED(hr))
        hr = SetDataOfACE(pObj, *ppACE);

    return hr;
}


HRESULT CAdminACL::SetDataOfACE(
    IWbemClassObject* pObj,
    IADsAccessControlEntry* pACE
    )
{
    HRESULT     hr;
    CComVariant vt;

    //
    // AccessMask
    //
    hr = pObj->Get(L"AccessMask", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AccessMask(vt.lVal); 
    vt.Clear();

    //
    // AceType
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"AceType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AceType(vt.lVal); 
    vt.Clear();

    //
    // AceFlags
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"AceFlags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AceFlags(vt.lVal); 
    vt.Clear();

    //
    // Flags
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"Flags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_Flags(vt.lVal); 
    vt.Clear();

    //
    // ObjectType
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"ObjectType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = pACE->put_ObjectType(vt.bstrVal); 
    vt.Clear();

    //
    // InheritedObjectType
    //
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"InheritedObjectType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = pACE->put_InheritedObjectType(vt.bstrVal); 
    vt.Clear();

    return hr;
}

//
// CACEEnumOperation_Base
//

HRESULT CACEEnumOperation_Base::PopulateWmiACE(
    IWbemClassObject* pObj,
    IADsAccessControlEntry* pACE
    )
{
    _variant_t vt;
    BSTR bstr;
    long lVal;
    HRESULT hr;

    // AccessMask
    hr = pACE->get_AccessMask(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AccessMask", 0, &vt, 0);
    }

    // AceType
    if(SUCCEEDED(hr))
       hr = pACE->get_AceType(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AceType", 0, &vt, 0);
    }
    
    // AceFlags
    if(SUCCEEDED(hr))
       hr = pACE->get_AceFlags(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AceFlags", 0, &vt, 0);
    }

    // Flags
    if(SUCCEEDED(hr))
       hr = pACE->get_Flags(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"Flags", 0, &vt, 0);
    }
    
    // ObjectType
    if(SUCCEEDED(hr))
       hr = pACE->get_ObjectType(&bstr);
    if(SUCCEEDED(hr))
    {
        vt = bstr;
        hr = pObj->Put(L"ObjectType", 0, &vt, 0);
        SysFreeString(bstr);
    }

    // InheritedObjectType
    if(SUCCEEDED(hr))
       hr = pACE->get_InheritedObjectType(&bstr);
    if(SUCCEEDED(hr))
    {
        vt = bstr;
        hr = pObj->Put(L"InheritedObjectType", 0, &vt, 0);
        SysFreeString(bstr);
    }
 
    return hr;
}

//
// CACEEnumOperation_IndicateAll
//

HRESULT CAdminACL::CACEEnumOperation_IndicateAll::Do(
    IADsAccessControlEntry* pACE)
{
    DBG_ASSERT(pACE);

    if(FAILED(m_hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", m_hr));
        return m_hr;
    }

    CComPtr<IWbemClassObject> spInstance;

    HRESULT hr = m_spClass->SpawnInstance(0, &spInstance);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    hr = spInstance->Put(
        WMI_CLASS_DATA::s_ACE.pszKeyName,
        0,
        &m_vNameValue,
        0);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    CComBSTR sbstrTrustee;
    hr = pACE->get_Trustee(&sbstrTrustee);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    VARIANT vTrustee;
    vTrustee.bstrVal = sbstrTrustee;
    vTrustee.vt      = VT_BSTR;
    hr = spInstance->Put(L"Trustee", 0, &vTrustee, 0);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    hr = PopulateWmiACE(spInstance, pACE);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    hr = m_pWbemObjectSink->Indicate(1, &spInstance);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    return hr;
}

//
// CACEEnumOperation_Find
//

HRESULT CAdminACL::CACEEnumOperation_Find::Do(
    IADsAccessControlEntry* pACE)
{
    DBG_ASSERT(pACE);
    DBG_ASSERT(m_eDone == eDONE_NO);

    CComBSTR sbstr;

    HRESULT hr = pACE->get_Trustee(&sbstr);
    if(FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
        return hr;
    }

    if(_wcsicmp(sbstr, m_bstrTrustee) == 0)
    {
        m_eDone = eDONE_YES;
        hr = DoOnMatch(pACE);
        if(FAILED(hr))
        {
            DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
            return hr;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\appladmin.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    appladmin.h

Abstract:

    This file contains definition of:
        CAppPoolMethod, CWebAppMethod

Author:

    ???

Revision History:

    Mohit Srivastava            21-Jan-01

--*/

#ifndef _appladmin_h_
#define _appladmin_h_

#include <atlbase.h>

class CAppPoolMethod
{
public:
    CAppPoolMethod();
    ~CAppPoolMethod();

    void GetCurrentMode(
        VARIANT* io_pvtServerMode);

    void Start(
        LPCWSTR i_wszMbPath);

    void Stop(
        LPCWSTR i_wszMbPath);

    void RecycleAppPool(
        LPCWSTR  i_wszMbPath);

    void EnumAppsInPool(
        LPCWSTR  i_wszMbPath,
        VARIANT* io_pvtApps);

    void DeleteAppPool(
        LPCWSTR  i_wszMbPath);

private:

    void GetPtrToAppPool(
        LPCWSTR  i_wszMbPath,
        LPCWSTR* o_pwszAppPool);

    void SetState(
        LPCWSTR i_wszMbPath,
        DWORD dwState);

    CComPtr<IIISApplicationAdmin> m_spAppAdmin;
};

class CWebAppMethod
{
private:

    IIISApplicationAdmin*   m_pAppAdmin;
    IWamAdmin2*             m_pWamAdmin2;

public:

    CWebAppMethod();
    ~CWebAppMethod();
    
    HRESULT AppCreate(LPCWSTR, bool, LPCWSTR, bool);
    HRESULT AppCreate2(LPCWSTR, long, LPCWSTR, bool);
    HRESULT AppDelete(LPCWSTR, bool);
    HRESULT AppUnLoad(LPCWSTR, bool);
    HRESULT AppDisable(LPCWSTR, bool);
    HRESULT AppEnable(LPCWSTR, bool);
    HRESULT AppGetStatus(LPCWSTR, DWORD*);
    HRESULT AspAppRestart(LPCWSTR);
};

#endif // _appladmin_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\adminacl.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    adminacl.h

Abstract:

    Contains definition of CAdminACL

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _adminacl_h_
#define _adminacl_h_

#include <iads.h>
#include <adshlp.h>

#include <atlbase.h>
#include <comutil.h>
#include <dbgutil.h>

//
// A parameter to the GetACE function.  As we enumerate the ACEs,
// we call IACEEnumOperation::Do.
// Then, we call Done to see whether to continue enumeration.
//
class CACEEnumOperation_Base
{
public:
    enum eDone
    {
        eDONE_YES,
        eDONE_NO,
        eDONE_DONT_KNOW
    };

    virtual HRESULT Do(
        IADsAccessControlEntry* pACE)   = 0;

    virtual eDone   Done() = 0;

protected:
    HRESULT PopulateWmiACE(
        IWbemClassObject* pObj,
        IADsAccessControlEntry* pACE);
};

class CAdminACL
{
    friend class CAssocACLACE;

private:

    IADs* m_pADs;
    IADsSecurityDescriptor* m_pSD;
    IADsAccessControlList* m_pDACL;

    //
    // Indicate all ACEs we enum to WMI.
    //
    class CACEEnumOperation_IndicateAll : public CACEEnumOperation_Base
    {
    public:
        CACEEnumOperation_IndicateAll(
            BSTR             i_bstrNameValue,
            CWbemServices&   i_refNamespace,
            IWbemObjectSink& i_refWbemObjectSink)
        {
            m_vNameValue.bstrVal = i_bstrNameValue;
            m_vNameValue.vt      = VT_BSTR;
            m_pNamespace         = &i_refNamespace;
            m_pWbemObjectSink    = &i_refWbemObjectSink;
            m_hr                 = WBEM_S_NO_ERROR;

            m_hr = m_pNamespace->GetObject(
                WMI_CLASS_DATA::s_ACE.pszClassName, 
                0, 
                NULL, 
                &m_spClass,
                NULL);
            if(FAILED(m_hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", m_hr));
                return;
            }
        }

        virtual HRESULT Do(
            IADsAccessControlEntry* pACE);

        virtual eDone Done() { return eDONE_DONT_KNOW; }

    private:
        CWbemServices*   m_pNamespace;
        IWbemObjectSink* m_pWbemObjectSink;
        VARIANT          m_vNameValue;

        HRESULT          m_hr;

        CComPtr<IWbemClassObject> m_spClass;
    };

    //
    // Find the matching ACE.
    //
    class CACEEnumOperation_Find : public CACEEnumOperation_Base
    {
    public:
        CACEEnumOperation_Find(
            CAdminACL*        pAdminACL,
            BSTR              bstrTrustee)
        {
            DBG_ASSERT(pAdminACL);
            DBG_ASSERT(bstrTrustee);

            m_pAdminACL   = pAdminACL;
            m_bstrTrustee = bstrTrustee;
            m_eDone       = eDONE_NO;
        }

        virtual HRESULT Do(
            IADsAccessControlEntry* pACE);

        virtual eDone Done() { return m_eDone; }

    protected:
        eDone                     m_eDone;

        CAdminACL*                m_pAdminACL;
        BSTR                      m_bstrTrustee;

        virtual HRESULT DoOnMatch(
            IADsAccessControlEntry* pACE) = 0;
    };

    //
    // Find and return the matching ACE.
    //
    class CACEEnumOperation_FindAndReturn : public CACEEnumOperation_Find
    {
    public:
        CACEEnumOperation_FindAndReturn(
            CAdminACL*        pAdminACL,
            IWbemClassObject* pObj,
            BSTR              bstrTrustee) : 
            CACEEnumOperation_Find(pAdminACL, bstrTrustee) 
        {
            DBG_ASSERT(pObj);
            m_spObj = pObj;
        }
    protected:
        virtual HRESULT DoOnMatch(
            IADsAccessControlEntry* pACE)
        {
            DBG_ASSERT(pACE);
            return PopulateWmiACE(m_spObj, pACE);
        }
    private:
        CComPtr<IWbemClassObject> m_spObj;
    };

    //
    // Find and update the matching ACE.
    //
    class CACEEnumOperation_FindAndUpdate : public CACEEnumOperation_Find
    {
    public:
        CACEEnumOperation_FindAndUpdate(
            CAdminACL*        pAdminACL,
            IWbemClassObject* pObj,
            BSTR              bstrTrustee) : 
            CACEEnumOperation_Find(pAdminACL, bstrTrustee) 
        {
            DBG_ASSERT(pObj);
            m_spObj = pObj;
        }
    protected:
        virtual HRESULT DoOnMatch(
            IADsAccessControlEntry* pACE)
        {
            DBG_ASSERT(pACE);
            return m_pAdminACL->SetDataOfACE(m_spObj, pACE);
        }
    private:
        CComPtr<IWbemClassObject> m_spObj;
    };

    //
    // Find and remove the matching ACE.
    //
    class CACEEnumOperation_FindAndRemove : public CACEEnumOperation_Find
    {
    public:
        CACEEnumOperation_FindAndRemove(
            CAdminACL*        pAdminACL,
            BSTR              bstrTrustee) : 
            CACEEnumOperation_Find(pAdminACL, bstrTrustee) 
        {
        }
    protected:
        virtual HRESULT DoOnMatch(
            IADsAccessControlEntry* pACE)
        {
            DBG_ASSERT(pACE);

            CComPtr<IDispatch> spDisp;
            HRESULT hr = pACE->QueryInterface(IID_IDispatch,(void**)&spDisp);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
                return hr;
            }
        
            hr = m_pAdminACL->m_pDACL->RemoveAce(spDisp);
            if(FAILED(hr))
            {
                DBGPRINTF((DBG_CONTEXT, "Failure, hr=0x%x\n", hr));
                return hr;
            }

            return hr;
        }
    };

public:

    CAdminACL();
    ~CAdminACL();

    HRESULT GetObjectAsync(
        IWbemClassObject* pObj,
        ParsedObjectPath* pParsedObject,
        WMI_CLASS* pWMIClass
        ); 

    HRESULT PutObjectAsync(
        IWbemClassObject* pObj,
        ParsedObjectPath* pParsedObject,
        WMI_CLASS* pWMIClass
        );

    HRESULT EnumerateACEsAndIndicate(
        BSTR             i_bstrNameValue,
        CWbemServices&   i_refNamespace,
        IWbemObjectSink& i_refWbemObjectSink);

    HRESULT DeleteObjectAsync(ParsedObjectPath* pParsedObject);

    HRESULT OpenSD(
        LPCWSTR wszMbPath);
    
    void CloseSD();

    HRESULT GetACEEnum(IEnumVARIANT** pEnum);

private:

    HRESULT SetSD();

    HRESULT CAdminACL::GetAdsPath(
        LPCWSTR     i_wszMbPath,
        BSTR*       o_pbstrAdsPath);

    //
    // ACL stuff
    //
    
    HRESULT PopulateWmiAdminACL(IWbemClassObject* pObj);
    
    HRESULT SetADSIAdminACL(
        IWbemClassObject* pObj);

    //
    // ACE stuff
    //

    HRESULT EnumACEsAndOp(
        CACEEnumOperation_Base& refOp);

    void GetTrustee(
        IWbemClassObject* pObj,
        ParsedObjectPath* pPath,    
        _bstr_t&          bstrTrustee);

    HRESULT AddACE(
        IWbemClassObject* pObj,
        _bstr_t& bstrTrustee);

    HRESULT NewACE(
        IWbemClassObject* pObj,
        _bstr_t& bstrTrustee,
        IADsAccessControlEntry** ppACE);

    HRESULT SetDataOfACE(
        IWbemClassObject* pObj,
        IADsAccessControlEntry* pACE);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\assocaclace.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocACLACE.cpp

Abstract:

    Implementation of:
    CAssocACLACE

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#include <dbgutil.h>
#include <atlbase.h>
#include "AssocACLACE.h"
#include "utils.h"
#include "SmartPointer.h"

CAssocACLACE::CAssocACLACE(
    CWbemServices*     i_pNamespace,
    IWbemObjectSink*   i_pResponseHandler) : 
    CAssocBase(i_pNamespace, i_pResponseHandler, &WMI_ASSOCIATION_DATA::s_AdminACLToACE)
{
}

void CAssocACLACE::GetInstances(
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp) //defaultvalue(NULL)
{
    DBG_ASSERT(m_pNamespace);
    DBG_ASSERT(i_pExp);

    SQL_LEVEL_1_TOKEN* pTokenACL  = NULL;  // left part of assoc
    SQL_LEVEL_1_TOKEN* pTokenACE = NULL;   // right part of assoc

    //
    // Walk thru tokens
    // Don't do query if we find OR or NOT
    // Record match for left and/or right part of association.
    //
    bool  bDoQuery = true;
    ProcessQuery(
        i_pExp,
        m_pWmiAssoc,
        &pTokenACL, // points to i_pExp, does not need to be cleaned up
        &pTokenACE, // points to i_pExp, does not need to be cleaned up
        &bDoQuery);

    if( !bDoQuery || (pTokenACL == NULL && pTokenACE == NULL))
    {
        GetAllInstances(m_pWmiAssoc);
        return;
    }

    //
    // We need to get just a single association instance.  If we were provided
    // at least a ACL or a ACE part, we have enough information.
    //
    DBG_ASSERT(pTokenACL != NULL || pTokenACE != NULL);

    if(pTokenACL && pTokenACE)
    {
        Indicate(pTokenACL->vConstValue.bstrVal, pTokenACE->vConstValue.bstrVal);
    }
    else if(pTokenACE)
    {
        _bstr_t sbstrPath;

        TSmartPointer<ParsedObjectPath> spParsedACLObjPath = NULL;
        if (m_PathParser.Parse(pTokenACE->vConstValue.bstrVal, &spParsedACLObjPath) 
            != CObjectPathParser::NoError)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }

        KeyRef* pkr = CUtils::GetKey(
            spParsedACLObjPath, 
            m_pWmiAssoc->pcRight->pszKeyName);

        sbstrPath = pkr->m_vValue.bstrVal;

        //
        // Make the ACL Object Path
        //
        BOOL    bRet = true;

        bRet = spParsedACLObjPath->SetClassName(
            m_pWmiAssoc->pcLeft->pszClassName);
        THROW_ON_FALSE(bRet);

        VARIANT vtPath;
        vtPath.vt      = VT_BSTR;
        vtPath.bstrVal = sbstrPath;
        spParsedACLObjPath->ClearKeys();
        bRet = spParsedACLObjPath->AddKeyRef(
            m_pWmiAssoc->pcLeft->pszKeyName,
            &vtPath);
        THROW_ON_FALSE(bRet);

        Indicate(spParsedACLObjPath, pTokenACE->vConstValue.bstrVal);
    }
    else
    {
        //
        // pTokenACL && !pTokenACE
        //
        CComBSTR           sbstr;

        TSmartPointer<ParsedObjectPath> spParsedACEObjPath = NULL;
        if (m_PathParser.Parse(pTokenACL->vConstValue.bstrVal, &spParsedACEObjPath) 
            != CObjectPathParser::NoError)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }


        //
        // Start with the ACL part of the association.  Convert it to an ACE part.
        //
        if(!spParsedACEObjPath->SetClassName(m_pWmiAssoc->pcRight->pszClassName))
        {
            THROW_ON_ERROR(WBEM_E_FAILED);
        }

        sbstr =  m_pWmiAssoc->pcLeft->pszMetabaseKey;
		sbstr += L"/";

        KeyRef* pkr = CUtils::GetKey(
            spParsedACEObjPath, 
            m_pWmiAssoc->pcLeft->pszKeyName);
        DBG_ASSERT(pkr);

        sbstr += pkr->m_vValue.bstrVal;
        if(sbstr.m_str == NULL)
        {
            THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
        }

        //
        // CloseSD called automatically
        //
        CAdminACL AdminAcl;
        HRESULT hr = AdminAcl.OpenSD(sbstr);
        THROW_ON_ERROR(hr);

        CACEEnumOperation_IndicateAllAsAssoc op(
            this,
            pTokenACL->vConstValue.bstrVal,
            spParsedACEObjPath);
        hr = AdminAcl.EnumACEsAndOp(/*ref*/ op);
        THROW_ON_ERROR(hr);
    }
}

HRESULT CAssocACLACE::CACEEnumOperation_IndicateAllAsAssoc::Do(
    IADsAccessControlEntry* pACE)
{
    DBG_ASSERT(pACE);

    CComBSTR sbstrTrustee;

    HRESULT hr = pACE->get_Trustee(&sbstrTrustee);
    if(FAILED(hr))
    {
        return hr;
    }

    //
    // add keyref
    //
    VARIANT vTrustee;
    vTrustee.bstrVal = sbstrTrustee;
    vTrustee.vt      = VT_BSTR;
    THROW_ON_FALSE(m_pParsedACEObjPath->AddKeyRefEx(L"Trustee",&vTrustee));

    m_pAssocACLACE->Indicate(m_bstrACLObjPath, m_pParsedACEObjPath);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\appladmin.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    appladmin.cpp

Abstract:

    This file contains implementation of:
        CAppPoolMethod, CWebAppMethod

Author:

    ???

Revision History:

    Mohit Srivastava            21-Jan-01

--*/


#include "iisprov.h"
#include "appladmin.h"
#include "MultiSzHelper.h"
#include "iiswmimsg.h"

//
// CApplAdmin
//

CAppPoolMethod::CAppPoolMethod()
{
    HRESULT hr = CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IIISApplicationAdmin,
        (void**)&m_spAppAdmin);

    THROW_ON_ERROR(hr);
}

CAppPoolMethod::~CAppPoolMethod()
{
}

void CAppPoolMethod::GetCurrentMode(
    VARIANT* io_pvtServerMode)
/*++

Synopsis: 
    This method, unlike the others, is actually on the IIsWebService node.

Arguments: [io_pvtServerMode] - 
           
--*/
{
    DBG_ASSERT(io_pvtServerMode != NULL);

    DWORD dwServerMode = 0;
    VariantInit(io_pvtServerMode);

    HRESULT hr = m_spAppAdmin->GetProcessMode(&dwServerMode);
    THROW_ON_ERROR(hr);

    io_pvtServerMode->vt   = VT_I4;
    io_pvtServerMode->lVal = dwServerMode;
}

void CAppPoolMethod::Start(
    LPCWSTR i_wszMbPath)
{
    DBG_ASSERT(i_wszMbPath != NULL);

    SetState(i_wszMbPath, MD_APPPOOL_COMMAND_START);
}

void CAppPoolMethod::Stop(
    LPCWSTR i_wszMbPath)
{
    DBG_ASSERT(i_wszMbPath != NULL);

    SetState(i_wszMbPath, MD_APPPOOL_COMMAND_STOP);
}

void CAppPoolMethod::RecycleAppPool(
    LPCWSTR i_wszMbPath)
{
    DBG_ASSERT(i_wszMbPath    != NULL);
    
    LPCWSTR wszAppPool = NULL;
    GetPtrToAppPool(i_wszMbPath, &wszAppPool);

    HRESULT hr = m_spAppAdmin->RecycleApplicationPool(wszAppPool);
    THROW_ON_ERROR(hr);
}

void CAppPoolMethod::EnumAppsInPool(
    LPCWSTR  i_wszMbPath,
    VARIANT* io_pvtApps)
/*++

Synopsis: 

Arguments: [i_wszMbPath] - 
           [io_pvtApps] - Will be an array of strings
           
--*/
{
    DBG_ASSERT(i_wszMbPath  != NULL);
    DBG_ASSERT(io_pvtApps != NULL);

    CComBSTR sbstrApps = NULL;
    VariantInit(io_pvtApps);

    LPCWSTR wszAppPool = NULL;
    GetPtrToAppPool(i_wszMbPath, &wszAppPool);

    HRESULT hr = m_spAppAdmin->EnumerateApplicationsInPool(
        wszAppPool,
        &sbstrApps);
    THROW_ON_ERROR(hr);

    CMultiSz MultiSz;

    hr = MultiSz.ToWmiForm(
        sbstrApps,
        io_pvtApps);
    THROW_ON_ERROR(hr);
}

void CAppPoolMethod::DeleteAppPool(
    LPCWSTR i_wszMbPath)
{
    DBG_ASSERT(i_wszMbPath);

    LPCWSTR wszAppPool = NULL;
    GetPtrToAppPool(i_wszMbPath, &wszAppPool);

    HRESULT hr = m_spAppAdmin->DeleteApplicationPool(wszAppPool);
    THROW_ON_ERROR(hr);
}

//
// CAppPoolMethod - private methods
//

void CAppPoolMethod::GetPtrToAppPool(
    LPCWSTR  i_wszMbPath,
    LPCWSTR* o_pwszAppPool)
/*++

Synopsis: 

Arguments: [i_wszMbPath] - 
           [o_wszAppPool] - This is a ptr to i_wszMbPath.  Does not need to be
                            freed by caller.
           
--*/
{
    DBG_ASSERT(i_wszMbPath);
    DBG_ASSERT(o_pwszAppPool);
    DBG_ASSERT(*o_pwszAppPool == NULL);

    DBG_ASSERT(i_wszMbPath[0] == L'/');
    DBG_ASSERT(i_wszMbPath[1] != L'\0');

    LPWSTR wszAppPool = (LPWSTR)wcsrchr(i_wszMbPath, L'/');

    *wszAppPool = L'\0';
    if(_wcsicmp(i_wszMbPath, L"/LM/w3svc/AppPools") != 0)
    {
        *wszAppPool = L'/';
        CIIsProvException e;
        e.SetMC(WBEM_E_FAILED, IISWMI_INVALID_APPPOOL_CONTAINER, i_wszMbPath);
        throw e;
    }

    *wszAppPool = L'/';

    //
    // Set out params on success
    //
    *o_pwszAppPool = wszAppPool + 1;
}

void CAppPoolMethod::SetState(
    LPCWSTR i_wszMbPath,
    DWORD dwState)
{
    METADATA_HANDLE        hObjHandle = NULL;
    DWORD                  dwBufferSize = sizeof(DWORD);
    METADATA_RECORD        mdrMDData;
    LPBYTE                 pBuffer = (LPBYTE)&dwState;
    CMetabase              metabase;
    CComPtr<IMSAdminBase2> spIABase = (IMSAdminBase2*)metabase;

    HRESULT hr = spIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        i_wszMbPath,
        METADATA_PERMISSION_WRITE,
        DEFAULT_TIMEOUT_VALUE,         // 30 seconds
        &hObjHandle 
        );

    THROW_ON_ERROR(hr);

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_APPPOOL_COMMAND,
                       METADATA_VOLATILE,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = spIABase->SetData(
                hObjHandle,
                L"",
                &mdrMDData
                );

    spIABase->CloseKey(hObjHandle);

    THROW_ON_ERROR(hr);
}

//
// CWebAppMethod
//

CWebAppMethod::CWebAppMethod()
{ 
    HRESULT hr = CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IIISApplicationAdmin,
        (void**)&m_pAppAdmin
        );

    hr = CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IWamAdmin2,
        (void**)&m_pWamAdmin2
        );

    THROW_ON_ERROR(hr);
}

CWebAppMethod::~CWebAppMethod()
{
    if(m_pAppAdmin)
        m_pAppAdmin->Release();

    if(m_pWamAdmin2)
        m_pWamAdmin2->Release();
}


HRESULT CWebAppMethod::AppCreate( 
    LPCWSTR szMetaBasePath, 
    bool bInProcFlag,
    LPCWSTR szAppPoolName,
    bool bCreatePool
    )
{
    HRESULT hr;
    LPWSTR szActualName;
    BOOL bActualCreation = FALSE;

    if (szAppPoolName) {
        szActualName = (LPWSTR)szAppPoolName;
    }
    else {
        szActualName = NULL;
    }

    if (bCreatePool != true) {
        bActualCreation = FALSE;
    }
    else {
        bActualCreation = TRUE;
    }

    hr = m_pAppAdmin->CreateApplication(
        szMetaBasePath,
        bInProcFlag ? 0 : 2,  // 0 for InProc, 2 for Pooled Proc
        szActualName,
        bActualCreation   // Don't create - DefaultAppPool should already be there
        );

    return hr;
}

HRESULT CWebAppMethod::AppCreate2( 
    LPCWSTR szMetaBasePath, 
    long lAppMode,
    LPCWSTR szAppPoolName,
    bool bCreatePool
    )
{
    HRESULT hr;
    LPWSTR szActualName;
    BOOL bActualCreation = FALSE;

    if (szAppPoolName) {
        szActualName = (LPWSTR)szAppPoolName;
    }
    else {
        szActualName = NULL;
    }

    if (bCreatePool != true) {
        bActualCreation = FALSE;
    }
    else {
        bActualCreation = TRUE;
    }

    hr = m_pAppAdmin->CreateApplication(
        szMetaBasePath,
        lAppMode,
        szActualName,
        bActualCreation   // Don't create - DefaultAppPool should already be there
        );

    return hr;
}

HRESULT CWebAppMethod::AppDelete( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pAppAdmin->DeleteApplication(
        szMetaBasePath, 
        bRecursive ? TRUE : FALSE  // Don't mix bool w/ BOOL
        );

    return hr;
}

HRESULT CWebAppMethod::AppUnLoad( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin2->AppUnLoad(
        szMetaBasePath, 
        bRecursive ? TRUE : FALSE  // Don't mix bool w/ BOOL
        );

    return hr;
}

HRESULT CWebAppMethod::AppDisable( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin2->AppDeleteRecoverable(
        szMetaBasePath, 
        bRecursive ? TRUE : FALSE  // Don't mix bool w/ BOOL
        );

    return hr;
}

HRESULT CWebAppMethod::AppEnable( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin2->AppRecover(
        szMetaBasePath, 
        bRecursive ? TRUE : FALSE  // Don't mix bool w/ BOOL
        );

    return hr;
}

HRESULT CWebAppMethod::AppGetStatus( 
    LPCWSTR szMetaBasePath, 
    DWORD* pdwStatus
    )
{
    HRESULT hr;
    hr = m_pWamAdmin2->AppGetStatus(
        szMetaBasePath, 
        pdwStatus);

    return hr;
}

HRESULT CWebAppMethod::AspAppRestart(
    LPCWSTR a_szMetaBasePath
    )
{
    HRESULT         hr = S_OK;
    DWORD           dwState = 0;
    METADATA_HANDLE t_hKey = NULL;
    CMetabase       t_mb;
    
    // open key
    t_hKey = t_mb.OpenKey(a_szMetaBasePath, true);

    // check app
    hr = t_mb.WebAppCheck(t_hKey);
    THROW_ON_ERROR(hr);

    // get state
    hr = t_mb.WebAppGetStatus(t_hKey, &dwState);
    THROW_ON_ERROR(hr);

    // change state value
    dwState = dwState ? 0 : 1;
    hr = t_mb.WebAppSetStatus(t_hKey, dwState);
    THROW_ON_ERROR(hr);

    // re-set back state value
    dwState = dwState ? 0 : 1;
    hr = t_mb.WebAppSetStatus(t_hKey, dwState);
    THROW_ON_ERROR(hr);

    t_mb.CloseKey(t_hKey);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\assoccomponent.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocComponent.cpp

Abstract:

    Implementation of:
    CAssocComponent

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

//
// Needed for metabase.h
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <mddefw.h>
#include <dbgutil.h>
#include <atlbase.h>
#include "AssocComponent.h"
#include "utils.h"
#include "metabase.h"
#include "SmartPointer.h"

CAssocComponent::CAssocComponent(
    CWbemServices*   i_pNamespace,
    IWbemObjectSink* i_pResponseHandler,
    WMI_ASSOCIATION* i_pWmiAssoc) : 
    CAssocBase(i_pNamespace, i_pResponseHandler, i_pWmiAssoc)
{
}

void CAssocComponent::GetInstances(
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp) //defaultvalue(NULL)
{
    DBG_ASSERT(m_pNamespace);
    DBG_ASSERT(i_pExp);

    SQL_LEVEL_1_TOKEN* pTokenGroup  = NULL;  // left part of assoc
    SQL_LEVEL_1_TOKEN* pTokenPart   = NULL;  // right part of assoc

    //
    // Walk thru tokens
    // Don't do query if we find OR or NOT
    // Record match for left and/or right part of association.
    //
    bool  bDoQuery = true;
    ProcessQuery(i_pExp, m_pWmiAssoc, &pTokenGroup, &pTokenPart, &bDoQuery);

    if( !bDoQuery || (pTokenGroup == NULL && pTokenPart == NULL) )
    {
        GetAllInstances(
            m_pWmiAssoc);
        return;
    }

    DBG_ASSERT(pTokenGroup != NULL || pTokenPart != NULL);

    BSTR  bstrLeft  = NULL;
    BSTR  bstrRight = NULL;

    if(pTokenGroup && pTokenPart)
    {
        Indicate(
            pTokenGroup->vConstValue.bstrVal,
            pTokenPart->vConstValue.bstrVal);
    }
    else if(pTokenGroup)
    {
        EnumParts(
            pTokenGroup);
    }
    else
    {
        GetGroup(
            pTokenPart);
    }
}

void CAssocComponent::EnumParts(
    SQL_LEVEL_1_TOKEN* pTokenLeft)
{
    DBG_ASSERT(pTokenLeft != NULL);

    HRESULT hr = S_OK;

    //
    // Parse the left part of the association
    //
    TSmartPointer<ParsedObjectPath> spParsedObject;
    if( m_PathParser.Parse(pTokenLeft->vConstValue.bstrVal, &spParsedObject)
        != CObjectPathParser::NoError)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
    }

    //
    // Get the key from the left part of the association
    //
    KeyRef* pkr = NULL;
    pkr = CUtils::GetKey(spParsedObject, m_pWmiAssoc->pcLeft->pszKeyName);

    CComBSTR sbstrMbPath =  m_pWmiAssoc->pcLeft->pszMetabaseKey; // Eg: /LM
    sbstrMbPath          += L"/";                                // Eg: /LM/
    sbstrMbPath          += pkr->m_vValue.bstrVal;               // Eg: /LM/w3svc
    if(sbstrMbPath.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    //
    // Convert parsed object to right part
    //
    if(!spParsedObject->SetClassName(m_pWmiAssoc->pcRight->pszClassName))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }
    spParsedObject->ClearKeys();

    CMetabase metabase;
    WCHAR wszMDName[METADATA_MAX_NAME_LEN+1] = {0};
    DWORD dwIndex = 0;
    do
    {
        METABASE_KEYTYPE* pkt = m_pWmiAssoc->pcRight->pkt;
		wszMDName[0]          = L'\0';
        hr = metabase.EnumKeys(
            METADATA_MASTER_ROOT_HANDLE,
            sbstrMbPath,
            wszMDName,
            &dwIndex,
            pkt,
            true);
        dwIndex++;
        if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
        {
            break;
        }
        THROW_ON_ERROR(hr);

		LPWSTR pStart =  sbstrMbPath;
		pStart        += wcslen(m_pWmiAssoc->pcRight->pszMetabaseKey);
		pStart        += (*pStart == L'/')  ? 1 : 0;

        CComBSTR sbstr =  pStart;
        sbstr          += (*pStart == L'\0') ? L"" : L"/"; // Eg. "w3svc/"
        sbstr          += wszMDName;					   // Eg. "w3svc/1"
        if(sbstr.m_str == NULL)
        {
            THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
        }

        VARIANT vt;
        vt.vt       = VT_BSTR;
        vt.bstrVal  = sbstr;

        if(!spParsedObject->AddKeyRefEx(m_pWmiAssoc->pcRight->pszKeyName, &vt))
        {
            THROW_ON_ERROR(WBEM_E_FAILED);
        }
      
        Indicate(
            pTokenLeft->vConstValue.bstrVal,
            spParsedObject,
            false,
            false);
    }
    while(1);
}

void CAssocComponent::GetGroup(
    SQL_LEVEL_1_TOKEN* pTokenRight)
{
    TSmartPointer<ParsedObjectPath> spParsedObject;
    if( m_PathParser.Parse(pTokenRight->vConstValue.bstrVal, &spParsedObject)
        != CObjectPathParser::NoError)
    {
        THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
    }

    //
    // Get the key from the right part of the association
    //
    KeyRef* pkr = NULL;
    pkr = CUtils::GetKey(spParsedObject, m_pWmiAssoc->pcRight->pszKeyName);

    const BSTR bstrRight = pkr->m_vValue.bstrVal;
    ULONG      cchRight  = wcslen(bstrRight);

    CComBSTR sbstrLeft;
    LPWSTR pSlash = wcsrchr(bstrRight, L'/');

    //
    // Trim off the last part and construct the Group (i.e. Left) obj path
    //
    if(pSlash == NULL)
    {
        if(m_pWmiAssoc->pcLeft == &WMI_CLASS_DATA::s_Computer)
        {
            sbstrLeft =  WMI_CLASS_DATA::s_Computer.pszClassName;
            sbstrLeft += "='LM'";
        }
        else
        {
            return;
        }
    }
    else
    {
        *pSlash = L'\0';
        sbstrLeft =  m_pWmiAssoc->pcLeft->pszClassName;
        sbstrLeft += L"='";
        sbstrLeft += (LPWSTR)bstrRight;
        sbstrLeft += L"'";

        //
        // Verify the group part actually exists.
        // Put back the slash in the string we modified.
        //
        if(!LookupKeytypeInMb(bstrRight, m_pWmiAssoc->pcLeft))
        {
            *pSlash = L'/';
            return;
        }
        *pSlash = L'/';
    }

    if(sbstrLeft.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    Indicate(
        sbstrLeft,
        pTokenRight->vConstValue.bstrVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\assocaclace.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocACLACE.h

Abstract:

    Definition of:
    CAssocACLACE

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _AssocACLACE_h_
#define _AssocACLACE_h_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <genlex.h>
#include "sqllex.h"
#include "sql_1ext.h"
#include <opathlex.h>
#include <objpath.h>

#include <wbemprov.h>

#include "WbemServices.h"
#include "AssocBase.h"
#include "adminacl.h"

class CAssocACLACE : public CAssocBase
{
public:
    CAssocACLACE(        
        CWbemServices*   i_pNamespace,
        IWbemObjectSink* i_pResponseHandler);

    //
    // IAssocBase
    //
    void GetInstances(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp = NULL);

private:
    class CACEEnumOperation_IndicateAllAsAssoc : public CACEEnumOperation_Base
    {
    public:
        CACEEnumOperation_IndicateAllAsAssoc(
            CAssocACLACE*     i_pAssocACLACE,
            const BSTR        i_bstrACLObjPath,
            ParsedObjectPath* i_pParsedACEObjPath) : m_bstrACLObjPath(i_bstrACLObjPath)
        {
            m_pAssocACLACE      = i_pAssocACLACE;
            m_pParsedACEObjPath = i_pParsedACEObjPath;
        }

        virtual HRESULT Do(
            IADsAccessControlEntry* pACE);

        virtual eDone Done() { return eDONE_DONT_KNOW; }

    private:
        CAssocACLACE*     m_pAssocACLACE;
        const BSTR        m_bstrACLObjPath;
        ParsedObjectPath* m_pParsedACEObjPath;
    };
};

#endif // _AssocACLACE_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\assocbase.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocBase.h

Abstract:

    Definition of:
    CAssocBase

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _assocbase_h_
#define _assocbase_h_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>
#include <opathlex.h>
#include <objpath.h>

#include <wbemprov.h>

#include "WbemServices.h"
#include "WbemObjectSink.h"
#include "schema.h"

class CAssocBase
{
public:
    CAssocBase(
        CWbemServices*              i_pNamespace,
        IWbemObjectSink*            i_pResponseHandler,
        WMI_ASSOCIATION*            i_pWmiAssoc);

    virtual void GetInstances(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp = NULL) = 0;

protected:
    void GetAllInstances(
        WMI_ASSOCIATION*            i_pWmiAssoc);

    void ProcessQuery(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp,
        WMI_ASSOCIATION*                i_pWmiAssoc,
        SQL_LEVEL_1_TOKEN**             o_ppTokenLeft,
        SQL_LEVEL_1_TOKEN**             o_ppTokenRight,
        bool*                           o_pbDoQuery);

    void Indicate(
        BSTR                        i_bstrObjPathLeft,
        BSTR                        i_bstrObjPathRight,
        bool                        i_bVerifyLeft  = true,
        bool                        i_bVerifyRight = true);

    void Indicate(
        const BSTR                  i_bstrLeftObjPath,
        ParsedObjectPath*           i_pParsedRightObjPath,
        bool                        i_bVerifyLeft  = true,
        bool                        i_bVerifyRight = true);

    void Indicate(
        ParsedObjectPath*           i_pParsedLeftObjPath,
        const BSTR                  i_bstrRightObjPath,
        bool                        i_bVerifyLeft  = true,
        bool                        i_bVerifyRight = true);

    bool LookupKeytypeInMb(
        LPCWSTR          i_wszWmiPath,
        WMI_CLASS*       i_pWmiClass);

    CWbemServices*      m_pNamespace;
    CWbemObjectSink     m_InstanceMgr;
    WMI_ASSOCIATION*    m_pWmiAssoc;
    CObjectPathParser   m_PathParser;

private:
    IWbemObjectSink*    m_pResponseHandler;
};

#endif // _assocbase_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\assocbase.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocSameLevel.cpp

Abstract:

    Implementation of:
    CAssocSameLevel

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

//
// Needed for metabase.h
//
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <dbgutil.h>

#include "AssocBase.h"

#include "InstanceHelper.h"
#include "metabase.h"
#include "enum.h"
#include "utils.h"

CAssocBase::CAssocBase(
    CWbemServices*              i_pNamespace,
    IWbemObjectSink*            i_pResponseHandler,
    WMI_ASSOCIATION*            i_pWmiAssoc) : 
    m_InstanceMgr(i_pResponseHandler),
    m_PathParser(e_ParserAcceptRelativeNamespace)
{
    DBG_ASSERT(i_pNamespace);
    DBG_ASSERT(i_pResponseHandler);
    DBG_ASSERT(i_pWmiAssoc);

    m_pWmiAssoc        = i_pWmiAssoc;
    m_pNamespace       = i_pNamespace;
    m_pResponseHandler = i_pResponseHandler;
}

void CAssocBase::GetAllInstances(
    WMI_ASSOCIATION*    i_pWmiAssoc)
{
    DBG_ASSERT(i_pWmiAssoc);

    ParsedObjectPath    ParsedObject;            //deconstructer frees memory
    CObjectPathParser   PathParser(e_ParserAcceptRelativeNamespace);

    CEnum EnumAssociation;
    EnumAssociation.Init(
        m_pResponseHandler,
        m_pNamespace,
        &ParsedObject,
        i_pWmiAssoc->pcRight->pszMetabaseKey,
        i_pWmiAssoc
        );
    EnumAssociation.Recurse(
        NULL,
        &METABASE_KEYTYPE_DATA::s_IIsComputer,        
        NULL,
        i_pWmiAssoc->pcRight->pszKeyName,
        i_pWmiAssoc->pcRight->pkt
        );
}

void CAssocBase::ProcessQuery(
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp,
    WMI_ASSOCIATION*                i_pWmiAssoc,
    SQL_LEVEL_1_TOKEN**             o_ppTokenLeft,
    SQL_LEVEL_1_TOKEN**             o_ppTokenRight,
    bool*                           o_pbDoQuery)
{
    int                iNumTokens = i_pExp->nNumTokens;
    SQL_LEVEL_1_TOKEN* pToken     = i_pExp->pArrayOfTokens;

    SQL_LEVEL_1_TOKEN* pTokenLeft  = NULL;  // left part of assoc
    SQL_LEVEL_1_TOKEN* pTokenRight = NULL;  // right part of assoc

    //
    // Walk thru tokens
    // Don't do query if we find OR or NOT
    // Record match for left and/or right part of association.
    //
    bool  bDoQuery = true;
    for(int i = 0; i < iNumTokens; i++, pToken++)
    {

        switch(pToken->nTokenType)
        {
        case SQL_LEVEL_1_TOKEN::OP_EXPRESSION:
            if( !pTokenLeft &&
                _wcsicmp(i_pWmiAssoc->pType->pszLeft, pToken->pPropertyName) == 0)
            {
                pTokenLeft = pToken;
            }
            if( !pTokenRight &&
                _wcsicmp(i_pWmiAssoc->pType->pszRight, pToken->pPropertyName) == 0)
            {
                pTokenRight = pToken;
            }
            break;
        case SQL_LEVEL_1_TOKEN::TOKEN_OR:
        case SQL_LEVEL_1_TOKEN::TOKEN_NOT:
            bDoQuery = false;
            break;
        }
    }

    if(bDoQuery)
    {
        if(pTokenLeft && pTokenLeft->vConstValue.vt != VT_BSTR)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }
        if(pTokenRight && pTokenRight->vConstValue.vt != VT_BSTR)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }
    }

    if(o_pbDoQuery)
    {
        *o_pbDoQuery = bDoQuery;
    }
    *o_ppTokenLeft  = pTokenLeft;
    *o_ppTokenRight = pTokenRight;
}

void CAssocBase::Indicate(
    const BSTR        i_bstrLeftObjPath,
    ParsedObjectPath* i_pParsedRightObjPath,
    bool              i_bVerifyLeft,
    bool              i_bVerifyRight)
{
    DBG_ASSERT(i_bstrLeftObjPath);
    DBG_ASSERT(i_pParsedRightObjPath);

    LPWSTR wszUnparsed = NULL;
    if (m_PathParser.Unparse(i_pParsedRightObjPath, &wszUnparsed) 
        != CObjectPathParser::NoError)
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }

    CComBSTR sbstrRightObjPath = wszUnparsed;
    delete [] wszUnparsed;
    wszUnparsed = NULL;
    
    if(sbstrRightObjPath.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    Indicate(
        i_bstrLeftObjPath,
        sbstrRightObjPath,
        i_bVerifyLeft,
        i_bVerifyRight);
}

void CAssocBase::Indicate(
    ParsedObjectPath* i_pParsedLeftObjPath,
    const BSTR        i_bstrRightObjPath,
    bool              i_bVerifyLeft,
    bool              i_bVerifyRight)
{
    DBG_ASSERT(i_bstrRightObjPath);
    DBG_ASSERT(i_pParsedLeftObjPath);

    LPWSTR wszUnparsed = NULL;
    if (m_PathParser.Unparse(i_pParsedLeftObjPath, &wszUnparsed) 
        != CObjectPathParser::NoError)
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }

    CComBSTR sbstrLeftObjPath = wszUnparsed;
    delete [] wszUnparsed;
    wszUnparsed = NULL;
    
    if(sbstrLeftObjPath.m_str == NULL)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    Indicate(
        sbstrLeftObjPath,
        i_bstrRightObjPath,
        i_bVerifyLeft,
        i_bVerifyRight);
}

void CAssocBase::Indicate(
    const BSTR        i_bstrObjPathLeft,
    const BSTR        i_bstrObjPathRight,
    bool              i_bVerifyLeft,
    bool              i_bVerifyRight)
{
    DBG_ASSERT(i_bstrObjPathLeft  != NULL);
    DBG_ASSERT(i_bstrObjPathRight != NULL);

    VARIANT vtObjPathLeft;
    VARIANT vtObjPathRight;

    vtObjPathLeft.vt        = VT_BSTR;
    vtObjPathLeft.bstrVal   = (BSTR)i_bstrObjPathLeft;  // this is okay, AddKeyRef makes copy
    vtObjPathRight.vt       = VT_BSTR;
    vtObjPathRight.bstrVal  = (BSTR)i_bstrObjPathRight; // this is okay, AddKeyRef makes copy

    ParsedObjectPath ParsedAssocObjPath;
    if(!ParsedAssocObjPath.SetClassName(m_pWmiAssoc->pszAssociationName))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }
    if(!ParsedAssocObjPath.AddKeyRef(m_pWmiAssoc->pType->pszLeft, &vtObjPathLeft))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }
    if(!ParsedAssocObjPath.AddKeyRef(m_pWmiAssoc->pType->pszRight, &vtObjPathRight))
    {
        THROW_ON_ERROR(WBEM_E_FAILED);
    }

    CInstanceHelper  InstanceHelper(&ParsedAssocObjPath, m_pNamespace);
    DBG_ASSERT(InstanceHelper.IsAssoc());

    CComPtr<IWbemClassObject> spObj;
    InstanceHelper.GetAssociation(&spObj, i_bVerifyLeft, i_bVerifyRight);

    m_InstanceMgr.Indicate(spObj);
}

bool CAssocBase::LookupKeytypeInMb(
    LPCWSTR          i_wszWmiPath,
    WMI_CLASS*       i_pWmiClass)
/*++

Synopsis: 
    GetInstances calls this for each side of the association to determine
    if the two sides actually exist in the metabase.  If at least one doesn't,
    there is no point in returning the association.

    If we are unsure (i.e. we get path busy), it is safer to return true.

Arguments: [i_wszWmiPath] - The value part of the object path (i.e. w3svc/1)
           [i_pWmiClass] - 
           
Return Value: 

--*/
{
    DBG_ASSERT(i_wszWmiPath);
    DBG_ASSERT(i_pWmiClass);

    CMetabase metabase;

    _bstr_t sbstrMbPath;
    sbstrMbPath =  i_pWmiClass->pszMetabaseKey;
    sbstrMbPath += L"/";
    sbstrMbPath += i_wszWmiPath;

    HRESULT hr = metabase.CheckKey(sbstrMbPath, i_pWmiClass->pkt);
    switch(hr)
    {
    case HRESULT_FROM_WIN32(ERROR_PATH_BUSY):
        return true;
    case HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
        return false;
    default:
        return true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\assocsamelevel.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocSameLevel.h

Abstract:

    Definition of:
    CAssocSameLevel

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _assocsamelevel_h_
#define _assocsamelevel_h_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>

#include <wbemprov.h>

#include "WbemServices.h"
#include "AssocBase.h"
#include "schema.h"

class CAssocSameLevel : public CAssocBase
{
public:
    CAssocSameLevel(
        CWbemServices*   i_pNamespace,
        IWbemObjectSink* i_pResponseHandler,
        WMI_ASSOCIATION* i_pWmiAssoc);

    //
    // IAssocBase
    //
    void GetInstances(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp = NULL);
};

#endif // _assocsamelevel_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\assoccomponent.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocComponent.h

Abstract:

    Definition of:
    CAssocComponent

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

#ifndef _AssocComponent_h_
#define _AssocComponent_h_

#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>
#include <opathlex.h>
#include <objpath.h>

#include <wbemprov.h>

#include "WbemServices.h"
#include "AssocBase.h"

class CAssocComponent : public CAssocBase
{
public:
    CAssocComponent(
        CWbemServices*              i_pNamespace,
        IWbemObjectSink*            i_pResponseHandler,
        WMI_ASSOCIATION*            i_pWmiAssoc);

    //
    // IAssocBase
    //
    void GetInstances(
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp = NULL);

private:
    void EnumParts(
        SQL_LEVEL_1_TOKEN* pTokenLeft);

    void GetGroup(
        SQL_LEVEL_1_TOKEN* pTokenRight);
};

#endif // _AssocComponent_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\assocsamelevel.cpp ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    AssocSameLevel.cpp

Abstract:

    Implementation of:
    CAssocSameLevel

Author:

    Mohit Srivastava            22-Mar-2001

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <mdmsg.h>
#include <dbgutil.h>
#include "AssocSameLevel.h"
#include "utils.h"
#include "instancehelper.h"
#include "metabase.h"
#include "SmartPointer.h"

CAssocSameLevel::CAssocSameLevel(
    CWbemServices*   i_pNamespace,
    IWbemObjectSink* i_pResponseHandler,
    WMI_ASSOCIATION* i_pWmiAssoc) : 
    CAssocBase(i_pNamespace, i_pResponseHandler, i_pWmiAssoc)
{
}

void CAssocSameLevel::GetInstances(
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* i_pExp) //defaultvalue(NULL)
{
    DBG_ASSERT(i_pExp);

    SQL_LEVEL_1_TOKEN* pTokenLeft  = NULL;  // left part of assoc
    SQL_LEVEL_1_TOKEN* pTokenRight = NULL;  // right part of assoc

    //
    // Walk thru tokens
    // Don't do query if we find OR or NOT
    // Record match for left and/or right part of association.
    //
    bool  bDoQuery = true;
    ProcessQuery(
        i_pExp,
        m_pWmiAssoc,
        &pTokenLeft,
        &pTokenRight,
        &bDoQuery);

    if( !bDoQuery || (pTokenLeft == NULL && pTokenRight == NULL) )
    {
        GetAllInstances(
            m_pWmiAssoc);
        return;
    }

    //
    // We need to get just a single association instance.  If we were provided
    // at least a left or a right part, we have enough information.
    //
    DBG_ASSERT(pTokenLeft != NULL || pTokenRight != NULL);

    VARIANT  vtLeft;
    VARIANT  vtRight;
    VariantInit(&vtLeft);
    VariantInit(&vtRight);

    CComBSTR sbstr;

    if(pTokenLeft && pTokenRight)
    {
        vtLeft.vt       = VT_BSTR;
        vtLeft.bstrVal  = pTokenLeft->vConstValue.bstrVal;
        vtRight.vt      = VT_BSTR;
        vtRight.bstrVal = pTokenRight->vConstValue.bstrVal;
    }
    else
    {
        //
        // An association contains two object paths.  We are going to construct
        // the missing one by simply replacing the class.
        //
        // Eg. IIsWebServer='w3svc/1' => IIsWebServerSetting='w3svc/1'
        //
        CObjectPathParser  PathParser(e_ParserAcceptRelativeNamespace);

        SQL_LEVEL_1_TOKEN* pTokenCur    = (pTokenLeft) ? pTokenLeft : pTokenRight;
        WMI_CLASS*         pWmiClass    =
            (pTokenLeft) ? m_pWmiAssoc->pcLeft : m_pWmiAssoc->pcRight;
        WMI_CLASS*         pWmiClassOpposite = 
            (pTokenLeft) ? m_pWmiAssoc->pcRight : m_pWmiAssoc->pcLeft;

        TSmartPointer<ParsedObjectPath> spParsedObject;
        if (PathParser.Parse(pTokenCur->vConstValue.bstrVal, &spParsedObject) 
            != CObjectPathParser::NoError)
        {
            THROW_ON_ERROR(WBEM_E_INVALID_QUERY);
        }

        KeyRef* pkr          = CUtils::GetKey(spParsedObject, pWmiClass->pszKeyName);
        if( !LookupKeytypeInMb(pkr->m_vValue.bstrVal, pWmiClass) &&
            !LookupKeytypeInMb(pkr->m_vValue.bstrVal, pWmiClassOpposite) )
        {
            //
            // One of the two classes in the assoc must be an element.
            //
            return;
        }

        if(!spParsedObject->SetClassName(pWmiClassOpposite->pszClassName))
        {
            THROW_ON_ERROR(WBEM_E_FAILED);
        }

        LPWSTR wszUnparsed = NULL;
        if (PathParser.Unparse(spParsedObject, &wszUnparsed) 
            != CObjectPathParser::NoError)
        {
            THROW_ON_ERROR(WBEM_E_FAILED);
        }
        sbstr = wszUnparsed;
        delete [] wszUnparsed; 
        wszUnparsed = NULL;

        if(sbstr.m_str == NULL)
        {
            THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
        }

        if(pTokenLeft)
        {
            vtLeft.vt        = VT_BSTR;
            vtLeft.bstrVal   = pTokenLeft->vConstValue.bstrVal;
            vtRight.vt       = VT_BSTR;
            vtRight.bstrVal  = sbstr;
        }
        else
        {
            vtRight.vt       = VT_BSTR;
            vtRight.bstrVal  = pTokenRight->vConstValue.bstrVal;
            vtLeft.vt        = VT_BSTR;
            vtLeft.bstrVal   = sbstr;
        }
    }

    Indicate(
        vtLeft.bstrVal,
        vtRight.bstrVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\certmap.h ===
#if !defined( _CERT_INCLUDED )
#define _CERT_INCLUDED


class CCertMapperMethod
{
#define IISMAPPER_LOCATE_BY_CERT    1
#define IISMAPPER_LOCATE_BY_NAME    2
#define IISMAPPER_LOCATE_BY_ACCT    3
#define IISMAPPER_LOCATE_BY_INDEX   4

private:

    IMSAdminBase*       m_pIABase;   //interface pointer
    METADATA_HANDLE     m_hmd;
    LPWSTR m_pszMetabasePath;

    HRESULT Init(LPCWSTR);        
    HRESULT Locate(LONG, VARIANT, LPWSTR);
    HRESULT SetString(LONG, VARIANT, BSTR, DWORD);       
    HRESULT SetBSTR(BSTR*, DWORD, LPBYTE);
    HRESULT SetVariantAsByteArray(VARIANT*, DWORD, LPBYTE);
    HRESULT SetVariantAsBSTR(VARIANT*, DWORD, LPBYTE);
    HRESULT SetVariantAsLong(VARIANT*, DWORD);
    HRESULT GetStringFromBSTR(BSTR, LPSTR*, LPDWORD, BOOL fAddDelimInCount = true);
    HRESULT GetStringFromVariant(VARIANT*, LPSTR*, LPDWORD, BOOL fAddDelimInCount = true);
    HRESULT OpenMd(LPWSTR, DWORD dwPermission = METADATA_PERMISSION_READ);
    HRESULT CloseMd(BOOL fSave = FALSE);
    HRESULT DeleteMdObject(LPWSTR);
    HRESULT CreateMdObject(LPWSTR);
    HRESULT OpenAdminBaseKey(LPWSTR, DWORD);
    void CloseAdminBaseKey();
    void FreeString(LPSTR psz);

public:

    CCertMapperMethod(LPCWSTR);
    ~CCertMapperMethod();

    HRESULT CreateMapping(VARIANT, BSTR, BSTR, BSTR, LONG);

    HRESULT GetMapping(LONG, VARIANT, VARIANT*, VARIANT*, VARIANT*, VARIANT*, VARIANT*);
    HRESULT DeleteMapping(LONG, VARIANT);
    HRESULT SetEnabled(LONG, VARIANT, LONG);
    HRESULT SetName(LONG, VARIANT, BSTR);
    HRESULT SetPwd(LONG, VARIANT, BSTR);
    HRESULT SetAcct(LONG, VARIANT, BSTR);

    HRESULT SetMdData(LPWSTR, DWORD, DWORD, DWORD, LPBYTE);
    HRESULT GetMdData(LPWSTR, DWORD, DWORD, LPDWORD, LPBYTE*);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\enum.h ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    enum.h.cpp

Abstract:

    Enumerates metabase tree.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _enum_h_
#define _enum_h_

#include "WbemObjectSink.h"

#include <genlex.h>
#include "sqllex.h"
#include <sql_1ext.h>

class CEnum
{
public:
    CEnum();
    ~CEnum();
    
    void Init(
        IWbemObjectSink FAR*, 
        CWbemServices*, 
        ParsedObjectPath*, 
        LPWSTR, 
        WMI_ASSOCIATION*,
        SQL_LEVEL_1_RPN_EXPRESSION_EXT* pExp=NULL);
    
    void Recurse(
        LPCWSTR, 
        METABASE_KEYTYPE*, 
        LPCWSTR, 
        LPCWSTR, 
        METABASE_KEYTYPE*);

private:
    bool ContinueRecurse(METABASE_KEYTYPE*, METABASE_KEYTYPE*);
    void SetObjectPath(LPCWSTR, LPCWSTR, IWbemClassObject*);
    void DoPing(LPCWSTR, LPCWSTR, LPCWSTR);
    void PingAssociation(LPCWSTR);
    void PingObject();
    void DoPingAdminACL(METABASE_KEYTYPE*, LPCWSTR, LPCWSTR);
    void PingAssociationAdminACL(LPCWSTR);
    void EnumACE(LPCWSTR);
    void DoPingIPSecurity(METABASE_KEYTYPE*, LPCWSTR, LPCWSTR);
    void PingAssociationIPSecurity(LPCWSTR);
    
    CMetabase                       m_metabase;
    CWbemObjectSink*                m_pInstMgr;
    CWbemServices*                  m_pNamespace;
    WMI_ASSOCIATION*                m_pAssociation;
    ParsedObjectPath*               m_pParsedObject;
    METADATA_HANDLE                 m_hKey;
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* m_pExp;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WMI IIS Instance provider
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "iisprov.h"


//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;    
}

CProvFactory::~CProvFactory(void)
{
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(
    REFIID riid,
    PPVOID ppv
    )
{
    *ppv=NULL;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
        *ppv=this;

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
        delete this;
    
    return lNewCount>0 ? lNewCount : 0;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid, PPVOID ppvObj
    )
{
    CIISInstProvider *pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj = new CIISInstProvider();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\enum.cpp ===
/*++

Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    enum.cpp

Abstract:

    Enumerates metabase tree.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/


#include "iisprov.h"
#include "enum.h"
#include "ipsecurity.h"
#include "adminacl.h"
#include "WbemObjectSink.h"
#include "instancehelper.h"
#include "SmartPointer.h"

#include <adserr.h>

extern CDynSchema* g_pDynSch;


///////////////////////////////////////
//
// CEnum class
//
///////////////////////////////////////

CEnum::CEnum()
{
    m_pInstMgr        = NULL;
    m_pNamespace      = NULL;
    m_pAssociation    = NULL;
    m_pParsedObject   = NULL;
    m_hKey            = NULL;
}

CEnum::~CEnum()
{
    if(m_hKey)
        m_metabase.CloseKey(m_hKey);

    delete m_pInstMgr;
}

void CEnum::Init(
    IWbemObjectSink FAR*            a_pHandler,
    CWbemServices*                  a_pNamespace,
    ParsedObjectPath*               a_pParsedObject,
    LPWSTR                          a_pszKey,
    WMI_ASSOCIATION*                a_pAssociation,
    SQL_LEVEL_1_RPN_EXPRESSION_EXT* a_pExp)            // default(NULL)
{
    if (!a_pHandler || !a_pNamespace || !a_pParsedObject)
        throw WBEM_E_FAILED;

    m_pInstMgr = new CWbemObjectSink(a_pHandler);
    if(!m_pInstMgr)
    {
        THROW_ON_ERROR(WBEM_E_OUT_OF_MEMORY);
    }

    m_pNamespace      = a_pNamespace;
    m_pAssociation    = a_pAssociation;
    m_pParsedObject   = a_pParsedObject;
    m_pExp            = a_pExp;

    m_hKey = m_metabase.OpenKey(a_pszKey, false);  // read only
}

void CEnum::SetObjectPath(
    LPCWSTR              a_pszPropertyName,
    LPCWSTR              a_pszObjectPath,
    IWbemClassObject*    a_pObj
    )
{
    _bstr_t bstr(a_pszPropertyName);
    _variant_t v(a_pszObjectPath);

    HRESULT hr = a_pObj->Put(bstr, 0, &v, 0);
    THROW_ON_ERROR(hr);
}

void CEnum::PingObject()
{
    CComPtr<IWbemClassObject> spObj;

    CInstanceHelper InstanceHelper(m_pParsedObject, m_pNamespace);

    DBG_ASSERT(!InstanceHelper.IsAssoc());

    try
    {
        InstanceHelper.GetInstance(false, &m_metabase, &spObj, m_pExp);
    }
    catch(HRESULT hr)
    {
        if(hr != E_ADS_PROPERTY_NOT_SUPPORTED && hr != WBEM_E_NOT_FOUND)
        {
            throw;
        }
    }

    if(spObj != NULL)
    {
        m_pInstMgr->Indicate(spObj);
    }
}

void CEnum::PingAssociation(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT                   hr;
    CComPtr<IWbemClassObject> spObj;
    CComPtr<IWbemClassObject> spClass;
    TSmartPointerArray<WCHAR> swszObjectPath;
    CObjectPathParser         PathParser(e_ParserAcceptRelativeNamespace);

    if( m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_ElementSetting &&
        m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_Component )
    {
        return;
    }

    hr = m_pNamespace->GetObject(
        m_pAssociation->pszAssociationName,
        0, 
        NULL, 
        &spClass, 
        NULL
        );
    THROW_ON_ERROR(hr);

    hr = spClass->SpawnInstance(0, &spObj);
    THROW_ON_ERROR(hr);

    //
    // first right side
    //
    if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
        throw WBEM_E_FAILED;

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
        throw WBEM_E_FAILED;

    SetObjectPath(m_pAssociation->pType->pszRight, swszObjectPath, spObj);
    swszObjectPath.Delete();

    //
    // then left side
    //
    if (m_pAssociation->pType == &WMI_ASSOCIATION_TYPE_DATA::s_Component)
    {
        // clear keyref first
        m_pParsedObject->ClearKeys();
 
        // add a keyref
        _variant_t vt;            
        if(m_pAssociation->pcLeft->pkt == &METABASE_KEYTYPE_DATA::s_IIsComputer)
            vt = L"LM";              // IIsComputer.Name = "LM"
        else
            vt = a_pszLeftKeyPath;

        THROW_ON_FALSE(m_pParsedObject->AddKeyRef(m_pAssociation->pcLeft->pszKeyName,&vt));
    }

    if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
        throw WBEM_E_FAILED;

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
        throw WBEM_E_FAILED;

    SetObjectPath(m_pAssociation->pType->pszLeft, swszObjectPath, spObj);
    swszObjectPath.Delete();

    m_pInstMgr->Indicate(spObj);
}

void CEnum::DoPing(
    LPCWSTR a_pszKeyName,
    LPCWSTR a_pszKeyPath,
    LPCWSTR a_pszParentKeyPath
    )
{
    // add keyref
    _variant_t v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&v));

    // ping
    if (!m_pAssociation) 
        PingObject();
    else
        PingAssociation(a_pszParentKeyPath);
 
    // clear keyref
    m_pParsedObject->ClearKeys();
}

void CEnum::Recurse(
    LPCWSTR           a_pszMetabasePath, // Current metabase location relative to m_hKey
    METABASE_KEYTYPE* a_pktParentKeyType,// Current keytype
    LPCWSTR           a_pszLeftPath,
    LPCWSTR           a_pszWmiPrimaryKey,// "Name" - WMI only - nothing to do with MB
    METABASE_KEYTYPE* a_pktSearch		 // the kt we are looking for
    )
{
    DWORD   i = 0;
    HRESULT hr;
    WCHAR   szSubKey[METADATA_MAX_NAME_LEN];
    METABASE_KEYTYPE* pktCurrent;

    DBGPRINTF((DBG_CONTEXT, "Recurse (Path = %ws, Left = %ws)\n", a_pszMetabasePath, a_pszLeftPath));

    do 
    {
        pktCurrent = a_pktSearch;

        //
        // Enumerate all subkeys of a_pszMetabasePath until we find a potential
        // (grand*)parent of pktCurrent
        //
        hr = m_metabase.EnumKeys(
                m_hKey,
                a_pszMetabasePath,
                szSubKey,
                &i,
                pktCurrent
                );
        i++;

        if( hr == ERROR_SUCCESS)
        {
            _bstr_t bstrMetabasePath;
            if(a_pszMetabasePath)
            {
                bstrMetabasePath = a_pszMetabasePath;
                bstrMetabasePath += L"/";
            }
            bstrMetabasePath += szSubKey;

            //
            // With the exception of AdminACL, AdminACE, IPSecurity, we will only
            // ping the object if we have found a keytype match in the metabase.
            //
            if( pktCurrent == a_pktSearch &&
                !( m_pAssociation && 
                   m_pAssociation->pType == &WMI_ASSOCIATION_TYPE_DATA::s_Component && 
                   m_pAssociation->pcLeft->pkt != a_pktParentKeyType
                   )
                )
            {
                DoPing(a_pszWmiPrimaryKey, bstrMetabasePath, a_pszLeftPath);
            }
            else if( a_pktSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||   // AdminACL
                a_pktSearch == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE
                     )
            {
				if( (m_pAssociation == NULL || // should never be
					 m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL ||
					 m_pAssociation->pcLeft->pkt == pktCurrent ||
					 m_pAssociation == &WMI_ASSOCIATION_DATA::s_AdminACLToACE) )
                {
                    DoPingAdminACL(a_pktSearch, a_pszWmiPrimaryKey, bstrMetabasePath);
                }
            }
            else if( a_pktSearch == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )   // IPSecurity
            {
                if( !(m_pAssociation &&
                      m_pAssociation->pType == &WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity && 
                      m_pAssociation->pcLeft->pkt != pktCurrent
                      )
                    )
                {
                    DoPingIPSecurity(a_pktSearch, a_pszWmiPrimaryKey, bstrMetabasePath);
                }
            }
            
            // recusive
            if(ContinueRecurse(pktCurrent, a_pktSearch))
            {
                Recurse(
                    bstrMetabasePath, 
                    pktCurrent, 
                    bstrMetabasePath, 
                    a_pszWmiPrimaryKey, 
                    a_pktSearch);
            }
        }

    }while(hr == ERROR_SUCCESS);

    DBGPRINTF((DBG_CONTEXT, "Recurse Exited\n"));
}

// DESC: You are looking for a_eKeyType by traversing thru the tree. You are
//       currently at a_eParentKeyType and need to determine if you should keep
//       on going.
// COMM: This seems very similar to CMetabase::CheckKey
bool CEnum::ContinueRecurse(
    METABASE_KEYTYPE*  a_pktParentKeyType,
    METABASE_KEYTYPE*  a_pktKeyType
    )
{
    bool bRet = false;

    if( a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL ||
        a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE ||
        a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity )
    {
        return true;
    }

    return g_pDynSch->IsContainedUnder(a_pktParentKeyType, a_pktKeyType);

    /*switch(a_pktKeyType)
    {
    case &METABASE_KEYTYPE_DATA::s_IIsLogModule:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsLogModules )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFtpInfo:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFtpServer:
         if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebInfo:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFilters:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsFilter:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFilters 
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFilters 
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsCompressionScheme:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFilters ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebServer:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsCertMapper:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer 
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebDirectory:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
        break;

    case &METABASE_KEYTYPE_DATA::s_IIsWebFile:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory
            )
            bRet = true;
        break;

    case TYPE_AdminACL:
    case TYPE_AdminACE:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
        break;

    case TYPE_IPSecurity:
        if( a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsWebDirectory ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpService ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpServer ||
            a_pktParentKeyType == &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir
            )
            bRet = true;
        break;

    default:
        break;
    }*/

    //return bRet;
    //return true;
}

void CEnum::DoPingAdminACL(
    METABASE_KEYTYPE*  a_pktKeyType, // Search key
    LPCWSTR            a_pszKeyName, // Wmi Primary key - nothing to do with MB
    LPCWSTR            a_pszKeyPath  // Current metabase path relative to m_hKey
    )
{
    // add keyref
    _variant_t v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&v));

    if(a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE)
    {
        EnumACE(a_pszKeyPath);
    }
    else if(a_pktKeyType == &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL)
    {
        // ping
        if (!m_pAssociation) 
            PingObject();
        else
            PingAssociationAdminACL(a_pszKeyPath);
    }
    
    // clear keyref
    m_pParsedObject->ClearKeys();
}


// for AdminACL
void CEnum::EnumACE(
    LPCWSTR pszKeyPath
    )
{
    HRESULT hr = S_OK;
    _variant_t var;
    CComPtr<IEnumVARIANT> spEnum;
    ULONG   lFetch;
    CComBSTR bstrTrustee;
    IDispatch* pDisp = NULL;
    CComPtr<IADsAccessControlEntry> spACE;
    _bstr_t bstrMbPath;
    WMI_CLASS* pWMIClass;

    // get the metabase path of the object
    BOOL fClass = FALSE;
    if(m_pAssociation)
        fClass = CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass);
    else
        fClass = CUtils::GetClass(m_pParsedObject->m_pClass,&pWMIClass);
    
    if(!fClass)
        return;

    CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
   
    // open ADSI
    CAdminACL objACL;
    hr = objACL.OpenSD(bstrMbPath);
    if(SUCCEEDED(hr))
        hr = objACL.GetACEEnum(&spEnum);
    if ( FAILED(hr) )
        return;

    //////////////////////////////////////////////
    // Enumerate ACEs
    //////////////////////////////////////////////
    hr = spEnum->Next( 1, &var, &lFetch );
    while( hr == S_OK )
    {
        if ( lFetch == 1 )
        {
            if ( VT_DISPATCH != V_VT(&var) )
            {
                break;
            }

            pDisp = V_DISPATCH(&var);

            /////////////////////////////
            // Get the individual ACE
            /////////////////////////////
            hr = pDisp->QueryInterface( 
                IID_IADsAccessControlEntry, 
                (void**)&spACE 
                ); 

            if ( SUCCEEDED(hr) )
            {
                hr = spACE->get_Trustee(&bstrTrustee);

                if( SUCCEEDED(hr) )
                {
                    // add keyref
                    _variant_t v(bstrTrustee);
                    //m_pParsedObject->RemoveKeyRef(L"Trustee");
                    THROW_ON_FALSE(m_pParsedObject->AddKeyRefEx(L"Trustee",&v));

                    // ping
                    if (!m_pAssociation) 
                        PingObject();
                    else
                        PingAssociationAdminACL(pszKeyPath);
                }

                bstrTrustee = (LPWSTR)NULL;
                spACE       = NULL;
            }
        }

        hr = spEnum->Next( 1, &var, &lFetch );
    }
}


void CEnum::PingAssociationAdminACL(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT                   hr;
    CComPtr<IWbemClassObject> spObj;
    CComPtr<IWbemClassObject> spClass;
    TSmartPointerArray<WCHAR> swszObjectPath;
    CObjectPathParser    PathParser(e_ParserAcceptRelativeNamespace);
    _bstr_t              bstrMbPath;
    WMI_CLASS*           pWMIClass;


    if(m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL)
    {
        return;
    }

    // get the metabase path of the object
    if (CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass))
    {
        CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
    }
    else
    {
        return;
    }

    // check if AdminACL existed
    CAdminACL objACL;
    hr = objACL.OpenSD(bstrMbPath);
    objACL.CloseSD();
    if(FAILED(hr))
    {
        return;
    }
    

    hr = m_pNamespace->GetObject(
        m_pAssociation->pszAssociationName,
        0, 
        NULL, 
        &spClass, 
        NULL
        );
    THROW_ON_ERROR(hr);

    hr = spClass->SpawnInstance(0, &spObj);
    THROW_ON_ERROR(hr);

    //
    // first right side
    //
    if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
    {
        throw WBEM_E_FAILED;
    }

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
    {
        throw WBEM_E_FAILED;
    }

    SetObjectPath(m_pAssociation->pType->pszRight, swszObjectPath, spObj);
    swszObjectPath.Delete();

    //
    // then left side
    //
	if(m_pAssociation == &WMI_ASSOCIATION_DATA::s_AdminACLToACE)
    {
        // clear keyref first
        m_pParsedObject->ClearKeys();
 
        // add a keyref
        _variant_t vt = a_pszLeftKeyPath;
        THROW_ON_FALSE(m_pParsedObject->AddKeyRef(m_pAssociation->pcLeft->pszKeyName,&vt));
    }

    if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
    {
        throw WBEM_E_FAILED;
    }

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
    {
        throw WBEM_E_FAILED;
    }

    SetObjectPath(m_pAssociation->pType->pszLeft, swszObjectPath, spObj);
    swszObjectPath.Delete();

    m_pInstMgr->Indicate(spObj);
}


// for IPSecurity
void CEnum::DoPingIPSecurity(
    METABASE_KEYTYPE*  a_pktKeyType,
    LPCWSTR            a_pszKeyName,
    LPCWSTR            a_pszKeyPath
    )
{
    // add keyref
    _variant_t v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&v));

    // ping
    if (!m_pAssociation) 
        PingObject();
    else
        PingAssociationIPSecurity(a_pszKeyPath);
    
    // clear keyref
    m_pParsedObject->ClearKeys();
}

// for IPSecurity
void CEnum::PingAssociationIPSecurity(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT                   hr;
    CComPtr<IWbemClassObject> spObj;
    CComPtr<IWbemClassObject> spClass;
    TSmartPointerArray<WCHAR> swszObjectPath;
    CObjectPathParser         PathParser(e_ParserAcceptRelativeNamespace);
    _bstr_t                   bstrMbPath;
    WMI_CLASS*                pWMIClass;


    if(m_pAssociation->pType != &WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity)
        return;

    // get the metabase path of the object
    if (CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass))
    {
        CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
    }
    else
        return;

    // check if IPSecurity existed
    CIPSecurity objIPsec;
    hr = objIPsec.OpenSD(bstrMbPath, m_metabase);
    objIPsec.CloseSD();
    if(FAILED(hr))
        return;
    
    hr = m_pNamespace->GetObject(
        m_pAssociation->pszAssociationName,
        0, 
        NULL, 
        &spClass, 
        NULL
        );
    THROW_ON_ERROR(hr);

    hr = spClass->SpawnInstance(0, &spObj);
    THROW_ON_ERROR(hr);

    //
    // first right side
    //
    if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
        throw WBEM_E_FAILED;

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
    {
        throw WBEM_E_FAILED;
    }

    SetObjectPath(m_pAssociation->pType->pszRight, swszObjectPath, spObj);
    swszObjectPath.Delete();

    //
    // then left side
    //
    if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
        throw WBEM_E_FAILED;

    if (PathParser.Unparse(m_pParsedObject,&swszObjectPath))
        throw WBEM_E_FAILED;

    SetObjectPath(m_pAssociation->pType->pszLeft, swszObjectPath, spObj);
    swszObjectPath.Delete();

    m_pInstMgr->Indicate(spObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\certmap.cpp ===
////////////////////////////////////////////////////
//
// Copyright (c) 1997  Microsoft Corporation
// 
// Module Name: certmap.cpp
//
// Abstract: IIS privider cert mapper object methods
//
// Author: Philippe Choquier (phillich)    10-Apr-1997
//
// History: Zeyong Xu borrowed the source code from ADSI object 
//          (created by Philippe Choquier at 10-Apr-1997) at 20-Oct-1999
//
///////////////////////////////////////////////////

#include "iisprov.h"
#include "certmap.h"

const ULONG MAX_CERT_KEY_LEN = 32;

//
// CCertMapperMethod
//

CCertMapperMethod::CCertMapperMethod(LPCWSTR pszMetabasePathIn)
{ 
    DBG_ASSERT(pszMetabasePathIn != NULL);

    m_hmd = NULL; 

    HRESULT hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void**)&m_pIABase
        );

    THROW_ON_ERROR(hr);
    
    hr = Init(pszMetabasePathIn);

    THROW_ON_ERROR(hr);
}


CCertMapperMethod::~CCertMapperMethod()
{
    if ( m_pszMetabasePath )
    {
        free( m_pszMetabasePath );
    }

    if(m_pIABase)
        m_pIABase->Release();
}

//
// CreateMapping(): Create a mapping entry
//
// Arguments:
//
//    vCert - X.509 certificate
//    bstrNtAcct - NT acct to map to
//    bstrNtPwd - NT pwd
//    bstrName - friendly name for mapping entry
//    lEnabled - 1 to enable mapping entry, 0 to disable it
//
HRESULT
CCertMapperMethod::CreateMapping(
    VARIANT     vCert,
    BSTR        bstrNtAcct,
    BSTR        bstrNtPwd,
    BSTR        bstrName,
    LONG        lEnabled
    )
{
    HRESULT     hr;
    LPBYTE      pbCert = NULL;
    DWORD       cCert;
    LPSTR       pszNtAcct = NULL;
    LPSTR       pszNtPwd = NULL;
    LPSTR       pszName = NULL;
    LPBYTE      pRes;
    DWORD       cRes;
    DWORD       cName;
    DWORD       cNtAcct;
    DWORD       cNtPwd;
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    VARIANT     vOldAcct;
    VARIANT     vOldCert;
    VARIANT     vOldPwd;
    VARIANT     vOldName;
    VARIANT     vOldEnabledFlag;
    PCCERT_CONTEXT pcCert = NULL;

    //
    // Do some sanity checks on the cert 
    //
    if ( SUCCEEDED( hr = GetStringFromVariant( &vCert, 
                                                 (LPSTR*)&pbCert,
                                                 &cCert,
                                                 FALSE ) ) )
    {
        //
        // try to construct a cert context
        //
        if ( !( pcCert = CertCreateCertificateContext( X509_ASN_ENCODING,
                                                       pbCert,
                                                       cCert ) ) )
        {
            //
            // If the decoding fails, GetLastError() returns an ASN1 decoding
            // error that is obtained by subtracting CRYPT_E_OSS_ERROR from the returned
            // error and looking in file asn1code.h for the actual error. To avoid the
            // cryptic ASN1 errors, we'll just return a general "invalid arg" error 
            //
            hr = RETURNCODETOHRESULT( E_INVALIDARG );
            FreeString( (LPSTR) pbCert );
            pbCert = NULL;
            return hr;
        }

        CertFreeCertificateContext( pcCert );
    }
    else
    {
        DBG_ASSERT(pbCert == NULL);
        return hr;
    }

    //
    // check if we already have a mapping for this cert; if we do, we'll replace that mapping
    // with the new one
    //
    if ( SUCCEEDED( hr = GetMapping( IISMAPPER_LOCATE_BY_CERT,
                                       vCert,
                                       &vOldCert,
                                       &vOldAcct,
                                       &vOldPwd,
                                       &vOldName,
                                       &vOldEnabledFlag ) ) )
    {
        if ( FAILED( hr = SetName( IISMAPPER_LOCATE_BY_CERT,
                                     vCert,
                                     bstrName ) ) ||
             FAILED( hr = SetAcct( IISMAPPER_LOCATE_BY_CERT,
                                     vCert,
                                     bstrNtAcct ) ) ||
             FAILED( hr = SetPwd( IISMAPPER_LOCATE_BY_CERT,
                                    vCert,
                                    bstrNtPwd ) ) ||
             FAILED( hr = SetEnabled( IISMAPPER_LOCATE_BY_CERT,
                                        vCert,
                                        lEnabled ) ) )
        {
            hr; //NOP - Something failed 
        }
    }
    //
    // New mapping
    //
    else if ( hr == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
    {
        //
        // check mapping exists, create if not
        //
        hr = OpenMd( L"Cert11", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );

        if ( hr == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
        {
            if ( SUCCEEDED( hr = OpenMd( L"", 
                                           METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
            {
                hr = CreateMdObject( L"Cert11" );
                CloseMd( FALSE );

                // Reopen to the correct node.
                hr = OpenMd( L"Cert11", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );
            }
        }

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // adding mapping cert "0" means add @ end of list
        //

        if ( SUCCEEDED( hr = CreateMdObject( L"mappings/0" ) ) )
        {
            if ( SUCCEEDED( hr = GetMdData( L"", MD_NSEPM_ACCESS_CERT, DWORD_METADATA, &
                                              cRes, &pRes ) ) )
            {
                if ( cRes == sizeof(DWORD ) )
                {
                    _snwprintf(
                        achIndex, 
                        MAX_CERT_KEY_LEN, 
                        L"mappings/%u", 
                        *(LPDWORD)pRes );

                    if ( FAILED( hr = GetStringFromBSTR( bstrNtAcct, &pszNtAcct, &cNtAcct ) ) ||
                         FAILED( hr = GetStringFromBSTR( bstrNtPwd, &pszNtPwd, &cNtPwd ) ) ||
                         FAILED( hr = GetStringFromBSTR( bstrName, &pszName, &cName ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, 
                                                   sizeof(DWORD), (LPBYTE)&lEnabled ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPNAME, STRING_METADATA, 
                                                   cName, (LPBYTE)pszName ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, 
                                                   cNtPwd, (LPBYTE)pszNtPwd ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, 
                                                   cNtAcct, (LPBYTE)pszNtAcct ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, 
                                                   cCert, (LPBYTE)pbCert ) ) )
                    {
                    }
                }   
                else
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    CloseMd( SUCCEEDED( hr ) );

    FreeString( (LPSTR)pbCert );
    FreeString( pszNtAcct );
    FreeString( pszNtPwd );
    FreeString( pszName );

    return hr;
}

//
// GetMapping: Get a mapping entry using key
//
// Arguments:
//
//    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
//    vKey - key to use to locate mapping
//    pvCert - X.509 certificate
//    pbstrNtAcct - NT acct to map to
//    pbstrNtPwd - NT pwd
//    pbstrName - friendly name for mapping entry
//    plEnabled - 1 to enable mapping entry, 0 to disable it
//

HRESULT
CCertMapperMethod::GetMapping(
    LONG        lMethod,
    VARIANT     vKey,
    VARIANT*    pvCert,
    VARIANT*    pbstrNtAcct,
    VARIANT*    pbstrNtPwd,
    VARIANT*    pbstrName,
    VARIANT*    plEnabled
    )
{
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    HRESULT     hr;
    DWORD       dwLen;
    LPBYTE      pbData;

    VariantInit( pvCert );
    VariantInit( pbstrNtAcct );
    VariantInit( pbstrNtPwd );
    VariantInit( pbstrName );
    VariantInit( plEnabled );

    if ( SUCCEEDED( hr = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hr = SetVariantAsByteArray( pvCert, dwLen, pbData );
                free( pbData );
            }
            else
            {
                CloseMd( FALSE );
                return hr;
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hr = SetVariantAsBSTR( pbstrNtAcct, dwLen, pbData );
                free( pbData );
            }
            else
            {
                CloseMd( FALSE );
                return hr;
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hr = SetVariantAsBSTR( pbstrNtPwd, dwLen, pbData );
                free( pbData );
            }
            else
            {
                CloseMd( FALSE );
                return hr;
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNAME, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hr = SetVariantAsBSTR( pbstrName, dwLen, pbData );
                free( pbData );
            }
            else
            {
                CloseMd( FALSE );
                return hr;
            }

            if ( FAILED( hr = GetMdData( achIndex, MD_MAPENABLED, STRING_METADATA, &dwLen, 
                                           &pbData ) ) )
            {
                SetVariantAsLong( plEnabled, FALSE );
            }
            else
            {
                SetVariantAsLong( plEnabled, *(LPDWORD)pbData );
                free( pbData );
            }
        }

        CloseMd( FALSE );
    }

    return hr;
}

//
// Delete a mapping entry using key
//
HRESULT
CCertMapperMethod::DeleteMapping(
    LONG        lMethod,
    VARIANT     vKey
    )
{
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    HRESULT     hr;

    if ( SUCCEEDED( hr = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = DeleteMdObject( achIndex );
        }
        CloseMd( TRUE );
    }

    return hr;
}

//
// Set the enable flag on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetEnabled(
    LONG        lMethod,
    VARIANT     vKey,
    LONG        lEnabled
    )
{
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    HRESULT     hr;

    if ( SUCCEEDED( hr = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, sizeof(DWORD), (LPBYTE)&lEnabled );
        }
        CloseMd( TRUE );
    }

    return hr;
}

//
// Set the Name on a mapping entry using key
//
HRESULT CCertMapperMethod::SetName(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName
    )
{
    return SetString( lMethod, vKey, bstrName, MD_MAPNAME );
}

//
// Set a string property on a mapping entry using key
//
HRESULT CCertMapperMethod::SetString(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName,
    DWORD       dwProp
    )
{
    WCHAR       achIndex[MAX_CERT_KEY_LEN];
    LPSTR       pszName = NULL;
    HRESULT     hr;
    DWORD       dwLen;


    if ( FAILED( hr = GetStringFromBSTR( bstrName, &pszName, &dwLen, TRUE ) ) )
    {
        return hr;
    }

    if ( SUCCEEDED( hr = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = SetMdData( achIndex, dwProp, STRING_METADATA, dwLen, (LPBYTE)pszName );
        }
        CloseMd( TRUE );
    }

    FreeString( pszName );

    return hr;
}

//
// Set the Password on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetPwd(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrPwd
    )
{
    return SetString( lMethod, vKey, bstrPwd, MD_MAPNTPWD );
}

//
// Set the NT account name on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetAcct(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrAcct
    )
{
    return SetString( lMethod, vKey, bstrAcct, MD_MAPNTACCT );
}


HRESULT
CCertMapperMethod::OpenMd(
    LPWSTR  pszOpenPath,
    DWORD   dwPermission
    )
{
    HRESULT hr;
    LPWSTR  pszPath;
    UINT    cL = wcslen( m_pszMetabasePath );

    pszPath = (LPWSTR)malloc( (wcslen(pszOpenPath) + 1 + cL + 1)*sizeof(WCHAR) );

    if ( pszPath == NULL )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( pszPath, m_pszMetabasePath, cL * sizeof(WCHAR) );
    if ( cL && m_pszMetabasePath[cL-1] != L'/' && *pszOpenPath && *pszOpenPath != L'/' )
    {
        pszPath[cL++] = L'/';
    }
    wcscpy( pszPath + cL, pszOpenPath );

    hr = OpenAdminBaseKey(
                pszPath,
                dwPermission
                );

    free( pszPath );

    return hr;
}


HRESULT
CCertMapperMethod::CloseMd(
    BOOL fSave
    )
{
    CloseAdminBaseKey();
    m_hmd = NULL;
    
    if ( m_pIABase && fSave )
    {
        m_pIABase->SaveData();
    }

    return S_OK;
}


HRESULT
CCertMapperMethod::DeleteMdObject(
    LPWSTR  pszKey
    )
{
    return m_pIABase->DeleteKey( m_hmd, pszKey );
}


HRESULT
CCertMapperMethod::CreateMdObject(
    LPWSTR  pszKey
    )
{
    return m_pIABase->AddKey( m_hmd, pszKey );
}


HRESULT
CCertMapperMethod::SetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    DWORD   dwDataLen,
    LPBYTE  pbData 
    )
{
    METADATA_RECORD     md;

    md.dwMDDataLen = dwDataLen;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = (dwProp == MD_MAPPWD) ? METADATA_SECURE : 0;
    md.pbMDData = pbData;

    return m_pIABase->SetData( m_hmd, achIndex, &md );
}


HRESULT
CCertMapperMethod::GetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    LPDWORD pdwDataLen,
    LPBYTE* ppbData 
    )
{
    HRESULT             hr;
    METADATA_RECORD     md;
    DWORD               dwRequired;

    md.dwMDDataLen = 0;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = 0;
    md.pbMDData = NULL;

    if ( FAILED(hr = m_pIABase->GetData( m_hmd, achIndex, &md, &dwRequired )) )
    {
        if ( hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
        {
            if ( (*ppbData = (LPBYTE)malloc(dwRequired)) == NULL )
            {
                return E_OUTOFMEMORY;
            }
            md.pbMDData = *ppbData;
            md.dwMDDataLen = dwRequired;
            hr = m_pIABase->GetData( m_hmd, achIndex, &md, &dwRequired );
            *pdwDataLen = md.dwMDDataLen;
        }
    }
    else
    {
       *pdwDataLen = 0;
       *ppbData = NULL;
    }

    return hr;
}

//
// Locate a mapping entry based on key 
// OpenMd() must be called 1st
//
HRESULT
CCertMapperMethod::Locate(
    LONG    lMethod,
    VARIANT vKey,
    LPWSTR  pszResKey
    )
{
    HRESULT     hr;
    LPSTR       pV = NULL;
    DWORD       cV;
    DWORD       dwProp;
    LPSTR       pRes;
    DWORD       cRes;
    BOOL        fAddDelim = TRUE;

    //
    // determine method
    //
    switch ( lMethod )
    {
        case IISMAPPER_LOCATE_BY_CERT:
            dwProp = MD_NSEPM_ACCESS_CERT;
            fAddDelim = FALSE;
            break;

        case IISMAPPER_LOCATE_BY_NAME:
            dwProp = MD_NSEPM_ACCESS_NAME;
            break;

        case IISMAPPER_LOCATE_BY_ACCT:
            dwProp = MD_NSEPM_ACCESS_ACCOUNT;
            break;

        case IISMAPPER_LOCATE_BY_INDEX:
            if ( SUCCEEDED( hr = GetStringFromVariant( &vKey, &pV, &cV, TRUE ) ) )
            {
                wsprintfW( pszResKey, L"mappings/%s", pV );
            }
            FreeString( pV );
            return hr;

        default:
            return E_FAIL;
    }

    //
    // get ptr to data
    //
    if ( SUCCEEDED( hr = GetStringFromVariant( &vKey, &pV, &cV, fAddDelim ) ) )
    {
        //
        // set search prop, get result
        //
        if ( SUCCEEDED( hr = SetMdData( L"", dwProp, BINARY_METADATA, cV, (LPBYTE)pV ) ) )
        {
            if ( SUCCEEDED( hr = GetMdData( L"", dwProp, DWORD_METADATA, &cRes, (LPBYTE*)&pRes ) ) )
            {
                if ( cRes == sizeof(DWORD ) )
                {
                    wsprintfW( pszResKey, L"mappings/%u", *(LPDWORD)pRes );
                }
                else
                {
                    hr = E_FAIL;
                }
                free( pRes );
            }
        }
    }

    FreeString( pV );
    return hr;
}

//
// GetStringFromBSTR: Allocate string buffer from BSTR
//
// Arguments:
//
//    bstr - bstr to convert from
//    psz - updated with ptr to buffer, to be freed with FreeString()
//    pdwLen - updated with strlen(string), incremented by 1 if fAddDelimInCount is TRUE
//    fAddDelimInCount - TRUE to increment *pdwLen 
//
HRESULT CCertMapperMethod::GetStringFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount
    )
{
    UINT    cch = SysStringLen(bstr);
    UINT    cchT;

    // include NULL terminator

    *pdwLen = cch + (fAddDelimInCount ? 1 : 0);

	CHAR *szNew = (CHAR*)malloc((2 * cch) + 1);			// * 2 for worst case DBCS string
	if (szNew == NULL)
    {
		return E_OUTOFMEMORY;
    }

	cchT = WideCharToMultiByte(CP_ACP, 0, bstr, cch + 1, szNew, (2 * cch) + 1, NULL, NULL);

	*psz = szNew;

	return NOERROR;
}

//
// GetStringFromVariant: Allocate string buffer from BSTR
//
// Arguments:
//
//    pVar - variant to convert from. Recognizes BSTR, VT_ARRAY|VT_UI1, ByRef or ByVal
//    psz - updated with ptr to buffer, to be freed with FreeString()
//    pdwLen - updated with size of input, incremented by 1 if fAddDelimInCount is TRUE
//    fAddDelimInCount - TRUE to increment *pdwLen 
//
HRESULT CCertMapperMethod::GetStringFromVariant( 
    VARIANT*    pVar,
    LPSTR*      psz,
    LPDWORD     pdwLen,
    BOOL        fAddDelim
    )
{
    LPBYTE  pbV = NULL;
    UINT    cV;
    HRESULT hr;
    WORD    vt = V_VT(pVar);
    BOOL    fByRef = FALSE;
    VARIANT vOut;

    // Set out params to 0
    *psz    = NULL;
    *pdwLen = 0;

    VariantInit( &vOut );

    if ( vt & VT_BYREF )
    {
        vt &= ~VT_BYREF;
        fByRef = TRUE;
    }


    // if pVar is BSTR, convert to multibytes

    if ( vt == VT_VARIANT )
    {
        pVar = (VARIANT*)V_BSTR(pVar);
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    if ( vt == VT_BSTR )
    {
        hr = GetStringFromBSTR( 
            fByRef ? *(BSTR*)V_BSTR(pVar) : V_BSTR(pVar), 
            psz, 
            pdwLen,
            fAddDelim 
            );
    }
    else if( vt == (VT_ARRAY | VT_UI1) )
    {
        long        lBound, uBound, lItem;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

        // array of VT_UI1 (probably OctetString)   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hr = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hr = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)malloc(cV)) )
        {
            hr = E_OUTOFMEMORY;
            VariantClear( &vOut );
            return hr;
        }

        hr = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hr  = SafeArrayGetElement( pSafeArray, &lItem, &bValue );
            if( FAILED( hr ) )
            {
                break;
            }
            pbV[lItem-lBound] = bValue;
        }

        *psz = (LPSTR)pbV;
        *pdwLen = cV;
    }
    else if( vt == (VT_ARRAY | VT_VARIANT) )
    {
        long        lBound, uBound, lItem;
        VARIANT     vValue;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_VARIANT (probably VT_I4 )
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hr = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hr = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)malloc(cV)) )
        {
            hr = E_OUTOFMEMORY;
            VariantClear( &vOut );
            return hr;
        }

        hr = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hr  = SafeArrayGetElement( pSafeArray, &lItem, &vValue );
            if( FAILED( hr ) )
            {
                break;
            }
            if ( V_VT(&vValue) == VT_UI1 )
            {
                bValue = V_UI1(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I2 )
            {
                bValue = (BYTE)V_I2(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I4 )
            {
                bValue = (BYTE)V_I4(&vValue);
            }
            else
            {
                bValue = 0;
            }
            pbV[lItem-lBound] = bValue;
        }

        *psz = (LPSTR)pbV;
        *pdwLen = cV;
    }
    else
    {
        hr = E_FAIL;
    }

    VariantClear( &vOut );
    if(FAILED(hr))
    {
        *psz    = NULL;
        *pdwLen = 0;
        free(pbV);
        pbV     = NULL;
    }
    return hr;
}


VOID CCertMapperMethod::FreeString( 
    LPSTR   psz 
    )
{
    if ( psz )
    {
        free( psz );
    }
}


HRESULT CCertMapperMethod::SetBSTR( 
    BSTR*   pbstrRet,
    DWORD   cch, 
    LPBYTE  sz 
    )
{
	BSTR bstrRet;
	
	if (sz == NULL)
	{
		*pbstrRet = NULL;
		return(NOERROR);
	}
		
	// Allocate a string of the desired length
	// SysAllocStringLen allocates enough room for unicode characters plus a null
	// Given a NULL string it will just allocate the space
	bstrRet = SysAllocStringLen(NULL, cch);
	if (bstrRet == NULL)
    {
		return(E_OUTOFMEMORY);
    }

	// If we were given "", we will have cch=0.  return the empty bstr
	// otherwise, really copy/convert the string
	// NOTE we pass -1 as 4th parameter of MultiByteToWideChar for DBCS support

	if (cch != 0)
	{
		UINT cchTemp = 0;
		if (MultiByteToWideChar(CP_ACP, 0, (LPSTR)sz, -1, bstrRet, cch+1) == 0)
        {
			return(HRESULT_FROM_WIN32(GetLastError()));
        }

		// If there are some DBCS characters in the sz(Input), then, the character count of BSTR(DWORD) is 
		// already set to cch(strlen(sz)) in SysAllocStringLen(NULL, cch), we cannot change the count, 
		// and later call of SysStringLen(bstr) always returns the number of characters specified in the
		// cch parameter at allocation time.  Bad, because one DBCS character(2 bytes) will convert
		// to one UNICODE character(2 bytes), not 2 UNICODE characters(4 bytes).
		// Example: For input sz contains only one DBCS character, we want to see SysStringLen(bstr) 
		// = 1, not 2.
		bstrRet[cch] = 0;
		cchTemp = wcslen(bstrRet);
		if (cchTemp < cch)
		{
			BSTR bstrTemp = SysAllocString(bstrRet);
			SysFreeString(bstrRet);
			bstrRet = bstrTemp;	
			cch = cchTemp;
		}
	}

	bstrRet[cch] = 0;
	*pbstrRet = bstrRet;

	return(NOERROR);
}

HRESULT CCertMapperMethod::Init( 
    LPCWSTR  pszMetabasePath 
    )
{
    DBG_ASSERT(pszMetabasePath != NULL);

    UINT cL;

    cL = wcslen( pszMetabasePath );
    while ( cL && pszMetabasePath[cL-1] != L'/' && pszMetabasePath[cL-1] != L'\\' )
    {
        --cL;
    }
    if ( m_pszMetabasePath = (LPWSTR)malloc( cL*sizeof(WCHAR) + sizeof(L"<nsepm>") ) )
    {
        memcpy( m_pszMetabasePath, pszMetabasePath, cL * sizeof(WCHAR) );
        memcpy( m_pszMetabasePath + cL, L"<nsepm>", sizeof(L"<nsepm>") );
    }
    else
    {
        return E_OUTOFMEMORY;
    }

	return S_OK;
}


HRESULT CCertMapperMethod::SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
{
	SAFEARRAYBOUND  rgsabound[1];
	BYTE *          pbData = NULL;

	// Set the variant type of the output parameter

	V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
	V_ARRAY(pvarReturn) = NULL;

	// Allocate a SafeArray for the data

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = cbLen;

	V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
	if (V_ARRAY(pvarReturn) == NULL)
	{
		return E_OUTOFMEMORY;
	}

	if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
	{
		return E_UNEXPECTED;
	}

	memcpy(pbData, pbIn, cbLen );

	SafeArrayUnaccessData(V_ARRAY(pvarReturn));

	return NOERROR;
}


HRESULT CCertMapperMethod::SetVariantAsBSTR(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
{
    V_VT(pvarReturn) = VT_BSTR;
    return SetBSTR( &V_BSTR(pvarReturn), cbLen, pbIn );
}


HRESULT CCertMapperMethod::SetVariantAsLong(
    VARIANT*    pvarReturn, 
    DWORD       dwV
    )
{
    V_VT(pvarReturn) = VT_I4;
    V_I4(pvarReturn) = dwV;

    return S_OK;
}

HRESULT CCertMapperMethod::OpenAdminBaseKey(
    LPWSTR pszPathName,
    DWORD dwAccessType
    )
{
    if(m_hmd)
        CloseAdminBaseKey();
    
    HRESULT t_hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        pszPathName,
        dwAccessType,
        DEFAULT_TIMEOUT_VALUE,       // 30 seconds
        &m_hmd 
        );

    if(FAILED(t_hr))
        m_hmd = NULL;

    return t_hr;
}


VOID CCertMapperMethod::CloseAdminBaseKey()
{
    if(m_hmd && m_pIABase)
    {
        m_pIABase->CloseKey(m_hmd);
        m_hmd = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\globdata.cpp ===
#include "iisprov.h"

//
// Initialize WMI_ASSOCIATION_TYPE_DATA
//
WMI_ASSOCIATION_TYPE WMI_ASSOCIATION_TYPE_DATA::s_ElementSetting = 
    { L"Element", L"Setting", g_wszElementSettingAssocParent, g_wszExtElementSettingAssocParent };
WMI_ASSOCIATION_TYPE WMI_ASSOCIATION_TYPE_DATA::s_Component = 
    { L"GroupComponent", L"PartComponent", g_wszGroupPartAssocParent, g_wszExtGroupPartAssocParent };
WMI_ASSOCIATION_TYPE WMI_ASSOCIATION_TYPE_DATA::s_AdminACL =
    { L"GroupComponent", L"PartComponent", g_wszGroupPartAssocParent, g_wszExtGroupPartAssocParent };
WMI_ASSOCIATION_TYPE WMI_ASSOCIATION_TYPE_DATA::s_IPSecurity =
    { L"Element", L"Setting", g_wszElementSettingAssocParent, g_wszExtElementSettingAssocParent };

//
// Initialize METABASE_KEYTYPE_DATA
//
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsApplicationPool = 
{
    L"IIsApplicationPool", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsApplicationPools = 
{
    L"IIsApplicationPools", NULL, L"/LM/w3svc/AppPools"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsCertMapper = 
{
    L"IIsCertMapper", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsCompressionScheme = 
{
    L"IIsCompressionScheme", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsCompressionSchemes = 
{
    L"IIsCompressionSchemes", NULL, L"/LM/w3svc/Filters/Compression/Parameters"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsComputer = 
{
    L"IIsComputer", NULL, L"/LM"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsCustomLogModule = 
{
    L"IIsCustomLogModule", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFilter = 
{
    L"IIsFilter", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFilters = 
{
    L"IIsFilters", NULL, L"/LM/w3svc/filters"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFtpInfo = 
{
    L"IIsFtpInfo", NULL, L"/LM/msftpsvc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFtpServer = 
{
    L"IIsFtpServer", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFtpService = 
{
    L"IIsFtpService", NULL, L"/LM/msftpsvc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir = 
{
    L"IIsFtpVirtualDir", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsImapInfo = 
{
    L"IIsImapInfo", NULL, L"/LM/imapsvc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsImapService = 
{
    L"IIsImapService", NULL, L"/LM/imapsvc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsLogModule = 
{
    L"IIsLogModule", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsLogModules = 
{
    L"IIsLogModules", NULL, L"/LM/Logging"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsMimeMap = 
{
    L"IIsMimeMap", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsNntpInfo = 
{
    L"IIsNntpInfo", NULL, L"/LM/nntpsvc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsNntpService = 
{
    L"IIsNntpService", NULL, L"/LM/nntpsvc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsObject = 
{
    L"IIsObject", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsPop3Info = 
{
    L"IIsPop3Info", NULL, L"/LM/pop3svc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsPop3Service = 
{
    L"IIsPop3Service", NULL, L"/LM/pop3svc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsSmtpInfo = 
{
    L"IIsSmtpInfo", NULL, L"/LM/smtpsvc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsSmtpService = 
{
    L"IIsSmtpService", NULL, L"/LM/smtpsvc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebDirectory = 
{
    L"IIsWebDirectory", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebFile = 
{
    L"IIsWebFile", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebInfo = 
{
    L"IIsWebInfo", NULL, L"/LM/w3svc/info"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebServer = 
{
    L"IIsWebServer", NULL, NULL
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebService = 
{
    L"IIsWebService", NULL, L"/LM/w3svc"
};
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir = 
{
    L"IIsWebVirtualDir", NULL, NULL
};

//
// These are special.  They don't get put into the hashtable of keytypes
//
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_TYPE_AdminACL = { NULL, NULL };
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_TYPE_AdminACE = { NULL, NULL };
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity = { NULL, NULL };
METABASE_KEYTYPE METABASE_KEYTYPE_DATA::s_NO_TYPE = { NULL, NULL };

METABASE_KEYTYPE* METABASE_KEYTYPE_DATA::s_MetabaseKeyTypes[] = 
{
    &s_IIsApplicationPool,
    &s_IIsApplicationPools,
    &s_IIsCertMapper,
    &s_IIsCompressionScheme,
    &s_IIsCompressionSchemes,
    &s_IIsComputer,
    &s_IIsCustomLogModule,
    &s_IIsFilter,
    &s_IIsFilters,
    &s_IIsFtpInfo,
    &s_IIsFtpServer,
    &s_IIsFtpService,
    &s_IIsFtpVirtualDir,
    &s_IIsImapInfo,
    &s_IIsImapService,
    &s_IIsLogModule,
    &s_IIsLogModules,
    &s_IIsMimeMap,
    &s_IIsNntpInfo,
    &s_IIsNntpService,
    &s_IIsObject,
    &s_IIsPop3Info,
    &s_IIsPop3Service,
    &s_IIsSmtpInfo,
    &s_IIsSmtpService,
    &s_IIsWebDirectory,
    &s_IIsWebFile,
    &s_IIsWebInfo,
    &s_IIsWebServer,
    &s_IIsWebService,
    &s_IIsWebVirtualDir,

    &s_TYPE_AdminACL,
    &s_TYPE_AdminACE,
    &s_TYPE_IPSecurity,
    &s_NO_TYPE,

    NULL
};


///
// initialize METABASE_PROPERTY_DATA
//
METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppRoot =
    { L"AppRoot",MD_APP_ROOT, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, TRUE, NULL };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_Path =
    { L"Path", MD_VR_PATH, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE, NULL };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerBindings =
    { L"ServerBindings",MD_SERVER_BINDINGS, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE, NULL };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerComment =
    { L"ServerComment",MD_SERVER_COMMENT, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE, L"" };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_KeyType =
    { L"", MD_KEY_TYPE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE, L"IIsObject", 0 };

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_MetabaseProperties[] = 
{
    &s_AppRoot,
    &s_Path,
    &s_ServerBindings,
    &s_ServerComment,
    &s_KeyType,
    NULL
};


//
//initiailze WMI_METHOD_PARAM_DATA
//
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Applications = { L"Applications", CIM_STRING | VT_ARRAY, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_AppMode = { L"AppMode", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupDateTimeOut = { L"BackupDateTimeOut", CIM_DATETIME, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupFlags = { L"BackupFlags", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupLocation = { L"BackupLocation", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupLocation_io = { L"BackupLocation", CIM_STRING, PARAM_INOUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupVersion = { L"BackupVersion", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_BackupVersionOut = { L"BackupVersionOut", CIM_SINT32, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_DestPath = { L"DestPath", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_EnumIndex = { L"EnumIndex", CIM_SINT32, PARAM_IN};
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_FileName = { L"FileName", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_HistoryTime = { L"HistoryTime", CIM_DATETIME, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_IEnabled = { L"IEnabled", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_IEnabled_o = { L"IEnabled", CIM_BOOLEAN, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_IMethod = { L"IMethod", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_IndexIn = { L"IndexIn", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_InProcFlag = { L"InProcFlag", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_AppPoolName = { L"AppPoolName", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_bCreate = { L"bCreate", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MajorVersion = { L"MajorVersion", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MajorVersion_o = { L"MajorVersion", CIM_SINT32, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MDFlags = { L"MDFlags", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MDHistoryLocation = { L"MDHistoryLocation", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MDHistoryLocation_io = { L"MDHistoryLocation", CIM_STRING, PARAM_INOUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MinorVersion = { L"MinorVersion", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_MinorVersion_o = { L"MinorVersion", CIM_SINT32, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_NtAcct = { L"NtAcct", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_NtAcct_o = { L"NtAcct", CIM_STRING, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_NtPwd = { L"NtPwd", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_NtPwd_o = { L"NtPwd", CIM_STRING, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Password = { L"Password", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Passwd = { L"Passwd", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_PathOfRootVirtualDir = { L"PathOfRootVirtualDir", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_Recursive = { L"Recursive", CIM_BOOLEAN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ServerComment = { L"ServerComment", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ServerBindings = { L"ServerBindings", VT_ARRAY | VT_UNKNOWN, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ServerId = { L"ServerId", CIM_SINT32, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_ServerMode = { L"ServerMode", CIM_SINT32, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_SourcePath = { L"SourcePath", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_strName = { L"strName", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_strName_o = { L"strName", CIM_STRING, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_vCert = { L"vCert", CIM_STRING, PARAM_IN };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_vCert_o = { L"vCert", CIM_STRING, PARAM_OUT };
WMI_METHOD_PARAM WMI_METHOD_PARAM_DATA::s_vKey = { L"vKey", CIM_STRING, PARAM_IN };

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_ServiceCreateNewServer[] =
{ 
    &s_ServerComment,
    &s_ServerBindings,
    &s_PathOfRootVirtualDir,
    &s_ServerId,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_GetCurrentMode[] =
{
    &s_ServerMode,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppCreate[] =
{
    &s_InProcFlag,
    &s_AppPoolName,
    &s_bCreate,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppCreate2[] =
{
    &s_AppMode,
    &s_AppPoolName,
    &s_bCreate,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppDelete[] =
{
    &s_Recursive,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppUnLoad[] =
{
    &s_Recursive,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppEnable[] =
{
    &s_Recursive,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_AppDisable[] =
{
    &s_Recursive,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_BackupWithPasswd[] =
{
    &s_BackupLocation,
    &s_BackupVersion,
    &s_BackupFlags,
    &s_Password,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_DeleteBackup[] =
{
    &s_BackupLocation,
    &s_BackupVersion,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_EnumBackups[] =
{
    &s_BackupLocation_io,
    &s_IndexIn,
    &s_BackupVersionOut,
    &s_BackupDateTimeOut,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_RestoreWithPasswd[] =
{
    &s_BackupLocation,
    &s_BackupVersion,
    &s_BackupFlags,
    &s_Password,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_Export[] =
{
    &s_Passwd,
    &s_FileName,
    &s_SourcePath,
    &s_MDFlags,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_Import[] =
{
    &s_Passwd,
    &s_FileName,
    &s_SourcePath,
    &s_DestPath,
    &s_MDFlags,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_RestoreHistory[] =
{
    &s_MDHistoryLocation,
    &s_MajorVersion,
    &s_MinorVersion,
    &s_MDFlags,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_EnumHistory[] =
{
    &s_MDHistoryLocation_io,
    &s_MajorVersion_o,
    &s_MinorVersion_o,
    &s_HistoryTime,
    &s_EnumIndex,
    NULL
};

WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_CreateMapping[] =
{
    &s_vCert,
    &s_NtAcct,
    &s_NtPwd,
    &s_strName,
    &s_IEnabled,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_DeleteMapping[] =
{
    &s_IMethod,
    &s_vKey,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_GetMapping[] =
{
    &s_IMethod,
    &s_vKey,
    &s_vCert_o,
    &s_NtAcct_o,
    &s_NtPwd_o,
    &s_strName_o,
    &s_IEnabled_o,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_SetAcct[] =
{
    &s_IMethod,
    &s_vKey,
    &s_NtAcct,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_SetEnabled[] =
{
    &s_IMethod,
    &s_vKey,
    &s_IEnabled,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_SetName[] =
{
    &s_IMethod,
    &s_vKey,
    &s_strName,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_SetPwd[] =
{
    &s_IMethod,
    &s_vKey,
    &s_NtPwd,
    NULL
};
WMI_METHOD_PARAM* WMI_METHOD_PARAM_DATA::s_EnumAppsInPool[] =
{
    &s_Applications,
    NULL
};


//
//initialize WMI_METHOD_DATA
//
WMI_METHOD WMI_METHOD_DATA::s_ServiceCreateNewServer = {L"CreateNewSite", 0, L"string", WMI_METHOD_PARAM_DATA::s_ServiceCreateNewServer, L"Creates a new site." };
WMI_METHOD WMI_METHOD_DATA::s_GetCurrentMode = {L"GetCurrentMode", 0, NULL, WMI_METHOD_PARAM_DATA::s_GetCurrentMode, L"Returns what mode -- Full Isolation (= 1) or Shared Isolation (= 0) -- the W3SVC is running in." };

WMI_METHOD WMI_METHOD_DATA::s_ServerStart = {L"Start", MD_SERVER_COMMAND_START, NULL, NULL, L"Starts the server." };
WMI_METHOD WMI_METHOD_DATA::s_ServerStop = {L"Stop", MD_SERVER_COMMAND_STOP, NULL, NULL, L"Stops the server." };
WMI_METHOD WMI_METHOD_DATA::s_ServerContinue = {L"Continue", MD_SERVER_COMMAND_CONTINUE, NULL, NULL, L"Continues the server." };
WMI_METHOD WMI_METHOD_DATA::s_ServerPause = {L"Pause", MD_SERVER_COMMAND_PAUSE, NULL, NULL, L"Pauses the server." };

WMI_METHOD WMI_METHOD_DATA::s_AppCreate = {L"AppCreate", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppCreate, L"Creates an application at the specified metabase key(parameter is a Boolean)." };
WMI_METHOD WMI_METHOD_DATA::s_AppCreate2 = {L"AppCreate2", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppCreate2, L"Creates an application at the specified metabase key(parameter is a Long)." };
WMI_METHOD WMI_METHOD_DATA::s_AppDelete = {L"AppDelete", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppDelete, L"Deletes an application definition at the specified key (and its subkeys)." };
WMI_METHOD WMI_METHOD_DATA::s_AppUnLoad = {L"AppUnLoad", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppUnLoad, L"Unloads an application at the specified key (and its subkeys)." };
WMI_METHOD WMI_METHOD_DATA::s_AppDisable = {L"AppDisable", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppDisable, NULL };
WMI_METHOD WMI_METHOD_DATA::s_AppEnable = {L"AppEnable", 0, NULL, WMI_METHOD_PARAM_DATA::s_AppEnable, NULL };
WMI_METHOD WMI_METHOD_DATA::s_AppGetStatus = {L"AppGetStatus", 0, L"uint32", NULL, NULL };
WMI_METHOD WMI_METHOD_DATA::s_AspAppRestart = {L"AspAppRestart", 0, NULL, NULL, L"Restarts the ASP application that invoked it." };

WMI_METHOD WMI_METHOD_DATA::s_SaveData = {L"SaveData", 0, NULL, NULL, L"Explicitly saves the metabase data to disk." };
WMI_METHOD WMI_METHOD_DATA::s_BackupWithPasswd = {L"BackupWithPassword", 0, NULL, WMI_METHOD_PARAM_DATA::s_BackupWithPasswd, L"Saves the metabase to long-term storage." };
WMI_METHOD WMI_METHOD_DATA::s_DeleteBackup = {L"DeleteBackup", 0, NULL, WMI_METHOD_PARAM_DATA::s_DeleteBackup, L"Deletes a metabase backup from long-term storage." };
WMI_METHOD WMI_METHOD_DATA::s_EnumBackups = {L"EnumBackups", 0, NULL, WMI_METHOD_PARAM_DATA::s_EnumBackups, L"Enumerates metabase backups in long-term storage." };
WMI_METHOD WMI_METHOD_DATA::s_RestoreWithPasswd = {L"RestoreWithPassword", 0, NULL, WMI_METHOD_PARAM_DATA::s_RestoreWithPasswd, L"Restores a metabase backup from long-term storage." };
WMI_METHOD WMI_METHOD_DATA::s_Export = {L"Export", 0, NULL, WMI_METHOD_PARAM_DATA::s_Export, NULL };
WMI_METHOD WMI_METHOD_DATA::s_Import = {L"Import", 0, NULL, WMI_METHOD_PARAM_DATA::s_Import, NULL };
WMI_METHOD WMI_METHOD_DATA::s_RestoreHistory = {L"RestoreHistory", 0, NULL, WMI_METHOD_PARAM_DATA::s_RestoreHistory, NULL };
WMI_METHOD WMI_METHOD_DATA::s_EnumHistory = {L"EnumHistory", 0, NULL, WMI_METHOD_PARAM_DATA::s_EnumHistory, NULL };

WMI_METHOD WMI_METHOD_DATA::s_CreateMapping = {L"CreateMapping", 0, NULL, WMI_METHOD_PARAM_DATA::s_CreateMapping, L"Maps a certificate to a Windows account." };
WMI_METHOD WMI_METHOD_DATA::s_DeleteMapping = {L"DeleteMapping", 0, NULL, WMI_METHOD_PARAM_DATA::s_DeleteMapping, L"Deletes an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_GetMapping = {L"GetMapping", 0, NULL, WMI_METHOD_PARAM_DATA::s_GetMapping, L"Retrieves a certificate and the mapping data from an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_SetAcct = {L"SetAcct", 0, NULL, WMI_METHOD_PARAM_DATA::s_SetAcct, L"Sets a new value for the Windows account string in an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_SetEnabled = {L"SetEnabled", 0, NULL, WMI_METHOD_PARAM_DATA::s_SetEnabled, L"Enables or disables an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_SetName = {L"SetName", 0, NULL, WMI_METHOD_PARAM_DATA::s_SetName, L"Sets a new value for the name string in an existing certificate mapping." };
WMI_METHOD WMI_METHOD_DATA::s_SetPwd = {L"SetPwd", 0, NULL, WMI_METHOD_PARAM_DATA::s_SetPwd, L"Sets a new value for the Windows password string in an existing certificate mapping." };

WMI_METHOD WMI_METHOD_DATA::s_RecycleAppPool = {L"RecycleAppPool", 0, NULL, NULL, L"Recycle an already enabled application pool on demand" };
WMI_METHOD WMI_METHOD_DATA::s_EnumAppsInPool = {L"EnumAppsInPool", 0, NULL, WMI_METHOD_PARAM_DATA::s_EnumAppsInPool, L"Determine which applications are currently routed to the given application pool" };
WMI_METHOD WMI_METHOD_DATA::s_Start = {L"Start", 0, NULL, NULL, L"Starts an application pool"};
WMI_METHOD WMI_METHOD_DATA::s_Stop = {L"Stop", 0, NULL, NULL, L"Stops an application pool"};


WMI_METHOD* WMI_METHOD_DATA::s_WebServiceMethods[] = 
{
    &s_ServiceCreateNewServer,
    &s_GetCurrentMode,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_ServiceMethods[] = 
{
    &s_ServiceCreateNewServer,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_ServerMethods[] = 
{
    &s_ServerStart,
    &s_ServerStop,
    &s_ServerContinue,
    &s_ServerPause,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_WebAppMethods[] = 
{
    &s_AppCreate,
    &s_AppCreate2,
    &s_AppDelete,
    &s_AppUnLoad,
    &s_AppDisable,
    &s_AppEnable,
    &s_AppGetStatus,
    &s_AspAppRestart,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_ComputerMethods[] = 
{
    &s_SaveData,
    &s_BackupWithPasswd,
    &s_DeleteBackup,
    &s_EnumBackups,
    &s_RestoreWithPasswd,
    &s_Export,
    &s_Import,
    &s_RestoreHistory,
    &s_EnumHistory,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_CertMapperMethods[] = 
{
    &s_CreateMapping,
    &s_DeleteMapping,
    &s_GetMapping,
    &s_SetAcct,
    &s_SetEnabled,
    &s_SetName,
    &s_SetPwd,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_AppPoolMethods[] =
{
    &s_EnumAppsInPool,
    &s_RecycleAppPool,
    &s_Start,
    &s_Stop,
    NULL
};


//
// initialize WMI_CLASS_DATA
//
//** Computer
WMI_CLASS WMI_CLASS_DATA::s_Computer   =
    {L"IIsComputer", L"", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsComputer, WMI_METHOD_DATA::s_ComputerMethods, SHIPPED_TO_MOF, L"CIM_ApplicationSystem", true, NULL};
WMI_CLASS WMI_CLASS_DATA::s_ComputerSetting   =
    {L"IIsComputerSetting", L"", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsComputer, NULL, SHIPPED_TO_MOF, g_wszSettingParent, true, NULL};

//** FtpService
WMI_CLASS WMI_CLASS_DATA::s_FtpService = 
    {L"IIsFtpService", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsFtpService, WMI_METHOD_DATA::s_ServiceMethods, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eWin32_Service], false, NULL};

//** FtpServer
WMI_CLASS WMI_CLASS_DATA::s_FtpServer  = 
    {L"IIsFtpServer", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsFtpServer, WMI_METHOD_DATA::s_ServerMethods, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** FtpVirtualDir
WMI_CLASS WMI_CLASS_DATA::s_FtpVirtualDir = 
    {L"IIsFtpVirtualDir",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsFtpVirtualDir, NULL, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eIIsDirectory], true, NULL};

//** WebService
WMI_CLASS WMI_CLASS_DATA::s_WebService =    
    {L"IIsWebService", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebService, WMI_METHOD_DATA::s_WebServiceMethods, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eWin32_Service], false, NULL};

//** WebFilter
WMI_CLASS WMI_CLASS_DATA::s_WebFilter =
    {L"IIsFilter", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsFilter, NULL, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** WebServer
WMI_CLASS WMI_CLASS_DATA::s_WebServer =
    {L"IIsWebServer", L"/LM", L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebServer, WMI_METHOD_DATA::s_ServerMethods, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** Web CertMapper
WMI_CLASS WMI_CLASS_DATA::s_WebCertMapper = 
    {L"IIsCertMapper",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsCertMapper, WMI_METHOD_DATA::s_CertMapperMethods, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** Web VirtualDir
WMI_CLASS WMI_CLASS_DATA::s_WebVirtualDir = 
    {L"IIsWebVirtualDir",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebVirtualDir, WMI_METHOD_DATA::s_WebAppMethods, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eIIsDirectory], true, NULL};

//** Web Directory
WMI_CLASS WMI_CLASS_DATA::s_WebDirectory = 
    {L"IIsWebDirectory",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebDirectory, WMI_METHOD_DATA::s_WebAppMethods, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eIIsDirectory], true, NULL};

//** Web File
WMI_CLASS WMI_CLASS_DATA::s_WebFile = 
    {L"IIsWebFile",L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_IIsWebFile, NULL, SHIPPED_TO_MOF, g_awszParentClassWithNamePK[eIIsDirectory], true, NULL};

//** Application Pool
WMI_CLASS WMI_CLASS_DATA::s_ApplicationPool =
    {L"IIsApplicationPool",L"/LM",L"Name",NULL, &METABASE_KEYTYPE_DATA::s_IIsApplicationPool, WMI_METHOD_DATA::s_AppPoolMethods, SHIPPED_TO_MOF, g_wszElementParent, true, NULL};

//** AdminACL
WMI_CLASS WMI_CLASS_DATA::s_AdminACL = 
    {L"IIsAdminACL", L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_TYPE_AdminACL, NULL, SHIPPED_NOT_TO_MOF, g_wszElementParent, true, NULL};

WMI_CLASS WMI_CLASS_DATA::s_ACE = 
    {L"IIsACE", L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_TYPE_AdminACE, NULL, SHIPPED_NOT_TO_MOF, g_wszElementParent, true, NULL};

//** IPSecurity
WMI_CLASS WMI_CLASS_DATA::s_IPSecurity = 
    {L"IIsIPSecuritySetting", L"/LM",L"Name", NULL, &METABASE_KEYTYPE_DATA::s_TYPE_IPSecurity, NULL, SHIPPED_NOT_TO_MOF, g_wszSettingParent, true, NULL};

WMI_CLASS* WMI_CLASS_DATA:: s_WmiClasses[] = 
{
    &s_Computer,
    &s_ComputerSetting,

    &s_FtpService,
    &s_FtpServer,
    &s_FtpVirtualDir,

    &s_WebService,
    &s_WebFilter,
    &s_WebServer,
    &s_WebCertMapper,
    &s_WebVirtualDir,
    &s_WebDirectory,
    &s_WebFile,

    &s_ApplicationPool,

    &s_AdminACL,
    &s_ACE,    
    &s_IPSecurity,

    NULL
};


//** Hard-coded Associations
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_AdminACLToACE = 
    { L"IIsAdminACL_IIsACE", &WMI_CLASS_DATA::s_AdminACL, &WMI_CLASS_DATA::s_ACE, &WMI_ASSOCIATION_TYPE_DATA::s_AdminACL, 0, SHIPPED_TO_MOF, g_wszGroupPartAssocParent};

WMI_ASSOCIATION* WMI_ASSOCIATION_DATA:: s_WmiAssociations[] = 
{
    &s_AdminACLToACE,
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\globalconstants.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    GlobalConstants.h

Abstract:

    Global include file.

Author:

    ???

Revision History:

    Mohit Srivastava            22-Mar-01

--*/

#ifndef _globalconstants_H_
#define _globalconstants_H_

#include <windows.h>

//
// Provider name
//
static LPCWSTR g_wszIIsProvider = L"IIS__PROVIDER";

//
// Instance level property qualifiers
//
static LPCWSTR       g_wszIsInherit              = L"IsInherit";
static const ULONG   g_cchIsInherit              = wcslen(g_wszIsInherit);
static LPCWSTR       g_wszIsDefault              = L"IsDefault";
static const ULONG   g_cchIsDefault              = wcslen(g_wszIsDefault);
static LPCWSTR       g_wszForcePropertyOverwrite = L"ForcePropertyOverwrite";
static const ULONG   g_cchForcePropertyOverwrite = wcslen(g_wszForcePropertyOverwrite);

static const ULONG   g_fIsInherit                = 0x1;
static const ULONG   g_fIsDefault                = 0x2;
static const ULONG   g_fForcePropertyOverwrite   = 0x4;

//
// Instance level qualifiers
//
static LPCWSTR       g_wszInstanceName           = L"InstanceName";
static const ULONG   g_cchInstanceName           = wcslen(g_wszInstanceName);
static LPCWSTR       g_wszInstanceExists         = L"InstanceExists";
static const ULONG   g_cchInstanceExists         = wcslen(g_wszInstanceExists);

static const ULONG   g_idxInstanceName            = 0;
static const ULONG   g_idxInstanceExists          = 1;

//
// These contants are used by globdata.cpp
//

static const ULONG ALL_BITS_ON = 0xFFFFFFFF;

static const ULONG PARAM_IN    = 0;
static const ULONG PARAM_OUT   = 1;
static const ULONG PARAM_INOUT = 2;

static const LPWSTR g_wszGroupPartAssocParent       = L"CIM_Component";
static const LPWSTR g_wszElementSettingAssocParent  = L"CIM_ElementSetting";
static const LPWSTR g_wszElementParent              = L"CIM_LogicalElement";
static const LPWSTR g_wszSettingParent              = L"IIsSetting";

static const LPWSTR g_wszExtGroupPartAssocParent       = L"IIsUserDefinedComponent";
static const LPWSTR g_wszExtElementSettingAssocParent  = L"IIsUserDefinedElementSetting";
static const LPWSTR g_wszExtElementParent              = L"IIsUserDefinedLogicalElement";
static const LPWSTR g_wszExtSettingParent              = L"IIsUserDefinedSetting";

//
// This is used by globdata, mofgen, and pusher
// A few base classes already have a "Name" primary key.  We should not
// be putting the "Name" property in child classes.
//
static enum tagParentClassWithNamePK
{
    eIIsDirectory  = 0,
    eWin32_Service = 1
} eParentClassWithNamePK;
static const LPWSTR g_awszParentClassWithNamePK[] = { L"IIsDirectory", L"Win32_Service", NULL };

//
// Used by dwExtended field of WMI_CLASS and WMI_ASSOCIATION
//
static const ULONG SHIPPED_TO_MOF                      = 1;
static const ULONG SHIPPED_NOT_TO_MOF                  = 2;
static const ULONG EXTENDED                            = 3;
static const ULONG USER_DEFINED_TO_REPOSITORY          = 4;
static const ULONG USER_DEFINED_NOT_TO_REPOSITORY      = 5;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\iisprov.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    iisprov.h

Abstract:

    Global include file.  This file is included by pretty much everything, so
    to minimize dependencies, only put stuff in here that will be used by majority 
    of files.

Author:

    ???

Revision History:

    Mohit Srivastava            18-Dec-00

--*/

#ifndef _iisprov_H_
#define _iisprov_H_

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <objbase.h>
#include <initguid.h>

#include <windows.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <comdef.h>
#include <stdio.h>

#include <atlbase.h>
#include "iisfiles.h"
#include <eventlog.hxx>

#include "ProviderBase.h"
#include "schema.h"
#include "schemadynamic.h"
#include "hashtable.h"
#include "metabase.h"
#include "utils.h"
#include "globalconstants.h"


//
// These variables keep track of when the module can be unloaded
//
extern long  g_cLock;

//
// Provider interfaces are provided by objects of this class
//
class CIISInstProvider : public CProviderBase
{
public:
    static bool     ms_bInitialized; // If Initialize succeeded

    //
    // Implemented
    //
    CIISInstProvider(
        BSTR ObjectPath = NULL, 
        BSTR User = NULL, 
        BSTR Password = NULL, 
        IWbemContext* pCtx = NULL)
    {}

    HRESULT STDMETHODCALLTYPE DoInitialize(
        LPWSTR                      i_wszUser,
        LONG                        i_lFlags,
        LPWSTR                      i_wszNamespace,
        LPWSTR                      i_wszLocale,
        IWbemServices*              i_pNamespace,
        IWbemContext*               i_pCtx,
        IWbemProviderInitSink*      i_pInitSink);

    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
        const BSTR                  i_ClassName,
        long                        i_lFlags, 
        IWbemContext __RPC_FAR*     i_pCtx, 
        IWbemObjectSink __RPC_FAR*  i_pHandler);

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        const BSTR                  i_ObjectPath, 
        long                        i_lFlags,
        IWbemContext __RPC_FAR*     i_pCtx,
        IWbemObjectSink __RPC_FAR*  i_pHandler);

    HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        const BSTR                  i_strObjectPath,                   
        const BSTR                  i_strMethodName,
        long                        i_lFlags,                       
        IWbemContext*               i_pCtx,                 
        IWbemClassObject*           i_pInParams,
        IWbemObjectSink*            i_pHandler);

    HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        const BSTR                  i_ObjectPath, 
        long                        i_lFlags,
        IWbemContext __RPC_FAR*     i_pCtx,
        IWbemObjectSink __RPC_FAR*  i_pHandler);

    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
        IWbemClassObject __RPC_FAR* i_pObj,
        long                        i_lFlags,
        IWbemContext __RPC_FAR*     i_pCtx,
        IWbemObjectSink __RPC_FAR*  i_pHandler);

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        const BSTR                  i_bstrQueryLanguage,
        const BSTR                  i_bstrQuery,
        long                        i_lFlags,
        IWbemContext __RPC_FAR*     i_pCtx,
        IWbemObjectSink __RPC_FAR*  i_pResponseHandler);

private:
    IWbemClassObject* ConstructExtendedStatus(
        const CIIsProvException* i_pException) const;

    IWbemClassObject* ConstructExtendedStatus(
        HRESULT i_hr) const;

    void ValidatePutParsedObject(
        ParsedObjectPath*    i_pParsedObject,
        IWbemClassObject*    i_pObj,
        bool*                io_pbInstanceNameSame,
        bool*                io_pbInstanceExists,
        WMI_CLASS**          o_ppWmiClass = NULL);

    //
    // Worker methods called by public methods
    //
    void WorkerGetObjectAsync(
        IWbemClassObject**   o_ppObj,
        BSTR                 i_bstrObjPath,
        bool                 i_bCreateKeyIfNotExist);

    void WorkerGetObjectAsync(
        IWbemClassObject**   o_ppObj,
        ParsedObjectPath*    i_pParsedObjPath,
        bool                 i_bCreateKeyIfNotExist);

    void WorkerExecMethodAsync(
        BSTR                 i_strObjectPath,
        BSTR                 i_strMethodName,
        IWbemContext*        i_pCtx, 
        IWbemClassObject*    i_pInParams,
        IWbemObjectSink*     i_pHandler);

    void WorkerDeleteObjectAsync(
        ParsedObjectPath*    i_pParsedObject);

    void WorkerPutObjectAsync(
        IWbemClassObject*    i_pObj,
        IWbemClassObject*    i_pObjOld,               // can be NULL
        ParsedObjectPath*    i_pParsedObject,
        long                 i_lFlags,
        bool                 i_bInstanceExists,
        BSTR*                o_pbstrObjPath);

    void WorkerEnumObjectAsync(
        BSTR                 i_bstrClassName,
        IWbemObjectSink FAR* i_pHandler);

    //
    // These methods should only be called by WorkerExecMethodAsync
    //
    void WorkerExecFtpServiceMethod(
        LPCWSTR             i_wszMbPath,
        WMI_CLASS*          i_pClass,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler);

    void WorkerExecWebServiceMethod(
        LPCWSTR             i_wszMbPath,
        WMI_CLASS*          i_pClass,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler);

    static void WorkerExecWebAppMethod(
        LPCWSTR             i_wszMbPath,
        LPCWSTR             i_wszClassName,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler,
        CWbemServices*      i_pNameSpace);

    static void WorkerExecComputerMethod(
        LPCWSTR             i_wszMbPath,
        LPCWSTR             i_wszClassName,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler,
        CWbemServices*      i_pNameSpace);

    static void WorkerExecCertMapperMethod(
        LPCWSTR             i_wszMbPath,
        LPCWSTR             i_wszClassName,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler,
        CWbemServices*      i_pNameSpace);

    static void WorkerExecAppPoolMethod(
        LPCWSTR             i_wszMbPath,
        LPCWSTR             i_wszClassName,
        WMI_METHOD*         i_pMethod,
        IWbemContext*       i_pCtx, 
        IWbemClassObject*   i_pInParams,
        IWbemObjectSink*    i_pHandler,
        CWbemServices*      i_pNameSpace);
};


// This class is the class factory for CInstPro objects.

class CProvFactory : public IClassFactory
{
protected:
    ULONG           m_cRef;

public:
    CProvFactory(void);
    ~CProvFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\iisfiles.h ===
#ifndef _iisfiles_h_
#define _iisfiles_h_

#include <iadmw.h>
#include <wincrypt.h>
#include <iiscnfg.h>    // public\sdk\inc
#include "iiscnfgp.h"   // got from inetsrv\iis\inc (build iis)
#include <iwamreg.h>    // public\sdk\inc
#include <dbgutil.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\admin\wmiprov_dynamic\hashtable.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    hashtable.h

Abstract:

    Implementation of:
    CPool<T>, CStringPool, CHashTableElement<T>

Author:

    Mohit Srivastava            10-Nov-2000

Revision History:

--*/

#include "iisprov.h"

template CPool<METABASE_PROPERTY>;
template CHashTable<METABASE_PROPERTY*>;

template CPool<WMI_CLASS>;
template CHashTable<WMI_CLASS*>;

template CPool<WMI_ASSOCIATION>;
template CHashTable<WMI_ASSOCIATION*>;

template CPool<METABASE_KEYTYPE>;
template CHashTable<METABASE_KEYTYPE*>;

template CArrayPool<wchar_t, ::STRING_POOL_STRING_SIZE>;
template CArrayPool<METABASE_PROPERTY*, 10>;
template CArrayPool<BYTE, 10>;

template CPool<METABASE_KEYTYPE_NODE>;

//
// CPool<T>
//

template <class T>
HRESULT CPool<T>::Initialize(ULONG i_iFirstBucketSize)
/*++

Synopsis: 
    Set up data structures:
        Initialize array to size CPool::ARRAY_SIZE
        Create first bucket of size i_iFirstBucketSize

Arguments: [i_iFirstBucketSize] - 
           
Return Value: 
    S_OK, E_OUTOFMEMORY

--*/
{
    DBG_ASSERT(m_bInitCalled     == false);
    DBG_ASSERT(m_bInitSuccessful == false);
    m_bInitCalled = true;

    HRESULT hr = S_OK;

    m_apBuckets = new T*[ARRAY_SIZE];
    if(m_apBuckets == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    m_iArraySize     = ARRAY_SIZE;
    m_iArrayPosition = 1;

    m_apBuckets[0] = new T[i_iFirstBucketSize];
    if(m_apBuckets[0] == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    m_iCurrentBucketSize     = i_iFirstBucketSize;
    m_iFirstBucketSize       = i_iFirstBucketSize;
    m_iCurrentBucketPosition = 0;

exit:
    if(SUCCEEDED(hr))
    {
        m_bInitSuccessful = true;
    }
    return hr;
}

template <class T>
HRESULT CPool<T>::GetNewElement(T** o_ppElement)
/*++

Synopsis: 
    Normally, just a matter of returning pointer to next spot in bucket.
    May have to create a new bucket and/or grow the array, however.

Arguments: [o_ppElement] - 
           
Return Value: 
    S_OK, E_OUTOFMEMORY

--*/{
    DBG_ASSERT(m_bInitCalled == true);
    DBG_ASSERT(m_bInitSuccessful == true);
    DBG_ASSERT(o_ppElement != NULL);

    HRESULT hr = S_OK;

    //
    // Check to see if we need to move on to the next bucket
    //
    if(m_iCurrentBucketPosition == m_iCurrentBucketSize)
    {
        //
        // Check to see if we need to grow the array
        //
        if(m_iArrayPosition == m_iArraySize)
        {
            T** apBucketsNew;
            apBucketsNew = new T*[m_iArraySize*2];
            if(m_apBuckets == NULL)
            {
                return E_OUTOFMEMORY;
            }
            memcpy(apBucketsNew, m_apBuckets, m_iArraySize * sizeof(T*));            
            delete [] m_apBuckets;
            m_apBuckets   = apBucketsNew;
            m_iArraySize *= 2;
        }

        T* pBucketNew;
        pBucketNew = new T[m_iCurrentBucketSize*2];
        if(pBucketNew == NULL)
        {
            return E_OUTOFMEMORY;
        }
        m_apBuckets[m_iArrayPosition] = pBucketNew;
        m_iCurrentBucketSize *= 2;
        m_iCurrentBucketPosition = 0;
        m_iArrayPosition++;
    }
    *o_ppElement = &m_apBuckets[m_iArrayPosition-1][m_iCurrentBucketPosition];
    m_iCurrentBucketPosition++;

    return hr;
}


template <class T>
T* CPool<T>::Lookup(ULONG i_idx) const
/*++

Synopsis: 
    Looks up data in pool by index

Arguments: [i_idx] - Valid Range is 0 to GetUsed()-1
           
Return Value: 
    A pointer to the data unless i_idx is out of range.

--*/
{
    DBG_ASSERT(m_bInitCalled     == true);
    DBG_ASSERT(m_bInitSuccessful == true);

    //
    // Total element capacity of all buckets up to and including the current one
    // in the for loop below
    //
    ULONG iElementsCovered = 0;

    ULONG iBucketPos = 0;

    if (i_idx >= GetUsed())
    {
        return NULL;
    }
    for(ULONG i = 0; i < m_iArrayPosition; i++)
    {
        iElementsCovered = iElementsCovered + (1 << i)*(m_iFirstBucketSize);
        if(i_idx < iElementsCovered)
        {
            iBucketPos = 
                i_idx - ( iElementsCovered - (1 << i)*(m_iFirstBucketSize) );
            return &m_apBuckets[i][iBucketPos];
        }            
    }
    return NULL;
}


//
// CArrayPool
//

template <class T, ULONG size>
HRESULT CArrayPool<T, size>::Initialize()
/*++

Synopsis: 
    should only be called once

Return Value: 

--*/
{
    HRESULT hr = S_OK;
    hr = m_PoolFixedSize.Initialize(FIRST_BUCKET_SIZE);
    if(FAILED(hr))
    {
        return hr;
    }
    hr = m_PoolDynamic.Initialize(FIRST_BUCKET_SIZE);
    if(FAILED(hr))
    {
        return hr;
    }
    return hr;
}

template <class T, ULONG size>
HRESULT CArrayPool<T, size>::GetNewArray(ULONG i_cElem, T** o_ppElem)
/*++

Synopsis: 
    Fills o_ppElem from either the fixedsize or dynamic pool based on the
    requested size.

Arguments: [i_cElem] - number of elements caller wants in new array
           [o_ppElem] - receives the new array
           
Return Value: 

--*/
{
    DBG_ASSERT(o_ppElem != NULL);

    HRESULT hr = S_OK;
    T** ppNew = NULL;
    T*  pNew  = NULL;
    if(i_cElem <= size)
    {
        hr = m_PoolFixedSize.GetNewElement((CArrayPoolEntry<T,size>**)&pNew);
        if(FAILED(hr))
        {
            return hr;
        }
        ppNew = &pNew;
    }
    else
    {
        hr = m_PoolDynamic.GetNewElement(&ppNew);
        if(FAILED(hr))
        {
            return hr;
        }
        *ppNew = NULL;
        *ppNew = new T[i_cElem+1];
        if(*ppNew == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }
    *o_ppElem = *ppNew;
    return hr;
}

//
// for debugging only
// if msb set, goto dynamic pool
// else use fixedsize pool
//
template <class T, ULONG size>
T* CArrayPool<T, size>::Lookup(ULONG i_idx) const
{
    ULONG i_msb;
    i_msb = i_idx >> 31;

    if(i_msb == 0)
    {
        return (T *)(m_PoolFixedSize.Lookup(i_idx));
    }
    else {
        T** pElem = m_PoolDynamic.Lookup( i_idx - (ULONG)(1 << 31) );
