\n"));
		T* pT = static_cast<T*>(this);
		*pClassID = pT->GetObjectCLSID();
		return S_OK;
	}

	// IPersistPropertyBag
	//
	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::InitNew\n"));
		return S_OK;
	}
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		return pT->IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap);
	}
	STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
	{
		ATLTRACE(_T("IPersistPropertyBagImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		return pT->IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleControlImpl
template <class T>
class ATL_NO_VTABLE IOleControlImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleControlImpl)

	// IOleControl methods
	//
	STDMETHOD(GetControlInfo)(LPCONTROLINFO /* pCI */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));
	}
	STDMETHOD(OnMnemonic)(LPMSG /* pMsg */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));
	}
	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		dispid;
		ATLTRACE(_T("IOleControlImpl::OnAmbientPropertyChange\n"));
		ATLTRACE(_T(" -- DISPID = %d (%d)\n"), dispid);
		return S_OK;
	}
	STDMETHOD(FreezeEvents)(BOOL bFreeze)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleControlImpl::FreezeEvents\n"));
		if (bFreeze)
			pT->m_nFreezeEvents++;
		else
			pT->m_nFreezeEvents--;
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IQuickActivateImpl
template <class T>
class ATL_NO_VTABLE IQuickActivateImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IQuickActivateImpl)

	// IQuickActivate
	//
	STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::QuickActivate\n"));
		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
	}
	STDMETHOD(SetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::SetContentExtent\n"));
		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);
	}
	STDMETHOD(GetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IQuickActivateImpl::GetContentExtent\n"));
		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleObjectImpl
template <class T>
class ATL_NO_VTABLE IOleObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleObjectImpl)

	// IOleObject
	//
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::SetClientSite\n"));
		return pT->IOleObject_SetClientSite(pClientSite);
	}
	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::GetClientSite\n"));
		return pT->IOleObject_GetClientSite(ppClientSite);
	}
	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
		ATLTRACE(_T("IOleObjectImpl::SetHostNames\n"));
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Close\n"));
		return pT->IOleObject_Close(dwSaveOption);
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));
	}

	// Helpers for DoVerb - Over-rideable in user class
	HRESULT DoVerbPrimary(LPCRECT prcPosRect, HWND hwndParent)
	{
		T* pT = static_cast<T*>(this);
		BOOL bDesignMode = FALSE;
		CComVariant var;
		// if container doesn't support this property
		// don't allow design mode
		HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)
			bDesignMode = TRUE;
		if (bDesignMode)
			return pT->DoVerbProperties(prcPosRect, hwndParent);
		else
			return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);
	}
	HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
	}
	HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
	}
	HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		return pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);
	}
	HRESULT DoVerbHide(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		pT->UIDeactivate();
		if (pT->m_hWnd)
			pT->ShowWindow(SW_HIDE);
		return S_OK;
	}
	HRESULT DoVerbOpen(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		return S_OK;
	}
	HRESULT DoVerbDiscardUndo(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		return S_OK;
	}
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::DoVerb\n"));
		_ASSERTE(pT->m_spClientSite);

		HRESULT hr = E_NOTIMPL;
		switch (iVerb)
		{
		case OLEIVERB_PRIMARY:
			hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_SHOW:
			hr = pT->DoVerbShow(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_INPLACEACTIVATE:
			hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_UIACTIVATE:
			hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_HIDE:
			hr = pT->DoVerbHide(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_OPEN:
			hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_DISCARDUNDOSTATE:
			hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_PROPERTIES:
			hr = pT->DoVerbProperties(lprcPosRect, hwndParent);
		}
		return hr;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
		ATLTRACE(_T("IOleObjectImpl::EnumVerbs\n"));
		_ASSERTE(ppEnumOleVerb);
		if (!ppEnumOleVerb)
			return E_POINTER;
		return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);
	}
	STDMETHOD(Update)(void)
	{
		ATLTRACE(_T("IOleObjectImpl::Update\n"));
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
		ATLTRACE(_T("IOleObjectImpl::IsUpToDate\n"));
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
		ATLTRACE(_T("IOleObjectImpl::GetUserClassID\n"));
		_ASSERTE(pClsid);
		if (!pClsid)
			return E_POINTER;
		*pClsid = T::GetObjectCLSID();
		return S_OK;
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
		ATLTRACE(_T("IOleObjectImpl::GetUserType\n"));
		return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::SetExtent\n"));
		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::GetExtent\n"));
		if (dwDrawAspect != DVASPECT_CONTENT)
			return E_FAIL;
		if (psizel == NULL)
			return E_POINTER;
		*psizel = pT->m_sizeExtent;
		return S_OK;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Advise\n"));
		return pT->IOleObject_Advise(pAdvSink, pdwConnection);
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::Unadvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);
		return hRes;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleObjectImpl::EnumAdvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);
		return hRes;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
		ATLTRACE(_T("IOleObjectImpl::GetMiscStatus\n"));
		return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));
	}
};

//local struct used for implementation
#pragma pack(push, 1)
struct _ATL_DLGTEMPLATEEX
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;
};
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// IPropertyPageImpl
template <class T>
class ATL_NO_VTABLE IPropertyPageImpl
{

public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleControlImpl)

	void SetDirty(BOOL bDirty)
	{
		T* pT = static_cast<T*>(this);
		if (!pT->m_bDirty && bDirty)
			pT->m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE);
		pT->m_bDirty = bDirty;
	}

	IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		pT->m_pPageSite = NULL;
		pT->m_size.cx = 0;
		pT->m_size.cy = 0;
		pT->m_dwTitleID = 0;
		pT->m_dwHelpFileID = 0;
		pT->m_dwDocStringID = 0;
		pT->m_dwHelpContext = 0;
		pT->m_ppUnk = NULL;
		pT->m_nObjects = 0;
		pT->m_bDirty = FALSE;
		pT->m_hWnd = NULL;
	}

	~IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_pPageSite != NULL)
			pT->m_pPageSite->Release();

		for (UINT i = 0; i < m_nObjects; i++)
			pT->m_ppUnk[i]->Release();

		delete[] pT->m_ppUnk;
	}

	// IPropertyPage
	//
	STDMETHOD(SetPageSite)(IPropertyPageSite *pPageSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::SetPageSite\n"));

		if (!pPageSite && pT->m_pPageSite)
		{
			pT->m_pPageSite->Release();
			return S_OK;
		}

		if (!pPageSite && !pT->m_pPageSite)
			return S_OK;

		if (pPageSite && pT->m_pPageSite)
		{
			ATLTRACE(_T("Error : setting page site again with non NULL value\n"));
			return E_UNEXPECTED;
		}

		pT->m_pPageSite = pPageSite;
		pT->m_pPageSite->AddRef();
		return S_OK;
	}
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Activate\n"));

		if (pRect == NULL)
		{
			ATLTRACE(_T("Error : Passed a NULL rect\n"));
			return E_POINTER;
		}

		pT->m_hWnd = pT->Create(hWndParent);
		Move(pRect);

		m_size.cx = pRect->right - pRect->left;
		m_size.cy = pRect->bottom - pRect->top;

		return S_OK;

	}
	STDMETHOD(Deactivate)( void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Deactivate\n"));

		if (pT->m_hWnd)
		{
			ATLTRACE(_T("Destroying Dialog\n"));
			if (::IsWindow(pT->m_hWnd))
				pT->DestroyWindow();
			pT->m_hWnd = NULL;
		}

		return S_OK;

	}
	STDMETHOD(GetPageInfo)(PROPPAGEINFO *pPageInfo)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::GetPageInfo\n"));

		if (pPageInfo == NULL)
		{
			ATLTRACE(_T("Error : PROPPAGEINFO passed == NULL\n"));
			return E_POINTER;
		}

		HRSRC hRsrc = FindResource(_Module.GetResourceInstance(),
								   MAKEINTRESOURCE(T::IDD), RT_DIALOG);
		if (hRsrc == NULL)
		{
			ATLTRACE(_T("Could not find resource template\n"));
			return E_UNEXPECTED;
		}

		HGLOBAL hGlob = LoadResource(_Module.GetResourceInstance(), hRsrc);
		DLGTEMPLATE* pTemp = (DLGTEMPLATE*)LockResource(hGlob);
		if (pTemp == NULL)
		{
			ATLTRACE(_T("Could not load resource template\n"));
			return E_UNEXPECTED;
		}
		pT->GetDialogSize(pTemp, &m_size);

		pPageInfo->cb = sizeof(PROPPAGEINFO);
		pPageInfo->pszTitle = LoadStringHelper(pT->m_dwTitleID);
		pPageInfo->size = m_size;
		pPageInfo->pszHelpFile = LoadStringHelper(pT->m_dwHelpFileID);
		pPageInfo->pszDocString = LoadStringHelper(pT->m_dwDocStringID);
		pPageInfo->dwHelpContext = pT->m_dwHelpContext;

		return S_OK;
	}

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::SetObjects\n"));

		if (ppUnk == NULL)
			return E_POINTER;

		if (pT->m_ppUnk != NULL && pT->m_nObjects > 0)
		{
			for (UINT iObj = 0; iObj < pT->m_nObjects; iObj++)
				pT->m_ppUnk[iObj]->Release();

			delete [] pT->m_ppUnk;
		}

		pT->m_ppUnk = NULL;
		ATLTRY(pT->m_ppUnk = new IUnknown*[nObjects]);

		if (pT->m_ppUnk == NULL)
			return E_OUTOFMEMORY;

		for (UINT i = 0; i < nObjects; i++)
		{
			ppUnk[i]->AddRef();
			pT->m_ppUnk[i] = ppUnk[i];
		}

		pT->m_nObjects = nObjects;

		return S_OK;
	}
	STDMETHOD(Show)(UINT nCmdShow)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Show\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		ShowWindow(pT->m_hWnd, nCmdShow);
		return S_OK;
	}
	STDMETHOD(Move)(LPCRECT pRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Move\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		if (pRect == NULL)
			return E_POINTER;

		MoveWindow(pT->m_hWnd, pRect->left, pRect->top, pRect->right - pRect->left,
				 pRect->bottom - pRect->top, TRUE);

		return S_OK;

	}
	STDMETHOD(IsPageDirty)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::IsPageDirty\n"));
		return pT->m_bDirty ? S_OK : S_FALSE;
	}
	STDMETHOD(Apply)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::Apply\n"));
		return S_OK;
	}
	STDMETHOD(Help)(LPCOLESTR pszHelpDir)
	{
		T* pT = static_cast<T*>(this);
		USES_CONVERSION;

		ATLTRACE(_T("IPropertyPageImpl::Help\n"));
		WinHelp(pT->m_hWnd, OLE2CT(pszHelpDir), HELP_CONTEXTPOPUP, NULL);
		return S_OK;
	}
	STDMETHOD(TranslateAccelerator)(MSG *pMsg)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IPropertyPageImpl::TranslateAccelerator\n"));
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
			(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return S_FALSE;

		return (IsDialogMessage(pT->m_hWnd, pMsg)) ? S_OK : S_FALSE;
	}

	IPropertyPageSite* m_pPageSite;
	IUnknown** m_ppUnk;
	ULONG m_nObjects;
	SIZE m_size;
	UINT m_dwTitleID;
	UINT m_dwHelpFileID;
	UINT m_dwDocStringID;
	DWORD m_dwHelpContext;
	BOOL m_bDirty;

//methods
public:

	BEGIN_MSG_MAP(IPropertyPageImpl<T>)
		MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange)
	END_MSG_MAP()

	LRESULT OnStyleChange(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
	{
		if (wParam == GWL_EXSTYLE)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
			lpss->styleNew |= WS_EX_CONTROLPARENT;
			return 0;
		}
		return 1;
	}

	LPOLESTR LoadStringHelper(UINT idRes)
	{
		USES_CONVERSION;

		TCHAR szTemp[_MAX_PATH];
		LPOLESTR sz = (LPOLESTR)CoTaskMemAlloc(_MAX_PATH*sizeof(OLECHAR));
		if (sz == NULL)
			return NULL;
		sz[0] = NULL;

		if (LoadString(_Module.GetResourceInstance(), idRes, szTemp, _MAX_PATH))
			ocscpy(sz, T2OLE(szTemp));
		else
		{
			ATLTRACE(_T("Error : Failed to load string from res\n"));
		}

		return sz;
	}

	void GetDialogSize(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		// If the dialog has a font we use it otherwise we default
		// to the system font.
		if (HasFont(pTemplate))
		{
			TCHAR szFace[LF_FACESIZE];
			WORD  wFontSize = 0;
			GetFont(pTemplate, szFace, &wFontSize);
			GetSizeInDialogUnits(pTemplate, pSize);
			ConvertDialogUnitsToPixels(szFace, wFontSize, pSize);
		}
		else
		{
			GetSizeInDialogUnits(pTemplate, pSize);
			LONG nDlgBaseUnits = GetDialogBaseUnits();
			pSize->cx = MulDiv(pSize->cx, LOWORD(nDlgBaseUnits), 4);
			pSize->cy = MulDiv(pSize->cy, HIWORD(nDlgBaseUnits), 8);
		}
	}

	static void ConvertDialogUnitsToPixels(LPCTSTR pszFontFace, WORD wFontSize, SIZE* pSizePixel)
	{
		// Attempt to create the font to be used in the dialog box
		UINT cxSysChar, cySysChar;
		LOGFONT lf;
		HDC hDC = ::GetDC(NULL);
		int cxDlg = pSizePixel->cx;
		int cyDlg = pSizePixel->cy;

		ZeroMemory(&lf, sizeof(LOGFONT));
		lf.lfHeight = -MulDiv(wFontSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
		lf.lfWeight = FW_NORMAL;
		lf.lfCharSet = DEFAULT_CHARSET;
		lstrcpy(lf.lfFaceName, pszFontFace);

		HFONT hNewFont = CreateFontIndirect(&lf);
		if (hNewFont != NULL)
		{
			TEXTMETRIC  tm;
			SIZE        size;
			HFONT       hFontOld = (HFONT)SelectObject(hDC, hNewFont);
			GetTextMetrics(hDC, &tm);
			cySysChar = tm.tmHeight + tm.tmExternalLeading;
			::GetTextExtentPoint(hDC,
				_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52,
				&size);
			cxSysChar = (size.cx + 26) / 52;
			SelectObject(hDC, hFontOld);
			DeleteObject(hNewFont);
		}
		else
		{
			// Could not create the font so just use the system's values
			cxSysChar = LOWORD(GetDialogBaseUnits());
			cySysChar = HIWORD(GetDialogBaseUnits());
		}
		::ReleaseDC(NULL, hDC);

		// Translate dialog units to pixels
		pSizePixel->cx = MulDiv(cxDlg, cxSysChar, 4);
		pSizePixel->cy = MulDiv(cyDlg, cySysChar, 8);
	}

	static BOOL IsDialogEx(const DLGTEMPLATE* pTemplate)
	{
		return ((_ATL_DLGTEMPLATEEX*)pTemplate)->signature == 0xFFFF;
	}

	static BOOL HasFont(const DLGTEMPLATE* pTemplate)
	{
		return (DS_SETFONT &
			(IsDialogEx(pTemplate) ?
				((_ATL_DLGTEMPLATEEX*)pTemplate)->style : pTemplate->style));
	}

	static BYTE* GetFontSizeField(const DLGTEMPLATE* pTemplate)
	{
		BOOL bDialogEx = IsDialogEx(pTemplate);
		WORD* pw;

		if (bDialogEx)
			pw = (WORD*)((_ATL_DLGTEMPLATEEX*)pTemplate + 1);
		else
			pw = (WORD*)(pTemplate + 1);

		if (*pw == (WORD)-1)        // Skip menu name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		if (*pw == (WORD)-1)        // Skip class name string or ordinal
			pw += 2; // WORDs
		else
			while(*pw++);

		while (*pw++);          // Skip caption string

		return (BYTE*)pw;
	}

	static BOOL GetFont(const DLGTEMPLATE* pTemplate, TCHAR* pszFace, WORD* pFontSize)
	{
		USES_CONVERSION;
		if (!HasFont(pTemplate))
			return FALSE;

		BYTE* pb = GetFontSizeField(pTemplate);
		*pFontSize = *(WORD*)pb;
		// Skip over font attributes to get to the font name
		pb += sizeof(WORD) * (IsDialogEx(pTemplate) ? 3 : 1);

		_tcscpy(pszFace, W2T((WCHAR*)pb));
		return TRUE;
	}

	static void GetSizeInDialogUnits(const DLGTEMPLATE* pTemplate, SIZE* pSize)
	{
		if (IsDialogEx(pTemplate))
		{
			pSize->cx = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cx;
			pSize->cy = ((_ATL_DLGTEMPLATEEX*)pTemplate)->cy;
		}
		else
		{
			pSize->cx = pTemplate->cx;
			pSize->cy = pTemplate->cy;
		}
	}
};


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage2Impl
template <class T>
class ATL_NO_VTABLE IPropertyPage2Impl : public IPropertyPageImpl<T>
{
public:

	STDMETHOD(EditProperty)(DISPID dispID)
	{
		ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n"));
	}
};



//////////////////////////////////////////////////////////////////////////////
// IPerPropertyBrowsingImpl
template <class T>
class ATL_NO_VTABLE IPerPropertyBrowsingImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPerPropertyBrowsingImpl)

	STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr)
	{
		ATLTRACE(_T("IPerPropertyBrowsingImpl::GetDisplayString\n"));
		T* pT = static_cast<T*>(this);
		CComVariant var;
		if (FAILED(CComDispatchDriver::GetProperty(pT, dispID, &var)))
		{
			*pBstr = NULL;
			return S_FALSE;
		}

		BSTR bstrTemp = var.bstrVal;
		if (var.vt != VT_BSTR)
		{
			CComVariant varDest;
			if (FAILED(::VariantChangeType(&varDest, &var, VARIANT_NOVALUEPROP, VT_BSTR)))
			{
				*pBstr = NULL;
				return S_FALSE;
			}
			bstrTemp = varDest.bstrVal;
		}
		*pBstr = SysAllocString(bstrTemp);
		return S_OK;
	}

	STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid)
	{
		ATLTRACE(_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		_ASSERTE(pMap != NULL);
		for(int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			if (pMap[i].szDesc == NULL)
				continue;
			if (pMap[i].dispid == dispID)
			{
				_ASSERTE(pMap[i].pclsidPropPage != NULL);
				*pClsid = *(pMap[i].pclsidPropPage);
				return S_OK;
			}
		}
		*pClsid = CLSID_NULL;
		return E_INVALIDARG;
	}
	STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut,CADWORD *pCaCookiesOut)
	{
		dispID;
		ATLTRACE(_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n"));
		if (pCaStringsOut == NULL || pCaCookiesOut == NULL)
			return E_POINTER;

		pCaStringsOut->cElems = 0;
		pCaStringsOut->pElems = NULL;
		pCaCookiesOut->cElems = 0;
		pCaCookiesOut->pElems = NULL;
		return S_OK;
	}
	STDMETHOD(GetPredefinedValue)(DISPID /*dispID*/, DWORD /*dwCookie*/, VARIANT* /*pVarOut*/)
	{
		ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IViewObjectExImpl
template <class T>
class ATL_NO_VTABLE IViewObjectExImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IViewObjectExImpl)

	// IViewObject
	//
	STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
					DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
					LPCRECTL prcBounds, LPCRECTL prcWBounds,
					BOOL (__stdcall * /*pfnContinue*/)(DWORD_PTR dwContinue),
					DWORD_PTR /*dwContinue*/)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::Draw\n"));
		return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
			prcBounds, prcWBounds);
	}

	STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, LOGPALETTE** /* ppColorSet */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));
	}
	STDMETHOD(Freeze)(DWORD /* dwDrawAspect */, LONG /* lindex */, void* /* pvAspect */,DWORD* /* pdwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));
	}
	STDMETHOD(Unfreeze)(DWORD /* dwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));
	}
	STDMETHOD(SetAdvise)(DWORD /* aspects */, DWORD /* advf */, IAdviseSink* pAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::SetAdvise\n"));
		pT->m_spAdviseSink = pAdvSink;
		return S_OK;
	}
	STDMETHOD(GetAdvise)(DWORD* /* pAspects */, DWORD* /* pAdvf */, IAdviseSink** ppAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetAdvise\n"));
		if (ppAdvSink != NULL)
		{
			*ppAdvSink = pT->m_spAdviseSink;
			if (pT->m_spAdviseSink)
				pT->m_spAdviseSink->AddRef();
		}
		return S_OK;
	}

	// IViewObject2
	//
	STDMETHOD(GetExtent)(DWORD /* dwDrawAspect */, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetExtent\n"));
		*lpsizel = pT->m_sizeExtent;
		return S_OK;
	}

	// IViewObjectEx
	//
	STDMETHOD(GetRect)(DWORD /* dwAspect */, LPRECTL /* pRect */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));
	}
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus =
//          VIEWSTATUS_DVASPECTOPAQUE | VIEWSTATUS_DVASPECTTRANSPARENT |
//          VIEWSTATUS_SOLIDBKGND |
			VIEWSTATUS_OPAQUE;

		return S_OK;
	}
	STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG /* lCloseHint */, DWORD *pHitResult)
	{
		ATLTRACE(_T("IViewObjectExImpl::QueryHitPoint\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE(_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG /* lCloseHint */, DWORD* pHitResult)
	{
		ATLTRACE(_T("IViewObjectExImpl::QueryHitRect\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			RECT rc;
			*pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE(_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, DVEXTENTINFO* pExtentInfo , LPSIZEL psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IViewObjectExImpl::GetNaturalExtent\n"));
		HRESULT hRes = E_FAIL;
		if (dwAspect == DVASPECT_CONTENT)
		{
			if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)
			{
				*psizel = pT->m_sizeNatural;
				hRes = S_OK;
			}
		}
		return hRes;
	}

public:
};

//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowlessImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleInPlaceObjectWindowlessImpl)

	// IOleWindow
	//

	// Change IOleInPlaceActiveObject::GetWindow as well
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceObject
	//
	STDMETHOD(InPlaceDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
		return pT->IOleInPlaceObject_InPlaceDeactivate();
	}
	STDMETHOD(UIDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
		return pT->IOleInPlaceObject_UIDeactivate();
	}
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
		return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);
	}
	STDMETHOD(ReactivateAndUndo)(void)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));
	}

	// IOleInPlaceObjectWindowless
	//
	STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
	{
		ATLTRACE(_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
		T* pT = static_cast<T*>(this);
		return (pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult)) ? S_OK : S_FALSE;
	}

	STDMETHOD(GetDropTarget)(IDropTarget** /* ppDropTarget */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceActiveObjectImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleInPlaceActiveObjectImpl)

	// IOleWindow
	//

	// Change IOleInPlaceObjectWindowless::GetWindow as well
	STDMETHOD(GetWindow)(HWND *phwnd)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceActiveObject
	//
	STDMETHOD(TranslateAccelerator)(LPMSG /* lpmsg */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
		return E_NOTIMPL;
	}
	STDMETHOD(OnFrameWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(OnDocWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(ResizeBorder)(LPCRECT /* prcBorder */, IOleInPlaceUIWindow* /* pUIWindow */, BOOL /* fFrameWindow */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
		return S_OK;
	}
	STDMETHOD(EnableModeless)(BOOL /* fEnable */)
	{
		ATLTRACE(_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPagesImpl
template <class T>
class ATL_NO_VTABLE ISpecifyPropertyPagesImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(ISpecifyPropertyPagesImpl)

	// ISpecifyPropertyPages
	//
	STDMETHOD(GetPages)(CAUUID* pPages)
	{
		ATLTRACE(_T("ISpecifyPropertyPagesImpl::GetPages\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		return pT->ISpecifyPropertyPages_GetPages(pPages, pMap);
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPointerInactiveImpl
template <class T>
class ATL_NO_VTABLE IPointerInactiveImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IPointerInactiveImpl)

	// IPointerInactive
	//
	STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy"));
	}
	STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove"));
	}
	STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IRunnableObjectImpl
template <class T>
class ATL_NO_VTABLE IRunnableObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IRunnableObjectImpl)

	// IRunnableObject
	//
	STDMETHOD(GetRunningClass)(LPCLSID lpClsid)
	{
		ATLTRACE(_T("IRunnableObjectImpl::GetRunningClass\n"));
		T* pT = static_cast<T*>(this);
		*lpClsid = GUID_NULL;
		return E_UNEXPECTED;
	}
	STDMETHOD(Run)(LPBINDCTX)
	{
		ATLTRACE(_T("IRunnableObjectImpl::Run\n"));
		return S_OK;
	}
	virtual BOOL STDMETHODCALLTYPE IsRunning()
	{
		ATLTRACE(_T("IRunnableObjectImpl::IsRunning\n"));
		return TRUE;
	}
	STDMETHOD(LockRunning)(BOOL /*fLock*/, BOOL /*fLastUnlockCloses*/)
	{
		ATLTRACE(_T("IRunnableObjectImpl::LockRunning\n"));
		return S_OK;
	}
	STDMETHOD(SetContainedObject)(BOOL /*fContained*/)
	{
		ATLTRACE(_T("IRunnableObjectImpl::SetContainedObject\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IDataObjectImpl
template <class T>
class ATL_NO_VTABLE IDataObjectImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IDataObjectImpl)

	// IDataObject
	//
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACE(_T("IDataObjectImpl::GetData\n"));
		T* pT = (T*) this;
		return pT->IDataObject_GetData(pformatetcIn, pmedium);
	}
	STDMETHOD(GetDataHere)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));
	}
	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACE(_T("IDataObjectImpl::DAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

		if (hr == S_OK)
			hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

		return hr;
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACE(_T("IDataObjectImpl::DUnadvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = OLE_E_NOCONNECTION;
		else
			hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);
		return hr;
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACE(_T("IDataObjectImpl::EnumDAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = E_FAIL;
		if (pT->m_spDataAdviseHolder != NULL)
			hr = pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPropertyNotifySinkCP
template <class T, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IPropertyNotifySinkCP :
	public IConnectionPointImpl<T, &IID_IPropertyNotifySink, CDV>
{
public:
	typedef CFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//

template <class T>
class ATL_NO_VTABLE IObjectSafetyImpl
{
public:
	IObjectSafetyImpl()
	{
		m_dwSafety = 0;
	}

	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IObjectSafetyImpl)

	// IObjectSafety
	//
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
		HRESULT hr = S_OK;
		if (riid == IID_IDispatch)
		{
			*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
			*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		}
		else
		{
			*pdwSupportedOptions = 0;
			*pdwEnabledOptions = 0;
			hr = E_NOINTERFACE;
		}
		return hr;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
		// If we're being asked to set our safe for scripting option then oblige
		if (riid == IID_IDispatch)
		{
			// Store our current safety level to return in GetInterfaceSafetyOptions
			m_dwSafety = dwEnabledOptions & dwOptionSetMask;
			return S_OK;
		}
		return E_NOINTERFACE;
	}

	DWORD m_dwSafety;
};


template <class T>
class ATL_NO_VTABLE IOleLinkImpl
{
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IOleLinkImpl)

	STDMETHOD(SetUpdateOptions)(DWORD /* dwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions"));
	}

	STDMETHOD(GetUpdateOptions)(DWORD* /* pdwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions"));
	}

	STDMETHOD(SetSourceMoniker)(IMoniker* /* pmk */, REFCLSID /* rclsid */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker"));
	}

	STDMETHOD(GetSourceMoniker)(IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker"));
	};

	STDMETHOD(SetSourceDisplayName)(LPCOLESTR /* pszStatusText */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName"));
	}

	STDMETHOD(GetSourceDisplayName)(LPOLESTR *ppszDisplayName)
	{
		ATLTRACE(_T("IOleLink::GetSourceDisplayName\n"));
		*ppszDisplayName = NULL;
		return E_FAIL;
	}

	STDMETHOD(BindToSource)(DWORD /* bindflags */, IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n"));
	};

	STDMETHOD(BindIfRunning)()
	{
		ATLTRACE(_T("IOleLinkImpl::BindIfRunning\n"));
		return S_OK;
	};

	STDMETHOD(GetBoundSource)(IUnknown** /* ppunk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource"));
	};

	STDMETHOD(UnbindSource)()
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource"));
	};

	STDMETHOD(Update)(IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::Update"));
	};
};


template <class T>
class ATL_NO_VTABLE IBindStatusCallbackImpl
{
public:
	// IUnknown
	//
	STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject) = 0;
	_ATL_DEBUG_ADDREF_RELEASE_IMPL(IBindStatusCallbackImpl)

	// IBindStatusCallback
	//
	STDMETHOD(OnStartBinding)(DWORD /* dwReserved */, IBinding *pBinding)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnStartBinding\n"));
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG* /* pnPriority */)
	{
		ATLTRACENOTIMPL(_T("IBindStatusCallbackImpl::GetPriority"));
	}

	STDMETHOD(OnLowResource)(DWORD /* reserved */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnLowResource\n"));
		return S_OK;
	}

	STDMETHOD(OnProgress)(ULONG /* ulProgress */, ULONG /* ulProgressMax */, ULONG /* ulStatusCode */, LPCWSTR /* szStatusText */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnProgress\n"));
		return S_OK;
	}

	STDMETHOD(OnStopBinding)(HRESULT /* hresult */, LPCWSTR /* szError */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnStopBinding\n"));
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD* /* pgrfBINDF */, BINDINFO* /* pBindInfo */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::GetBindInfo\n"));
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnDataAvailable\n"));
		return S_OK;
	}

	STDMETHOD(OnObjectAvailable)(REFIID /* riid */, IUnknown* /* punk */)
	{
		ATLTRACE(_T("IBindStatusCallbackImpl::OnObjectAvailable\n"));
		return S_OK;
	}
};


template <class T>
class ATL_NO_VTABLE CBindStatusCallback :
	public CComObjectRootEx<T::_ThreadModel::ThreadModelNoCS>,
	public IBindStatusCallbackImpl<T>
{
	typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

public:

BEGIN_COM_MAP(CBindStatusCallback<T>)
	COM_INTERFACE_ENTRY_IID(IID_IBindStatusCallback, IBindStatusCallbackImpl<T>)
END_COM_MAP()


	CBindStatusCallback()
	{
		m_pT = NULL;
		m_pFunc = NULL;
	}
	~CBindStatusCallback()
	{
		ATLTRACE(_T("~CBindStatusCallback\n"));
	}

	STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
	{
		ATLTRACE(_T("CBindStatusCallback::OnStartBinding\n"));
		m_spBinding = pBinding;
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG *pnPriority)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::GetPriority"));
	}

	STDMETHOD(OnLowResource)(DWORD reserved)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnLowResource"));
	}

	STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnProgress"));
	}

	STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
	{
		ATLTRACE(_T("CBindStatusCallback::OnStopBinding\n"));
		m_spBinding.Release();
		m_spBindCtx.Release();
		m_spMoniker.Release();
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
	{
		ATLTRACE(_T("CBindStatusCallback::GetBindInfo\n"));

		if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
			return E_INVALIDARG;

		*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
			BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;

		ULONG cbSize = pbindInfo->cbSize;		// remember incoming cbSize
		memset(pbindInfo, 0, cbSize);			// zero out structure
		pbindInfo->cbSize = cbSize;				// restore cbSize
		pbindInfo->dwBindVerb = BINDVERB_GET;	// set verb
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE(_T("CBindStatusCallback::OnDataAvailable\n"));
		HRESULT hr = S_OK;

		// Get the Stream passed
		if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
		{
			if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
				m_spStream = pstgmed->pstm;
		}

		DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
		DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		// If there is some data to be read then go ahead and read them
		if (m_spStream)
		{
			if (dwRead > 0)
			{
				BYTE* pBytes = NULL;
				ATLTRY(pBytes = new BYTE[dwRead + 1]);
				if (pBytes == NULL)
					return S_FALSE;
				hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
				if (SUCCEEDED(hr))
				{
					pBytes[dwActuallyRead] = 0;
					if (dwActuallyRead>0)
					{
						(m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
						m_dwTotalRead += dwActuallyRead;
					}
				}
				delete[] pBytes;
			}
		}

		if (BSCF_LASTDATANOTIFICATION & grfBSCF)
			m_spStream.Release();
		return hr;
	}

	STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
	{
		ATLTRACENOTIMPL(_T("CBindStatusCallback::OnObjectAvailable"));
	}

	HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
	{
		m_dwTotalRead = 0;
		m_dwAvailableToRead = 0;
		HRESULT hr = S_OK;
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
		CComPtr<IBindHost>	spBindHost;
		CComPtr<IStream>	spStream;
		if (spServiceProvider)
			spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

		if (spBindHost == NULL)
		{
			if (bRelative)
				return E_NOINTERFACE;  // relative asked for, but no IBindHost
			hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			if (SUCCEEDED(hr))
				hr = CreateBindCtx(0, &m_spBindCtx);

			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);
			else
				m_spMoniker.Release();

			if (SUCCEEDED(hr))
				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
		}
		else
		{
			hr = CreateBindCtx(0, &m_spBindCtx);
			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), 0, 0L);

			if (SUCCEEDED(hr))
			{
				if (bRelative)
					hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
				else
					hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			}

			if (SUCCEEDED(hr))
			{
				hr = spBindHost->MonikerBindToStorage(m_spMoniker, NULL, reinterpret_cast<IBindStatusCallback*>(static_cast<IBindStatusCallbackImpl<T>*>(this)), IID_IStream, (void**)&spStream);
				ATLTRACE(_T("Bound"));
			}
		}
		return hr;
	}

	HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		m_pT = pT;
		m_pFunc = pFunc;
		return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
	}

	static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		CComObject<CBindStatusCallback<T> > *pbsc;
		HRESULT hRes = CComObject<CBindStatusCallback<T> >::CreateInstance(&pbsc);
		if (FAILED(hRes))
			return hRes;
		return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative);
	}

	CComPtr<IMoniker> m_spMoniker;
	CComPtr<IBindCtx> m_spBindCtx;
	CComPtr<IBinding> m_spBinding;
	CComPtr<IStream> m_spStream;
	T* m_pT;
	ATL_PDATAAVAILABLE m_pFunc;
	DWORD m_dwTotalRead;
	DWORD m_dwAvailableToRead;
};

#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(type pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname; \
		return S_OK; \
	}

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname ? VARIANT_TRUE : VARIANT_FALSE; \
		return S_OK; \
	}

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \
	{ \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		*(&(pT->m_##pname)) = SysAllocString(pname); \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \
	{ \
		T* pT = (T*) this; \
		*p##pname = SysAllocString(pT->m_##pname); \
		return S_OK; \
	}

template < class T, class InterfaceName, const IID* piid, const GUID* plibid>
class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl< InterfaceName, piid, plibid >
{
public:
	// Font
	HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFont)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = 0;
		if (pFont)
		{
			CComQIPtr<IFont, &IID_IFont> p(pFont);
			if (p)
			{
				CComPtr<IFont> pFont;
				p->Clone(&pFont);
				if (pFont)
					pFont->QueryInterface(IID_IFontDisp, (void**) &pT->m_pFont);
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = pFont;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont)
	{
		T* pT = (T*) this;
		*ppFont = pT->m_pFont;
		if (*ppFont != NULL)
			(*ppFont)->AddRef();
		return S_OK;
	}
	// Picture
	HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pPicture);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture)
	{
		T* pT = (T*) this;
		*ppPicture = pT->m_pPicture;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	// MouseIcon
	HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pMouseIcon);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture)
	{
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture)
	{
		T* pT = (T*) this;
		*ppPicture = pT->m_pMouseIcon;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
	IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
	IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
	IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
	IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
        IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
	IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
	IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
	HRESULT STDMETHODCALLTYPE put_Window(LONG /*hWnd*/)
	{
		return E_FAIL;
	}
	HRESULT STDMETHODCALLTYPE get_Window(LONG* phWnd)
	{
		T* pT = (T*) this;
		*phWnd = (LONG)(LONG_PTR)pT->m_hWnd;
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(long, BackStyle, nBackStyle, DISPID_BACKSTYLE)
	IMPLEMENT_STOCKPROP(long, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
	IMPLEMENT_STOCKPROP(long, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
	IMPLEMENT_STOCKPROP(long, DrawMode, nDrawMode, DISPID_DRAWMODE)
	IMPLEMENT_STOCKPROP(long, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
	IMPLEMENT_STOCKPROP(long, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
	IMPLEMENT_STOCKPROP(long, FillStyle, nFillStyle, DISPID_FILLSTYLE)
	IMPLEMENT_STOCKPROP(long, Appearance, nAppearance, DISPID_APPEARANCE)
	IMPLEMENT_STOCKPROP(long, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
	IMPLEMENT_STOCKPROP(long, ReadyState, nReadyState, DISPID_READYSTATE)
};

#ifndef ATL_NO_NAMESPACE
}; //namespace ATL
#endif

#endif // __ATLCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\denames.h ===
// DENames.h : Declaration of the CDEGetBlockFmtNamesParam
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __DEGETBLOCKFMTNAMESPARAM_H_
#define __DEGETBLOCKFMTNAMESPARAM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDEGetBlockFmtNamesParam
class ATL_NO_VTABLE CDEGetBlockFmtNamesParam : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDEGetBlockFmtNamesParam, &CLSID_DEGetBlockFmtNamesParam>,
	public IDispatchImpl<IDEGetBlockFmtNamesParam, &IID_IDEGetBlockFmtNamesParam, &LIBID_DHTMLEDLib>
{
public:
	CDEGetBlockFmtNamesParam();
	~CDEGetBlockFmtNamesParam();

private:
	SAFEARRAY* m_pNamesArray;
public:

DECLARE_REGISTRY_RESOURCEID(IDR_DEGETBLOCKFMTNAMESPARAM)

BEGIN_COM_MAP(CDEGetBlockFmtNamesParam)
	COM_INTERFACE_ENTRY(IDEGetBlockFmtNamesParam)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDEGetBlockFmtNamesParam
public:
	STDMETHOD(get_Names)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_Names)(/*[in]*/ VARIANT* newVal);
};

#endif //__DEGETBLOCKFMTNAMESPARAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\denames.cpp ===
// DENames.cpp : Implementation of CDEGetBlockFmtNamesParam
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DENames.h"

/////////////////////////////////////////////////////////////////////////////
// CDEGetBlockFmtNamesParam

CDEGetBlockFmtNamesParam::CDEGetBlockFmtNamesParam()
{
	m_pNamesArray = NULL;

	m_pNamesArray = SafeArrayCreateVector(VT_VARIANT, 0, 0);	
	_ASSERTE(m_pNamesArray);

}


CDEGetBlockFmtNamesParam::~CDEGetBlockFmtNamesParam()
{
	if (m_pNamesArray)
		SafeArrayDestroy(m_pNamesArray);
}


//	This will always retreive a SafeArray of Variants containing BSTRs.
//
STDMETHODIMP CDEGetBlockFmtNamesParam::get_Names(VARIANT * pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);

	if (NULL == pVal)
		return E_INVALIDARG;

	VariantClear(pVal);

	V_VT(pVal) = VT_ARRAY|VT_VARIANT;
	hr = SafeArrayCopy(m_pNamesArray, &(V_ARRAY(pVal)));
	
	return hr;
}

//	The SafeArray gotten received from Trident is (currently) an array for BSTRs.
//	This works fine with VB, but not VBS or JScript.
//	We'll do the work at this end to copy the supplied array over to our private
//	storage as a SafeArray of Variants containing BSTRs.
//
STDMETHODIMP CDEGetBlockFmtNamesParam::put_Names(VARIANT* newVal)
{
	HRESULT hr = S_OK;
    LONG lLBound, lUBound, lIndex;

	_ASSERTE ( m_pNamesArray );
	_ASSERTE(VT_ARRAY == V_VT(newVal));
	_ASSERTE(NULL != V_ARRAY(newVal));

	if (VT_ARRAY != V_VT(newVal))
		return E_INVALIDARG;

	if (NULL == V_ARRAY(newVal))
		return E_INVALIDARG;

	SafeArrayGetLBound(V_ARRAY(newVal), 1, &lLBound);
	SafeArrayGetUBound(V_ARRAY(newVal), 1, &lUBound);

	SAFEARRAYBOUND rgsaBound[1];
	rgsaBound[0].lLbound	= 0;
	rgsaBound[0].cElements	= ( lUBound - lLBound ) + 1;
	hr = SafeArrayRedim ( m_pNamesArray, rgsaBound );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( FAILED ( hr ) )
	{
		SafeArrayDestroy ( V_ARRAY(newVal) );
		return hr;
	}

	// Copy all BSTRs or Variants from the source array to Variants in the m_pNamesArray
	VARIANT	var;
	BSTR	bstr = NULL;

	VariantInit ( &var );

	for (lIndex=lLBound; lIndex<=lUBound; lIndex++)
	{
		if ( FADF_BSTR & V_ARRAY(newVal)->fFeatures )
		{
			hr = SafeArrayGetElement(V_ARRAY(newVal), &lIndex, &bstr);
			_ASSERTE ( SUCCEEDED ( hr ) );
			if ( FAILED ( hr ) )
				break;

			// BSTR was copied, we can stick it in a variant, no release or duplicating needed.
			var.vt = VT_BSTR;
			var.bstrVal = bstr;
		}
		else if ( FADF_VARIANT & V_ARRAY(newVal)->fFeatures )
		{
			hr = SafeArrayGetElement(V_ARRAY(newVal), &lIndex, &var);
			_ASSERTE ( SUCCEEDED ( hr ) );
			if ( FAILED ( hr ) )
				break;

			hr = VariantChangeType ( &var, &var, 0, VT_BSTR );
			_ASSERTE ( SUCCEEDED ( hr ) );
			if ( FAILED ( hr ) )
				break;
		}
		else
		{
			_ASSERTE ( ( FADF_BSTR | FADF_VARIANT ) & V_ARRAY(newVal)->fFeatures );
			hr = E_UNEXPECTED;
			break;
		}

		hr = SafeArrayPutElement ( m_pNamesArray, &lIndex, &var );
		_ASSERTE ( SUCCEEDED ( hr ) );
		VariantClear ( &var );
	}

	VariantClear ( &var );	// In case a break occurred.
	SafeArrayDestroy ( V_ARRAY(newVal) );

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\cpdhtmled.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
// CProxy_DHTMLEditEvents

#include "triedtctlid.h"
template <class T> class CProxy_DHTMLSafeEvents : public IConnectionPointImpl<T, &DIID__DHTMLSafeEvents, CComDynamicUnkArray>
{
public:
//methods:
//_DHTMLEditEvents : IDispatch
public:

	void Fire_Generic_Event ( DISPID dispid )
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}
	VARIANT_BOOL Fire_Generic_Boolean_Event ( DISPID dispid )
	{
		VARIANT_BOOL	vbCancel = FALSE;
		CComVariant		varCancel ( VARIANT_FALSE );
		T*				pT = (T*)this;

		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			varCancel.ChangeType ( VT_BOOL );
			if ( varCancel.boolVal )
			{
				break;	// give up once we've received a cancel.
			}
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varCancel, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		return varCancel.boolVal;
	}
	void Fire_DocumentComplete()
	{
		Fire_Generic_Event ( DISPID_DOCUMENTCOMPLETE );
	}
	void Fire_DisplayChanged()
	{
		Fire_Generic_Event ( DISPID_DISPLAYCHANGED );
	}
	void Fire_ShowContextMenu( long xPos, long yPos)
	{
		VARIANTARG* pvars = new VARIANTARG[2];
		for (int i = 0; i < 2; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= yPos;
				pvars[1].vt = VT_I4;
				pvars[1].lVal= xPos;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(DISPID_SHOWCONTEXTMENU, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_ContextMenuAction(
		long itemIndex)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= itemIndex;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(DISPID_CONTEXTMENUACTION, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_onmousedown ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEDOWN );
	}
	void Fire_onmousemove ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEMOVE );
	}
	void Fire_onmouseup ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEUP );
	}
	void Fire_onmouseout ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEOUT );
	}
	void Fire_onmouseover ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEOVER );
	}
	void Fire_onclick ()
	{
		Fire_Generic_Event ( DISPID_ONCLICK );
	}
	void Fire_ondblclick ()
	{
		Fire_Generic_Event ( DISPID_ONDBLCLICK );
	}
	void Fire_onkeydown ()
	{
		Fire_Generic_Event ( DISPID_ONKEYDOWN );
	}
	void Fire_onkeypress ()
	{
		Fire_Generic_Event ( DISPID_ONKEYPRESS );
	}
	void Fire_onkeyup ()
	{
		Fire_Generic_Event ( DISPID_ONKEYUP );
	}
	void Fire_onblur ()
	{
		Fire_Generic_Event ( DISPID_ONBLUR );
	}
	void Fire_onreadystatechange ()
	{
		Fire_Generic_Event ( DISPID_ONREADYSTATECHANGE );
	}
};


template <class T>
class CProxy_DHTMLEditEvents : public IConnectionPointImpl<T, &DIID__DHTMLEditEvents, CComDynamicUnkArray>
{
public:
//methods:
//_DHTMLEditEvents : IDispatch
public:

	void Fire_Generic_Event ( DISPID dispid )
	{
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
	}
	VARIANT_BOOL Fire_Generic_Boolean_Event ( DISPID dispid )
	{
		VARIANT_BOOL	vbCancel = FALSE;
		CComVariant		varCancel = VARIANT_FALSE;
		T*				pT = (T*)this;

		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			varCancel.ChangeType ( VT_BOOL );
			if ( VARIANT_TRUE == varCancel.boolVal )
			{
				break;	// give up once we've received a cancel.
			}
			if (*pp != NULL)
			{
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varCancel, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		return varCancel.boolVal;
	}
	void Fire_DocumentComplete()
	{
		Fire_Generic_Event ( DISPID_DOCUMENTCOMPLETE );
	}
	void Fire_DisplayChanged()
	{
		Fire_Generic_Event ( DISPID_DISPLAYCHANGED );
	}
	void Fire_ShowContextMenu( long xPos, long yPos)
	{
		VARIANTARG* pvars = new VARIANTARG[2];
		for (int i = 0; i < 2; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= yPos;
				pvars[1].vt = VT_I4;
				pvars[1].lVal= xPos;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(DISPID_SHOWCONTEXTMENU, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_ContextMenuAction(
		long itemIndex)
	{
		VARIANTARG* pvars = new VARIANTARG[1];
		for (int i = 0; i < 1; i++)
			VariantInit(&pvars[i]);
		T* pT = (T*)this;
		pT->Lock();
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				pvars[0].vt = VT_I4;
				pvars[0].lVal= itemIndex;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
				pDispatch->Invoke(DISPID_CONTEXTMENUACTION, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
			pp++;
		}
		pT->Unlock();
		delete[] pvars;
	}
	void Fire_onmousedown ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEDOWN );
	}
	void Fire_onmousemove ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEMOVE );
	}
	void Fire_onmouseup ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEUP );
	}
	void Fire_onmouseout ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEOUT );
	}
	void Fire_onmouseover ()
	{
		Fire_Generic_Event ( DISPID_ONMOUSEOVER );
	}
	void Fire_onclick ()
	{
		Fire_Generic_Event ( DISPID_ONCLICK );
	}
	void Fire_ondblclick ()
	{
		Fire_Generic_Event ( DISPID_ONDBLCLICK );
	}
	void Fire_onkeydown ()
	{
		Fire_Generic_Event ( DISPID_ONKEYDOWN );
	}
	void Fire_onkeypress ()
	{
		Fire_Generic_Event ( DISPID_ONKEYPRESS );
	}
	void Fire_onkeyup ()
	{
		Fire_Generic_Event ( DISPID_ONKEYUP );
	}
	void Fire_onblur ()
	{
		Fire_Generic_Event ( DISPID_ONBLUR );
	}
	void Fire_onreadystatechange ()
	{
		Fire_Generic_Event ( DISPID_ONREADYSTATECHANGE );
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\dhshwui.cpp ===
/*
 * IDOCHOSTSHOWUI.CPP
 * IDocHostShowUI for Document Objects CSite class
 *
 * Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "site.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/


/*
 * CImpIDocHostShowUI::CImpIDocHostShowUI
 * CImpIDocHostShowUI::~CImpIDocHostShowUI
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
CImpIDocHostShowUI::CImpIDocHostShowUI( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIDocHostShowUI::~CImpIDocHostShowUI( void )
{
}



/*
 * CImpIDocHostShowUI::QueryInterface
 * CImpIDocHostShowUI::AddRef
 * CImpIDocHostShowUI::Release
 *
 * Purpose:
 *  IUnknown members for CImpIDocHostShowUI object.
 */
STDMETHODIMP CImpIDocHostShowUI::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIDocHostShowUI::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIDocHostShowUI::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}


/*
 * CImpIDocHostShowUI::ShowMessage
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 */
STDMETHODIMP CImpIDocHostShowUI::ShowMessage(
            HWND /*hwnd*/,
            LPOLESTR /*lpstrText*/,
            LPOLESTR /*lpstrCaption*/, 
            DWORD /*dwType*/,
            LPOLESTR /*lpstrHelpFile*/,
            DWORD /*dwHelpContext*/,
            LRESULT* /*plResult*/)
{
	return S_FALSE;
}

/*
 * CImpIDocHostShowUI::ShowHelp
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 */
STDMETHODIMP CImpIDocHostShowUI::ShowHelp(
            HWND /*hwnd*/,
            LPOLESTR /*pszHelpFile*/,
            UINT /*uCommand*/,
            DWORD /*dwData*/,
            POINT /*ptMouse*/,
            IDispatch* /*pDispatchObjectHit*/)
{
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\dhtmledit.cpp ===
// DHTMLEdit.cpp : Implementation of CDHTMLEdit and CDHTMLSafe
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "proxyframe.h"
#include "site.h"

/////////////////////////////////////////////////////////////////////////////
// CDHTMLSafe


CDHTMLSafe::CDHTMLSafe()
{
	m_bWindowOnly				= TRUE;				// A window is needed when we activate Trident.
	m_pFrame					= NULL;
	m_piControlSite				= NULL;
	m_fJustCreated				= TRUE;
	m_piOuterEditCtl			= (IDHTMLEdit*)-1;	// Crash if we use this without properly initializing it.
	m_bfOuterEditUnknownTested	= NULL;
}

CDHTMLSafe::~CDHTMLSafe()
{

}


HRESULT CDHTMLSafe::FinalConstruct()
{
	HRESULT hr E_FAIL;

	m_pFrame = new CProxyFrame(this);

	_ASSERTE(m_pFrame);

	if (NULL == m_pFrame)
		return E_OUTOFMEMORY;

	// not aggregating TriEdit -- don't get
	// reference to its pUnk;

	hr = m_pFrame->Init(NULL, NULL);

	_ASSERTE(SUCCEEDED(hr));

	if (FAILED(hr))
	{
		m_pFrame->Release ();
		m_pFrame = NULL;
	}

	return hr;
}


void CDHTMLSafe::FinalRelease()
{
	if ( NULL != m_piControlSite )
	{
		m_piControlSite->Release ();
		m_piControlSite = NULL;
	}

	if (NULL != m_pFrame)
	{
		if (m_pFrame->IsCreated())
		{
			_ASSERTE(FALSE == m_pFrame->IsActivated());

			m_pFrame->Close();
		}

		m_pFrame->Release ();
		m_pFrame = NULL;
	}
}


HRESULT CDHTMLSafe::OnDraw(ATL_DRAWINFO& di)
{
	HRESULT hr = S_OK;
	
	_ASSERTE(m_pFrame);

	if (NULL == m_pFrame)
		return E_UNEXPECTED;

	if (IsUserMode() == FALSE)
	{
		HBRUSH hgreyBrush = NULL;

		hgreyBrush = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);
		FillRect(di.hdcDraw, &rc, hgreyBrush);
        return S_OK;

	}
	else if (IsUserMode() && m_pFrame->IsCreated() == TRUE && m_pFrame->IsActivated() == FALSE)
	{
		_ASSERTE(m_bInPlaceActive == TRUE);

		hr = m_pFrame->LoadInitialDoc();
	}

	return hr;
}


LRESULT
CDHTMLSafe::OnSize(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& lResult)
{
    m_pFrame->UpdateObjectRects();

	lResult = TRUE;
	return 0;
}


STDMETHODIMP CDHTMLSafe::TranslateAccelerator(LPMSG lpmsg)
{
	HRESULT hr = S_OK;

	hr = m_pFrame->HrTranslateAccelerator(lpmsg);
	return hr;
}	

STDMETHODIMP CDHTMLSafe::OnMnemonic(LPMSG /*pMsg*/)
{
	return S_FALSE;
}


STDMETHODIMP CDHTMLSafe::SetClientSite(IOleClientSite *pClientSite)
{
	HRESULT hr = S_OK;

	if ( NULL == pClientSite )
		{
		_ASSERTE ( m_pFrame );
		if ( NULL != m_pFrame )
		{
			_ASSERTE(m_pFrame->IsCreated());
			hr = m_pFrame->Close();
			_ASSERTE(SUCCEEDED(hr));
		}
	}
	return IOleObject_SetClientSite ( pClientSite );
}


LRESULT
CDHTMLSafe::OnDestroy(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*lResult*/)
{
	HRESULT hr = S_OK;

	// This would, in turn, destroy the hosted Trident's window.
	if ( NULL != m_pFrame )
	{
		_ASSERTE(m_pFrame->IsCreated());
		_ASSERTE ( m_hWndCD );
		m_pFrame->SetParent ( NULL );
	}

	return hr;
}


LRESULT
CDHTMLSafe::OnCreate(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*lResult*/)
{
	if ( NULL != m_pFrame )
	{
		_ASSERTE(m_pFrame->IsCreated());
		_ASSERTE ( m_hWndCD );
		m_pFrame->SetParent ( m_hWndCD );
	}

	return 0;
}


LRESULT
CDHTMLSafe::OnShow(UINT /*nMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*lResult*/)
{
	if ( NULL != m_pFrame )
	{
		_ASSERTE(m_pFrame->IsCreated());
		m_pFrame->Show ( wParam );
	}
	return 0;
}


// Do our best to set the focus on the ControlSite.
// m_piControlSite is obtained on demand, and released in FinalRelease.
//
void
CDHTMLSafe::FocusSite ( BOOL bfGetFocus )
{
	if  ( NULL == m_piControlSite )
	{
		_ASSERTE ( m_spClientSite );
		if ( m_spClientSite )
		{
			m_spClientSite->QueryInterface ( IID_IOleControlSite, (void**)&m_piControlSite );
		}
	}

	if ( m_piControlSite )
	{
		m_piControlSite->OnFocus ( bfGetFocus );
	}
}


LRESULT
CDHTMLSafe::OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult)
{
	lResult = FALSE;	// Pass it on to the default event handler if not handled by Frame.
	_ASSERTE ( m_pFrame );
	if ( NULL != m_pFrame )
	{
		// If its the Trident instance loosing the focus, let's not set it right back again!
		// Also, if it has not yet been UIActivated, don't risk inplace deactivationg with this:
		if ( m_pFrame->GetDocWindow() != (HWND)wParam )
		{
			FocusSite ( TRUE );
			return m_pFrame->OnSetFocus ( nMsg, wParam, lParam, lResult );
		}
	}
	return 0;
}


//	This message is posted in OnReadyStateChanged.
//	This postpones firing DocumentComplete until MSHTML is actually complete.
//
LRESULT
CDHTMLSafe::OnDocumentComplete(UINT /*nMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& lResult)
{
	_ASSERTE ( DOCUMENT_COMPETE_SIGNATURE == wParam );
	if ( DOCUMENT_COMPETE_SIGNATURE == wParam )
	{
		lResult = TRUE;
		m_pFrame->ClearLoadingFlag ();
		Fire_DocumentComplete();
	}
	return 0;
}


STDMETHODIMP CDHTMLSafe::OnAmbientPropertyChange(DISPID /*dispID*/)
{
	HRESULT hr = S_OK;

	// There may be some VB ambients we may want to handle here
	// in the future for VB debugging.
	return hr;
}


//	IE5 security settings for Paste, and possibly for Copy and Cut, require that we call
//	ITHMLDocument2->execCommand for testing.
//
HRESULT CDHTMLSafe::SpecialEdit ( DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt )
{
	HRESULT					hr			= S_OK;
	CComPtr<IHTMLDocument2>	spDOM		= NULL;
	VARIANT_BOOL			vbResult	= VARIANT_FALSE;
	CComBSTR				bstrCommand;
	CComVariant				varValue;

	// Regression: The point of SpecialEdit was to call execCommand rather than Exec for the
	// editing commands and allow Trident to do the corss-zone security checks, but this has
	// broken.  (Bug 547802.)  In response, we now check the cross-zone security of the current
	// selection ourselves.  We stick with execCommand to minimize impact on behavior.

	hr = m_pFrame->CheckCrossZoneSecurityOfSelection ();
	if ( SUCCEEDED ( hr ) )
	{
		hr = get_DOM ( &spDOM );
		if ( SUCCEEDED ( hr ) )
		{
			switch ( cmdID )
			{
				case DECMD_CUT:
					bstrCommand = L"Cut";
					break;
				case DECMD_COPY:
					bstrCommand = L"Copy";
					break;
				case DECMD_PASTE:
					bstrCommand = L"Paste";
					break;
				default:
					return E_UNEXPECTED;
			}
			hr = spDOM->execCommand ( bstrCommand, cmdexecopt == OLECMDEXECOPT_PROMPTUSER, varValue, &vbResult );
		}
	}
	return hr;
}


//	To be Safe for Scripting, restrict the range of cmdIDs to a known set.
//	Handle edit commands specially to utilize IE5's security settings.
//
STDMETHODIMP CDHTMLSafe::ExecCommand(DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pInVar, LPVARIANT pOutVar)
{
	HRESULT			hr			= S_OK;
	LPVARIANT		_pVarIn		= NULL;
	LPVARIANT		_pVarOut	= NULL;

	// It is valid for pVar to be VT_EMPTY (on a DECMD_GETXXX op) but not VT_ERROR

	if (pInVar && (V_VT(pInVar) != VT_ERROR))
		_pVarIn = pInVar;

	if (pOutVar && (V_VT(pOutVar) != VT_ERROR))
		_pVarOut = pOutVar;

	if ( ( cmdexecopt < OLECMDEXECOPT_DODEFAULT ) ||
		 ( cmdexecopt >  OLECMDEXECOPT_DONTPROMPTUSER ) )
	{
		return E_INVALIDARG;
	}

	//	Special case for editing commands in Safe for Scripting version:
	if ( ( DECMD_CUT == cmdID ) || ( DECMD_COPY == cmdID ) || ( DECMD_PASTE == cmdID ) )
	{
		return SpecialEdit ( cmdID, cmdexecopt );
	}

	hr = m_pFrame->HrMapExecCommand(cmdID, cmdexecopt, _pVarIn, _pVarOut);

	return hr;
}


STDMETHODIMP CDHTMLSafe::QueryStatus(DHTMLEDITCMDID cmdID, DHTMLEDITCMDF* retval)
{
	HRESULT hr = S_OK;

	hr = m_pFrame->HrMapQueryStatus(cmdID, retval);

	return hr;
}


// Get Document Object Model
//
STDMETHODIMP CDHTMLSafe::get_DOM(IHTMLDocument2 ** pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);

	if (NULL == pVal)
		return E_INVALIDARG;

	*pVal = NULL;
	hr = m_pFrame->HrGetDoc(pVal);

	return hr;
}


STDMETHODIMP CDHTMLSafe::get_DocumentHTML(BSTR * pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetDocumentHTML(pVal);
	return hr;
}


STDMETHODIMP CDHTMLSafe::put_DocumentHTML(BSTR newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetDocumentHTML(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_DOCUMENTHTML );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_ActivateApplets(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPropActivateApplets(bVal);

#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ActivateApplets(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPropActivateApplets(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_ACTIVATEAPPLETS );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_ActivateActiveXControls(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPropActivateControls(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ActivateActiveXControls(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPropActivateControls(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_ACTIVATEACTIVEXCONTROLS );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_ActivateDTCs(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPropActivateDTCs(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ActivateDTCs(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPropActivateDTCs(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_ACTIVATEDTCS );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_ShowDetails(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	 hr = m_pFrame->HrGetPropShowAllTags(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	 return hr;
}

STDMETHODIMP CDHTMLSafe::put_ShowDetails(VARIANT_BOOL newVal)
{
	_ASSERTE(m_pFrame);
	SetDirty ( TRUE );
	FireOnChanged ( DISPID_SHOWDETAILS );
	
	return m_pFrame->HrSetPropShowAllTags(newVal);
}

STDMETHODIMP CDHTMLSafe::get_ShowBorders(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPropShowBorders(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value

	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ShowBorders(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPropShowBorders(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SHOWBORDERS );
	}
	return hr;
}



STDMETHODIMP CDHTMLSafe::get_Appearance(DHTMLEDITAPPEARANCE * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetDisplay3D(bVal);
	*pVal = (bVal) ? DEAPPEARANCE_3D : DEAPPEARANCE_FLAT;
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_Appearance(DHTMLEDITAPPEARANCE newVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = (newVal == DEAPPEARANCE_3D) ? TRUE : FALSE;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetDisplay3D(bVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_DHTMLEDITAPPEARANCE );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_Scrollbars(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetScrollbars(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_Scrollbars(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetScrollbars(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_DHTMLEDITSCROLLBARS );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_ScrollbarAppearance(DHTMLEDITAPPEARANCE * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetDisplayFlatScrollbars(bVal);
	*pVal = (bVal) ? DEAPPEARANCE_FLAT : DEAPPEARANCE_3D;
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_ScrollbarAppearance(DHTMLEDITAPPEARANCE newVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = (newVal == DEAPPEARANCE_3D) ? FALSE : TRUE;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetDisplayFlatScrollbars(bVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SCROLLBARAPPEARANCE );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_SourceCodePreservation(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetPreserveSource(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_SourceCodePreservation(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetPreserveSource(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SOURCECODEPRESERVATION );
	}
	return hr;
}

///////////////////////////////////////

STDMETHODIMP CDHTMLSafe::get_AbsoluteDropMode(VARIANT_BOOL* pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetAbsoluteDropMode(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}


STDMETHODIMP CDHTMLSafe::put_AbsoluteDropMode(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetAbsoluteDropMode(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_ABSOLUTEDROPMODE );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_SnapToGrid(VARIANT_BOOL* pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetSnapToGrid(bVal);
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_SnapToGrid(VARIANT_BOOL newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetSnapToGrid(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SNAPTOGRID );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_SnapToGridX(LONG* pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetSnapToGridX(*pVal);
	return hr;
}

STDMETHODIMP CDHTMLSafe::put_SnapToGridX(LONG newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetSnapToGridX(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SNAPTOGRIDX );
	}
	return hr;
}

STDMETHODIMP CDHTMLSafe::get_SnapToGridY(LONG* pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetSnapToGridY(*pVal);
	return hr;
}


STDMETHODIMP CDHTMLSafe::put_SnapToGridY(LONG newVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);

	hr = m_pFrame->HrSetSnapToGridY(newVal);
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_SNAPTOGRIDY );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_CurrentDocumentPath(BSTR * pVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (!pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetCurrentDocumentPath(pVal);
	return hr;
}


STDMETHODIMP CDHTMLSafe::get_IsDirty(VARIANT_BOOL * pVal)
{
	HRESULT hr = S_OK;
	BOOL bVal = FALSE;

	_ASSERTE(pVal);
	_ASSERTE(m_pFrame);

	if (NULL == pVal)
		return E_INVALIDARG;

	hr = m_pFrame->HrGetIsDirty(bVal);

#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = (TRUE == bVal) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value

	return hr;
}


STDMETHODIMP CDHTMLSafe::get_BaseURL(/* [retval][out] */ BSTR  *baseURL)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);
	_ASSERTE ( baseURL );

	if ( NULL == baseURL )
	{
		return E_INVALIDARG;
	}

	CComBSTR bstr;
	hr = m_pFrame->GetBaseURL ( bstr );

	if ( SUCCEEDED ( hr ) )
	{
		SysReAllocString ( baseURL, bstr );
	}
	return hr;
}


STDMETHODIMP CDHTMLSafe::put_BaseURL(/* [in] */ BSTR baseURL)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pFrame);
	_ASSERTE ( baseURL );
	if ( NULL == baseURL )
	{
		return E_INVALIDARG;
	}

	CComBSTR bstr = baseURL;
	hr = m_pFrame->SetBaseURL ( bstr );

	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_BASEURL );
	}

	return hr;
}


STDMETHODIMP CDHTMLSafe::get_DocumentTitle(/* [retval][out] */ BSTR  *docTitle)
{
	HRESULT hr = S_OK;

	_ASSERTE ( docTitle );
	_ASSERTE ( m_pFrame );

	if ( NULL == docTitle )
	{
		return E_INVALIDARG;
	}

	CComBSTR bstr;
	hr = m_pFrame->GetDocumentTitle ( bstr );
	if ( SUCCEEDED ( hr ) )
	{
		SysReAllocString ( docTitle, bstr );
	}

	return hr;
}


STDMETHODIMP CDHTMLSafe::get_UseDivOnCarriageReturn ( VARIANT_BOOL  *pVal )
{
	_ASSERTE ( pVal );
	if ( NULL == pVal )
	{
		return E_INVALIDARG;
	}

	return m_pFrame->GetDivOnCr ( pVal );
}


STDMETHODIMP CDHTMLSafe::get_Busy ( VARIANT_BOOL  *pVal )
{
	_ASSERTE ( pVal );
	if ( NULL == pVal )
	{
		return E_INVALIDARG;
	}

	return m_pFrame->GetBusy ( pVal );
}


STDMETHODIMP CDHTMLSafe::put_UseDivOnCarriageReturn ( VARIANT_BOOL newVal )
{
	HRESULT hr = S_OK;

	hr = m_pFrame->SetDivOnCr( newVal );
	if ( SUCCEEDED ( hr ) )
	{
		SetDirty ( TRUE );
		FireOnChanged ( DISPID_USEDIVONCR );
	}

	return hr;
}


STDMETHODIMP CDHTMLSafe::SetContextMenu(/*[in]*/LPVARIANT menuStrings, /*[in]*/ LPVARIANT menuStates)
{
	HRESULT hr = S_OK;

	hr = m_pFrame->SetContextMenu(menuStrings, menuStates);
	return hr;
}


STDMETHODIMP CDHTMLSafe::NewDocument ()
{
	HRESULT hr = E_FAIL;

	_ASSERTE ( m_pFrame );
	if ( NULL == m_pFrame )
	{
		return E_UNEXPECTED;
	}

	hr = m_pFrame->LoadDocument( NULL );

	return hr;
}


STDMETHODIMP CDHTMLSafe::Refresh ()
{
	HRESULT hr = E_FAIL;

	_ASSERTE ( m_pFrame );
	if ( NULL == m_pFrame )
	{
		return E_UNEXPECTED;
	}

	hr = m_pFrame->RefreshDoc ();

	return hr;
}


//	In the safe for scripting version, only the http: protocol is permitted.
//
STDMETHODIMP CDHTMLSafe::LoadURL ( BSTR url )
{
	HRESULT		hr = S_OK;
	CComBSTR	rbstrSafeProtocols[] = { L"http://", L"https://", L"ftp://" };

	_ASSERTE(url);

	_ASSERTE ( m_pFrame );
	if (  NULL == m_pFrame )
	{
		return E_UNEXPECTED;
	}

	if ( ( NULL == url ) || ( 0 == SysStringLen ( url ) ) )
		return E_INVALIDARG;

	// Check for the protocol:
	CComBSTR bstrURL = url;
	_wcslwr ( bstrURL.m_str );

	BOOL bfSafe = FALSE;
	for ( int iProtocol = 0;
		iProtocol < ( sizeof ( rbstrSafeProtocols ) / sizeof ( CComBSTR ) );
		iProtocol++ )
	{
		if ( 0 == wcsncmp ( bstrURL.m_str, rbstrSafeProtocols[iProtocol],
			rbstrSafeProtocols[iProtocol].Length () ) )
		{
			bfSafe = TRUE;
			break;
		}
	}

	hr = m_pFrame->CheckCrossZoneSecurity ( url );
	if ( SUCCEEDED ( hr ) )
	{
		hr = DE_E_UNKNOWN_PROTOCOL;
		if ( bfSafe )
		{
			hr = m_pFrame->LoadDocument( url, TRUE );
		}
	}

	return hr;
}


STDMETHODIMP CDHTMLSafe::FilterSourceCode(BSTR sourceCodeIn, BSTR* sourceCodeOut)
{
	HRESULT	hr;

	_ASSERTE ( sourceCodeIn );
	_ASSERTE ( sourceCodeOut );

	if ( ( NULL == sourceCodeIn ) || ( NULL == sourceCodeOut ) )
	{
		return E_INVALIDARG;
	}

	*sourceCodeOut = NULL;

	hr = m_pFrame->FilterSourceCode ( sourceCodeIn, sourceCodeOut );
	return hr;
}


//	Override handler for IOleInPlaceObject->UIDeactivate to fire the blur event.
//
HRESULT CDHTMLSafe::IOleInPlaceObject_UIDeactivate ( void )
{
    Fire_onblur();
    m_pFrame->UIDeactivate();
    return CComControlBase::IOleInPlaceObject_UIDeactivate ();
}

// Override IOleObjectImpl methods
// We must set the object as dirty when resized
//
HRESULT CDHTMLSafe::IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	if ((m_sizeExtent.cx != psizel->cx || m_sizeExtent.cy != psizel->cy) && !m_fJustCreated)
		SetDirty(TRUE);
	m_fJustCreated = FALSE;
	return CComControlBase::IOleObject_SetExtent(dwDrawAspect, psizel);
}


HRESULT CDHTMLSafe::IPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY*)
{
	return CComControlBase::IPersistStreamInit_Save ( pStm, fClearDirty, ProperPropMap() );
}


HRESULT CDHTMLSafe::IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY*)
{
	return CComControlBase::IPersistStreamInit_Load ( pStm, ProperPropMap() );
}

HRESULT CDHTMLSafe::IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* )
{
	return CComControlBase::IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, ProperPropMap());
}


HRESULT CDHTMLSafe::IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY*)
{
	return CComControlBase::IPersistPropertyBag_Load(pPropBag, pErrorLog, ProperPropMap());
}


//	We cannot QI for the OuterEditControl in the FinalConstruct, or we crash whenever
//	we're aggregated.  So, we QI on demand.
//	Call this routine to get the outer control's unknown, never use m_piOuterEditCtl
//	directly.
//	NOTE:
//	This routine DOES NOT addref the interface returned!  Do not release it!
//
IDHTMLEdit * CDHTMLSafe::GetOuterEditControl ()
{
	if ( ! m_bfOuterEditUnknownTested )
	{
		m_bfOuterEditUnknownTested = TRUE;

		// Keep an un-addreffed pointer to the aggregating DHTMLEdit control, if it exists.
		if ( SUCCEEDED ( GetControllingUnknown()->QueryInterface ( IID_IDHTMLEdit, (void**)&m_piOuterEditCtl ) ) )
		{
			_ASSERTE ( m_piOuterEditCtl );
			m_piOuterEditCtl->Release ();
		}
	}
	_ASSERTE ( (IDHTMLEdit*)-1 != m_piOuterEditCtl );
	return m_piOuterEditCtl;
}


//	There are two property maps to choose from.
//	Return the one for the DHTMLEdit control if it's aggregating us,
//	else return our own.
//
ATL_PROPMAP_ENTRY* CDHTMLSafe::ProperPropMap ()
{
	IDHTMLEdit *piOuterEditControl = GetOuterEditControl ();

	if ( NULL == piOuterEditControl )
	{
		return CDHTMLSafe::GetPropertyMap();
	}
	else
	{
		return CDHTMLEdit::GetPropertyMap();
	}
}


//	Return the appropriate CLSID, depending on whether we're the safe or unsafe control.
//
HRESULT CDHTMLSafe::GetClassID( CLSID *pClassID )
{
	IDHTMLEdit *piOuterEditControl = GetOuterEditControl ();

	if ( NULL == piOuterEditControl )
	{
		*pClassID = CLSID_DHTMLSafe;
	}
	else
	{
		*pClassID = CLSID_DHTMLEdit;
	}
	return S_OK;
}


//	The above redirecting of the PropertyMap doesn't work unless we override this method,
//	We keep an un-addref'd pointer to the aggregating DHTMLEdit control if available.
//	Addreffing it would cause a circular reference.
//
HRESULT CDHTMLSafe::ControlQueryInterface(const IID& iid, void** ppv)
{
	HRESULT	hr = S_OK;
	IDHTMLEdit *piOuterEditControl = GetOuterEditControl ();

	if ( NULL == piOuterEditControl )
	{
		hr = GetUnknown()->QueryInterface ( iid, ppv );
	}
	else
	{
		hr = piOuterEditControl->QueryInterface ( iid, ppv );
	}
	return hr;
}




////////////////////////////////////////////////////
//
//	Event sink
//

class ATL_NO_VTABLE CEventXferSink :
	public CComObjectRootEx<CComSingleThreadModel>,
	public _DHTMLSafeEvents
{
public:
BEGIN_COM_MAP(CEventXferSink)
	COM_INTERFACE_ENTRY_IID(DIID__DHTMLSafeEvents, _DHTMLSafeEvents)
END_COM_MAP()

	CEventXferSink ()
	{
		m_pCtl = NULL;
	}

	void SetOwner ( CDHTMLEdit* pCtl )
	{
		_ASSERTE ( pCtl );
		_ASSERTE ( NULL == m_pCtl );
		if ( NULL == m_pCtl )
		{
			m_pCtl = pCtl;
		}
	}

	STDMETHOD(GetTypeInfoCount) ( UINT * )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(GetTypeInfo) ( UINT, LCID, ITypeInfo ** )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(GetIDsOfNames) ( REFIID, OLECHAR **, UINT, LCID, DISPID * )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(Invoke) ( DISPID dispid, REFIID, LCID, USHORT, DISPPARAMS *pDispParams, VARIANT* /*pVarResult*/, EXCEPINFO *, UINT * )
	{
		HRESULT	hr = E_UNEXPECTED;
		_ASSERTE ( m_pCtl );
		if ( NULL != m_pCtl )
		{
			switch ( dispid )
			{
				case DISPID_DOCUMENTCOMPLETE:
					m_pCtl->Fire_DocumentComplete();
					break;

				case DISPID_DISPLAYCHANGED:
					m_pCtl->Fire_DisplayChanged ();
					break;

				case DISPID_SHOWCONTEXTMENU:
				{
					CComVariant		varParam;
					long			xPos = 0;
					long			yPos = 0;
					unsigned int	uiErr;

					// There should be exactly two parameters.
					_ASSERTE ( 2 == pDispParams->cArgs );
					if (2 == pDispParams->cArgs )
					{
						hr = DispGetParam( pDispParams, 1, VT_I4, &varParam, &uiErr );
						_ASSERTE ( SUCCEEDED ( hr ) );
						if ( SUCCEEDED ( hr ) )
						{
							yPos = varParam.lVal;
							hr = DispGetParam( pDispParams, 0, VT_I4, &varParam, &uiErr );
							_ASSERTE ( SUCCEEDED ( hr ) );
							if ( SUCCEEDED ( hr ) )
							{
								xPos = varParam.lVal;
								m_pCtl->Fire_ShowContextMenu ( xPos, yPos );
							}
						}
					}
					break;
				}

				case DISPID_CONTEXTMENUACTION:
				{
					CComVariant	varMenuIndex;
					unsigned int uiErr;

					// There should be exactly one parameter.
					_ASSERTE ( 1 == pDispParams->cArgs );
					if (1 == pDispParams->cArgs )
					{
						hr = DispGetParam( pDispParams, 0, VT_I4, &varMenuIndex, &uiErr );
						_ASSERTE ( SUCCEEDED ( hr ) );
						if ( SUCCEEDED ( hr ) )
						{
							long lMenuIndex = varMenuIndex.lVal;
							m_pCtl->Fire_ContextMenuAction ( lMenuIndex );
						}
					}
					break;
				}

				case DISPID_ONMOUSEDOWN:
					m_pCtl->Fire_onmousedown ();
					break;

				case DISPID_ONMOUSEMOVE:
					m_pCtl->Fire_onmousemove ();
					break;

				case DISPID_ONMOUSEUP:
					m_pCtl->Fire_onmouseup ();
					break;

				case DISPID_ONMOUSEOUT:
					m_pCtl->Fire_onmouseout ();
					break;

				case DISPID_ONMOUSEOVER:
					m_pCtl->Fire_onmouseover ();
					break;

				case DISPID_ONCLICK:
					m_pCtl->Fire_onclick ();
					break;

				case DISPID_ONDBLCLICK:
					m_pCtl->Fire_ondblclick ();
					break;

				case DISPID_ONKEYDOWN:
					m_pCtl->Fire_onkeydown ();
					break;

				case DISPID_ONKEYPRESS:
					{
						m_pCtl->Fire_onkeypress ();
#if 0
						VARIANT_BOOL	vbCancel;
						vbCancel = m_pCtl->Fire_onkeypress ();
						if ( NULL != pVarResult )
						{
							VariantClear ( pVarResult );
							pVarResult->vt = VT_BOOL;
							pVarResult->boolVal = vbCancel;
						}
#endif
					}
					break;

				case DISPID_ONKEYUP:
					m_pCtl->Fire_onkeyup ();
					break;

				case DISPID_ONBLUR:
					m_pCtl->Fire_onblur ();
					break;

				case DISPID_ONREADYSTATECHANGE:
					m_pCtl->Fire_onreadystatechange ();
					break;

				default:
					break;
			}
		}
		return S_OK;
	}

private:
	CDHTMLEdit*		m_pCtl;
};


////////////////////////////////////////////////////
//
//	CDHTMLEdit implementation
//

CDHTMLEdit::CDHTMLEdit()
{
	m_punkInnerCtl		= NULL;		// Aggregated control's IUnknown
	m_pInnerCtl			= NULL;		// Aggregated control's custome interface
	m_pInnerIOleObj		= NULL;		// Aggregated control's IOleObject
	m_pXferSink			= NULL;		// Event sink for aggregated control
	m_piInnerCtlConPt	= NULL;		// Connection point to aggregated control
	m_pInterconnect		= NULL;		// Interface on inner control for communication
	m_dwXferCookie		= 0;		// Cookie for aggregated control's connection point.
}

CDHTMLEdit::~CDHTMLEdit()
{
}


HRESULT CDHTMLEdit::FinalConstruct()
{
	// Aggregate DHTMLSafe control:
	HRESULT		hr			= E_FAIL;
	IUnknown*	punkContUnk	= NULL;

	punkContUnk = GetControllingUnknown ();
	_ASSERTE ( punkContUnk );

	hr = CoCreateInstance ( CLSID_DHTMLSafe, punkContUnk, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&m_punkInnerCtl );

	if ( SUCCEEDED ( hr ) )
	{
		_ASSERTE ( m_punkInnerCtl );

		hr = m_punkInnerCtl->QueryInterface ( IID_IOleObject, (void**)&m_pInnerIOleObj);
		_ASSERTE ( SUCCEEDED ( hr ) );
		_ASSERTE ( m_pInnerIOleObj );
		punkContUnk->Release ();

		hr = m_punkInnerCtl->QueryInterface ( IID_IDHTMLSafe, (void**)&m_pInnerCtl );	// This addrefs my unknown
		_ASSERTE ( SUCCEEDED ( hr ) );
		_ASSERTE ( m_pInnerCtl );
		punkContUnk->Release ();

		hr = m_punkInnerCtl->QueryInterface ( IID_IInterconnector, (void**)&m_pInterconnect );	// This addrefs my unknown
		_ASSERTE ( SUCCEEDED ( hr ) );
		_ASSERTE ( m_pInterconnect );
		punkContUnk->Release ();

		// Sink events from the aggregated control:
		m_pXferSink = new CComObject<CEventXferSink>;

		// Check if the new worked
		if(!m_pXferSink)
			return E_OUTOFMEMORY;

		m_pXferSink->AddRef ();
		m_pXferSink->SetOwner ( this );
		
		// Hook the sink up to the aggregated control:
		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer>picpc ( m_punkInnerCtl );
		if ( picpc )
		{
			punkContUnk->Release ();
			hr = picpc->FindConnectionPoint ( DIID__DHTMLSafeEvents, &m_piInnerCtlConPt );
			if ( SUCCEEDED ( hr ) )
			{
				hr = m_piInnerCtlConPt->Advise ( static_cast<IDispatch *>(m_pXferSink), &m_dwXferCookie);
				_ASSERTE ( SUCCEEDED ( hr ) );
			}
		}
	}

	_ASSERTE ( SUCCEEDED ( hr ) );
	return hr;
}

void CDHTMLEdit::FinalRelease()
{
	IUnknown*	punkContUnk	= NULL;

	punkContUnk = GetControllingUnknown ();
	_ASSERTE ( punkContUnk );

	// Unadvise the event sink:
	_ASSERTE ( m_pXferSink );
	_ASSERTE ( m_piInnerCtlConPt );
	if ( NULL != m_piInnerCtlConPt )
	{
		punkContUnk->AddRef ();
		m_piInnerCtlConPt->Unadvise ( m_dwXferCookie );
		m_piInnerCtlConPt->Release ();
		m_piInnerCtlConPt = NULL;
	}
	if ( NULL != m_pXferSink )
	{
		m_pXferSink->Release ();
		m_pXferSink = NULL;
	}

	if ( m_pInnerCtl )
	{
		// Releasing the cached interface will release my unknown, which has already been ballanced.
		punkContUnk->AddRef ();
		m_pInnerCtl->Release ();
	}
	if ( m_pInnerIOleObj )
	{
		punkContUnk->AddRef ();
		m_pInnerIOleObj->Release ();
	}
	if ( m_pInterconnect )
	{
		punkContUnk->AddRef ();
		m_pInterconnect->Release ();
	}
	if ( m_punkInnerCtl )
	{
		punkContUnk->AddRef ();
		m_punkInnerCtl->Release ();
	}
}



HRESULT
CDHTMLEdit::PromptOpenFile(LPTSTR pPath, ULONG ulPathLen)
{
    HRESULT         hr = S_OK;
    OPENFILENAME    ofn = {0};
    BOOL            bResult = FALSE;
	HWND			hWndCD	= NULL;
    
	_ASSERTE(pPath);

	if (NULL == pPath)
		return E_INVALIDARG;

	hr = m_pInterconnect->GetCtlWnd ( (SIZE_T*)&hWndCD );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( FAILED ( hr ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

    memset(&ofn, 0, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = NULL;
    ofn.hwndOwner = hWndCD;
	ofn.lpstrTitle = NULL;
    ofn.lpstrFilter = TEXT("HTML Documents (*.htm, *.html)\0*.htm;*.html\0");
    ofn.lpstrFile = pPath;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrDefExt = TEXT("htm");
    ofn.nMaxFile = ulPathLen;
    ofn.Flags = OFN_EXPLORER |
				OFN_FILEMUSTEXIST |
				OFN_PATHMUSTEXIST |
				OFN_OVERWRITEPROMPT |
				OFN_HIDEREADONLY;

    bResult = GetOpenFileName(&ofn);

    if (!bResult)
        return S_FALSE;

	return S_OK;
}


HRESULT
CDHTMLEdit::PromptSaveAsFile(LPTSTR pPath, ULONG ulPathLen)
{
    HRESULT         hr = S_OK;
    OPENFILENAME    ofn = {0};
    BOOL            bResult = FALSE;
	HWND			hWndCD	= NULL;
    
	_ASSERTE(pPath);

	if (NULL == pPath)
		return E_INVALIDARG;

	hr = m_pInterconnect->GetCtlWnd ( (SIZE_T*)&hWndCD );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( hWndCD );
	if ( FAILED ( hr ) || ( NULL == hWndCD ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

    memset(&ofn, 0, sizeof(ofn));

    ofn.lStructSize = sizeof(ofn);
	ofn.hwndOwner = NULL;
    ofn.hwndOwner = hWndCD;
	ofn.lpstrTitle = NULL;
    ofn.lpstrFilter = TEXT("HTML Documents (*.htm, *.html)\0*.htm;*.html\0");
    ofn.lpstrFile = pPath;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrDefExt = TEXT("htm");
    ofn.nMaxFile = ulPathLen;
	ofn.Flags           =   OFN_OVERWRITEPROMPT |
							OFN_CREATEPROMPT    |
							OFN_HIDEREADONLY    |
							OFN_EXPLORER;

    bResult = GetSaveFileName(&ofn);

    if (!bResult)
        return S_FALSE;

	return S_OK;
}



STDMETHODIMP CDHTMLEdit::LoadDocument(LPVARIANT path, LPVARIANT promptUser)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	BOOL bPromptUser = NULL;
	TCHAR promptPath[MAX_PATH] = {0};
	CComBSTR bstrPath;
	BSTR _path = NULL;

	_ASSERTE(path);

	CProxyFrame* pFrame = NULL;
	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	if (NULL == path || !(V_VT(path) ==  VT_BSTR || V_VT(path) == (VT_BSTR|VT_BYREF)))
		return E_INVALIDARG;

	// Note that it is valid for path to be NULL,
	// In automation an empty string (BSTR) is a NULL pointer
	// Passing in an emtpy string here allows for initializing TriEdit with
	// an empty document (IPersistStreamInit->InitNew)

	if (promptUser && (V_VT(promptUser) != VT_EMPTY && V_VT(promptUser) != VT_ERROR))
	{
		// note that if promptUser is not type VT_BOOL or VT_BOOL|VT_BYREF
		// then user is not prompted

#pragma warning(disable: 4310) // cast truncates constant value
		if (VT_BOOL == V_VT(promptUser))
			bPromptUser = (VARIANT_TRUE == V_BOOL(promptUser)) ? TRUE : FALSE;
		else if ((VT_BOOL|VT_BYREF) == V_VT(promptUser))
		{
			_ASSERTE(V_BOOLREF(promptUser));

			if (V_BOOLREF(promptUser))
				bPromptUser = (BOOL) (*(V_BOOLREF(promptUser)) == VARIANT_TRUE) ? TRUE : FALSE;
		}
#pragma warning(default: 4310) // cast truncates constant value
	}

	// prompt user overrides any doc name that is specified
	// Change VK:
	// ...but the provided doc name is used as the default.
	if (bPromptUser)
	{
		if ( NULL != path->bstrVal )
		{
			_tcsncpy ( promptPath, OLE2T(path->bstrVal), MAX_PATH );
		}
		hr = PromptOpenFile(promptPath, MAX_PATH);

		if (S_FALSE == hr)
			return S_OK;

		bstrPath = promptPath;
		_path = bstrPath;
	}
	else
	{	
		if ((VT_BSTR|VT_BYREF) == V_VT(path) && V_BSTRREF(path))
			_path = *(V_BSTRREF(path));
		else if (VT_BSTR == V_VT(path) && V_BSTR(path))
			_path = V_BSTR(path);
	}

	if ( 0 == SysStringLen ( _path ) )
	{
		return DE_E_INVALIDARG;
	}

	hr = pFrame->LoadDocument(_path);

	return hr;
}


STDMETHODIMP CDHTMLEdit::SaveDocument(LPVARIANT path, LPVARIANT promptUser)
{
	USES_CONVERSION;

	HRESULT hr= S_OK;
	TCHAR promptPath[MAX_PATH] = {0};
	CComBSTR bstrPath;
	BOOL bPromptUser = FALSE;
	BSTR _path = NULL;

	_ASSERTE(path);

	CProxyFrame* pFrame = NULL;
	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	if (NULL == path || !(V_VT(path) ==  VT_BSTR || V_VT(path) == (VT_BSTR|VT_BYREF)))
		return E_INVALIDARG;

	// prompt user overrides any doc name that is specified
	if (promptUser && (V_VT(promptUser) != VT_EMPTY && V_VT(promptUser) != VT_ERROR))
	{
		// note that if promptUser is not type VT_BOOL or VT_BOOL|VT_BYREF
		// then user is not prompted

#pragma warning(disable: 4310) // cast truncates constant value
		if (VT_BOOL == V_VT(promptUser))
			bPromptUser = (VARIANT_TRUE == V_BOOL(promptUser)) ? TRUE : FALSE;
		else if ((VT_BOOL|VT_BYREF) == V_VT(promptUser))
		{
			_ASSERTE(V_BOOLREF(promptUser));

			if (V_BOOLREF(promptUser))
				bPromptUser = (BOOL) (*(V_BOOLREF(promptUser)) == VARIANT_TRUE) ? TRUE : FALSE;
		}
#pragma warning(default: 4310) // cast truncates constant value
	}

	// prompt user overrides any doc name that is specified
	// Change VK:
	// ...but the provided doc name is used as the default.  If doc name is empty,
	// and the doc was opened from a file, the original file name is provided as a default.
	if (bPromptUser)
	{
		if ( NULL != path->bstrVal )
		{
			_tcsncpy ( promptPath, OLE2T(path->bstrVal), MAX_PATH );
			if ( 0 == _tcslen ( promptPath ) )
			{
				CComBSTR bstrFileName;

				if ( SUCCEEDED ( pFrame->GetCurDocNameWOPath ( bstrFileName ) ) )
				{
					_tcsncpy ( promptPath, OLE2T(bstrFileName), MAX_PATH );
				}
			}
		}
		hr = PromptSaveAsFile(promptPath, MAX_PATH);

		if (S_FALSE == hr)
			return S_OK;

		bstrPath = promptPath;
		_path = bstrPath;
	}
	else
	{	
		if ((VT_BSTR|VT_BYREF) == V_VT(path) && V_BSTRREF(path))
			_path = *(V_BSTRREF(path));
		else if (VT_BSTR == V_VT(path) && V_BSTR(path))
			_path = V_BSTR(path);
	}

	hr = pFrame->SaveDocument(_path);
	return hr;
}


STDMETHODIMP CDHTMLEdit::LoadURL ( BSTR url )
{
	HRESULT			hr		= E_FAIL;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	if ( ( NULL == url ) || ( 0 == SysStringLen ( url ) ) )
		return E_INVALIDARG;

	hr = pFrame->LoadDocument( url, TRUE );

	return hr;
}


STDMETHODIMP CDHTMLEdit::PrintDocument ( VARIANT* pvarWithUI )
{
	BOOL	bfWithUI	= FALSE;
	HRESULT	hr			= E_FAIL;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	if ( NULL != pvarWithUI )
	{
		CComVariant	varLocal = *pvarWithUI;

		hr = varLocal.ChangeType ( VT_BOOL );
		if ( SUCCEEDED ( hr ) )
		{
			bfWithUI = varLocal.boolVal;	// VariantBool to Bool is safe, not the reverse.
		}
	}

	hr = pFrame->Print ( bfWithUI );
	return S_OK;  // We can't return anything meaningful, because w/UI, Cancel returns E_FAIL.
}


STDMETHODIMP CDHTMLEdit::get_BrowseMode(/* [retval][out] */ VARIANT_BOOL  *pVal)
{
	HRESULT			hr		= S_OK;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	_ASSERTE ( pVal );
	if ( NULL == pVal )
	{
		return E_INVALIDARG;
	}

	return pFrame->GetBrowseMode ( pVal );
}


STDMETHODIMP CDHTMLEdit::put_BrowseMode(/* [in] */ VARIANT_BOOL newVal)
{
	HRESULT			hr		= S_OK;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	hr = pFrame->SetBrowseMode ( newVal );
	if ( SUCCEEDED ( hr ) )
	{
		m_pInterconnect->MakeDirty ( DISPID_BROWSEMODE );
	}

	return hr;
}


//	To be safe, restrict the range of cmdIDs to a known set.
//
STDMETHODIMP CDHTMLEdit::ExecCommand(DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pInVar, LPVARIANT pOutVar)
{
	HRESULT			hr			= S_OK;
	LPVARIANT		_pVarIn		= NULL;
	LPVARIANT		_pVarOut	= NULL;
	CProxyFrame*	pFrame	= NULL;

	hr = m_pInterconnect->GetInterconnector ( (SIZE_T*)&pFrame );
	_ASSERTE ( SUCCEEDED ( hr ) );
	_ASSERTE ( pFrame );
	if ( FAILED ( hr ) || ( NULL == pFrame ) )
	{
		return ( SUCCEEDED ( hr ) ) ? E_UNEXPECTED : hr;
	}

	// It is valid for pVar to be VT_EMPTY (on a DECMD_GETXXX op) but not VT_ERROR

	if (pInVar && (V_VT(pInVar) != VT_ERROR))
		_pVarIn = pInVar;

	if (pOutVar && (V_VT(pOutVar) != VT_ERROR))
		_pVarOut = pOutVar;

	if ( ( cmdexecopt < OLECMDEXECOPT_DODEFAULT ) ||
		 ( cmdexecopt >  OLECMDEXECOPT_DONTPROMPTUSER ) )
	{
		return E_INVALIDARG;
	}

	hr = pFrame->HrMapExecCommand(cmdID, cmdexecopt, _pVarIn, _pVarOut);

	return hr;
}


/*
 * IServiceProvider implementation
 */
STDMETHODIMP CDHTMLEdit::QueryService( REFGUID guidService, REFIID riid, void** ppvService )
{
	*ppvService = NULL;
	if ( SID_SInternetSecurityManager == guidService )
	{
		return GetUnknown()->QueryInterface ( riid, ppvService );
	}
	return E_NOINTERFACE;
}



/*
 * IInternetSecurityManager implementation
 *
 * The purpose of this implementation is to OVERRIDE security and reduce it to the minimum.
 * This should only be provided in Edit mode, not in browse mode. (Browse mode edits scripts.)
 * This prevents warnings about unsafe for scripting DTCs, etc.
 *
 * From HTMED/TriSite, by Carlos Gomes.
 *
 */

STDMETHODIMP CDHTMLEdit::GetSecurityId ( LPCWSTR /*pwszUrl*/, BYTE* /*pbSecurityId*/,
	DWORD* /*pcbSecurityId*/, DWORD_PTR /*dwReserved*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::GetSecuritySite ( IInternetSecurityMgrSite** /*ppSite*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::GetZoneMappings ( DWORD /*dwZone*/, IEnumString** /*ppenumString*/, DWORD /*dwFlags*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::MapUrlToZone ( LPCWSTR /*pwszUrl*/, DWORD *pdwZone, DWORD /*dwFlags*/ )
{
	if ( pdwZone != NULL )
	{
		*pdwZone = URLZONE_LOCAL_MACHINE;
		return NOERROR;
	}
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::ProcessUrlAction ( LPCWSTR /*pwszUrl*/, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy,
	BYTE* /*pContext*/, DWORD /*cbContext*/, DWORD /*dwFlags*/, DWORD /*dwReserved*/ )
{
	_ASSERTE ( pPolicy );
	if ( NULL == pPolicy )
	{
		return E_INVALIDARG;
	}

	// Handle
	// URLACTION_DOWNLOAD_SIGNED_ACTIVEX
	// URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY
	// URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY
	// URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY
	// URLACTION_SCRIPT_OVERRIDE_SAFETY
	// URLACTION_ACTIVEX_RUN
	// URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY
	// URLACTION_SCRIPT_SAFE_ACTIVEX
	//
	if(dwAction >= URLACTION_ACTIVEX_MIN && dwAction <= URLACTION_ACTIVEX_MAX)
	{
		if (cbPolicy >= sizeof(DWORD))
		{
			*(DWORD *)pPolicy = URLPOLICY_ALLOW;
			return S_OK;
		}
		return S_FALSE;
	}
	//
	// Handle
	// URLACTION_DOWNLOAD_SIGNED_ACTIVEX
	// URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX
	//
	
	// BUG 597859: Disable download overrides; use default action instead.
	//else if(dwAction >= URLACTION_DOWNLOAD_MIN && dwAction <= URLACTION_DOWNLOAD_MAX)
	//{
	//	if (cbPolicy >= sizeof(DWORD))
	//	{
	//		*(DWORD *)pPolicy = URLPOLICY_ALLOW;
	//		return S_OK;
	//	}
	//	return S_FALSE;
	//}
	
	//
	// Handle
	// URLACTION_SCRIPT_RUN
	// URLACTION_SCRIPT_JAVA_USE
	// URLACTION_SCRIPT_SAFE_ACTIVEX
	//
	else if(dwAction >= URLACTION_SCRIPT_MIN && dwAction <= URLACTION_SCRIPT_MAX)
	{
		if (cbPolicy >= sizeof(DWORD))
		{
			*(DWORD *)pPolicy = URLPOLICY_ALLOW;
			return S_OK;
		}
		return S_FALSE;
	}
	//
	// Allow applets to do anything they want.
	// Provide the java permissions.
	//
	else if(dwAction == URLACTION_JAVA_PERMISSIONS)
	{
		if (cbPolicy >= sizeof(DWORD))
		{
			//
			// URLPOLICY_JAVA_LOW
			// Set low Java security. Java applets will be allowed to
			// do high-capability operations, such as file I/O.
			//
			*(DWORD *)pPolicy = URLPOLICY_JAVA_LOW;
			return S_OK;
		}
		return S_FALSE;
	}
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::QueryCustomPolicy ( LPCWSTR /*pwszUrl*/, REFGUID /*guidKey*/,
	BYTE** /*ppPolicy*/, DWORD* /*pcbPolicy*/, BYTE* /*pContext*/, DWORD /*cbContext*/, DWORD /*dwReserved*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::SetSecuritySite ( IInternetSecurityMgrSite* /*pSite*/ )
{
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdit::SetZoneMapping ( DWORD /*dwZone*/, LPCWSTR /*lpszPattern*/, DWORD /*dwFlags*/ )
{
	return INET_E_DEFAULT_ACTION;
}


// Map to aggregated control's methods:
//
STDMETHODIMP CDHTMLEdit::get_IsDirty(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_IsDirty ( pVal );}
STDMETHODIMP CDHTMLEdit::get_SourceCodePreservation(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_SourceCodePreservation ( pVal );}
STDMETHODIMP CDHTMLEdit::put_SourceCodePreservation(VARIANT_BOOL newVal) {return m_pInnerCtl->put_SourceCodePreservation ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ScrollbarAppearance(DHTMLEDITAPPEARANCE *pVal) {return m_pInnerCtl->get_ScrollbarAppearance ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ScrollbarAppearance(DHTMLEDITAPPEARANCE newVal) {return m_pInnerCtl->put_ScrollbarAppearance ( newVal );}
STDMETHODIMP CDHTMLEdit::get_Scrollbars(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_Scrollbars ( pVal );}
STDMETHODIMP CDHTMLEdit::put_Scrollbars(VARIANT_BOOL newVal) {return m_pInnerCtl->put_Scrollbars ( newVal );}
STDMETHODIMP CDHTMLEdit::get_Appearance(DHTMLEDITAPPEARANCE *pVal) {return m_pInnerCtl->get_Appearance ( pVal );}
STDMETHODIMP CDHTMLEdit::put_Appearance(DHTMLEDITAPPEARANCE newVal) {return m_pInnerCtl->put_Appearance ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ShowBorders(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ShowBorders ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ShowBorders(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ShowBorders ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ShowDetails(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ShowDetails ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ShowDetails(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ShowDetails ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ActivateDTCs(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ActivateDTCs ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ActivateDTCs(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ActivateDTCs ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ActivateActiveXControls(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ActivateActiveXControls ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ActivateActiveXControls(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ActivateActiveXControls ( newVal );}
STDMETHODIMP CDHTMLEdit::get_ActivateApplets(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_ActivateApplets ( pVal );}
STDMETHODIMP CDHTMLEdit::put_ActivateApplets(VARIANT_BOOL newVal) {return m_pInnerCtl->put_ActivateApplets ( newVal );}
STDMETHODIMP CDHTMLEdit::get_DOM(IHTMLDocument2 **pVal) {return m_pInnerCtl->get_DOM ( pVal );}
STDMETHODIMP CDHTMLEdit::get_DocumentHTML(BSTR *pVal) {return m_pInnerCtl->get_DocumentHTML ( pVal );}
STDMETHODIMP CDHTMLEdit::put_DocumentHTML(BSTR newVal) {return m_pInnerCtl->put_DocumentHTML ( newVal );}
STDMETHODIMP CDHTMLEdit::get_AbsoluteDropMode(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_AbsoluteDropMode ( pVal );}
STDMETHODIMP CDHTMLEdit::put_AbsoluteDropMode(VARIANT_BOOL newVal) {return m_pInnerCtl->put_AbsoluteDropMode ( newVal );}
STDMETHODIMP CDHTMLEdit::get_SnapToGridX(LONG  *pVal) {return m_pInnerCtl->get_SnapToGridX ( pVal );}
STDMETHODIMP CDHTMLEdit::put_SnapToGridX(LONG newVal) {return m_pInnerCtl->put_SnapToGridX ( newVal );}
STDMETHODIMP CDHTMLEdit::get_SnapToGridY(LONG  *pVal) {return m_pInnerCtl->get_SnapToGridY ( pVal );}
STDMETHODIMP CDHTMLEdit::put_SnapToGridY(LONG newVal) {return m_pInnerCtl->put_SnapToGridY ( newVal );}
STDMETHODIMP CDHTMLEdit::get_SnapToGrid(VARIANT_BOOL  *pVal) {return m_pInnerCtl->get_SnapToGrid ( pVal );}
STDMETHODIMP CDHTMLEdit::put_SnapToGrid(VARIANT_BOOL newVal) {return m_pInnerCtl->put_SnapToGrid ( newVal );}
STDMETHODIMP CDHTMLEdit::get_CurrentDocumentPath(BSTR  *pVal) {return m_pInnerCtl->get_CurrentDocumentPath ( pVal );}
STDMETHODIMP CDHTMLEdit::QueryStatus(DHTMLEDITCMDID cmdID, DHTMLEDITCMDF* retval) {return m_pInnerCtl->QueryStatus ( cmdID, retval );}
STDMETHODIMP CDHTMLEdit::SetContextMenu(LPVARIANT menuStrings,LPVARIANT menuStates) {return m_pInnerCtl->SetContextMenu ( menuStrings, menuStates );}
STDMETHODIMP CDHTMLEdit::get_BaseURL(BSTR  *baseURL) {return m_pInnerCtl->get_BaseURL(baseURL);}
STDMETHODIMP CDHTMLEdit::put_BaseURL(BSTR baseURL) {return m_pInnerCtl->put_BaseURL(baseURL);}
STDMETHODIMP CDHTMLEdit::get_DocumentTitle(BSTR  *docTitle) {return m_pInnerCtl->get_DocumentTitle(docTitle);}
STDMETHODIMP CDHTMLEdit::NewDocument() {return m_pInnerCtl->NewDocument();}
STDMETHODIMP CDHTMLEdit::get_UseDivOnCarriageReturn(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_UseDivOnCarriageReturn(pVal);}
STDMETHODIMP CDHTMLEdit::put_UseDivOnCarriageReturn(VARIANT_BOOL newVal) {return m_pInnerCtl->put_UseDivOnCarriageReturn(newVal);}
STDMETHODIMP CDHTMLEdit::FilterSourceCode(BSTR sourceCodeIn, BSTR* sourceCodeOut) {return m_pInnerCtl->FilterSourceCode(sourceCodeIn, sourceCodeOut);}
STDMETHODIMP CDHTMLEdit::Refresh() {return m_pInnerCtl->Refresh();}
STDMETHODIMP CDHTMLEdit::get_Busy(VARIANT_BOOL *pVal) {return m_pInnerCtl->get_Busy(pVal);}

// End of DHTMLEdit.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\dispexa.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef _dispexa_h_
#define _dispexa_h_
#include <dispex.h>

class CDispExArray
{
public:

	CDispExArray() {
	};

	~CDispExArray() {
	};

	void Attach(IDispatchEx* pDispEx) {
		m_piDispEx = pDispEx;
	};

	void Detach() {
		m_piDispEx = NULL;
	};

	HRESULT HrGetLength(ULONG* pLength);
	HRESULT HrGetElement(ULONG index, LPVARIANT pVar);

private:
	CComPtr<IDispatchEx> m_piDispEx;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\dhtmled.cpp ===
// DHTMLEd.cpp : Implementation of DLL Exports.
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f DHTMLEdps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "DHTMLEd.h"
#include <TRIEDIID.h>
#include "DHTMLEd_i.c"
#include "DHTMLEdit.h"
#include "DEInsTab.h"
#include "DENames.h"


CComModule _Module;

static void SpikeSharedFileCount ();

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DHTMLEdit, CDHTMLEdit)
	OBJECT_ENTRY(CLSID_DHTMLSafe, CDHTMLSafe)
	OBJECT_ENTRY(CLSID_DEInsertTableParam, CDEInsertTableParam)
	OBJECT_ENTRY(CLSID_DEGetBlockFmtNamesParam, CDEGetBlockFmtNamesParam)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
//
//	Array of CLSIDs as text to be DELETED when registering the control.
//	These represent no-longer supported GUIDs for interfaces of the past.
//	All GUIDs in this array will be deleted from the HKCR\CLSID section.
//	MAINTENANCE NOTE:
//	When interfaces get new GUIDs (and the old ones are to be invalidated)
//	add the old GUIDs here with appropriate comments.
//
static TCHAR* s_rtszOldClsids [] =
{
	TEXT("{683364AF-B37D-11D1-ADC5-006008A5848C}"),	// Original Edit control GUID
	TEXT("{711054E0-CA70-11D1-8CD2-00A0C959BC0A}"),	// Original Safe for Scripting GUID
	TEXT("{F8A79F00-DA38-11D1-8CD6-00A0C959BC0A}"),	// Intermediate Edit control GUID
	TEXT("{F8A79F01-DA38-11D1-8CD6-00A0C959BC0A}")	// Intermediate Safe for Scripting GUID
};


/////////////////////////////////////////////////////////////////////////////
//
//	Array of CURRENT Interface GUIDS.
//	Note that IIDs and CLSIDs are not equivalent!
//	ATL fails to unregister these when unregisterin the control.
//	MAINTENANCE NOTE:
//	When interface GUIDs are changed, update this array.
//
static TCHAR* s_rtszCurrentInterfaces [] =
{
	TEXT("{CE04B590-2B1F-11d2-8D1E-00A0C959BC0A}"),	// IDHTMLSafe
	TEXT("{CE04B591-2B1F-11d2-8D1E-00A0C959BC0A}"),	// IDHTMLEdit
	TEXT("{47B0DFC6-B7A3-11D1-ADC5-006008A5848C}"),	// IDEInsertTableParam
	TEXT("{8D91090D-B955-11D1-ADC5-006008A5848C}"),	// IDEGetBlockFmtNamesParam
	TEXT("{588D5040-CF28-11d1-8CD3-00A0C959BC0A}"),	// _DHTMLEditEvents
	TEXT("{D1FC78E8-B380-11d1-ADC5-006008A5848C}"),	// _DHTMLSafeEvents
};


//	MAINTENANCE NOTE:
//	If the GUID of the type library changes, update here:
//
static TCHAR* s_tszTypeLibGUID = TEXT("{683364A1-B37D-11D1-ADC5-006008A5848C}");


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point
//
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		_Module.Term();
	}
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE
//
STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
//
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//
STDAPI DllRegisterServer(void)
{
	HRESULT hr = S_OK;
	CRegKey keyClassID;

	SpikeSharedFileCount ();

	// Unregister old CLSIDs, just in case the user is upgrading without unregistering first.
	hr = keyClassID.Open ( HKEY_CLASSES_ROOT, TEXT("CLSID") );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( ERROR_SUCCESS == hr )
	{
		int ctszOldClsids = sizeof ( s_rtszOldClsids ) / sizeof ( TCHAR* );
		for ( int iOldIntf = 0; iOldIntf < ctszOldClsids; iOldIntf++ )
		{
			hr = keyClassID.RecurseDeleteKey ( s_rtszOldClsids [ iOldIntf ] );
		}
		hr = keyClassID.Close ();
	}
	// hr is NOT returned.  Any failure deleting possibly non-existant keys is OK.

	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI DllUnregisterServer(void)
{
	HRESULT	hr		= S_OK;
	HRESULT hrMod	= _Module.UnregisterServer();

	// Since ATL does not unregister the TypeLib, do it manually.
	CRegKey	keyTypeLib;
	hr = keyTypeLib.Open ( HKEY_CLASSES_ROOT, TEXT("TypeLib") );
	if ( ERROR_SUCCESS == hr )
	{
		hr = keyTypeLib.RecurseDeleteKey ( s_tszTypeLibGUID );
		keyTypeLib.Close ();
	}

	// Delete all current GUIDs from the Interfaces section.  ATL fails to do this, too.
	CRegKey keyInterface;
	hr = keyInterface.Open ( HKEY_CLASSES_ROOT, TEXT("Interface") );
	if ( ERROR_SUCCESS == hr )
	{
		int ctszCurIntf = sizeof ( s_rtszCurrentInterfaces ) / sizeof ( TCHAR* );
		for ( int iCurIntf = 0; iCurIntf < ctszCurIntf; iCurIntf++ )
		{
			hr = keyInterface.RecurseDeleteKey ( s_rtszCurrentInterfaces [ iCurIntf ] );
		}
		hr = keyInterface.Close ();
	}
	// DO NOT RETURN the hr from above! It's OK to fail.

	return hrMod;
}


//	Because we've changed from a shared component to a system component, and we're now
//	installed by IE using RollBack rather than reference counting, a serious bug
//	occurs if we're installed once under IE4, IE5 is installed, and the original
//	product is uninstalled.  (We're deleted.  Bug 23681.)
//	This crude but effective routine spikes our reference count to 10000.
//	It doesn't matter so much where we're installed NOW, it matters where the shared
//	component was, or might be, installed.  Even if it's a different copy, the
//	DLL will be unregistered when its reference count is decremented to zero.
//
static void SpikeSharedFileCount ()
{
	CRegKey	keyShared;
	CRegKey	keyCurVer;
	HRESULT	hr = S_OK;

	hr = keyCurVer.Open ( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion" ) );
	_ASSERTE ( SUCCEEDED ( hr ) );

	if ( FAILED ( hr ) )
	{
		return;	// There's nothing we can do.
	}

	hr = keyShared.Open ( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls") );
	
	// We expect there to be a SharedDLLs key, but it's possible that there is none.
	if ( FAILED ( hr ) )
	{
		hr = keyShared.Create ( keyCurVer, TEXT("SharedDlls") );
	}

	_ASSERT ( SUCCEEDED ( hr ) );
	if ( SUCCEEDED ( hr ) )
	{
		TCHAR	tszPath[_MAX_PATH];
		TCHAR	tszMod[_MAX_PATH];
		DWORD	cchPath	= _MAX_PATH;
		
		// Build the string X:\Program Files\Common Files\Microsoft Shared\Triedit\dhtmled.ocx
		hr = keyCurVer.QueryValue ( tszPath, TEXT("CommonFilesDir"), &cchPath );
		if ( SUCCEEDED ( hr ) )
		{
			_tcscat ( tszPath, TEXT("\\Microsoft Shared\\Triedit\\") );
			
			// This routine gets the full path name of this DLL.  It SHOULD be the same
			// as the path we're constructing, but that could change in the future, so
			// truncate all but the bare file name.
			if ( 0 != GetModuleFileName ( _Module.GetModuleInstance(), tszMod, _MAX_PATH ) )
			{
				_tcsrev ( tszMod );				// Reverse the string
				_tcstok ( tszMod, TEXT("\\") );	// This replaces the first backslash with a \0.
				_tcsrev ( tszMod );
				_tcscat ( tszPath, tszMod );

				hr = keyShared.SetValue ( 10000, tszPath );
			}
		}
		hr = keyShared.Close ();
	}
	keyCurVer.Close ();
}


// End of DHTMLEd.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\dispexa.cpp ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "dispexa.h"


HRESULT
CDispExArray::HrGetLength(ULONG* pLength)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	VARIANT var;
	BSTR bstrName = NULL;
	WCHAR* oleStr = NULL;
	DISPID dispid;
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

	if (!m_piDispEx)
		return E_UNEXPECTED;

	_ASSERTE(pLength);
	if (NULL == pLength)
		return E_INVALIDARG;

	VariantInit(&var);
	oleStr = T2OLE(_T("length"));
	bstrName = ::SysAllocString(oleStr);

	if (FAILED(hr = m_piDispEx->GetDispID(bstrName, fdexNameCaseSensitive, &dispid)))
		goto cleanup;

	::SysFreeString(bstrName);
	bstrName = NULL;	// BUG 597865

	hr = m_piDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, 
				DISPATCH_PROPERTYGET, &dispparamsNoArgs, 
				&var, NULL, NULL);

	if (FAILED(hr))
		goto cleanup;


	if (V_VT(&var) != VT_I4)
		goto cleanup;

	*pLength = V_I4(&var);

cleanup:
	if (FAILED(hr))
	{
		if (bstrName)
			::SysFreeString(bstrName);
	}

	return hr;
}


HRESULT 
CDispExArray::HrGetElement(ULONG index, LPVARIANT pVar)
{

	USES_CONVERSION;
	HRESULT hr = S_OK;
	VARIANT var;
	BSTR bstrName = NULL;
	WCHAR* oleStr = NULL;
	DISPID dispid = 0;
	DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
	char buffer[32];

	if (!m_piDispEx)
		return E_UNEXPECTED;

	_ASSERTE(pVar);
	if (NULL == pVar)
		return E_INVALIDARG;

	VariantInit(&var);
	oleStr = A2OLE(_itoa(index, buffer, 10));
	bstrName = ::SysAllocString(oleStr);

	if (FAILED(hr = m_piDispEx->GetDispID(bstrName, fdexNameCaseSensitive, &dispid)))
		goto cleanup;

	SysFreeString(bstrName);
	bstrName = NULL;	// BUG 597865

	hr = m_piDispEx->InvokeEx(dispid, LOCALE_USER_DEFAULT, 
				DISPATCH_PROPERTYGET, &dispparamsNoArgs, 
				pVar, NULL, NULL);

	if (FAILED(hr))
		goto cleanup;

cleanup:

	if (FAILED(hr))
	{
		if (bstrName)
			::SysFreeString(bstrName);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\iadvsink.cpp ===
/*
 * IADVSINK.CPP
 * IAdviseSink for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "site.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/


/*
 * CImpIAdviseSink::CImpIAdviseSink
 * CImpIAdviseSink::~CImpIAdviseSink
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpIAdviseSink::CImpIAdviseSink( PCSite pSite, LPUNKNOWN pUnkOuter )
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIAdviseSink::~CImpIAdviseSink( void )
{
}


/*
 * CImpIAdviseSink::QueryInterface
 * CImpIAdviseSink::AddRef
 * CImpIAdviseSink::Release
 *
 * Purpose:
 *  IUnknown members for CImpIAdviseSink object.
 */

STDMETHODIMP CImpIAdviseSink::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIAdviseSink::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIAdviseSink::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



/*
 * Unused members in CImpIAdviseSink
 *  OnDataChange
 *  OnViewChange
 *  OnRename
 *  OnSave
 */

STDMETHODIMP_(void) CImpIAdviseSink::OnDataChange(LPFORMATETC /*pFEIn*/,
											LPSTGMEDIUM /*pSTM*/)
{
}

STDMETHODIMP_(void) CImpIAdviseSink::OnViewChange(DWORD /*dwAspect*/,
												LONG /*lindex*/)
{    
}

STDMETHODIMP_(void) CImpIAdviseSink::OnRename( LPMONIKER /*pmk*/ )
{
}

STDMETHODIMP_(void) CImpIAdviseSink::OnSave( void )
{
}


/*
 * CImpIAdviseSink::OnClose
 *
 * Purpose:
 *  Informs the advise sink that the OLE object has closed and is
 *  no longer bound in any way.  We use this to do a File/Close
 *  to delete the object since we don't hold onto any.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

STDMETHODIMP_(void) CImpIAdviseSink::OnClose( void )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\dhtmledit.h ===
// DHTMLEdit.h : Declaration of the CDHTMLEdit
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __DHTMLEDIT_H_
#define __DHTMLEDIT_H_

#include "resource.h"       // main symbols
#include "CPDHTMLEd.h"
#include "triedtctlid.h"
#include "private.h"
#include "wininet.h"
#include "trixacc.h"


class CProxyFrame;
class CEventXferSink;

typedef /* [helpstring][uuid] */ 
enum TriEditFilterConstants
    {	filterNone	= 0x1,
		filterDTCs	= 0x2,
		filterASP	= 0x8,
		preserveSourceCode	= 0x10,
		filterSourceCode	= 0x20,
		filterAll	= filterDTCs | filterASP | preserveSourceCode
    }	TriEditCtlFilterConstants;

#define DOCUMENT_COMPETE_MESSAGE	(WM_USER+18)
#define DOCUMENT_COMPETE_SIGNATURE	0xADFE


//	ATL 3.0 macro for overriding the window class settings.
#ifndef DECLARE_WND_CLASS_EX
#define DECLARE_WND_CLASS_EX(WndClassName, style, bkgnd) \
static CWndClassInfo& GetWndClassInfo() \
{ \
	static CWndClassInfo wc = \
	{ \
		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
	}; \
	return wc; \
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CDHTMLSafe
// This is the Safe for Scripting control, which is complete and stand-alone,
// but aggregated by DHTMLEdit to provide Load and Save capabilities.
//
class ATL_NO_VTABLE CDHTMLSafe : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDHTMLSafe, &CLSID_DHTMLSafe>,
	public CComControl<CDHTMLSafe>,
	public IDispatchImpl<IDHTMLSafe, &IID_IDHTMLSafe, &LIBID_DHTMLEDLib>,
	public IProvideClassInfo2Impl<&CLSID_DHTMLSafe, &DIID__DHTMLSafeEvents, &LIBID_DHTMLEDLib>,
	public IPersistStreamInitImpl<CDHTMLSafe>,
	public IPersistStorageImpl<CDHTMLSafe>,
	public IPersistPropertyBagImpl<CDHTMLSafe>,
	public IOleControlImpl<CDHTMLSafe>,
	public IOleObjectImpl<CDHTMLSafe>,
	public IOleInPlaceActiveObjectImpl<CDHTMLSafe>,
	public IViewObjectExImpl<CDHTMLSafe>,
	public IOleInPlaceObjectWindowlessImpl<CDHTMLSafe>,
	public IDataObjectImpl<CDHTMLSafe>,
	public ISpecifyPropertyPagesImpl<CDHTMLSafe>,
	public CProxy_DHTMLSafeEvents<CDHTMLSafe>,
	public IPropertyNotifySinkCP<CDHTMLSafe>,
	public IConnectionPointContainerImpl<CDHTMLSafe>,
	public IInterconnector
{
public:

	DECLARE_WND_CLASS_EX(NULL, CS_DBLCLKS, (HBRUSH)(COLOR_WINDOW+1))

	CDHTMLSafe();
	~CDHTMLSafe();

	BOOL IsUserMode() {
		HRESULT hr = S_OK;		
		BOOL bVal = FALSE;

		if (FAILED(hr = GetAmbientUserMode(bVal)))
			bVal = TRUE;
		
		return (bVal) ? TRUE : FALSE;
	};


DECLARE_REGISTRY_RESOURCEID(IDR_DHTMLSafe)
DECLARE_AGGREGATABLE(CDHTMLSafe)

BEGIN_COM_MAP(CDHTMLSafe)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IDHTMLSafe)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
	COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
	COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY_IMPL(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IInterconnector)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDHTMLSafe)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	PROP_ENTRY("ActivateApplets",				DISPID_ACTIVATEAPPLETS,			CLSID_NULL)
	PROP_ENTRY("ActivateActiveXControls",		DISPID_ACTIVATEACTIVEXCONTROLS, CLSID_NULL)
	PROP_ENTRY("ActivateDTCs",					DISPID_ACTIVATEDTCS,			CLSID_NULL)
	PROP_ENTRY("ShowDetails",					DISPID_SHOWDETAILS,				CLSID_NULL)
	PROP_ENTRY("ShowBorders",					DISPID_SHOWBORDERS,				CLSID_NULL)
	PROP_ENTRY("Appearance",					DISPID_DHTMLEDITAPPEARANCE,		CLSID_NULL)
	PROP_ENTRY("Scrollbars",					DISPID_DHTMLEDITSCROLLBARS,		CLSID_NULL)
	PROP_ENTRY("ScrollbarAppearance",			DISPID_SCROLLBARAPPEARANCE,		CLSID_NULL)
	PROP_ENTRY("SourceCodePreservation",		DISPID_SOURCECODEPRESERVATION,	CLSID_NULL)
	PROP_ENTRY("AbsoluteDropMode",				DISPID_ABSOLUTEDROPMODE,		CLSID_NULL)
	PROP_ENTRY("SnapToGrid",					DISPID_SNAPTOGRID,				CLSID_NULL)
	PROP_ENTRY("SnapToGridX",					DISPID_SNAPTOGRIDX,				CLSID_NULL)
	PROP_ENTRY("SnapToGridY",					DISPID_SNAPTOGRIDY,				CLSID_NULL)
	PROP_ENTRY("UseDivOnCarriageReturn",		DISPID_USEDIVONCR,				CLSID_NULL)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CDHTMLSafe)
	CONNECTION_POINT_ENTRY(DIID__DHTMLSafeEvents)
	CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CDHTMLSafe)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_SHOWWINDOW, OnShow)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(DOCUMENT_COMPETE_MESSAGE, OnDocumentComplete)
END_MSG_MAP()


// IViewObjectEx
	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
		return S_OK;
	}

// IDHTMLSafe
public:
	STDMETHOD(get_IsDirty)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_SourceCodePreservation)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_SourceCodePreservation)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_ScrollbarAppearance)(/*[out, retval]*/ DHTMLEDITAPPEARANCE *pVal);
	STDMETHOD(put_ScrollbarAppearance)(/*[in]*/ DHTMLEDITAPPEARANCE newVal);

	STDMETHOD(get_Scrollbars)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Scrollbars)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_Appearance)(/*[out, retval]*/ DHTMLEDITAPPEARANCE *pVal);
	STDMETHOD(put_Appearance)(/*[in]*/ DHTMLEDITAPPEARANCE newVal);

	STDMETHOD(get_ShowBorders)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ShowBorders)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ShowDetails)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ShowDetails)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_ActivateDTCs)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateDTCs)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ActivateActiveXControls)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateActiveXControls)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ActivateApplets)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateApplets)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_DOM)(/*[out, retval]*/ IHTMLDocument2 **pVal);
	STDMETHOD(get_DocumentHTML)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DocumentHTML)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_AbsoluteDropMode)(/* [retval][out] */ VARIANT_BOOL *pVal);
    STDMETHOD(put_AbsoluteDropMode)(/* [in] */ VARIANT_BOOL newVal);

    STDMETHOD(get_SnapToGridX)(/* [retval][out] */ LONG  *pVal);        
    STDMETHOD(put_SnapToGridX)(/* [in] */ LONG newVal);

    STDMETHOD(get_SnapToGridY)(/* [retval][out] */ LONG  *pVal);
    STDMETHOD(put_SnapToGridY)(/* [in] */ LONG newVal);

    STDMETHOD(get_SnapToGrid)(/* [retval][out] */ VARIANT_BOOL  *pVal);
    STDMETHOD(put_SnapToGrid)(/* [in] */ VARIANT_BOOL newVal);

    STDMETHOD(get_CurrentDocumentPath)(/* [retval][out] */ BSTR  *pVal);

    STDMETHOD(get_BaseURL)(/* [retval][out] */ BSTR  *baseURL);
    STDMETHOD(put_BaseURL)(/* [in] */ BSTR baseURL);
    STDMETHOD(get_DocumentTitle)(/* [retval][out] */ BSTR  *docTitle);

	STDMETHOD(get_UseDivOnCarriageReturn)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_UseDivOnCarriageReturn)(/*[in]*/ VARIANT_BOOL newVal);

    STDMETHOD(get_Busy)(/* [retval][out] */ VARIANT_BOOL *pVal);

	STDMETHOD(ExecCommand)(DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pInVar, LPVARIANT pOutVar);
	STDMETHOD(QueryStatus)(DHTMLEDITCMDID cmdID, /*[out, retval]*/ DHTMLEDITCMDF* retval);
	STDMETHOD(SetContextMenu)(/*[in]*/ LPVARIANT menuStrings, /*[in]*/ LPVARIANT menuStates);
	STDMETHOD(NewDocument)(void);
	STDMETHOD(LoadURL)(BSTR url);
	STDMETHOD(FilterSourceCode)(/*[in]*/ BSTR sourceCodeIn, /*[out, retval]*/ BSTR* sourceCodeOut);
	STDMETHOD(Refresh)(void);

	HRESULT OnDraw(ATL_DRAWINFO& di);
	LRESULT OnSize(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnDestroy(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnShow(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	LRESULT OnDocumentComplete(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);
	STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
	STDMETHOD(OnAmbientPropertyChange)(DISPID dispID);
	STDMETHOD(OnMnemonic)(LPMSG pMsg);
	HRESULT IOleInPlaceObject_UIDeactivate ( void );

	// IOleObject
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

	// IOleObjectImpl
	HRESULT IOleObject_SetExtent (DWORD dwDrawAspect, SIZEL *psizel);

	// IPersist overrides
	STDMETHOD(GetClassID)(CLSID *pClassID);

	// IPersistStreamInit override
	HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap);
	
	BOOL IsPropertyBagLoading ( void ) { return m_bfPropertyBagLoading; }

	// IPersistPropertyBag override
	HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap);
	HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap);

	// IInterconnector
	STDMETHOD(GetInterconnector)( SIZE_T* vp ) { *vp = (SIZE_T)m_pFrame; return S_OK; }
	STDMETHOD(GetCtlWnd)( SIZE_T* vw ) { *vw = (SIZE_T)m_hWndCD; return S_OK; }
	STDMETHOD(MakeDirty)( DISPID dispid ) { SetDirty ( TRUE ); FireOnChanged ( dispid ); return S_OK; }

	DECLARE_GET_CONTROLLING_UNKNOWN();

	// ATL helper functions override

	DECLARE_PROTECT_FINAL_CONSTRUCT();

	HRESULT FinalConstruct();
	void FinalRelease();

	void FocusSite ( BOOL bfGetFocus );

	IOleControlSite* GetControlSite ( void ) { return m_piControlSite; }

	HRESULT ControlQueryInterface(const IID& iid, void** ppv);
	BOOL	IsSafeForScripting ( void ) { return ( NULL == GetOuterEditControl () ); }

protected:
	HRESULT SpecialEdit ( DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt );

private:
	ATL_PROPMAP_ENTRY* ProperPropMap ( void );
	IDHTMLEdit* GetOuterEditControl ( void );

protected:

	class CProxyFrame*	m_pFrame;
	IOleControlSite*	m_piControlSite;
	BOOL				m_fJustCreated;
	IDHTMLEdit*			m_piOuterEditCtl;
	BOOL				m_bfPropertyBagLoading;
	BOOL				m_bfOuterEditUnknownTested;
};


/////////////////////////////////////////////////////////////////////////////
// CDHTMLEdit
//
class ATL_NO_VTABLE CDHTMLEdit : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDHTMLEdit, &CLSID_DHTMLEdit>,
	public IDispatchImpl<IDHTMLEdit, &IID_IDHTMLEdit, &LIBID_DHTMLEDLib>,
	public CProxy_DHTMLEditEvents<CDHTMLEdit>,
	public IProvideClassInfo2Impl<&CLSID_DHTMLEdit, &DIID__DHTMLEditEvents, &LIBID_DHTMLEDLib>,
	public IConnectionPointContainerImpl<CDHTMLEdit>,
	public IOleObject,
	public IServiceProvider,
	public IInternetSecurityManager
{
public:

	CDHTMLEdit();
	~CDHTMLEdit();

DECLARE_REGISTRY_RESOURCEID(IDR_DHTMLEDIT)
DECLARE_AGGREGATABLE(CDHTMLEdit)

BEGIN_COM_MAP(CDHTMLEdit)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IDHTMLEdit)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IServiceProvider)
	COM_INTERFACE_ENTRY(IInternetSecurityManager)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_punkInnerCtl)
END_COM_MAP()

BEGIN_PROPERTY_MAP(CDHTMLEdit)
	PROP_ENTRY("ActivateApplets",				DISPID_ACTIVATEAPPLETS,			CLSID_NULL)
	PROP_ENTRY("ActivateActiveXControls",		DISPID_ACTIVATEACTIVEXCONTROLS, CLSID_NULL)
	PROP_ENTRY("ActivateDTCs",					DISPID_ACTIVATEDTCS,			CLSID_NULL)
	PROP_ENTRY("ShowDetails",					DISPID_SHOWDETAILS,				CLSID_NULL)
	PROP_ENTRY("ShowBorders",					DISPID_SHOWBORDERS,				CLSID_NULL)
	PROP_ENTRY("Appearance",					DISPID_DHTMLEDITAPPEARANCE,		CLSID_NULL)
	PROP_ENTRY("Scrollbars",					DISPID_DHTMLEDITSCROLLBARS,		CLSID_NULL)
	PROP_ENTRY("ScrollbarAppearance",			DISPID_SCROLLBARAPPEARANCE,		CLSID_NULL)
	PROP_ENTRY("SourceCodePreservation",		DISPID_SOURCECODEPRESERVATION,	CLSID_NULL)
	PROP_ENTRY("AbsoluteDropMode",				DISPID_ABSOLUTEDROPMODE,		CLSID_NULL)
	PROP_ENTRY("SnapToGrid",					DISPID_SNAPTOGRID,				CLSID_NULL)
	PROP_ENTRY("SnapToGridX",					DISPID_SNAPTOGRIDX,				CLSID_NULL)
	PROP_ENTRY("SnapToGridY",					DISPID_SNAPTOGRIDY,				CLSID_NULL)
	PROP_ENTRY("BrowseMode",					DISPID_BROWSEMODE,				CLSID_NULL)
	PROP_ENTRY("UseDivOnCarriageReturn",		DISPID_USEDIVONCR,				CLSID_NULL)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CDHTMLEdit)
	CONNECTION_POINT_ENTRY(DIID__DHTMLEditEvents)
END_CONNECTION_POINT_MAP()


// IDHTMLEdit
public:
	STDMETHOD(get_IsDirty)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_SourceCodePreservation)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_SourceCodePreservation)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_ScrollbarAppearance)(/*[out, retval]*/ DHTMLEDITAPPEARANCE *pVal);
	STDMETHOD(put_ScrollbarAppearance)(/*[in]*/ DHTMLEDITAPPEARANCE newVal);

	STDMETHOD(get_Scrollbars)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Scrollbars)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_Appearance)(/*[out, retval]*/ DHTMLEDITAPPEARANCE *pVal);
	STDMETHOD(put_Appearance)(/*[in]*/ DHTMLEDITAPPEARANCE newVal);

	STDMETHOD(get_ShowBorders)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ShowBorders)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ShowDetails)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ShowDetails)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_ActivateDTCs)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateDTCs)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ActivateActiveXControls)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateActiveXControls)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ActivateApplets)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ActivateApplets)(/*[in]*/ VARIANT_BOOL newVal);

	STDMETHOD(get_DOM)(/*[out, retval]*/ IHTMLDocument2 **pVal);
	STDMETHOD(get_DocumentHTML)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_DocumentHTML)(/*[in]*/ BSTR newVal);

    STDMETHOD(get_AbsoluteDropMode)(/* [retval][out] */ VARIANT_BOOL *pVal);
    STDMETHOD(put_AbsoluteDropMode)(/* [in] */ VARIANT_BOOL newVal);

    STDMETHOD(get_SnapToGridX)(/* [retval][out] */ LONG  *pVal);        
    STDMETHOD(put_SnapToGridX)(/* [in] */ LONG newVal);

    STDMETHOD(get_SnapToGridY)(/* [retval][out] */ LONG  *pVal);
    STDMETHOD(put_SnapToGridY)(/* [in] */ LONG newVal);

    STDMETHOD(get_SnapToGrid)(/* [retval][out] */ VARIANT_BOOL  *pVal);
    STDMETHOD(put_SnapToGrid)(/* [in] */ VARIANT_BOOL newVal);

    STDMETHOD(get_CurrentDocumentPath)(/* [retval][out] */ BSTR  *pVal);

    STDMETHOD(get_BaseURL)(/* [retval][out] */ BSTR  *baseURL);
    STDMETHOD(put_BaseURL)(/* [in] */ BSTR baseURL);
    STDMETHOD(get_DocumentTitle)(/* [retval][out] */ BSTR  *docTitle);
    STDMETHOD(get_BrowseMode)(/* [retval][out] */ VARIANT_BOOL  *pVal);
    STDMETHOD(put_BrowseMode)(/* [in] */ VARIANT_BOOL newVal);

	STDMETHOD(get_UseDivOnCarriageReturn)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_UseDivOnCarriageReturn)(/*[in]*/ VARIANT_BOOL newVal);

    STDMETHOD(get_Busy)(/* [retval][out] */ VARIANT_BOOL *pVal);

	STDMETHOD(LoadDocument)(LPVARIANT path, LPVARIANT promptUser);
	STDMETHOD(SaveDocument)(LPVARIANT path, LPVARIANT promptUser);
	STDMETHOD(ExecCommand)(DHTMLEDITCMDID cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pInVar, LPVARIANT pOutVar);
	STDMETHOD(QueryStatus)(DHTMLEDITCMDID cmdID, /*[out, retval]*/ DHTMLEDITCMDF* retval);
	STDMETHOD(SetContextMenu)(/*[in]*/ LPVARIANT menuStrings, /*[in]*/ LPVARIANT menuStates);
	STDMETHOD(NewDocument)(void);
	STDMETHOD(PrintDocument)(VARIANT* pvarWithUI);
	STDMETHOD(LoadURL)(BSTR url);
	STDMETHOD(FilterSourceCode)(/*[in]*/ BSTR sourceCodeIn, /*[out, retval]*/ BSTR* sourceCodeOut);
	STDMETHOD(Refresh)(void);

	// IOleObject
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite);
	STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
	STDMETHOD(Close)(DWORD dwSaveOption);
	STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker* pmk);
	STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk );
	STDMETHOD(InitFromData)(IDataObject*  pDataObject, BOOL fCreation, DWORD dwReserved);
	STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject** ppDataObject);
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite , LONG lindex , HWND hwndParent, LPCRECT lprcPosRect);
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb);
	STDMETHOD(Update)(void);
	STDMETHOD(IsUpToDate)(void);
	STDMETHOD(GetUserClassID)(CLSID *pClsid);
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType);
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection);
	STDMETHOD(Unadvise)(DWORD dwConnection);
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise);
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus);
	STDMETHOD(SetColorScheme)(LOGPALETTE* pLogpal);

	// IServiceProvider
	STDMETHODIMP QueryService( REFGUID guidService, REFIID riid, void** ppv );

	// IInternetSecurityManager
	STDMETHOD(GetSecurityId)(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
	STDMETHOD(GetSecuritySite)(IInternetSecurityMgrSite **ppSite);
	STDMETHOD(GetZoneMappings)(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);
	STDMETHOD(MapUrlToZone)(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
	STDMETHOD(ProcessUrlAction)(LPCWSTR pwszUrl, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy, BYTE* pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
	STDMETHOD(QueryCustomPolicy)(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
	STDMETHOD(SetSecuritySite)(IInternetSecurityMgrSite *pSite);
	STDMETHOD(SetZoneMapping)(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);

	DECLARE_GET_CONTROLLING_UNKNOWN()

	// ATL helper functions override

	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct();
	void FinalRelease();

protected:

	HRESULT PromptOpenFile(LPTSTR pPath, ULONG ulPathLen);
	HRESULT PromptSaveAsFile(LPTSTR pPath, ULONG ulPathLen);

protected:

	IUnknown*			m_punkInnerCtl;
	IDHTMLSafe*			m_pInnerCtl;
	IOleObject*			m_pInnerIOleObj;
	IInterconnector*	m_pInterconnect;
	CEventXferSink*		m_pXferSink;
	IConnectionPoint*	m_piInnerCtlConPt;
	DWORD				m_dwXferCookie;
};


#endif //__DHTMLEDIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\dhuihndl.cpp ===
/*
 * IDOCHOSTUIHANDLER.CPP
 * IDocHostUIHandler for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "site.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "proxyframe.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImpIDocHostUIHandler::CImpIDocHostUIHandler
 * CImpIDocHostUIHandler::~CImpIDocHostUIHandler
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
CImpIDocHostUIHandler::CImpIDocHostUIHandler( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIDocHostUIHandler::~CImpIDocHostUIHandler( void )
{
}



/*
 * CImpIDocHostUIHandler::QueryInterface
 * CImpIDocHostUIHandler::AddRef
 * CImpIDocHostUIHandler::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleDocumentSite object.
 */
STDMETHODIMP CImpIDocHostUIHandler::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIDocHostUIHandler::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIDocHostUIHandler::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



// * CImpIDocHostUIHandler::GetHostInfo
// *
// * Purpose: Called at initialisation
// *
STDMETHODIMP CImpIDocHostUIHandler::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
	DWORD dwFlags = 0;
	BOOL bDialogEditing = FALSE;
	BOOL bDisplay3D= FALSE;
	BOOL bScrollbars = FALSE;
	BOOL bFlatScrollbars = FALSE;
	BOOL bContextMenu = FALSE;

	m_pSite->GetFrame()->HrGetDisplay3D(bDisplay3D);
	m_pSite->GetFrame()->HrGetScrollbars(bScrollbars);
	m_pSite->GetFrame()->HrGetDisplayFlatScrollbars(bFlatScrollbars);
	
	if (bDialogEditing == TRUE)
		dwFlags |= DOCHOSTUIFLAG_DIALOG;
	if (bDisplay3D == FALSE)
		dwFlags |= DOCHOSTUIFLAG_NO3DBORDER;
	if (bScrollbars == FALSE)
		dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;
	if (bFlatScrollbars)
		dwFlags |= DOCHOSTUIFLAG_FLAT_SCROLLBAR;
	if (bContextMenu == FALSE)
		dwFlags |= DOCHOSTUIFLAG_DISABLE_HELP_MENU;

	pInfo->dwFlags = dwFlags;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return S_OK;
}

// * CImpIDocHostUIHandler::ShowUI
// *
// * Purpose: Called when MSHTML.DLL shows its UI
// *
STDMETHODIMP CImpIDocHostUIHandler::ShowUI(
				DWORD /*dwID*/, 
				IOleInPlaceActiveObject * /*pActiveObject*/,
				IOleCommandTarget * /*pCommandTarget*/,
				IOleInPlaceFrame * /*pFrame*/,
				IOleInPlaceUIWindow * /*pDoc*/)
{

	// We've already got our own UI in place so just return S_OK
    return S_OK;
}

// * CImpIDocHostUIHandler::HideUI
// *
// * Purpose: Called when MSHTML.DLL hides its UI
// *
STDMETHODIMP CImpIDocHostUIHandler::HideUI(void)
{
    return S_OK;
}

// * CImpIDocHostUIHandler::UpdateUI
// *
// * Purpose: Called when MSHTML.DLL updates its UI
// *
STDMETHODIMP CImpIDocHostUIHandler::UpdateUI(void)
{
	// we fire this from proxyframe's IOleCommandTarget
	return S_OK;
}

// * CImpIDocHostUIHandler::EnableModeless
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::EnableModeless
// *
STDMETHODIMP CImpIDocHostUIHandler::EnableModeless(BOOL /*fEnable*/)
{
    return E_NOTIMPL;
}

// * CImpIDocHostUIHandler::OnDocWindowActivate
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::OnDocWindowActivate
// *
STDMETHODIMP CImpIDocHostUIHandler::OnDocWindowActivate(BOOL /*fActivate*/)
{
    return E_NOTIMPL;
}

// * CImpIDocHostUIHandler::OnFrameWindowActivate
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::OnFrameWindowActivate
// *
STDMETHODIMP CImpIDocHostUIHandler::OnFrameWindowActivate(BOOL /*fActivate*/)
{
    return E_NOTIMPL;
}

// * CImpIDocHostUIHandler::ResizeBorder
// *
// * Purpose: Called from MSHTML.DLL's IOleInPlaceActiveObject::ResizeBorder
// *
STDMETHODIMP CImpIDocHostUIHandler::ResizeBorder(
				LPCRECT /*prcBorder*/, 
				IOleInPlaceUIWindow* /*pUIWindow*/,
				BOOL /*fRameWindow*/)
{
    return E_NOTIMPL;
}

// * CImpIDocHostUIHandler::ShowContextMenu
// *
// * Purpose: Called when MSHTML.DLL would normally display its context menu
// *
STDMETHODIMP CImpIDocHostUIHandler::ShowContextMenu(
				DWORD /*dwID*/, 
				POINT* pptPosition,
				IUnknown* /*pCommandTarget*/,
				IDispatch* /*pDispatchObjectHit*/)
{
	USES_CONVERSION;

	HMENU hmenu = NULL;
	INT id = 0;
    HRESULT hr = NOERROR;
    LONG lLBound, lUBound, lIndex, lLBoundState, lUBoundState;
    BSTR  bstr=0;
    SAFEARRAY * psaStrings = NULL;
    SAFEARRAY * psaStates = NULL;
    int i;
	BOOL ok = FALSE;
	ULONG	state = 0;
	CComBSTR _bstr;

	_ASSERTE(m_pSite);
	_ASSERTE(m_pSite->GetFrame());
	_ASSERTE(m_pSite->GetFrame()->GetControl());
	_ASSERTE(m_pSite->GetFrame()->GetControl()->m_hWndCD);

	// Correct X & Y position for local coordinates:
	POINT ptPos = *pptPosition;
	HWND hwndDoc = m_pSite->GetFrame()->GetDocWindow ();
	_ASSERTE ( hwndDoc );
	_ASSERTE ( ::IsWindow ( hwndDoc ) );
	if ( ( NULL != hwndDoc ) && ::IsWindow ( hwndDoc ) )
	{
		::ScreenToClient ( hwndDoc, &ptPos );
		// correct for scrolling
		POINT ptScrollPos;
		if ( SUCCEEDED ( m_pSite->GetFrame()->GetScrollPos ( &ptScrollPos ) ) )
		{
			ptPos.x += ptScrollPos.x;
			ptPos.y += ptScrollPos.y;
		}
		m_pSite->GetFrame()->GetControl()->Fire_ShowContextMenu ( ptPos.x, ptPos.y );
	}

	psaStrings = m_pSite->GetFrame()->GetMenuStrings();
	psaStates = m_pSite->GetFrame()->GetMenuStates();

	if (NULL == psaStrings || NULL == psaStates)
		return S_OK;

	SafeArrayGetLBound(psaStrings, 1, &lLBound);
	SafeArrayGetUBound(psaStrings, 1, &lUBound);

	SafeArrayGetLBound(psaStates, 1, &lLBoundState);
	SafeArrayGetUBound(psaStates, 1, &lUBoundState);

	if (lLBound != lLBoundState || lUBound != lUBoundState)
		return S_OK;

	// there arrays have no elements
#if 0
	Bug 15224: lower and upper bound are both zero if there is one element in sthe array.
	psaStrings is NULL if there are no strings.
	if (lLBound == lUBound)
		return S_OK;
#endif

	hmenu = CreatePopupMenu();

	if (NULL == hmenu)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		return hr;
	}

	for (lIndex=lLBound, i=0; lIndex<=lUBound && i <= 256; lIndex++, i++)
	{
		if ( FADF_BSTR & psaStrings->fFeatures )
		{
			SafeArrayGetElement(psaStrings, &lIndex, &bstr);
			_bstr = bstr;
		}
		else if ( FADF_VARIANT & psaStrings->fFeatures )
		{
			VARIANT var;
			VariantInit ( &var );
			SafeArrayGetElement(psaStrings, &lIndex, &var);
			VariantChangeType ( &var, &var, 0, VT_BSTR );
			_bstr = var.bstrVal;
			VariantClear ( &var );
		}
		else
		{
			_ASSERTE ( ( FADF_BSTR | FADF_VARIANT ) & psaStrings->fFeatures );
			return E_UNEXPECTED;
		}

		if ( FADF_VARIANT & psaStates->fFeatures )
		{
			VARIANT var;
			VariantInit ( &var );
			SafeArrayGetElement(psaStates, &lIndex, &var);
			VariantChangeType ( &var, &var, 0, VT_I4 );
			state = var.lVal;
			VariantClear ( &var );
		}
		else
		{
			// A safe array of integers seems to use an fFeatures == 0, which can't
			// safely be tested for.
			SafeArrayGetElement(psaStates, &lIndex, &state);
		}
		
		if (_bstr.Length() == 0)
			state = MF_SEPARATOR|MF_ENABLED;
		else  if (state == triGray)
			state = MF_GRAYED;
		else if (state == triChecked)
			state = MF_CHECKED|MF_ENABLED;
		else  
			state = MF_ENABLED;

		ok = AppendMenu(hmenu, MF_STRING | state, i+35000, W2T(_bstr.m_str));

		_ASSERTE(ok);
	}

	id = (INT)TrackPopupMenu(
			hmenu,
			TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
			pptPosition->x,
			pptPosition->y,
			0,
			m_pSite->GetFrame()->GetControl()->m_hWndCD,
			NULL);

	_ASSERTE(id == 0 || (id >= 35000 && id <= 35000+i));

	if (id >= 35000 && id <= 35000+i)
		m_pSite->GetFrame()->GetControl()->Fire_ContextMenuAction(id-35000);

	DestroyMenu(hmenu);

    return S_OK;
}

// * CImpIDocHostUIHandler::TranslateAccelerator
// *
// * Purpose: Called from MSHTML.DLL's TranslateAccelerator routines
// *
STDMETHODIMP CImpIDocHostUIHandler::TranslateAccelerator(LPMSG /*lpMsg*/,
            /* [in] */ const GUID __RPC_FAR * /*pguidCmdGroup*/,
            /* [in] */ DWORD /*nCmdID*/)
{
    return S_FALSE;
}

// * CImpIDocHostUIHandler::GetOptionKeyPath
// *
// * Purpose: Called by MSHTML.DLL to find where the host wishes to store 
// *	its options in the registry
// *
STDMETHODIMP CImpIDocHostUIHandler::GetOptionKeyPath(BSTR* pbstrKey, DWORD)
{
	pbstrKey = NULL; // docs say this should be set to null if not used
	return S_OK;
}

STDMETHODIMP CImpIDocHostUIHandler::GetDropTarget( 
            /* [in] */ IDropTarget __RPC_FAR * /*pDropTarget*/,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR * /*ppDropTarget*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImpIDocHostUIHandler::GetExternal( 
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch)
{
	_ASSERTE ( ppDispatch );
	if ( NULL == ppDispatch )
	{
		return E_INVALIDARG;
	}
	*ppDispatch = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CImpIDocHostUIHandler::TranslateUrl( 
    /* [in] */ DWORD /*dwTranslate*/,
    /* [in] */ OLECHAR __RPC_FAR * /*pchURLIn*/,
    /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR * /*ppchURLOut*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImpIDocHostUIHandler::FilterDataObject( 
    /* [in] */ IDataObject __RPC_FAR * /*pDO*/,
    /* [out] */ IDataObject __RPC_FAR *__RPC_FAR * /*ppDORet*/)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\inc.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

//	VK 3/13/98:  Changed from StdAfx.cpp to Inc.cpp.  This naming convention wasn't compatible with NTBuild.


#include "stdafx.h"

#pragma warning(disable: 4100 4189)	// Necessary for ia64 build

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#pragma warning(default: 4100 4189)	// Necessary for ia64 build
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\iclisite.cpp ===
/*
 * ICLISITE.CPP
 * IOleClientSite for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "site.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImpIOleClientSite::CImpIOleClientSite
 * CImpIOleClientSite::~CImpIOleClientSite
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpIOleClientSite::CImpIOleClientSite( PCSite pSite, LPUNKNOWN pUnkOuter )
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIOleClientSite::~CImpIOleClientSite( void )
{
}



/*
 * CImpIOleClientSite::QueryInterface
 * CImpIOleClientSite::AddRef
 * CImpIOleClientSite::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleClientSite object.
 */

STDMETHODIMP CImpIOleClientSite::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIOleClientSite::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleClientSite::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}




/*
 * CImpIOleClientSite::SaveObject
 *
 * Purpose:
 *  Requests that the container call OleSave for the object that
 *  lives here.  Typically this happens on server shutdown.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         Standard.
 */
STDMETHODIMP CImpIOleClientSite::SaveObject( void )
{
    return S_OK;
}




/*
 * Unimplemented/trivial members
 *  GetMoniker
 *  GetContainer
 *  RequestNewObjectLayout
 *  OnShowWindow
 *  ShowObject
 */

STDMETHODIMP CImpIOleClientSite::GetMoniker(DWORD /*dwAssign*/,
							DWORD /*dwWhich*/, LPMONIKER* /*ppmk*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImpIOleClientSite::GetContainer( LPOLECONTAINER* ppContainer )
{
	_ASSERTE ( m_pSite );
	if ( m_pSite )
	{
		return m_pSite->GetContainer ( ppContainer );
	}
    return E_NOTIMPL;
}

STDMETHODIMP CImpIOleClientSite::RequestNewObjectLayout(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CImpIOleClientSite::OnShowWindow(BOOL /*fShow*/)
{
    return S_OK;
}

STDMETHODIMP CImpIOleClientSite::ShowObject(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\idocsite.cpp ===
/*
 * IDOCSITE.CPP
 * IOleDocumentSite for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "site.h"
#include "proxyframe.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImpIOleDocumentSite::CImpIOleDocumentSite
 * CImpIOleDocumentSite::~CImpIOleDocumentSite
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */
CImpIOleDocumentSite::CImpIOleDocumentSite( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIOleDocumentSite::~CImpIOleDocumentSite( void )
{
}



/*
 * CImpIOleDocumentSite::QueryInterface
 * CImpIOleDocumentSite::AddRef
 * CImpIOleDocumentSite::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleDocumentSite object.
 */
STDMETHODIMP CImpIOleDocumentSite::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIOleDocumentSite::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleDocumentSite::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}



/*
 * CImpIOleDocumentsite::ActivateMe
 *
 * Purpose:
 *  Instructs the container to activate the object in this site as
 *  a document object.
 *
 * Parameters:
 *  pView           IOleDocumentView * of the object to activate.
 *
 * Return Value:
 *  HRESULT         S_OK if successful, error code otherwise.
 */
STDMETHODIMP CImpIOleDocumentSite::ActivateMe( IOleDocumentView *pView )
{
    RECT                rc;
    IOleDocument*       pDoc;
    
    /*
     * If we're passed a NULL view pointer, then try to get one from
     * the document object (the object within us).
     */
    if ( NULL == pView )
    {
        if ( FAILED( m_pSite->GetObjectUnknown()->QueryInterface( 
 								IID_IOleDocument, (void **)&pDoc ) ) )
		{
            return E_FAIL;
		}

        if ( FAILED( pDoc->CreateView( m_pSite->GetIPSite(),
												NULL, 0, &pView ) ) )
		{
			pDoc->Release();
            return E_OUTOFMEMORY;
		}

        // Release doc pointer since CreateView is a good com method that addrefs
        pDoc->Release();
    }        
    else
    {
        IOleInPlaceSite* pInplaceSite = NULL;        
        pView->GetInPlaceSite(&pInplaceSite);
        
        if(pInplaceSite != m_pSite->GetIPSite())
        {
            //Make sure that the view has our client site
            pView->SetInPlaceSite( m_pSite->GetIPSite() );

        }

        //We're holding onto the pointer, so AddRef it.
        pView->AddRef();

        if(pInplaceSite)
            pInplaceSite->Release();
    }


    // Activation steps, now that we have a view:

    m_pSite->SetDocView( pView );
    
    //This sets up toolbars and menus first    
    pView->UIActivate( TRUE );

    //Set the window size sensitive to new toolbars
    m_pSite->GetFrame()->GetControl()->GetClientRect( &rc );
    pView->SetRect( &rc );

	//Makes it all active
    pView->Show( TRUE );    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\ipropsink.cpp ===
/*
 * IPROPSINK.CPP
 * IPropertyNotifySink for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include "site.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImplPropertyNotifySink::CImplPropertyNotifySink
 * CImplPropertyNotifySink::~CImplPropertyNotifySink
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImplPropertyNotifySink::CImplPropertyNotifySink( PCSite pSite, LPUNKNOWN pUnkOuter )
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImplPropertyNotifySink::~CImplPropertyNotifySink( void )
{
}


/*
 * CImplPropertyNotifySink::QueryInterface
 * CImplPropertyNotifySink::AddRef
 * CImplPropertyNotifySink::Release
 *
 * Purpose:
 *  IUnknown members for CImplPropertyNotifySink object.
 */

STDMETHODIMP CImplPropertyNotifySink::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImplPropertyNotifySink::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImplPropertyNotifySink::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}


STDMETHODIMP CImplPropertyNotifySink::OnChanged(DISPID dispid)
{
    if (dispid == DISPID_READYSTATE)
        m_pSite->OnReadyStateChanged();
    return S_OK;
}


STDMETHODIMP CImplPropertyNotifySink::OnRequestEdit (DISPID /*dispid*/)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\iipsite.cpp ===
/*
 * IIPSITE.CPP
 * IOleInPlaceSite for Document Objects CSite class
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#include "stdafx.h"
#include <docobj.h>
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "site.h"
#include "proxyframe.h"

/**
	Note: the m_cRef count is provided for debugging purposes only.
	CSite controls the destruction of the object through delete,
	not reference counting
*/

/*
 * CImpIOleInPlaceSite::CImpIOleInPlaceSite
 * CImpIOleInPlaceSite::~CImpIOleInPlaceSite
 *
 * Parameters (Constructor):
 *  pSite           PCSite of the site we're in.
 *  pUnkOuter       LPUNKNOWN to which we delegate.
 */

CImpIOleInPlaceSite::CImpIOleInPlaceSite( PCSite pSite, LPUNKNOWN pUnkOuter)
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIOleInPlaceSite::~CImpIOleInPlaceSite( void )
{
}


/*
 * CImpIOleInPlaceSite::QueryInterface
 * CImpIOleInPlaceSite::AddRef
 * CImpIOleInPlaceSite::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleInPlaceSite object.
 */

STDMETHODIMP CImpIOleInPlaceSite::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIOleInPlaceSite::AddRef(void)
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleInPlaceSite::Release(void)
{
    --m_cRef;
    return m_pUnkOuter->Release();
}




/*
 * CImpIOleInPlaceActiveObject::GetWindow
 *
 * Purpose:
 *  Retrieves the handle of the window associated with the object
 *  on which this interface is implemented.
 *
 * Parameters:
 *  phWnd           HWND * in which to store the window handle.
 *
 * Return Value:
 *  HRESULT         S_OK if successful, E_FAIL if there is no
 *                  window.
 */
STDMETHODIMP CImpIOleInPlaceSite::GetWindow( HWND *phWnd )
{
    //This is the client-area window in the frame
    *phWnd = m_pSite->GetWindow();
    return S_OK;
}


/*
 * CImpIOleInPlaceActiveObject::ContextSensitiveHelp
 *
 * Purpose:
 *  Instructs the object on which this interface is implemented to
 *  enter or leave a context-sensitive help mode.
 *
 * Parameters:
 *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 *  HRESULT         S_OK
 */

STDMETHODIMP CImpIOleInPlaceSite::ContextSensitiveHelp( 
											BOOL /*fEnterMode*/ )
{
    return S_OK;
}


/*
 * CImpIOleInPlaceSite::CanInPlaceActivate
 *
 * Purpose:
 *  Answers the server whether or not we can currently in-place
 *  activate its object.  By implementing this interface we say
 *  that we support in-place activation, but through this function
 *  we indicate whether the object can currently be activated
 *  in-place.  Iconic aspects, for example, cannot, meaning we
 *  return S_FALSE.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         S_OK if we can in-place activate the object
 *                  in this site, S_FALSE if not.
 */
STDMETHODIMP CImpIOleInPlaceSite::CanInPlaceActivate( void )
{    
    /*
     * We can always in-place activate--no restrictions for DocObjects.
     * We don't worry about other cases since CSite only ever creates
     * embedded files.
     */
    return S_OK;
}


/*
 * CImpIOleInPlaceSite::OnInPlaceActivate
 *
 * Purpose:
 *  Informs the container that an object is being activated in-place
 *  such that the container can prepare appropriately.  The
 *  container does not, however, make any user interface changes at
 *  this point.  See OnUIActivate.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */
STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceActivate( void )
{
	LPOLEINPLACEOBJECT pIOleIPObject;
    HRESULT hr = m_pSite->GetObjectUnknown()->QueryInterface(
					IID_IOleInPlaceObject, (void**) &pIOleIPObject );

	m_pSite->SetIPObject( pIOleIPObject );
    return hr;
}



/*
 * CImpIOleInPlaceSite::OnInPlaceDeactivate
 *
 * Purpose:
 *  Notifies the container that the object has deactivated itself
 *  from an in-place state.  Opposite of OnInPlaceActivate.  The
 *  container does not change any UI at this point.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */

STDMETHODIMP CImpIOleInPlaceSite::OnInPlaceDeactivate( void )
{
    /*
     * Since we don't have an Undo command, we can tell the object
     * right away to discard its Undo state.
     */
    m_pSite->Activate(OLEIVERB_DISCARDUNDOSTATE);
    m_pSite->GetIPObject()->Release();
    return NOERROR;
}




/*
 * CImpIOleInPlaceSite::OnUIActivate
 *
 * Purpose:
 *  Informs the container that the object is going to start munging
 *  around with user interface, like replacing the menu.  The
 *  container should remove any relevant UI in preparation.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */

STDMETHODIMP CImpIOleInPlaceSite::OnUIActivate( void )
{
	m_pSite->GetFrame()->GetControl()->DoVerbUIActivate ( NULL, NULL );
	// Bug 107500 returns an error from OnUIActivate.
	// If we return that error here, the control gets into an inconsistant state.
	// All is well if we return OK.
	return S_OK;
}




/*
 * CImpIOleInPlaceSite::OnUIDeactivate
 *
 * Purpose:
 *  Informs the container that the object is deactivating its
 *  in-place user interface at which time the container may
 *  reinstate its own.  Opposite of OnUIActivate.
 *
 * Parameters:
 *  fUndoable       BOOL indicating if the object will actually
 *                  perform an Undo if the container calls
 *                  ReactivateAndUndo.
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */
STDMETHODIMP CImpIOleInPlaceSite::OnUIDeactivate( BOOL /*fUndoable*/ )
{
	// Normally we'd tidy up here, but since MSHTML.DLL is the only thing we host
	// the Frame will go away on deactivation so there's no point in restoring
	// the Frame's empty state

    return NOERROR;
}


/*
 * CImpIOleInPlaceSite::DeactivateAndUndo
 *
 * Purpose:
 *  If immediately after activation the object does an Undo, the
 *  action being undone is the activation itself, and this call
 *  informs the container that this is, in fact, what happened.
 *  The container should call IOleInPlaceObject::UIDeactivate.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */
STDMETHODIMP CImpIOleInPlaceSite::DeactivateAndUndo( void )
{
	// Tell the object we are deactivating
    m_pSite->GetIPObject()->InPlaceDeactivate();
    return NOERROR;
}




/*
 * CImpIOleInPlaceSite::DiscardUndoState
 *
 * Purpose:
 *  Informs the container that something happened in the object
 *  that means the container should discard any undo information
 *  it currently maintains for the object.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR or an appropriate error code.
 */

STDMETHODIMP CImpIOleInPlaceSite::DiscardUndoState( void )
{
    return E_NOTIMPL;
}




/*
 * CImpIOleInPlaceSite::GetWindowContext
 *
 * Purpose:
 *  Provides an in-place object with pointers to the frame and
 *  document level in-place interfaces (IOleInPlaceFrame and
 *  IOleInPlaceUIWindow) such that the object can do border
 *  negotiation and so forth.  Also requests the position and
 *  clipping rectangles of the object in the container and a
 *  pointer to an OLEINPLACEFRAME info structure which contains
 *  accelerator information.
 *
 *  Note that the two interfaces this call returns are not
 *  available through QueryInterface on IOleInPlaceSite since they
 *  live with the frame and document, but not the site.
 *
 * Parameters:
 *  ppIIPFrame      LPOLEINPLACEFRAME * in which to return the
 *                  AddRef'd pointer to the container's
 *                  IOleInPlaceFrame.
 *  ppIIPUIWindow   LPOLEINPLACEUIWINDOW * in which to return
 *                  the AddRef'd pointer to the container document's
 *                  IOleInPlaceUIWindow.
 *  prcPos          LPRECT in which to store the object's position.
 *  prcClip         LPRECT in which to store the object's visible
 *                  region.
 *  pFI             LPOLEINPLACEFRAMEINFO to fill with accelerator
 *                  stuff.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CImpIOleInPlaceSite::GetWindowContext(
						LPOLEINPLACEFRAME* ppIIPFrame,
						LPOLEINPLACEUIWINDOW* ppIIPUIWindow,
						LPRECT prcPos,
						LPRECT prcClip,
						LPOLEINPLACEFRAMEINFO pFI )
{
    *ppIIPUIWindow = NULL;
    m_pSite->QueryInterface(
						IID_IOleInPlaceFrame, (void **)ppIIPFrame);
    
    if (NULL != prcPos)
	{
        GetClientRect( m_pSite->GetWindow(), prcPos );
	}

    *prcClip = *prcPos;

    pFI->cb = sizeof(OLEINPLACEFRAMEINFO);
    pFI->fMDIApp = FALSE;

	m_pSite->GetFrame()->GetWindow(&pFI->hwndFrame);
	SetWindowLong ( pFI->hwndFrame, GWL_STYLE,
		GetWindowLong ( pFI->hwndFrame, GWL_STYLE ) |
		WS_CLIPSIBLINGS | WS_CLIPCHILDREN );

    pFI->haccel = NULL;
    pFI->cAccelEntries = 0;

    return NOERROR;
}


/*
 * CImpIOleInPlaceSite::Scroll
 *
 * Purpose:
 *  Asks the container to scroll the document, and thus the object,
 *  by the given amounts in the sz parameter.
 *
 * Parameters:
 *  sz              SIZE containing signed horizontal and vertical
 *                  extents by which the container should scroll.
 *                  These are in device units.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CImpIOleInPlaceSite::Scroll( SIZE /*sz*/ )
{
    //Not needed for DocObjects
    return E_NOTIMPL;
}


/*
 * CImpIOleInPlaceSite::OnPosRectChange
 *
 * Purpose:
 *  Informs the container that the in-place object was resized.
 *  The container must call IOleInPlaceObject::SetObjectRects.
 *  This does not change the site's rectangle in any case.
 *
 * Parameters:
 *  prcPos          LPCRECT containing the new size of the object.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CImpIOleInPlaceSite::OnPosRectChange( LPCRECT /*prcPos*/ )
{
    //Not needed for DocObjects
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\ioleobj.cpp ===
//------------------------------------------------------------------------------
// ioleobj.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      6-27-97      created     (bash)
//		4-8-98       ported to dhtmled (vank)
//
// Implementation of IOleObject.
//
// We mostly just delegate to Trident's IOleObject, except
// for GetUserClassID and GetUserType.
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "DHTMLEd.h"
#include "dhtmledit.h"

STDMETHODIMP CDHTMLEdit::SetClientSite(IOleClientSite *pClientSite)
{
	ATLTRACE(_T("CDHTMLEdit::SetClientSite\n"));

	_ASSERTE(m_pInnerIOleObj);
    
	return m_pInnerIOleObj->SetClientSite ( pClientSite );
}

STDMETHODIMP CDHTMLEdit::GetClientSite(IOleClientSite **ppClientSite)
{
	ATLTRACE(_T("CDHTMLEdit::GetClientSite\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetClientSite(ppClientSite);
}

STDMETHODIMP CDHTMLEdit::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
	ATLTRACE(_T("CDHTMLEdit::SetHostNames\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->SetHostNames(szContainerApp, szContainerObj);
}

STDMETHODIMP CDHTMLEdit::Close(DWORD dwSaveOption)
{
	ATLTRACE(_T("CDHTMLEdit::Close\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->Close(dwSaveOption);
}

STDMETHODIMP CDHTMLEdit::SetMoniker(DWORD dwWhichMoniker, IMoniker* pmk)
{
	ATLTRACE(_T("CDHTMLEdit::SetMoniker\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->SetMoniker(dwWhichMoniker, pmk);
}

STDMETHODIMP CDHTMLEdit::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk )
{
	ATLTRACE(_T("CDHTMLEdit::GetMoniker\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetMoniker(dwAssign, dwWhichMoniker, ppmk);
}

STDMETHODIMP CDHTMLEdit::InitFromData(IDataObject*  pDataObject, BOOL fCreation, DWORD dwReserved)
{
	ATLTRACE(_T("CDHTMLEdit::InitFromData\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->InitFromData(pDataObject,  fCreation,  dwReserved );
}

STDMETHODIMP CDHTMLEdit::GetClipboardData(DWORD dwReserved, IDataObject** ppDataObject)
{
	ATLTRACE(_T("CDHTMLEdit::GetClipboardData\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetClipboardData(dwReserved, ppDataObject);
}


STDMETHODIMP CDHTMLEdit::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite , LONG lindex ,
								 HWND hwndParent, LPCRECT lprcPosRect)
{
	ATLTRACE(_T("CDHTMLEdit::DoVerb\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
}

STDMETHODIMP CDHTMLEdit::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
	ATLTRACE(_T("CDHTMLEdit::EnumVerbs\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->EnumVerbs(ppEnumOleVerb);
}

STDMETHODIMP CDHTMLEdit::Update(void)
{
	ATLTRACE(_T("CDHTMLEdit::Update\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->Update();
}

STDMETHODIMP CDHTMLEdit::IsUpToDate(void)
{
	ATLTRACE(_T("CDHTMLEdit::IsUpToDate\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->IsUpToDate();
}

STDMETHODIMP CDHTMLEdit::GetUserClassID(CLSID *pClsid)
{
	ATLTRACE(_T("CDHTMLEdit::GetUserClassID\n"));

	_ASSERTE(m_pInnerIOleObj);

	*pClsid = GetObjectCLSID();

	return S_OK;
}

STDMETHODIMP CDHTMLEdit::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
	ATLTRACE(_T("CDHTMLEdit::GetUserType\n"));

	_ASSERTE(m_pInnerIOleObj);

	return OleRegGetUserType(GetObjectCLSID(), dwFormOfType, pszUserType);
}

STDMETHODIMP CDHTMLEdit::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	ATLTRACE(_T("CDHTMLEdit::SetExtent\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->SetExtent(dwDrawAspect, psizel);
}

STDMETHODIMP CDHTMLEdit::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	ATLTRACE(_T("CDHTMLEdit::GetExtent\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetExtent(dwDrawAspect, psizel);
}

STDMETHODIMP CDHTMLEdit::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
	ATLTRACE(_T("CDHTMLEdit::Advise\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->Advise(pAdvSink, pdwConnection);
}

STDMETHODIMP CDHTMLEdit::Unadvise(DWORD dwConnection)
{
	ATLTRACE(_T("CDHTMLEdit::Unadvise\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->Unadvise(dwConnection);
}

STDMETHODIMP CDHTMLEdit::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
	ATLTRACE(_T("CDHTMLEdit::EnumAdvise\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->EnumAdvise(ppenumAdvise);
}

STDMETHODIMP CDHTMLEdit::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
	ATLTRACE(_T("CDHTMLEdit::GetMiscStatus\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->GetMiscStatus(dwAspect, pdwStatus);
}

STDMETHODIMP CDHTMLEdit::SetColorScheme(LOGPALETTE* pLogpal)
{
	ATLTRACE(_T("CDHTMLEdit::SetColorScheme\n"));

	_ASSERTE(m_pInnerIOleObj);

	return m_pInnerIOleObj->SetColorScheme(pLogpal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\private.h ===
//	private.h
//	Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//	Private interfaces for DHTMLED
// Include this in the file which used <initguid.h>

#ifndef __DHTMLED_PRIVATE_H__
#define __DHTMLED_PRIVATE_H__


typedef interface IInterconnector IInterconnector;
typedef interface IProtocolInfoConnector IProtocolInfoConnector;


DEFINE_GUID(IID_IInterconnector, 0x9499F420,0xCE86,0x11d1,0x8C,0xD3,0x00,0xA0,0xC9,0x59,0xBC,0x0A);

MIDL_INTERFACE("9499F420-CE86-11d1-8CD3-00A0C959BC0A")
IInterconnector : public IUnknown
{
	public:
    STDMETHOD(GetInterconnector)( SIZE_T* pProxyFrame );
    STDMETHOD(GetCtlWnd)( SIZE_T* pWndCD );
	STDMETHOD(MakeDirty)( DISPID dispid );
};



DEFINE_GUID(IID_IProtocolInfoConnector, 0x5ADEA280,0xC2CD,0x11d1,0x8C,0xCB,0x00,0xA0,0xC9,0x59,0xBC,0x0A);

MIDL_INTERFACE("5ADEA280-C2CD-11d1-8CCB-00A0C959BC0A")
IProtocolInfoConnector : public IUnknown
{
	public:
     STDMETHOD(SetProxyFrame)( SIZE_T* pProxyFrame);
    
};


DEFINE_GUID(CLSID_DHTMLEdProtocol, 0xF6E34E90,0xC032,0x11d1, 0x8C,0xCB,0x00,0xA0,0xC9,0x59,0xBC,0x0A);

DEFINE_GUID(IID_IMultiLanguage2Correct, 0xDCCFC164,0x2B38,0x11d2, 0xB7,0xEC,0x00,0xC0,0x4F,0x8F,0x5D,0x9A);

#endif //__DHTMLED_PRIVATE_H__

// End of private.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\plgprot.cpp ===
/*

    File: PlgProt.cpp

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:

    History:
        06/26/97    Cgomes - ported from Trident
		03/20/98	Vank   - ported from VID/htmed

	This pluggable protocol handler allows the control to override
	URL combining, parsing the security URL, and loading data.

	The control implements a property for the BaseURL which is set
	properly by default, but can be overridden by the user.  To make
	this work we override CombineURL.

	To assure that the control is safe when hosted by IE but powerful
	when hosted by VB, we override ParseURL(PARSE_SECURITY_URL) and
	return a URL representing the zone of the outermost hosting Trident,
	or the path to the drive where the DLL is installed if Trident is
	not our host.  This correctly handles cases where we're hosted on
	an intranet page, which is hosted in an internet page, which is
	hosted in an intranet page, etc.  The topmost container's security
	zone is the one returned to IE.
	
	Finally, the control is in charge of saying what data is to be loaded.
	This can be set from a file, a URL, or a BSTR.

	NOTE:
	TSDK had the unusual requirement of having to be able to register
	even when it could not run.  WinINet and UrlMon were dynamically
	loaded when the control was instantiated.  This is clearly not
	necessary when we're a part of IE5, so this code has been disabled
	using the define LATE_BIND_URLMON_WININET.

*/
#include "stdafx.h"
#include <wininet.h>
#include "plgprot.h"
#include "dhtmledit.h"


//////////////////////////////////////////////////////////////////////////////
//
//  DHTMLEd Protocol Implementaion
//
CDHTMLEdProtocolInfo::CDHTMLEdProtocolInfo()
{
	ATLTRACE(_T("CDHTMLEdProtocolInfo::CDHTMLEdProtocolInfo\n"));

	m_fZombied			= FALSE;
	m_pProxyFrame		= NULL;
	m_piProtocolConIntf	= NULL;
}


CDHTMLEdProtocolInfo::~CDHTMLEdProtocolInfo()
{
	ATLTRACE(_T("CDHTMLEdProtocolInfo::~CDHTMLEdProtocolInfo\n"));

	Zombie();
}


void CDHTMLEdProtocolInfo::Zombie()
{
	m_fZombied = TRUE;
	if ( NULL != m_piProtocolConIntf )
	{
		m_piProtocolConIntf->Release ();
		m_piProtocolConIntf = NULL;
	}
}


//////////////////////////////////////////////////////////////////////////////
//
//  IClassFactory Implementation
//

STDMETHODIMP CDHTMLEdProtocolInfo::CreateInstance
(
	IUnknown* 	/*pUnkOuter*/,
	REFIID 	   	riid,
	void**		ppvObject
)
{
	ExpectedExpr((!m_fZombied));
	InitParam(ppvObject);
	IfNullRet(ppvObject);

	HRESULT hr;

	// Only support creating the DHTMLEdProtocol object

	AtlCreateInstance(CDHTMLEdProtocol, riid, ppvObject);
	_ASSERTE(*ppvObject != NULL);

	if(*ppvObject == NULL)
		return E_NOINTERFACE;
	else
	{
		hr = (reinterpret_cast<IUnknown*>(*ppvObject)->QueryInterface) ( IID_IProtocolInfoConnector, (LPVOID*) &m_piProtocolConIntf );
		_ASSERTE ( SUCCEEDED ( hr ) && m_piProtocolConIntf );
		if ( SUCCEEDED ( hr ) && m_piProtocolConIntf )
		{
			if ( NULL != m_pProxyFrame )
			{
				m_piProtocolConIntf->SetProxyFrame ( (SIZE_T*)m_pProxyFrame );
			}
		}
		return NOERROR;
	}
}


STDMETHODIMP CDHTMLEdProtocolInfo::RemoteCreateInstance
(
	REFIID 		/*riid*/,
	IUnknown** 	/*ppvObject*/
)
{
	ExpectedExpr((!m_fZombied));
	ATLTRACENOTIMPL(_T("RemoteCreateInstance"));
}


STDMETHODIMP CDHTMLEdProtocolInfo::LockServer(BOOL /*fLock*/)
{
	ExpectedExpr((!m_fZombied));
	ATLTRACE(_T("CDHTMLEdProtocolInfo::LockServer\n"));

	return NOERROR;
}


STDMETHODIMP CDHTMLEdProtocolInfo::RemoteLockServer(BOOL /*fLock*/)
{
	ExpectedExpr((!m_fZombied));
	ATLTRACENOTIMPL(_T("RemoteLockServer"));
}


//////////////////////////////////////////////////////////////////////////////
//
//  IInternetProtocolInfo Implementation
//


//	Override the BaseURL
//
STDMETHODIMP CDHTMLEdProtocolInfo::CombineUrl
(
    LPCWSTR     pwzBaseURL,
    LPCWSTR     pwzRelativeURL,
    DWORD       /*dwFlags*/,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       /*dwReserved*/
)
{
	_ASSERTE ( m_pProxyFrame );

	CComBSTR bstrBaseURL;
#ifdef LATE_BIND_URLMON_WININET
	PFNCoInternetCombineUrl pfnCoInternetCombineUrl = m_pProxyFrame->m_pfnCoInternetCombineUrl;
#endif // LATE_BIND_URLMON_WININET

	ExpectedExpr((!m_fZombied));
	InitParam(pcchResult);
	IfNullGo(pwzBaseURL);
	IfNullGo(pwzRelativeURL);
	IfNullGo(pwzResult);
	IfNullGo(pcchResult);

	ATLTRACE(_T("CDHTMLEdProtocolInfo::CombineUrl(%ls,%ls)\n"), pwzBaseURL, pwzRelativeURL);

	HRESULT hr;
	_ASSERTE ( m_pProxyFrame );
	IfNullGo(m_pProxyFrame);

	// GetBaseURL returns the value of the control's BaseURL property.  The pwzBaseURL parameter is ignored.
	hr = m_pProxyFrame->GetBaseURL(bstrBaseURL);
	_IfFailGo(hr);

	// Handle case where return buffer is too small
	*pcchResult  = bstrBaseURL.Length () + 1;
	if(*pcchResult > cchResult)
	{
		return S_FALSE;
	}

	// combine with our base url
#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( pfnCoInternetCombineUrl );
    hr = (*pfnCoInternetCombineUrl) ( bstrBaseURL, pwzRelativeURL, ICU_ESCAPE, pwzResult, cchResult, pcchResult, 0 );
#else
    hr = CoInternetCombineUrl ( bstrBaseURL, pwzRelativeURL, ICU_ESCAPE, pwzResult, cchResult, pcchResult, 0 );
#endif // LATE_BIND_URLMON_WININET

	IfFailGo(hr);

	if ( S_OK == hr )
		ATLTRACE(_T("CDHTMLEdProtocolInfo::CombinUrl to %ls\n"), pwzResult);

	return hr;

ONERROR:
	return INET_E_DEFAULT_ACTION;
}


STDMETHODIMP CDHTMLEdProtocolInfo::CompareUrl
(
    LPCWSTR     /*pwzUrl1*/,
    LPCWSTR     /*pwzUrl2*/,
    DWORD       /*dwFlags*/
)
{
	ExpectedExpr((!m_fZombied));
    return E_NOTIMPL;
}


//	Override the security URL.  See comments at top of file.
//
STDMETHODIMP CDHTMLEdProtocolInfo::ParseUrl
(
    LPCWSTR     pwzURL,
    PARSEACTION ParseAction,
    DWORD       /*dwFlags*/,
    LPWSTR      pwzResult,
    DWORD       cchResult,
    DWORD *     pcchResult,
    DWORD       /*dwReserved*/
)
{
	ExpectedExpr((!m_fZombied));
	IfNullRet(pwzURL);
	InitParam(pcchResult);

	ATLTRACE(_T("CDHTMLEdProtocolInfo::ParseUrl(%d, %ls)\n"), (int)ParseAction, pwzURL);

	HRESULT hr;

	switch(ParseAction)
	{
		case PARSE_SECURITY_URL:
		{
			_ASSERTE(m_pProxyFrame != NULL);

			if(m_pProxyFrame != NULL)
			{
				CComBSTR bstrSecurityURL;

				hr = m_pProxyFrame->GetSecurityURL(bstrSecurityURL);

				if(SUCCEEDED(hr))
				{
					// set out param
					*pcchResult = bstrSecurityURL.Length () + 1;

					if(*pcchResult <= cchResult)
					{
						// copy result
						wcscpy(pwzResult, bstrSecurityURL);

						ATLTRACE(_T("CDHTMLEdProtocolInfo::ParseUrl(%ls)\n"), pwzResult);

						return NOERROR;
					}
					else
						return S_FALSE; // buffer too small
				}
			}
		}
		break;

		case PARSE_CANONICALIZE:
		case PARSE_FRIENDLY:
		case PARSE_DOCUMENT:
		case PARSE_PATH_FROM_URL:
		case PARSE_URL_FROM_PATH:
		case PARSE_ROOTDOCUMENT:
		case PARSE_ANCHOR:
		case PARSE_ENCODE:
		case PARSE_DECODE:
		case PARSE_MIME:
		case PARSE_SERVER:
		case PARSE_SCHEMA:
		case PARSE_SITE:
		case PARSE_DOMAIN:
		case PARSE_LOCATION:
		case PARSE_SECURITY_DOMAIN:
		default:
    		return INET_E_DEFAULT_ACTION;
	}

    return INET_E_DEFAULT_ACTION;
}

STDMETHODIMP CDHTMLEdProtocolInfo::QueryInfo
(
    LPCWSTR         /*pwzURL*/,
    QUERYOPTION     QueryOption,
    DWORD           /*dwQueryFlags*/,
    LPVOID          pBuffer,
    DWORD           /*cbBuffer*/,
    DWORD *         pcbBuf,
    DWORD           /*dwReserved*/
)
{
	ExpectedExpr((!m_fZombied));
	InitParam(pcbBuf);
	IfNullRet(pBuffer);
	IfNullRet(pcbBuf);

	switch(QueryOption)
	{
		case QUERY_CONTENT_TYPE:
		case QUERY_EXPIRATION_DATE:
		case QUERY_TIME_OF_LAST_CHANGE:
		case QUERY_CONTENT_ENCODING:
		case QUERY_REFRESH:
		case QUERY_RECOMBINE:
		case QUERY_CAN_NAVIGATE:
		default:
			break;
	}

    return INET_E_DEFAULT_ACTION;
}


//	This type of strong coupling should normally be avoided, but it was
//	fast, simple, and safe in this case.
//
STDMETHODIMP CDHTMLEdProtocolInfo::SetProxyFrame ( SIZE_T* vpProxyFrame )
{
	m_pProxyFrame = (CProxyFrame*)vpProxyFrame;
	if ( NULL != m_piProtocolConIntf )
	{
		m_piProtocolConIntf->SetProxyFrame ( vpProxyFrame );
	}
	return S_OK;
}


STDMETHODIMP CDHTMLEdProtocol::SetProxyFrame ( SIZE_T* vpProxyFrame )
{
	m_pProxyFrame = (CProxyFrame*)vpProxyFrame;
	return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  DHTMLEd Protocol Implementaion
//


CDHTMLEdProtocol::CDHTMLEdProtocol()
{
	ATLTRACE(_T("CDHTMLEdProtocol::CDHTMLEdProtocol\n"));

	m_fZombied = FALSE;
	m_fAborted = FALSE;
    m_bscf = BSCF_FIRSTDATANOTIFICATION;
	m_pProxyFrame = NULL;

}


CDHTMLEdProtocol::~CDHTMLEdProtocol()
{
	ATLTRACE(_T("CDHTMLEdProtocol::~CDHTMLEdProtocol\n"));
	Zombie();
}


void CDHTMLEdProtocol::Zombie()
{
	m_fZombied = TRUE;
	m_srpSink.Release();
	m_srpBindInfo.Release();
	m_srpStream.Release();
	m_bstrBaseURL.Empty();
}


/*

    HRESULT ParseAndBind

    Description:
		Gets the stream from the control and begins returning data to IE.

*/
HRESULT CDHTMLEdProtocol::ParseAndBind()
{
	HRESULT hr;
	STATSTG sstg = {0};

	_ASSERTE(m_bstrBaseURL != NULL);
	_ASSERTE(m_srpStream == NULL);

	hr = m_pProxyFrame->GetFilteredStream(&m_srpStream);

	IfFailGo(hr);
	IfNullPtrGo(m_srpStream);

	// Read in size of the stream

	hr = m_srpStream->Stat(&sstg, STATFLAG_NONAME);
	IfFailGo(hr);

// fall through

ONERROR:

	if(!m_fAborted)
	{
		// Report Data to sink
		if(m_srpSink != NULL)
		{
			DWORD bscf = m_bscf | BSCF_DATAFULLYAVAILABLE | BSCF_LASTDATANOTIFICATION;

			// Specify mime / type as HTML
			m_srpSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, L"text/html");

			// Report size of data
			ATLTRACE(_T("CDHTMLEdProtocol::ParseAndBind(%d bytes)\n"), sstg.cbSize.LowPart);
			m_srpSink->ReportData(bscf, sstg.cbSize.LowPart, sstg.cbSize.LowPart);

			// Report result should be called only when all data have been read by consumer
			// IE4 accepts ReportResult() here while IE5 does not. This is because IE4 queues
			// the report while IE5 executes it immediatetely, terminating the VID protocol.
			// See VID bug #18128 for additional details.
			//if(m_srpSink != NULL)
			//{
			//	m_srpSink->ReportResult(hr, 0, 0);  DO NOT DO THIS!
			//}
		}
	}
    return hr;
}


/*

    void ReportData

    Description:
        Report to sink data is fully available

*/
void CDHTMLEdProtocol::ReportData(ULONG cb)
{
    m_bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;

	if(m_srpSink != NULL)
	{
    	m_srpSink->ReportData(m_bscf, cb, cb);
	}
}


//////////////////////////////////////////////////////////////////////////////
//
//  IInternetProtocol Implementation
//


STDMETHODIMP CDHTMLEdProtocol::LockRequest(DWORD /*dwOptions*/)
{
	ExpectedExpr((!m_fZombied));
    return S_OK;
}


STDMETHODIMP CDHTMLEdProtocol::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Read(%ls) %d bytes\n"), m_bstrBaseURL ? m_bstrBaseURL : L"(null)", cb);

	if(m_fZombied)
		return S_FALSE;

	_ASSERTE(m_srpStream != NULL);
	if(m_srpStream == NULL)
		return INET_E_DOWNLOAD_FAILURE;

	HRESULT hr;

	hr = m_srpStream->Read(pv, cb, pcbRead);
	_ASSERTE(SUCCEEDED(hr));

	if(FAILED(hr))
		return INET_E_DOWNLOAD_FAILURE;

	ATLTRACE(_T("CDHTMLEdProtocol::Read returning hr=%08X %d bytes read\n"), ((*pcbRead) ? hr : S_FALSE), *pcbRead);

	if(*pcbRead)
		return hr;
	else
	{
		// Tell the sink that I am done reading.
		m_srpSink->ReportResult(S_FALSE, 0, 0);
		return S_FALSE;
	}
}


STDMETHODIMP CDHTMLEdProtocol::Seek
(
    LARGE_INTEGER 	dlibMove,
    DWORD 			dwOrigin,
    ULARGE_INTEGER 	*plibNewPosition
)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Seek(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));
	ExpectedPtr(m_srpStream);

	HRESULT hr;

	// Do the seek

    hr = m_srpStream->Seek(dlibMove, dwOrigin, plibNewPosition);
	IfFailRet(hr);

	return hr;
}


STDMETHODIMP CDHTMLEdProtocol::UnlockRequest()
{
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
//
//  IInternetProtocolRoot Implementation
//


STDMETHODIMP CDHTMLEdProtocol::Start
(
    LPCWSTR 				pwzURL,
    IInternetProtocolSink 	*pSink,
    IInternetBindInfo 		*pBindInfo,
    DWORD 					grfSTI,
    HANDLE_PTR				/*dwReserved*/
)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Start(%ls)\n"), pwzURL);
	_ASSERTE ( m_pProxyFrame );

#ifdef LATE_BIND_URLMON_WININET
	PFNCoInternetParseUrl pfnCoInternetParseUrl = m_pProxyFrame->m_pfnCoInternetParseUrl;
#endif // LATE_BIND_URLMON_WININET

	ExpectedExpr((!m_fZombied));
	IfNullRet(pwzURL);
	IfNullRet(pBindInfo);
	IfNullRet(pSink);

    HRESULT         hr;
    WCHAR           wch[INTERNET_MAX_URL_LENGTH];
    DWORD           dwSize;

	_ASSERTE(m_srpSink == NULL);
	_ASSERTE(m_bstrBaseURL == NULL);

    if( !(grfSTI & PI_PARSE_URL))
    {
		m_srpSink.Release();
		m_srpSink = pSink;

		m_srpBindInfo.Release();
		m_srpBindInfo = pBindInfo;
    }

    m_bindinfo.cbSize = sizeof(BINDINFO);
    hr = pBindInfo->GetBindInfo(&m_grfBindF, &m_bindinfo);
	IfFailGo(hr);

	ATLTRACE(_T("CDHTMLEdProtocol::BINDF                    =%08X\n"), 	m_grfBindF);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.szExtraInfo     =%ls\n"), 	m_bindinfo.szExtraInfo ? m_bindinfo.szExtraInfo : L"(null)");
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.grfBindInfoF    =%08X\n"), 	m_bindinfo.grfBindInfoF);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwBindVerb      =%08X\n"), 	m_bindinfo.dwBindVerb);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.szCustomVerb    =%ls\n"),   	m_bindinfo.szCustomVerb ? m_bindinfo.szCustomVerb : L"(null)");
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.cbstgmedData    =%08X\n"), 	m_bindinfo.cbstgmedData);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwOptions       =%08X\n"), 	m_bindinfo.dwOptions);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwOptionsFlags  =%08X\n"), 	m_bindinfo.dwOptionsFlags);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwCodePage      =%08X\n"), 	m_bindinfo.dwCodePage);
	ATLTRACE(_T("CDHTMLEdProtocol::BindInfo.dwReserved      =%08X\n"), 	m_bindinfo.dwReserved);

    //
    // First get the basic url.  Unescape it first.
    //

#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( pfnCoInternetParseUrl );
    hr = (*pfnCoInternetParseUrl)( pwzURL, PARSE_ENCODE, 0, wch, dimensionof(wch), &dwSize, 0 );
#else
    hr = CoInternetParseUrl ( pwzURL, PARSE_ENCODE, 0, wch, dimensionof(wch), &dwSize, 0 );
#endif // LATE_BIND_URLMON_WININET

	IfFailGo(hr);

	m_bstrBaseURL = wch;
	IfNullPtrGo(m_bstrBaseURL.m_str);

    //
    // Now append any extra data if needed.
    //

    if (m_bindinfo.szExtraInfo)
    {
		m_bstrBaseURL.Append(m_bindinfo.szExtraInfo);
		IfNullPtrGo(m_bstrBaseURL.m_str);
    }

    m_grfSTI = grfSTI;

    //
    // If forced to go async, return E_PENDING now, and
    // perform binding when we get the Continue.
    //

    if (grfSTI & PI_FORCE_ASYNC)
    {
        PROTOCOLDATA    protdata;

        hr = E_PENDING;
        protdata.grfFlags = PI_FORCE_ASYNC;
        protdata.dwState = BIND_ASYNC;
        protdata.pData = NULL;
        protdata.cbData = 0;

        m_srpSink->Switch(&protdata);
    }
    else
    {
        hr = ParseAndBind();
		IfFailGo(hr);
    }

	return hr;

ONERROR:
    return hr;
}


STDMETHODIMP CDHTMLEdProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Continue(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));
	IfNullRet(pStateInfoIn);

    HRESULT hr = E_FAIL;

	_ASSERTE(pStateInfoIn->pData != NULL);
	_ASSERTE(pStateInfoIn->cbData != 0);
	_ASSERTE(pStateInfoIn->dwState == (DWORD) BIND_ASYNC);

    if(pStateInfoIn->dwState == BIND_ASYNC)
    {
        hr =  ParseAndBind();
    }

    return hr;
}


STDMETHODIMP CDHTMLEdProtocol::Abort(HRESULT /*hrReason*/, DWORD /*dwOptions*/)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Abort(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));

    m_fAborted = TRUE;

	ExpectedPtr(m_srpSink);

    return m_srpSink->ReportResult(E_ABORT, 0, 0);
}


STDMETHODIMP CDHTMLEdProtocol::Terminate(DWORD dwOptions)
{
	ATLTRACE(_T("CDHTMLEdProtocol::Terminate(%08X, %ls)\n"), dwOptions, m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));

    if (m_bindinfo.stgmedData.tymed != TYMED_NULL)
    {
        ::ReleaseStgMedium(&(m_bindinfo.stgmedData));
        m_bindinfo.stgmedData.tymed = TYMED_NULL;
    }

    if (m_bindinfo.szExtraInfo)
    {
        ::CoTaskMemFree(m_bindinfo.szExtraInfo);
        m_bindinfo.szExtraInfo = NULL;
    }

	Zombie();

    return NOERROR;
}


STDMETHODIMP CDHTMLEdProtocol::Suspend()
{
	ATLTRACE(_T("CDHTMLEdProtocol::Suspend(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));
    return E_NOTIMPL;
}


STDMETHODIMP CDHTMLEdProtocol::Resume()
{
	ATLTRACE(_T("CDHTMLEdProtocol::Resume(%ls)\n"), m_bstrBaseURL);

	ExpectedExpr((!m_fZombied));
    return E_NOTIMPL;
}

/* end of file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
// Used by DHTMLEd.rc
//
#define IDB_TOOLBOX                     1
#define IDB_TOOLBOX_Safe                2
#define IDS_PROJNAME                    100
#define IDR_DHTMLEDIT                   101
#define IDR_DEINSERTTABLEPARAM          102
#define IDR_DEGETBLOCKFMTNAMESPARAM     103
#define IDR_DHTMLSafe                   202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\proxyframe.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef _proxyframe_h_
#define _proxyframe_h_

#include <docobj.h>
#include <ocidl.h>
#include <WinINet.h>
#include "plgprot.h"
#include "dhtmledit.h"

// This was given in email from Josh Kaplan to Steve Isaac in response
// to what command is necessary so that Trident won't clear the undo
// stack on setAttribute calls. The command takes a BOOL -- True == good behavior
#define IDM_GOOD_UNDO_BEHAVIOR 6049

typedef struct _CommandMap
{
	DHTMLEDITCMDID typeLibCmdID;
	ULONG cmdID;
	BOOL bOutParam;

} CommandMap;

#ifdef LATE_BIND_URLMON_WININET
typedef HRESULT (WINAPI *PFNCoInternetCombineUrl)(LPCWSTR,LPCWSTR,DWORD,LPWSTR,DWORD,DWORD*,DWORD);             
typedef HRESULT (WINAPI *PFNCoInternetParseUrl)(LPCWSTR,PARSEACTION,DWORD,LPWSTR,DWORD,DWORD*,DWORD);
typedef HRESULT (WINAPI *PFNCreateURLMoniker)(LPMONIKER,LPCWSTR,LPMONIKER FAR*);
typedef HRESULT (WINAPI *PFNCoInternetGetSession)(DWORD,IInternetSession**,DWORD);
typedef HRESULT (WINAPI *PFNURLOpenBlockingStream)(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);

typedef BOOL (WINAPI *PFNDeleteUrlCacheEntry)(LPCSTR);
typedef BOOL (WINAPI *PFNInternetCreateUrl)(LPURL_COMPONENTSA,DWORD,LPSTR,LPDWORD);
typedef BOOL (WINAPI *PFNInternetCrackURL)(LPCSTR,DWORD,DWORD,LPURL_COMPONENTSA);
#endif // LATE_BIND_URLMON_WININET



class CDHTMLEdProtocolInfo;
typedef CComObject<CDHTMLEdProtocolInfo> 	*PProtocolInfo;

class CDHTMLSafe;


typedef enum DENudgeDirection {
	deNudgeUp = 8000,
	deNudgeDown,
	deNudgeLeft,
	deNudgeRight,
};


class CProxyFrame : public IOleInPlaceFrame, public IOleCommandTarget,
	public IBindStatusCallback, public IAuthenticate
{
public:
		CProxyFrame(CDHTMLSafe* pCtl);
		~CProxyFrame();

		HRESULT Init(IUnknown* pUnk, IUnknown** ppUnkTriEdit);
		HRESULT PreActivate();
		HRESULT Activate();
		void    UIDeactivate();
		HRESULT Close();
		HRESULT LoadInitialDoc();
		HRESULT LoadDocument(BSTR path, BOOL bfIsURL = FALSE);
		HRESULT FilterSourceCode ( BSTR bsSourceIn, BSTR* pbsSourceOut );
		HRESULT Print( BOOL bfWithUI );
		HRESULT SaveDocument(BSTR path);
		HRESULT SetContextMenu(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates);
		HRESULT SetContextMenuSA(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates);
		HRESULT SetContextMenuDispEx(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates);
		HRESULT GetBrowseMode ( VARIANT_BOOL  *pVal );
		HRESULT SetBrowseMode ( VARIANT_BOOL  newVal );
		HRESULT GetDocumentTitle ( CComBSTR&  bstrTitle );
		HRESULT GetDivOnCr ( VARIANT_BOOL *pVal );
		HRESULT SetDivOnCr ( VARIANT_BOOL newVal );
		HRESULT GetBusy ( VARIANT_BOOL *pVal );
		HRESULT RefreshDoc ( void );

		HRESULT HrTridentSetPropBool(ULONG cmd, BOOL bVal);
		HRESULT HrTridentGetPropBool(ULONG cmd, BOOL& bVal);

		HRESULT HrMapCommand(DHTMLEDITCMDID typeLibCmdID, ULONG* cmdID, const GUID** ppguidCmdGroup, BOOL* bpInParam);
		HRESULT HrExecCommand(const GUID* pguidCmdGroup, ULONG ucmdID, OLECMDEXECOPT cmdexecopt, VARIANT* pVarIn, VARIANT* pVarOut);
		HRESULT HrMapExecCommand(DHTMLEDITCMDID deCommand, OLECMDEXECOPT cmdexecopt, VARIANT* pVarIn, VARIANT* pVarOut);
		HRESULT HrExecGenericCommands(const GUID* pguidCmdGroup, ULONG cmdID, OLECMDEXECOPT cmdexecopt, LPVARIANT pVarInput, BOOL bOutParam);
		HRESULT HrExecGetBlockFmtNames(LPVARIANT pVarInput);
		HRESULT HrExecInsertTable(LPVARIANT pVarInput);
		HRESULT HrExecGetColor(DHTMLEDITCMDID deCommand, ULONG ulMappedCommand, LPVARIANT pVarOutput);
		HRESULT HrExecSetFontSize(LPVARIANT pVarInput);

		HRESULT HrQueryStatus(const GUID* pguidCmdGroup, ULONG ucmdID, OLECMDF* cmdf);
		HRESULT HrMapQueryStatus( DHTMLEDITCMDID ucmdID, DHTMLEDITCMDF* cmdf);

		HRESULT HrGetDoc(IHTMLDocument2 **ppDoc);
		HRESULT HrGetTableSafeArray(IDEInsertTableParam* pTable, LPVARIANT pVarIn);

		HRESULT HrTranslateAccelerator(LPMSG lpmsg);
		HRESULT HrHandleAccelerator(LPMSG lpmsg);
		HRESULT HrNudge(DENudgeDirection dir);
		HRESULT HrToggleAbsolutePositioned();
		HRESULT HrHyperLink();
		HRESULT HrIncreaseIndent();
		HRESULT HrDecreaseIndent();

		void UpdateObjectRects(void);
		void SetParent ( HWND hwndControl );
		void Show ( WPARAM nCmdShow );
		LRESULT OnSetFocus(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

		void OnReadyStateChanged(READYSTATE readyState);

		inline CDHTMLSafe* GetControl() {
			return m_pCtl;
		};

		inline BOOL IsCreated() {
			return m_fCreated;
		};

		inline BOOL IsActivated() {
			return m_fActivated;
		};

		inline SAFEARRAY* GetMenuStrings() {
			return m_pMenuStrings;
		};

		inline SAFEARRAY* GetMenuStates() {
			return m_pMenuStates;
		};

		HRESULT GetContainer ( LPOLECONTAINER* ppContainer );

		HRESULT GetCurDocNameWOPath ( CComBSTR& bstrDocName );
		HRESULT GetBaseURL ( CComBSTR& bstrBaseURL );
		HRESULT SetBaseURL ( CComBSTR& bstrBaseURL );
		HRESULT GetFilteredStream ( IStream** ppStream );
		HRESULT GetSecurityURL (CComBSTR& bstrSecurityURL );

protected:

		HRESULT HrSetRuntimeProperties();
		HRESULT HrSetDocLoadedProperties();
		HRESULT SetBaseURLFromBaseHref ( void );
		HRESULT SetBaseURLFromCurDocPath ( BOOL bfIsURL );
		HRESULT SetBaseURLFromURL ( const CComBSTR& bstrURL );
		HRESULT SetBaseURLFromFileName ( const CComBSTR& bstrFName );
		HRESULT SetBaseUrlFromFileUrlComponents ( URL_COMPONENTS & urlc );
		HRESULT SetBaseUrlFromUrlComponents ( URL_COMPONENTS & urlc );

		typedef enum TriEditState {
			ESTATE_NOTCREATED = 0,
			ESTATE_CREATED,
			ESTATE_PREACTIVATING,
			ESTATE_ACTIVATING,
			ESTATE_ACTIVATED,
		} TriEditState;

		void ChangeState(TriEditState state) { m_state = state; }
		inline TriEditState GetState() { return m_state; }

		HRESULT GetSelectionPos ( LPPOINT lpWhere );

public: // properties

		HRESULT HrSetPropActivateControls(BOOL activateControls);
		HRESULT HrGetPropActivateControls(BOOL& activateControls);

		HRESULT HrSetPropActivateApplets(BOOL activateApplets);
		HRESULT HrGetPropActivateApplets(BOOL& activateApplets);

		HRESULT HrSetPropActivateDTCs(BOOL activateDTCs);
		HRESULT HrGetPropActivateDTCs(BOOL& activateDTCs);

		HRESULT HrSetPropShowAllTags(BOOL showAllTags);
		HRESULT HrGetPropShowAllTags(BOOL& showAllTags);

		HRESULT HrSetPropShowBorders(BOOL showBorders);
		HRESULT HrGetPropShowBorders(BOOL& showBorders);

		HRESULT HrSetDisplay3D(BOOL bVal);
		HRESULT HrGetDisplay3D(BOOL& bVal);

		HRESULT HrSetScrollbars(BOOL bVal);
		HRESULT HrGetScrollbars(BOOL& bVal);

		HRESULT HrSetDisplayFlatScrollbars(BOOL bVal);
		HRESULT HrGetDisplayFlatScrollbars(BOOL& bVal);

		HRESULT HrSetDocumentHTML(BSTR bVal);
		HRESULT HrGetDocumentHTML(BSTR* bVal);

		HRESULT HrSetPreserveSource(BOOL bVal);
		HRESULT HrGetPreserveSource(BOOL& bVal);

		HRESULT HrSetAbsoluteDropMode(BOOL dropMode);
		HRESULT HrGetAbsoluteDropMode(BOOL& dropMode);

		HRESULT HrSetSnapToGrid(BOOL snapToGrid);
		HRESULT HrGetSnapToGrid(BOOL& snapToGrid);

		HRESULT HrSetSnapToGridX(LONG snapToGridX);
		HRESULT HrGetSnapToGridX(LONG& snapToGridX);

		HRESULT HrSetSnapToGridY(LONG snapToGridY);
		HRESULT HrGetSnapToGridY(LONG& snapToGridY);

		HRESULT HrGetIsDirty(BOOL& bVal);

		HRESULT HrGetCurrentDocumentPath(BSTR* bVal);

		// IBindStatusCallback trivial implementation, for synchronous transfer ONLY:
		STDMETHOD(GetBindInfo)(DWORD*,BINDINFO*) { return E_NOTIMPL; }
		STDMETHOD(OnStartBinding)(DWORD, IBinding*) { return S_OK; }
		STDMETHOD(GetPriority)(LONG *pnPriority) { *pnPriority = THREAD_PRIORITY_NORMAL; return S_OK; }
		STDMETHOD(OnProgress)(ULONG, ULONG, ULONG, LPCWSTR);
		STDMETHOD(OnDataAvailable)(DWORD, DWORD, FORMATETC*, STGMEDIUM*) { return E_NOTIMPL; }
		STDMETHOD(OnObjectAvailable)(REFIID, IUnknown*) { return E_NOTIMPL; }
		STDMETHOD(OnLowResource)(DWORD) { return E_NOTIMPL; }
		STDMETHOD(OnStopBinding)(HRESULT, LPCWSTR) { return S_OK; }

		// IAuthenticate
		STDMETHOD(Authenticate)(HWND *phwnd, LPWSTR *pszUserName, LPWSTR *pszPassword)
		{ *phwnd = m_hWndObj; *pszUserName = NULL; *pszPassword = NULL; return S_OK; }

public:
		//Shared IUnknown implementation
        STDMETHODIMP         QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		//IOleInPlaceFrame implementation
        STDMETHODIMP         GetWindow(HWND *);
        STDMETHODIMP         ContextSensitiveHelp(BOOL);
        STDMETHODIMP         GetBorder(LPRECT);
        STDMETHODIMP         RequestBorderSpace(LPCBORDERWIDTHS);
        STDMETHODIMP         SetBorderSpace(LPCBORDERWIDTHS);
        STDMETHODIMP         SetActiveObject(LPOLEINPLACEACTIVEOBJECT
                                 , LPCOLESTR);
        STDMETHODIMP         InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
        STDMETHODIMP         SetMenu(HMENU, HOLEMENU, HWND);
        STDMETHODIMP         RemoveMenus(HMENU);
        STDMETHODIMP         SetStatusText(LPCOLESTR);
        STDMETHODIMP         EnableModeless(BOOL);
        STDMETHODIMP         TranslateAccelerator(LPMSG, WORD);

		//IOleCommandTarget
        STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds
            , OLECMD prgCmds[], OLECMDTEXT *pCmdText);
        
        STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID
            , DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

		HRESULT OnTriEditEvent ( const GUID& iidEventInterface, DISPID dispid );	

		HWND	GetDocWindow () { return m_hWndObj; }
		HRESULT GetScrollPos ( LPPOINT lpPos );
		HRESULT CheckCrossZoneSecurity ( BSTR url );
		HRESULT	CheckCrossZoneSecurityOfSelection ( void );
		void	ClearSFSRedirect ( void ) { m_bfSFSRedirect = FALSE; }
		BOOL	GetSFSRedirect ( void ) { return m_bfSFSRedirect; }

		void	ClearLoadingFlag ( void ) { m_bfIsLoading = FALSE; }

private:
		HRESULT RegisterPluggableProtocol ( void );
		HRESULT UnRegisterPluggableProtocol ( void );
		HRESULT LoadBSTRDeferred ( BSTR bVal );
		void AssureActivated ( void );
		WCHAR* GetInitialHTML ( void );
		void InitializeDocString ( void ) { m_bstrInitialDoc = GetInitialHTML (); }
		BOOL IsMissingBackSlash ( BSTR path, BOOL bfIsURL );
		HRESULT SetDirtyFlag ( BOOL bfMakeDirty );
#ifdef LATE_BIND_URLMON_WININET
		BOOL DynLoadLibraries ( void );
		void DynUnloadLibraries ( void );
#endif // LATE_BIND_URLMON_WININET

private:

        ULONG           m_cRef;
		TriEditState	m_state;

		class CDHTMLSafe*m_pCtl; // back pointer to control
        class CSite*	m_pSite;  // Site holding object        

		BOOL			m_fCreated;
		BOOL			m_fActivated;
		LPUNKNOWN		m_pUnkTriEdit;
        IOleInPlaceActiveObject *m_pIOleIPActiveObject;
		HWND			m_hWndObj;			// Trident's window

		READYSTATE		m_readyState;

		DWORD			m_dwFilterFlags;	// Flags to use for the next filter in
		DWORD			m_dwFilterOutFlags;	// Flags used on the last filter out

		SAFEARRAY*		m_pMenuStrings;
		SAFEARRAY*		m_pMenuStates;

		BOOL m_fActivateApplets;			// takes affect at init only
		BOOL m_fActivateControls;		// takes affect at init only
		BOOL m_fActivateDTCs;			// takes affect at init only

		BOOL m_fShowAllTags;				// can be set anytime
		BOOL m_fShowBorders;				// can be set anytime

		BOOL m_fDialogEditing;				// takes affect at init only
		BOOL m_fDisplay3D;					// takes affect at init only
		BOOL m_fScrollbars;					// takes affect at init only
		BOOL m_fDisplayFlatScrollbars;		// takes affect at init only
		BOOL m_fContextMenu;				// takes affect at init only

		BOOL m_fPreserveSource;			// takes affect at init only

		BOOL m_fAbsoluteDropMode;
		BOOL m_fSnapToGrid;
		LONG m_ulSnapToGridX;
		LONG m_ulSnapToGridY;

		CComBSTR m_bstrInitialDoc;
		CComBSTR m_bstrCurDocPath;
		CComBSTR m_bstrBaseURL;
		VARIANT_BOOL	m_vbBrowseMode;
		PProtocolInfo	m_pProtInfo;
		WCHAR	m_wszProtocol[16];
		WCHAR	m_wszProtocolPrefix[16];
		BOOL	m_bfIsURL;
		CComBSTR	m_bstrLoadText;
		HWND	m_hwndRestoreFocus;
		VARIANT_BOOL	m_vbUseDivOnCr;
		BOOL	m_bfIsLoading;
		BOOL	m_bfBaseURLFromBASETag;
		BOOL	m_bfPreserveDirtyFlagAcrossBrowseMode;
		HRESULT	m_hrDeferredLoadError;

		BOOL	m_bfModeSwitched;
		BOOL	m_bfReloadAttempted;
		BOOL	m_bfSFSRedirect;

#ifdef LATE_BIND_URLMON_WININET
		HMODULE						m_hUlrMon;
		HMODULE						m_hWinINet;

public:
		PFNCoInternetCombineUrl		m_pfnCoInternetCombineUrl;
		PFNCoInternetParseUrl		m_pfnCoInternetParseUrl;
		PFNCreateURLMoniker			m_pfnCreateURLMoniker;
		PFNCoInternetGetSession		m_pfnCoInternetGetSession;
		PFNURLOpenBlockingStream	m_pfnURLOpenBlockingStream;

		PFNDeleteUrlCacheEntry		m_pfnDeleteUrlCacheEntry;
		PFNInternetCreateUrl		m_pfnInternetCreateUrl;
		PFNInternetCrackURL			m_pfnInternetCrackUrl;
#endif // LATE_BIND_URLMON_WININET
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\site.cpp ===
//
// SITE.CPP
// Document Object Site Object
//
// Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
//

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "proxyframe.h"
#include "site.h"
#include <urlmon.h>
#include "triedsnk.h"
#include "private.h"

/*
 * CSite::CSite
 * CSite::~CSite
 *
 * Constructor Parameters:
 *  hWnd            HWND of the window associated with the site
 *  pFR             PCFrame to the parent structure.
 */
CSite::CSite(CProxyFrame* pFR )
{
    m_cRef						= 0;
    m_hWnd						= NULL;
    m_pFR						= pFR;
	m_dwPropNotifyCookie		= 0;
	m_dwOleObjectCookie			= 0;

    m_pObj						= NULL;
	m_bFiltered					= TRUE;//FALSE;
    
    m_pIOleObject				= NULL;
    m_pIOleIPObject				= NULL;
    m_pIOleDocView				= NULL;
	m_pIOleCommandTarget		= NULL;

    m_pImpIOleClientSite		= NULL;
    m_pImpIAdviseSink			= NULL;
    m_pImpIOleIPSite			= NULL;
    m_pImpIOleDocumentSite		= NULL;
	m_pImpIDocHostUIHandler		= NULL;
	m_pImpIDocHostShowUI		= NULL;
	m_pImpAmbientIDispatch		= NULL;
	m_pImpIPropertyNotifySink	= NULL;
	m_pImpIOleControlSite		= NULL;

	m_pTriEdDocEvtSink			= NULL;
	m_pTriEdWndEvtSink			= NULL;
	m_bfSaveAsUnicode			= FALSE;
	m_cpCodePage				= CP_ACP;
	m_piMLang					= NULL;
}


CSite::~CSite(void)
{
    //Object pointers cleaned up in Close.

    //We delete our own interfaces since we control them
    DeleteInterfaceImp( m_pImpIOleDocumentSite );
    DeleteInterfaceImp( m_pImpIOleIPSite );
    DeleteInterfaceImp( m_pImpIAdviseSink );
    DeleteInterfaceImp( m_pImpIOleClientSite );
	DeleteInterfaceImp( m_pImpIDocHostUIHandler );
	DeleteInterfaceImp( m_pImpIDocHostShowUI );
	DeleteInterfaceImp( m_pImpAmbientIDispatch);
	DeleteInterfaceImp( m_pImpIPropertyNotifySink);
	DeleteInterfaceImp( m_pImpIOleControlSite );

	if ( NULL != m_pTriEdDocEvtSink )
	{
		delete m_pTriEdDocEvtSink;
	}
	if ( NULL != m_pTriEdWndEvtSink )
	{
		delete m_pTriEdWndEvtSink;
	}
}


/*
 * CSite::QueryInterface
 * CSite::AddRef
 * CSite::Release
 *
 * Purpose:
 *  IUnknown members for CSite object.
 */
STDMETHODIMP CSite::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;

#ifdef _DEBUG
	OLECHAR wszGUID[39];
	StringFromGUID2(riid, wszGUID, 39);
	USES_CONVERSION;
	LPTSTR szGUID = OLE2T(wszGUID);
	OutputDebugString(_T("CSite::QI("));
	OutputDebugString(szGUID);
	OutputDebugString(_T(")\n"));
#endif

    if ( IID_IOleClientSite == riid )
	{
        *ppv = m_pImpIOleClientSite;
	}

    if ( IID_IAdviseSink == riid )
	{
        *ppv = m_pImpIAdviseSink;
	}

    if ( IID_IOleWindow == riid || IID_IOleInPlaceSite == riid )
	{
        *ppv = m_pImpIOleIPSite;
	}

    if ( IID_IOleDocumentSite == riid )
	{
        *ppv = m_pImpIOleDocumentSite;
	}

    if ( IID_IDocHostUIHandler == riid )
    {
        *ppv = m_pImpIDocHostUIHandler;
    }

    if ( IID_IDocHostShowUI == riid )
    {
        *ppv = m_pImpIDocHostShowUI;
    }

    if ( IID_IDispatch == riid )
    {
        *ppv = m_pImpAmbientIDispatch;
    }

    if ( IID_IPropertyNotifySink== riid )
    {
        *ppv = m_pImpIPropertyNotifySink;
    }

    if ( IID_IOleControlSite== riid )
    {
        *ppv = m_pImpIOleControlSite;
    }

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

	// Try the frame instead
	return GetFrame()->QueryInterface( riid, ppv );

}


STDMETHODIMP_(ULONG) CSite::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CSite::Release(void)
{
    if ( 0 != --m_cRef )
	{
        return m_cRef;
	}

    delete this;

    return 0;
}

/*
 * CSite::HrCreate
 *
 * Purpose:
 *  Asks the site to instantiate the MSHTML.DLL object.
 *  
 *
 * Parameters:
 *  pIStorage       IStorage * of the parent storage in which we're
 *                  to create an IStorage for the new object.
 *  pchPath         Path of what to load..
 *
 * Return Value:
 *  BOOL            Result of the creation.
 */
HRESULT CSite::HrCreate(IUnknown* pUnk, IUnknown** ppUnkTriEdit)
{
    HRESULT   hr = S_OK;

	_ASSERTE(NULL == m_pObj);

	if (m_pObj)
		return E_UNEXPECTED;

	// It is valid for pUnk and ppUnkTriEdit to be NULL

	// Create the site's interface implementations which MSHTML.DLL will call
    m_pImpIOleClientSite = new CImpIOleClientSite( this, this );
    m_pImpIAdviseSink = new CImpIAdviseSink( this, this );
    m_pImpIOleIPSite = new CImpIOleInPlaceSite( this, this );
    m_pImpIOleDocumentSite = new CImpIOleDocumentSite( this, this );
	m_pImpIDocHostUIHandler = new CImpIDocHostUIHandler( this, this );
	m_pImpIDocHostShowUI = new CImpIDocHostShowUI( this, this );
	m_pImpAmbientIDispatch = new CImpAmbientIDispatch( this, this );
	m_pImpIPropertyNotifySink = new CImplPropertyNotifySink( this, this );
	m_pImpIOleControlSite = new  CImpIOleControlSite ( this, this );

	m_pTriEdDocEvtSink = new CTriEditEventSink ( m_pFR, DIID_HTMLDocumentEvents );
	m_pTriEdWndEvtSink = new CTriEditEventSink ( m_pFR, DIID_HTMLWindowEvents );

    if ( NULL == m_pImpIOleClientSite
		|| NULL == m_pImpIAdviseSink
        || NULL == m_pImpIOleIPSite
		|| NULL == m_pImpIOleDocumentSite
		|| NULL == m_pImpIDocHostUIHandler 
		|| NULL == m_pImpAmbientIDispatch
		|| NULL == m_pImpIPropertyNotifySink
		|| NULL == m_pImpIOleControlSite
		|| NULL == m_pTriEdDocEvtSink
		|| NULL == m_pImpIOleControlSite
		)
	{
		// releasing the site will delete any of the interface
		// implementations that did get allocated
        return E_OUTOFMEMORY;
	}


	// Create TriEdit
	hr = CoCreateInstance( CLSID_TriEditDocument, pUnk,								
			CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&m_pObj );

    if (SUCCEEDED(hr))
	{
		if (ppUnkTriEdit)
		{
			m_pObj->AddRef();
			*ppUnkTriEdit = m_pObj;
		}
	}
	else if ( REGDB_E_CLASSNOTREG == hr )
	{
		DllUnregisterServer ();
	}

// RJ - 2/26/98
// defer call ObjectInitialize() until control has been created
// so that props for IDHUIHandler::GetHostInfo can be set by host. ObjectInitialize
// (really SetClientSite results in IDHUIHandler::GetHostInfo being called
#if 0 
	hr = ObjectInitialize();
#endif

	return hr;
}


/*
 * CSite::HrObjectInitialize
 * (Protected)
 *
 * Purpose:
 *  Creates DocObject object and cache frequently used interfaces
 *
 * Return Value:
 *  HRESULT indicating success or failure
 */
HRESULT CSite::HrObjectInitialize()
{
    HRESULT         hr;

	_ASSERTE(m_pObj);

    if (NULL == m_pObj)
	{
        return E_UNEXPECTED;
	}

    // cache IOleObject
    if (FAILED(hr = m_pObj->QueryInterface( IID_IOleObject, (void **)&m_pIOleObject )))
		return hr;

	_ASSERTE(m_pIOleObject);

    // SetClientSite is critical for DocObjects
    m_pIOleObject->SetClientSite( m_pImpIOleClientSite );

	_ASSERTE(0 == m_dwOleObjectCookie);
    m_pIOleObject->Advise(m_pImpIAdviseSink, &m_dwOleObjectCookie);

	// cache IOleCommandTarget
    if (FAILED(hr = m_pObj->QueryInterface( IID_IOleCommandTarget, (void **) &m_pIOleCommandTarget)))
		return hr;

	_ASSERTE(m_pIOleCommandTarget);

	if (FAILED(hr = HrRegisterPropNotifySink(TRUE)))
		return hr;

	// Hook up the proxy frame to the Trident Document events
	if (FAILED(hr = m_pTriEdDocEvtSink->Advise ( m_pIOleObject )))
		return hr;

	CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2>piHtmlDoc ( m_pIOleObject );
	_ASSERTE ( piHtmlDoc );
	if ( piHtmlDoc )
	{
		CComPtr<IHTMLWindow2>	piHtmlWindow = NULL;
		hr = piHtmlDoc->get_parentWindow ( &piHtmlWindow );
		if ( SUCCEEDED ( hr ) )
		{
			hr = m_pTriEdWndEvtSink->Advise ( piHtmlWindow );
		}
	}
	if ( FAILED ( hr ) )
		return hr;

	// Attempt to create the IMultiLanguage2 object, avaialable only with IE5.
	// It's OK if this fails.
	CoCreateInstance ( CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2Correct, (void**)&m_piMLang );

	// Put the object in the running state
	OleRun( m_pIOleObject );

    return hr;
}



/*
 * CSite::Close
 *
 * Purpose:
 *  Possibly commits the storage, then releases it, afterwards
 *  frees alls the object pointers.
 *
 * Parameters:
 *  fCommit         BOOL indicating if we're to commit.
 *
 * Return Value:
 *  None
 */
void CSite::Close(BOOL fCommit)
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pObj);

	hr = HrRegisterPropNotifySink(FALSE);

	_ASSERTE(SUCCEEDED(hr));

    if ( NULL != m_pIOleIPObject )
	{
        m_pIOleIPObject->InPlaceDeactivate();
	}

    ReleaseInterface( m_pIOleDocView );
	ReleaseInterface( m_pIOleCommandTarget );
	ReleaseInterface( m_piMLang );

    if ( NULL != m_pIOleObject )
    {
	    hr = m_pIOleObject->Unadvise(m_dwOleObjectCookie);
		_ASSERTE(SUCCEEDED(hr));

		m_pTriEdDocEvtSink->Unadvise ();
		m_pTriEdWndEvtSink->Unadvise ();

        m_pIOleObject->Close( fCommit ? OLECLOSE_SAVEIFDIRTY : OLECLOSE_NOSAVE );
        m_pIOleObject->SetClientSite( NULL );
        ReleaseInterface( m_pIOleObject );
    }

    ReleaseInterface( m_pObj );
}




/*
 * CSite::InitialActivate
 *
 * Purpose:
 *  Activates a verb on the object living in the site.
 *
 * Parameters:
 *  iVerb           LONG of the verb to execute.
 *  hWnd			HWND of hosting window
 *
 * Return Value:
 *  None
 */


void
CSite::InitialActivate(LONG iVerb, HWND hWnd)
{
	_ASSERTE(hWnd);

	m_hWnd = hWnd;
	Activate(iVerb);
}


void CSite::Activate(LONG iVerb)
{
    RECT rc = {0};

	// There is no window when we're being called to discard - (InPlaceDeactivate)
	if ( iVerb !=  OLEIVERB_DISCARDUNDOSTATE )
	{
		_ASSERTE(m_hWnd);
		GetClientRect(m_hWnd, &rc);
	}

    if (m_pIOleObject)
    {
        m_pIOleObject->DoVerb(iVerb, NULL, m_pImpIOleClientSite, -1, m_hWnd, &rc);
    }
}


/*
 * CSite::UpdateObjectRects
 *
 * Purpose:
 *  Informs the site that the client area window was resized and
 *  that the site needs to also tell the DocObject of the resize.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CSite::UpdateObjectRects( void )
{
    if ( NULL != m_pIOleDocView )
	{
		RECT    rc;
        
	    GetClientRect(m_hWnd, &rc);
		m_pIOleDocView->SetRect(&rc);
	}
}


void CSite::OnReadyStateChanged()
{
    HRESULT     hr = S_OK;
    VARIANT     Var;
    IDispatch * pDisp = NULL;
	CComDispatchDriver dispDriver;

    _ASSERTE(m_pObj);

    hr = m_pObj->QueryInterface(IID_IDispatch, (void **)&pDisp);

	_ASSERTE(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
	{	
		VariantInit(&Var);

		dispDriver = pDisp;

        if (SUCCEEDED(hr = dispDriver.GetProperty(DISPID_READYSTATE, &Var)))
		{
            // should be either I4 or I2
            _ASSERTE(Var.vt == VT_I4 || Var.vt == VT_I2);

            // we get the ready state so we can warn about sending while downloading
            GetFrame()->OnReadyStateChanged((READYSTATE) Var.lVal);
		}

		_ASSERTE(SUCCEEDED(hr));

        pDisp->Release();
	}
}


HRESULT 
CSite::HrRegisterPropNotifySink(BOOL fRegister)
{
    IConnectionPointContainer   *pCPContainer=0;
    IConnectionPoint            *pCP=0;
    HRESULT                     hr = S_OK;

	_ASSERTE(m_pObj);

    hr = m_pObj->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
    if (FAILED(hr))
        goto error;

    hr = pCPContainer->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
    if (FAILED(hr))
        goto error;

    if (fRegister)
	{
        _ASSERTE(m_dwPropNotifyCookie == 0);

        hr = pCP->Advise((IPropertyNotifySink *)this, &m_dwPropNotifyCookie);
        if (FAILED(hr))
            goto error;
	}
    else
	{
        if (m_dwPropNotifyCookie)
		{
            hr = pCP->Unadvise(m_dwPropNotifyCookie);
            if (FAILED(hr))
                goto error;
            m_dwPropNotifyCookie = 0;
		}
	}
error:
    ReleaseInterface(pCPContainer);
    ReleaseInterface(pCP);
    return hr;
}


HRESULT
CSite::HrSaveToStream(LPSTREAM pStream)
{
	HRESULT hr = S_OK;	
	CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> piPersistStreamInit(m_pObj);

	_ASSERTE(pStream);
	_ASSERTE(m_pObj);

	if (!piPersistStreamInit)
		return E_NOINTERFACE;

	if (FAILED(hr = piPersistStreamInit->Save(pStream, TRUE)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	// This can return an ASCII stream, even if we loaded Unicode into the control!
	hr = HrConvertStreamToUnicode ( pStream );

cleanup:
	return hr;
}


HRESULT
CSite::HrSaveToStreamAndFilter(LPSTREAM* ppStream, DWORD dwFilterFlags)
{
	HRESULT hr = S_OK;
	CComPtr<IStream> piStream;
	CComPtr<IStream> piFilteredStream;
	VARIANT_BOOL vbBrowse;

	_ASSERTE(ppStream);

	if (FAILED(hr = CreateStreamOnHGlobal(NULL, TRUE, &piStream)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (FAILED(hr = HrSaveToStream(piStream)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	m_pFR->GetBrowseMode ( &vbBrowse );
	if ( vbBrowse )
	{
		piStream->AddRef ();
		piFilteredStream = piStream;
	}
	else
	{
		hr = HrFilter(FALSE, piStream, &piFilteredStream, dwFilterFlags);
	}
	if (FAILED(hr))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	*ppStream = piFilteredStream;
	(*ppStream)->AddRef();

cleanup:
	return hr;
}


HRESULT
CSite::HrSaveToFile(BSTR fileName, DWORD dwFilterFlags)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	LPTSTR pFileName = NULL;
	CComPtr<IStream> piStream;

	_ASSERTE(fileName);

	pFileName = OLE2T(fileName);

	_ASSERTE(pFileName);

	if (NULL == pFileName)
		return E_OUTOFMEMORY;

	_ASSERTE(fileName);

	if (FAILED(hr = HrSaveToStreamAndFilter(&piStream, dwFilterFlags)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}
	
	if (FAILED(hr = HrStreamToFile(piStream, pFileName)))
	{
		goto cleanup;
	}


cleanup:
	return hr;
}


HRESULT
CSite::HrSaveToBstr(BSTR* pBstr, DWORD dwFilterFlags)
{
	HRESULT hr = S_OK;
	CComPtr<IStream> piStream;

	_ASSERTE(pBstr);

	if (FAILED(hr = HrSaveToStreamAndFilter(&piStream, dwFilterFlags)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}
	
	if (FAILED(hr = HrStreamToBstr(piStream, pBstr)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}


cleanup:
	return hr;
}


HRESULT
CSite::HrIsDirtyIPersistStreamInit(BOOL& bVal)
{
	HRESULT hr = S_OK;
	HRESULT hrpsi = S_FALSE;
	CComQIPtr<IPersistStreamInit, &IID_IPersistStreamInit> piPersistStreamInit(m_pObj);

	_ASSERTE(m_pObj);

	bVal = FALSE;

	if (!piPersistStreamInit)
		return E_NOINTERFACE;

	if (FAILED(hrpsi = piPersistStreamInit->IsDirty()))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	(S_OK == hrpsi) ? bVal = TRUE : bVal = FALSE;

cleanup:
	return hr;

}


HRESULT CSite::GetContainer ( LPOLECONTAINER* ppContainer )
{
	return m_pFR->GetContainer ( ppContainer );
}



/*
 * CImpIOleControlSite::QueryInterface
 * CImpIOleControlSite::AddRef
 * CImpIOleControlSite::Release
 *
 * Purpose:
 *  IUnknown members for CImpIOleControlSite object.
 */

CImpIOleControlSite::CImpIOleControlSite( PCSite pSite, LPUNKNOWN pUnkOuter )
{
    m_cRef = 0;
    m_pSite = pSite;
    m_pUnkOuter = pUnkOuter;
}

CImpIOleControlSite::~CImpIOleControlSite( void )
{
}


STDMETHODIMP CImpIOleControlSite::QueryInterface( REFIID riid, void **ppv )
{
    return m_pUnkOuter->QueryInterface( riid, ppv );
}


STDMETHODIMP_(ULONG) CImpIOleControlSite::AddRef( void )
{
    ++m_cRef;
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CImpIOleControlSite::Release( void )
{
    --m_cRef;
    return m_pUnkOuter->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\plgprot.h ===
/*

    File: PlgProt.h

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:
		DHTMLEd Pluggable Protocol

    History:
        06/26/97    Cgomes - ported from trident
		03/20/98	Vank   - ported from VID/htmed

*/
#if !defined __INC_PLGPROT_H__
#define __INC_PLGPRO_H__

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"
#include "dhtmled.h"
#include "proxyframe.h"
#include "private.h"

EXTERN_C const CLSID CLSID_DHTMLEdProtocolInfo;
EXTERN_C const CLSID CLSID_DHTMLEdProtocol;

#define BIND_ASYNC 1

#define ExpectedExpr(expr)		\
		_ASSERTE((expr));			\
		if(!(expr))					\
			{ return E_UNEXPECTED; }

#define ExpectedPtr(ptr)		\
		_ASSERTE(ptr != NULL);			\
		if(ptr == NULL)					\
			{ return E_UNEXPECTED; }

#define InitParam(param)				\
		if(param != NULL)				\
			{ *param = NULL; }

#define IfNullRet(param) 				\
		_ASSERTE(param != NULL);		\
		if(param == NULL)				\
			{ return E_INVALIDARG; }

#define IfNullGo(param) 				\
		_ASSERTE(param != NULL);		\
		if(param == NULL)				\
			{ goto ONERROR; }

#define IfFailGo(hr)							\
		_ASSERTE(SUCCEEDED(hr));				\
		if(FAILED(hr))							\
			goto ONERROR;

#define _IfFailGo(hr)							\
		if(FAILED(hr))							\
			goto ONERROR;

#define IfFailRet(hr)						\
		_ASSERTE(SUCCEEDED(hr));		\
		if(FAILED(hr)) 					\
			{ return hr; }

#define IfNullPtrGo(ptr)							\
		_ASSERTE(ptr != NULL);					\
		if(ptr == NULL)							\
		{ hr = E_POINTER; goto ONERROR;}

#define AtlCreateInstance(ClassName, iid, ppUnk) \
	{ \
		CComObject<ClassName> *pObject = NULL; \
		if(SUCCEEDED(CComObject<ClassName>::CreateInstance(&pObject)) && \
			pObject != NULL) \
		{ \
			if(FAILED(pObject->GetUnknown()->QueryInterface(iid, (void**) ppUnk))) \
			{ \
				*ppUnk = NULL; \
			} \
		} \
	}

#define dimensionof(a)  (sizeof(a)/sizeof(*(a)))


//////////////////////////////////////////////////////////////////////////////
//
// DHTMLEd ProtocolInfo class
//

class ATL_NO_VTABLE CDHTMLEdProtocolInfo :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IClassFactory,
	public IInternetProtocolInfo,
	public IProtocolInfoConnector
{
public:

//DECLARE_POLY_AGGREGATABLE(CDHTMLEdProtocolInfo)
//DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CDHTMLEdProtocolInfo)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IInternetProtocolInfo)
	COM_INTERFACE_ENTRY(IProtocolInfoConnector)
END_COM_MAP()

//
//  IClassFactory methods
//
    STDMETHODIMP CreateInstance(IUnknown * pUnkOuter, REFIID riid, void **ppvObject);
    STDMETHODIMP RemoteCreateInstance( REFIID riid, IUnknown ** ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);
    STDMETHODIMP RemoteLockServer(BOOL fLock);
//
//  IInternetProtocolInfo methods
//
    STDMETHODIMP CombineUrl(LPCWSTR     pwzBaseUrl,
                            LPCWSTR     pwzRelativeUrl,
                            DWORD       dwFlags,
                            LPWSTR      pwzResult,
                            DWORD       cchResult,
                            DWORD *     pcchResult,
                            DWORD       dwReserved);
    STDMETHODIMP CompareUrl(LPCWSTR     pwzUrl1,
                            LPCWSTR     pwzUrl2,
                            DWORD       dwFlags);
    STDMETHODIMP ParseUrl(LPCWSTR     pwzUrl,
                          PARSEACTION ParseAction,
                          DWORD       dwFlags,
                          LPWSTR      pwzResult,
                          DWORD       cchResult,
                          DWORD *     pcchResult,
                          DWORD       dwReserved);
    STDMETHODIMP QueryInfo(LPCWSTR         pwzUrl,
                           QUERYOPTION     QueryOption,
                           DWORD           dwQueryFlags,
                           LPVOID          pBuffer,
                           DWORD           cbBuffer,
                           DWORD *         pcbBuf,
                           DWORD           dwReserved);

	// IProtocolInfoConnector methods
	STDMETHODIMP SetProxyFrame ( SIZE_T* vpProxyFrame );
//
//  Data members
//
private:
	BOOL					m_fZombied:1;
	CProxyFrame*			m_pProxyFrame;
	IProtocolInfoConnector*	m_piProtocolConIntf;

//
//  constructor
//
public:
	CDHTMLEdProtocolInfo();
	~CDHTMLEdProtocolInfo();
	void Zombie();

#if defined _DEBUG_ADDREF_RELEASE
public:
	ULONG InternalAddRef()
	{
		ATLTRACE(_T("CDHTMLEdProtocolInfo Ref %d>\n"), m_dwRef+1);
		_ASSERTE(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		ATLTRACE(_T("CDHTMLEdProtocolInfo Ref %d<\n"), m_dwRef-1);
		return _ThreadModel::Decrement(&m_dwRef);
	}
#endif

};

//////////////////////////////////////////////////////////////////////////////
//
// DHTMLEd Protocol class
//

class ATL_NO_VTABLE CDHTMLEdProtocol :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDHTMLEdProtocol, &CLSID_DHTMLEdProtocol>,
	public IInternetProtocol,
	public IProtocolInfoConnector
{
public:

DECLARE_POLY_AGGREGATABLE(CDHTMLEdProtocol)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CDHTMLEdProtocol)
	COM_INTERFACE_ENTRY(IInternetProtocol)
	COM_INTERFACE_ENTRY(IProtocolInfoConnector)
END_COM_MAP()

//
//  IInternetProtocol methods
//
    STDMETHOD(LockRequest)(DWORD dwOptions);
    STDMETHOD(Read)(void *pv,ULONG cb,ULONG *pcbRead);
    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(UnlockRequest)();

//
//  IInternetProtocolRoot methods
//
    STDMETHOD(Abort)(HRESULT hrReason,DWORD dwOptions);
    STDMETHOD(Continue)(PROTOCOLDATA *pStateInfo);
    STDMETHOD(Resume)();
    STDMETHOD(Start)(LPCWSTR szUrl, IInternetProtocolSink *pProtSink, IInternetBindInfo *pOIBindInfo, DWORD grfSTI, HANDLE_PTR dwReserved);
    STDMETHOD(Suspend)();
    STDMETHOD(Terminate)(DWORD dwOptions);

	// IProtocolInfoConnector methods
	STDMETHODIMP SetProxyFrame ( SIZE_T* vpProxyFrame );
//
//  Data members
//
private:
    CComPtr<IInternetProtocolSink> 	m_srpSink; 			// The protocol sink
    CComPtr<IInternetBindInfo>     	m_srpBindInfo; 		// The Bind info
	CComPtr<IStream>				m_srpStream;		// Buffer Stream

	CComBSTR		m_bstrBaseURL;			// BaseURL of buffer
    DWORD 			m_bscf;
	DWORD			m_grfBindF;
	DWORD			m_grfSTI;
	BINDINFO		m_bindinfo;
	BOOL			m_fAborted:1;
	BOOL 			m_fZombied:1;
	CProxyFrame*	m_pProxyFrame;

//
//  constructor
//
public:
	CDHTMLEdProtocol();
	~CDHTMLEdProtocol();
	void Zombie();

//
//  Method members
//
private:
	HRESULT ParseAndBind();
	void 	ReportData(ULONG cb);

#if defined _DEBUG_ADDREF_RELEASE
public:
	ULONG InternalAddRef()
	{
		ATLTRACE(_T("CDHTMLEdProtocol Ref %d>\n"), m_dwRef+1);
		_ASSERTE(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		ATLTRACE(_T("CDHTMLEdProtocol Ref %d<\n"), m_dwRef-1);
		return _ThreadModel::Decrement(&m_dwRef);
	}
#endif
};

#endif __INC_PLGPRO_H__

/* end of file*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\site.h ===
/*
 * SITE.H
 * View Site for Document Objects.
 *
 * Copyright (c)1995-1999 Microsoft Corporation, All Rights Reserved
 */


#ifndef _SITE_H_
#define _SITE_H_

#include "stdafx.h"
#include "mlang.h"


class CProxyFrame;
class CTriEditEventSink;

class CImpIOleClientSite : public IOleClientSite
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleClientSite(class CSite *, IUnknown *);
        ~CImpIOleClientSite(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP SaveObject(void);
        STDMETHODIMP GetMoniker(DWORD, DWORD, LPMONIKER *);
        STDMETHODIMP GetContainer(LPOLECONTAINER *);
        STDMETHODIMP ShowObject(void);
        STDMETHODIMP OnShowWindow(BOOL);
        STDMETHODIMP RequestNewObjectLayout(void);
};

typedef CImpIOleClientSite *PCImpIOleClientSite;



class CImpIAdviseSink : public IAdviseSink
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIAdviseSink(class CSite *, IUnknown *);
        ~CImpIAdviseSink(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP_(void)  OnDataChange(LPFORMATETC, LPSTGMEDIUM);
        STDMETHODIMP_(void)  OnViewChange(DWORD, LONG);
        STDMETHODIMP_(void)  OnRename(LPMONIKER);
        STDMETHODIMP_(void)  OnSave(void);
        STDMETHODIMP_(void)  OnClose(void);
};


typedef CImpIAdviseSink *PCImpIAdviseSink;


class CImplPropertyNotifySink : public IPropertyNotifySink
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImplPropertyNotifySink(class CSite *, IUnknown *);
        ~CImplPropertyNotifySink(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP OnChanged(DISPID dispid);
        STDMETHODIMP OnRequestEdit (DISPID dispid);
};


typedef CImplPropertyNotifySink *PCImplPropertyNotifySink;


class CImpIOleInPlaceSite : public IOleInPlaceSite
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleInPlaceSite(class CSite *, IUnknown *);
        ~CImpIOleInPlaceSite(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetWindow(HWND *);
        STDMETHODIMP ContextSensitiveHelp(BOOL);
        STDMETHODIMP CanInPlaceActivate(void);
        STDMETHODIMP OnInPlaceActivate(void);
        STDMETHODIMP OnUIActivate(void);
        STDMETHODIMP GetWindowContext(LPOLEINPLACEFRAME *
                        , LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT
                        , LPOLEINPLACEFRAMEINFO);
        STDMETHODIMP Scroll(SIZE);
        STDMETHODIMP OnUIDeactivate(BOOL);
        STDMETHODIMP OnInPlaceDeactivate(void);
        STDMETHODIMP DiscardUndoState(void);
        STDMETHODIMP DeactivateAndUndo(void);
        STDMETHODIMP OnPosRectChange(LPCRECT);
};

typedef CImpIOleInPlaceSite *PCImpIOleInPlaceSite;


class CImpIOleDocumentSite : public IOleDocumentSite
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleDocumentSite(class CSite *, IUnknown *);
        ~CImpIOleDocumentSite(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP ActivateMe(IOleDocumentView *);
};

typedef CImpIOleDocumentSite *PCImpIOleDocumentSite;



///////////////////////////////////////////////////
// MSHTML.DLL host integration interfaces
///////////////////////////////////////////////////
class CImpIDocHostUIHandler : public IDocHostUIHandler
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIDocHostUIHandler(class CSite *, IUnknown *);
        ~CImpIDocHostUIHandler(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		STDMETHODIMP GetHostInfo(DOCHOSTUIINFO * pInfo);
		STDMETHODIMP ShowUI(
				DWORD dwID, 
				IOleInPlaceActiveObject * pActiveObject,
				IOleCommandTarget * pCommandTarget,
				IOleInPlaceFrame * pFrame,
				IOleInPlaceUIWindow * pDoc);
		STDMETHODIMP HideUI(void);
		STDMETHODIMP UpdateUI(void);
		STDMETHODIMP EnableModeless(BOOL fEnable);
		STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
		STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
		STDMETHODIMP ResizeBorder(
				LPCRECT prcBorder, 
				IOleInPlaceUIWindow * pUIWindow, 
				BOOL fRameWindow);
		STDMETHODIMP ShowContextMenu(
				DWORD dwID, 
				POINT * pptPosition,
				IUnknown* pCommandTarget,
				IDispatch * pDispatchObjectHit);
		STDMETHODIMP TranslateAccelerator(
            /* [in] */ LPMSG lpMsg,
            /* [in] */ const GUID __RPC_FAR *pguidCmdGroup,
            /* [in] */ DWORD nCmdID);
		STDMETHODIMP GetOptionKeyPath(BSTR* pbstrKey, DWORD dw);
		STDMETHODIMP GetDropTarget( 
            /* [in] */ IDropTarget __RPC_FAR *pDropTarget,
            /* [out] */ IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget);

		STDMETHODIMP GetExternal( 
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispatch);
        
        STDMETHODIMP TranslateUrl( 
            /* [in] */ DWORD dwTranslate,
            /* [in] */ OLECHAR __RPC_FAR *pchURLIn,
            /* [out] */ OLECHAR __RPC_FAR *__RPC_FAR *ppchURLOut);
        
        STDMETHODIMP FilterDataObject( 
            /* [in] */ IDataObject __RPC_FAR *pDO,
            /* [out] */ IDataObject __RPC_FAR *__RPC_FAR *ppDORet);


};

typedef CImpIDocHostUIHandler* PCImpIDocHostUIHandler;



class CImpIDocHostShowUI : public IDocHostShowUI
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIDocHostShowUI(class CSite *, IUnknown *);
        ~CImpIDocHostShowUI(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

		STDMETHODIMP ShowMessage(
								HWND hwnd,
								LPOLESTR lpstrText,
								LPOLESTR lpstrCaption, 
								DWORD dwType,
								LPOLESTR lpstrHelpFile,
								DWORD dwHelpContext,
								LRESULT * plResult);
		STDMETHODIMP ShowHelp(
								HWND hwnd,
								LPOLESTR pszHelpFile,
								UINT uCommand,
								DWORD dwData,
								POINT ptMouse,
								IDispatch * pDispatchObjectHit);
};

typedef CImpIDocHostShowUI* PCImpIDocHostShowUI;



/*
 * IDispatch - implements Ambient properties
 */
class CImpAmbientIDispatch : public IDispatch
{
    protected:
        ULONG           m_cRef;
        class CSite		*m_pSite;
        LPUNKNOWN       m_pUnkOuter;

    public:
        CImpAmbientIDispatch(class CSite *, IUnknown *);
        ~CImpAmbientIDispatch(void);

        STDMETHODIMP QueryInterface(REFIID, LPVOID *);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT
            , LCID, DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, USHORT
            , DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
};

typedef class CImpAmbientIDispatch *PCImpAmbientIDispatch;


class CImpIOleControlSite : public IOleControlSite
{
    protected:
        ULONG               m_cRef;
        class CSite        *m_pSite;
        LPUNKNOWN           m_pUnkOuter;

    public:
        CImpIOleControlSite(class CSite *, IUnknown *);
        ~CImpIOleControlSite(void);

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP OnControlInfoChanged(void) { return S_OK;}
        STDMETHODIMP LockInPlaceActive(BOOL) {return E_NOTIMPL;}
        STDMETHODIMP GetExtendedControl(IDispatch**) {return E_NOTIMPL;}
        STDMETHODIMP TransformCoords(POINTL*, POINTF*, DWORD) {return E_NOTIMPL;}
        STDMETHODIMP TranslateAccelerator(LPMSG, DWORD) {return E_NOTIMPL;}
        STDMETHODIMP OnFocus(BOOL) { return S_OK;}
        STDMETHODIMP ShowPropertyFrame(void) { return E_NOTIMPL; }
};

typedef class CImpIOleControlSite *PCImpIOleControlSite;



/*
 * The CSite class, a COM object with the interfaces IOleClientSite,
 * IAdviseSink, IOleInPlaceSite, and IOleDocumentSite.
 */


class CSite : public IUnknown
{
	
    private:
        ULONG						m_cRef;
        HWND						m_hWnd; //Client area window of parent
		DWORD						m_dwPropNotifyCookie;
		DWORD						m_dwOleObjectCookie;
        class CProxyFrame*			m_pFR;
		BOOL						m_bFiltered;

        //Object interfaces
        LPUNKNOWN					m_pObj;
        LPOLEOBJECT					m_pIOleObject;
        LPOLEINPLACEOBJECT			m_pIOleIPObject;
        LPOLEDOCUMENTVIEW			m_pIOleDocView;
		LPOLECOMMANDTARGET			m_pIOleCommandTarget;


        //Our interfaces
        PCImpIOleClientSite			m_pImpIOleClientSite;
        PCImpIAdviseSink			m_pImpIAdviseSink;
        PCImpIOleInPlaceSite		m_pImpIOleIPSite;
        PCImpIOleDocumentSite		m_pImpIOleDocumentSite;
        PCImpIDocHostUIHandler		m_pImpIDocHostUIHandler;
        PCImpIDocHostShowUI			m_pImpIDocHostShowUI;
		PCImpAmbientIDispatch		m_pImpAmbientIDispatch;
		PCImplPropertyNotifySink	m_pImpIPropertyNotifySink;
		PCImpIOleControlSite		m_pImpIOleControlSite;

		CTriEditEventSink*			m_pTriEdDocEvtSink;		
		CTriEditEventSink*			m_pTriEdWndEvtSink;		
		BOOL						m_bfSaveAsUnicode;
		UINT						m_cpCodePage;
		IMultiLanguage2*			m_piMLang;

    protected:

    public:
        CSite(CProxyFrame*);
        ~CSite(void);

        //BOOL    ObjectInitialize( TCHAR* pchPath );

        //Gotta have an IUnknown for delegation
        STDMETHODIMP QueryInterface(REFIID, void** );
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);


		// Other functions
        HRESULT		HrCreate(IUnknown* pUnk, IUnknown** ppUnkTriEdit);
		HRESULT		HrObjectInitialize();
		HRESULT		HrRegisterPropNotifySink(BOOL fRegister);
        void        Close(BOOL);
		void		InitialActivate(LONG, HWND hWnd);
		void		Activate(LONG);
        void        UpdateObjectRects(void);

		HRESULT		HrIsDirtyIPersistStreamInit(BOOL& bVal);

		HRESULT		HrSaveToFile(BSTR bstrPath, DWORD dwFilterFlags);
		HRESULT		HrSaveToBstr(BSTR* bstr, DWORD dwFilterFlags);

		HRESULT		HrSaveToStream(LPSTREAM pStream);
		HRESULT		HrSaveToStreamAndFilter(LPSTREAM* ppStream, DWORD dwFilterFlags);

		HRESULT		HrTestFileOpen(BSTR path);

		// Filtering methods

		HRESULT		HrFileToStream(LPCTSTR fileName, LPSTREAM* ppiStream);
		HRESULT		HrURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream);
		HRESULT		HrSecureURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream);
		HRESULT		HrNonSecureURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream);
		HRESULT		HrStreamToFile(LPSTREAM pStream, LPCTSTR fileName);
		HRESULT		HrBstrToStream(BSTR bstrSrc, LPSTREAM* ppStream);
		HRESULT		HrStreamToBstr(LPSTREAM pStream, BSTR* pBstr, BOOL bfRetainByteOrderMark = FALSE);
		HRESULT		HrFilter(BOOL bDirection, LPSTREAM pSrcStream, LPSTREAM* ppFilteredStream, DWORD dwFilterFlags);

		HRESULT		HrConvertStreamToUnicode ( IStream* piStream );
		BOOL		BfFlipBytesIfBigEndianUnicode ( CHAR* pchData, int cbSize );
		BOOL		IsUnicode ( void* pData, int cbSize );

		// ReadyState property methods
		void OnReadyStateChanged();

		// helper functions

		HRESULT GetContainer ( LPOLECONTAINER* ppContainer );

		inline CProxyFrame*	GetFrame(void) {
							return m_pFR;
						}

		inline LPUNKNOWN		GetObjectUnknown(void ) {
							return m_pObj; 
						} 

		inline PCImpIOleInPlaceSite GetIPSite(void) {
							return m_pImpIOleIPSite;
						}

		inline HWND			GetWindow(void) {
							return m_hWnd;
						}

		inline void			SetWindow(HWND hwnd) {
							m_hWnd = hwnd;
						}

		inline LPOLECOMMANDTARGET GetCommandTarget(void) {
							return m_pIOleCommandTarget;
						}

		inline void			SetCommandTarget(LPOLECOMMANDTARGET pTarget) {
							m_pIOleCommandTarget = pTarget;
						}

		inline void			SetDocView(LPOLEDOCUMENTVIEW pDocView) {
							// VSQFE:406/WinSERAID:23872, hongyuwu, 4/18/2002
							// need to release the old pointer first 
							// (AddRef'ed in CImpIOleDocumentSite::ActivateMe)
							if(m_pIOleDocView) m_pIOleDocView->Release();
							m_pIOleDocView = pDocView;
						}
		
		inline void			SetIPObject(LPOLEINPLACEOBJECT pIPObject) {
							m_pIOleIPObject = pIPObject;
						}

		inline LPOLEINPLACEOBJECT GetIPObject(void) {
							return m_pIOleIPObject; 
						}

		inline BOOL GetSaveAsUnicode ( void ) {
							return m_bfSaveAsUnicode;
						}

		inline BOOL SetSaveAsUnicode ( BOOL bfUnicode ) {
							BOOL bf = m_bfSaveAsUnicode;
							m_bfSaveAsUnicode = bfUnicode;
							return bf;
						}

		inline UINT GetCurrentCodePage ( void ) {
							return m_cpCodePage;
						}
};


typedef CSite* PCSite;



//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
{\
            if (NULL!=p)\
            {\
                delete p;\
                p=NULL;\
            }\
}


//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
{\
            IUnknown *pt=(IUnknown *)p;\
            p=NULL;\
            if (NULL!=pt)\
                pt->Release();\
}

#endif //_SITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\proxyframe.cpp ===
//	Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//	Notes on m_bfModeSwitched and m_bfReloadAttempted.
//	IE5 bug 52818 was punted; pages containing IFrames don't refresh when changing
//	browse/edit modes, because the stream is seen as dirty (because the IFrame
//	considers itself dirty.)  In response, we set m_bfModeSwitched when changing mode,
//	m_bfReloadAttempted when and ATTEMPT is made to reload the page, and check for BOTH
//	in OnReadyStateChanged.  If the mode was changed but the page wasn't reloaded,
//	we have to reload it manually.


#include "stdafx.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "site.h"
#include "proxyframe.h"
#include <TRIEDIID.h>
#include <mshtmdid.h>
#include "dispexa.h"
#include <wchar.h>
#include <string.h>


// HTML to initialize Trident with if the host didn't supply any
// The <P>&nbsp;</P> works around a nasty Trident bug.
// Change: now there is one with paragraphs, one with DIVs.
//
static WCHAR* g_initialHTMLwithP = \
L"<HTML>\r\n\
<HEAD>\r\n\
<META NAME=\"GENERATOR\" Content=\"Microsoft DHTML Editing Control\">\r\n\
<TITLE></TITLE>\r\n\
</HEAD>\r\n\
<BODY>\r\n\
<P>&nbsp;</P>\r\n\
</BODY>\r\n\
</HTML>\r\n";

static WCHAR* g_initialHTMLwithDIV = \
L"<HTML>\r\n\
<HEAD>\r\n\
<META NAME=\"GENERATOR\" Content=\"Microsoft DHTML Editing Control\">\r\n\
<TITLE></TITLE>\r\n\
</HEAD>\r\n\
<BODY>\r\n\
<DIV>&nbsp;</DIV>\r\n\
</BODY>\r\n\
</HTML>\r\n";


//	Text, numbers and constants used to construct a unique-per-process protocol ID
//
static WCHAR* g_wszProtocolPrefix = L"DHTMLEd";
static int	s_iProtocolSuffix = 0;
#define MAX_PROTOCOL_SUFFIX	999999


// Name of the Title property which we get from the IHtmlDocument2 interface.
static WCHAR* 	g_wszHTMLTitlePropName = L"title";


//	Maps private DHTMLEdit command IDs to Triedit command IDs.
//	The third field is true if the command includes an out parameter.
//
static CommandMap cmdMap[] = 
{
	{DECMD_BOLD,				IDM_TRIED_BOLD,				FALSE},
	{DECMD_COPY,				IDM_TRIED_COPY,				FALSE},
	{DECMD_CUT,					IDM_TRIED_CUT,				FALSE},
	{DECMD_DELETE,				IDM_TRIED_DELETE,			FALSE},
	{DECMD_DELETECELLS,			IDM_TRIED_DELETECELLS,		FALSE},
	{DECMD_DELETECOLS,			IDM_TRIED_DELETECOLS,		FALSE},
	{DECMD_DELETEROWS,			IDM_TRIED_DELETEROWS,		FALSE},
	{DECMD_FINDTEXT,			IDM_TRIED_FIND,				FALSE},
	{DECMD_FONT,				IDM_TRIED_FONT,				FALSE},
	{DECMD_GETBACKCOLOR,		IDM_TRIED_BACKCOLOR,		TRUE},
	{DECMD_GETBLOCKFMT,			IDM_TRIED_BLOCKFMT,			TRUE},
	{DECMD_GETBLOCKFMTNAMES,	IDM_TRIED_GETBLOCKFMTS,		TRUE},
	{DECMD_GETFONTNAME,			IDM_TRIED_FONTNAME,			TRUE},
	{DECMD_GETFONTSIZE,			IDM_TRIED_FONTSIZE,			TRUE},
	{DECMD_GETFORECOLOR,		IDM_TRIED_FORECOLOR,		TRUE},
	{DECMD_HYPERLINK,			IDM_TRIED_HYPERLINK,		FALSE},
	{DECMD_IMAGE,				IDM_TRIED_IMAGE,			FALSE},
	{DECMD_INDENT,				IDM_TRIED_INDENT,			FALSE},
	{DECMD_INSERTCELL,			IDM_TRIED_INSERTCELL,		FALSE},
	{DECMD_INSERTCOL,			IDM_TRIED_INSERTCOL,		FALSE},
	{DECMD_INSERTROW,			IDM_TRIED_INSERTROW,		FALSE},
	{DECMD_INSERTTABLE,			IDM_TRIED_INSERTTABLE,		FALSE},
	{DECMD_ITALIC,				IDM_TRIED_ITALIC,			FALSE},
	{DECMD_JUSTIFYLEFT,			IDM_TRIED_JUSTIFYLEFT,		FALSE},
	{DECMD_JUSTIFYRIGHT,		IDM_TRIED_JUSTIFYRIGHT,		FALSE},
	{DECMD_JUSTIFYCENTER,		IDM_TRIED_JUSTIFYCENTER,	FALSE},
	{DECMD_LOCK_ELEMENT,		IDM_TRIED_LOCK_ELEMENT,		FALSE},
	{DECMD_MAKE_ABSOLUTE,		IDM_TRIED_MAKE_ABSOLUTE,	FALSE},
	{DECMD_MERGECELLS,			IDM_TRIED_MERGECELLS,		FALSE},
	{DECMD_ORDERLIST,			IDM_TRIED_ORDERLIST,		FALSE},
	{DECMD_OUTDENT,				IDM_TRIED_OUTDENT,			FALSE},
	{DECMD_PASTE,				IDM_TRIED_PASTE,			FALSE},
	{DECMD_REDO,				IDM_TRIED_REDO,				FALSE},
	{DECMD_REMOVEFORMAT,		IDM_TRIED_REMOVEFORMAT,		FALSE},
	{DECMD_SELECTALL,			IDM_TRIED_SELECTALL,		FALSE},
	{DECMD_SEND_BACKWARD,		IDM_TRIED_SEND_BACKWARD,	FALSE},
	{DECMD_BRING_FORWARD,		IDM_TRIED_SEND_FORWARD,		FALSE},
	{DECMD_SEND_BELOW_TEXT,		IDM_TRIED_SEND_BEHIND_1D,	FALSE},
	{DECMD_BRING_ABOVE_TEXT,	IDM_TRIED_SEND_FRONT_1D,	FALSE},
	{DECMD_SEND_TO_BACK,		IDM_TRIED_SEND_TO_BACK,		FALSE},
	{DECMD_BRING_TO_FRONT,		IDM_TRIED_SEND_TO_FRONT,	FALSE},
	{DECMD_SETBACKCOLOR,		IDM_TRIED_BACKCOLOR,		FALSE},
	{DECMD_SETBLOCKFMT,			IDM_TRIED_BLOCKFMT,			FALSE},
	{DECMD_SETFONTNAME,			IDM_TRIED_FONTNAME,			FALSE},
	{DECMD_SETFONTSIZE,			IDM_TRIED_FONTSIZE,			FALSE},
	{DECMD_SETFORECOLOR,		IDM_TRIED_FORECOLOR,		FALSE},
	{DECMD_SPLITCELL,			IDM_TRIED_SPLITCELL,		FALSE},
	{DECMD_UNDERLINE,			IDM_TRIED_UNDERLINE,		FALSE},
	{DECMD_UNDO,				IDM_TRIED_UNDO,				FALSE},
	{DECMD_UNLINK,				IDM_TRIED_UNLINK,			FALSE},
	{DECMD_UNORDERLIST,			IDM_TRIED_UNORDERLIST,		FALSE},
	{DECMD_PROPERTIES,			IDM_TRIED_DOVERB,			FALSE}
};



CProxyFrame::CProxyFrame(CDHTMLSafe* pCtl)
{
	SAFEARRAYBOUND rgsabound[1] = {0};

	_ASSERTE(pCtl);

	m_cRef = 1;

	m_pUnkTriEdit = NULL;
	m_hWndObj = NULL;
	m_pIOleIPActiveObject = NULL;
	m_pSite = NULL;
	m_pCtl = pCtl;

	m_fCreated = FALSE;
	m_fActivated = FALSE;
	m_state = ESTATE_NOTCREATED;
	m_readyState = READYSTATE_UNINITIALIZED;
	m_dwFilterFlags = m_dwFilterOutFlags = filterAll;

	m_fActivateApplets = FALSE;
	m_fActivateControls = FALSE;
	m_fActivateDTCs = TRUE;
	m_fShowAllTags = FALSE;
	m_fShowBorders = FALSE;

	m_fDialogEditing = TRUE;
	m_fDisplay3D = TRUE;
	m_fScrollbars = TRUE;
	m_fDisplayFlatScrollbars = FALSE;
	m_fContextMenu = TRUE;

	m_fPreserveSource = TRUE;

	m_fAbsoluteDropMode = FALSE;
	m_fSnapToGrid = FALSE;
	m_ulSnapToGridX = 50;
	m_ulSnapToGridY = 50;

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = 0;

	m_pMenuStrings = NULL;	
	m_pMenuStates = NULL;	

	m_vbBrowseMode = VARIANT_FALSE;

	m_vbUseDivOnCr = VARIANT_FALSE;
	m_bfIsLoading  = FALSE;
	m_bfBaseURLFromBASETag = FALSE;
	m_bfPreserveDirtyFlagAcrossBrowseMode = FALSE;
	m_bstrInitialDoc.Empty ();

	m_bstrCurDocPath.Empty ();

	wcscpy ( m_wszProtocol, g_wszProtocolPrefix );
	WCHAR wszSuffix[8];
	_itow ( s_iProtocolSuffix++, wszSuffix, 10 );
	if ( MAX_PROTOCOL_SUFFIX <= s_iProtocolSuffix )
	{
		s_iProtocolSuffix = 0;	// Roll over.
	}
	wcscat ( m_wszProtocol, wszSuffix );
	wcscpy ( m_wszProtocolPrefix, m_wszProtocol );
	wcscat ( m_wszProtocolPrefix, L":" );

	m_pProtInfo = NULL;
	m_bfIsURL   = FALSE;
	m_bstrBaseURL = L"";
	m_hwndRestoreFocus = NULL;

#ifdef LATE_BIND_URLMON_WININET
	m_hUlrMon					= NULL;
	m_hWinINet					= NULL;
	m_pfnCoInternetCombineUrl	= NULL;
	m_pfnCoInternetParseUrl		= NULL;
	m_pfnCreateURLMoniker		= NULL;
	m_pfnCoInternetGetSession	= NULL;
	m_pfnURLOpenBlockingStream	= NULL;

	m_pfnDeleteUrlCacheEntry	= NULL;
	m_pfnInternetCreateUrl		= NULL;
	m_pfnInternetCrackUrl		= NULL;
#endif // LATE_BIND_URLMON_WININET

	m_bfModeSwitched	= FALSE;
	m_bfReloadAttempted	= FALSE;
	m_bfSFSRedirect		= FALSE;
}

CProxyFrame::~CProxyFrame()
{
	_ASSERTE(FALSE == m_fCreated);
	_ASSERTE(FALSE == m_fActivated);
	_ASSERTE( m_cRef == 0 );

	if (m_pMenuStrings)
	{
		SafeArrayDestroy(m_pMenuStrings);
		m_pMenuStrings = NULL;
	}

	if (m_pMenuStates)
	{
		SafeArrayDestroy(m_pMenuStates);
		m_pMenuStates = NULL;
	}

	// This should never happen: SetActiveObject should take care of it.
	_ASSERTE ( NULL == m_pIOleIPActiveObject );
	if (m_pIOleIPActiveObject)
	{
		m_pIOleIPActiveObject->Release();
		m_pIOleIPActiveObject = NULL;
	}

	UnRegisterPluggableProtocol ();
#ifdef LATE_BIND_URLMON_WININET
	DynUnloadLibraries ();
#endif // LATE_BIND_URLMON_WININET
}


//	Create the TriEdit object and host it.
//	Clean up and return an error if there was any problem.
//
HRESULT
CProxyFrame::Init(IUnknown* pUnk, IUnknown** ppUnkTriEdit)
{
	HRESULT hr = S_OK;

#ifdef LATE_BIND_URLMON_WININET
	if ( ! DynLoadLibraries () )
	{
		return E_FAIL;
	}
#endif // LATE_BIND_URLMON_WININET

	hr = RegisterPluggableProtocol ();
	if ( FAILED ( hr ) )
	{
		return hr;
	}

	_ASSERTE(NULL == m_pSite);
	_ASSERTE(GetState() == ESTATE_NOTCREATED);

	InitializeDocString ();

	if (m_pSite)
		return E_UNEXPECTED;

	if (GetState() != ESTATE_NOTCREATED)
		return E_UNEXPECTED;

	// Create and initialize the site for TriEdit
	m_pSite = new CSite(this);

    if (NULL == m_pSite)
	{
        return E_OUTOFMEMORY;
	}

    m_pSite->AddRef();  // So we can free with Release

	// Ask the site to create TriEdit
    if (SUCCEEDED(hr = m_pSite->HrCreate(pUnk, &m_pUnkTriEdit)))
	{
		ChangeState(ESTATE_CREATED);
		m_fCreated = TRUE;
		if (ppUnkTriEdit)
		{
			m_pUnkTriEdit->AddRef();
			*ppUnkTriEdit = m_pUnkTriEdit;
		}
	}
	else
	{
		m_pSite->Release();
		m_pSite = NULL;
	}

    return hr;        
}


//	Destroy the site and the TriEdit object.
//
HRESULT
CProxyFrame::Close()
{
	HRESULT hr = S_OK;

	_ASSERTE(m_pUnkTriEdit);
	_ASSERTE(m_pSite);
	_ASSERTE(GetState() != ESTATE_NOTCREATED);

	m_bstrCurDocPath.Empty ();

	// triedit must be created
	// any state from created to activated is ok
	if (GetState() == ESTATE_NOTCREATED)
		return E_UNEXPECTED;

	if (m_fActivated)
	{
		hr = HrExecCommand(&CGID_MSHTML, IDM_STOP, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
		_ASSERTE(SUCCEEDED(hr));
	}

	ChangeState(ESTATE_NOTCREATED);
	m_fCreated = FALSE;
	m_fActivated = FALSE;
    if (m_pSite != NULL)
	{
		CSite* pSite = m_pSite; // prevents reentry;
		m_pSite = NULL;

		pSite->Close(FALSE);
		ReleaseInterface(pSite)
		pSite = NULL;
	}

	if (m_pUnkTriEdit != NULL)
	{
		LPUNKNOWN pUnkTriEdit = m_pUnkTriEdit;
		m_pUnkTriEdit = NULL;

		ReleaseInterface(pUnkTriEdit);
		pUnkTriEdit = NULL;
	}

	m_hwndRestoreFocus = NULL;

	return S_OK;
}


//	Determine which string constant to use and return a pointer to it.
//
WCHAR* CProxyFrame::GetInitialHTML ()
{
	if ( m_vbUseDivOnCr )
	{
		return g_initialHTMLwithDIV;
	}
	else
	{
		return g_initialHTMLwithP;
	}
}


//	Perform these steps before loading TriEdit's contents
//
HRESULT
CProxyFrame::PreActivate()
{
	HRESULT hr = S_OK;
	_ASSERTE(m_pSite);
	_ASSERTE(m_pCtl);

	_ASSERTE(ESTATE_CREATED == GetState());

	if (GetState() != ESTATE_CREATED)
		return E_UNEXPECTED;


	if (FAILED(hr = m_pSite->HrObjectInitialize()))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	m_fActivated = TRUE;
	ChangeState(ESTATE_PREACTIVATING);

	if (FAILED(hr = HrSetRuntimeProperties()))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	ChangeState(ESTATE_ACTIVATING);

error:

	return hr;
}


void
CProxyFrame::UIDeactivate()
{
	// This was m_pSite->GetIPObject()->UIDeactivate(),
	// but the QA teams VB app using this version of the control crashed
	// with a NULL pointer dereference.

	if ( NULL != m_pSite )
	{
		LPOLEINPLACEOBJECT pipObj = m_pSite->GetIPObject();
		if ( NULL != pipObj )
		{
			pipObj->UIDeactivate();
		}
	}
}

//	Perform these steps after loading TriEdits contents to go UI active.
//
HRESULT
CProxyFrame::Activate()
{
    HRESULT hr = S_OK;

    _ASSERTE(m_pSite);
    _ASSERTE(m_pCtl);
    _ASSERTE(m_pCtl->m_hWndCD);

    _ASSERTE(GetState() == ESTATE_ACTIVATING);

    if (GetState() != ESTATE_ACTIVATING)
        return E_UNEXPECTED;

    // UI-activate the control
    if ( ! m_pCtl->m_bUIActive )
    {
        // Used to be UIActivate, until MohanB fixed OnSetFocus and activation/deactivation linkage.
        m_pCtl->DoVerbInPlaceActivate ( NULL, NULL );
    }

    // activate Trident with "Show"
    m_pSite->InitialActivate(OLEIVERB_SHOW, m_pCtl->m_hWndCD);

    ChangeState(ESTATE_ACTIVATED);

    // This may have been deferred, because the site's command target did not yet exist...
    SetBrowseMode ( m_vbBrowseMode );

    return hr;
}


//	Load and activate the control with a minimal, empty page.
//
HRESULT
CProxyFrame::LoadInitialDoc()
{
	HRESULT hr = S_OK;

	_ASSERTE(GetState() == ESTATE_CREATED);

	if (GetState() != ESTATE_CREATED)
		return E_UNEXPECTED;
	
	if (FAILED(hr = PreActivate()))
		goto error;

	if (FAILED(hr = LoadBSTRDeferred ( m_bstrInitialDoc )))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = Activate()))
		goto error;

error:

	return hr;
}


// Before getting or setting a property or calling a method on the docobject,
// assure that it's been properly activated.
//
void CProxyFrame::AssureActivated ()
{
	if ( ! m_fActivated )
	{
		if ( m_pCtl->IsUserMode() )
		{
			if ( !m_pCtl->m_bInPlaceActive )
			{
				m_pCtl->DoVerbInPlaceActivate ( NULL, NULL );
			}
			LoadInitialDoc ();
		}
	}
}


//	Loading MSHTML shifts the focus to its document window.
//	This is not desirable in a control.  Experimentation has demonstrated
//	that the focus shifts between various QIs from MSHTML (probably in response
//	to posted messages.)  There is no routine in DHTMLEdit which enters with the	
//	focus outside the control and exits with the focus within the control.
//	Therefore, a member variable is used to preserve the appropriate focus
//	across calls to OnReadyStateChanged, which are called in response to events
//	fired by the control.  m_hwndRestoreFocus is used to preserve the appropriate
//	window to receive the focus.  Note that NULL may be appropriate, but is not honored.
//	If no window had focus, the document will gain focus.
//
void 
CProxyFrame::OnReadyStateChanged(READYSTATE readyState)
{
	_ASSERTE(m_pCtl);

	m_readyState = readyState;

	switch (m_readyState)
	{	
	case READYSTATE_UNINITIALIZED:
		{
			m_hwndRestoreFocus = NULL;
		}
		break;

	case READYSTATE_LOADING:
		{
			m_hwndRestoreFocus = ::GetFocus ();
		}
		break;
		
	case READYSTATE_LOADED:
		{
		}
		break;

	case READYSTATE_INTERACTIVE:
		{
			if ( NULL != m_hwndRestoreFocus )
			{
				_ASSERTE ( ::IsWindow ( m_hwndRestoreFocus ) );
				if ( ::IsWindow ( m_hwndRestoreFocus ) )
				{
					::SetFocus ( m_hwndRestoreFocus );
				}
			}

			// See if we failed to get a refresh on a mode change.  This happens if
			// there are IFrames on the page, perhaps in other cases as well.
			if ( m_bfModeSwitched && !m_bfReloadAttempted )
			{
				HRESULT	hr	= S_OK;

				CComPtr<IMoniker> srpMoniker;
				CComPtr<IBindCtx> srpBindCtx;
				CComQIPtr<IPersistMoniker, &IID_IPersistMoniker> srpPM (m_pUnkTriEdit);
				_ASSERTE ( srpPM );

				if ( srpPM )
				{
					CComBSTR	bstrProtocol = m_wszProtocolPrefix;

#ifdef LATE_BIND_URLMON_WININET
					_ASSERTE ( m_pfnCreateURLMoniker );
					hr = (*m_pfnCreateURLMoniker)( NULL, bstrProtocol, &srpMoniker );
#else
					hr = CreateURLMoniker ( NULL, bstrProtocol, &srpMoniker );
#endif // LATE_BIND_URLMON_WININET

					_ASSERTE ( SUCCEEDED( hr ) );
					if ( SUCCEEDED ( hr ) )
					{
						hr = ::CreateBindCtx(NULL, &srpBindCtx);
						_ASSERTE ( SUCCEEDED( hr ) );
						if ( SUCCEEDED ( hr ) )
						{
							hr = srpPM->Load(FALSE, srpMoniker,  srpBindCtx, STGM_READ);
						}
					}
				}
			}
			m_bfModeSwitched	= FALSE;
			m_bfReloadAttempted	= FALSE;
		}
		break;

	case READYSTATE_COMPLETE:
		{
			HRESULT hr		= S_OK;

			m_hwndRestoreFocus = NULL;
			if ( ! m_vbBrowseMode )
			{
				hr = HrSetDocLoadedProperties();
				_ASSERTE(SUCCEEDED(hr));
			}

			_ASSERTE ( m_pCtl->m_hWnd );
			_ASSERTE ( ::IsWindow ( m_pCtl->m_hWnd ) );

			if ( m_bfPreserveDirtyFlagAcrossBrowseMode && !m_vbBrowseMode )
			{
				m_bfPreserveDirtyFlagAcrossBrowseMode = FALSE;
				SetDirtyFlag ( TRUE );
			}
			// Post a user message to fire the DocumentComplete event.
			// Otherwise, calling things like LoadURL from DocumentComplete behaves strangely.
			::PostMessage ( m_pCtl->m_hWnd, DOCUMENT_COMPETE_MESSAGE, DOCUMENT_COMPETE_SIGNATURE, 0L );
			HrSetRuntimeProperties ();
			//m_bfIsLoading = FALSE;	// This has been moved the the DOCUMENT_COMPETE_MESSAGE handler.
			SetBaseURLFromBaseHref ();	// Must be called after clearing m_bfIsLoading
		}
		break;
	}
}


/*
 * IUnknown implementation
 */
/*
 * CProxyFrame::QueryInterface
 * CProxyFrame::AddRef
 * CProxyFrame::Release
 */
STDMETHODIMP CProxyFrame::QueryInterface( REFIID riid, void **ppv )
{
    /*
     * We provide IOleInPlaceFrame and IOleCommandTarget
	 *   interfaces here for the ActiveX Document hosting
	 */
    *ppv = NULL;

    if ( IID_IUnknown == riid || IID_IOleInPlaceUIWindow == riid
        || IID_IOleWindow == riid || IID_IOleInPlaceFrame == riid )
	{
        *ppv = static_cast<IOleInPlaceFrame *>(this);
	}

	else if ( IID_IOleCommandTarget == riid )
	{
        *ppv = static_cast<IOleCommandTarget *>(this);
	}
	else if ( IID_IBindStatusCallback == riid )
	{
        *ppv = static_cast<IBindStatusCallback *>(this);
	}
	else if ( IID_IAuthenticate == riid )
	{
        *ppv = static_cast<IAuthenticate *>(this);
	}
	else if ( IID_IServiceProvider == riid )
	{
		// Ask the control for a security manager IF in edit mode:
		if ( ! m_vbBrowseMode )
		{
			return m_pCtl->GetUnknown()->QueryInterface ( riid, ppv );
		}
	}

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CProxyFrame::AddRef( void )
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CProxyFrame::Release( void )
{
    //Nothing special happening here-- life if user-controlled.
	// Debug check to see we don't fall below 0
	_ASSERTE( m_cRef != 0 );

	ULONG ulRefCount = --m_cRef;
	if ( 0 == ulRefCount )
	{
		delete this;	// Do not refer to any member variables after this.
	}
    return ulRefCount;
}


/*
 * IOleInPlaceFrame implementation
 */
/*
 * CProxyFrame::GetWindow
 *
 * Purpose:
 *  Retrieves the handle of the window associated with the object
 *  on which this interface is implemented.
 *
 * Parameters:
 *  phWnd           HWND * in which to store the window handle.
 *
 * Return Value:
 *  HRESULT         S_OK if successful, E_FAIL if there is no
 *                  window.
 */
STDMETHODIMP CProxyFrame::GetWindow( HWND* phWnd )
{
	if ( m_pCtl != NULL )
	{
		*phWnd = m_pCtl->m_hWnd;
	}
	return S_OK;
}



/*
 * CProxyFrame::ContextSensitiveHelp
 *
 * Purpose:
 *  Instructs the object on which this interface is implemented to
 *  enter or leave a context-sensitive help mode.
 *
 * Parameters:
 *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise.
 *
 * Return Value:
 *  HRESULT         S_OK
 */
STDMETHODIMP CProxyFrame::ContextSensitiveHelp( BOOL /*fEnterMode*/ )
{
    return S_OK;
}



/*
 * CProxyFrame::GetBorder
 *
 * Purpose:
 *  Returns the rectangle in which the container is willing to
 *  negotiate about an object's adornments.
 *
 * Parameters:
 *  prcBorder       LPRECT in which to store the rectangle.
 *
 * Return Value:
 *  HRESULT         S_OK if all is well, INPLACE_E_NOTOOLSPACE
 *                  if there is no negotiable space.
 */
STDMETHODIMP CProxyFrame::GetBorder( LPRECT prcBorder )
{
    if ( NULL == prcBorder )
	{
        return E_INVALIDARG;
	}

    //We return all the client area space
    m_pCtl->GetClientRect( prcBorder );
    return S_OK;
}


/*
 * CProxyFrame::RequestBorderSpace
 *
 * Purpose:
 *  Asks the container if it can surrender the amount of space
 *  in pBW that the object would like for it's adornments.  The
 *  container does nothing but validate the spaces on this call.
 *
 * Parameters:
 *  pBW             LPCBORDERWIDTHS containing the requested space.
 *                  The values are the amount of space requested
 *                  from each side of the relevant window.
 *
 * Return Value:
 *  HRESULT         S_OK if we can give up space,
 *                  INPLACE_E_NOTOOLSPACE otherwise.
 */
STDMETHODIMP CProxyFrame::RequestBorderSpace( LPCBORDERWIDTHS /*pBW*/ )
{
    // We have no border space restrictions
    return S_OK;
}


/*
 * CProxyFrame::SetBorderSpace
 *
 * Purpose:
 *  Called when the object now officially requests that the
 *  container surrender border space it previously allowed
 *  in RequestBorderSpace.  The container should resize windows
 *  appropriately to surrender this space.
 *
 * Parameters:
 *  pBW             LPCBORDERWIDTHS containing the amount of space
 *                  from each side of the relevant window that the
 *                  object is now reserving.
 *
 * Return Value:
 *  HRESULT         S_OK
 */
STDMETHODIMP CProxyFrame::SetBorderSpace( LPCBORDERWIDTHS /*pBW*/ )
{
	// We turn off the MSHTML.DLL UI so we ignore all of this.

    return S_OK;
}




/*
 * CProxyFrame::SetActiveObject
 *
 * Purpose:
 *  Provides the container with the object's IOleInPlaceActiveObject
 *  pointer
 *
 * Parameters:
 *  pIIPActiveObj   LPOLEINPLACEACTIVEOBJECT of interest.
 *  pszObj          LPCOLESTR naming the object.  Not used.
 *
 * Return Value:
 *  HRESULT         S_OK
 */
STDMETHODIMP CProxyFrame::SetActiveObject( LPOLEINPLACEACTIVEOBJECT pIIPActiveObj,
											LPCOLESTR /*pszObj*/)
{
	// If we already have an active Object then release it.
    if ( NULL != m_pIOleIPActiveObject )
	{
        m_pIOleIPActiveObject->Release();
	}

    //NULLs m_pIOleIPActiveObject if pIIPActiveObj is NULL
    m_pIOleIPActiveObject = pIIPActiveObj;

    if ( NULL != m_pIOleIPActiveObject )
	{
        m_pIOleIPActiveObject->AddRef();
		m_pIOleIPActiveObject->GetWindow( &m_hWndObj );
	}
    return S_OK;
}



/*
 * CProxyFrame::InsertMenus
 *
 * Purpose:
 *  Instructs the container to place its in-place menu items where
 *  necessary in the given menu and to fill in elements 0, 2, and 4
 *  of the OLEMENUGROUPWIDTHS array to indicate how many top-level
 *  items are in each group.
 *
 * Parameters:
 *  hMenu           HMENU in which to add popups.
 *  pMGW            LPOLEMENUGROUPWIDTHS in which to store the
 *                  width of each container menu group.
 *
 * Return Value:
 *  HRESULT         E_NOTIMPL
 */
STDMETHODIMP CProxyFrame::InsertMenus( HMENU /*hMenu*/, LPOLEMENUGROUPWIDTHS /*pMGW*/ )
{
	// We've turned off the MSHTML.DLL Menus so we don't expect any merging to go on!
	return E_NOTIMPL;
}


/*
 * CProxyFrame::SetMenu
 *
 * Purpose:
 *  Instructs the container to replace whatever menu it's currently
 *  using with the given menu and to call OleSetMenuDescritor so OLE
 *  knows to whom to dispatch messages.
 *
 * Parameters:
 *  hMenu           HMENU to show.
 *  hOLEMenu        HOLEMENU to the menu descriptor.
 *  hWndObj         HWND of the active object to which messages are
 *                  dispatched.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CProxyFrame::SetMenu( HMENU /*hMenu*/, HOLEMENU /*hOLEMenu*/, HWND /*hWndObj*/ )
{
	// We've turned off the MSHTML.DLL Menus so we don't expect any merging to go on!
	return E_NOTIMPL;
}



/*
 * CProxyFrame::RemoveMenus
 *
 * Purpose:
 *  Asks the container to remove any menus it put into hMenu in
 *  InsertMenus.
 *
 * Parameters:
 *  hMenu           HMENU from which to remove the container's
 *                  items.
 *
 * Return Value:
 *  HRESULT         NOERROR
 */
STDMETHODIMP CProxyFrame::RemoveMenus( HMENU /*hMenu*/ )
{
	// We've turned off the MSHTML.DLL Menus so we don't expect any merging to go on!
	return E_NOTIMPL;
}


/*
 * CProxyFrame::SetStatusText
 *
 * Purpose:
 *  Asks the container to place some text in a status line, if one
 *  exists.  If the container does not have a status line it
 *  should return E_FAIL here in which case the object could
 *  display its own.
 *
 * Parameters:
 *  pszText         LPCOLESTR to display.
 *
 * Return Value:
 *  HRESULT         S_OK if successful, S_TRUNCATED if not all
 *                  of the text could be displayed, or E_FAIL if
 *                  the container has no status line.
 */
STDMETHODIMP CProxyFrame::SetStatusText( LPCOLESTR /*pszText*/ )
{
    return S_OK;
}



/*
 * CProxyFrame::EnableModeless
 *
 * Purpose:
 *  Instructs the container to show or hide any modeless popup
 *  windows that it may be using.
 *
 * Parameters:
 *  fEnable         BOOL indicating to enable/show the windows
 *                  (TRUE) or to hide them (FALSE).
 *
 * Return Value:
 *  HRESULT         S_OK
 */

STDMETHODIMP CProxyFrame::EnableModeless( BOOL /*fEnable*/ )
{
    return S_OK;
}


/*
 * CProxyFrame::TranslateAccelerator
 *
 * Purpose:
 *  When dealing with an in-place object from an EXE server, this
 *  is called to give the container a chance to process accelerators
 *  after the server has looked at the message.
 *
 * Parameters:
 *  pMSG            LPMSG for the container to examine.
 *  wID             WORD the identifier in the container's
 *                  accelerator table (from IOleInPlaceSite
 *                  ::GetWindowContext) for this message (OLE does
 *                  some translation before calling).
 *
 * Return Value:
 *  HRESULT         NOERROR if the keystroke was used,
 *                  S_FALSE otherwise.
 */
STDMETHODIMP CProxyFrame::TranslateAccelerator( LPMSG /*pMSG*/, WORD /*wID*/ )
{
    return S_FALSE;
}


/*
 * IOleCommandTarget::QueryStatus
 */
STDMETHODIMP CProxyFrame::QueryStatus( const GUID* pguidCmdGroup, ULONG cCmds,
				OLECMD* prgCmds, OLECMDTEXT* pCmdText )
{
    if ( pguidCmdGroup != NULL )
	{
		// It's a nonstandard group!!
        return OLECMDERR_E_UNKNOWNGROUP;
	}

    MSOCMD*     pCmd;
    INT         c;
    HRESULT     hr = S_OK;

    // By default command text is NOT SUPPORTED.
    if ( pCmdText && ( pCmdText->cmdtextf != OLECMDTEXTF_NONE ) )
	{
        pCmdText->cwActual = 0;
	}

    // Loop through each command in the array, setting the status of each.
    for ( pCmd = prgCmds, c = cCmds; --c >= 0; pCmd++ )
    {
        // By default command status is NOT SUPPORTED.
        pCmd->cmdf = 0;

        switch ( pCmd->cmdID )
        {
			case OLECMDID_UPDATECOMMANDS:
				pCmd->cmdf = OLECMDF_SUPPORTED;
				break;

			case OLECMDID_NEW:
			case OLECMDID_OPEN:
			case OLECMDID_SAVE:
				pCmd->cmdf = (MSOCMDF_SUPPORTED | MSOCMDF_ENABLED);
				break;
        }
    }

    return (hr);
}


/*
 * IOleCommandTarget::Exec
 */

STDMETHODIMP CProxyFrame::Exec( const GUID* pguidCmdGroup, DWORD nCmdID,
    DWORD /*nCmdexecopt*/, VARIANTARG* /*pvaIn*/, VARIANTARG* /*pvaOut*/ )
{
    HRESULT hr = S_OK;

    if ( pguidCmdGroup == NULL )
    {
        switch (nCmdID)
        {

			case OLECMDID_UPDATECOMMANDS:
				{
					// Fires event to container.
					m_pCtl->Fire_DisplayChanged();
					hr = S_OK;
				}
				break;

			default:
				hr = OLECMDERR_E_NOTSUPPORTED;
				break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }
    return (hr);
}


//	Connector from control to site.
//
void
CProxyFrame::UpdateObjectRects()
{
	_ASSERTE ( m_pSite );
	if ( NULL != m_pSite )
	{
		m_pSite->UpdateObjectRects();
	}
}


//	Called from the control's TranslateAccelerator.
//	Try our own (VID-like) acclerators first, and if not handled pass them along to TriEdit.
//
HRESULT
CProxyFrame::HrTranslateAccelerator(LPMSG lpmsg)
{
	HRESULT hr = S_OK;

	if (NULL != m_pIOleIPActiveObject)
	{
		_ASSERTE(lpmsg);

		hr = HrHandleAccelerator(lpmsg);

		if (hr != S_OK)
		{
			_ASSERTE(SUCCEEDED(hr));
			hr = m_pIOleIPActiveObject->TranslateAccelerator(lpmsg);
		}
	}

	return hr;
}


//	A lot of time was lost here in scenarios like clicking on/tabbing to a control
//	embedded in a VB OCX, tabbing to a control on a page, etc.
//	Exercise great caution and perform a lot of testing if this is changed.
//
LRESULT
CProxyFrame::OnSetFocus(UINT /*nMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
{
	if ( ! m_pCtl->m_bUIActive )
	{
		m_pCtl->DoVerbUIActivate ( NULL, NULL );
	}

	// Give the focus to the ActiveX Document window
    if ( m_hWndObj != NULL )
	{
		::SetFocus( m_hWndObj );
		bHandled = TRUE;
	}

	// activate Trident with "Show"
	m_pSite->Activate(OLEIVERB_SHOW);

	return 0;
}


//	Sets the Trident window's parent correctly when created and destroyed.
//
void
CProxyFrame::SetParent ( HWND hwndParent )
{
	// This may be called before the control has been drawn.
	if ( NULL != m_hWndObj )
	{
		HWND hwndOldParent = ::SetParent ( m_hWndObj, hwndParent );
		if ( NULL == hwndOldParent )
		{
			DWORD dwErr = 0;
			dwErr = GetLastError ();
		}
		_ASSERTE ( m_pSite );
		m_pSite->SetWindow ( hwndParent );
	}
}


//	Handles WM_SHOWWINDOW messages directed to the control.
//
void
CProxyFrame::Show ( WPARAM nCmdShow )
{
	// This may be called before the control has been drawn.
	// Hide or show the hosted Trident
	if ( NULL != m_hWndObj )
	{
		::ShowWindow ( m_hWndObj, (int)nCmdShow );
	}
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	ExecCommand mechanism
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Convert a command ID into a TriEdit command ID.
//	Some commands used to represent other command groups as well, thus the ppguidCmdGroup parameter.
//	While this does little now, it may be useful again in the future.
//
HRESULT
CProxyFrame::HrMapCommand(DHTMLEDITCMDID typeLibCmdID,
	ULONG* cmdID, const GUID** ppguidCmdGroup, BOOL* pbOutParam)
{

	_ASSERTE(cmdID);
	_ASSERTE(ppguidCmdGroup);
	_ASSERTE(pbOutParam);

	*cmdID = 0;
	*ppguidCmdGroup = NULL;
	*pbOutParam = FALSE;

	for (UINT i=0; i < sizeof(cmdMap)/sizeof(CommandMap); ++i)
	{
		if (typeLibCmdID == cmdMap[i].typeLibCmdID)
		{
			*cmdID = cmdMap[i].cmdID;
			*ppguidCmdGroup = &GUID_TriEditCommandGroup;
			*pbOutParam = cmdMap[i].bOutParam;

			return S_OK;
		}
	}

	return OLECMDERR_E_NOTSUPPORTED ;
}


//	Helper routine for calling Exec.
//
HRESULT
CProxyFrame::HrExecCommand(const GUID* pguidCmdGroup, ULONG ucmdID,
	OLECMDEXECOPT cmdexecopt, VARIANT* pVarIn, VARIANT* pVarOut)
{
	HRESULT hr = E_FAIL;
	LPOLECOMMANDTARGET pCommandTarget = NULL;

	// note that it is valid for pguidCmdGroup to be NULL

	_ASSERTE(m_pSite);

	if (NULL == m_pSite)
		return E_UNEXPECTED;

	pCommandTarget = m_pSite->GetCommandTarget();

	_ASSERTE(pCommandTarget);

	if (pCommandTarget != NULL)
	{
		hr = pCommandTarget->Exec(pguidCmdGroup, ucmdID, cmdexecopt, pVarIn, pVarOut);
	}

	return hr;
}


//	Main command dispatcher; called from the control's ExecCommand method.
//	Handle our unique commands here, pass the rest onto HrExecGenericCommands.
//
HRESULT
CProxyFrame::HrMapExecCommand(DHTMLEDITCMDID deCommand, OLECMDEXECOPT cmdexecopt,
	VARIANT* pVarInput, VARIANT* pVarOutput)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	ULONG ulMappedCommand = 0;
	const GUID* pguidCmdGroup = NULL;
	BOOL bOutParam = FALSE;

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;

	_ASSERTE(m_pSite);
	if (NULL == m_pSite)
		return E_UNEXPECTED;

	pCmdTgt = m_pSite->GetCommandTarget();
	_ASSERTE(pCmdTgt);

	if (NULL == pCmdTgt)
		return E_UNEXPECTED;

	// Its valid for pVarInput to be NULL

	if (FAILED(hr = HrMapCommand(deCommand, &ulMappedCommand, &pguidCmdGroup, &bOutParam)))
		return hr;

	AssureActivated();

	switch ( deCommand )
	{
		case DECMD_GETBLOCKFMTNAMES:
			hr = HrExecGetBlockFmtNames(pVarInput);
			break;

		case DECMD_INSERTTABLE:
			hr = HrExecInsertTable(pVarInput);
			break;

		case DECMD_GETFORECOLOR:
		case DECMD_GETBACKCOLOR:
			hr = HrExecGetColor(deCommand, ulMappedCommand, pVarOutput);
			break;

		case DECMD_SETFONTSIZE:
			hr = HrExecSetFontSize(pVarInput);
			break;

		case DECMD_GETBLOCKFMT:
			// Trident inconsistancy: GetBlockFmt fails if outparam isn't a BSTR.  GetFontName is OK with VT_EMPTY
			VariantChangeType ( pVarOutput, pVarOutput, 0, VT_BSTR );
			// Fall through; do not break!
		case DECMD_GETFONTNAME:
		case DECMD_GETFONTSIZE:
			hr = HrExecGenericCommands(pguidCmdGroup, ulMappedCommand, cmdexecopt, pVarOutput, TRUE );
			break;

		// Because our QueryStatus on DECMD_PROPERTIES returns TRUE for anything with IOleObject, executing the properties
		// verb can return an unexpected error.  Therefore, we ALWAYS return S_OK from this command to avoid causing VB and
		// script to terminate.
		case DECMD_PROPERTIES:
		{
			CComVariant	varParam;
			varParam.vt		= VT_I4;
			varParam.lVal	= OLEIVERB_PROPERTIES;
			hr = HrExecGenericCommands(pguidCmdGroup, ulMappedCommand, cmdexecopt, &varParam, FALSE );
			hr = S_OK;
		}
		break;

		default:
			hr = HrExecGenericCommands(pguidCmdGroup, ulMappedCommand, cmdexecopt, pVarInput, bOutParam);
			break;
	}

	if (FAILED(hr))
	{
		if (DISP_E_BADVARTYPE == hr || DISP_E_MEMBERNOTFOUND == hr)
		{
		// Map these Trident errors to something more general.
		// These errors can occur if Trident expected the element
		// it was trying to operate on to support certain interfaces.
		// The caller was trying to perform an operation not valid
		// for the current selection. Probably didn't call QueryStatus
		// first.

			hr = OLECMDERR_E_NOTSUPPORTED;
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	ExecCommand handler implementations
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Helper routine for calling Exec and dealing with results.
//
HRESULT
CProxyFrame::HrExecGenericCommands(const GUID* pguidCmdGroup, ULONG cmdID,
	OLECMDEXECOPT cmdexecopt, LPVARIANT pVarInput, BOOL bOutParam)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	LPVARIANT _pVar = NULL;
	VARIANT	varCopy;

	pCmdTgt = m_pSite->GetCommandTarget();

	if (pVarInput && V_VT(pVarInput) & VT_BYREF)
	{
		// convert VARIANTARGs to Variant for use by Trident
		// this occurs in VB if the user specified a basic type
		// as an arg, i.e., String or Long, instead of Variant

		VariantInit(&varCopy);
		if (FAILED(hr = VariantCopyInd(&varCopy, pVarInput)))
		{
			_ASSERTE(SUCCEEDED(hr));
			return hr;
		}

		_pVar = &varCopy;
	}
	else if (pVarInput)
		_pVar = pVarInput;

	if (bOutParam)
	{
		hr = pCmdTgt->Exec(pguidCmdGroup, cmdID, cmdexecopt, NULL, _pVar);
	}
	else
	{
		hr = pCmdTgt->Exec(pguidCmdGroup, cmdID, cmdexecopt, _pVar, NULL);
	}

	if (FAILED(hr))
		goto cleanup;

	// if a VARIANTARG was passed in for a command with output then
	// fill it in with the result from the Exec
	if (bOutParam && pVarInput && (V_VT(pVarInput) & VT_BYREF))
	{
		_ASSERTE(_pVar);	// _pVar should always be non NULL here
							// if there was an input arg that was byref,
							// then it should have been mapped to _pVar

		if (NULL == _pVar)
			return E_UNEXPECTED; // the catch all error return for "we are in a weird state"

		// if the type of return is different that the type the caller
		// passed in then do nothing and return
		if (V_VT(_pVar) != (V_VT(pVarInput) ^ VT_BYREF))
			return hr;

		switch(V_VT(_pVar))
		{
		case VT_BSTR:
			_ASSERTE(V_VT(pVarInput) == (VT_BSTR|VT_BYREF));

			if (V_BSTRREF(pVarInput))
				hr = SysReAllocString(V_BSTRREF(pVarInput), V_BSTR(_pVar));
			break;

		case VT_BOOL:
			_ASSERTE(V_VT(pVarInput) == (VT_BOOL|VT_BYREF));

			if (V_BOOLREF(pVarInput))
				*(V_BOOLREF(pVarInput)) = V_BOOL(_pVar);
			break;

		case VT_I4:
			_ASSERTE(V_VT(pVarInput) == (VT_I4|VT_BYREF));

			if (V_I4REF(pVarInput))
				*(V_I4REF(pVarInput)) = V_I4(_pVar);
			break;

		default:
			_ASSERTE(0);
			break;
		}
	}

cleanup:
	// Our documentation replaces E_FAIL with DE_E_UNEXPECTED: different values.
	if ( E_FAIL == hr )
	{
		hr = DE_E_UNEXPECTED;
	}

	return hr;
}


//	Handler for command DECMD_GETBLOCKFMTNAMES.
//	There are plenty of possible types of arrays to be handled.
//
HRESULT
CProxyFrame::HrExecGetBlockFmtNames(LPVARIANT pVarInput)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	VARIANT varArray;
	LPUNKNOWN pUnk = NULL;
	CComPtr<IDEGetBlockFmtNamesParam> piNamesParam;

	pCmdTgt = m_pSite->GetCommandTarget();

	if (NULL == pVarInput)
		return E_INVALIDARG;

	if (V_VT(pVarInput) == (VT_BYREF|VT_DISPATCH))
	{
		if (V_DISPATCHREF(pVarInput))
			pUnk = *(V_DISPATCHREF(pVarInput));
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == VT_DISPATCH)
	{
		if (V_DISPATCH(pVarInput))
			pUnk = V_DISPATCH(pVarInput);
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == (VT_BYREF|VT_UNKNOWN))
	{
		if (V_UNKNOWNREF(pVarInput))
			pUnk = *(V_UNKNOWNREF(pVarInput));
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == VT_UNKNOWN)
	{
		if (V_UNKNOWN(pVarInput))
			pUnk = V_UNKNOWN(pVarInput);
		else
			return E_INVALIDARG;
	}
	else
		return E_INVALIDARG;

	// This can happen in VB if an object that has not
	// been set with CreateObject has been passed in
	if (NULL == pUnk)
		return E_INVALIDARG;

	// Try to get the names object before
	// performing the command

	if (FAILED(hr = pUnk->QueryInterface(IID_IDEGetBlockFmtNamesParam, (LPVOID*) &piNamesParam)))
		return E_INVALIDARG;

	_ASSERTE((!piNamesParam) == FALSE);

	// Trident wants the vt to be specifically VT_ARRAY with
	// no type qualifer -- if you give one it fails even though
	// an array of BSTRs is returned

	VariantInit(&varArray);
	V_VT(&varArray) = VT_ARRAY;

	hr = pCmdTgt->Exec(&GUID_TriEditCommandGroup, IDM_TRIED_GETBLOCKFMTS,
		MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &varArray);

	if (FAILED(hr))
		goto cleanup;

	piNamesParam->put_Names(&varArray);

cleanup:

	return hr;
}


//	Handler for command DECMD_INSERTTABLE.
//
HRESULT
CProxyFrame::HrExecInsertTable(LPVARIANT pVarInput)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	VARIANT varTableArray;
	LPUNKNOWN pUnk = NULL;
	CComPtr<IDEInsertTableParam> piTableParam;

	pCmdTgt = m_pSite->GetCommandTarget();

	VariantInit(&varTableArray);

	if (NULL == pVarInput)
		return E_INVALIDARG;

	if (V_VT(pVarInput) == (VT_BYREF|VT_DISPATCH))
	{
		if (V_DISPATCHREF(pVarInput))
			pUnk = *(V_DISPATCHREF(pVarInput));
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == VT_DISPATCH)
	{
		if (V_DISPATCH(pVarInput))
			pUnk = V_DISPATCH(pVarInput);
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == (VT_BYREF|VT_UNKNOWN))
	{
		if (V_UNKNOWNREF(pVarInput))
			pUnk = *(V_UNKNOWNREF(pVarInput));
		else
			return E_INVALIDARG;
	}
	else if (V_VT(pVarInput) == VT_UNKNOWN)
	{
		if (V_UNKNOWN(pVarInput))
			pUnk = V_UNKNOWN(pVarInput);
		else
			return E_INVALIDARG;
	}
	else
		return E_INVALIDARG;

	// This can happen in VB if an object that has not
	// been set with CreateObject has been passed in
	if (NULL == pUnk)
		return E_INVALIDARG;

	if (FAILED(hr = pUnk->QueryInterface(IID_IDEInsertTableParam, (LPVOID*) &piTableParam)))
		return E_INVALIDARG;

	_ASSERTE((!piTableParam) == FALSE);

	if (FAILED(hr = HrGetTableSafeArray(piTableParam, &varTableArray)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}


	hr = pCmdTgt->Exec(&GUID_TriEditCommandGroup, IDM_TRIED_INSERTTABLE,
		MSOCMDEXECOPT_DONTPROMPTUSER, &varTableArray, NULL);

	return hr;
}


//	Hanlder for commands DECMD_GETFORECOLOR and DECMD_GETBACKCOLOR.
//	Reply with a string in the format #RRGGBB or an empty string.
//
HRESULT
CProxyFrame::HrExecGetColor(DHTMLEDITCMDID deCommand, ULONG ulMappedCommand, LPVARIANT pVarOutput)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	VARIANT varColorOut;
	TCHAR buf[32];
	WCHAR* oleStr = NULL;

	pCmdTgt = m_pSite->GetCommandTarget();

	if (NULL == pVarOutput)
		return E_INVALIDARG;

	// validate the command
	if (DECMD_GETFORECOLOR != deCommand && DECMD_GETBACKCOLOR != deCommand)
		return E_INVALIDARG;

	// validate the args
	if (V_VT(pVarOutput) == (VT_BYREF|VT_BSTR))
	{
		if (NULL == V_BSTRREF(pVarOutput))
			return E_INVALIDARG;
	}
	else if (V_VT(pVarOutput) == VT_BSTR)
	{
		if (NULL == V_BSTR(pVarOutput))
			return E_INVALIDARG;
	}
	else if (V_VT(pVarOutput) != (VT_EMPTY) && V_VT(pVarOutput) != (VT_NULL))
		return E_INVALIDARG;

	VariantInit(&varColorOut);
	V_VT(&varColorOut) = VT_I4;

	hr = pCmdTgt->Exec(&GUID_TriEditCommandGroup, ulMappedCommand,
		MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &varColorOut);

	// Trident will return VT_NULL if color selection
	// was mixed or no text is selected, we return empty
	// string ("") in that case.

	buf[0] = 0;

	if (VT_I4 == V_VT(&varColorOut))
	{
		ULONG ulColor = 0;
		ULONG r=0;
		ULONG g=0;
		ULONG b=0;

		ulColor = V_I4(&varColorOut);
		r = 0x000000ff & ulColor;
		g = (0x0000ff00 & ulColor) >> 8;
		b = (0x00ff0000 & ulColor) >> 16;

		wsprintf(buf, TEXT("#%02X%02X%02X"), r, g, b);
	}
	
	oleStr = T2OLE(buf);

	if (V_VT(pVarOutput) == (VT_BSTR|VT_BYREF))
		hr = SysReAllocString(V_BSTRREF(pVarOutput), oleStr);
	else if (V_VT(pVarOutput) == (VT_BSTR))
		hr = SysReAllocString(&(V_BSTR(pVarOutput)), oleStr);
	else if (V_VT(pVarOutput) == (VT_EMPTY) || V_VT(pVarOutput) == (VT_NULL))
	{
		V_VT(pVarOutput) = VT_BSTR;
		V_BSTR(pVarOutput) = SysAllocString(oleStr);
	}

	return hr;
}


//	Handler for command DECMD_SETFONTSIZE.
//
HRESULT
CProxyFrame::HrExecSetFontSize(LPVARIANT pVarInput)
{
	HRESULT hr = S_OK;
	LPOLECOMMANDTARGET pCmdTgt = NULL;
	VARIANT varSizeIn;
	

	pCmdTgt = m_pSite->GetCommandTarget();

	if (NULL == pVarInput)
		return E_INVALIDARG;

	VariantInit(&varSizeIn);

	if (FAILED(hr = VariantChangeType(&varSizeIn, pVarInput, 0, VT_I4)))
		return E_INVALIDARG;

	if (varSizeIn.lVal < 0 || varSizeIn.lVal > 7)
		return E_INVALIDARG;

	if (0 == varSizeIn.lVal)
		varSizeIn.lVal = varSizeIn.lVal + 1;


	hr = pCmdTgt->Exec(&GUID_TriEditCommandGroup, IDM_TRIED_FONTSIZE,
		MSOCMDEXECOPT_DONTPROMPTUSER, &varSizeIn, NULL);

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	QueryStatus mechanism
//
///////////////////////////////////////////////////////////////////////////////////////////

//	Map the control specific command ID to a TriEdit command ID and call QueryStatus.
//
HRESULT
CProxyFrame::HrMapQueryStatus( DHTMLEDITCMDID ucmdID, DHTMLEDITCMDF* cmdf)
{
	LPOLECOMMANDTARGET pCommandTarget = NULL;

	_ASSERTE(cmdf);

	HRESULT hr = E_FAIL;

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;

	if (NULL == cmdf)
		return E_INVALIDARG;

	*cmdf = (DHTMLEDITCMDF) 0;

	_ASSERTE(m_pSite);

	if (NULL == m_pSite)
		return E_UNEXPECTED;

	pCommandTarget = m_pSite->GetCommandTarget();
	_ASSERTE(pCommandTarget);

	if ( pCommandTarget != NULL )
	{

		AssureActivated ();

		ULONG cmdID = 0;
		const GUID* pguidCmdGroup = NULL;
		BOOL bOutParam = FALSE;

		if (SUCCEEDED(hr = HrMapCommand(ucmdID, &cmdID, &pguidCmdGroup, &bOutParam)))
		{
			MSOCMD msocmd;
			msocmd.cmdID = cmdID;
			msocmd.cmdf  = 0;

			hr = pCommandTarget->QueryStatus(pguidCmdGroup, 1, &msocmd, NULL);

			*cmdf = (DHTMLEDITCMDF) msocmd.cmdf;
		}
	}

	return hr;
}


//	General routine for determining the status of a command.
//	Should resolve to not supported, disabled, enabled, latched or ninched.
//
HRESULT
CProxyFrame::HrQueryStatus(const GUID* pguidCmdGroup, ULONG ucmdID, OLECMDF* cmdf)
{
	HRESULT hr = E_FAIL;

	_ASSERTE(cmdf);

	// Note that it is valid for pguidCmdGroup to be NULL

	if (NULL == cmdf)
		return E_INVALIDARG;

	*cmdf = (OLECMDF) 0;

	_ASSERTE(m_pSite);

	if ( m_pSite != NULL ) // m_pSite should always be set
	{
		LPOLECOMMANDTARGET pCommandTarget = m_pSite->GetCommandTarget();

		if ( pCommandTarget != NULL )
		{
			MSOCMD msocmd;
			msocmd.cmdID = ucmdID;
			msocmd.cmdf  = 0;

			hr = pCommandTarget->QueryStatus(pguidCmdGroup, 1, &msocmd, NULL);

			*cmdf = (OLECMDF) msocmd.cmdf;
		}
	}

	return hr;
}


//	A tragic FAT16 compatibility problem: file names in the specific form:
//	[a-zA-z]\:[^\\].+ cause various, severe problems.  NTFS "forgives".
//	We must detect these, both in file names and file:// URL and return an error.
//
BOOL
CProxyFrame::IsMissingBackSlash ( BSTR path, BOOL bfIsURL )
{
	BOOL bfMissing = FALSE;

	if ( bfIsURL )
	{
		WCHAR	wszFileProtocol[] = L"file://";
		int		cchProtocol		= wcslen ( wszFileProtocol );

		if ( 0 == _wcsnicmp ( path, wszFileProtocol, cchProtocol ) )
		{
			if ( OLECHAR(':') == path[cchProtocol+1] )
			{
				if ( OLECHAR('\\') != path[cchProtocol+2] )
				{
					bfMissing = TRUE;
				}
			}
		}
	}
	else
	{
		// Path name.  chec for drive letter, colon, non-backslash.
		if ( OLECHAR(':') == path[1] )
		{
			if ( OLECHAR('\\') != path[2] )
			{
				bfMissing = TRUE;
			}
		}
	}
	return bfMissing;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Control methods and properties
//
///////////////////////////////////////////////////////////////////////////////////////////

//	Handles NewDocument, LoadURL and LoadDocument control methods.
//	The document is loaded indirectly via the pluggable protocol handler.
//	If "path" is NULL, do NewDocument.  TestbfURL to see if it's a URL or UNC path.
//
HRESULT
CProxyFrame::LoadDocument(BSTR path, BOOL bfIsURL )
{
	USES_CONVERSION;

	HRESULT hr			= S_OK;
	UINT pathLen		= 0;

	AssureActivated ();	// This can set m_bstrLoadText as a side effect in unactivated controls!  Be careful!

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;

	m_bstrLoadText.Empty ();	// Clear the text to be added directly, or it will be used instead!
	m_bstrCurDocPath	= L"";
	m_bstrBaseURL		= L"";

	if (path)
		pathLen = ::SysStringLen(path);
	else
		pathLen = 0;

	// We've resetting the contents of the control.  Go back to default save mechanism.
	// If we load Unicode it will be reset.
	m_pSite->SetSaveAsUnicode ( FALSE );

	if (path && pathLen)
	{
		_ASSERTE(path);
		_ASSERTE(pathLen > 0);

		// First, look out for a wicked error: X:FileName with no '\' is BAD on FAT16.
		if ( IsMissingBackSlash ( path, bfIsURL ) )
		{
			hr = DE_E_PATH_NOT_FOUND;
			LoadBSTRDeferred ( m_bstrInitialDoc );
			goto error;
		}

		// Try to open the file -- stop the sequence
		// if its bogus or we don't have access
		if ( !bfIsURL )
		{
			if (FAILED(hr = m_pSite->HrTestFileOpen(path)))
			{
				LoadBSTRDeferred ( m_bstrInitialDoc );
				goto error;
			}
		}
		m_bfIsURL = bfIsURL;

		m_bstrCurDocPath = path;	// This needs to be set before loading, because base url is needed durring load.
		SetBaseURLFromCurDocPath ( bfIsURL );
		m_bfPreserveDirtyFlagAcrossBrowseMode = FALSE;

		CComPtr<IMoniker> srpMoniker;
		CComPtr<IBindCtx> srpBindCtx;
		CComQIPtr<IPersistMoniker, &IID_IPersistMoniker> srpPM (m_pUnkTriEdit);
		_ASSERTE ( srpPM );

		if ( srpPM )
		{
			CComBSTR	bstrProtocol = m_wszProtocolPrefix;
			bstrProtocol += L"(";
			bstrProtocol += path;
			bstrProtocol += L")";

#ifdef LATE_BIND_URLMON_WININET
			_ASSERTE ( m_pfnCreateURLMoniker );
			hr = (*m_pfnCreateURLMoniker)( NULL, bstrProtocol, &srpMoniker );
#else
			hr = CreateURLMoniker ( NULL, bstrProtocol, &srpMoniker );
#endif // LATE_BIND_URLMON_WININET

			_ASSERTE ( SUCCEEDED( hr ) );
			if ( SUCCEEDED ( hr ) )
			{
				hr = ::CreateBindCtx(NULL, &srpBindCtx);
				_ASSERTE ( SUCCEEDED( hr ) );
				if ( SUCCEEDED ( hr ) )
				{
					// Delete the cache entry before downloading.
					// This assures that loading, posting, and reloading works.
					// Bug 18544.
					// NOTE: Inexact match fails!  http://www.microsoft.com fails,
					// because this actually loads/caches a specific default page.
					if ( bfIsURL )
					{
						LPTSTR szURL = OLE2T ( m_bstrCurDocPath );
#ifdef LATE_BIND_URLMON_WININET
						_ASSERTE ( m_pfnDeleteUrlCacheEntry );
						(*m_pfnDeleteUrlCacheEntry)( szURL );
#else
						DeleteUrlCacheEntry ( szURL );
#endif // LATE_BIND_URLMON_WININET
					}
					m_bfIsLoading = TRUE;
					m_hrDeferredLoadError = S_OK;	// URLs: don't let Trident get the error!

					hr = srpPM->Load(FALSE, srpMoniker,  srpBindCtx, STGM_READ);

					if ( SUCCEEDED ( hr ) && FAILED ( m_hrDeferredLoadError ) )
					{
						hr = m_hrDeferredLoadError;	// In case we stashed a result
					}
					if ( FAILED ( hr ) )
					{
						m_bfIsLoading = FALSE;
					}
				}
			}
		}
	}
	else
	{
		if (FAILED(hr = LoadBSTRDeferred ( m_bstrInitialDoc )))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto error;
		}
	}

error:
	return hr;
}


//	Implements FilterSourceCode control method
//	Used to restore filtered content extracted directly from DOM.
//
HRESULT
CProxyFrame::FilterSourceCode ( BSTR bsSourceIn, BSTR* pbsSourceOut )
{
	HRESULT				hr;
	CComPtr<IStream>	spStreamIn;
	IStream*			piStreamOut;

	hr = m_pSite->HrBstrToStream(bsSourceIn, &spStreamIn);
	if ( SUCCEEDED ( hr ) )
	{
		if ( m_vbBrowseMode )
		{
			spStreamIn->AddRef ();
			piStreamOut = spStreamIn;
		}
		else
		{
			hr = m_pSite->HrFilter ( FALSE, spStreamIn, &piStreamOut, m_dwFilterOutFlags | dwFilterSourceCode);
		}
		if ( SUCCEEDED ( hr ) )
		{
			hr = m_pSite->HrStreamToBstr ( piStreamOut, pbsSourceOut );
			piStreamOut->Release ();
		}
	}
	return hr;
}


//	Implements the control's Print method
//
HRESULT
CProxyFrame::Print ( BOOL bfWithUI )
{
	AssureActivated ();

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;
	return HrExecCommand ( &GUID_TriEditCommandGroup, IDM_TRIED_PRINT,
		bfWithUI ? MSOCMDEXECOPT_PROMPTUSER : MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL );
}


//	Implements the control's Refresh method
//
HRESULT
CProxyFrame::RefreshDoc ()
{
	if ( NULL != m_hWndObj )
	{
		if ( ::IsWindow ( m_hWndObj ) )
		{
			::InvalidateRect ( m_hWndObj, NULL, TRUE );
			return S_OK;
		}
	}
	return S_FALSE;
}


//	Implements the control's SaveDocument method
//
HRESULT
CProxyFrame::SaveDocument(BSTR path)
{
	HRESULT hr = S_OK;
	ULONG pathLen = 0;

	if (FALSE == m_fActivated)
		return E_UNEXPECTED;

	_ASSERTE(GetState() == ESTATE_ACTIVATED);

	AssureActivated ();

	if (GetState() != ESTATE_ACTIVATED)
		return E_UNEXPECTED;

	_ASSERTE(path);

	if (path)
		pathLen = ::SysStringLen(path);
	else
		pathLen = 0;

	if (0 == pathLen)
		return E_INVALIDARG;

	_ASSERTE(pathLen);

	// First, look out for a wicked error: X:FileName with no '\' is BAD on FAT16.
	if ( IsMissingBackSlash ( path, FALSE ) )
	{
		return DE_E_PATH_NOT_FOUND;
	}

	hr = m_pSite->HrSaveToFile(path, m_dwFilterOutFlags);

	if ( SUCCEEDED ( hr ) )
	{
		m_bstrCurDocPath = path;
	}

	return hr;
}


//	Implements the control's SetContextMenu method
//	One routine handles javascript arrays, the other simple arrays.
//
HRESULT
CProxyFrame::SetContextMenu(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates)
{
	if (V_VT(pVarMenuStrings) == VT_DISPATCH || V_VT(pVarMenuStates) == VT_DISPATCH)
		return SetContextMenuDispEx(pVarMenuStrings, pVarMenuStates);
	else
		return SetContextMenuSA(pVarMenuStrings, pVarMenuStates);
}


// Get menu strings from SafeArray
//
HRESULT
CProxyFrame::SetContextMenuSA(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates)
{
	HRESULT hr = S_OK;
	SAFEARRAY* psaStrings = NULL;
	SAFEARRAY* psaStates = NULL;
    LONG lLBound, lUBound, lLBoundState, lUBoundState;

	if (NULL == pVarMenuStrings || NULL == pVarMenuStates)
		return E_INVALIDARG;

	if ((VT_ARRAY|VT_BSTR) != V_VT(pVarMenuStrings) &&
		((VT_ARRAY|VT_BSTR)|VT_BYREF) != V_VT(pVarMenuStrings) &&
		((VT_ARRAY|VT_VARIANT)|VT_BYREF) != V_VT(pVarMenuStrings) &&
		(VT_ARRAY|VT_VARIANT) != V_VT(pVarMenuStrings))
		return E_INVALIDARG;

	if ((VT_ARRAY|VT_I4) != V_VT(pVarMenuStates) &&
		((VT_ARRAY|VT_I4)|VT_BYREF) != V_VT(pVarMenuStates) &&
		((VT_ARRAY|VT_VARIANT)|VT_BYREF) != V_VT(pVarMenuStates) &&
		(VT_ARRAY|VT_VARIANT) != V_VT(pVarMenuStates))
		return E_INVALIDARG;

	if ((VT_ARRAY|VT_BSTR) == V_VT(pVarMenuStrings))
	{
		psaStrings = V_ARRAY(pVarMenuStrings);
	}
	if ((VT_ARRAY|VT_VARIANT) == V_VT(pVarMenuStrings))
	{
		psaStrings = V_ARRAY(pVarMenuStrings);
	}
	else if ((VT_ARRAY|VT_BSTR|VT_BYREF) == V_VT(pVarMenuStrings))
	{
		if (NULL == V_ARRAYREF(pVarMenuStrings))
			return E_INVALIDARG;

		psaStrings = *(V_ARRAYREF(pVarMenuStrings));
	}
	else if ((VT_ARRAY|VT_VARIANT|VT_BYREF) == V_VT(pVarMenuStrings))
	{
		if (NULL == V_ARRAYREF(pVarMenuStrings))
			return E_INVALIDARG;
		
		psaStrings = *(V_ARRAYREF(pVarMenuStrings));
	}

	if ((VT_ARRAY|VT_I4) == V_VT(pVarMenuStates))
	{
		psaStates = V_ARRAY(pVarMenuStates);
	}
	if ((VT_ARRAY|VT_VARIANT) == V_VT(pVarMenuStates))
	{
		psaStates = V_ARRAY(pVarMenuStates);
	}
	else if ((VT_ARRAY|VT_I4|VT_BYREF) == V_VT(pVarMenuStates))
	{
		if (NULL == V_ARRAYREF(pVarMenuStates))
			return E_INVALIDARG;

		psaStates = *(V_ARRAYREF(pVarMenuStates));
	}
	else if ((VT_ARRAY|VT_VARIANT|VT_BYREF) == V_VT(pVarMenuStates))
	{
		if (NULL == V_ARRAYREF(pVarMenuStates))
			return E_INVALIDARG;

		psaStates = *(V_ARRAYREF(pVarMenuStates));
	}


	if (NULL == psaStrings || NULL == psaStates)
		return E_INVALIDARG;

	SafeArrayGetLBound(psaStrings, 1, &lLBound);
	SafeArrayGetUBound(psaStrings, 1, &lUBound);

	SafeArrayGetLBound(psaStates, 1, &lLBoundState);
	SafeArrayGetUBound(psaStates, 1, &lUBoundState);

	if (lLBound != lLBoundState || lUBound != lUBoundState)
		return E_INVALIDARG;

	if (m_pMenuStrings)
	{
		SafeArrayDestroy(m_pMenuStrings);
		m_pMenuStrings = NULL;
	}

	if (m_pMenuStates)
	{
		SafeArrayDestroy(m_pMenuStates);
		m_pMenuStates = NULL;
	}

	// An empty array was passed in 
	// The context menu has been cleared
	if (lLBound ==lUBound )
		goto cleanup;

	if (FAILED(hr = SafeArrayCopy(psaStrings, &m_pMenuStrings)))
		goto cleanup;

	if (FAILED(hr = SafeArrayCopy(psaStates, &m_pMenuStates)))
		goto cleanup;

cleanup:

	if (FAILED(hr))
	{
		if (m_pMenuStrings)
		{
			SafeArrayDestroy(m_pMenuStrings);
			m_pMenuStrings = NULL;
		}

		if (m_pMenuStates)
		{
			SafeArrayDestroy(m_pMenuStates);
			m_pMenuStates = NULL;	
		}
	}

    return hr;
}


// Get menu strings from JScript array, or object that supports IDispatchEx
// For iterating through JScript arrays, we expect the elements
// to be accessable by ordinals starting at 0, i.e., a 0 based array
//
HRESULT
CProxyFrame::SetContextMenuDispEx(LPVARIANT pVarMenuStrings, LPVARIANT pVarMenuStates)
{
	HRESULT hr = S_OK;
	ULONG i=0;
	ULONG ulStringsLen = 0;
	ULONG ulStatesLen = 0;
	IDispatch* pdStrings = NULL;
	IDispatch* pdStates = NULL;
	IDispatchEx* pdexStrings = NULL;
	IDispatchEx* pdexStates = NULL;
	CDispExArray dispStrings;
	CDispExArray dispStates;
	VARIANT varString;
	VARIANT varState;
	SAFEARRAYBOUND rgsabound[1] = {0};
	LONG ix[1]					= {0};

	if (VT_DISPATCH != V_VT(pVarMenuStrings) || VT_DISPATCH != V_VT(pVarMenuStates))
		return E_INVALIDARG;

	VariantInit(&varString);
	VariantInit(&varState);

	pdStrings = V_DISPATCH(pVarMenuStrings);
	pdStates = V_DISPATCH(pVarMenuStates);

	_ASSERTE(pdStrings);
	_ASSERTE(pdStates);

	if (FAILED(hr = pdStrings->QueryInterface(IID_IDispatchEx, (LPVOID*) &pdexStrings)))
	{
		return E_INVALIDARG;
	}
	dispStrings.Attach(pdexStrings);

	if (FAILED(hr = pdStates->QueryInterface(IID_IDispatchEx, (LPVOID*) &pdexStates)))
	{
		return E_INVALIDARG;
	}
	dispStates.Attach(pdexStates);

	if (FAILED(dispStrings.HrGetLength(&ulStringsLen)))
		goto cleanup;

	if (FAILED(dispStates.HrGetLength(&ulStatesLen)))
		goto cleanup;

	// Make sure that arrays are equal length
	if (ulStringsLen != ulStatesLen)
		return E_INVALIDARG;

	if (m_pMenuStrings)
	{
		SafeArrayDestroy(m_pMenuStrings);
		m_pMenuStrings = NULL;
	}

	if (m_pMenuStates)
	{
		SafeArrayDestroy(m_pMenuStates);
		m_pMenuStates = NULL;
	}

	// An empty array was passed in 
	// The context menu has been cleared
	if (ulStringsLen <= 0)
		goto cleanup;

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = ulStringsLen;

	m_pMenuStrings = SafeArrayCreate(VT_BSTR, 1, rgsabound);	
	_ASSERTE(m_pMenuStrings);
	if (NULL == m_pMenuStrings)
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	m_pMenuStates = SafeArrayCreate(VT_I4, 1, rgsabound);	
	_ASSERTE(m_pMenuStates);
	if (NULL == m_pMenuStates)
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	// For iterating through JScript arrays, we expect the elements
	// to be accessable by ordinals starting at 0, i.e., a 0 based array
	hr = S_OK;
	for (i=0; i < ulStringsLen && hr != S_FALSE; i++)
	{		
		if (FAILED(hr = dispStrings.HrGetElement(i, &varString)))
			goto cleanup;

		if (FAILED(hr = dispStates.HrGetElement(i, &varState)))
			goto cleanup;

		if (VT_BSTR != V_VT(&varString) || VT_I4 != V_VT(&varState))
		{
			hr = E_INVALIDARG;
			goto cleanup;
		}

		ix[0] = i;
		if (FAILED(hr = SafeArrayPutElement(m_pMenuStrings, ix, (LPVOID) V_BSTR(&varString))))
			goto cleanup;

		if (FAILED(hr = SafeArrayPutElement(m_pMenuStates, ix, (LPVOID) &(V_I4(&varState)))))
			goto cleanup;

		VariantClear ( &varString );
		VariantClear ( &varState );
	}

cleanup:

	if (FAILED(hr))
	{
		if (m_pMenuStrings)
		{
			SafeArrayDestroy(m_pMenuStrings);
			m_pMenuStrings = NULL;
		}

		if (m_pMenuStates)
		{
			SafeArrayDestroy(m_pMenuStates);
			m_pMenuStates = NULL;	
		}
	}

    return hr;
}


//	DocumentTitle property implementation; read only.
//	Get the property from the HTML document.
//
HRESULT
CProxyFrame::GetDocumentTitle ( CComBSTR&  bstrTitle )
{
	HRESULT		hr = S_OK;
	DISPID		dispid;
	DISPPARAMS	dispparamsNoArgs = {NULL, NULL, 0, 0};
	CComVariant	varResult;

	CComPtr<IHTMLDocument2> piHtmlDoc = NULL;
	hr = HrGetDoc( &piHtmlDoc );

	if ( SUCCEEDED ( hr ) )
	{
		AssureActivated();

		hr = piHtmlDoc->GetIDsOfNames ( IID_NULL, &g_wszHTMLTitlePropName, 1, LOCALE_SYSTEM_DEFAULT, &dispid );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( FAILED ( hr ) )
		{
			return hr;
		}

		hr = piHtmlDoc->Invoke ( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
			&dispparamsNoArgs, &varResult, NULL, NULL );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( FAILED ( hr ) )
		{
			return hr;
		}
		
		hr = varResult.ChangeType ( VT_BSTR );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( FAILED ( hr ) )
		{
			return hr;
		}

		bstrTitle = varResult.bstrVal;
	}

	return hr;
}


//	Implements getting the control's BrowseMode property
//
HRESULT
CProxyFrame::GetBrowseMode ( VARIANT_BOOL  *pVal )
{
	*pVal = m_vbBrowseMode;
	return S_OK;
}


//	Implements setting the control's BrowseMode property
//
HRESULT
CProxyFrame::SetBrowseMode ( VARIANT_BOOL  newVal )
{
	HRESULT hr = S_FALSE;	// Indicates value was set, but actual mode was not changed.

	_ASSERTE ( m_pSite );

	// If we're still reading the property bag, just set the value, don't change the text;
	// it hasn't been loaded yet.
	if ( NULL == m_pSite->GetCommandTarget() )
	{
		m_vbBrowseMode = newVal;
		hr = S_OK;
	}
	else
	{
		if ( m_vbBrowseMode != newVal )
		{
			AssureActivated ();

			m_bfModeSwitched = TRUE;

			if ( newVal && m_pCtl->IsUserMode () )	// newVal means "switching to browse mode"
			{
				CComPtr<IStream>	spStream	= NULL;

				HrGetIsDirty ( m_bfPreserveDirtyFlagAcrossBrowseMode );
				hr = m_pSite->HrSaveToStreamAndFilter ( &spStream, m_dwFilterOutFlags );
				if ( SUCCEEDED ( hr ) )
				{
					m_bstrLoadText.Empty ();
					// Preserve the byte order mark, or else it will not be reloaded properly
					hr = m_pSite->HrStreamToBstr ( spStream, &m_bstrLoadText, TRUE );
				}
			}

			m_vbBrowseMode = newVal;

			// Let Trident know the ambient property has changed.
			CComQIPtr<IOleControl,&IID_IOleControl>spioc ( m_pSite->GetObjectUnknown() );
			if ( spioc )
			{
				m_bfIsLoading = TRUE;
				spioc->OnAmbientPropertyChange ( DISPID_AMBIENT_USERMODE );
			}
		}
	}
	return hr;
}


//	Implements getting the control's UseDivOnCarriageReturn property
//
HRESULT
CProxyFrame::GetDivOnCr ( VARIANT_BOOL  *pVal )
{
	*pVal = m_vbUseDivOnCr;
	return S_OK;
}


//	Implements setting the control's UseDivOnCarriageReturn property
//
HRESULT
CProxyFrame::SetDivOnCr ( VARIANT_BOOL  newVal )
{
	HRESULT		hr	= S_OK;
	CComVariant varDefBlock;

	m_vbUseDivOnCr = newVal;

	// Reinitialize if we haven't loaded our properties before this point.
	if ( READYSTATE_UNINITIALIZED == m_readyState )
	{
		// InitializeDocString takes m_vbUseDivOnCr into account
		InitializeDocString ();
	}
	return hr;
}


//	Implements getting the control's read-only Busy property
//
HRESULT
CProxyFrame::GetBusy ( VARIANT_BOOL *pVal )
{
#pragma warning(disable: 4310) // cast truncates constant value
	*pVal = ( m_bfIsLoading ) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	return S_OK;
}


// Implements setting the control's ActivateActiveXControls property
//
HRESULT
CProxyFrame::HrSetPropActivateControls(BOOL activateControls)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_NOACTIVATENORMALOLECONTROLS, !activateControls)))
			m_fActivateControls = activateControls;
	}
	else
		m_fActivateControls = activateControls;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ActivateActiveXControls property
//
HRESULT
CProxyFrame::HrGetPropActivateControls(BOOL& activateControls)
{
	HRESULT hr = S_OK;

	activateControls = m_fActivateControls;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements setting the control's ActivateApplets property
//
HRESULT
CProxyFrame::HrSetPropActivateApplets(BOOL activateApplets)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_NOACTIVATEJAVAAPPLETS, !activateApplets)))
			m_fActivateApplets = activateApplets;
	}
	else
		m_fActivateApplets = activateApplets;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ActivateApplets property
//
HRESULT
CProxyFrame::HrGetPropActivateApplets(BOOL& activateApplets)
{
	HRESULT hr = S_OK;

	activateApplets = m_fActivateApplets;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements setting the control's ActivateDTCs property
//
HRESULT
CProxyFrame::HrSetPropActivateDTCs(BOOL activateDTCs)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_NOACTIVATEDESIGNTIMECONTROLS, !activateDTCs)))
			m_fActivateDTCs = activateDTCs;
	}
	else
		m_fActivateDTCs = activateDTCs;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ActivateDTCs property
//
HRESULT
CProxyFrame::HrGetPropActivateDTCs(BOOL& activateDTCs)
{
	HRESULT hr = S_OK;

	activateDTCs = m_fActivateDTCs;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}



// Implements setting the control's ShowDetails property
//
HRESULT
CProxyFrame::HrSetPropShowAllTags(BOOL showAllTags)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_SHOWALLTAGS, showAllTags)))
			m_fShowAllTags = showAllTags;
	}
	else
		m_fShowAllTags = showAllTags;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ShowDetails property
//
HRESULT
CProxyFrame::HrGetPropShowAllTags(BOOL& showAllTags)
{
	HRESULT hr = S_OK;

	showAllTags = m_fShowAllTags;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements setting the control's ShowBorders property
//
HRESULT
CProxyFrame::HrSetPropShowBorders(BOOL showBorders)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		if (SUCCEEDED(hr = HrTridentSetPropBool(IDM_SHOWZEROBORDERATDESIGNTIME, showBorders)))
			m_fShowBorders = showBorders;
	}
	else
		m_fShowBorders = showBorders;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's ShowBorders property
//
HRESULT
CProxyFrame::HrGetPropShowBorders(BOOL& showBorders)
{
	HRESULT hr = S_OK;

	showBorders = m_fShowBorders;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements setting the control's Appearance property
//
HRESULT
CProxyFrame::HrSetDisplay3D(BOOL bVal)
{
	m_fDisplay3D = bVal;
	return S_OK;
}


// Implements getting the control's Appearance property
//
HRESULT
CProxyFrame::HrGetDisplay3D(BOOL& bVal)
{
	bVal = m_fDisplay3D;
	return S_OK;
}


// Implements setting the control's Scrollbars property
//
HRESULT
CProxyFrame::HrSetScrollbars(BOOL bVal)
{
	m_fScrollbars = bVal;
	return S_OK;
}


// Implements getting the control's Scrollbars property
//
HRESULT
CProxyFrame::HrGetScrollbars(BOOL& bVal)
{
	bVal = m_fScrollbars;
	return S_OK;
}


// Implements setting the control's ScrollbarAppearance property
//
HRESULT
CProxyFrame::HrSetDisplayFlatScrollbars(BOOL bVal)
{
	m_fDisplayFlatScrollbars = bVal;
	return S_OK;
}


// Implements getting the control's ScrollbarAppearance property
//
HRESULT
CProxyFrame::HrGetDisplayFlatScrollbars(BOOL& bVal)
{
	bVal = m_fDisplayFlatScrollbars;
	return S_OK;
}


// Implements setting the control's AbsoluteDropMode property
//
HRESULT
CProxyFrame::HrSetAbsoluteDropMode(BOOL dropMode)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		VARIANT var;

		VariantInit(&var);

		V_VT(&var) = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		V_BOOL(&var) = (dropMode) ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value

		if (SUCCEEDED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_SET_2D_DROP_MODE,
			MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL)))
			m_fAbsoluteDropMode = dropMode;
	}
	else
		m_fAbsoluteDropMode = dropMode;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's AbsoluteDropMode property
//
HRESULT
CProxyFrame::HrGetAbsoluteDropMode(BOOL& dropMode)
{
	HRESULT hr = S_OK;

	dropMode = m_fAbsoluteDropMode;
	return hr;
}


// Implements setting the control's SnapToGrid property
//
HRESULT
CProxyFrame::HrSetSnapToGrid(BOOL snapToGrid)
{
	HRESULT hr = S_OK;

	if (m_fActivated)
	{
		VARIANT var;
		POINT pt = {0};

		VariantInit(&var);
		if ( snapToGrid )
		{
			pt.y = m_ulSnapToGridY;
			pt.x = m_ulSnapToGridX;
		}
		else
		{
			pt.y = 0;
			pt.x = 0;
		}

		V_VT(&var) = VT_BYREF;
		V_BYREF(&var) = &pt;

		if (SUCCEEDED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_SET_ALIGNMENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL)))
			m_fSnapToGrid = snapToGrid;

	}
	else
		m_fSnapToGrid = snapToGrid;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's SnapToGrid property
//
HRESULT
CProxyFrame::HrGetSnapToGrid(BOOL& snapToGrid)
{
	HRESULT hr = S_OK;

	snapToGrid = m_fSnapToGrid;
	return hr;
}


// Implements setting the control's SnapToGridX property
//
HRESULT
CProxyFrame::HrSetSnapToGridX(LONG snapToGridX)
{
	HRESULT hr = S_OK;

	if ( 0 >= snapToGridX )
	{
		return DE_E_INVALIDARG;
	}

	if (m_fActivated)
	{
		VARIANT var;
		POINT pt = {0};

		VariantInit(&var);

		pt.x = snapToGridX;
		pt.y = m_ulSnapToGridY;

		V_VT(&var) = VT_BYREF;
		V_BYREF(&var) = &pt;

		if (SUCCEEDED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_SET_ALIGNMENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL)))
			m_ulSnapToGridX = snapToGridX;
	}
	else
		m_ulSnapToGridX = snapToGridX;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's SnapToGridX property
//
HRESULT
CProxyFrame::HrGetSnapToGridX(LONG& snapToGridX)
{
	HRESULT hr = S_OK;

	snapToGridX = m_ulSnapToGridX;
	return hr;
}


// Implements setting the control's SnapToGridY property
//
HRESULT
CProxyFrame::HrSetSnapToGridY(LONG snapToGridY)
{
	HRESULT hr = S_OK;

	if ( 0 >= snapToGridY )
	{
		return DE_E_INVALIDARG;
	}

	if (m_fActivated)
	{
		VARIANT var;
		POINT pt = {0};

		VariantInit(&var);
		pt.y = snapToGridY;
		pt.x = m_ulSnapToGridX;

		V_VT(&var) = VT_BYREF;
		V_BYREF(&var) = &pt;

		if (SUCCEEDED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_SET_ALIGNMENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, &var, NULL)))
			m_ulSnapToGridY = snapToGridY;
	}
	else
		m_ulSnapToGridY = snapToGridY;

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


// Implements getting the control's SnapToGridY property
//
HRESULT
CProxyFrame::HrGetSnapToGridY(LONG& snapToGridY)
{
	HRESULT hr = S_OK;

	snapToGridY = m_ulSnapToGridY;
	return hr;
}


// Implements setting the control's DocumentHTML property
//
HRESULT
CProxyFrame::HrSetDocumentHTML(BSTR bVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(bVal);

	if (NULL == bVal)
		return E_INVALIDARG;

	if (m_pCtl->IsUserMode ())
	{
		hr = DE_E_UNEXPECTED;

		AssureActivated ();
		if ( m_fActivated )
		{
			m_bstrBaseURL = L"";
			m_bfPreserveDirtyFlagAcrossBrowseMode = FALSE;
			if ( 0 == SysStringLen ( bVal ) )
			{
				CComBSTR bstrMT = GetInitialHTML ();
				hr = LoadBSTRDeferred ( bstrMT );
			}
			else
			{
				hr = LoadBSTRDeferred ( bVal );
			}

			if ( FAILED ( hr ) )
			{
				goto error;
			}

			// We've reset the contents of the control.  Go back to default save mechanism.
			m_pSite->SetSaveAsUnicode ( FALSE );
		}
	}

error:

	return hr;
}


// Implements getting the control's DocumentHTML property
//
HRESULT
CProxyFrame::HrGetDocumentHTML(BSTR* bVal)
{
	HRESULT hr			= S_OK;
	BOOL	bfWasDirty	= FALSE;

	_ASSERTE(bVal);

	if (NULL == bVal)
		return E_INVALIDARG;

	if ( m_bfIsLoading )
		return DE_E_UNEXPECTED;	// This is invalid while document is still loading.

	if ( FAILED ( hr = m_pSite->HrIsDirtyIPersistStreamInit(bfWasDirty) ) )
	{
		_ASSERTE ( SUCCEEDED ( hr ) );
		bfWasDirty = FALSE;	// what else can we do in a situation like this?
	}

	AssureActivated ();

	if (m_fActivated)
	{
		_ASSERTE(m_pSite);

		hr = m_pSite->HrSaveToBstr(bVal, m_dwFilterOutFlags );

		// Preserve original dirty state.
		if ( bfWasDirty )
		{
			SetDirtyFlag ( TRUE );
		}
	}

	return hr;
}


// Implements setting the control's SourceCodePreservation property
//
HRESULT
CProxyFrame::HrSetPreserveSource(BOOL bVal)
{
	m_fPreserveSource = bVal;
	if (m_fPreserveSource)
		m_dwFilterFlags = filterAll;
	else
		m_dwFilterFlags = filterDTCs | filterASP;

	return S_OK;
}


// Implements getting the control's SourceCodePreservation property
//
HRESULT
CProxyFrame::HrGetPreserveSource(BOOL& bVal)
{
	bVal = m_fPreserveSource;
	return S_OK;
}


// Implements getting the control's read-only IsDirty property
//
HRESULT
CProxyFrame::HrGetIsDirty(BOOL& bVal)
{
	HRESULT hr = S_OK;

	bVal = FALSE;

	AssureActivated ();

	if (m_fActivated)
	{
		hr = m_pSite->HrIsDirtyIPersistStreamInit(bVal);
	}

	return hr;
}


//	Implements getting the BaseURL property
//
HRESULT
CProxyFrame::GetBaseURL ( CComBSTR& bstrBaseURL )
{
	AssureActivated ();

	if ( NULL == m_bstrBaseURL.m_str )
	{
		bstrBaseURL = L"";
	}
	else
	{
		bstrBaseURL = m_bstrBaseURL;
	}
	return S_OK;
}


//	Implements setting the BaseURL property.
//	NOTE:
//	The BaseURL can't be (effectively) changed if there's a <BASE HREF=XXX> tag in
//	the document.  Our pluggable Protocol's CombineURL is never called in this case,
//	so don't misguide the user by changing the property.
//
//	Pay attention to m_bfBaseURLFromBASETag before calling to set the value from
//	the routine parsing the <BASE> tag!
//
HRESULT
CProxyFrame::SetBaseURL ( CComBSTR& bstrBaseURL )
{
	HRESULT hr = S_OK;

	_ASSERTE ( bstrBaseURL );

	// Non-persisted property.  Ignore if not in UserMode.
	if ( m_pCtl->IsUserMode () )
	{
		if ( m_bfBaseURLFromBASETag )
		{
			return S_FALSE;
		}
		else
		{
			if ( NULL == m_bstrBaseURL.m_str )
			{
				m_bstrBaseURL = L"";
			}

			// If this test succeedes, the user has done something like x.BaseURL = x.DOM.url or
			// x.BaseURL = y.DOM.url.
			// Response: bstrBaseURL may be the bare protocol prefix, or a prefix with a URL attached
			// for example: dhtmled0:(http://www.microsoft.com).
			// Strip off the prefix and parens (if they exist) and use the interior URL.
			if ( 0 == _wcsnicmp ( bstrBaseURL.m_str, g_wszProtocolPrefix, wcslen ( g_wszProtocolPrefix ) ) )
			{
				CComBSTR bstrNew = bstrBaseURL.m_str;

				// There must be a colon; it would be possibe to have a legitimate base url beginning with g_wszProtocolPrefix
				WCHAR* pwcURL = wcschr ( bstrNew, (WCHAR)':' );
				if ( NULL != pwcURL )
				{
					// Find the first open paren:
					pwcURL = wcschr ( pwcURL, (WCHAR)'(' );
					
					if ( NULL == pwcURL )
					{
						bstrBaseURL = L"";	// No (...)? Set the Base to empty.  Input must have been bare protocol ID.
					}
					else
					{
						pwcURL++;	// Step past the paren.

						// Strip of dhtmledXXX:( ...to... ) and set the BaseURL to what remains.
						_ASSERTE ( (WCHAR)')' == pwcURL[wcslen(pwcURL)-1] );
						if ( (WCHAR)')' == pwcURL[wcslen(pwcURL)-1] )
						{
							pwcURL[wcslen(pwcURL)-1] = (WCHAR)'\0';
							bstrBaseURL = pwcURL;
						}
						else
						{
							// Unexpected:  ill formed pluggable protocol id:
							// starts with dhtml[n[n]]:( but does not end with ).
							// If we skipped it, we would crash.  Best to use an empty base URL.
							bstrBaseURL = L"";
						}
					}
				}
			}

			if ( 0 != wcscmp ( m_bstrBaseURL.m_str, bstrBaseURL.m_str ) )
			{
				m_bstrBaseURL = bstrBaseURL;
				m_bfIsLoading = TRUE;

				// Can't Exec without a command target:
				if ( NULL != m_pSite->GetCommandTarget() )
				{
					// Reload the page, revaluating relative links.
					hr = HrExecCommand(&CGID_MSHTML, IDM_REFRESH, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
				}
			}
		}
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Accelerator handler implementations
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Nudge accelerator handler
//	Nudge the selection in the given direction by one pixle if SnaptoGrid is off, or by
//	the SnaptoGridX/Y quantity if SnapToGrid is on.
//
HRESULT
CProxyFrame::HrNudge(DENudgeDirection dir)
{
	HRESULT		hr		= S_FALSE;
	OLECMDF		cmdf	= (OLECMDF) 0;
	VARIANT		var;
	LPVARIANT	pVarIn	= &var;
	LONG		lXDelta	= m_fSnapToGrid ? m_ulSnapToGridX : 1;
	LONG		lYDelta	= m_fSnapToGrid ? m_ulSnapToGridY : 1;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_NUDGE_ELEMENT, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		LPPOINT lpPoint = new POINT;

		if (NULL == lpPoint)
		{
			hr = E_OUTOFMEMORY;
			goto cleanup;
		}
		_ASSERTE(lpPoint);

		lpPoint->x = 0;
		lpPoint->y = 0;

		// Set increment to snap to absolute grid, not relative grid.
		// Find the selections current position and set increment modulo that position.
		// This assures the first nudge snaps to a grid corner.
		if ( m_fSnapToGrid )
		{
			POINT	ptSelPos;
			if ( SUCCEEDED ( GetSelectionPos ( &ptSelPos ) ) )
			{
				LONG lXNorm = ptSelPos.x % lXDelta;
				LONG lYNorm = ptSelPos.y % lYDelta;
				lXDelta = lXNorm ? lXNorm : lXDelta;
				lYDelta = lYNorm ? lYNorm : lYDelta;
			}
		}

		switch(dir)
		{
		case deNudgeUp:
			{
				lpPoint->x = 0;
				lpPoint->y = -lYDelta;
			}
			break;

		case deNudgeDown:
			{
				lpPoint->x = 0;
				lpPoint->y = lYDelta;
			}
			break;

		case deNudgeLeft:
			{
				lpPoint->x = -lXDelta;
				lpPoint->y = 0;
			}
			break;

		case deNudgeRight:
			{
				lpPoint->x = lXDelta;
				lpPoint->y = 0;
			}
			break;

		default: // move right by default
			{
				lpPoint->x = lXDelta;
				lpPoint->y = 0;
			}
			break;
		}

		VariantInit(pVarIn);
		V_VT(pVarIn) = VT_BYREF;
		V_BYREF(pVarIn) = lpPoint;

		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_NUDGE_ELEMENT, MSOCMDEXECOPT_DONTPROMPTUSER, pVarIn, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}
	else
		hr = S_FALSE;

cleanup:
	return hr;
}


//	Accelerator handler
//	Toggle the absolute positioned property of the selected object
//
HRESULT
CProxyFrame::HrToggleAbsolutePositioned()
{
	HRESULT hr = S_FALSE;
	OLECMDF cmdf = (OLECMDF) 0;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_MAKE_ABSOLUTE, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_MAKE_ABSOLUTE,
			MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}

cleanup:
	return hr;
}


//	Accelerator handler
//	Make a link out of the current selection (with UI.)
//
HRESULT
CProxyFrame::HrHyperLink()
{
	HRESULT hr = S_FALSE;
	OLECMDF cmdf = (OLECMDF) 0;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_HYPERLINK, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_HYPERLINK,
			MSOCMDEXECOPT_PROMPTUSER, NULL, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}

cleanup:
	return hr;
}


//	Accelerator handler
//	Increase the indent of the current selection.
//
HRESULT
CProxyFrame::HrIncreaseIndent()
{
	HRESULT hr = S_FALSE;
	OLECMDF cmdf = (OLECMDF) 0;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_INDENT, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_INDENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}

cleanup:
	return hr;
}


//	Accelerator handler
//	Decrease the indent of the current selection.
//
HRESULT
CProxyFrame::HrDecreaseIndent()
{
	HRESULT hr = S_FALSE;
	OLECMDF cmdf = (OLECMDF) 0;

	if (FAILED(hr = HrQueryStatus(&GUID_TriEditCommandGroup, IDM_TRIED_OUTDENT, &cmdf)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	if (cmdf & OLECMDF_SUPPORTED && cmdf & OLECMDF_ENABLED)
	{
		if (FAILED(hr = HrExecCommand(&GUID_TriEditCommandGroup, IDM_TRIED_OUTDENT,
			MSOCMDEXECOPT_DONTPROMPTUSER, NULL, NULL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}

		hr = S_OK;
	}

cleanup:
	return hr;
}


//	Check for and handle control-specific accelerators.  If none is found, call TriEdit to handle it.
//	
HRESULT
CProxyFrame::HrHandleAccelerator(LPMSG lpmsg)
{
	HRESULT hr = S_FALSE;
	BOOL fControl = (0x8000 & GetKeyState(VK_CONTROL));
	BOOL fShift = (0x8000 & GetKeyState(VK_SHIFT));
	BOOL fAlt = (0x8000 & GetKeyState(VK_MENU));

    if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_UP)
	{
		hr = HrNudge(deNudgeUp);
	}
    else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_DOWN)
	{
		hr = HrNudge(deNudgeDown);
	}
    else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_LEFT)
	{
		hr = HrNudge(deNudgeLeft);
	}
    else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_RIGHT)
	{
		hr = HrNudge(deNudgeRight);
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 'K' && fControl)
	{
		hr = HrToggleAbsolutePositioned();
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 'L' && fControl && !fAlt)
	{
		hr = HrHyperLink();
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 'T' && !fShift && fControl)
	{
		hr = HrIncreaseIndent();
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == 'T' && fShift && fControl)
	{
		hr = HrDecreaseIndent();
	}
	else if (lpmsg->message == WM_KEYDOWN && lpmsg->wParam == VK_TAB && fControl)
	{
		// Process control-tab keys as belonging to the container; this allows the user
		// to tab out of the control in non-MDI apps.  MDI uses control-tab to switch
		// windows, thus these apps (like VID) do not pass them to us.
		IOleControlSite* piControlSite = m_pCtl->GetControlSite ();
		_ASSERTE ( piControlSite );
		if ( NULL != piControlSite )
		{
			// Eat the control key, but preserve shift to perform reverse tabbing.
			// KEYMOD_SHIFT = 0x00000001, but isn't defined in any header...
			DWORD dwModifiers = fShift ? 1 : 0;

			hr = piControlSite->TranslateAccelerator ( lpmsg, dwModifiers );
		}
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	BaseURL helper routines
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Override the default BaseURL if there is one or more <BASE HREF=...> tags
//	in the document.  If successful, set m_bfBaseURLFromBASETag to TRUE
//	If multiple BASE tags exist, simply use the last one.
//	Equivilent script:  baseurl = document.all.tags("BASE")[<LAST>].href,
//	where <LAST> is derived.
//
HRESULT
CProxyFrame::SetBaseURLFromBaseHref ()
{
	HRESULT		hr	= S_OK;
	CComBSTR	bstrBase;

	if ( !m_bfBaseURLFromBASETag )
	{
		if ( SUCCEEDED ( hr ) )
		{
			CComPtr<IHTMLDocument2> spHtmlDoc = NULL;
			hr = HrGetDoc( &spHtmlDoc );
			if ( spHtmlDoc && SUCCEEDED ( hr ) )
			{
				CComPtr<IHTMLElementCollection> spAll = NULL;
				hr = spHtmlDoc->get_all ( &spAll );
				if ( spAll && SUCCEEDED ( hr ) )
				{
					CComVariant varTag		= L"BASE";
					IDispatch*	piDispTags	= NULL;

					hr = spAll->tags ( varTag, &piDispTags );
					if ( piDispTags && SUCCEEDED ( hr ) )
					{
						CComQIPtr<IHTMLElementCollection, &IID_IHTMLElementCollection> spBases (piDispTags);
						piDispTags->Release ();
						piDispTags = NULL;
						if ( spBases )
						{
							long	cBases = 0;
							hr = spBases->get_length ( &cBases );
							if ( SUCCEEDED ( hr ) && ( 0 != cBases ) )
							{
								CComVariant varName;
								varName.vt = VT_I2;

								for ( varName.iVal = 0; varName.iVal < cBases; varName.iVal++ )
								{
									IDispatch*	piDispBase = NULL;
									CComVariant varValue;

									hr = spBases->item ( varName, varName, &piDispBase );
									if ( piDispBase && SUCCEEDED ( hr ) )
									{
										CComQIPtr<IHTMLElement, &IID_IHTMLElement> spElem ( piDispBase );
										piDispBase->Release ();
										piDispBase = NULL;

										if ( spElem )
										{
											varValue.Clear ();
											hr = spElem->getAttribute ( L"HREF", FALSE, &varValue );
											if ( SUCCEEDED ( hr ) )
											{
												hr = varValue.ChangeType ( VT_BSTR );
												if ( SUCCEEDED ( hr ) )
												{
													if ( 0 != SysStringLen ( varValue.bstrVal ) )
													{
														bstrBase = varValue.bstrVal;
													}
												}
											}
										}
									}
								}
								if ( 0 != bstrBase.Length () )
								{
									hr = SetBaseURL ( bstrBase );	// This clears m_bfBaseURLIsDefault
									m_bfBaseURLFromBASETag = TRUE;
								}
							}
						}
					}
				}
			}
		}
	}
	return hr;
}


//	Set the m_bstrBaseURL value using m_bstrCurDocPath.
//	With URLs, it may be impossible to be certain about the correct BaseURL,
//	so make an intellegent guess.  With files, it should be deterministic.
//	
HRESULT
CProxyFrame::SetBaseURLFromCurDocPath ( BOOL bfIsURL )
{
	m_bfBaseURLFromBASETag = FALSE;	// We're reloading: whipe this out.
	if ( bfIsURL )
	{
		return SetBaseURLFromURL ( m_bstrCurDocPath );
	}
	else
	{
		return SetBaseURLFromFileName ( m_bstrCurDocPath );
	}
}


//	Given a URL_COMPONENTS with nScheme set to INTERNET_SCHEME_FILE,
//	modify the path part to reflect the base path, reconstruct the URL,
//	and set m_bstrBaseURL.
//	Separators may be \ or /.
//
HRESULT
CProxyFrame::SetBaseUrlFromFileUrlComponents ( URL_COMPONENTS & urlc )
{
	TCHAR*	pszPath;
	BOOL	bfBackSlash	= TRUE;
	HRESULT	hr			= S_OK;

	_ASSERTE ( INTERNET_SCHEME_FILE == urlc.nScheme );
	_ASSERTE ( urlc.dwUrlPathLength );
	if ( urlc.dwUrlPathLength <= 0)
	{
		return E_UNEXPECTED;
	}
	pszPath = new TCHAR [urlc.dwUrlPathLength + 3];	// Extra room for \0, dot, and /.
	if ( NULL != pszPath )
	{
		TCHAR	c		= 0;
		int		iPos	= 0;

		// Scan backwards and modify in copy (never in BSTR, please) for beginning, '/' or '\'
		memcpy ( pszPath, urlc.lpszUrlPath, ( urlc.dwUrlPathLength + 1 ) * sizeof(TCHAR) );
		for ( iPos = urlc.dwUrlPathLength - 1; iPos >= 0; iPos-- )
		{
			c = pszPath[iPos];
			pszPath[iPos] = '\0';	// Delete first, ask questions later.  '\' must go.
			if ( '\\' == c )
			{
				break;
			}
			if ( '/' == c )
			{
				bfBackSlash = FALSE;
				break;
			}
		}

		// Space was reserved for an additional two characters, if needed.
		// If empty, add a dot.
		if ( 0 == _tcslen ( pszPath ) )
		{
			_tcscat ( pszPath, TEXT(".") );
		}
		// Add a / or \.
		if ( bfBackSlash )
		{
			_tcscat ( pszPath, TEXT("\\") );
		}
		else
		{
			_tcscat ( pszPath, TEXT("/") );
		}

		urlc.lpszUrlPath = pszPath;
		urlc.dwUrlPathLength = _tcslen ( pszPath );

		DWORD	dwLen = 0;
#ifdef LATE_BIND_URLMON_WININET
		_ASSERTE ( m_pfnInternetCreateUrl );
		(*m_pfnInternetCreateUrl)( &urlc, 0, NULL, &dwLen );	// Get the size required.
#else
		InternetCreateUrl ( &urlc, 0, NULL, &dwLen );	// Get the size required.
#endif // LATE_BIND_URLMON_WININET

		_ASSERTE ( 0 != dwLen );
		TCHAR* pszURL = new TCHAR [ dwLen + 1 ];
		_ASSERTE ( pszURL );
		if ( NULL != pszURL )
		{
			// Incredibly, on Win98, the URL is terminated with a single byte \0.
			// Intializing this buffer to zero assures full termination of the string.
			dwLen += 1;
			memset ( pszURL, 0, sizeof(TCHAR) * dwLen );
#ifdef LATE_BIND_URLMON_WININET
			if ( (*m_pfnInternetCreateUrl)( &urlc, 0, pszURL, &dwLen ) )
#else
			if ( InternetCreateUrl ( &urlc, 0, pszURL, &dwLen ) )
#endif // LATE_BIND_URLMON_WININET
			{
				m_bstrBaseURL = pszURL;
			}
			else
			{
				hr = HRESULT_FROM_WIN32 ( GetLastError () );
			}
			delete [] pszURL;
		}

		delete [] pszPath;
	}
	else
	{
		return E_FAIL;
	}

	return hr;
}


//	The most complicated scenario for "guessing" at the base URL.
//	URLs like http://www.x.com/stuff could be either a file or a directory;
//	a default page might actually be loaded.  We guess based on whether or
//	not the last item in the path contains a period.  If so, we eliminate it.
//	We make sure the path ends with a '/'.
//
HRESULT
CProxyFrame::SetBaseUrlFromUrlComponents ( URL_COMPONENTS & urlc )
{
	_ASSERTE ( INTERNET_SCHEME_FILE != urlc.nScheme );

	BOOL	bfPeriodIncluded	= FALSE;
	HRESULT	hr					= S_OK;

	if ( 0 == urlc.dwSchemeLength )
	{
		m_bstrBaseURL = L"";
		return S_FALSE;
	}

	// Scan backwards over path for beginning, '/'
	TCHAR	c		= 0;
	int		iPos	= 0;

	for ( iPos = urlc.dwUrlPathLength - 1; iPos >= 0; iPos-- )
	{
		c = urlc.lpszUrlPath[iPos];
		if ( '/' == c )
		{
			break;
		}
		if ( '.' == c )
		{
			bfPeriodIncluded = TRUE;
		}
	}

	if ( bfPeriodIncluded )
	{
		if ( 0 > iPos ) iPos = 0;
		urlc.lpszUrlPath[iPos] = '\0';	// Truncate at the '/', or beginning
		urlc.dwUrlPathLength = _tcslen ( urlc.lpszUrlPath );
	}

	// Recreate the URL:
	DWORD	dwLen = 0;
#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( m_pfnInternetCreateUrl );
	(*m_pfnInternetCreateUrl)( &urlc, 0, NULL, &dwLen );	// Get the size required.
#else
	InternetCreateUrl ( &urlc, 0, NULL, &dwLen );	// Get the size required.
#endif // LATE_BIND_URLMON_WININET

	_ASSERTE ( 0 != dwLen );
	TCHAR* pszURL = new TCHAR [ dwLen + 1 ];
	_ASSERTE ( pszURL );
	if ( NULL != pszURL )
	{
		dwLen += 1;
		memset ( pszURL, 0, sizeof(TCHAR) * dwLen );
#ifdef LATE_BIND_URLMON_WININET
		if ( (*m_pfnInternetCreateUrl)( &urlc, 0, pszURL, &dwLen ) )
#else
		if ( InternetCreateUrl ( &urlc, 0, pszURL, &dwLen ) )
#endif
		{
			m_bstrBaseURL = pszURL;

			// Append a '/' if needed.
			WCHAR wc = m_bstrBaseURL.m_str[m_bstrBaseURL.Length () - 1];
			if ( ( WCHAR('/') != wc ) && ( NULL != urlc.lpszHostName ) )	// hostname: special case for user pluggable protocols
			{
				m_bstrBaseURL += L"/";
			}
		}
		else
		{
			hr = HRESULT_FROM_WIN32 ( GetLastError () );
		}
		delete [] pszURL;
	}
	return hr;
}


//	Crack the URL, determine if it's a file scheme or other, and call the appropriate handler.
//
HRESULT
CProxyFrame::SetBaseURLFromURL ( const CComBSTR& bstrURL )
{
	USES_CONVERSION;

	HRESULT			hr	= S_OK;
	URL_COMPONENTS	urlc;
	TCHAR			*ptszScheme		= NULL;
	TCHAR			*ptszHostName	= NULL;
	TCHAR			*ptszUrlPath	= NULL;
	BOOL			fSuccess		= FALSE;
	TCHAR*			tszURL			= NULL;

	_ASSERTE ( 0 != bstrURL.Length () );

	tszURL = OLE2T ( bstrURL );
	_ASSERTE ( tszURL );
	if ( NULL == tszURL )
	{
		return E_OUTOFMEMORY;
	}

	memset ( &urlc, 0, sizeof ( urlc ) );
	urlc.dwStructSize		= sizeof ( urlc );
	urlc.dwSchemeLength		= 1;
	urlc.dwHostNameLength	= 1;
	urlc.dwUrlPathLength	= 1;

#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( m_pfnInternetCrackUrl );
	fSuccess = (*m_pfnInternetCrackUrl)( tszURL, 0, 0, &urlc );
#else
	fSuccess = InternetCrackUrl ( tszURL, 0, 0, &urlc );
#endif // LATE_BIND_URLMON_WININET

	if ( !fSuccess )
	{
		return E_FAIL;
	}

	if ( 0 != urlc.dwSchemeLength )
	{
		urlc.dwSchemeLength++;
		ptszScheme		= new TCHAR[urlc.dwSchemeLength];
		urlc.lpszScheme	= ptszScheme;
		if ( NULL == ptszScheme )
			goto ONERROR;
	}
	if ( 0 != urlc.dwHostNameLength )
	{
		urlc.dwHostNameLength++;
		ptszHostName		= new TCHAR[urlc.dwHostNameLength];
		urlc.lpszHostName	= ptszHostName;
		if ( NULL == ptszHostName )
			goto ONERROR;
	}
	if ( 0 != urlc.dwUrlPathLength )
	{
		urlc.dwUrlPathLength++;
		ptszUrlPath			= new TCHAR[urlc.dwUrlPathLength];
		urlc.lpszUrlPath	= ptszUrlPath;
		if ( NULL == ptszUrlPath )
			goto ONERROR;
	}

#ifdef LATE_BIND_URLMON_WININET
	fSuccess = (*m_pfnInternetCrackUrl)( tszURL, 0, 0, &urlc );
#else
	fSuccess = InternetCrackUrl ( tszURL, 0, 0, &urlc );
#endif
	
	if ( fSuccess )
	{
		if ( INTERNET_SCHEME_FILE == urlc.nScheme )
		{
			hr = SetBaseUrlFromFileUrlComponents ( urlc );
		}
		else
		{
			hr = SetBaseUrlFromUrlComponents ( urlc );
		}
	}

ONERROR:
	if ( ptszScheme )
		delete [] ptszScheme;
	if ( ptszHostName )
		delete [] ptszHostName;
	if ( ptszUrlPath )
		delete [] ptszUrlPath;

	return hr;
}


//	Given a UNC file name, set the m_bstrBaseURL member variable.
//	if bstrFName is empty, set m_bstrBaseURL to empty.
//	Else, scan backward to the first "\" or the beginning of the string.
//	Truncate the string at this point.  If the resultant string is empty,
//	add ".".  Then, add "\".
//
HRESULT
CProxyFrame::SetBaseURLFromFileName ( const CComBSTR& bstrFName )
{
	if ( 0 == bstrFName.Length () )
	{
		m_bstrBaseURL = L"";
	}
	else
	{
		WCHAR* pwzstr = new WCHAR[bstrFName.Length () + 1];
		_ASSERTE ( pwzstr );
		if ( NULL != pwzstr )
		{
			WCHAR	wc		= 0;
			int		iPos	= 0;

			// Scan backwards and modify in copy (never in BSTR, please) for beginning or '\'
			memcpy ( pwzstr, bstrFName.m_str, sizeof(WCHAR) * (bstrFName.Length () + 1) );
			for ( iPos = wcslen ( pwzstr ) - 1; iPos >= 0; iPos-- )
			{
				wc = pwzstr[iPos];
				pwzstr[iPos] = WCHAR('\0');	// Delete first, ask questions later.  '\' must go.
				if ( WCHAR('\\') == wc )
				{
					break;
				}
			}
			m_bstrBaseURL = pwzstr;
			delete [] pwzstr;

			// If empty, add a '.'
			if ( 0 == m_bstrBaseURL.Length () )
			{
				m_bstrBaseURL += L".";
			}
			m_bstrBaseURL += L"\\";
		}
		else
		{
			return E_FAIL;
		}
	}
	return S_OK;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Security oriented routines
//
///////////////////////////////////////////////////////////////////////////////////////////


//	This is a critical security issue:
//	The pluggable protocol's ParseURL is called with PARSE_SECURITY_URL in the SFS control.
//	If the BaseURL is empty, and if we're hosted in Trident, we should return the
//	URL of the hosting page.
//	If there is no Trident host, say we're hosted in VB, return the bootdrive + : + /.
//	Bootdrive is not always C.
//
HRESULT
CProxyFrame::GetSecurityURL (CComBSTR& bstrSecurityURL )
{
	HRESULT			hr						= S_OK;
	IOleClientSite	*piClientSiteUnreffed	= NULL;

	bstrSecurityURL = L"";
	
	piClientSiteUnreffed = m_pCtl->m_spClientSite;
	if ( NULL != piClientSiteUnreffed )
	{
		CComPtr<IOleContainer> spContainer = NULL;
		hr = piClientSiteUnreffed->GetContainer ( &spContainer );
		if ( SUCCEEDED ( hr ) && spContainer )
		{
			CComQIPtr<IHTMLDocument2, &IID_IHTMLDocument2> spHostDoc ( spContainer );
			if ( spHostDoc )
			{
				CComPtr<IHTMLLocation> spHostLoc = NULL;


				spHostDoc->get_location ( &spHostLoc );
				if ( spHostLoc )
				{
					BSTR bsOut;
					hr = spHostLoc->get_href ( &bsOut );
					if ( SUCCEEDED ( hr ) )
					{
						bstrSecurityURL.Empty ();
						bstrSecurityURL.Attach ( bsOut );
					}
				}
			}
			else
			{
				// If we are not hosted in Trident, use local machine access:
				TCHAR	tszDrive[4];
				GetModuleFileName ( _Module.m_hInst, tszDrive, 3 );	// Get X:\.
				_ASSERTE ( TCHAR(':') == tszDrive[1] );
				_ASSERTE ( TCHAR('\\') == tszDrive[2] );
				bstrSecurityURL = tszDrive;
				hr = S_OK;
			}
		}
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Pluggable protocol oriented routines
//
///////////////////////////////////////////////////////////////////////////////////////////


//	Register our pluggable protocol handler so dhtmledN[N...] is loaded by our code.
//
HRESULT
CProxyFrame::RegisterPluggableProtocol()
{
	HRESULT hr;

	// Get InternetSession

	CComPtr<IInternetSession> srpSession;
#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( m_pfnCoInternetGetSession );
	hr = (*m_pfnCoInternetGetSession)(0, &srpSession, 0);
#else
	hr = CoInternetGetSession (0, &srpSession, 0);
#endif // LATE_BIND_URLMON_WININET

	if ( FAILED ( hr ) )
	{
		return hr;
	}

	if(m_pProtInfo == NULL)
	{
		hr = CComObject<CDHTMLEdProtocolInfo>::CreateInstance(&m_pProtInfo);
		if ( FAILED ( hr ) )
		{
			return hr;
		}

		// CreateInstance - doesnt AddRef
		m_pProtInfo->GetUnknown()->AddRef();
	}

	hr = srpSession->RegisterNameSpace(
						static_cast<IClassFactory*>(m_pProtInfo),
						CLSID_DHTMLEdProtocol,
						m_wszProtocol,
						0,
						NULL,
						0);

	if ( FAILED ( hr ) )
	{
		return hr;
	}

	CComQIPtr <IProtocolInfoConnector, &IID_IProtocolInfoConnector> piPic ( m_pProtInfo );
	_ASSERTE ( piPic );
	piPic->SetProxyFrame ( (SIZE_T*)this );

	ATLTRACE( _T("CProxyFrame::Registered ProtocolInfo\n"));

	return NOERROR;
}

//	Unregister the pluggable protocol handler installed in RegisterPluggableProtocol
//
HRESULT
CProxyFrame::UnRegisterPluggableProtocol()
{
	if(m_pProtInfo == NULL)
		return E_UNEXPECTED;

	// Get InternetSession

	HRESULT hr;
	CComPtr<IInternetSession> srpSession;

#ifdef LATE_BIND_URLMON_WININET
	_ASSERTE ( m_pfnCoInternetGetSession );
	hr = (*m_pfnCoInternetGetSession)(0, &srpSession, 0);
#else
	hr = CoInternetGetSession (0, &srpSession, 0);
#endif // LATE_BIND_URLMON_WININET

	if(SUCCEEDED(hr))
	{
		// UnRegister Protocol

		srpSession->UnregisterNameSpace(
							static_cast<IClassFactory*>(m_pProtInfo),
							m_wszProtocol);

	}

	m_pProtInfo->GetUnknown()->Release();
	m_pProtInfo = NULL;

	ATLTRACE(_T("CProxyFrame::UnRegistered ProtocolInfo\n"));

	return NOERROR;
}


//	Workhorse routine that actually performs the loading of the control, including filtering.
//	ParseAndBind calls this to retrieve the data to be displayed in the control.
//
HRESULT
CProxyFrame::GetFilteredStream ( IStream** ppStream )
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	LPTSTR pFileName = NULL;
	CComPtr<IStream> piStream;
	BOOL	bfLoadingFromBSTR = ( 0 != m_bstrLoadText.Length () );

	*ppStream = NULL;
	m_bfReloadAttempted = TRUE;

	if ( !bfLoadingFromBSTR )
	{
		_ASSERTE(m_bstrCurDocPath);

		pFileName = OLE2T(m_bstrCurDocPath);

		_ASSERTE(pFileName);

		if (NULL == pFileName)
			return E_OUTOFMEMORY;
	}

	if ( bfLoadingFromBSTR )
	{
		hr = m_pSite->HrBstrToStream(m_bstrLoadText, &piStream);
	}
	else if ( m_bfIsURL )
	{
		hr = m_pSite->HrURLToStream(pFileName, &piStream);
	}
	else
	{
		hr = m_pSite->HrFileToStream(pFileName, &piStream);
	}

	if (FAILED( hr ))
	{
		m_bstrCurDocPath.Empty ();
		m_bstrBaseURL.Empty ();

		// Get TriEdit into a reasonable state by loading an empty document
		// If we reinstanced successfully, this should never fail
		// Also, this will make ignoring the above assert benign
		if (FAILED(m_pSite->HrBstrToStream(m_bstrInitialDoc, ppStream)))
		{
			_ASSERTE(SUCCEEDED(hr));
		}

	}
	else
	{
		if ( m_vbBrowseMode )
		{
			piStream->AddRef ();
			*ppStream = piStream;
		}
		else
		{
			hr = m_pSite->HrFilter(TRUE, piStream, ppStream, m_dwFilterFlags);
		}

		if (FAILED(hr))
		{
			m_pSite->HrBstrToStream(m_bstrInitialDoc, ppStream);
		}
		else
		{
			m_dwFilterOutFlags = m_dwFilterFlags;
		}
	}

	// Store the result to return from the (indirectly) called routine,
	// but don't return an error to ParseAndBind!
	if ( FAILED(hr) && ( ! bfLoadingFromBSTR ) )
	{
		m_hrDeferredLoadError = hr;	// Stash this away, we'll pic it up in LoadDocument
		hr = S_OK;
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Document event handling routines
//
///////////////////////////////////////////////////////////////////////////////////////////


HRESULT
CProxyFrame::OnTriEditEvent ( const GUID& iidEventInterface, DISPID dispid )
{
	HRESULT hr = S_OK;

	if ( DIID_HTMLDocumentEvents == iidEventInterface )
	{
		switch ( dispid )
		{
			case DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS:
			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN:
				if ( DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN == dispid )
				{
					m_pCtl->Fire_onmousedown();
				}
				else if ( DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS == dispid )
				{
					m_pCtl->Fire_onkeypress();
				}

				// Make the control UIActive if it was clicked in.  Since the DocObject swallows the clicks,
				// the control isn't activated automatically.
				// Not needed in browse mode.
				if (  !m_pCtl->m_bUIActive && ! m_vbBrowseMode )
				{
					m_pCtl->DoVerbUIActivate ( NULL, NULL );
					if ( m_hWndObj != NULL )
					{
						::SetFocus( m_hWndObj );
					}
				}
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE:
				m_pCtl->Fire_onmousemove();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP:
				m_pCtl->Fire_onmouseup();
				// onclick is not delivered in edit mode.  First one lost in broswe mode.
				m_pCtl->Fire_onclick();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOUT:
				m_pCtl->Fire_onmouseout();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONMOUSEOVER:
				m_pCtl->Fire_onmouseover();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONCLICK:
				// We do not fire the onclick event in response.
				// It is only delivered in browse mode, and in addition,
				// the first onclick is lost.  We fire on onmouseup.
				//m_pCtl->Fire_onclick();

				// The addition of the DesignMode property, in addition to <BASE TARGET="_top">
				// makes links exploitable for cross-zone access in the SFS control.
				// We must disable clicks (user and script) in the SFS control to prevent this.
				if ( m_pCtl->IsSafeForScripting ())
				{
					CComPtr<IHTMLDocument2>	spHtmlDoc;
					hr = HrGetDoc ( &spHtmlDoc );
					if ( SUCCEEDED ( hr ) && spHtmlDoc )
					{
						CComPtr<IHTMLWindow2> spWindow;

						hr = spHtmlDoc->get_parentWindow ( &spWindow );
						if ( SUCCEEDED ( hr ) && spWindow )
						{
							CComPtr<IHTMLEventObj> spEvt;
							hr = spWindow->get_event ( &spEvt );
							if ( SUCCEEDED ( hr ) && spEvt )
							{
								CComVariant varFalse(VARIANT_FALSE);

								spEvt->put_cancelBubble ( VARIANT_TRUE );
								spEvt->put_returnValue ( varFalse );
							}
						}
					}
				}

				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK:
				m_pCtl->Fire_ondblclick();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN:
				m_pCtl->Fire_onkeydown();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONKEYUP:
				m_pCtl->Fire_onkeyup();
				break;

			case DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE:
				m_pCtl->Fire_onreadystatechange();
				break;

			default:
				_ASSERTE ( TRUE );
				break;
		}
	}
	else if ( DIID_HTMLWindowEvents == iidEventInterface )
	{
		// I expected to get these, but I'm not...
		switch ( dispid )
		{
			case DISPID_HTMLWINDOWEVENTS_ONLOAD:
			case DISPID_HTMLWINDOWEVENTS_ONUNLOAD:
			case DISPID_HTMLWINDOWEVENTS_ONHELP:
			case DISPID_HTMLWINDOWEVENTS_ONFOCUS:
			case DISPID_HTMLWINDOWEVENTS_ONBLUR:
			case DISPID_HTMLWINDOWEVENTS_ONERROR:
			case DISPID_HTMLWINDOWEVENTS_ONRESIZE:
			case DISPID_HTMLWINDOWEVENTS_ONSCROLL:
			case DISPID_HTMLWINDOWEVENTS_ONBEFOREUNLOAD:
				hr = S_OK;
				break;
			
			default:
				_ASSERTE ( TRUE );
				break;
		}
	}
	return hr;
}


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Dynamic loading routines, used in 4.0 versions
//
///////////////////////////////////////////////////////////////////////////////////////////


#ifdef LATE_BIND_URLMON_WININET
//	Load Urlmon and Wininet and get the proc addresses of every routine we use.
//	We must be able to register the control, even if these libraries are not installed.
//	NOTE:
//	This routine loads ANSI versions.  Needs addaptation for UNICODE.
//
BOOL CProxyFrame::DynLoadLibraries ()
{
	m_hUlrMon	= LoadLibrary ( TEXT("URLMON.DLL") );
	m_hWinINet	= LoadLibrary ( TEXT("WININET.DLL") );
	if ( ( NULL == m_hUlrMon ) || ( NULL == m_hWinINet ) )
	{
		DynUnloadLibraries ();
		return FALSE;
	}

	m_pfnCoInternetCombineUrl	= (PFNCoInternetCombineUrl)GetProcAddress (
									m_hUlrMon, "CoInternetCombineUrl" );
									_ASSERTE ( m_pfnCoInternetCombineUrl );
	m_pfnCoInternetParseUrl		= (PFNCoInternetParseUrl)GetProcAddress (
									m_hUlrMon, "CoInternetParseUrl" );
									_ASSERTE ( m_pfnCoInternetParseUrl );
	m_pfnCreateURLMoniker		= (PFNCreateURLMoniker)GetProcAddress (
									m_hUlrMon, "CreateURLMoniker" );
									_ASSERTE ( m_pfnCreateURLMoniker );
	m_pfnCoInternetGetSession	= (PFNCoInternetGetSession)GetProcAddress (
									m_hUlrMon, "CoInternetGetSession" );
									_ASSERTE ( m_pfnCoInternetGetSession );
	m_pfnURLOpenBlockingStream	= (PFNURLOpenBlockingStream)GetProcAddress (
									m_hUlrMon, "URLOpenBlockingStreamA" );
									_ASSERTE ( m_pfnURLOpenBlockingStream );

	m_pfnDeleteUrlCacheEntry	= (PFNDeleteUrlCacheEntry)GetProcAddress (
									m_hWinINet, "DeleteUrlCacheEntry" );
									_ASSERTE ( m_pfnDeleteUrlCacheEntry );
	m_pfnInternetCreateUrl		= (PFNInternetCreateUrl)GetProcAddress (
									m_hWinINet, "InternetCreateUrlA" );
									_ASSERTE ( m_pfnInternetCreateUrl );
	m_pfnInternetCrackUrl		= (PFNInternetCrackURL)GetProcAddress (
									m_hWinINet, "InternetCrackUrlA" );
									_ASSERTE ( m_pfnInternetCrackUrl );

	return ( m_pfnCoInternetCombineUrl && m_pfnCoInternetParseUrl && m_pfnCreateURLMoniker &&
		m_pfnCoInternetGetSession && m_pfnURLOpenBlockingStream && m_pfnDeleteUrlCacheEntry &&
		m_pfnInternetCreateUrl && m_pfnInternetCrackUrl );
}


//	Release the libraries loaded by DynLoadLibraries
//
void CProxyFrame::DynUnloadLibraries ()
{
	if ( NULL != m_hUlrMon )
	{
		FreeLibrary ( m_hUlrMon );
		m_hUlrMon = NULL;
	}
	if ( NULL != m_hWinINet )
	{
		FreeLibrary ( m_hWinINet );
		m_hWinINet = NULL;
	}

	m_pfnCoInternetCombineUrl	= NULL;
	m_pfnCoInternetParseUrl		= NULL;
	m_pfnCreateURLMoniker		= NULL;
	m_pfnCoInternetGetSession	= NULL;
	m_pfnURLOpenBlockingStream	= NULL;

	m_pfnDeleteUrlCacheEntry	= NULL;
	m_pfnInternetCreateUrl		= NULL;
	m_pfnInternetCrackUrl		= NULL;
}
#endif // LATE_BIND_URLMON_WININET


///////////////////////////////////////////////////////////////////////////////////////////
//
//	Utility routines
//
///////////////////////////////////////////////////////////////////////////////////////////

//	Return the IHTMLDocument2 pointer from the hosted doc.
//
HRESULT
CProxyFrame::HrGetDoc(IHTMLDocument2 **ppDoc)
{
	HRESULT hr = E_FAIL;
	IUnknown* lpUnk = m_pSite->GetObjectUnknown();

	if (FALSE == m_fActivated)
		return DE_E_UNEXPECTED;

	_ASSERTE(ppDoc);

	if (NULL == ppDoc)
		return DE_E_INVALIDARG;

	_ASSERTE(lpUnk);

	if ( m_bfIsLoading )
		return DE_E_UNEXPECTED;	// This is invalid while document is still loading.

	if (lpUnk != NULL)
	{
		// Request the "document" object from the MSHTML
		*ppDoc = NULL;
		hr = lpUnk->QueryInterface(IID_IHTMLDocument2, (void **)ppDoc);
	}

	_ASSERTE(SUCCEEDED(hr)); // this should always succeed
	return hr;
}


//	Helper routine to set any Boolean Trident property
//
HRESULT
CProxyFrame::HrTridentSetPropBool(ULONG cmd, BOOL bVal)
{
	HRESULT hr = S_OK;
	VARIANT varIn;

	VariantInit(&varIn);
	V_VT(&varIn) = VT_BOOL;

#pragma warning(disable: 4310) // cast truncates constant value
	bVal ? V_BOOL(&varIn) = VARIANT_TRUE : V_BOOL(&varIn) = VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value

	hr = HrExecCommand(&CGID_MSHTML, cmd, MSOCMDEXECOPT_DONTPROMPTUSER, &varIn, NULL);

	// this should always succeed since all props 
	// should be set in correct phases of Trident creation

	_ASSERTE(SUCCEEDED(hr)); 
	return hr;
}


//	Helper routine to get any Boolean Trident property
//
HRESULT
CProxyFrame::HrTridentGetPropBool(ULONG cmd, BOOL& bVal)
{
	HRESULT hr = S_OK;
	OLECMDF cmdf = (OLECMDF) 0;

	if (SUCCEEDED(HrQueryStatus(&CGID_MSHTML, cmd, &cmdf)))
	{
		bVal = (cmdf & OLECMDF_ENABLED) == OLECMDF_ENABLED ? TRUE : FALSE;
	}

	// this should always succeed since all props 
	// should be set in correct phases of Trident creation

	_ASSERTE(SUCCEEDED(hr));
	return hr;
}


//	Store the BSTR so LoadFilteredStream can access it, and load a URL with our protocol
//	to kick off the load/resolve/display through the pluggable protocol handler.
//
//	Clear the BaseURL, and mark the control "Loading..."
//
HRESULT
CProxyFrame::LoadBSTRDeferred ( BSTR bVal )
{
	HRESULT	hr	= E_FAIL;

	_ASSERTE ( m_pUnkTriEdit );

	m_bstrLoadText = bVal;

	CComPtr<IMoniker> srpMoniker;
	CComPtr<IBindCtx> srpBindCtx;
	CComQIPtr<IPersistMoniker, &IID_IPersistMoniker> srpPM (m_pUnkTriEdit);
	_ASSERTE ( srpPM );

	if ( srpPM )
	{
#ifdef LATE_BIND_URLMON_WININET
		_ASSERTE ( m_pfnCreateURLMoniker );
		hr = (*m_pfnCreateURLMoniker)( NULL, m_wszProtocolPrefix, &srpMoniker );
#else
		hr = CreateURLMoniker ( NULL, m_wszProtocolPrefix, &srpMoniker );
#endif // LATE_BIND_URLMON_WININET

		_ASSERTE ( SUCCEEDED( hr ) );
		if ( SUCCEEDED ( hr ) )
		{
			hr = ::CreateBindCtx(NULL, &srpBindCtx);
			_ASSERTE ( SUCCEEDED( hr ) );
			if ( SUCCEEDED ( hr ) )
			{
				m_bfIsLoading = TRUE;
				m_bfBaseURLFromBASETag = FALSE;

				hr = srpPM->Load(FALSE, srpMoniker,  srpBindCtx, STGM_READ);

				_ASSERTE ( SUCCEEDED( hr ) );
			}
		}
	}
	return hr;
}


//	Set the document stream's dirty flag
//
HRESULT
CProxyFrame::SetDirtyFlag ( BOOL bfMakeDirty )
{
	CComVariant varDirty;

	varDirty = bfMakeDirty ? true : false;

	return HrExecCommand(&CGID_MSHTML, IDM_SETDIRTY, MSOCMDEXECOPT_DONTPROMPTUSER, &varDirty, NULL);
}


// properties that can be set only after TriEdit is in running state
HRESULT
CProxyFrame::HrSetRuntimeProperties()
{
	HRESULT hr = S_OK;

	if (FAILED(hr = HrSetPropActivateControls(m_fActivateControls)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetPropActivateApplets(m_fActivateApplets)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetPropActivateDTCs(m_fActivateDTCs)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	// toggle properties

	if (FAILED(hr = HrSetPropShowAllTags(m_fShowAllTags)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}


	if (FAILED(hr = HrSetPropShowBorders(m_fShowBorders)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

error:

	return hr;
}


HRESULT
CProxyFrame::HrGetCurrentDocumentPath(BSTR* bVal)
{
	HRESULT hr = S_OK;

	_ASSERTE(bVal);

	if (NULL == bVal)
		return E_INVALIDARG;

	*bVal = m_bstrCurDocPath.Copy ();
	return hr;
}


// properties that can only be set after UIActivation
HRESULT
CProxyFrame::HrSetDocLoadedProperties()
{
	HRESULT hr = S_OK;
	BOOL bGoodUndoBehavior = TRUE;

	bGoodUndoBehavior = TRUE;
	if (FAILED(HrTridentGetPropBool(IDM_GOOD_UNDO_BEHAVIOR, bGoodUndoBehavior)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetAbsoluteDropMode(m_fAbsoluteDropMode)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetSnapToGridX(m_ulSnapToGridX)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetSnapToGridY(m_ulSnapToGridY)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

	if (FAILED(hr = HrSetSnapToGrid(m_fSnapToGrid)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto error;
	}

error:

	return hr;
}


//	HrExecInsertTable helper.  Extract the safearrys
//
HRESULT
CProxyFrame::HrGetTableSafeArray(IDEInsertTableParam* pTable, LPVARIANT pVarIn)
{
	HRESULT hr					= S_OK;
	UINT i						= 0;
	SAFEARRAY FAR* psa			= NULL;
	SAFEARRAYBOUND rgsabound[1] = {0};
	LONG ix[1]					= {0};
	VARIANT varElem;
	LONG  nNumRows				= 0;
	LONG  nNumCols				= 0;
	BSTR bstrTableAttrs			= NULL;
	BSTR bstrCellAttrs			= NULL;
	BSTR bstrCaption			= NULL;

	_ASSERTE(pTable);

	if (FAILED(hr = pTable->get_NumRows(&nNumRows)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	if (FAILED(hr = pTable->get_NumCols(&nNumCols)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	if (FAILED(hr = pTable->get_TableAttrs(&bstrTableAttrs)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}
	_ASSERTE(bstrTableAttrs);

	if (FAILED(hr = pTable->get_CellAttrs(&bstrCellAttrs)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}
	_ASSERTE(bstrCellAttrs);

	if (FAILED(hr = pTable->get_Caption(&bstrCaption)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}
	_ASSERTE(bstrCaption);

	rgsabound[0].lLbound = 0;
	rgsabound[0].cElements = 5;

	psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);	
	_ASSERTE(psa);

	if(NULL == psa)
		return E_OUTOFMEMORY;

	VariantInit(pVarIn);
	V_VT(pVarIn) = VT_ARRAY;
	V_ARRAY(pVarIn) = psa;

	i=0;

	// elmement 1: number of rows
	ix[0] = i;
	VariantInit(&varElem);
	V_VT(&varElem) = VT_I4;
	V_I4(&varElem) = nNumRows; 
	hr = SafeArrayPutElement(psa, ix, &varElem);
	VariantClear(&varElem);
	++i;

	// elmement 2: number of columns
	ix[0] = i;
	VariantInit(&varElem);
	V_VT(&varElem) = VT_I4;
	V_I4(&varElem) = nNumCols;
	hr = SafeArrayPutElement(psa, ix, &varElem);
	VariantClear(&varElem);
	++i;

	// elmement 3: table tag attributes
	ix[0] = i;
	VariantInit(&varElem);
	V_VT(&varElem) = VT_BSTR;
	V_BSTR(&varElem) = bstrTableAttrs;
	hr = SafeArrayPutElement(psa, ix, &varElem);
	VariantClear(&varElem);
	++i;

	// elmement 4: cell attributes
	ix[0] = i;
	VariantInit(&varElem);
	V_VT(&varElem) = VT_BSTR;
	V_BSTR(&varElem) = bstrCellAttrs;
	hr = SafeArrayPutElement(psa, ix, &varElem);
	VariantClear(&varElem);
	++i;

	// elmement 5: table caption
	// VK bug 15857: don't include caption if it's empty.
	if ( 0 != SysStringLen ( bstrCaption ) )
	{
		ix[0] = i;
		VariantInit(&varElem);
		V_VT(&varElem) = VT_BSTR;
		V_BSTR(&varElem) = bstrCaption;
		hr = SafeArrayPutElement(psa, ix, &varElem);
		VariantClear(&varElem);
		++i;
	}

	return hr;
}


//	Determine which object is selected, and return its position
//
HRESULT
CProxyFrame::GetSelectionPos ( LPPOINT lpWhere )
{
	HRESULT	hr	= E_FAIL;
	CComPtr<IHTMLDocument2> spHtmlDoc				= NULL;
	CComPtr<IHTMLSelectionObject> spSelectionObj	= NULL;
	CComPtr<IDispatch> spRangeDisp					= NULL;
	CComPtr<IHTMLElement> spElement					= NULL;
	
	lpWhere->x	= 0;
	lpWhere->y	= 0;

	hr = HrGetDoc ( &spHtmlDoc );
	if ( SUCCEEDED ( hr ) )
	{
		hr = spHtmlDoc->get_selection ( &spSelectionObj );
		if ( SUCCEEDED ( hr ) )
		{
			hr = spSelectionObj->createRange ( &spRangeDisp );
			if (SUCCEEDED ( hr ) )
			{
				CComQIPtr<IHTMLTxtRange, &IID_IHTMLTxtRange> spTextRange ( spRangeDisp );
				if ( spTextRange )
				{
					hr = spTextRange->parentElement(&spElement);
				}
				else
				{
					CComQIPtr<IHTMLControlRange, &IID_IHTMLControlRange> spControlRange ( spRangeDisp );
					if ( spControlRange )
					{
						hr = spControlRange->commonParentElement(&spElement);
					}
				}
				if ( spElement )
				{
					CComPtr<IHTMLStyle> spStyle = NULL;
					hr = spElement->get_style ( &spStyle );
					if ( spStyle )
					{
						spStyle->get_pixelTop ( &( lpWhere->y ) );
						spStyle->get_pixelLeft ( &( lpWhere->x ) );
					}
				}
			}
		}
	}
	return hr;
}


//	If the current document is loaded from a URL, return the empty string.
//	If it's loaded from a file, strip the path part off and return just the file name.
//	Return S_FALSE for a URL or no file name.  S_OK if a file name is supplied.
//
HRESULT
CProxyFrame::GetCurDocNameWOPath ( CComBSTR& bstrDocName )
{
	bstrDocName = L"";

	if ( m_bfIsURL )
	{
		return S_FALSE;
	}
	if ( 0 == m_bstrCurDocPath.Length () )
	{
		return S_FALSE;
	}

	bstrDocName = m_bstrCurDocPath;

	// Truncate at first backslash:
	_wcsrev ( bstrDocName );
	wcstok ( bstrDocName, OLESTR( "\\" ) );
	_wcsrev ( bstrDocName );

	return S_OK;
}


//	Used by ShowContextMenu to properly offset the position of the click
// 
HRESULT
CProxyFrame::GetScrollPos ( LPPOINT lpPos )
{
	HRESULT					hr			= E_FAIL;
	CComPtr<IHTMLDocument2>	spHtmlDoc	= NULL;
	CComPtr<IHTMLElement>	spBodyElem	= NULL;

	_ASSERTE ( lpPos );
	
	hr = HrGetDoc ( &spHtmlDoc );
	
	// It's possible that the user clicked while the doc was still loading.
	// If so, just return 0, 0.
	if ( DE_E_UNEXPECTED == hr )
	{
		lpPos->x = lpPos->y = 0;
		return S_FALSE;
	}

	_ASSERTE ( spHtmlDoc );
	if ( SUCCEEDED ( hr ) )
	{
		hr = spHtmlDoc->get_body ( &spBodyElem );
		_ASSERTE ( spBodyElem );
		if ( SUCCEEDED ( hr ) )
		{
			CComQIPtr<IHTMLTextContainer, &IID_IHTMLTextContainer> spHtmlTextCont ( spBodyElem );
			if ( spHtmlTextCont )
			{
				LONG	lxPos	= 0;
				LONG	lyPos	= 0;

				hr = spHtmlTextCont->get_scrollLeft ( &lxPos );
				_ASSERTE ( SUCCEEDED ( hr ) );
				if ( SUCCEEDED ( hr ) )
				{
					hr = spHtmlTextCont->get_scrollTop ( &lyPos );
					_ASSERTE ( SUCCEEDED ( hr ) );
					if ( SUCCEEDED ( hr ) )
					{
						lpPos->x = lxPos;
						lpPos->y = lyPos;
					}
				}
			}
			else
			{
				hr = E_NOINTERFACE;
				_ASSERTE ( SUCCEEDED ( hr ) );
			}
		}
	}
	return hr;
}


HRESULT
CProxyFrame::GetContainer ( LPOLECONTAINER* ppContainer )
{
	_ASSERTE ( m_pCtl );
	_ASSERTE ( m_pCtl->m_spClientSite );
	if ( m_pCtl->m_spClientSite )
	{
		return m_pCtl->m_spClientSite->GetContainer ( ppContainer );
	}
	return E_NOTIMPL;
}


//	For the Safe for Scripting control, make sure the URL specified comes from
//	the same host as the SecurityURL, the URL of the hosting container..
//	Note that this makes the SFS control virtually useless in VB, which returns
//	the Boot Drive Root Folder as the Security URL.
//
HRESULT CProxyFrame::CheckCrossZoneSecurity ( BSTR urlToLoad )
{
	HRESULT		hr	= S_OK;

	CComPtr<IInternetSecurityManager> srpSec;
	CComBSTR	bstrSecURL;

	hr = GetSecurityURL ( bstrSecURL );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( SUCCEEDED ( hr ) )
	{
#ifdef LATE_BIND_URLMON_WININET
		hr = (m_pfnCoInternetCreateSecurityManager)( NULL, &srpSec, 0 );
#else
		hr = CoInternetCreateSecurityManager( NULL, &srpSec, 0 );
#endif // LATE_BIND_URLMON_WININET
		if ( SUCCEEDED ( hr ) && srpSec )
		{
			BYTE*	pbSidToLoad		= NULL;
			BYTE*	pbDSidSecURL	= NULL;
			DWORD	dwSizeToLoad	= INTERNET_MAX_URL_LENGTH;
			DWORD	dwSizeSecURL	= INTERNET_MAX_URL_LENGTH;

			pbSidToLoad  = new BYTE [INTERNET_MAX_URL_LENGTH];
			pbDSidSecURL = new BYTE [INTERNET_MAX_URL_LENGTH];

			hr = srpSec->GetSecurityId ( urlToLoad, pbSidToLoad, &dwSizeToLoad, 0 );
			_ASSERTE ( SUCCEEDED ( hr ) );
			if ( SUCCEEDED ( hr ) )
			{
				hr = srpSec->GetSecurityId ( bstrSecURL, pbDSidSecURL, &dwSizeSecURL, 0 );
				_ASSERTE ( SUCCEEDED ( hr ) );
				if ( SUCCEEDED ( hr ) )
				{
					hr = DE_E_ACCESS_DENIED;

					if ( ( dwSizeToLoad == dwSizeSecURL ) &&
						( 0 == memcmp ( pbSidToLoad, pbDSidSecURL, dwSizeToLoad ) ) )
					{
						hr = S_OK;
					}
				}
			}

			delete [] pbSidToLoad;
			delete [] pbDSidSecURL;
		}
		else
		{
			// BUG 597887: If CoInternetCreateSecurityManager returns NULL and success, return error:
			if ( !srpSec )
			{
				hr = E_UNEXPECTED;
			}
		}
	}
	return hr;
}


//	A specialization of CheckCrossZoneSecurity which works on the current selection.
//	Bug 547802 indicated a regression in execCommand, so we will assure safety ourselves.
//
HRESULT CProxyFrame::CheckCrossZoneSecurityOfSelection ()
{
	HRESULT						hr	= S_OK;
	CComPtr<IHTMLDocument2>		spDOM;
	CComPtr<IServiceProvider>	srpSP;
	CComPtr<IHTMLEditServices>	srpEditor;
	CComPtr<ISelectionServices>	srpSelSvc;
	CComPtr<IMarkupContainer>	sprMarkupCont;
	CComPtr<IHTMLDocument2>		spSelDoc;
	CComPtr<IHTMLLocation>		spHostLoc;
	CComBSTR					bstrHref;

	hr = HrGetDoc( &spDOM );
	if ( FAILED(hr) ) goto ONERROR;

	hr = spDOM->QueryInterface(IID_IServiceProvider, (LPVOID *)&srpSP);
	if ( FAILED(hr) ) goto ONERROR;
	hr = srpSP->QueryService(SID_SHTMLEditServices, IID_IHTMLEditServices, (void **)&srpEditor);
	if ( FAILED(hr) ) goto ONERROR;
	hr = srpEditor->GetSelectionServices(NULL, &srpSelSvc);
	if ( FAILED(hr) ) goto ONERROR;
	if ( !srpSelSvc ) goto ONERROR;
	hr = srpSelSvc->GetMarkupContainer(&sprMarkupCont);
	if ( FAILED(hr) ) goto ONERROR;
	if ( !sprMarkupCont ) goto ONERROR;
	hr = sprMarkupCont->QueryInterface(&spSelDoc);
	if ( FAILED(hr) ) goto ONERROR;
	
	hr = spSelDoc->get_location ( &spHostLoc );
	if ( FAILED(hr) ) goto ONERROR;
	if ( !spHostLoc ) goto ONERROR;
	hr = spHostLoc->get_href ( &bstrHref );
	if ( FAILED(hr) ) goto ONERROR;
	if ( !bstrHref ) goto ONERROR;

	hr = CheckCrossZoneSecurity ( bstrHref );

	return hr;

ONERROR:
	return DE_E_ACCESS_DENIED;
}


HRESULT CProxyFrame::OnProgress(ULONG, ULONG, ULONG ulStatusCode, LPCWSTR)
{
	if ( BINDSTATUS_REDIRECTING == ulStatusCode )
	{
		// If we're the SFS control, cancel on Redirect.  Otherwise, ignore it.
		if ( m_pCtl->IsSafeForScripting ())
		{
			m_bfSFSRedirect = TRUE;
		}
	}
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\triedcmdg.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef _triedcmdg_h_
#define _triedcmdg_h_

#ifdef __cplusplus
extern "C"{
#endif 

EXTERN_C const GUID GUID_TriEditCommandGroup;

DEFINE_GUID(GUID_TriEditCommandGroup,
0x2582f1c0, 0x84e, 0x11d1, 0x9a, 0xe, 0x0, 0x60, 0x97, 0xc9, 0xb3, 0x44);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\triedsnk.h ===
//	Event sink for TriEdit/Trident
//	Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//	Van Kichline



//	Create an event sink impl, then immediately call SetOwner with, in this case,
//	a pointer to a CProxyFrame, implementing OnTriEditEvent.
//	It would be better to require an interface on the OnTriEditEvent when time allows.
//	The lifetime of the CProxyFrame is managed by the CTriEditEventSink, below.
//
//	OnTriEditEvent will be called with the following DISPIDs for Document events:
//		DISPID_HTMLDOCUMENTEVENTS_ONHELP:
//		DISPID_HTMLDOCUMENTEVENTS_ONCLICK:
//		DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK:
//		DISPID_HTMLDOCUMENTEVENTS_ONKEYDOWN:
//		DISPID_HTMLDOCUMENTEVENTS_ONKEYUP:
//		DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS:
//		DISPID_HTMLDOCUMENTEVENTS_ONMOUSEMOVE:
//		DISPID_HTMLDOCUMENTEVENTS_ONMOUSEDOWN:
//		DISPID_HTMLDOCUMENTEVENTS_ONMOUSEUP:
//		DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE:
//
//	Changes: more versital implementation allows creating sinks for various event interfaces.
//	The interface IID is sent along to OnTriEditEvent.
//
class ATL_NO_VTABLE CTriEditEventSinkImpl :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatch
{
public:
BEGIN_COM_MAP(CTriEditEventSinkImpl)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	CTriEditEventSinkImpl ()
	{
		m_pFR = NULL;
	}

	void SetOwner ( CProxyFrame* pFR, const GUID& iidEventInterface )
	{
		_ASSERTE ( pFR );
		_ASSERTE ( NULL == m_pFR );
		if ( NULL == m_pFR )
		{
			m_pFR = pFR;
			m_iidEventInterface = iidEventInterface;
		}
	}

	STDMETHOD(GetTypeInfoCount) ( UINT * )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(GetTypeInfo) ( UINT, LCID, ITypeInfo ** )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(GetIDsOfNames) ( REFIID, OLECHAR **, UINT, LCID, DISPID * )
	{
		_ASSERTE ( FALSE );
		return E_NOTIMPL;
	}

	STDMETHOD(Invoke) ( DISPID dispid, REFIID, LCID, USHORT, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT * )
	{
		HRESULT	hr = E_UNEXPECTED;
		_ASSERTE ( m_pFR );
		if ( NULL != m_pFR )
		{
			hr = m_pFR->OnTriEditEvent ( m_iidEventInterface, dispid );
		}
		return hr;
	}

private:
	CProxyFrame*	m_pFR;
	GUID			m_iidEventInterface;
};


//	This class manages hooking up an event sink on Trident using CTriEditEventSinkImpl above.
//	The sink is advised and unadvised by this class, making management simple.
//	CProxyFrame must implement OnTriEditEvent.
//
class CTriEditEventSink
{
public:
	CTriEditEventSink ( CProxyFrame* pFR, GUID iidEventInterface ) :
	  m_piConPt ( NULL ), m_dwCookie ( 0 ), m_pSink ( NULL ), m_iidEventInterface ( iidEventInterface )
	{
		_ASSERTE ( pFR );
		m_pFR = pFR;
		if ( NULL != m_pFR )
		{
			m_pFR->AddRef ();
			m_pSink = new CComObject<CTriEditEventSinkImpl>;
			_ASSERTE ( m_pSink );
			m_pSink->AddRef ();
			m_pSink->SetOwner ( m_pFR, m_iidEventInterface );
			m_bfSunk = FALSE;
		}
	}

	~CTriEditEventSink ()
	{
		_ASSERTE ( m_pFR );

		Unadvise ();
		
		if ( NULL != m_pSink )
		{
			m_pSink->Release ();
			m_pSink = NULL;
		}

		if ( NULL != m_pFR )
		{
			m_pFR->Release ();
			m_pFR = NULL;
		}
	}

	HRESULT Advise ( IUnknown* pUnk )
	{
		HRESULT hr	= E_FAIL;
		_ASSERTE ( pUnk );
		_ASSERTE ( m_pFR );
		_ASSERTE ( m_pSink );

		if ( NULL == pUnk )
		{
			_ASSERTE ( FALSE );
			return E_UNEXPECTED;
		}

		if ( m_bfSunk )
		{
			_ASSERTE ( FALSE );
			return E_UNEXPECTED;
		}

		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer>picpc ( pUnk );
		if ( picpc )
		{
			hr = picpc->FindConnectionPoint ( m_iidEventInterface, &m_piConPt );
			if ( SUCCEEDED ( hr ) )
			{
				hr = m_piConPt->Advise ( static_cast<IDispatch *>(m_pSink), &m_dwCookie);
				_ASSERTE ( SUCCEEDED ( hr ) );
				if ( SUCCEEDED ( hr ) )
				{
					m_bfSunk = TRUE;
				}
			}
		}
		return hr;
	}

	void Unadvise ()
	{
		if ( !m_bfSunk )
		{
			return;
		}

		if ( ( NULL != m_pSink ) && ( NULL != m_piConPt ) )
		{
			m_piConPt->Unadvise ( m_dwCookie );
			m_bfSunk = FALSE;
				
		}
		if ( NULL != m_piConPt )
		{
			m_piConPt->Release ();
			m_piConPt = NULL;
		}
	}

private:
	CTriEditEventSinkImpl*	m_pSink;
	IConnectionPoint*		m_piConPt;
	DWORD					m_dwCookie;
	CProxyFrame*			m_pFR;
	BOOL					m_bfSunk;
	GUID					m_iidEventInterface;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_STDAFX_H__683364A5_B37D_11D1_ADC5_006008A5848C__INCLUDED_)
#define AFX_STDAFX_H__683364A5_B37D_11D1_ADC5_006008A5848C__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif // STRICT

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#pragma warning(disable:4786)	// Turncated label warnings
#pragma warning(disable: 4505)	// unreferenced local function has been removed

#include <windows.h>

// Note that this include MUST be at this location (after the above include)
#include "win95wrp.h"

#include <atlbase.h>

#define AGGREGATE_TRIDENT 0
#define DHTMLEDTRACE OutputDebugString

// DHTMLEdit 1.0 had a requirement to be able to register WITHOUT being able to run.
// Thus, URLMon and WinINet were loaded late and necessary routines were bound as needed.
// This reuqirement went away with 2.0, and stood in the way of Win95Wrap utilization.
//#define LATE_BIND_URLMON_WININET	1


//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#pragma warning(disable: 4100 4189 4244)	// Necessary for ia64 build
#include <atlcom.h>
#pragma warning(disable: 4510 4610)			// Necessary for Win32 build W4
#include "atlctl.h"
#pragma warning(default: 4510 4610)			// Necessary for Win32 build W4
#pragma warning(default: 4100 4189 4244)	// Necessary for ia64 build

#include <mshtml.h>
#include <mshtmhst.h>
#include <mshtmcid.h>
#include <triedit.h>
#include <triedcid.h>
#include <comdef.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__683364A5_B37D_11D1_ADC5_006008A5848C__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\triedtctlid.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __TRIEDTCTLID_H_
#define __TRIEDTCTLID_H_


// methods and properties
#define DISPID_LOADDOCUMENT				1
#define DISPID_EXECCOMMAND				2
#define DISPID_QUERYSTATUS				3
#define DISPID_SAVEDOCUMENT				4
#define DISPID_SETCONTEXTMENU			5

#define DISPID_DOCUMENT					6
#define DISPID_ACTIVATEAPPLETS			7
#define DISPID_ACTIVATEACTIVEXCONTROLS	8
#define DISPID_ACTIVATEDTCS				9	
//#define DISPID_OVERWRITEMODE			10
#define DISPID_SHOWDETAILS				11
#define DISPID_SHOWBORDERS				12
#define DISPID_DHTMLEDITAPPEARANCE		13
#define DISPID_DHTMLEDITSCROLLBARS		14
#define DISPID_SCROLLBARAPPEARANCE		15
#define DISPID_SOURCECODEPRESERVATION	16
#define DISPID_DOCUMENTHTML				17
#define DISPID_ABSOLUTEDROPMODE			18
#define DISPID_SNAPTOGRIDX				19
#define DISPID_SNAPTOGRIDY				20
#define DISPID_SNAPTOGRID				21
#define DISPID_ISDIRTY					22
#define DISPID_CURRENTDOCUMENTPATH		23
#define DISPID_BASEURL					24
#define DISPID_DOCUMENTTITLE			25
#define DISPID_BROWSEMODE				26
#define DISPID_NEWDOCUMENT				27
#define DISPID_PRINT					28
#define DISPID_LOADURL					29
#define DISPID_USEDIVONCR				30
#define DISPID_FILTERSRCCODE			31
#define DISPID_REFRESHDOC				32
#define DISPID_BUSY						33

// events
#define	DISPID_DOCUMENTCOMPLETE			1
#define	DISPID_DISPLAYCHANGED			2
#define	DISPID_SHOWCONTEXTMENU			3
#define	DISPID_CONTEXTMENUACTION		4
#define DISPID_ONMOUSEDOWN				5
#define DISPID_ONMOUSEMOVE				6
#define DISPID_ONMOUSEUP				7
#define DISPID_ONMOUSEOUT				8
#define DISPID_ONMOUSEOVER				9
#define DISPID_ONCLICK					10
#define DISPID_ONDBLCLICK				11
#define DISPID_ONKEYDOWN				12
#define DISPID_ONKEYPRESS				13
#define DISPID_ONKEYUP					14
#define DISPID_ONBLUR					15
#define DISPID_ONREADYSTATECHANGE		16


#define DISPID_TABLEPARAMS_NUMROWS		1
#define DISPID_TABLEPARAMS_NUMCOLS		2
#define DISPID_TABLEPARAMS_TABLEATTRS	3
#define DISPID_TABLEPARAMS_CELLATTRS	4
#define DISPID_TABLEPARAMS_CAPTION		5

#define DISPID_NAMESPARAM_NAMES	1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\win95wrp.cpp ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       win95wrp.cpp
//
//  This file was taken from the Davinci sources and adapted for TriEdit
//  on 3/11/98 in order to get rid of the external dependency for the TriEdit SDK
//  The adaptation process included getting rid of several APIs that were not being
//  supported and moving some APIs from the supported to unsupported group
//
//  Contents:   Unicode wrapper API, used only on Win95
//
//  Functions:  About 125 Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//              All memory allocation is done on the stack.
//
//----------------------------------------------------------------------------

// Includes ------------------------------------------------------------------

#include "stdafx.h"

// The following two lines will ensure that no mapping from Foo to OFoo will take place
// and the real windows APIs will get called from this file
#define __WIN95WRP_CPP__
#include "win95wrp.h"

#include <mbstring.h>
#include <commctrl.h>
#include <shlobj.h>

// Function prototypes
inline LONG UnicodeToAnsi(LPSTR szOut, LPCWSTR pwszIn, LONG cbOut, LONG cbIn = -1) throw();
inline LONG AnsiToUnicode(LPWSTR pwszOut, LPCSTR szIn, LONG cbOut, LONG cbIn = -1) throw();
static void CvtDevmode(DEVMODEA *pdma, const DEVMODEW *pdmw) throw();

BOOL g_fWin95;
BOOL g_fOSInit = FALSE;

// Debug ----------------------------------------------------------------------
#ifdef _DEBUG
#define Assert(f)   ((f) ? 0 : AssertFail(#f))
#define Verify(f)   Assert(f)
#define Debug(f)    (f)
#else
#define Assert(f)   (0)
#define Verify(f)   (f)
#define Debug(f)    (0)
#endif

#ifdef DEBUG
int AssertFail(const CHAR *pszMsg) throw()
{
	int wRet = MessageBoxA(NULL, pszMsg, "Assert Failed in Win95 layer",
						   MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 |
						   MB_SYSTEMMODAL | MB_ICONHAND );

	switch (wRet)
		{
		case IDABORT:
			FatalAppExit(0, L"BOO HOO");
			break;

		case IDRETRY:
			DebugBreak();
			// deliberately fall through to IDIGNORE in order to continue

		case IDIGNORE:

			// go aways
			break;
		}
	return 0;
}
#else
#define AssertFail(s) (0)
#endif  // ! DEBUG

// This macro determines whether a LPTSTR is an atom or string pointer
#define FATOM(x)    (!(HIWORD(x)))

// OffsetOf       - Return the byte offset into s of m
#define	OffsetOf(s,m)	(size_t)(((unsigned char*)&(((s*)0)->m))-((unsigned char*)0))

inline LONG UnicodeToAnsi(LPSTR szDestString, LPCWSTR pwszSrcString,
						  LONG  cbDestString, LONG    cbSrcString ) throw()
{

	Assert(-1 != cbDestString && (!cbDestString || szDestString));
	return WideCharToMultiByte(CP_ACP, 0, pwszSrcString, cbSrcString,
							   szDestString, cbDestString, NULL, NULL);

}

inline LONG AnsiToUnicode(LPWSTR pwszDestString, LPCSTR szSrcString,
						  LONG   cbDestString,   LONG   cbSrcString ) throw()
{

	Assert(-1 != cbDestString && (!cbDestString || pwszDestString));
	return MultiByteToWideChar(CP_ACP, 0, szSrcString, cbSrcString,
							   pwszDestString, cbDestString );
}

static void CvtDevmode(
	DEVMODEA *pdma,
	const DEVMODEW *pdmw
	) throw()
{
	Verify(0 <= UnicodeToAnsi((LPSTR)pdma->dmDeviceName, pdmw->dmDeviceName, CCHDEVICENAME));

	memcpy(&pdma->dmSpecVersion, &pdmw->dmSpecVersion, OffsetOf(DEVMODE,dmFormName) -
		OffsetOf(DEVMODE,dmSpecVersion));

	Verify(0 <= UnicodeToAnsi((LPSTR)pdma->dmFormName, pdmw->dmFormName, CCHFORMNAME));

	memcpy(&pdma->dmLogPixels, &pdmw->dmLogPixels, sizeof(DEVMODE)-OffsetOf(DEVMODE, dmLogPixels));

	// Make sure we copy the extra driver bits.
	if ( pdmw->dmDriverExtra )
		memcpy((char*)pdma + sizeof(DEVMODEA), (char*)pdmw + sizeof(DEVMODEW), pdmw->dmDriverExtra );
}


inline bool FWide() throw()
{
	if (!g_fOSInit)
	{
		OSVERSIONINFOA osvi;
		osvi.dwOSVersionInfoSize = sizeof(osvi);

		GetVersionExA(&osvi);
		g_fWin95 = (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId);
		g_fOSInit = TRUE;
	}

	Assert(g_fOSInit);
	return !g_fWin95;
}

//  The implementation of the Unicode to ANSI (MBCS) convertion macros use the
//  _alloca() function to allocate memory from the stack instead of the heap.
//  Allocating memory from the stack is much faster than allocating memory on
//  the heap, and the memory is automatically freed when the function is exited.
//  In addition, these macros avoid calling WideCharToMultiByte more than one
//  time.  This is done by allocating a little bit more memory than is
//  necessary.  We know that an MBC will convert into at most one WCHAR and
//  that for each WCHAR we will have a maximum of two MBC bytes.  By allocating
//  a little more than necessary, but always enough to handle the conversion
//  the second call to the conversion function is avoided.  The call to the
//  helper function UnicodeToAnsi reduces the number of argument pushes that
//  must be done in order to perform the conversion (this results in smaller
//  code, than if it called WideCharToMultiByte directly).
//
//  In order for the macros to store the temporary length and the pointer to
//  the resultant string, it is necessary to declare some local variables
//  called _len and _sz in each function that uses these conversion macros.
//  This is done by invoking the PreConvert macro in each function before any
//  uses of Convert or ConverWithLen.  (PreConvert just need to be invoked once
//  per function.)

#define PreConvert() \
	LONG   _len;     \
	LPSTR  _sz;      \
	LONG   _lJunk;   \
	_lJunk; // Unused sometimes

// stack-allocates a char buffer of size cch
#define SzAlloc(cch)  ((LPSTR)_alloca(cch))

// stack-allocates a wchar buffer of size cch
#define SzWAlloc(cch) ((LPWSTR)_alloca(cch * sizeof(WCHAR)))

// Returns a properly converted string,
//   or NULL string on failure or szFrom == NULL
// On return the variable passed via pnTo will have the output byte count
//   (including the trailing '\0' iff the nFrom is -1)
#define ConvertWithLen(szFrom, nFrom, pnTo) \
			(!szFrom ? NULL : \
				(_len = (-1 == nFrom ? (wcslen(szFrom) + 1) : nFrom) * \
						sizeof(WCHAR), \
				 _sz = SzAlloc(_len + sizeof(WCHAR)), \
				 Debug(_sz[_len] = '\0'), \
				 ( ((*pnTo) = UnicodeToAnsi(_sz, szFrom, _len, nFrom)) < 0 ? \
				  (AssertFail("Convert failed in Unicode wrapper"), NULL) : \
				  (Assert('\0' == _sz[_len]), _sz) ) ) )
#define Convert(szFrom) ConvertWithLen(szFrom, -1, &_lJunk)

// There are strings which are blocks of strings end to end with a trailing '\0'
// to indicate the true end.  These strings are used with the REG_MULTI_SZ
// option of the Reg... routines and the lpstrFilter field of the OPENFILENAME
// structure used in the GetOpenFileName and GetSaveFileName routines.  To help
// in converting these strings here are two routines which calculate the length
// of the Unicode and ASNI versions (including all '\0's!):

size_t
cUnicodeMultiSzLen
(
LPCWSTR lpsz
) throw()
{
	size_t cRet = 0;
	while (*lpsz)
		{
		size_t c = wcslen(lpsz) + 1;
		cRet += c;
		lpsz += c;
		}
	return cRet + 1;
}

size_t
cAnsiMultiSzLen
(
LPCSTR lpsz
) throw()
{
	size_t cRet = 0;
	while (*lpsz)
		{
		size_t c = _mbslen((const unsigned char*)lpsz) + 1;
		cRet += c;
		lpsz += c;
		}
	return cRet + 1;
}

extern "C"{

// Added by VanK for DHTMLEdit OCX
HINTERNET
WINAPI
OInternetOpenW(LPCWSTR lpszAgent, DWORD dwAccessType, LPCWSTR lpszProxy, LPCWSTR lpszProxyBypass, DWORD dwFlags)
{
	if(FWide())
		return InternetOpenW(lpszAgent, dwAccessType, lpszProxy, lpszProxyBypass, dwFlags);

	PreConvert();

	LPSTR szAgent	= NULL;
	LPSTR szProxy	= NULL;
	LPSTR szBypass	= NULL;

	if ( NULL != lpszAgent )
		szAgent = Convert(lpszAgent);
	if ( NULL != lpszProxy )
		szProxy = Convert(lpszProxy);
	if ( NULL != lpszProxyBypass )
		szBypass = Convert(lpszProxyBypass);

	return InternetOpenA(szAgent, dwAccessType, szProxy, szBypass, dwFlags);
}


HINTERNET
WINAPI
OInternetOpenUrlW(HINTERNET hInternet, LPCWSTR lpszUrl, LPCWSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext)
{
	if(FWide())
		return InternetOpenUrlW(hInternet, lpszUrl, lpszHeaders, dwHeadersLength, dwFlags, dwContext);

	PreConvert();

	LPSTR szURL		= NULL;
	LPSTR szHead	= NULL;

	if ( NULL != lpszUrl )
		szURL = Convert(lpszUrl);
	if ( NULL != lpszHeaders )
		szHead = Convert(lpszHeaders);

	return InternetOpenUrlA(hInternet, szURL, szHead, dwHeadersLength, dwFlags, dwContext);
}


HRESULT
__stdcall
OURLOpenBlockingStreamW(
	LPUNKNOWN				pCaller,	// In
	LPCWSTR					wszURL,		// In
	LPSTREAM				*ppStream,	// Out
	DWORD					dwReserved,	// In
	LPBINDSTATUSCALLBACK	lpfnCB		// In
	)
{
	if(FWide())
		return URLOpenBlockingStreamW(pCaller, wszURL, ppStream, dwReserved, lpfnCB);

	PreConvert();
	LPSTR szURL = Convert(wszURL);
	return URLOpenBlockingStreamA(pCaller, szURL, ppStream, dwReserved, lpfnCB);
}

// Added by VanK for DHTMLEdit OCX
// lpdwUrlLength must be set even on failure; callers use a zero length to determine
// how many bytes to actually allocate.
// NOTE that contrary to all expectations, lpdwUrlLength is a byte count, not a character count!
BOOL
WINAPI
OInternetCreateUrlW(
	LPURL_COMPONENTSW	lpUrlComponents,	// In
	DWORD				dwFlags,			// In
	LPWSTR				lpwszUrl,			// Out
	LPDWORD				lpdwUrlLength		// In/Out
	)
{
	Assert ( lpUrlComponents );
	Assert ( lpdwUrlLength );

	if(FWide())
		return InternetCreateUrlW(lpUrlComponents, dwFlags, lpwszUrl, lpdwUrlLength);

	PreConvert();
	DWORD cchLen = (*lpdwUrlLength) / sizeof(WCHAR);	// dwUrlLength is a count of bytes
	LPSTR szUrl = SzAlloc(*lpdwUrlLength);
	URL_COMPONENTSA	urlaComp;
	memset ( &urlaComp, 0, sizeof ( urlaComp ) );	// In case this is ever recompiled with a larger structure

	urlaComp.dwStructSize		= sizeof(URL_COMPONENTSA);
    urlaComp.lpszScheme			= Convert(lpUrlComponents->lpszScheme);
	urlaComp.dwSchemeLength		= lpUrlComponents->dwSchemeLength;
	urlaComp.nScheme			= lpUrlComponents->nScheme;
    urlaComp.lpszHostName		= Convert(lpUrlComponents->lpszHostName);
	urlaComp.dwHostNameLength	= lpUrlComponents->dwHostNameLength;
	urlaComp.nPort				= lpUrlComponents->nPort;
	urlaComp.lpszUserName		= Convert(lpUrlComponents->lpszUserName);
	urlaComp.dwUserNameLength	= lpUrlComponents->dwUserNameLength;
	urlaComp.lpszPassword		= Convert(lpUrlComponents->lpszPassword);
	urlaComp.dwPasswordLength	= lpUrlComponents->dwPasswordLength;
	urlaComp.lpszUrlPath		= Convert(lpUrlComponents->lpszUrlPath);
	urlaComp.dwUrlPathLength	= lpUrlComponents->dwUrlPathLength;
	urlaComp.lpszExtraInfo		= Convert(lpUrlComponents->lpszExtraInfo);
	urlaComp.dwExtraInfoLength	= lpUrlComponents->dwExtraInfoLength;

	BOOL bfResult = InternetCreateUrlA(&urlaComp, dwFlags, szUrl, &cchLen);
	*lpdwUrlLength = cchLen*sizeof(WCHAR);	// Return even on fail; this tells how much to allocate on next call.
	if ( bfResult )
	{
		LONG lRet = AnsiToUnicode(lpwszUrl, szUrl, *lpdwUrlLength, cchLen);
		*lpdwUrlLength = lRet * sizeof(WCHAR);
	}
	return bfResult;
}

// Added by VanK for DHTMLEdit OCX
//	INCOMPLETE IMPLEMENTATION:
//	This implementation is not designed to work in the case where string pointers
//	are specified as NULL and their corresponding lengths non-zero.
//	Normally, this results in a pointer to the first character of the corresponding
//	component to be stored in the pointer.
//
//	IMPLEMENTATION NOTE:
//	Returned strings are terminated.  Although the system implementation seems to assume
//	that the buffers are one character larger than the character count supplied, and
//	thereby equipped to accept an additional terminator, this behavior is never clearly
//	documented.  I feel this behavior is too unsafe, so ONE CHARACTER LESS than the
//	buffer size in characters is the maximum size of the string that can be returned.
BOOL WINAPI OInternetCrackUrlW(
	LPCWSTR				lpwszUrl,		// In
	DWORD				dwUrlLength,	// In
	DWORD				dwFlags,		// In
	LPURL_COMPONENTSW	lpUrlComponents	// Out
	)
{
	if(FWide())
		return InternetCrackUrlW(lpwszUrl, dwUrlLength, dwFlags, lpUrlComponents);

	// Test our limitation restrictions:
	Assert ( ((NULL != lpUrlComponents->lpszScheme) && (0 < lpUrlComponents->dwSchemeLength)) ||
			 ((NULL == lpUrlComponents->lpszScheme) && (0 == lpUrlComponents->dwSchemeLength)));
	Assert ( ((NULL != lpUrlComponents->lpszHostName) && (0 < lpUrlComponents->dwHostNameLength)) ||
			 ((NULL == lpUrlComponents->lpszHostName) && (0 == lpUrlComponents->dwHostNameLength)));
	Assert ( ((NULL != lpUrlComponents->lpszUserName) && (0 < lpUrlComponents->dwUserNameLength)) ||
			 ((NULL == lpUrlComponents->lpszUserName) && (0 == lpUrlComponents->dwUserNameLength)));
	Assert ( ((NULL != lpUrlComponents->lpszPassword) && (0 < lpUrlComponents->dwPasswordLength)) ||
			 ((NULL == lpUrlComponents->lpszPassword) && (0 == lpUrlComponents->dwPasswordLength)));
	Assert ( ((NULL != lpUrlComponents->lpszUrlPath) && (0 < lpUrlComponents->dwUrlPathLength)) ||
			 ((NULL == lpUrlComponents->lpszUrlPath) && (0 == lpUrlComponents->dwUrlPathLength)));
	Assert ( ((NULL != lpUrlComponents->lpszExtraInfo) && (0 < lpUrlComponents->dwExtraInfoLength)) ||
			 ((NULL == lpUrlComponents->lpszExtraInfo) && (0 == lpUrlComponents->dwExtraInfoLength)));

	PreConvert();
	LPCSTR	szURLIn		= Convert(lpwszUrl);
	LPSTR	szScheme	= NULL;
	LPSTR	szHostName	= NULL;
	LPSTR	szUserName	= NULL;
	LPSTR	szPassword	= NULL;
	LPSTR	szUrlPath	= NULL;
	LPSTR	szExtraInfo	= NULL;

	URL_COMPONENTSA	urlaComp;
	memset ( &urlaComp, 0, sizeof ( urlaComp ) );	// In case this is ever recompiled with a larger structure
	
	if ( 0 != lpUrlComponents->dwSchemeLength && NULL != lpUrlComponents->lpszScheme )
	{
		szScheme = SzAlloc((lpUrlComponents->dwSchemeLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwHostNameLength && NULL != lpUrlComponents->lpszHostName )
	{
		szHostName = SzAlloc((lpUrlComponents->dwHostNameLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwUserNameLength && NULL != lpUrlComponents->lpszUserName )
	{
		szUserName = SzAlloc((lpUrlComponents->dwUserNameLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwPasswordLength && NULL != lpUrlComponents->lpszPassword )
	{
		szPassword = SzAlloc((lpUrlComponents->dwPasswordLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwUrlPathLength && NULL != lpUrlComponents->lpszUrlPath )
	{
		szUrlPath = SzAlloc((lpUrlComponents->dwUrlPathLength+1)*sizeof(WCHAR));
	}
	if ( 0 != lpUrlComponents->dwExtraInfoLength && NULL != lpUrlComponents->lpszExtraInfo )
	{
		szExtraInfo = SzAlloc((lpUrlComponents->dwExtraInfoLength+1)*sizeof(WCHAR));
	}

	urlaComp.dwStructSize		= sizeof(URL_COMPONENTSA);
    urlaComp.lpszScheme			= szScheme;
	urlaComp.dwSchemeLength		= lpUrlComponents->dwSchemeLength;
	urlaComp.nScheme			= lpUrlComponents->nScheme;
    urlaComp.lpszHostName		= szHostName;
	urlaComp.dwHostNameLength	= lpUrlComponents->dwHostNameLength;
	urlaComp.nPort				= lpUrlComponents->nPort;
	urlaComp.lpszUserName		= szUserName;
	urlaComp.dwUserNameLength	= lpUrlComponents->dwUserNameLength;
	urlaComp.lpszPassword		= szPassword;
	urlaComp.dwPasswordLength	= lpUrlComponents->dwPasswordLength;
	urlaComp.lpszUrlPath		= szUrlPath;
	urlaComp.dwUrlPathLength	= lpUrlComponents->dwUrlPathLength;
	urlaComp.lpszExtraInfo		= szExtraInfo;
	urlaComp.dwExtraInfoLength	= lpUrlComponents->dwExtraInfoLength;

	BOOL bfResult = InternetCrackUrlA ( szURLIn, dwUrlLength, dwFlags, &urlaComp );
	
	if ( bfResult )
	{
		lpUrlComponents->nScheme = urlaComp.nScheme;
		lpUrlComponents->nPort = urlaComp.nPort;

		if ( NULL != szScheme )
		{
			lpUrlComponents->dwSchemeLength = AnsiToUnicode(
				lpUrlComponents->lpszScheme, szScheme,
				lpUrlComponents->dwSchemeLength, urlaComp.dwSchemeLength+1) - 1;
		}
		if ( NULL != szHostName )
		{
			lpUrlComponents->dwHostNameLength = AnsiToUnicode(
				lpUrlComponents->lpszHostName, szHostName,
				lpUrlComponents->dwHostNameLength, urlaComp.dwHostNameLength+1) - 1;
		}
		if ( NULL != szUserName )
		{
			lpUrlComponents->dwUserNameLength = AnsiToUnicode(
				lpUrlComponents->lpszUserName, szUserName,
				lpUrlComponents->dwUserNameLength, urlaComp.dwUserNameLength+1) - 1;
		}
		if ( NULL != szPassword )
		{
			lpUrlComponents->dwPasswordLength = AnsiToUnicode(
				lpUrlComponents->lpszPassword, szPassword,
				lpUrlComponents->dwPasswordLength, urlaComp.dwPasswordLength+1) - 1;
		}
		if ( NULL != szUrlPath )
		{
			lpUrlComponents->dwUrlPathLength = AnsiToUnicode(
				lpUrlComponents->lpszUrlPath, szUrlPath,
				lpUrlComponents->dwUrlPathLength, urlaComp.dwUrlPathLength+1) - 1;
		}
		if ( NULL != szExtraInfo )
		{
			lpUrlComponents->dwExtraInfoLength = AnsiToUnicode(
				lpUrlComponents->lpszExtraInfo, szExtraInfo,
				lpUrlComponents->dwExtraInfoLength, urlaComp.dwExtraInfoLength+1) - 1;
		}
	}
	return bfResult;
}

// Added by VanK for DHTMLEdit OCX
BOOL
WINAPI
ODeleteUrlCacheEntryW(
	LPCWSTR	lpwszUrlName	// In
	)
{
	if(FWide())
		return DeleteUrlCacheEntryW(lpwszUrlName);

	PreConvert();
	LPSTR szUrlName = Convert(lpwszUrlName);
	return DeleteUrlCacheEntryA(szUrlName);
}

BOOL
WINAPI
OAppendMenuW(
	HMENU hMenu,
	UINT uFlags,
	UINT uIDnewItem,
	LPCWSTR lpnewItem
	)
{
	if(FWide())
		return AppendMenuW(hMenu, uFlags, uIDnewItem, lpnewItem);

	if(MF_STRING != uFlags)
		return AppendMenuA(hMenu, uFlags, uIDnewItem, (LPSTR)lpnewItem);

	PreConvert();
	LPSTR sz = Convert(lpnewItem);
	return AppendMenuA(hMenu, uFlags, uIDnewItem, sz);
}

LRESULT
WINAPI
OCallWindowProcW(
	WNDPROC lpPrevWndFunc,
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);

	return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);  //$ CONSIDER - Not really wrapped
}

DWORD
WINAPI
OCharLowerBuffW(
	LPWSTR lpsz,
	DWORD cchLength)
{
	if(!lpsz)
		return 0;

	if(FWide())
		return CharLowerBuffW(lpsz, cchLength);

	DWORD i = 0;
	while(i++ < cchLength)
		{
		*lpsz = towlower(*lpsz);
		lpsz++;
		}
	return i;
}

LPWSTR
WINAPI
OCharLowerW(
	LPWSTR lpsz)
{
	if(!lpsz)
		return NULL;

	if(FWide())
		return CharLowerW(lpsz);

	// Checking if it's a single byte character.
	if(FATOM(lpsz))
		{
		return (LPWSTR)towlower((WCHAR)LOWORD(lpsz));
		}

	LPWSTR lp = lpsz;

	while(*lp)
		{
		*lp = towlower(*lp);
		lp++;
		}
	return lpsz;
}

// From: Mark Ashton on 5/29/97
LPWSTR
WINAPI
OCharPrevW(
	LPCWSTR lpszStart,
	LPCWSTR lpszCurrent)
{
	return (LPWSTR)((lpszStart != lpszCurrent) ? lpszCurrent - 1 : lpszCurrent);
}

BOOL
WINAPI
OCharToOemW(
	LPCWSTR lpszSrc,
	LPSTR lpszDst)
{
	if(FWide())
		{
		Assert((LPSTR) lpszSrc != lpszDst);
		return CharToOemW(lpszSrc, lpszDst);
		}

	PreConvert();
	LPSTR sz = Convert(lpszSrc);

	return CharToOemA(sz, lpszDst);
}

LPWSTR
WINAPI
OCharUpperW(
	LPWSTR lpsz)
{
	if(!lpsz)
		return NULL;

	if(FWide())
		return CharUpperW(lpsz);

	// Checking if it's a single byte character.
	if(FATOM(lpsz))
		{
		return (LPWSTR)towupper((WCHAR)LOWORD(lpsz));
		}

	LPWSTR lp = lpsz;

	while(*lp)
		{
		*lp = towupper(*lp);
		lp++;
		}
	return lpsz;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OCopyFileW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName,
	BOOL bFailIfExists
	)
{
	if (FWide())
		return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);

	char szExisting[_MAX_PATH], szNew[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szExisting, lpExistingFileName, _MAX_PATH));
	Verify(0 <= UnicodeToAnsi(szNew, lpNewFileName, _MAX_PATH));
	return CopyFileA(szExisting, szNew, bFailIfExists);
}

HDC
WINAPI
OCreateDCW(
	LPCWSTR lpszDriver,
	LPCWSTR lpszDevice,
	LPCWSTR lpszOutput,
	CONST DEVMODEW *lpInitData)
{
	Assert(!lpszOutput);
	if(FWide())
		return CreateDCW(lpszDriver, lpszDevice, lpszOutput, lpInitData);

	DEVMODEA *pdma = lpInitData ?
						(DEVMODEA*)SzAlloc(sizeof(DEVMODEA) + lpInitData->dmDriverExtra) :
						NULL;

	PreConvert();
	LPSTR szDriv = Convert(lpszDriver);
	LPSTR szDev = NULL;

	// in Win95, only "display" is allowed as a driver name
	if (szDriv && !lstrcmpiA(szDriv, "display"))
		{
		Assert(!lpszDevice);
		Assert(!lpInitData);
		pdma = NULL;	// Force to NULL.
		}
	else
		{
#ifdef DEBUG
		// For NT we pass this in so only assert if this is
		// not true.
		if (szDriv && lstrcmpiA(szDriv, "winspool"))
			Assert(!lpszDriver);
#endif // DEBUG
		szDriv = NULL;
		Assert(lpszDevice);
		szDev = Convert(lpszDevice);
		if (lpInitData)
			{
			CvtDevmode(pdma, lpInitData);
			}
		}

	return CreateDCA(szDriv, szDev, NULL, pdma);
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OCreateDirectoryW(
	LPCWSTR lpPathName,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	if (FWide())
		return CreateDirectoryW(lpPathName, lpSecurityAttributes);

	PreConvert();
	LPSTR sz = Convert(lpPathName);
	return CreateDirectoryA(sz, NULL);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith: simpified on 6/25
// Smoke tested by Mark Ashton on 6/25
BOOL
WINAPI
OCreateDirectoryExW(
	LPCWSTR lpTemplateDirectory,
	LPCWSTR lpNewDirectory,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	if (FWide())
		return CreateDirectoryExW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);

	PreConvert();
	LPSTR szTemplateDirectory = Convert(lpTemplateDirectory);
	LPSTR szNewDirectory      = Convert(lpNewDirectory);
	return CreateDirectoryExA(szTemplateDirectory, szNewDirectory, NULL);
}

HDC
WINAPI
OCreateEnhMetaFileW(
	HDC hdc,
	LPCWSTR lpFileName,
	CONST RECT *lpRect,
	LPCWSTR lpDescription)
{
	if(FWide())
		return CreateEnhMetaFileW(hdc, lpFileName, lpRect, lpDescription);

	PreConvert();
	LPSTR szN = Convert(lpFileName);
	LPSTR szD = ConvertWithLen(lpDescription, cUnicodeMultiSzLen(lpDescription), &_lJunk);
	return  CreateEnhMetaFileA(hdc, szN, lpRect, szD);
}

HANDLE
WINAPI
OCreateEventW(
	LPSECURITY_ATTRIBUTES lpEventAttributes,
	BOOL bManualReset,
	BOOL bInitialState,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateEventA(lpEventAttributes, bManualReset, bInitialState, sz);
}

HANDLE
WINAPI
OCreateFileW(
	LPCWSTR lpFileName,
	DWORD dwDesiredAccess,
	DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes,
	HANDLE hTemplateFile
	)
{
	// Don't even attempt this on Win95!
	Assert(0 != wcsncmp(lpFileName, L"\\\\?\\", 4));

	if(FWide())
		return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
			dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	return CreateFileA(sz, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
		dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

HFONT
WINAPI
OCreateFontIndirectW(CONST LOGFONTW * plfw)
{
	Assert(plfw);

	if(FWide())
		return CreateFontIndirectW(plfw);

	LOGFONTA  lfa;

	// It's assumed here that sizeof(LOGFONTA) <= sizeof (LOGFONTW);
	memcpy(&lfa, plfw, sizeof(LOGFONTA));

	Verify(0 <= UnicodeToAnsi(lfa.lfFaceName, plfw->lfFaceName, LF_FACESIZE));
	return CreateFontIndirectA(&lfa);
}

// From: Mark Ashton on 5/29/97
HFONT
OCreateFontW(
	int nHeight, // logical height of font
	int nWidth, // logical average character width
	int nEscapement, // angle of escapement
	int nOrientation, // base-line orientation angle
	int fnWeight, // font weight
	DWORD fdwItalic, // italic attribute flag
	DWORD fdwUnderline, // underline attribute flag
	DWORD fdwStrikeOut, // strikeout attribute flag
	DWORD fdwCharSet, // character set identifier
	DWORD fdwOutputPrecision, // output precision
	DWORD fdwClipPrecision, // clipping precision
	DWORD fdwQuality, // output quality
	DWORD fdwPitchAndFamily, // pitch and family
	LPCWSTR lpszFace) // pointer to typeface name string
{
	if (FWide())
		return CreateFontW(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, lpszFace);
	PreConvert();
	LPSTR sz = Convert(lpszFace);
	return CreateFontA(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, sz);
}

HWND
WINAPI
OCreateMDIWindowW(
	LPWSTR lpClassName,
	LPWSTR lpWindowName,
	DWORD dwStyle,
	int X,
	int Y,
	int nWidth,
	int nHeight,
	HWND hWndParent,
	HINSTANCE hInstance,
	LPARAM lParam
	)
{
	if(FWide())
		return CreateMDIWindowW(lpClassName, lpWindowName, dwStyle,
			X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);

	PreConvert();
	LPSTR szClass = Convert(lpClassName);
	LPSTR szWin   = Convert(lpWindowName);

	return CreateMDIWindowA(szClass, szWin, dwStyle,
			X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
}

HDC
WINAPI
OCreateMetaFileW(LPCWSTR lpstr)
{
	if(FWide())
		return CreateMetaFileW(lpstr);

	PreConvert();
	LPSTR sz = Convert(lpstr);
	return CreateMetaFileA(sz);
}

HANDLE
WINAPI
OCreateSemaphoreW(
	LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
	LONG lInitialCount,
	LONG lMaximumCount,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateSemaphoreA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, sz);
}

HWND
WINAPI
OCreateWindowExW( DWORD dwExStyle,
			  LPCWSTR lpClassName,
				LPCWSTR lpWindowName,
				DWORD dwStyle,
				int X,
				int Y,
				int nWidth,
				int nHeight,
				HWND hWndParent ,
				HMENU hMenu,
				HINSTANCE hInstance,
				LPVOID lpParam )
{
	if(FWide())
		return CreateWindowExW(dwExStyle,
				lpClassName,
				lpWindowName,
				dwStyle,
				X,
				Y,
				nWidth,
				nHeight,
				hWndParent ,
				hMenu,
				hInstance,
				lpParam );

	PreConvert();

	LPSTR szClass;
	if (FATOM(lpClassName))
		{
		// is it an atom?
		szClass = (LPSTR) lpClassName;
		}
	else
		{
		// otherwise convert the string
		szClass = Convert(lpClassName);
		}
	LPSTR szWindow = Convert(lpWindowName);

	return CreateWindowExA (dwExStyle, szClass, szWindow, dwStyle, X, Y,
						 nWidth, nHeight, hWndParent, hMenu, hInstance,
						 lpParam);

}

HSZ
WINAPI
ODdeCreateStringHandleW(
	DWORD idInst,
	LPCWSTR psz,
	int iCodePage)
{
	if(FWide())
		{
		Assert(CP_WINUNICODE == iCodePage);
		return DdeCreateStringHandleW(idInst, psz, iCodePage);
		}
	PreConvert();
	LPSTR sz = Convert(psz);
	return DdeCreateStringHandleA(idInst, sz, CP_WINANSI);
}

UINT
WINAPI
ODdeInitializeW(
	LPDWORD pidInst,
	PFNCALLBACK pfnCallback,
	DWORD afCmd,
	DWORD ulRes)
{
	if(FWide())
		return DdeInitializeW(pidInst, pfnCallback, afCmd, ulRes);
	return DdeInitializeA(pidInst, pfnCallback, afCmd, ulRes);
}

LRESULT
WINAPI
ODefFrameProcW(
	HWND hWnd,
	HWND hWndMDIClient ,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefFrameProcW(hWnd, hWndMDIClient , uMsg, wParam, lParam);

	return DefFrameProcA(hWnd, hWndMDIClient , uMsg, wParam, lParam);
}

LRESULT
WINAPI
ODefMDIChildProcW(
	HWND hWnd,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefMDIChildProcW(hWnd, uMsg, wParam, lParam);

	return DefMDIChildProcA(hWnd, uMsg, wParam, lParam);
}

LRESULT
WINAPI
ODefWindowProcW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefWindowProcW( hWnd, Msg,wParam, lParam);

	return DefWindowProcA( hWnd, Msg,wParam, lParam);
}

BOOL
WINAPI
ODeleteFileW(
	LPCWSTR pwsz)
{
	if(FWide())
		return DeleteFileW(pwsz);

	PreConvert();
	LPSTR sz = Convert(pwsz);
	return DeleteFileA(sz);
}

LRESULT
WINAPI
ODialogBoxIndirectParamW(
	HINSTANCE hInstance,
	LPCDLGTEMPLATEW hDialogTemplate,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	if(FWide())
		return DialogBoxIndirectParamW(hInstance, hDialogTemplate, hWndParent ,
			lpDialogFunc, dwInitParam);

	return DialogBoxIndirectParamA(hInstance, hDialogTemplate, hWndParent ,
			lpDialogFunc, dwInitParam);
}

LRESULT
WINAPI
ODialogBoxParamW(
	HINSTANCE hInstance,
	LPCWSTR lpTemplateName,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	if(FWide())
		return DialogBoxParamW(hInstance, lpTemplateName, hWndParent , lpDialogFunc, dwInitParam);

	if(FATOM(lpTemplateName))
		return DialogBoxParamA(hInstance, (LPSTR)lpTemplateName, hWndParent , lpDialogFunc, dwInitParam);

	PreConvert();
	LPSTR sz = Convert(lpTemplateName);
	return DialogBoxParamA(hInstance, sz, hWndParent , lpDialogFunc, dwInitParam);
}

LRESULT
WINAPI
ODispatchMessageW(
	CONST MSG *lpMsg)
{
	if(FWide())
		return DispatchMessageW(lpMsg);

	return DispatchMessageA(lpMsg);
}

int
WINAPI
ODrawTextW(
	HDC hDC,
	LPCWSTR lpString,
	int nCount,
	LPRECT lpRect,
	UINT uFormat)
{
	// NOTE OS may write 3 characters beyond end of lpString so make room!


	if(FWide())
		return DrawTextW(hDC, lpString, nCount, lpRect, uFormat);

	bool fModifyString = (uFormat & DT_MODIFYSTRING) &&
						 (uFormat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS));

	const int nBuff = WideCharToMultiByte(CP_ACP, 0, lpString, nCount,
										  NULL, 0, NULL, NULL );
	Assert(0 <= nBuff);

	// OS may write beyond end of buffer so make room!
	const LPSTR sz = SzAlloc(nBuff + 4);

	Verify(nBuff == WideCharToMultiByte(CP_ACP, 0, lpString, nCount,
										sz, nBuff, NULL, NULL ));

	if (fModifyString)
		{
		// DrawTextA doesn't nessacerily '\0' terminate the output,
		// so have termiators ready
		memcpy(sz + nBuff, "\0\0\0\0", 4);
		}

	const int iDrawTextReturn = DrawTextA(hDC, sz, nBuff - 1, lpRect, uFormat);

	// With certain flags, DrawText modifies the string, truncating it with
	// an ellipsis.  We need to convert back and update the string passed to
	// the wrapper before we return.
	if (fModifyString && 0 <= iDrawTextReturn)
		{
		Assert('\0' == sz[nBuff + 3]); // Verify not too many were overwritten

		// The windows function prototype has lpString as constant even
		//    though the string gets modified!
		const int nStringLen = -1 != nCount ? nCount : wcslen(lpString);
		Verify(0 <= AnsiToUnicode(const_cast<LPWSTR>(lpString), sz,
								 nStringLen + 4 ));
		}
	return iDrawTextReturn;
}

// Written by Bill Hiebert on 9/4/97
// Smoke tested by Bill Hiebert 9/4/97
int
WINAPI
ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams)
{
	Assert(-1 != cb);
	Assert(!(DT_MODIFYSTRING & dwDTFormat));

	if(FWide())
		return DrawTextExW(hdc, pwsz, cb, lprect, dwDTFormat, lpDTParams);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);

	return DrawTextExA(hdc, sz, n, lprect, dwDTFormat, lpDTParams);
}


// Written for Carlos Gomes on 6/26/97 by Ted Smith
// Smoke tested by Carlos Gomes on 6/26
DWORD
WINAPI
OExpandEnvironmentStringsW(
	LPCWSTR lpSrc,
	LPWSTR lpDst,
	DWORD nSize
	)
{
	if (FWide())
		return ExpandEnvironmentStringsW(lpSrc, lpDst, nSize);

	PreConvert();
	LPSTR szSrc = Convert(lpSrc);
	LPSTR szDst = SzAlloc(sizeof(WCHAR) * nSize);
	DWORD dwRet = ExpandEnvironmentStringsA(szSrc, szDst, sizeof(WCHAR) * nSize);

	if (dwRet)
		{
		LONG lRet = AnsiToUnicode(lpDst, szDst, nSize, min(dwRet, sizeof(WCHAR) * nSize));
		if (dwRet < (DWORD) lRet)
			{
			dwRet = lRet;
			}
		}
	else if (lpDst && 0 < nSize)
		{
		*lpDst = L'\0';
		}

	return dwRet;
}

VOID
WINAPI
OFatalAppExitW(
	UINT uAction,
	LPCWSTR lpMessageText
	)
{
	if(FWide())
		FatalAppExitW(uAction, lpMessageText);

	PreConvert();
	LPSTR sz = Convert(lpMessageText);
	FatalAppExitA(uAction, sz);
}

// From: Mark Ashton on 5/8/97
HANDLE
WINAPI
OFindFirstChangeNotificationW(
	LPCWSTR lpPathName,
	BOOL bWatchSubtree,
	DWORD dwNotifyFilter
	)
{
	if (FWide())
		return FindFirstChangeNotificationW(lpPathName, bWatchSubtree, dwNotifyFilter);

	PreConvert();
	LPSTR sz = Convert(lpPathName);
	return FindFirstChangeNotificationA(sz, bWatchSubtree, dwNotifyFilter);
}

// From: Mark Ashton on 5/8/97
HANDLE
WINAPI
OFindFirstFileW(
	LPCWSTR lpFileName,
	LPWIN32_FIND_DATAW lpFindFileData
	)
{
	if (FWide())
		return FindFirstFileW(lpFileName, lpFindFileData);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	WIN32_FIND_DATAA findFileData;
	HANDLE h = FindFirstFileA(sz, &findFileData);
	if (INVALID_HANDLE_VALUE != h)
		{
		lpFindFileData->dwFileAttributes    = findFileData.dwFileAttributes;
		lpFindFileData->ftCreationTime      = findFileData.ftCreationTime;
		lpFindFileData->ftLastAccessTime    = findFileData.ftLastAccessTime;
		lpFindFileData->ftLastWriteTime     = findFileData.ftLastWriteTime;
		lpFindFileData->nFileSizeHigh       = findFileData.nFileSizeHigh;
		lpFindFileData->nFileSizeLow        = findFileData.nFileSizeLow;
		lpFindFileData->dwReserved0         = findFileData.dwReserved0;
		lpFindFileData->dwReserved1         = findFileData.dwReserved1;
		Verify(0 <= AnsiToUnicode(lpFindFileData->cFileName, findFileData.cFileName, _MAX_PATH));
		Verify(0 <= AnsiToUnicode(lpFindFileData->cAlternateFileName, findFileData.cAlternateFileName, 14));
		}
	return h;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OFindNextFileW(
	HANDLE hFindFile,
	LPWIN32_FIND_DATAW lpFindFileData
	)
{
	if (FWide())
		return FindNextFileW(hFindFile, lpFindFileData);

	WIN32_FIND_DATAA findFileData;
	BOOL fFlag = FindNextFileA(hFindFile, &findFileData);
	if (fFlag)
		{
		lpFindFileData->dwFileAttributes    = findFileData.dwFileAttributes;
		lpFindFileData->ftCreationTime      = findFileData.ftCreationTime;
		lpFindFileData->ftLastAccessTime    = findFileData.ftLastAccessTime;
		lpFindFileData->ftLastWriteTime     = findFileData.ftLastWriteTime;
		lpFindFileData->nFileSizeHigh       = findFileData.nFileSizeHigh;
		lpFindFileData->nFileSizeLow        = findFileData.nFileSizeLow;
		lpFindFileData->dwReserved0         = findFileData.dwReserved0;
		lpFindFileData->dwReserved1         = findFileData.dwReserved1;
		Verify(0 <= AnsiToUnicode(lpFindFileData->cFileName, findFileData.cFileName, _MAX_PATH));
		Verify(0 <= AnsiToUnicode(lpFindFileData->cAlternateFileName, findFileData.cAlternateFileName, 14));
		}
	return fFlag;
}

HRSRC
WINAPI
OFindResourceW(
	HINSTANCE hModule,
	LPCWSTR lpName,
	LPCWSTR lpType
	)
{
	if(FWide())
		return FindResourceW(hModule, lpName, lpType);

	LPCSTR szName = (LPCSTR)lpName;
	LPCSTR szType = (LPCSTR)lpType;

	PreConvert();
	if(!FATOM(lpName))
		szName = Convert(lpName);
	if(!FATOM(lpType))
		szType = Convert(lpType);

	return FindResourceA(hModule, szName, szType);
}

HWND
WINAPI
OFindWindowW(
	LPCWSTR lpClassName ,
	LPCWSTR lpWindowName)
{
	if(FWide())
		return FindWindowW(lpClassName , lpWindowName);

	PreConvert();
	LPSTR szClass = Convert(lpClassName);
	LPSTR szWnd   = Convert(lpWindowName);

	return FindWindowA(szClass, szWnd);
}

// Bill Hiebert of IStudio on 6/13/97 added support for the
//   FORMAT_MESSAGE_ALLOCATE_BUFFER flag
// Bill donated a bugfix for 1819 on 8/1/97

DWORD
WINAPI
OFormatMessageW(
	DWORD dwFlags,
	LPCVOID lpSource,
	DWORD dwMessageId,
	DWORD dwLanguageId,
	LPWSTR lpBuffer,
	DWORD nSize,
	va_list *Arguments)
{

	if (FWide())
		return FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId,
							  lpBuffer, nSize, Arguments );

	DWORD dwRet;

	LPSTR szBuffer = NULL;

	if (!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER))
		{
		Assert(!IsBadWritePtr(lpBuffer, nSize * sizeof(WCHAR)));
		szBuffer = SzAlloc(sizeof(WCHAR) * nSize);
		}

	if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
		{
		PreConvert();
		LPSTR szSource = Convert((LPWSTR)lpSource);

		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{   // Must pass address of szBuffer
			dwRet = FormatMessageA(dwFlags, szSource, dwMessageId, dwLanguageId,
				(char*)&szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		else
			{
			dwRet = FormatMessageA(dwFlags, szSource, dwMessageId, dwLanguageId,
				szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		}
	else
		{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{   // Must pass address of szBuffer
			dwRet = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId,
					(char*)&szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		else
			{
			dwRet = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId,
					szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		}

	if (dwRet)
		{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{ // szBuffer contains LocalAlloc ptr to new string. lpBuffer is a
			  // WCHAR** when FORMAT_MESSAGE_ALLOCATE_BUFFER is defined.
			WCHAR* pTemp = (WCHAR*)LocalAlloc(NONZEROLPTR, (dwRet + 1) * sizeof(WCHAR) );
			dwRet = pTemp == NULL? 0 : AnsiToUnicode(pTemp, szBuffer, dwRet + 1);
			LocalFree(szBuffer);
			if (dwRet)
				{
				*(WCHAR**)lpBuffer = pTemp;
				}
			return dwRet;
			}
		else
			{ // Just convert
			return AnsiToUnicode(lpBuffer, szBuffer, nSize);
			}
		}
	else if (lpBuffer && 0 < nSize)
		{
		*lpBuffer = L'\0';
		}

	return dwRet;
}

BOOL
APIENTRY
OGetCharABCWidthsFloatW(
	HDC     hdc,
	UINT    uFirstChar,
	UINT    uLastChar,
	LPABCFLOAT      lpABC)
{
	if(FWide())
		return GetCharABCWidthsFloatW(hdc, uFirstChar, uLastChar, lpABC);

	return GetCharABCWidthsFloatA(hdc, uFirstChar, uLastChar, lpABC);
}

BOOL
APIENTRY
OGetCharABCWidthsW(
	HDC hdc,
	UINT uFirstChar,
	UINT uLastChar,
	LPABC lpABC)
{
	if(FWide())
		return GetCharABCWidthsW(hdc, uFirstChar, uLastChar, lpABC);

	return GetCharABCWidthsA(hdc, uFirstChar, uLastChar, lpABC);
}

BOOL
APIENTRY
OGetCharWidthFloatW(
	HDC     hdc,
	UINT    iFirstChar,
	UINT    iLastChar,
	PFLOAT  pBuffer)
{
	if(FWide())
		return GetCharWidthFloatW(hdc, iFirstChar, iLastChar, pBuffer);

	return GetCharWidthFloatA(hdc, iFirstChar, iLastChar, pBuffer);
}


BOOL
WINAPI
OGetCharWidthW(
	HDC hdc,
	UINT iFirstChar,
	UINT iLastChar,
	LPINT lpBuffer)
{
	if(FWide())
		return GetCharWidth32W(hdc, iFirstChar, iLastChar, lpBuffer);

	return GetCharWidth32A(hdc, iFirstChar, iLastChar, lpBuffer);
}

// Static buffers for GetClassInfo[Ex] to return the classname
// and menuname in Unicode, when running on an Ansi system.
// The contract of GetClassInfo is that it returns const ptrs
// back to the class name and menu name.  Unfortuntely, this
// prevents us from translating these back from Ansi to Unicode,
// without having some static buffers to use.  Since we strongly
// believe that the only people calling this are doing it just to
// see if it succeeds or not, so they know whether the class is
// already registered, we've willing to just have one set of
// static buffers to use.
// CAUTION: this will work as long as two threads don't call
// GetClassInfo[Ex] at the same time!
static WCHAR g_szClassName[256];
static WCHAR g_szMenuName[256];

#ifdef DEBUG
static DWORD g_dwCallingThread = 0;    // debug global for ensuring one thread.
#endif // DEBUG

BOOL
WINAPI
OGetClassInfoW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSW lpWndClass
)
{
	if (FWide())
		return GetClassInfoW(hInstance, lpClassName, lpWndClass);

	PreConvert();
	LPSTR szClassName = Convert(lpClassName);
	BOOL fRet = GetClassInfoA(hInstance, szClassName, (LPWNDCLASSA)lpWndClass);
	if (!fRet)
		{
		return false;
		}

	// if ClassName or MenuName aren't atom's, we need to
	// translate them back to Unicode.  We use our static
	// buffers above.  See note about why and the CAUTION!
#ifdef DEBUG
	if (!g_dwCallingThread)
		g_dwCallingThread = GetCurrentThreadId();
	Assert(GetCurrentThreadId() == g_dwCallingThread);
#endif // DEBUG

	if (!FATOM(lpWndClass->lpszMenuName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszMenuName) <
				(sizeof(g_szMenuName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szMenuName, (LPCSTR)lpWndClass->lpszMenuName,
				strlen((LPCSTR)lpWndClass->lpszMenuName)+1))
			{
			return false;
			}
		lpWndClass->lpszMenuName = g_szMenuName;
		}

	if (!FATOM(lpWndClass->lpszClassName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszClassName) <
				(sizeof(g_szClassName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szClassName, (LPCSTR)lpWndClass->lpszClassName,
				strlen((LPCSTR)lpWndClass->lpszClassName)+1))
			{
			return false;
			}
		lpWndClass->lpszClassName = g_szClassName;
		}

	return fRet;
}

BOOL
WINAPI
OGetClassInfoExW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSEXW lpWndClass
)
{
	if (FWide())
		return GetClassInfoExW(hInstance, lpClassName, lpWndClass);

	PreConvert();
	LPSTR szClassName = Convert(lpClassName);
	BOOL fRet = GetClassInfoExA(hInstance, szClassName, (LPWNDCLASSEXA)lpWndClass);
	if (!fRet)
		{
		return false;
		}

	// if ClassName or MenuName aren't atom's, we need to
	// translate them back to Unicode.  We use our static
	// buffers above.  See note about why and the CAUTION!
#ifdef DEBUG
	if (!g_dwCallingThread)
		g_dwCallingThread = GetCurrentThreadId();
	Assert(GetCurrentThreadId() == g_dwCallingThread);
#endif // DEBUG

	if (!FATOM(lpWndClass->lpszMenuName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszMenuName) <
				(sizeof(g_szMenuName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szMenuName, (LPCSTR)lpWndClass->lpszMenuName,
				strlen((LPCSTR)lpWndClass->lpszMenuName)+1))
			{
			return false;
			}
		lpWndClass->lpszMenuName = g_szMenuName;
		}

	if (!FATOM(lpWndClass->lpszClassName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszClassName) <
				(sizeof(g_szClassName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szClassName, (LPCSTR)lpWndClass->lpszClassName,
				strlen((LPCSTR)lpWndClass->lpszClassName)+1))
			{
			return false;
			}
		lpWndClass->lpszClassName = g_szClassName;
		}

	return fRet;
}

DWORD
WINAPI
OGetClassLongW(
	HWND hWnd,
	int nIndex)
{
	if(FWide())
		return GetClassLongW(hWnd, nIndex);
	return GetClassLongA(hWnd, nIndex);  //$UNDONE_POST_98 Watch out for GCL_MENUNAME, etc!
}

DWORD
WINAPI
OSetClassLongW(
	HWND hWnd,
	int nIndex,
	LONG dwNewLong)
{
	if (FWide())
		return SetClassLongW(hWnd, nIndex, dwNewLong);

	return SetClassLongA(hWnd, nIndex, dwNewLong);  //$UNDONE_POST_98 Watch out for GCL_MENUNAME, etc!

}

int
WINAPI
OGetClassNameW(
	HWND hWnd,
	LPWSTR lpClassName,
	int nMaxCount)
{
	if(FWide())
		return GetClassNameW(hWnd, lpClassName, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount + 2);
	int nRet = GetClassNameA(hWnd, sz, sizeof(WCHAR) * nMaxCount);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (nRet)
		{
		// force null-termination
		sz[sizeof(WCHAR) * nMaxCount] = '\0';
		sz[sizeof(WCHAR) * nMaxCount + 1] = '\0';

		// need a temporary wide string
		LPWSTR wsz = SzWAlloc(2 * nMaxCount + 1);

		nRet = min(AnsiToUnicode(wsz, sz, 2 * nMaxCount + 1), nMaxCount);

		// copy the requested number of characters
		if (lpClassName)
			{
			memcpy(lpClassName, wsz, nRet * sizeof(WCHAR));
			}

		return nRet;
		}

	else if (lpClassName && 0 < nMaxCount)
		{
		*lpClassName = L'\0';
		}

	return nRet;
}

DWORD
WINAPI
OGetCurrentDirectoryW(
	DWORD nBufferLength,
	LPWSTR lpBuffer)
{
	if (FWide())
		return GetCurrentDirectoryW(nBufferLength, lpBuffer);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nBufferLength);
	DWORD dwRet = GetCurrentDirectoryA(sizeof(WCHAR) * nBufferLength, sz);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (dwRet)
		{
		return AnsiToUnicode(lpBuffer, sz, nBufferLength);
		}
	else if (lpBuffer && 0 < nBufferLength)
		{
		*lpBuffer = L'\0';
		}

	return dwRet;
}

UINT
WINAPI
OGetDlgItemTextW(
	HWND hDlg,
	int nIDDlgItem,
	LPWSTR lpString,
	int nMaxCount)
{
	if(FWide())
		return GetDlgItemTextW(hDlg, nIDDlgItem, lpString, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount);
	UINT uRet = GetDlgItemTextA(hDlg, nIDDlgItem, sz, sizeof(WCHAR) * nMaxCount);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(uRet)
		{
		return AnsiToUnicode(lpString, sz, nMaxCount);
		}
	else if (lpString && 0 < nMaxCount)
		{
		*lpString = L'\0';
		}

	return uRet;
}

DWORD
WINAPI
OGetFileAttributesW(
	LPCWSTR lpFileName
	)
{
	if(FWide())
		return GetFileAttributesW(lpFileName);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	return GetFileAttributesA(sz);
}

DWORD
WINAPI
OGetFullPathNameW(
	LPCWSTR lpFileName,
	DWORD nBufferLength,
	LPWSTR lpBuffer,
	LPWSTR *lpFilePart
	)
{
	if(FWide())
		return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);

	PreConvert();
	LPSTR szFile = Convert(lpFileName);
	LPSTR szBuffer = SzAlloc(sizeof(WCHAR) * nBufferLength);
	LPSTR pszFile;

	DWORD dwRet = GetFullPathNameA(szFile ,sizeof(WCHAR) * nBufferLength, szBuffer , &pszFile);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(dwRet)
		{
		DWORD dwNoOfChar = AnsiToUnicode(lpBuffer, szBuffer , nBufferLength);
		*pszFile = '\0';
		*lpFilePart = lpBuffer + AnsiToUnicode(NULL, szBuffer, 0);
		return dwNoOfChar;
		}

	return dwRet;
}

DWORD
WINAPI
OGetGlyphOutlineW(
	HDC     hdc,
	UINT    uChar,
	UINT    uFormat,
	LPGLYPHMETRICS      lpgm,
	DWORD       cbBuffer,
	LPVOID      lpvBuffer,
	CONST MAT2 *    lpmat2)
{
	if (FWide())
		return GetGlyphOutlineW(hdc, uChar, uFormat, lpgm, cbBuffer, lpvBuffer, lpmat2);

	return GetGlyphOutlineA(hdc, uChar, uFormat, lpgm, cbBuffer, lpvBuffer, lpmat2);
}

DWORD
WINAPI
OGetKerningPairsW(
	HDC         hdc,
	DWORD       nNumPairs,
	LPKERNINGPAIR       lpkrnpair)
{
	if(FWide())
		return GetKerningPairsW(hdc, nNumPairs, lpkrnpair);

	return GetKerningPairsA(hdc, nNumPairs, lpkrnpair);
}

BOOL
WINAPI
OGetMessageW(
	LPMSG lpMsg,
	HWND hWnd ,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax)
{
	if(FWide())
		return GetMessageW(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax);

	return GetMessageA(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax);
}

DWORD
WINAPI
OGetModuleFileNameW(
	HINSTANCE hModule,
	LPWSTR pwszFilename,
	DWORD nSize
	)
{
	if(FWide())
		return GetModuleFileNameW(
			hModule,
			pwszFilename,
			nSize
			);

	LPSTR sz    = SzAlloc(sizeof(WCHAR) * nSize);
	DWORD dwRet = GetModuleFileNameA(hModule, sz, sizeof(WCHAR) * nSize);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (dwRet)
		{
		return AnsiToUnicode(pwszFilename, sz, nSize, dwRet + 1);
		}
	else if (pwszFilename && 0 < nSize)
		{
		*pwszFilename = L'\0';
		}

	return dwRet;
}

HMODULE
WINAPI
OGetModuleHandleW(
	LPCWSTR lpModuleName
	)
{
	if(FWide())
		return GetModuleHandleW(lpModuleName);

	PreConvert();
	LPSTR sz = Convert(lpModuleName);

	return GetModuleHandleA(sz);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith: Re-wrote fixing handling of non-trivial parameters on 6/25
// Smoke tested by Mark Ashton on 6/25

APIENTRY
OGetOpenFileNameW
(
LPOPENFILENAMEW lpofn
)
{
	if (FWide())
		return GetOpenFileNameW(lpofn);

	Assert(!(lpofn->Flags & OFN_ENABLEHOOK));

	PreConvert();
	OPENFILENAMEA ofn;
	ofn.lStructSize       = sizeof(OPENFILENAMEA);
	ofn.hwndOwner         = lpofn->hwndOwner;
	ofn.hInstance         = lpofn->hInstance;
	ofn.lpstrFilter       = ConvertWithLen(lpofn->lpstrFilter, cUnicodeMultiSzLen(lpofn->lpstrFilter), &_lJunk);
	ofn.lpstrCustomFilter = ConvertWithLen(lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter, (LONG *)&ofn.nMaxCustFilter);
	ofn.nFilterIndex      = lpofn->nFilterIndex;
	ofn.lpstrFile         = ConvertWithLen(lpofn->lpstrFile, lpofn->nMaxFile, (LONG *)&ofn.nMaxFile);
	ofn.lpstrFileTitle    = ConvertWithLen(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle, (LONG *)&ofn.nMaxFileTitle);
	ofn.lpstrInitialDir   = Convert(lpofn->lpstrInitialDir);
	ofn.lpstrTitle        = Convert(lpofn->lpstrTitle);
	ofn.Flags             = lpofn->Flags;
	ofn.nFileOffset       = lpofn->nFileOffset;
	ofn.nFileExtension    = lpofn->nFileExtension;
	ofn.lpstrDefExt       = Convert(lpofn->lpstrDefExt);
	ofn.lCustData         = lpofn->lCustData;
	ofn.lpfnHook          = NULL;
	ofn.lpTemplateName    = ((lpofn->Flags & OFN_ENABLETEMPLATE) &&
							 !FATOM(lpofn->lpTemplateName) ) ?
							Convert(lpofn->lpTemplateName) :
							(LPSTR)lpofn->lpTemplateName;
	BOOL fFlag = GetOpenFileNameA(&ofn);
	if (fFlag)
		{
		Assert(lpofn->hwndOwner == ofn.hwndOwner);
		Assert(lpofn->hInstance == ofn.hInstance);
		if (ofn.lpstrCustomFilter)
			{
			lpofn->nMaxCustFilter = AnsiToUnicode(lpofn->lpstrCustomFilter, ofn.lpstrCustomFilter, lpofn->nMaxCustFilter, strlen(ofn.lpstrCustomFilter) + 1);
			}
		lpofn->nFilterIndex   = ofn.nFilterIndex;
		Assert(lpofn->nMaxFile == ofn.nMaxFile);
		Verify(0 <= AnsiToUnicode(lpofn->lpstrFile, ofn.lpstrFile, lpofn->nMaxFile, strlen(ofn.lpstrFile) + 1));
		if (ofn.lpstrFileTitle)
			{
			lpofn->nMaxFileTitle = AnsiToUnicode(lpofn->lpstrFileTitle, ofn.lpstrFileTitle, strlen(ofn.lpstrFileTitle) + 1);
			}
		lpofn->Flags          = ofn.Flags;
		lpofn->nFileOffset    = ofn.nFileOffset;
		lpofn->nFileExtension = ofn.nFileExtension;
		Assert(lpofn->lCustData == ofn.lCustData);
		Assert(lpofn->lpfnHook == ofn.lpfnHook);
		}
	else if (lpofn->lpstrFile)
		{   // if buffer too small first 2 bytes are the required size
		memcpy(lpofn->lpstrFile, ofn.lpstrFile, sizeof(short));
		}
	return fFlag;
}

UINT
APIENTRY
OGetOutlineTextMetricsW(
	HDC hdc,
	UINT cbData,
	LPOUTLINETEXTMETRICW lpOTM)
{
	// *** TextMetrics defines BYTE elements in the structure for the
	// value of first first/last character defined in the font.
	// Problem for DBCS.

	if(FWide())
		return GetOutlineTextMetricsW(hdc, cbData, lpOTM);

	return GetOutlineTextMetricsA(hdc, cbData, (LPOUTLINETEXTMETRICA)lpOTM); //$ UNDONE_POST_98 - This doesn't convert the embedded Names...
}

UINT
WINAPI
OGetPrivateProfileIntW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	INT nDefault,
	LPCWSTR lpFileName)
{
	if(FWide())
		return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szFileName = Convert(lpFileName);

	return GetPrivateProfileIntA(szAppName, szKeyName, nDefault, szFileName);
}

DWORD
WINAPI
OGetPrivateProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpDefault,
	LPWSTR lpReturnedString,
	DWORD nSize,
	LPCWSTR lpFileName)
{
	if(FWide())
		return GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString,
		  nSize, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szDefault  = Convert(lpDefault);
	LPSTR szFileName = Convert(lpFileName);

	LPSTR szReturnedString = SzAlloc(sizeof(WCHAR) * nSize);

	DWORD dwRet = GetPrivateProfileStringA(szAppName, szKeyName, szDefault, szReturnedString,
	  sizeof(WCHAR) * nSize, szFileName);

	// I hope this doesn't fail because there's no clear failure value in the docs

	DWORD dwNoOfChar = AnsiToUnicode(lpReturnedString, szReturnedString, nSize);

	if (dwNoOfChar)
		return dwRet;
	else
		{
		LPWSTR lpTempString = SzWAlloc(sizeof(WCHAR) * nSize);
		if (AnsiToUnicode(lpTempString, szReturnedString, sizeof(WCHAR) * nSize))
			{
			if (lpAppName && lpKeyName)
				{
				lpTempString[nSize - 1] = L'\0';
				wcsncpy(lpReturnedString, lpTempString, nSize);
				return nSize - 1;
				}
			else
				{
				lpTempString[nSize - 1] = L'\0';
				lpTempString[nSize - 2] = L'\0';
				wcsncpy(lpReturnedString, lpTempString, nSize);
				return nSize - 2;
				}
			}
		}

	return dwRet;
}


int
WINAPI
OGetObjectW(
	HGDIOBJ hgdiobj,
	int cbBuffer,
	LPVOID lpvObject)
{
	if(FWide())
		return GetObjectW(hgdiobj, cbBuffer, lpvObject);

	DWORD dwObj = GetObjectType(hgdiobj);
	if (OBJ_FONT == dwObj)
		{
		//$CONSIDER: This effects all getobject call, performance?
		Assert(cbBuffer == sizeof(LOGFONTW));
		LOGFONTA  lfa;
		LOGFONTW *plfw = (LOGFONTW *)lpvObject;

		int nRet = GetObjectA(hgdiobj, sizeof(lfa), &lfa);

		if(nRet)
			{
			memcpy(plfw, &lfa, sizeof(LOGFONTA));
			Verify(0 <= AnsiToUnicode(plfw->lfFaceName, lfa.lfFaceName, LF_FACESIZE));
			}

		return nRet;
		}
	else
		{
		return GetObjectA(hgdiobj, cbBuffer, lpvObject);
		}
}

UINT
WINAPI
OGetProfileIntW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	INT nDefault
	)
{
	if(FWide())
		return GetProfileIntW(lpAppName, lpKeyName, nDefault);

	PreConvert();
	LPSTR szApp = Convert(lpAppName);
	LPSTR szKey = Convert(lpKeyName);

	return GetProfileIntA(szApp, szKey, nDefault);
}

HANDLE
WINAPI
OGetPropW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return GetPropW(hWnd, lpString);

	if(FATOM(lpString))
		return GetPropA(hWnd, (LPSTR)lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return GetPropA(hWnd, sz);
}

// From: Mark Ashton on 5/29/97
//       Ted Smith: Re-wrote fixing handling of non-trivial parameters on 6/25
// Smoke tested by Mark Ashton on 6/25

APIENTRY
OGetSaveFileNameW(LPOPENFILENAMEW lpofn)
{
	if (FWide())
		return GetSaveFileNameW(lpofn);

	PreConvert();
	Assert(!(lpofn->Flags & OFN_ENABLEHOOK));

	OPENFILENAMEA ofn;
	ofn.lStructSize       = sizeof(OPENFILENAMEA);
	ofn.hwndOwner         = lpofn->hwndOwner;
	ofn.hInstance         = lpofn->hInstance;
	ofn.lpstrFilter       = ConvertWithLen(lpofn->lpstrFilter, cUnicodeMultiSzLen(lpofn->lpstrFilter), &_lJunk);
	ofn.lpstrCustomFilter = ConvertWithLen(lpofn->lpstrCustomFilter, lpofn->nMaxCustFilter, (LONG *)&ofn.nMaxCustFilter);
	ofn.nFilterIndex      = lpofn->nFilterIndex;
	ofn.lpstrFile         = ConvertWithLen(lpofn->lpstrFile, lpofn->nMaxFile, (LONG *)&ofn.nMaxFile);
	ofn.lpstrFileTitle    = ConvertWithLen(lpofn->lpstrFileTitle, lpofn->nMaxFileTitle, (LONG *)&ofn.nMaxFileTitle);
	ofn.lpstrInitialDir   = Convert(lpofn->lpstrInitialDir);
	ofn.lpstrTitle        = Convert(lpofn->lpstrTitle);
	ofn.Flags             = lpofn->Flags;
	ofn.nFileOffset       = lpofn->nFileOffset;
	ofn.nFileExtension    = lpofn->nFileExtension;
	ofn.lpstrDefExt       = Convert(lpofn->lpstrDefExt);
	ofn.lCustData         = lpofn->lCustData;
	ofn.lpfnHook          = NULL;
	ofn.lpTemplateName    = ((lpofn->Flags & OFN_ENABLETEMPLATE) &&
							 !FATOM(lpofn->lpTemplateName) ) ?
							Convert(lpofn->lpTemplateName) :
							(LPSTR)lpofn->lpTemplateName;
	BOOL fFlag = GetSaveFileNameA(&ofn);
	if (fFlag)
		{
		Assert(lpofn->hwndOwner == ofn.hwndOwner);
		Assert(lpofn->hInstance == ofn.hInstance);
		if (ofn.lpstrCustomFilter)
			{
			lpofn->nMaxCustFilter = AnsiToUnicode(lpofn->lpstrCustomFilter, ofn.lpstrCustomFilter, lpofn->nMaxCustFilter, ofn.nMaxCustFilter);
			}
		lpofn->nFilterIndex   = ofn.nFilterIndex;
		Assert(lpofn->nMaxFile == ofn.nMaxFile);
		Verify(0 <= AnsiToUnicode(lpofn->lpstrFile, ofn.lpstrFile, lpofn->nMaxFile, ofn.nMaxFile));
		if (ofn.lpstrFileTitle)
			{
			lpofn->nMaxFileTitle = AnsiToUnicode(lpofn->lpstrFileTitle, ofn.lpstrFileTitle, lpofn->nMaxFileTitle);
			}
		lpofn->Flags          = ofn.Flags;
		lpofn->nFileOffset    = ofn.nFileOffset;
		lpofn->nFileExtension = ofn.nFileExtension;
		Assert(lpofn->lCustData == ofn.lCustData);
		Assert(lpofn->lpfnHook == ofn.lpfnHook);
		}
	else if (lpofn->lpstrFile)
		{   // if buffer too small first 2 bytes are the required size
		memcpy(lpofn->lpstrFile, ofn.lpstrFile, sizeof(short));
		}
	return fFlag;
}

DWORD
WINAPI
OGetTabbedTextExtentW(
	HDC hDC,
	LPCWSTR lpString,
	int nCount,
	int nTabPositions,
	LPINT lpnTabStopPositions)
{
	Assert(-1 != nCount);

	if(FWide())
		return GetTabbedTextExtentW(hDC, lpString, nCount, nTabPositions, lpnTabStopPositions);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpString, nCount, &n);

	return GetTabbedTextExtentA(hDC, sz, n, nTabPositions, lpnTabStopPositions);
}

// From: Mark Ashton on 5/8/97
UINT
WINAPI
OGetTempFileNameW(
	LPCWSTR lpPathName,
	LPCWSTR lpPrefixString,
	UINT uUnique,
	LPWSTR lpTempFileName
	)
{
	if (FWide())
		return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

	char szPathName[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szPathName, lpPathName, _MAX_PATH));

	char szPrefixString[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szPrefixString, lpPrefixString, _MAX_PATH));

	char szTempFilename[_MAX_PATH];
	UINT dwRet = GetTempFileNameA(szPathName, szPrefixString, uUnique, szTempFilename);
	if (dwRet)
		{
		Verify(0 <= AnsiToUnicode(lpTempFileName, szTempFilename, _MAX_PATH));
		}
	return dwRet;
}

// From: Mark Ashton on 5/8/97
DWORD
WINAPI
OGetTempPathW(
	DWORD nBufferLength,
	LPWSTR lpBuffer
	)
{
	if (FWide())
		return GetTempPathW(nBufferLength, lpBuffer);

	char szPath[_MAX_PATH];
	DWORD dwRet = GetTempPathA(_MAX_PATH, szPath);
	if (dwRet)
		{
		Verify(0 <= AnsiToUnicode(lpBuffer, szPath, nBufferLength));
		}
	return dwRet;
}

BOOL
APIENTRY
OGetTextExtentPoint32W(
					HDC hdc,
					LPCWSTR pwsz,
					int cb,
					LPSIZE pSize
					)
{
	Assert(-1 != cb);

	if(FWide())
		return GetTextExtentPoint32W(hdc, pwsz, cb, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);

	return GetTextExtentPoint32A(hdc, sz, n, pSize);
}

BOOL
APIENTRY
OGetTextExtentPointW(
					HDC hdc,
					LPCWSTR pwsz,
					int cb,
					LPSIZE pSize
					)
{
	Assert(-1 != cb);

	if(FWide())
		return GetTextExtentPointW(hdc, pwsz, cb, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);
	return GetTextExtentPointA(hdc, sz, n, pSize);
}

BOOL
APIENTRY OGetTextExtentExPointW(
					HDC hdc,
					LPCWSTR lpszStr,
					int cchString,
					int nMaxExtent,
					LPINT lpnFit,
					LPINT alpDx,
					LPSIZE pSize
					)
{
	Assert(-1 != cchString);

	if(FWide())
		return GetTextExtentExPointW(hdc, lpszStr, cchString,
									 nMaxExtent, lpnFit, alpDx, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpszStr, cchString, &n);
	return GetTextExtentExPointA(hdc, sz, n, nMaxExtent, lpnFit, alpDx, pSize);

}

LONG
WINAPI
OGetWindowLongW(
	HWND hWnd,
	int nIndex)
{
	if(FWide())
		return GetWindowLongW(hWnd, nIndex);

	return GetWindowLongA(hWnd, nIndex);
}

BOOL
WINAPI
OGetTextMetricsW(
	HDC hdc,
	LPTEXTMETRICW lptm)
{
	if(FWide())
		return GetTextMetricsW(hdc, lptm);

	TEXTMETRICA tma;

	memcpy(&tma, lptm, OffsetOf(TEXTMETRIC, tmFirstChar));

	// tmFirstChar is defined as BYTE.
	// $CONSIDER : will fail for DBCS !!

	wctomb((LPSTR)&tma.tmFirstChar, lptm->tmFirstChar);
	wctomb((LPSTR)&tma.tmLastChar, lptm->tmLastChar);
	wctomb((LPSTR)&tma.tmDefaultChar, lptm->tmDefaultChar);
	wctomb((LPSTR)&tma.tmBreakChar, lptm->tmBreakChar);

	memcpy(&tma.tmItalic, &lptm->tmItalic, sizeof(TEXTMETRIC) - OffsetOf(TEXTMETRIC, tmItalic));

	BOOL fRet = GetTextMetricsA(hdc, &tma);

	if(fRet)
		{
		memcpy(&lptm->tmItalic, &tma.tmItalic, sizeof(TEXTMETRIC) - OffsetOf(TEXTMETRIC, tmItalic));

		// Convert tma.tmFirstChar (1 byte char) to lptm->tmFirstChar
		mbtowc(&lptm->tmFirstChar, (LPSTR)&tma.tmFirstChar, 1);
		mbtowc(&lptm->tmLastChar, (LPSTR)&tma.tmLastChar, 1);
		mbtowc(&lptm->tmDefaultChar, (LPSTR)&tma.tmDefaultChar, 1);
		mbtowc(&lptm->tmBreakChar, (LPSTR)&tma.tmBreakChar, 1);

		memcpy(lptm, &tma, OffsetOf(TEXTMETRIC, tmFirstChar));
		}

	return fRet;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OGetUserNameW (
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	if (FWide())
		return GetUserNameW(lpBuffer, nSize);

	DWORD dwLen = *nSize;
	LPSTR sz = SzAlloc(dwLen);

	BOOL fFlag = GetUserNameA(sz, nSize);
	if (fFlag)
		{
		*nSize = AnsiToUnicode(lpBuffer, sz, dwLen);
		}
	return fFlag;
}

BOOL
WINAPI
OGetVolumeInformationW(
	LPCWSTR lpRootPathName,
	LPWSTR lpVolumeNameBuffer,
	DWORD nVolumeNameSize,
	LPDWORD lpVolumeSerialNumber,
	LPDWORD lpMaximumComponentLength,
	LPDWORD lpFileSystemFlags,
	LPWSTR lpFileSystemNameBuffer,
	DWORD nFileSystemNameSize
	)
{
	if(FWide())
		return GetVolumeInformationW(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber,
			lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);

	PreConvert();
	LPSTR szRoot = Convert(lpRootPathName);
	LPSTR szName = SzAlloc(sizeof(WCHAR) * nVolumeNameSize);
	LPSTR szSysName = SzAlloc(sizeof(WCHAR) * nFileSystemNameSize);

	BOOL fRet = GetVolumeInformationA(szRoot, szName, sizeof(WCHAR) * nVolumeNameSize, lpVolumeSerialNumber,
			lpMaximumComponentLength, lpFileSystemFlags, szSysName, sizeof(WCHAR) * nFileSystemNameSize);

	if(fRet)
		{
		if (!AnsiToUnicode(lpVolumeNameBuffer, szName, nVolumeNameSize) ||
			!AnsiToUnicode(lpFileSystemNameBuffer, szSysName, nFileSystemNameSize))
			{
			fRet = false;
			}
		}
	if (!fRet)
		{
		if (lpVolumeNameBuffer && 0 < nVolumeNameSize)
			{
			*lpVolumeNameBuffer = L'\0';
			}

		if (lpFileSystemNameBuffer && 0 < nFileSystemNameSize)
			{
			*lpFileSystemNameBuffer = L'\0';
			}
		}

	return fRet;
}

int
WINAPI
OGetWindowTextLengthW(
	HWND hWnd)
{
	if(FWide())
		return GetWindowTextLengthW(hWnd);

	return GetWindowTextLengthA(hWnd);
}

int
WINAPI
OGetWindowTextW(
	HWND hWnd,
	LPWSTR lpString,
	int nMaxCount)
{

	/*******  Blackbox Testing results for GetWindowText Win32 API ******

	TestCase    lpString    nMaxCount   Return Value    *lpString modified
	======================================================================
	Testing GetWindowTextW on WinNT :-
		A       not NULL        0           0               No
		B           NULL        0           0               No
		C           NULL    not 0           0               No
		D       not NULL    not 0       # of chars w/o      Yes
										\0 terminator

	Testing GetWindowTextA on Win95 :-
		A       not NULL        0           0               Yes
		B           NULL        0               GPF!!
		C           NULL    not 0               GPF!!
		D       not NULL    not 0       # of chars w/o      Yes
										\0 terminator
	*********************************************************************/

	if(FWide())
		return GetWindowTextW(hWnd, lpString, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount);
	int nRet = GetWindowTextA(hWnd, sz, sizeof(WCHAR) * nMaxCount);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(nRet)
		{
		return AnsiToUnicode(lpString, sz, nMaxCount);
		}
	else
		{
		// GetWindowText() returns 0 when you call it on a window which
		// has no text (e.g. edit control without any text). It also initializes
		// the buffer passed in to receive the text to "\0". So we should initialize
		// the buffer passed in before returning.
		if (lpString && 0 < nMaxCount)
			{
			*lpString = L'\0';
			}
		}

	return nRet;
}

ATOM
WINAPI
OGlobalAddAtomW(
	LPCWSTR lpString
	)
{
	if(FWide())
		return GlobalAddAtomW(lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return GlobalAddAtomA(sz);
}

// From: Josh Kaplan on 8/12/97
UINT
WINAPI
OGlobalGetAtomNameW(
	ATOM nAtom,
	LPWSTR lpBuffer,
	int nSize
	)
{
	if(FWide())
		return GlobalGetAtomNameW(nAtom, lpBuffer, nSize);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nSize);
	if (GlobalGetAtomNameA(nAtom, sz, sizeof(WCHAR) * nSize))
		{
		// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
		return AnsiToUnicode(lpBuffer, sz, nSize) - 1;
		}

	if (lpBuffer && 0 < nSize)
		{
		*lpBuffer = L'\0';
		}
	return 0;
}

BOOL
WINAPI
OGrayStringW(
	HDC hDC,
	HBRUSH hBrush,
	GRAYSTRINGPROC lpOutputFunc,
	LPARAM lpData,
	int nCount,
	int X,
	int Y,
	int nWidth,
	int nHeight)
{
	if(FWide())
		return GrayStringW(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);

	if (!lpOutputFunc)
		{
		PreConvert();
		LPSTR szData = Convert((LPCWSTR) lpData);
		return GrayStringA(hDC, hBrush, lpOutputFunc, (LPARAM) szData, nCount, X, Y, nWidth, nHeight);
		}

	return GrayStringA(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
}

BOOL
WINAPI
OInsertMenuW(
	HMENU hMenu,
	UINT uPosition,
	UINT uFlags,
	UINT uIDNewItem,
	LPCWSTR lpNewItem
	)
{
	if(FWide())
		return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);

	if(uFlags & (MF_BITMAP | MF_OWNERDRAW))
		return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPSTR)lpNewItem);

	PreConvert();
	LPSTR sz = Convert(lpNewItem);
	return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, sz);
}

BOOL
WINAPI
OIsBadStringPtrW(
	LPCWSTR lpsz,
	UINT ucchMax
	)
{
	if(FWide())
		return IsBadStringPtrW(lpsz, ucchMax);

	return IsBadStringPtrA((LPSTR) lpsz, ucchMax * sizeof(WCHAR));  //$UNDONE_POST_98 - We should use IsBadReadPtr(strlen)!
}


BOOL
WINAPI
OIsCharAlphaNumericW(
	WCHAR wch)
{
	if(FWide())
		return IsCharAlphaNumericW(wch);

	//$CONSIDER: we really want to use MB_CUR_MAX, but that is
	// not a defined constant
	CHAR psz[4];

	int cch = WideCharToMultiByte(CP_ACP, 0, &wch, 1, (CHAR *) psz, 4, NULL, NULL);
	if (1 == cch)
		{
		return IsCharAlphaNumericA(*psz);
		}
	else if (1 < cch)
		{
		// It's a multi-byte character, so treat it as alpha
		// Note: we are not sure that this is entirely correct
		return true;
		}
	else
		{
		return false;
		}
}

BOOL
WINAPI
OIsCharAlphaW(
	WCHAR wch)
{
	if(FWide())
		return IsCharAlphaW(wch);

	//$CONSIDER: we really want to use MB_CUR_MAX, but that is
	// not a defined constant
	CHAR psz[4];

	int cch = WideCharToMultiByte(CP_ACP, 0, &wch, 1, (CHAR *) psz, 4, NULL, NULL);
	if(1 == cch)
		{
		return IsCharAlphaA(*psz);
		}
	else if (1 < cch)
		{
		// It's a multi-byte character, so treat it as alpha
		// Note: we are not sure that this is entirely correct
		return true;
		}
	else
		{
		return false;
		}
}

BOOL
WINAPI
OIsDialogMessageW(
	HWND hDlg,
	LPMSG lpMsg)
{
	// WARNING!!!
	// Bug #6488. We have run into problems due to using IsDialogMessageW on
	// WinNT Japanese. The fix for the bug was calling ANSI version of
	// IsDialogMessage irrespective of whether we are running on NT or Win95.
	// The shell is compiled MBCS (not UNICODE) and they are always using the
	// ANSI versions of the routines. lpMsg passed by shell contains MBCS
	// characters & not UNICODE. So in cases where you get the message
	// structure from the Shell, you will have to call the IsDialogMessageA
	// directly and not use this wrapper.

	if(FWide())
		return IsDialogMessageW(hDlg, lpMsg);

	return IsDialogMessageA(hDlg, lpMsg);
}

// From: Mark Ashton on 5/8/97
//		 Bill Hieber - 2/5/98 fixed buffer size problem.
int
WINAPI
OLCMapStringW(
	LCID     Locale,
	DWORD    dwMapFlags,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWSTR  lpDestStr,
	int      cchDest)
{
	if (FWide())
		return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);

	// lpSrcStr is not required to be '\0' terminated. Note that we don't support -1!
	Assert(cchSrc != -1);
	LPSTR sz = SzAlloc(cchSrc * 2);
	int dw = WideCharToMultiByte(CP_ACP, 0, lpSrcStr, cchSrc, sz, cchSrc * 2, NULL, NULL);

	LPSTR dst = cchDest ? SzAlloc(cchDest*2) : NULL;
	int dwRet = LCMapStringA(Locale, dwMapFlags, sz, dw, dst, cchDest*2);
	if (dwRet && cchDest)
		{
		dwRet = MultiByteToWideChar(CP_ACP, 0, dst, dwRet, lpDestStr, cchDest);
		}
	return dwRet;
}

HACCEL
WINAPI
OLoadAcceleratorsW(
	HINSTANCE hInst,
	LPCWSTR   lpTableName)
{
	if(FWide())
		return LoadAcceleratorsW(hInst, lpTableName);

	if(FATOM(lpTableName))
		return LoadAcceleratorsA(hInst, (LPSTR)lpTableName);

	PreConvert();
	LPSTR sz = Convert(lpTableName);
	return LoadAcceleratorsA(hInst, sz);
}

HBITMAP
WINAPI
OLoadBitmapW(
	HINSTANCE hInstance,
	LPCWSTR lpBitmapName)
{
	if(FWide())
		return LoadBitmapW(hInstance, lpBitmapName);

	if(FATOM(lpBitmapName))
		return LoadBitmapA(hInstance, (LPSTR)lpBitmapName);

	PreConvert();
	LPSTR sz = Convert(lpBitmapName);
	return LoadBitmapA(hInstance, sz);
}

HCURSOR
WINAPI
OLoadCursorW(
	HINSTANCE hInstance,
	LPCWSTR lpCursorName)
{
	if(FWide())
		return LoadCursorW(
			hInstance,
			lpCursorName);

	if (FATOM(lpCursorName))
		return LoadCursorA(hInstance, (LPSTR) lpCursorName);

	PreConvert();
	LPSTR sz = Convert(lpCursorName);
	return LoadCursorA(hInstance, sz);
}

HICON
WINAPI
OLoadIconW(
	HINSTANCE hInstance,
	LPCWSTR lpIconName)
{
	if(FWide())
		return LoadIconW(hInstance, lpIconName);

	if(FATOM(lpIconName))
		return LoadIconA(hInstance, (LPSTR)lpIconName);

	PreConvert();
	LPSTR sz = Convert(lpIconName);
	return LoadIconA(hInstance, sz);
}

HINSTANCE
WINAPI
OLoadLibraryW(
	LPCWSTR pwszFileName
	)
{
	if(FWide())
		return LoadLibraryW(pwszFileName);

	PreConvert();
	LPSTR sz = Convert(pwszFileName);
	return LoadLibraryA(sz);
}

HMODULE
WINAPI
OLoadLibraryExW(
	LPCWSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags
	)
{
	if(FWide())
		return LoadLibraryExW(lpLibFileName, hFile, dwFlags);

	PreConvert();
	LPSTR sz = Convert(lpLibFileName);
	return LoadLibraryExA(sz, hFile, dwFlags);
}

HMENU
WINAPI
OLoadMenuIndirectW(
	CONST MENUTEMPLATEW *lpMenuTemplate)
{
	if(FWide())
		return LoadMenuIndirectW(lpMenuTemplate);

	//$NOTE: For both the ANSI and the Unicode version of this function,
	//the strings in the MENUITEMTEMPLATE structure must be Unicode strings

	return LoadMenuIndirectA(lpMenuTemplate);
}

HMENU
WINAPI
OLoadMenuW(
	HINSTANCE hInstance,
	LPCWSTR lpMenuName)
{
	if(FWide())
		return LoadMenuW(hInstance, lpMenuName);

	if(FATOM(lpMenuName))
		return LoadMenuA(hInstance, (LPCSTR)lpMenuName);

	PreConvert();
	LPSTR sz = Convert(lpMenuName);
	return LoadMenuA(hInstance, sz);
}

int
WINAPI
OLoadStringW(
	HINSTANCE hInstance,
	UINT uID,
	LPWSTR lpBuffer,
	int nBufferMax)
{
	if(FWide())
		return LoadStringW(hInstance, uID,  lpBuffer, nBufferMax);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nBufferMax);
	int nRet = LoadStringA(hInstance, uID, sz, sizeof(WCHAR) * nBufferMax);

	if (!nRet)
		{
		if (lpBuffer && 0 < nBufferMax)
			{
			*lpBuffer = L'\0';
			}
		return 0;
		}

	LONG lRet = AnsiToUnicode(lpBuffer, sz, nBufferMax, nRet + 1); // '\0'
	if (lRet)
		{
		return lRet - 1;
		}

	LPWSTR szBuff = SzWAlloc(nRet + 1);
	lRet = AnsiToUnicode(szBuff, sz, nRet + 1, nRet + 1);
	Assert(lRet);
	memcpy(lpBuffer, szBuff, sizeof(WCHAR) * nBufferMax);
	lpBuffer[nBufferMax - 1] = L'\0';
	return nBufferMax - 1;
}

LPWSTR
WINAPI
OlstrcatW(
	LPWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if (!lpString1 || !lpString2)
		return lpString1;

	return wcscat(lpString1, lpString2);
}

int
WINAPI
OlstrcmpiW(
	LPCWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if(FWide())
		return lstrcmpiW(lpString1, lpString2);

	PreConvert();
	LPSTR psz1 = lpString1 ? Convert(lpString1) : NULL;
	LPSTR psz2 = lpString2 ? Convert(lpString2) : NULL;

	return lstrcmpiA(psz1, psz2);
}

int
WINAPI
OlstrcmpW(
	LPCWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if(FWide())
		return lstrcmpW(lpString1, lpString2);

	PreConvert();
	LPSTR psz1 = lpString1 ? Convert(lpString1) : NULL;
	LPSTR psz2 = lpString2 ? Convert(lpString2) : NULL;

	return lstrcmpA(psz1, psz2);
}

LPWSTR
WINAPI
OlstrcpyW(
	LPWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if (!lpString1)
		return lpString1;

	if (!lpString2)
		lpString2 = L"";

	return wcscpy(lpString1, lpString2);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith added null string pointer handling
LPWSTR
WINAPI
OlstrcpynW(
	LPWSTR lpString1,
	LPCWSTR lpString2,
	int iMaxLength
	)
{
	if (!lpString1)
		{
		return lpString1;
		}

	if (!lpString2)
		{
		lpString2 = L"";
		}

	if(FWide())
		return lstrcpynW(lpString1, lpString2, iMaxLength);

	lpString1[--iMaxLength] = L'\0';
	return wcsncpy(lpString1, lpString2, iMaxLength);
}

int
WINAPI
OlstrlenW(
	LPCWSTR lpString
	)
{
	return lpString ? wcslen(lpString) : 0;
}

UINT
WINAPI
OMapVirtualKeyW(
	UINT uCode,
	UINT uMapType)
{
	// The only person using this so far is using uMapType == 0
	Assert(2 != uMapType);
	if (FWide())
		return MapVirtualKeyW(uCode, uMapType);
	return MapVirtualKeyA(uCode, uMapType);
}

int
WINAPI
OMessageBoxW(
	HWND hWnd ,
	LPCWSTR lpText,
	LPCWSTR lpCaption,
	UINT uType)
{
	if(FWide())
		return MessageBoxW(hWnd, lpText, lpCaption, uType);

	PreConvert();
	LPSTR szText = Convert(lpText);
	LPSTR szCap  = Convert(lpCaption);

	return MessageBoxA(hWnd, szText, szCap, uType);
}

int
WINAPI
OMessageBoxIndirectW(
	LPMSGBOXPARAMSW lpmbp)
{
	Assert(!IsBadWritePtr((void*)lpmbp, sizeof MSGBOXPARAMSW));
	Assert(sizeof MSGBOXPARAMSW == lpmbp->cbSize);
	Assert(sizeof MSGBOXPARAMSW == sizeof MSGBOXPARAMSA);

	if(FWide())
		return MessageBoxIndirectW(lpmbp);

	PreConvert();

	MSGBOXPARAMSA mbpa;
	memcpy(&mbpa, lpmbp, sizeof MSGBOXPARAMSA);

	if (!FATOM(lpmbp->lpszText))
		{
		mbpa.lpszText = Convert(lpmbp->lpszText);
		}
	if (!FATOM(lpmbp->lpszCaption))
		{
		mbpa.lpszCaption = Convert(lpmbp->lpszCaption);
		}
	if ((lpmbp->dwStyle & MB_USERICON) && !FATOM(lpmbp->lpszIcon))
		{
		mbpa.lpszIcon = Convert(lpmbp->lpszIcon);
		}

	return MessageBoxIndirectA(&mbpa);
}

BOOL
WINAPI
OModifyMenuW(
	HMENU hMnu,
	UINT uPosition,
	UINT uFlags,
	UINT uIDNewItem,
	LPCWSTR lpNewItem
	)
{
	if(FWide())
		return ModifyMenuW(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);

	if (MF_STRING == uFlags)
		{
		PreConvert();
		LPSTR sz = Convert(lpNewItem);
		return ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, sz);
		}
	else
		return ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, (LPSTR) lpNewItem);

}


// From: Mark Ashton on 5/29/97
BOOL
WINAPI
OMoveFileExW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName,
	DWORD dwFlags
	)
{
	if (FWide())
		return MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags);

	PreConvert();
	LPSTR szOld = Convert(lpExistingFileName);
	LPSTR szNew = Convert(lpNewFileName);

	return MoveFileExA(szOld, szNew, dwFlags);
}

BOOL
WINAPI
OMoveFileW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName)
{
	if(FWide())
		return MoveFileW(lpExistingFileName, lpNewFileName);

	PreConvert();
	LPSTR szOld = Convert(lpExistingFileName);
	LPSTR szNew = Convert(lpNewFileName);

	return MoveFileA(szOld, szNew);
}

HANDLE
WINAPI
OLoadImageW(
	HINSTANCE hinst,
	LPCWSTR lpszName,
	UINT uType,
	int cxDesired,
	int cyDesired,
	UINT fuLoad)
{
	if (FWide())
		{
		Assert(!(LR_LOADFROMFILE & fuLoad));
		return LoadImageW(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);
		}

	if (!FATOM(lpszName))
		{
		PreConvert();
		LPSTR pszName = Convert(lpszName);
		return LoadImageA(hinst, pszName, uType, cxDesired, cyDesired, fuLoad);
		}
	 else
		return LoadImageA(hinst, (LPSTR) lpszName, uType, cxDesired, cyDesired, fuLoad);
}

BOOL
WINAPI
OOemToCharW(
	LPCSTR lpszSrc,
	LPWSTR lpszDst)
{
	if(FWide())
		{
		Assert(lpszSrc != (LPCSTR) lpszDst);
#pragma prefast(suppress:56, "do not know the size of the destination")
		return OemToCharW(lpszSrc, lpszDst);
		}

	DWORD cb = _mbslen((const unsigned char *)lpszSrc);
	LPSTR szDst = SzAlloc(cb);
#pragma prefast(suppress:56, "noise")
	BOOL fRet = OemToCharA(lpszSrc, szDst);
	if(fRet)
		{
		Verify(0 <= AnsiToUnicode(lpszDst, szDst, cb));
		}
	return fRet;
}

VOID
WINAPI
OOutputDebugStringW(
	LPCWSTR lpOutputString
	)
{
	if(FWide())
		{
		OutputDebugStringW(lpOutputString);
		return;
		}

	PreConvert();
	LPSTR sz = Convert(lpOutputString);
	OutputDebugStringA(sz);
}

BOOL
WINAPI
OPeekMessageW(
	LPMSG lpMsg,
	HWND hWnd ,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax,
	UINT wRemoveMsg)
{
	if(FWide())
		return PeekMessageW(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

	return PeekMessageA(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

BOOL
WINAPI
OPostMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return PostMessageW(hWnd, Msg, wParam, lParam);

	return PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OPostThreadMessageW(
	DWORD idThread,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
 {
	if (FWide())
		return PostThreadMessageW(idThread, Msg, wParam, lParam);

	return PostThreadMessageA(idThread, Msg, wParam, lParam);
 }


// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegCreateKeyExW(
	HKEY hKey,
	LPCWSTR lpSubKey,
	DWORD Reserved,
	LPWSTR lpClass,
	DWORD dwOptions,
	REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult,
	LPDWORD lpdwDisposition
	)
{
	Assert(lpSubKey);
	if(FWide())
		return RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired,
			lpSecurityAttributes, phkResult, lpdwDisposition);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);
	LPSTR sz2 = Convert(lpClass);
	return RegCreateKeyExA(hKey, sz, Reserved, sz2, dwOptions, samDesired,
			lpSecurityAttributes, phkResult, lpdwDisposition);
}

// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegCreateKeyW (
	HKEY hKey,
	LPCWSTR lpSubKey,
	PHKEY phkResult
	)
{
	if (FWide())
		return RegCreateKeyW(hKey, lpSubKey, phkResult);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);
	return RegCreateKeyA(hKey, sz, phkResult);
}

// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegEnumKeyW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpName,
	DWORD cbName
	)
{
	if (FWide())
		return RegEnumKeyW(hKey, dwIndex, lpName, cbName);

	LPSTR sz = SzAlloc(cbName);
	LONG dwRet = RegEnumKeyA(hKey, dwIndex, sz, cbName);
	Verify(0 <= AnsiToUnicode(lpName, sz, cbName));
	return dwRet;
}

//  Van Kichline
//  IHammer group
//  Not supported: REG_MULTI_SZ
//
LONG
APIENTRY
ORegEnumValueW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpValueName,
	LPDWORD lpcbValueName,  // Documentation indicates this is a count of characters, despite the Hungarian.
	LPDWORD lpReserved,
	LPDWORD lpType,         // May be NULL, but we need to know it on return if lpData is not NULL.
	LPBYTE lpData,          // May be NULL
	LPDWORD lpcbData        // May be NULL is lpData is NULL
	)
{
	if (FWide())
		return RegEnumValueW(hKey, dwIndex, lpValueName, lpcbValueName, lpReserved, lpType, lpData, lpcbData);

	// Required pointers:
	if (!lpValueName || !lpcbValueName || !lpcbData && lpData)
		{
		Assert(lpValueName);
		Assert(lpcbValueName);
		Assert(!lpcbData && lpData);
		return E_POINTER;
		}

	// If NULL was specified for lpType, we need to supply our own so we can check for string results.
	DWORD dwPrivateType = 0;
	if (!lpType)
		{
		lpType = &dwPrivateType;
		}

	DWORD cbValueName  = *lpcbValueName;
	DWORD dwOrigCbData = lpcbData ? *lpcbData : 0;
	LPSTR pchValueName = SzAlloc(*lpcbValueName);

	LONG lResult = RegEnumValueA(hKey, dwIndex, pchValueName, &cbValueName, lpReserved, lpType, lpData, lpcbData);

	if (ERROR_SUCCESS == lResult)
		{
		*lpcbValueName = AnsiToUnicode(lpValueName, pchValueName, min(*lpcbValueName, cbValueName + 1)) - 1; // Returned value does NOT include terminating NULL

		if (lpData)
			{
			// If the resulting data was a string, convert it in place.
			switch (*lpType)
				{
				case REG_MULTI_SZ:
					// Not supported
					Assert(0 && REG_MULTI_SZ);
					lResult = E_FAIL;
					break;
				case REG_EXPAND_SZ:
				case REG_SZ:
					{
					Assert(lpcbData);
					LPSTR pszTemp = SzAlloc(*lpcbData); // is the number of bytes!
					memcpy(pszTemp, lpData, *lpcbData);
					*lpcbData = AnsiToUnicode((LPWSTR)lpData, pszTemp, dwOrigCbData/sizeof(WCHAR), *lpcbData) * sizeof(WCHAR);

					//	It's possible to encounter a second stage overflow, if lpData >= sizeof(Unicode)/2
					if ( 0 == *lpcbData )
						{
						lResult = ERROR_MORE_DATA;
						}
					}
					break;
				}
			}
		}

	return lResult;
}

LONG
APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
	if(FWide())
		return RegOpenKeyW(hKey, pwszSubKey, phkResult);

	PreConvert();
	LPSTR sz = Convert(pwszSubKey);

	return RegOpenKeyA(hKey, sz, phkResult);
}

LONG
APIENTRY
ORegDeleteKeyW(
	HKEY hKey,
	LPCWSTR pwszSubKey
	)
{
	Assert(pwszSubKey);
	if(FWide())
		return RegDeleteKeyW(hKey, pwszSubKey);

	PreConvert();
	LPSTR sz = Convert(pwszSubKey);
	return RegDeleteKeyA(hKey, sz);
}

LONG
APIENTRY
ORegDeleteValueW(
	HKEY hKey,
	LPWSTR lpValueName
	)
{
	if(FWide())
		return RegDeleteValueW (hKey, lpValueName);

	PreConvert();
	LPSTR sz = Convert(lpValueName);
	return RegDeleteValueA(hKey, sz);
}

ATOM
WINAPI
ORegisterClassW(
	CONST WNDCLASSW *lpWndClass)
{
	if(FWide())
		return RegisterClassW(lpWndClass);

	WNDCLASSA wc;
	memcpy(&wc, lpWndClass, sizeof(wc));

	PreConvert();

	if (!(IsBadReadPtr(wc.lpszMenuName, sizeof(* wc.lpszMenuName)) ||
		  IsBadReadPtr(lpWndClass->lpszMenuName, sizeof (*(lpWndClass->lpszMenuName)))))
		{
		wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
		}

	wc.lpszClassName = Convert(lpWndClass->lpszClassName);

	return RegisterClassA(&wc);
}

ATOM
WINAPI
ORegisterClassExW(CONST WNDCLASSEXW * lpWndClass)
{
	if (FWide())
		return RegisterClassExW(lpWndClass);

	WNDCLASSEXA wc;
	memcpy(&wc, lpWndClass, sizeof(wc));

	PreConvert();

	if (!FATOM(wc.lpszMenuName))
		{
		wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
		}

	if (!FATOM(wc.lpszClassName))
		wc.lpszClassName = Convert(lpWndClass->lpszClassName);

	return RegisterClassExA(&wc);
}

BOOL
WINAPI
OUnregisterClassW
(
LPCTSTR  lpClassName,   // address of class name string
HINSTANCE  hInstance    // handle of application instance
)
{
	if(FWide())
		return UnregisterClassW(lpClassName, hInstance);

	if (FATOM(lpClassName))
		return UnregisterClassW(lpClassName, hInstance);

	PreConvert();
	LPSTR sz = Convert(lpClassName);

	return UnregisterClassA(sz, hInstance);
}

UINT
WINAPI
ORegisterClipboardFormatW(
	LPCWSTR lpszFormat)
{
	if(FWide())
		return RegisterClipboardFormatW(lpszFormat);

	PreConvert();
	LPSTR sz = Convert(lpszFormat);

	return RegisterClipboardFormatA(sz);
}

UINT
WINAPI
ORegisterWindowMessageW(LPCWSTR lpString)
{
	if(FWide())
		return RegisterWindowMessageW(lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return  RegisterWindowMessageA(sz);
}

LONG
APIENTRY
ORegOpenKeyExW (
	HKEY hKey,
	LPCTSTR lpSubKey,
	DWORD ulOptions,
	REGSAM samDesired,
	PHKEY phkResult
	)
{
	if(FWide())
		return RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);

	return RegOpenKeyExA(hKey, sz, ulOptions, samDesired, phkResult);
}

LONG
APIENTRY
ORegQueryInfoKeyW (
	HKEY hKey,
	LPWSTR lpClass,
	LPDWORD lpcbClass,
	LPDWORD lpReserved,
	LPDWORD lpcSubKeys,
	LPDWORD lpcbMaxSubKeyLen,
	LPDWORD lpcbMaxClassLen,
	LPDWORD lpcValues,
	LPDWORD lpcbMaxValueNameLen,
	LPDWORD lpcbMaxValueLen,
	LPDWORD lpcbSecurityDescriptor,
	PFILETIME lpftLastWriteTime
	)
{
	Assert(!lpClass && !lpcbClass); //$ UNDONE_POST_98 - Not wrapped yet!
	if(FWide())
		return RegQueryInfoKeyW(hKey, lpClass, lpcbClass, lpReserved,
								lpcSubKeys, lpcbMaxSubKeyLen,
								lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
								lpcbMaxValueLen, lpcbSecurityDescriptor,
								lpftLastWriteTime );

	if (lpClass && (!lpcbClass || IsBadWritePtr(lpcbClass, sizeof(lpcbClass))))
		{
		// lpcbClass must be valid if lpClass is non-NULL
		return ERROR_INVALID_PARAMETER;
		}

	return RegQueryInfoKeyA(hKey, NULL, NULL, lpReserved,
							lpcSubKeys, lpcbMaxSubKeyLen,
							lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
							lpcbMaxValueLen, lpcbSecurityDescriptor,
							lpftLastWriteTime );
}

LONG
APIENTRY ORegQueryValueW(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue,
	PLONG   lpcbValue)
{
	if(FWide())
		return RegQueryValueW(hKey, pwszSubKey, pwszValue, lpcbValue);

	LONG  cb;
	LONG  lRet    = 0;
	LPSTR szValue = NULL;
	PreConvert();
	LPSTR sz = Convert(pwszSubKey);

	lRet = RegQueryValueA(hKey, sz, NULL, &cb);

	if(ERROR_SUCCESS != lRet)
		{
		return lRet;
		}
	// If the caller was just asking for the size of the value, jump out
	//  now, without actually retrieving and converting the value.

	if (!pwszValue)
		{
		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		goto Exit;
		}


	// If the caller was asking for the value, but allocated too small
	// of a buffer, set the buffer size and jump out.

	if (*lpcbValue < (LONG) (cb * sizeof(WCHAR)))
		{
		//$UNDONE_POST_98: We should actually use the nubmer of bytes required, not some
		// wild guess as we are here

		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		lRet = ERROR_MORE_DATA;
		goto Exit;
		}

	// Otherwise, retrieve and convert the value.

	szValue = SzAlloc(cb);

	lRet = RegQueryValueA(hKey, sz, szValue, &cb);

	if (ERROR_SUCCESS == lRet)
		{
		Verify(0 <= AnsiToUnicode(pwszValue, szValue, cb));

		//$UNDONE_POST_98: We should actually use the nubmer of bytes required, not some
		// wild guess as we are here

		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		}
	else if (pwszValue && 0 < cb)
		{
		*pwszValue = L'\0';
		}

Exit:

	return lRet;
}

LONG
APIENTRY
ORegSetValueExW(
	HKEY hKey,
	LPCWSTR lpValueName,
	DWORD Reserved,
	DWORD dwType,
	CONST BYTE* lpData,
	DWORD cbData
	)
{
	if(FWide())
		return RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

	PreConvert();
	LPSTR sz = Convert(lpValueName);

	LONG lRet;

	// NOTE: when calling RegSetValueExA, if the data type is
	// REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, then the API expects the strings
	// to be ansi also.
	if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
		{
		LONG lData = 0;
		LPSTR szData = ConvertWithLen((LPTSTR)lpData, -1, &lData);
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, (CONST BYTE *)szData, lData);
		}
	else if (REG_MULTI_SZ == dwType)
		{
		LONG lData = 0;
		LPSTR szData = ConvertWithLen((LPWSTR)lpData,
									  cUnicodeMultiSzLen((LPWSTR)lpData),
									  &lData );
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, (CONST BYTE *)szData, lData);
		}
	else
		{
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, lpData, cbData);
		}

	return lRet;
}

LONG
APIENTRY ORegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType,
	LPCWSTR lpData, DWORD cbData)
{
	Assert(REG_SZ == dwType);

	if(FWide())
		return RegSetValueW(hKey, lpSubKey, dwType,
			lpData, cbData);

	PreConvert();
	LPSTR szKey   = Convert(lpSubKey);
	LPSTR szValue = Convert(lpData);

	return RegSetValueA(hKey, szKey, dwType, szValue, cbData);
}

LONG
APIENTRY
ORegQueryValueExW (
	HKEY hKey,
	LPCWSTR lpValueName,
	LPDWORD lpReserved,
	LPDWORD lpType,
	LPBYTE lpData,
	LPDWORD lpcbData
	)
{
	Assert(lpcbData || !lpData); // lpcbData can be NULL only if lpData is NULL
	if(FWide())
		return RegQueryValueExW (
			hKey,
			lpValueName,
			lpReserved,
			lpType,
			lpData,
			lpcbData
			);

	LPBYTE lpTempBuffer;
	DWORD dwTempType;
	DWORD cb, cbRequired;
	LONG  lRet;
	PreConvert();
	LPSTR sz = Convert(lpValueName);

	lRet = RegQueryValueExA(hKey, sz, lpReserved, &dwTempType, NULL, &cb);

	if(ERROR_SUCCESS != lRet)
		{
		return lRet;
		}

	// If the caller was just asking for the size of the value, jump out
	//  now, without actually retrieving and converting the value.

	if (!lpData)
		{
		switch (dwTempType)
			{
			case REG_EXPAND_SZ:
			case REG_MULTI_SZ:
			case REG_SZ:
				// Adjust size of buffer to report, to account for CHAR -> WCHAR

				*lpcbData = cb * sizeof(WCHAR);
				break;

			default:
				*lpcbData = cb;
				break;
			}

		// Set the type, if required.
		if (lpType)
			{
			*lpType = dwTempType;
			}

		goto Exit;
		}


	//
	// Determine the size of buffer needed
	//

	switch (dwTempType)
		{
		case REG_EXPAND_SZ:
		case REG_MULTI_SZ:
		case REG_SZ:
			cbRequired = cb * sizeof(WCHAR);
			break;

		default:
			cbRequired = cb;
			break;
		}

	// If the caller was asking for the value, but allocated too small
	// of a buffer, set the buffer size and jump out.

	if (*lpcbData < cbRequired)
		{
		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbData = cbRequired;

		// Set the type, if required.
		if (lpType)
			{
			*lpType = dwTempType;
			}

		lRet = ERROR_MORE_DATA;
		goto Exit;
		}

	// Otherwise, retrieve and convert the value.

	switch (dwTempType)
		{
		case REG_EXPAND_SZ:
		case REG_MULTI_SZ:
		case REG_SZ:

			lpTempBuffer = (LPBYTE)SzAlloc(cbRequired);

			lRet = RegQueryValueExA(hKey,
									sz,
									lpReserved,
									&dwTempType,
									lpTempBuffer,
									&cb);

			if (ERROR_SUCCESS == lRet)
				{
				switch (dwTempType)
					{
					case REG_EXPAND_SZ:
					case REG_MULTI_SZ:
					case REG_SZ:

						*lpcbData = AnsiToUnicode((LPWSTR)lpData, (LPSTR)lpTempBuffer, *lpcbData, cb);
						*lpcbData = cb * sizeof(WCHAR); // Result it in BYTES!

						// Set the type, if required.
						if (lpType)
							{
							*lpType = dwTempType;
							}
						break;
					}
				}

			goto Exit;

		default:

			//
			// No conversion of out parameters needed.  Just call narrow
			// version with args passed in, and return directly.
			//

			lRet = RegQueryValueExA(hKey,
									sz,
									lpReserved,
									lpType,
									lpData,
									lpcbData);

		}

Exit:

	return lRet;
}

HANDLE
WINAPI
ORemovePropW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return RemovePropW(hWnd, lpString);

	if(FATOM(lpString))
		return RemovePropA(hWnd, (LPSTR)lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return RemovePropA(hWnd, sz);
}

LRESULT
WINAPI
OSendDlgItemMessageW(
	HWND hDlg,
	int nIDDlgItem,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);

	PreConvert();
	switch (Msg)
		{
		case LB_ADDSTRING:
		case LB_INSERTSTRING:
		case LB_SELECTSTRING:
		case LB_FINDSTRING:
		case LB_FINDSTRINGEXACT:
		case CB_ADDSTRING:
		case CB_INSERTSTRING:
		case CB_SELECTSTRING:
		case CB_FINDSTRING:
		case CB_FINDSTRINGEXACT:
			{
			lParam = (LPARAM)Convert((LPWSTR)lParam);
			break;
			}
		}

	return SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
}

LRESULT
WINAPI
OSendMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	// incase TCHAR strings are being passed in lParam the caller
	// will have to do the proper conversions PlatformToInternal or
	// InternalToPlatform

	if(FWide())
		return SendMessageW(hWnd, Msg, wParam, lParam);

	return SendMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OSendNotifyMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return SendNotifyMessageW(hWnd, Msg, wParam, lParam);

	return SendNotifyMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OSetDlgItemTextW(
	HWND hDlg,
	int nIDDlgItem,
	LPCWSTR lpString)
{
	if(FWide())
		return SetDlgItemTextW(hDlg, nIDDlgItem, lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetDlgItemTextA(hDlg, nIDDlgItem, sz);
}

BOOL
WINAPI
OSetFileAttributesW(
	LPCWSTR lpFileName,
	DWORD dwFileAttributes
	)
{
	if (FWide())
		return SetFileAttributesW(lpFileName, dwFileAttributes);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	return SetFileAttributesA(sz, dwFileAttributes);
}

BOOL
WINAPI
OSetPropW(
	HWND hWnd,
	LPCWSTR lpString,
	HANDLE hData)
{
	if(FWide())
		return SetPropW(hWnd, lpString, hData);

	if(FATOM(lpString))
		return SetPropA(hWnd, (LPSTR)lpString, hData);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetPropA(hWnd, sz, hData);
}

BOOL
WINAPI
OSetMenuItemInfoW(
	HMENU hMenu,
	UINT uItem,
	BOOL fByPosition,
	LPCMENUITEMINFOW lpcmii
	)
{
	Assert(!IsBadWritePtr((void*)lpcmii, sizeof MENUITEMINFOW));
	Assert(sizeof MENUITEMINFOW == lpcmii->cbSize);
	Assert(sizeof MENUITEMINFOW == sizeof MENUITEMINFOA);

	if (FWide())
		return SetMenuItemInfoW(hMenu, uItem, fByPosition, lpcmii);

	MENUITEMINFOA mii;
	memcpy(&mii, lpcmii, sizeof MENUITEMINFOA);

	if (!(lpcmii->fMask & MIIM_TYPE) ||
		MFT_STRING != (lpcmii->fType &
				  (MFT_BITMAP | MFT_SEPARATOR | MFT_OWNERDRAW | MFT_STRING) ) )
		{
		return SetMenuItemInfoA(hMenu, uItem, fByPosition, &mii);
		}

	PreConvert();
	mii.dwTypeData = Convert(lpcmii->dwTypeData);
	return SetMenuItemInfoA(hMenu, uItem, fByPosition, &mii);
}

LONG
WINAPI
OSetWindowLongW(
	HWND hWnd,
	int nIndex,
	LONG dwNewLong)
{
	if(FWide())
		return SetWindowLongW(hWnd, nIndex, dwNewLong);

	return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

HHOOK
WINAPI
OSetWindowsHookExW(
	int idHook,
	HOOKPROC lpfn,
	HINSTANCE hmod,
	DWORD dwThreadId)
{
	if(FWide())
		return SetWindowsHookExW(idHook, lpfn, hmod, dwThreadId);

	return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);  //$ CONSIDER - Not really wrapped
}

BOOL
WINAPI
OSetWindowTextW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return SetWindowTextW(hWnd, lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetWindowTextA(hWnd, sz);
}

LONG
WINAPI
OTabbedTextOutW(
	HDC hDC,
	int X,
	int Y,
	LPCWSTR lpString,
	int nCount,
	int nTabPositions,
	LPINT lpnTabStopPositions,
	int nTabOrigin)
{
	Assert(-1 != nCount);

	if(FWide())
		return TabbedTextOutW(hDC, X, Y, lpString, nCount, nTabPositions,
			lpnTabStopPositions, nTabOrigin);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpString, nCount, &n);

	return TabbedTextOutA(hDC, X, Y, sz, n, nTabPositions,
						  lpnTabStopPositions, nTabOrigin );
}

#if 0
// FOR OLE CTL: THIS MAGLES INTERFACE MEMBERS BY SAME NAME
int
WINAPI
OTranslateAcceleratorW(
	HWND hWnd,
	HACCEL hAccTable,
	LPMSG lpMsg)
{
	if(FWide())
		return TranslateAcceleratorW(hWnd, hAccTable, lpMsg);

	return TranslateAcceleratorA(hWnd, hAccTable, lpMsg);
}
#endif

SHORT
WINAPI
OVkKeyScanW(
	WCHAR ch)
{
	if (FWide())
		return VkKeyScanW(ch);
	TCHAR szW[2];
	char szA[2];
	szW[0] = ch;
	szW[1] = L'\0';
	Verify(0 <= UnicodeToAnsi(szA, szW, 2));
	return VkKeyScanA(szA[0]);
}

BOOL
WINAPI
OWinHelpW(
	HWND hWndMain,
	LPCWSTR lpszHelp,
	UINT uCommand,
	DWORD dwData
	)
{
	if(FWide())
		return WinHelpW(hWndMain, lpszHelp, uCommand,dwData);

	PreConvert();
	LPSTR sz = Convert(lpszHelp);
	return WinHelpA(hWndMain, sz, uCommand, dwData);
}

BOOL
WINAPI
OWritePrivateProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpString,
	LPCWSTR lpFileName)
{
	if(FWide())
		return WritePrivateProfileStringW(lpAppName, lpKeyName, lpString, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szString   = Convert(lpString);
	LPSTR szFileName = Convert(lpFileName);

	return WritePrivateProfileStringA(szAppName, szKeyName, szString, szFileName);
}

int
WINAPIV
OwsprintfW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
	va_list vaArgs;
	va_start(vaArgs, pwszFormat);
	int retval;

	if(FWide())
		retval = wvsprintfW(pwszOut, pwszFormat, vaArgs);
	else
		retval = _vstprintf(pwszOut, pwszFormat, vaArgs); //$CONSIDER Why isn't this vswprint?

	va_end(vaArgs);
	return retval;
}

BOOL
WINAPI
OGetVersionExW(
	LPOSVERSIONINFOW lpVersionInformation
	)
{
	if(FWide())
		return GetVersionExW(lpVersionInformation);

	if (lpVersionInformation->dwOSVersionInfoSize < sizeof(OSVERSIONINFOW))
		return false;

	OSVERSIONINFOA  osviVersionInfo;
	osviVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	int fRetval = GetVersionExA(&osviVersionInfo);

	if (fRetval)
		{
		memcpy(lpVersionInformation, &osviVersionInfo, sizeof(OSVERSIONINFOA));

		Verify(0 <= AnsiToUnicode(lpVersionInformation->szCSDVersion,
								 osviVersionInfo.szCSDVersion,
								 sizeof(lpVersionInformation->szCSDVersion)
								 /sizeof(lpVersionInformation->szCSDVersion[0])));
		}

	return fRetval;
}

LONG
APIENTRY
ORegEnumKeyExW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpName,
	LPDWORD lpcbName,
	LPDWORD lpReserved,
	LPWSTR lpClass,
	LPDWORD lpcbClass,
	PFILETIME lpftLastWriteTime
	)
{
	if(FWide())
		return RegEnumKeyExW (
			hKey,
			dwIndex,
			lpName,
			lpcbName,
			lpReserved,
			lpClass,
			lpcbClass,
			lpftLastWriteTime
			);

	LPSTR szName, szClass;
	DWORD cbName, cbClass;

	if (lpcbName)
		{
		cbName = sizeof(WCHAR) * *lpcbName;
		szName = lpName ? SzAlloc(cbName) : NULL;
		}
	else
		{
		szName = NULL;
		cbName = 0;
		}

	if (lpcbClass)
		{
		cbClass = sizeof(WCHAR) * (*lpcbClass);
		szClass = lpClass ? SzAlloc(cbClass) : NULL;
		}
	else
		{
		szClass = NULL;
		cbClass = 0;
		}

	LONG lRet = RegEnumKeyExA(hKey, dwIndex, szName, &cbName, lpReserved,
							  szClass, &cbClass, lpftLastWriteTime );

	if (ERROR_SUCCESS != lRet)
		{
		return lRet;
		}

	// Get the number of characters instead of number of bytes.
	if (lpcbName)
		{
		DWORD dwNoOfChar = AnsiToUnicode((LPWSTR) lpName, (LPSTR) szName, *lpcbName);
		if (cbName && !dwNoOfChar)
			{
			return ERROR_BUFFER_OVERFLOW;
			}

		*lpcbName = dwNoOfChar;
		}

	if (lpcbClass && lpClass)
		{
		DWORD dwNoOfChar = AnsiToUnicode((LPWSTR) lpClass, (LPSTR) szClass, *lpcbClass);

		if (cbClass && !dwNoOfChar)
			{
			return ERROR_BUFFER_OVERFLOW;
			}

		*lpcbClass = dwNoOfChar;
		}

	return lRet;

}

HANDLE
WINAPI
OCreateFileMappingW(
	HANDLE hFile,
	LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
	DWORD flProtect,
	DWORD dwMaximumSizeHigh,
	DWORD dwMaximumSizeLow,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, sz);
}

LRESULT
WINAPI
ODefDlgProcW(
	HWND hDlg,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	// incase TCHAR strings are being passed in lParam the caller
	// will have to do the proper conversions PlatformToInternal or
	// InternalToPlatform

	if(FWide())
		return DefDlgProcW(hDlg, Msg, wParam, lParam);

	return DefDlgProcA(hDlg, Msg, wParam, lParam);
}

int
WINAPI
OGetLocaleInfoW(
	LCID     Locale,
	LCTYPE   LCType,
	LPWSTR  lpLCData,
	int      cchData)
{
	DWORD dwRet;

	if (FWide())
		return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);

	if (!cchData || !lpLCData)
		return GetLocaleInfoA(Locale, LCType, NULL, cchData);

	int cchDataAnsi = sizeof(WCHAR) * cchData;
	LPSTR szBuffer = SzAlloc(cchDataAnsi);

	dwRet = GetLocaleInfoA(Locale, LCType, szBuffer, cchDataAnsi);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(dwRet)
		{
		return AnsiToUnicode(lpLCData, szBuffer, cchData, dwRet);
		}
	else if (lpLCData && 0 < cchData)
		{
		*lpLCData = L'\0';
		}

	return dwRet;
}

BOOL
WINAPI
OSetLocaleInfoW(
	LCID     Locale,
	LCTYPE   LCType,
	LPCWSTR lpLCData)
{
	if (FWide())
		return SetLocaleInfoW(Locale, LCType, lpLCData);
	PreConvert();
	LPSTR sz = Convert(lpLCData);

	return SetLocaleInfoA(Locale, LCType, sz);
}

// $UNDONE_POST_98$ Workaround because StgCreateDocfile is not reentrant.
//          We were getting ACCESS DENIED errors when multiple threads opened
//             temp files simultaneously.

//-----------------------------------------------------------------------------
// Name: StgCreateDocfileCriticalSection
//
// Description:
// Used solely by OStgCreateDocfile in order to protect its call to
// StgCreateDocfile from simultaneously entry by multiple threads.
//
//-----------------------------------------------------------------------------
class StgCreateDocfileCriticalSection
{
public:
	StgCreateDocfileCriticalSection() {InitializeCriticalSection(&m_critsec);}
	~StgCreateDocfileCriticalSection() {DeleteCriticalSection(&m_critsec);}
	VOID VEnter() {EnterCriticalSection(&m_critsec);}
	VOID VLeave() {LeaveCriticalSection(&m_critsec);}
private:
	CRITICAL_SECTION m_critsec;
};

//-----------------------------------------------------------------------------
// Name: OStgCreateDocfile
//
// Description:
// Wrapper for StgCreateDocfile to protect against reentrancy bug in OLE.
//
// Thread-Safety: Bullet-proof
//
// Return Values: same HRESULT as StgCreateDocfile
//-----------------------------------------------------------------------------
HRESULT
WINAPI
OStgCreateDocfile
(
const WCHAR * pwcsName,
DWORD grfMode,
DWORD reserved,
IStorage ** ppstgOpen
)
{
	HRESULT hrReturn;
	static StgCreateDocfileCriticalSection Crit;
	Crit.VEnter();
// Change: Vank
// This definitions was infinitely recursive.  The 64 bit compiler caught it and refused to let it pass.
#ifdef StgCreateDocfile
#undef StgCreateDocfile
	hrReturn = StgCreateDocfile(pwcsName, grfMode, reserved, ppstgOpen);
#define StgCreateDocfile OStgCreateDocfile
#else
	hrReturn = StgCreateDocfile(pwcsName, grfMode, reserved, ppstgOpen);
#endif
// End change: VanK
	Crit.VLeave();
	return hrReturn;
}

int
WINAPI
OStartDocW
(
HDC hDC,
CONST DOCINFOW * pdiDocW
)
{
	if (FWide())
		return StartDocW(hDC, pdiDocW);

	DOCINFOA diDocA;

	PreConvert();

	diDocA.lpszDocName  = Convert(pdiDocW->lpszDocName);
	diDocA.lpszOutput   = Convert(pdiDocW->lpszOutput);
	diDocA.lpszDatatype = Convert(pdiDocW->lpszDatatype);
	diDocA.cbSize       = sizeof(DOCINFOA);
	diDocA.fwType       = pdiDocW->fwType;

	return StartDocA(hDC, &diDocA);

}

BOOL
WINAPI
OSystemParametersInfoW(
	UINT uiAction,
	UINT uiParam,
	PVOID pvParam,
	UINT fWinIni)
{
	if (FWide())
		return SystemParametersInfoW(uiAction, uiParam, pvParam, fWinIni);

	switch (uiAction)
		{   // unsupported actions
		case SPI_GETHIGHCONTRAST:
		case SPI_GETICONMETRICS:
		case SPI_GETICONTITLELOGFONT:
		case SPI_GETNONCLIENTMETRICS:
		case SPI_GETSERIALKEYS:
		case SPI_GETSOUNDSENTRY:

		case SPI_SETDESKWALLPAPER:
		case SPI_SETHIGHCONTRAST:
		case SPI_SETICONMETRICS:
		case SPI_SETICONTITLELOGFONT:
		case SPI_SETNONCLIENTMETRICS:
		case SPI_SETSERIALKEYS:
		case SPI_SETSOUNDSENTRY:
			AssertFail("No Unicode Wrapper Available for Win32 API - SystemParametersInfoW");
			return 0;
		};
	return SystemParametersInfoA(uiAction, uiParam, pvParam, fWinIni);
}

LPWSTR
WINAPI
OCharNextW(
LPCWSTR lpsz)
{
	if ( FWide() )
		return CharNextW( lpsz );

	if (*lpsz == L'\0')
		{
		return const_cast<LPWSTR>(lpsz);
		}

	return const_cast<LPWSTR>(lpsz + 1);
}


#ifdef DEBUG
BOOL
APIENTRY
OAbortSystemShutdownW(
	LPWSTR lpMachineName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AbortSystemShutdownW");
	return 0;
}

BOOL
WINAPI
OAccessCheckAndAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	LPWSTR ObjectTypeName,
	LPWSTR ObjectName,
	PSECURITY_DESCRIPTOR SecurityDescriptor,
	DWORD DesiredAccess,
	PGENERIC_MAPPING GenericMapping,
	BOOL ObjectCreation,
	LPDWORD GrantedAccess,
	LPBOOL AccessStatus,
	LPBOOL pfGenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AccessCheckAndAuditAlarmW");
	return 0;
}

int
WINAPI OAddFontResourceW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddFontResourceW");
	return 0;
}

BOOL
WINAPI
OAddFormW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pForm
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddFormW");
	return 0;
}

BOOL
WINAPI
OAddJobW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pData,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddJobW");
	return 0;
}

BOOL
WINAPI
OAddMonitorW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pMonitors
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddMonitorW");
	return 0;
}

BOOL
WINAPI
OAddPortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pMonitorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPortW");
	return 0;
}

HANDLE
WINAPI
OAddPrinterW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pPrinter
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterW");
	return 0;
}

BOOL
WINAPI
OAddPrinterConnectionW(
	LPWSTR   pName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterConnectionW");
	return 0;
}

BOOL
WINAPI
OAddPrinterDriverW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pDriverInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterDriverW");
	return 0;
}

BOOL
WINAPI
OAddPrintProcessorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPathName,
	LPWSTR   pPrintProcessorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrintProcessorW");
	return 0;
}

BOOL
WINAPI
OAddPrintProvidorW(
	LPWSTR  pName,
	DWORD    level,
	LPBYTE   pProvidorInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrintProvidorW");
	return 0;
}

LONG
WINAPI
OAdvancedDocumentPropertiesW(
	HWND    hWnd,
	HANDLE  hPrinter,
	LPWSTR   pDeviceName,
	PDEVMODEW pDevModeOutput,
	PDEVMODEW pDevModeInput
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AdvancedDocumentPropertiesW");
	return 0;
}

MMRESULT WINAPI OauxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - auxGetDevCapsW");
	return 0;
}

BOOL
WINAPI
OBackupEventLogW (
	HANDLE hEventLog,
	LPCWSTR lpBackupFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BackupEventLogW");
	return 0;
}

HANDLE
WINAPI
OBeginUpdateResourceW(
	LPCWSTR pFileName,
	BOOL bDeleteExistingResources
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BeginUpdateResourceW");
	return 0;
}

BOOL
WINAPI
OBuildCommDCBW(
	LPCWSTR lpDef,
	LPDCB lpDCB
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BuildCommDCBW");
	return 0;
}

BOOL
WINAPI
OBuildCommDCBAndTimeoutsW(
	LPCWSTR lpDef,
	LPDCB lpDCB,
	LPCOMMTIMEOUTS lpCommTimeouts
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BuildCommDCBAndTimeoutsW");
	return 0;
}

BOOL
WINAPI
OCallMsgFilterW(
	LPMSG lpMsg,
	int nCode)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CallMsgFilterW");
	return 0;
}

BOOL
WINAPI
OCallNamedPipeW(
	LPCWSTR lpNamedPipeName,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesRead,
	DWORD nTimeOut
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CallNamedPipeW");
	return 0;
}

LONG
WINAPI
OChangeDisplaySettingsW(
	LPDEVMODEW lpDevMode,
	DWORD dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeDisplaySettingsW");
	return 0;
}

BOOL
WINAPI
OChangeMenuW(
	HMENU hMenu,
	UINT cmd,
	LPCWSTR lpszNewItem,
	UINT cmdInsert,
	UINT flags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeMenuW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OChangeServiceConfigW(
	SC_HANDLE    hService,
	DWORD        dwServiceType,
	DWORD        dwStartType,
	DWORD        dwErrorControl,
	LPCWSTR     lpBinaryPathName,
	LPCWSTR     lpLoadOrderGroup,
	LPDWORD      lpdwTagId,
	LPCWSTR     lpDependencies,
	LPCWSTR     lpServiceStartName,
	LPCWSTR     lpPassword,
	LPCWSTR     lpDisplayName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeServiceConfigW");
	return 0;
}
#endif

BOOL
WINAPI
OCharToOemBuffW(
	LPCWSTR lpszSrc,
	LPSTR lpszDst,
	DWORD cchDstLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CharToOemBuffW");
	return 0;
}

DWORD
WINAPI
OCharUpperBuffW(
	LPWSTR lpsz,
	DWORD cchLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CharUpperBuffW");
	return 0;
}

BOOL
WINAPI
OChooseColorW(
	LPCHOOSECOLORW lpcc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChooseColorW");
	return 0;
}

BOOL
APIENTRY OChooseFontW(LPCHOOSEFONTW pchfw)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChooseFontW");
	return 0;
}

BOOL
WINAPI
OClearEventLogW (
	HANDLE hEventLog,
	LPCWSTR lpBackupFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ClearEventLogW");
	return 0;
}

BOOL
WINAPI
OCommConfigDialogW(
	LPCWSTR lpszName,
	HWND hWnd,
	LPCOMMCONFIG lpCC
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CommConfigDialogW");
	return 0;
}

int
WINAPI
OCompareStringW(
	LCID     Locale,
	DWORD    dwCmpFlags,
	LPCWSTR lpString1,
	int      cchCount1,
	LPCWSTR lpString2,
	int      cchCount2)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CompareStringW");
	return 0;
}

BOOL
WINAPI
OConfigurePortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pPortName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ConfigurePortW");
	return 0;
}

int
WINAPI
OCopyAcceleratorTableW(
	HACCEL hAccelSrc,
	LPACCEL lpAccelDst,
	int cAccelEntries)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyAcceleratorTableW");
	return 0;
}

HENHMETAFILE
WINAPI
OCopyEnhMetaFileW(HENHMETAFILE, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyEnhMetaFileW");
	return 0;
}

HMETAFILE
WINAPI
OCopyMetaFileW(HMETAFILE, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyMetaFileW");
	return 0;
}

HACCEL
WINAPI
OCreateAcceleratorTableW(
	LPACCEL, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateAcceleratorTableW");
	return 0;
}

WINAPI
OCreateColorSpaceW(LPLOGCOLORSPACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateColorSpaceW");
	return 0;
}

HDESK
WINAPI
OCreateDesktopW(
	LPWSTR lpszDesktop,
	LPWSTR lpszDevice,
	LPDEVMODEW pDevmode,
	DWORD dwFlags,
	DWORD dwDesiredAccess,
	LPSECURITY_ATTRIBUTES lpsa)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDesktopW");
	return 0;
}

HWND
WINAPI
OCreateDialogIndirectParamW(
	HINSTANCE hInstance,
	LPCDLGTEMPLATEW lpTemplate,
	HWND hWndParent,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDialogIndirectParamW");
	return 0;
}

HWND
WINAPI
OCreateDialogParamW(
	HINSTANCE hInstance,
	LPCWSTR lpTemplateName,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDialogParamW");
	return 0;
}

HDC
WINAPI
OCreateICW(
	LPCWSTR lpszDriver,
	LPCWSTR lpszDevice,
	LPCWSTR lpszOutput,
	CONST DEVMODEW *lpdvmInit)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateICW");
	return 0;
}

HANDLE
WINAPI
OCreateMailslotW(
	LPCWSTR lpName,
	DWORD nMaxMessageSize,
	DWORD lReadTimeout,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateMailslotW");
	return 0;
}

HANDLE
WINAPI
OCreateMutexW(
	LPSECURITY_ATTRIBUTES lpMutexAttributes,
	BOOL bInitialOwner,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateMutexW");
	return 0;
}

HANDLE
WINAPI
OCreateNamedPipeW(
	LPCWSTR lpName,
	DWORD dwOpenMode,
	DWORD dwPipeMode,
	DWORD nMaxInstances,
	DWORD nOutBufferSize,
	DWORD nInBufferSize,
	DWORD nDefaultTimeOut,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateNamedPipeW");
	return 0;
}

BOOL
WINAPI
OCreateProcessW(
	LPCWSTR lpApplicationName,
	LPWSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory,
	LPSTARTUPINFOW lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateProcessW");
	return 0;
}

BOOL
WINAPI
OCreateProcessAsUserW (
	HANDLE hToken,
	LPCWSTR lpApplicationName,
	LPWSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory,
	LPSTARTUPINFOW lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateProcessAsUserW");
	return 0;
}

HPROPSHEETPAGE
WINAPI
OCreatePropertySheetPageW(
	LPCPROPSHEETPAGEW lpcpsp
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreatePropertySheetPageW");
	return 0;
}

BOOL
WINAPI
OCreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateScalableFontResourceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OCreateServiceW(
	SC_HANDLE    hSCManager,
	LPCWSTR     lpServiceName,
	LPCWSTR     lpDisplayName,
	DWORD        dwDesiredAccess,
	DWORD        dwServiceType,
	DWORD        dwStartType,
	DWORD        dwErrorControl,
	LPCWSTR     lpBinaryPathName,
	LPCWSTR     lpLoadOrderGroup,
	LPDWORD      lpdwTagId,
	LPCWSTR     lpDependencies,
	LPCWSTR     lpServiceStartName,
	LPCWSTR     lpPassword
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateServiceW");
	return 0;
}
#endif

HWND WINAPI OCreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateStatusWindowW");
	return 0;
}

HWINSTA
WINAPI
OCreateWindowStationW(
	LPWSTR lpwinsta,
	DWORD dwReserved,
	DWORD dwDesiredAccess,
	LPSECURITY_ATTRIBUTES lpsa)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateWindowStationW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ODceErrorInqTextW (
	IN RPC_STATUS RpcStatus,
	OUT unsigned short __RPC_FAR * ErrorText
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DceErrorInqTextW");
	return 0;
}

BOOL
WINAPI
ODefineDosDeviceW(
	DWORD dwFlags,
	LPCWSTR lpDeviceName,
	LPCWSTR lpTargetPath
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DefineDosDeviceW");
	return 0;
}

BOOL
WINAPI
ODeleteFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeleteFormW");
	return 0;
}

BOOL
WINAPI
ODeleteMonitorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pMonitorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeleteMonitorW");
	return 0;
}

BOOL
WINAPI
ODeletePortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pPortName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePortW");
	return 0;
}

BOOL
WINAPI
ODeletePrinterConnectionW(
	LPWSTR   pName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrinterConnectionW");
	return 0;
}

BOOL
WINAPI
ODeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrinterDriverW");
	return 0;
}

BOOL
WINAPI
ODeletePrintProcessorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPrintProcessorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrintProcessorW");
	return 0;
}

BOOL
WINAPI
ODeletePrintProvidorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPrintProvidorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrintProvidorW");
	return 0;
}

int
WINAPI
ODeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,
								LPWSTR, CONST DEVMODEW *)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeviceCapabilitiesW");
	return 0;
}

int
WINAPI
ODlgDirListW(
	HWND hDlg,
	LPWSTR lpPathSpec,
	int nIDListBox,
	int nIDStaticPath,
	UINT uFileType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirListW");
	return 0;
}

int
WINAPI
ODlgDirListComboBoxW(
	HWND hDlg,
	LPWSTR lpPathSpec,
	int nIDComboBox,
	int nIDStaticPath,
	UINT uFiletype)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirListComboBoxW");
	return 0;
}

BOOL
WINAPI
ODlgDirSelectComboBoxExW(
	HWND hDlg,
	LPWSTR lpString,
	int nCount,
	int nIDComboBox)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirSelectComboBoxExW");
	return 0;
}

BOOL
WINAPI
ODlgDirSelectExW(
	HWND hDlg,
	LPWSTR lpString,
	int nCount,
	int nIDListBox)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirSelectExW");
	return 0;
}

DWORD
WINAPI
ODocumentPropertiesW(
	HWND      hWnd,
	HANDLE    hPrinter,
	LPWSTR   pDeviceName,
	PDEVMODEW pDevModeOutput,
	PDEVMODEW pDevModeInput,
	DWORD     fMode
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DocumentPropertiesW");
	return 0;
}

DWORD
APIENTRY
ODoEnvironmentSubstW(LPWSTR szString, UINT cbString)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DoEnvironmentSubstW");
	return 0;
}

UINT
APIENTRY
ODragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DragQueryFileW");
	return 0;
}

BOOL
WINAPI
ODrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DrawStateW");
	return 0;
}

BOOL
WINAPI
OEndUpdateResourceW(
	HANDLE      hUpdate,
	BOOL        fDiscard
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EndUpdateResourceW");
	return 0;
}

BOOL
WINAPI
OEnumCalendarInfoW(
	CALINFO_ENUMPROCW lpCalInfoEnumProc,
	LCID              Locale,
	CALID             Calendar,
	CALTYPE           CalType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumCalendarInfoW");
	return 0;
}

BOOL
WINAPI
OEnumDateFormatsW(
	DATEFMT_ENUMPROCW lpDateFmtEnumProc,
	LCID              Locale,
	DWORD             dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDateFormatsW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OEnumDependentServicesW(
	SC_HANDLE               hService,
	DWORD                   dwServiceState,
	LPENUM_SERVICE_STATUSW  lpServices,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded,
	LPDWORD                 lpServicesReturned
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDependentServicesW");
	return 0;
}
#endif

BOOL
WINAPI
OEnumDesktopsW(
	HWINSTA hwinsta,
	DESKTOPENUMPROCW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDesktopsW");
	return 0;
}

BOOL
WINAPI
OEnumDisplaySettingsW(
	LPCWSTR lpszDeviceName,
	DWORD iModeNum,
	LPDEVMODEW lpDevMode)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDisplaySettingsW");
	return 0;
}

int
WINAPI
OEnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontFamiliesW");
	return 0;
}

int
WINAPI
OEnumFontFamiliesExW(HDC, LPLOGFONTW,FONTENUMPROCW, LPARAM,DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontFamiliesExW");
	return 0;
}

int
WINAPI
OEnumFontsW(HDC, LPCWSTR,  FONTENUMPROCW, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontsW");
	return 0;
}

BOOL
WINAPI
OEnumFormsW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pForm,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFormsW");
	return 0;
}

WINAPI
OEnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumICMProfilesW");
	return 0;
}

BOOL
WINAPI
OEnumJobsW(
	HANDLE  hPrinter,
	DWORD   FirstJob,
	DWORD   NoJobs,
	DWORD   Level,
	LPBYTE  pJob,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumJobsW");
	return 0;
}

BOOL
WINAPI
OEnumMonitorsW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pMonitors,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumMonitorsW");
	return 0;
}

BOOL
WINAPI
OEnumPortsW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pPorts,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPortsW");
	return 0;
}

BOOL
WINAPI
OEnumPrinterDriversW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrinterDriversW");
	return 0;
}

BOOL
WINAPI
OEnumPrintersW(
	DWORD   Flags,
	LPWSTR   Name,
	DWORD   Level,
	LPBYTE  pPrinterEnum,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintersW");
	return 0;
}

BOOL
WINAPI
OEnumPrintProcessorDatatypesW(
	LPWSTR   pName,
	LPWSTR   pPrintProcessorName,
	DWORD   Level,
	LPBYTE  pDatatypes,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintProcessorDatatypesW");
	return 0;
}

BOOL
WINAPI
OEnumPrintProcessorsW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pPrintProcessorInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintProcessorsW");
	return 0;
}

int
WINAPI
OEnumPropsW(
	HWND hWnd,
	PROPENUMPROCW lpEnumFunc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPropsW");
	return 0;
}

int
WINAPI
OEnumPropsExW(
	HWND hWnd,
	PROPENUMPROCEXW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPropsExW");
	return 0;
}

INT
APIENTRY
OEnumProtocolsW (
	IN     LPINT           lpiProtocols,
	IN OUT LPVOID          lpProtocolBuffer,
	IN OUT LPDWORD         lpdwBufferLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumProtocolsW");
	return 0;
}

BOOL
WINAPI
OEnumResourceLanguagesW(
	HMODULE hModule,
	LPCWSTR lpType,
	LPCWSTR lpName,
	ENUMRESLANGPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceLanguagesW");
	return 0;
}

BOOL
WINAPI
OEnumResourceNamesW(
	HMODULE hModule,
	LPCWSTR lpType,
	ENUMRESNAMEPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceNamesW");
	return 0;
}

BOOL
WINAPI
OEnumResourceTypesW(
	HMODULE hModule,
	ENUMRESTYPEPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceTypesW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OEnumServicesStatusW(
	SC_HANDLE               hSCManager,
	DWORD                   dwServiceType,
	DWORD                   dwServiceState,
	LPENUM_SERVICE_STATUSW  lpServices,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded,
	LPDWORD                 lpServicesReturned,
	LPDWORD                 lpResumeHandle
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumServicesStatusW");
	return 0;
}
#endif

BOOL
WINAPI
OEnumSystemCodePagesW(
	CODEPAGE_ENUMPROCW lpCodePageEnumProc,
	DWORD              dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumSystemCodePagesW");
	return 0;
}

BOOL
WINAPI
OEnumSystemLocalesW(
	LOCALE_ENUMPROCW lpLocaleEnumProc,
	DWORD            dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumSystemLocalesW");
	return 0;
}

BOOL
WINAPI
OEnumTimeFormatsW(
	TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
	LCID              Locale,
	DWORD             dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumTimeFormatsW");
	return 0;
}

BOOL
WINAPI
OEnumWindowStationsW(
	WINSTAENUMPROCW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumWindowStationsW");
	return 0;
}

HICON
APIENTRY
OExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractAssociatedIconW");
	return 0;
}

HICON
APIENTRY
OExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractIconW");
	return 0;
}


UINT
WINAPI
OExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractIconExW");
	return 0;
}

// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*
BOOL
WINAPI
OExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtTextOutW");
	return 0;
}
*/

BOOL
WINAPI
OFillConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	WCHAR  cCharacter,
	DWORD  nLength,
	COORD  dwWriteCoord,
	LPDWORD lpNumberOfCharsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FillConsoleOutputCharacterW");
	return 0;
}

LPWSTR
APIENTRY
OFindEnvironmentStringW(LPWSTR szEnvVar)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindEnvironmentStringW");
	return 0;
}

HINSTANCE
APIENTRY
OFindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindExecutableW");
	return 0;
}

HRSRC
WINAPI
OFindResourceExW(
	HMODULE hModule,
	LPCWSTR lpType,
	LPCWSTR lpName,
	WORD    wLanguage
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindResourceExW");
	return 0;
}

APIENTRY
OFindTextW(LPFINDREPLACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindTextW");
	return 0;
}

HWND
WINAPI
OFindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindWindowExW");
	return 0;
}

int
WINAPI
OFoldStringW(
	DWORD    dwMapFlags,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWSTR  lpDestStr,
	int      cchDest)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FoldStringW");
	return 0;
}

BOOL
WINAPI
OGetBinaryTypeW(
	LPCWSTR lpApplicationName,
	LPDWORD lpBinaryType
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetBinaryTypeW");
	return 0;
}

DWORD
WINAPI
OGetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCharacterPlacementW");
	return 0;
}

BOOL
WINAPI
OGetCharWidth32W(HDC, UINT, UINT, LPINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCharWidth32W");
	return 0;
}

LPWSTR
WINAPI
OGetCommandLineW(
	VOID
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCommandLineW");
	return 0;
}

DWORD
WINAPI
OGetCompressedFileSizeW(
	LPCWSTR lpFileName,
	LPDWORD lpFileSizeHigh
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCompressedFileSizeW");
	return 0;
}

BOOL
WINAPI
OGetComputerNameW (
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetComputerNameW");
	return 0;
}

DWORD
WINAPI
OGetConsoleTitleW(
	LPWSTR lpConsoleTitle,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetConsoleTitleW");
	return 0;
}

int
WINAPI
OGetCurrencyFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	LPCWSTR lpValue,
	CONST CURRENCYFMTW *lpFormat,
	LPWSTR  lpCurrencyStr,
	int      cchCurrency)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCurrencyFormatW");
	return 0;
}

int
WINAPI
OGetDateFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	CONST SYSTEMTIME *lpDate,
	LPCWSTR lpFormat,
	LPWSTR  lpDateStr,
	int      cchDate)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDateFormatW");
	return 0;
}

BOOL
WINAPI
OGetDefaultCommConfigW(
	LPCWSTR lpszName,
	LPCOMMCONFIG lpCC,
	LPDWORD lpdwSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDefaultCommConfigW");
	return 0;
}

BOOL
WINAPI
OGetDiskFreeSpaceW(
	LPCWSTR lpRootPathName,
	LPDWORD lpSectorsPerCluster,
	LPDWORD lpBytesPerSector,
	LPDWORD lpNumberOfFreeClusters,
	LPDWORD lpTotalNumberOfClusters
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDiskFreeSpaceW");
	return 0;
}

UINT
WINAPI
OGetDriveTypeW(
	LPCWSTR lpRootPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDriveTypeW");
	return 0;
}

HENHMETAFILE
WINAPI
OGetEnhMetaFileW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnhMetaFileW");
	return 0;
}

UINT
WINAPI
OGetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnhMetaFileDescriptionW");
	return 0;
}

DWORD
WINAPI
OGetEnvironmentVariableW(
	LPCWSTR lpName,
	LPWSTR lpBuffer,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnvironmentVariableW");
	return 0;
}

INT
APIENTRY
OGetExpandedNameW(
	LPWSTR,
	LPWSTR
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetExpandedNameW");
	return 0;
}

BOOL
WINAPI
OGetFileSecurityW (
	LPCWSTR lpFileName,
	SECURITY_INFORMATION RequestedInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	DWORD nLength,
	LPDWORD lpnLengthNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileSecurityW");
	return 0;
}

short
WINAPI
OGetFileTitleW
(
LPCWSTR pwszFile,
LPWSTR pwszOut,
WORD w
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileTitleW");
	return 0;
}

BOOL
WINAPI
OGetFileVersionInfoW(
	LPWSTR lpszFile,
	DWORD dwHandle,
	DWORD cbBuf,
	LPVOID lpvData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileVersionInfoW");
	return 0;
}

DWORD
WINAPI
OGetFileVersionInfoSizeW(
	LPWSTR lpszFile,
	LPDWORD lpdwHandle)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileVersionInfoSizeW");
	return 0;
}

BOOL
WINAPI
OGetFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName,
	DWORD   Level,
	LPBYTE  pForm,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFormW");
	return 0;
}

WINAPI OGetICMProfileW(HDC,LPDWORD,LPWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetICMProfileW");
	return 0;
}

BOOL
WINAPI
OGetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetJobW");
	return 0;
}

BOOL
WINAPI
OGetKeyboardLayoutNameW(
	LPWSTR pwszKLID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetKeyboardLayoutNameW");
	return 0;
}

WINAPI OGetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetLogColorSpaceW");
	return 0;
}

DWORD
WINAPI
OGetLogicalDriveStringsW(
	DWORD nBufferLength,
	LPWSTR lpBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetLogicalDriveStringsW");
	return 0;
}

BOOL
WINAPI
OGetMenuItemInfoW(
	HMENU,
	UINT,
	BOOL,
	LPMENUITEMINFOW
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuItemInfoW");
	return 0;
}

HMETAFILE   WINAPI OGetMetaFileW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMetaFileW");
	return 0;
}

INT
APIENTRY
OGetNameByTypeW (
	IN     LPGUID          lpServiceType,
	IN OUT LPWSTR         lpServiceName,
	IN     DWORD           dwNameLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNameByTypeW");
	return 0;
}

BOOL
WINAPI
OGetNamedPipeHandleStateW(
	HANDLE hNamedPipe,
	LPDWORD lpState,
	LPDWORD lpCurInstances,
	LPDWORD lpMaxCollectionCount,
	LPDWORD lpCollectDataTimeout,
	LPWSTR lpUserName,
	DWORD nMaxUserNameSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNamedPipeHandleStateW");
	return 0;
}

int
WINAPI
OGetNumberFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	LPCWSTR lpValue,
	CONST NUMBERFMTW *lpFormat,
	LPWSTR  lpNumberStr,
	int      cchNumber)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNumberFormatW");
	return 0;
}

BOOL
WINAPI
OGetPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pPrinter,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterW");
	return 0;
}

DWORD
WINAPI
OGetPrinterDataW(
	HANDLE   hPrinter,
	LPWSTR    pValueName,
	LPDWORD  pType,
	LPBYTE   pData,
	DWORD    nSize,
	LPDWORD  pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDataW");
	return 0;
}

BOOL
WINAPI
OGetPrinterDriverW(
	HANDLE  hPrinter,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDriverW");
	return 0;
}

BOOL
WINAPI
OGetPrinterDriverDirectoryW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverDirectory,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDriverDirectoryW");
	return 0;
}

BOOL
WINAPI
OGetPrintProcessorDirectoryW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pPrintProcessorInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrintProcessorDirectoryW");
	return 0;
}

DWORD
WINAPI
OGetPrivateProfileSectionW(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileSectionW");
	return 0;
}

DWORD
WINAPI
OGetPrivateProfileSectionNamesW(
	LPWSTR lpszReturnBuffer,
	DWORD nSize,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileSectionNamesW");
	return 0;
}

BOOL
WINAPI
OGetPrivateProfileStructW(
	LPCWSTR lpszSection,
	LPCWSTR lpszKey,
	LPVOID   lpStruct,
	UINT     uSizeStruct,
	LPCWSTR szFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileStructW");
	return 0;
}

DWORD
WINAPI
OGetProfileSectionW(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetProfileSectionW");
	return 0;
}

DWORD
WINAPI
OGetProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpDefault,
	LPWSTR lpReturnedString,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetProfileStringW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OGetServiceDisplayNameW(
	SC_HANDLE               hSCManager,
	LPCWSTR                lpServiceName,
	LPWSTR                 lpDisplayName,
	LPDWORD                 lpcchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetServiceDisplayNameW");
	return 0;
}

BOOL
WINAPI
OGetServiceKeyNameW(
	SC_HANDLE               hSCManager,
	LPCWSTR                lpDisplayName,
	LPWSTR                 lpServiceName,
	LPDWORD                 lpcchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetServiceKeyNameW");
	return 0;
}
#endif

DWORD
WINAPI
OGetShortPathNameW(
	LPCWSTR lpszLongPath,
	LPWSTR  lpszShortPath,
	DWORD    cchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetShortPathNameW");
	return 0;
}

VOID
WINAPI
OGetStartupInfoW(
	LPSTARTUPINFOW lpStartupInfo
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetStartupInfoW");
	return;
}

BOOL
WINAPI
OGetStringTypeExW(
	LCID     Locale,
	DWORD    dwInfoType,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWORD   lpCharType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetStringTypeExW");
	return 0;
}

UINT
WINAPI
OGetSystemDirectoryW(
	LPWSTR lpBuffer,
	UINT uSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetSystemDirectoryW");
	return 0;
}

int
WINAPI
OGetTimeFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	CONST SYSTEMTIME *lpTime,
	LPCWSTR lpFormat,
	LPWSTR  lpTimeStr,
	int      cchTime)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetTimeFormatW");
	return 0;
}

INT
APIENTRY
OGetTypeByNameW (
	IN     LPWSTR         lpServiceName,
	IN OUT LPGUID          lpServiceType
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetTypeByNameW");
	return 0;
}

BOOL
WINAPI
OGetUserObjectInformationW(
	HANDLE hObj,
	int nIndex,
	PVOID pvInfo,
	DWORD nLength,
	LPDWORD lpnLengthNeeded)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetUserObjectInformationW");
	return 0;
}

UINT
WINAPI
OGetWindowsDirectoryW(
	LPWSTR lpBuffer,
	UINT uSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetWindowsDirectoryW");
	return 0;
}

ATOM
WINAPI
OGlobalFindAtomW(
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GlobalFindAtomW");
	return 0;
}

RPC_STATUS RPC_ENTRY
OI_RpcServerUnregisterEndpointW (
	IN unsigned short * Protseq,
	IN unsigned short * Endpoint
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - I_RpcServerUnregisterEndpointW");
	return 0;
}

HIMAGELIST
WINAPI
OImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImageList_LoadImageW");
	return 0;
}

WINAPI
OImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmConfigureIMEW");
	return 0;
}

WINAPI
OImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmEnumRegisterWordW");
	return 0;
}

WINAPI
OImmEscapeW(HKL, HIMC, UINT, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmEscapeW");
	return 0;
}

WINAPI
OImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCandidateListW");
	return 0;
}

WINAPI
OImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCandidateListCountW");
	return 0;
}

WINAPI
OImmGetCompositionFontW(HIMC, LPLOGFONTW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCompositionFontW");
	return 0;
}

WINAPI
OImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCompositionStringW");
	return 0;
}

WINAPI
OImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetConversionListW");
	return 0;
}

WINAPI
OImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetDescriptionW");
	return 0;
}

WINAPI
OImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetGuideLineW");
	return 0;
}

WINAPI
OImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetIMEFileNameW");
	return 0;
}

WINAPI
OImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetRegisterWordStyleW");
	return 0;
}

WINAPI
OImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmInstallIMEW");
	return 0;
}

WINAPI
OImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmIsUIMessageW");
	return 0;
}

WINAPI
OImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmRegisterWordW");
	return 0;
}

WINAPI
OImmSetCompositionFontW(HIMC, LPLOGFONTW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmSetCompositionFontW");
	return 0;
}

WINAPI
OImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmSetCompositionStringW");
	return 0;
}

WINAPI
OImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmUnregisterWordW");
	return 0;
}

BOOL
APIENTRY
OInitiateSystemShutdownW(
	LPWSTR lpMachineName,
	LPWSTR lpMessage,
	DWORD dwTimeout,
	BOOL bForceAppsClosed,
	BOOL bRebootAfterShutdown
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - InitiateSystemShutdownW");
	return 0;
}

BOOL
WINAPI
OInsertMenuItemW(
	HMENU,
	UINT,
	BOOL,
	LPCMENUITEMINFOW
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - InsertMenuItemW");
	return 0;
}

BOOL
WINAPI
OIsCharLowerW(
	WCHAR ch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - IsCharLowerW");
	return 0;
}

BOOL
WINAPI
OIsCharUpperW(
	WCHAR ch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - IsCharUpperW");
	return 0;
}

MMRESULT
WINAPI
OjoyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - joyGetDevCapsW");
	return 0;
}

HCURSOR
WINAPI
OLoadCursorFromFileW(
	LPCWSTR    lpFileName)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LoadCursorFromFileW");
	return 0;
}

HKL
WINAPI
OLoadKeyboardLayoutW(
	LPCWSTR pwszKLID,
	UINT Flags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LoadKeyboardLayoutW");
	return 0;
}

BOOL
WINAPI
OLogonUserW (
	LPWSTR lpszUsername,
	LPWSTR lpszDomain,
	LPWSTR lpszPassword,
	DWORD dwLogonType,
	DWORD dwLogonProvider,
	PHANDLE phToken
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LogonUserW");
	return 0;
}

INT
APIENTRY
OLZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LZOpenFileW");
	return 0;
}

UINT
WINAPI
OMapVirtualKeyExW(
	UINT uCode,
	UINT uMapType,
	HKL dwhkl)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MapVirtualKeyExW");
	return 0;
}

HRESULT
WINAPI
OMIMEAssociationDialogW(HWND hwndParent,
									   DWORD dwInFlags,
									   PCWSTR pcszFile,
									   PCWSTR pcszMIMEContentType,
									   PWSTR pszAppBuf,
									   UINT ucAppBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MIMEAssociationDialogW");
	return 0;
}

DWORD
APIENTRY
OMultinetGetConnectionPerformanceW(
		LPNETRESOURCEW lpNetResource,
		LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MultinetGetConnectionPerformanceW");
	return 0;
}

BOOL
WINAPI
OObjectCloseAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	BOOL GenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectCloseAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OObjectOpenAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	LPWSTR ObjectTypeName,
	LPWSTR ObjectName,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	HANDLE ClientToken,
	DWORD DesiredAccess,
	DWORD GrantedAccess,
	PPRIVILEGE_SET Privileges,
	BOOL ObjectCreation,
	BOOL AccessGranted,
	LPBOOL GenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectOpenAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OObjectPrivilegeAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	HANDLE ClientToken,
	DWORD DesiredAccess,
	PPRIVILEGE_SET Privileges,
	BOOL AccessGranted
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectPrivilegeAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OOemToCharBuffW(
	LPCSTR lpszSrc,
	LPWSTR lpszDst,
	DWORD cchDstLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OemToCharBuffW");
	return 0;
}

HANDLE
WINAPI
OOpenBackupEventLogW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenBackupEventLogW");
	return 0;
}

HDESK
WINAPI
OOpenDesktopW(
	LPWSTR lpszDesktop,
	DWORD dwFlags,
	BOOL fInherit,
	DWORD dwDesiredAccess)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenDesktopW");
	return 0;
}

HANDLE
WINAPI
OOpenEventW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenEventW");
	return 0;
}

HANDLE
WINAPI
OOpenEventLogW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpSourceName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenEventLogW");
	return 0;
}

HANDLE
WINAPI
OOpenFileMappingW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenFileMappingW");
	return 0;
}

HANDLE
WINAPI
OOpenMutexW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenMutexW");
	return 0;
}

BOOL
WINAPI
OOpenPrinterW(
	LPWSTR    pPrinterName,
	LPHANDLE phPrinter,
	LPPRINTER_DEFAULTSW pDefault
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenPrinterW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OOpenSCManagerW(
	LPCWSTR lpMachineName,
	LPCWSTR lpDatabaseName,
	DWORD   dwDesiredAccess
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenSCManagerW");
	return 0;
}
#endif

HANDLE
WINAPI
OOpenSemaphoreW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenSemaphoreW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OOpenServiceW(
	SC_HANDLE   hSCManager,
	LPCWSTR    lpServiceName,
	DWORD       dwDesiredAccess
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenServiceW");
	return 0;
}
#endif

HWINSTA
WINAPI
OOpenWindowStationW(
	LPWSTR lpszWinSta,
	BOOL fInherit,
	DWORD dwDesiredAccess)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenWindowStationW");
	return 0;
}

APIENTRY OPageSetupDlgW( LPPAGESETUPDLGW )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PageSetupDlgW");
	return 0;
}

BOOL
WINAPI
OPeekConsoleInputW(
	HANDLE hConsoleInput,
	PINPUT_RECORD lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PeekConsoleInputW");
	return 0;
}

BOOL
WINAPI
OPolyTextOutW(HDC, CONST POLYTEXTW *, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PolyTextOutW");
	return 0;
}

APIENTRY
OPrintDlgW(LPPRINTDLGW lppd)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrintDlgW");
	return 0;
}

DWORD
WINAPI
OPrinterMessageBoxW(
	HANDLE  hPrinter,
	DWORD   Error,
	HWND    hWnd,
	LPWSTR   pText,
	LPWSTR   pCaption,
	DWORD   dwType
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrinterMessageBoxW");
	return 0;
}

BOOL
WINAPI
OPrivilegedServiceAuditAlarmW (
	LPCWSTR SubsystemName,
	LPCWSTR ServiceName,
	HANDLE ClientToken,
	PPRIVILEGE_SET Privileges,
	BOOL AccessGranted
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrivilegedServiceAuditAlarmW");
	return 0;
}

int
WINAPI
OPropertySheetW(
	LPCPROPSHEETHEADERW lpcpsh
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PropertySheetW");
	return 0;
}

DWORD
WINAPI
OQueryDosDeviceW(
	LPCWSTR lpDeviceName,
	LPWSTR lpTargetPath,
	DWORD ucchMax
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryDosDeviceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OQueryServiceConfigW(
	SC_HANDLE               hService,
	LPQUERY_SERVICE_CONFIGW lpServiceConfig,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryServiceConfigW");
	return 0;
}

BOOL
WINAPI
OQueryServiceLockStatusW(
	SC_HANDLE                       hSCManager,
	LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
	DWORD                           cbBufSize,
	LPDWORD                         pcbBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryServiceLockStatusW");
	return 0;
}
#endif

BOOL
WINAPI
OReadConsoleW(
	HANDLE hConsoleInput,
	LPVOID lpBuffer,
	DWORD nNumberOfCharsToRead,
	LPDWORD lpNumberOfCharsRead,
	LPVOID lpReserved
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleW");
	return 0;
}

BOOL
WINAPI
OReadConsoleInputW(
	HANDLE hConsoleInput,
	PINPUT_RECORD lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleInputW");
	return 0;
}

BOOL
WINAPI
OReadConsoleOutputW(
	HANDLE hConsoleOutput,
	PCHAR_INFO lpBuffer,
	COORD dwBufferSize,
	COORD dwBufferCoord,
	PSMALL_RECT lpReadRegion
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleOutputW");
	return 0;
}

BOOL
WINAPI
OReadConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	LPWSTR lpCharacter,
	DWORD nLength,
	COORD dwReadCoord,
	LPDWORD lpNumberOfCharsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleOutputCharacterW");
	return 0;
}

BOOL
WINAPI
OReadEventLogW (
	 HANDLE     hEventLog,
	 DWORD      dwReadFlags,
	 DWORD      dwRecordOffset,
	 LPVOID     lpBuffer,
	 DWORD      nNumberOfBytesToRead,
	 DWORD      *pnBytesRead,
	 DWORD      *pnMinNumberOfBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadEventLogW");
	return 0;
}

LONG
APIENTRY
ORegConnectRegistryW (
	LPWSTR lpMachineName,
	HKEY hKey,
	PHKEY phkResult
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegConnectRegistryW");
	return 0;
}

HANDLE
WINAPI
ORegisterEventSourceW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpSourceName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegisterEventSourceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SERVICE_STATUS_HANDLE
WINAPI
ORegisterServiceCtrlHandlerW(
	LPCWSTR             lpServiceName,
	LPHANDLER_FUNCTION   lpHandlerProc
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegisterServiceCtrlHandlerW");
	return 0;
}
#endif

LONG
APIENTRY
ORegLoadKeyW (
	HKEY    hKey,
	LPCWSTR  lpSubKey,
	LPCWSTR  lpFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegLoadKeyW");
	return 0;
}

LONG
APIENTRY
ORegQueryMultipleValuesW (
	HKEY hKey,
	PVALENTW val_list,
	DWORD num_vals,
	LPWSTR lpValueBuf,
	LPDWORD ldwTotsize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegQueryMultipleValuesW");
	return 0;
}

LONG
APIENTRY
ORegReplaceKeyW (
	HKEY     hKey,
	LPCWSTR  lpSubKey,
	LPCWSTR  lpNewFile,
	LPCWSTR  lpOldFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegReplaceKeyW");
	return 0;
}

LONG
APIENTRY
ORegRestoreKeyW (
	HKEY hKey,
	LPCWSTR lpFile,
	DWORD   dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegRestoreKeyW");
	return 0;
}

LONG
APIENTRY
ORegSaveKeyW (
	HKEY hKey,
	LPCWSTR lpFile,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegSaveKeyW");
	return 0;
}

LONG
APIENTRY
ORegUnLoadKeyW (
	HKEY    hKey,
	LPCWSTR lpSubKey
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegUnLoadKeyW");
	return 0;
}

BOOL
WINAPI
ORemoveDirectoryW(
	LPCWSTR lpPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RemoveDirectoryW");
	return 0;
}

BOOL
WINAPI
ORemoveFontResourceW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RemoveFontResourceW");
	return 0;
}

APIENTRY
OReplaceTextW(LPFINDREPLACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReplaceTextW");
	return 0;
}

BOOL
WINAPI
OReportEventW (
	 HANDLE     hEventLog,
	 WORD       wType,
	 WORD       wCategory,
	 DWORD      dwEventID,
	 PSID       lpUserSid,
	 WORD       wNumStrings,
	 DWORD      dwDataSize,
	 LPCWSTR   *lpStrings,
	 LPVOID     lpRawData
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReportEventW");
	return 0;
}

HDC
WINAPI
OResetDCW(
	HDC hdc,
	CONST DEVMODEW *lpInitData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ResetDCW");
	return 0;
}

BOOL
WINAPI
OResetPrinterW(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ResetPrinterW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingFromStringBindingW (
	IN unsigned short __RPC_FAR * StringBinding,
	OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingFromStringBindingW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingInqAuthClientW (
	IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
	OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingInqAuthClientW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingToStringBindingW (
	IN RPC_BINDING_HANDLE Binding,
	OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingToStringBindingW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcEpRegisterNoReplaceW (
	IN RPC_IF_HANDLE IfSpec,
	IN RPC_BINDING_VECTOR * BindingVector,
	IN UUID_VECTOR * UuidVector OPTIONAL,
	IN unsigned short  * Annotation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcEpRegisterNoReplaceW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcMgmtEpEltInqNextW (
	IN RPC_EP_INQ_HANDLE InquiryContext,
	OUT RPC_IF_ID __RPC_FAR * IfId,
	OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
	OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcMgmtEpEltInqNextW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcMgmtInqServerPrincNameW (
	IN RPC_BINDING_HANDLE Binding,
	IN unsigned long AuthnSvc,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcMgmtInqServerPrincNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNetworkInqProtseqsW (
	OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNetworkInqProtseqsW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNetworkIsProtseqValidW (
	IN unsigned short __RPC_FAR * Protseq
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNetworkIsProtseqValidW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNsBindingInqEntryNameW (
	IN RPC_BINDING_HANDLE Binding,
	IN unsigned long EntryNameSyntax,
	OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNsBindingInqEntryNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcProtseqVectorFreeW (
	IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcProtseqVectorFreeW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerInqDefaultPrincNameW (
	IN unsigned long AuthnSvc,
	OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerInqDefaultPrincNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqEpW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN unsigned short __RPC_FAR * Endpoint,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqEpW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqIfW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN RPC_IF_HANDLE IfSpec,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqIfW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringBindingComposeW (
	IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
	IN unsigned short __RPC_FAR * Protseq OPTIONAL,
	IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
	IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
	IN unsigned short __RPC_FAR * Options OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringBindingComposeW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringBindingParseW (
	IN unsigned short __RPC_FAR * StringBinding,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringBindingParseW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringFreeW (
	IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringFreeW");
	return 0;
}

BOOL
WINAPI
OScrollConsoleScreenBufferW(
	HANDLE hConsoleOutput,
	CONST SMALL_RECT *lpScrollRectangle,
	CONST SMALL_RECT *lpClipRectangle,
	COORD dwDestinationOrigin,
	CONST CHAR_INFO *lpFill
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ScrollConsoleScreenBufferW");
	return 0;
}

DWORD
WINAPI
OSearchPathW(
	LPCWSTR lpPath,
	LPCWSTR lpFileName,
	LPCWSTR lpExtension,
	DWORD nBufferLength,
	LPWSTR lpBuffer,
	LPWSTR *lpFilePart
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SearchPathW");
	return 0;
}

BOOL
WINAPI
OSendMessageCallbackW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam,
	SENDASYNCPROC lpResultCallBack,
	DWORD dwData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SendMessageCallbackW");
	return 0;
}

LRESULT
WINAPI
OSendMessageTimeoutW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam,
	UINT fuFlags,
	UINT uTimeout,
	LPDWORD lpdwResult)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SendMessageTimeoutW");
	return 0;
}

BOOL
WINAPI
OSetComputerNameW (
	LPCWSTR lpComputerName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetComputerNameW");
	return 0;
}

BOOL
WINAPI
OSetConsoleTitleW(
	LPCWSTR lpConsoleTitle
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetConsoleTitleW");
	return 0;
}

BOOL
WINAPI
OSetCurrentDirectoryW(
	LPCWSTR lpPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetCurrentDirectoryW");
	return 0;
}

BOOL
WINAPI
OSetDefaultCommConfigW(
	LPCWSTR lpszName,
	LPCOMMCONFIG lpCC,
	DWORD dwSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetDefaultCommConfigW");
	return 0;
}

BOOL
WINAPI
OSetEnvironmentVariableW(
	LPCWSTR lpName,
	LPCWSTR lpValue
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetEnvironmentVariableW");
	return 0;
}

BOOL
WINAPI
OSetFileSecurityW (
	LPCWSTR lpFileName,
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetFileSecurityW");
	return 0;
}

BOOL
WINAPI
OSetFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName,
	DWORD   Level,
	LPBYTE  pForm
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetFormW");
	return 0;
}

WINAPI
OSetICMProfileW(HDC,LPWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetICMProfileW");
	return 0;
}

BOOL
WINAPI
OSetJobW(
	HANDLE  hPrinter,
	DWORD   JobId,
	DWORD   Level,
	LPBYTE  pJob,
	DWORD   Command
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetJobW");
	return 0;
}

BOOL
WINAPI
OSetPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pPrinter,
	DWORD   Command
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetPrinterW");
	return 0;
}

DWORD
WINAPI
OSetPrinterDataW(
	HANDLE  hPrinter,
	LPWSTR   pValueName,
	DWORD   Type,
	LPBYTE  pData,
	DWORD   cbData
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetPrinterDataW");
	return 0;
}

BOOL
WINAPI
OSetUserObjectInformationW(
	HANDLE hObj,
	int nIndex,
	PVOID pvInfo,
	DWORD nLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetUserObjectInformationW");
	return 0;
}

BOOL
WINAPI
OSetVolumeLabelW(
	LPCWSTR lpRootPathName,
	LPCWSTR lpVolumeName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetVolumeLabelW");
	return 0;
}

HHOOK
WINAPI
OSetWindowsHookW(
	int nFilterType,
	HOOKPROC pfnFilterProc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetWindowsHookW");
	return 0;
}

LPITEMIDLIST
WINAPI
OSHBrowseForFolderW(
	LPBROWSEINFO lpbi)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHBrowseForFolderW");
	return 0;
}

BOOL
WINAPI
OShell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - Shell_NotifyIconW");
	return 0;
}

INT
APIENTRY
OShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellAboutW");
	return 0;
}

HINSTANCE
APIENTRY
OShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellExecuteW");
	return 0;
}

BOOL
WINAPI
OShellExecuteExW(
	LPSHELLEXECUTEINFOW lpExecInfo)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellExecuteExW");
	return 0;
}


int
WINAPI
OSHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHFileOperationW");
	return 0;
}

DWORD
WINAPI
OSHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetFileInfoW");
	return 0;
}

BOOL
WINAPI
OSHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName,
							 BOOL FAR * pfMustCopy, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetNewLinkInfoW");
	return 0;
}

BOOL
WINAPI
OSHGetPathFromIDListW(
	LPCITEMIDLIST pidl,
	LPTSTR pszPath)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetPathFromIDListW");
	return 0;
}

BOOL
WINAPI
OsndPlaySoundW(LPCWSTR pszSound, UINT fuSound)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - sndPlaySoundW");
	return 0;
}

DWORD
WINAPI
OStartDocPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pDocInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartDocPrinterW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OStartServiceW(
	SC_HANDLE            hService,
	DWORD                dwNumServiceArgs,
	LPCWSTR             *lpServiceArgVectors
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartServiceW");
	return 0;
}

BOOL
WINAPI
OStartServiceCtrlDispatcherW(
	LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartServiceCtrlDispatcherW");
	return 0;
}
#endif

// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*
BOOL
WINAPI
OTextOutW(HDC, int, int, LPCWSTR, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - TextOutW");
	return 0;
}
*/

HRESULT
WINAPI
OTranslateURLW(PCWSTR pcszURL,
										 DWORD dwInFlags,
										 PWSTR *ppszTranslatedURL)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - TranslateURLW");
	return 0;
}

WINAPI
OUpdateICMRegKeyW(DWORD, DWORD, LPWSTR, UINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - UpdateICMRegKeyW");
	return 0;
}

HRESULT
WINAPI
OURLAssociationDialogW(HWND hwndParent,
												 DWORD dwInFlags,
												 PCWSTR pcszFile,
												 PCWSTR pcszURL,
												 PWSTR pszAppBuf,
												 UINT ucAppBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - URLAssociationDialogW");
	return 0;
}

/* client/server */
RPC_STATUS RPC_ENTRY
OUuidFromStringW (
	IN unsigned short __RPC_FAR * StringUuid,
	OUT UUID __RPC_FAR * Uuid
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - UuidFromStringW");
	return 0;
}

DWORD
APIENTRY
OVerFindFileW(
		DWORD uFlags,
		LPWSTR szFileName,
		LPWSTR szWinDir,
		LPWSTR szAppDir,
		LPWSTR szCurDir,
		PUINT lpuCurDirLen,
		LPWSTR szDestDir,
		PUINT lpuDestDirLen
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerFindFileW");
	return 0;
}

DWORD
APIENTRY
OVerInstallFileW(
		DWORD uFlags,
		LPWSTR szSrcFileName,
		LPWSTR szDestFileName,
		LPWSTR szSrcDir,
		LPWSTR szDestDir,
		LPWSTR szCurDir,
		LPWSTR szTmpFile,
		PUINT lpuTmpFileLen
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerInstallFileW");
	return 0;
}

DWORD
APIENTRY
OVerLanguageNameW(
		DWORD wLang,
		LPWSTR szLang,
		DWORD nSize
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerLanguageNameW");
	return 0;
}

BOOL
WINAPI
OVerQueryValueW(
	const LPVOID pBlock,
	LPWSTR lpSubBlock,
	LPVOID *lplpBuffer,
	PUINT puLerr)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerQueryValueW");
	return 0;
}

WINAPI
OVkKeyScanExW(
	WCHAR  ch,
	HKL   dwhkl)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VkKeyScanExW");
	return 0;
}

BOOL
WINAPI
OWaitNamedPipeW(
	LPCWSTR lpNamedPipeName,
	DWORD nTimeOut
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WaitNamedPipeW");
	return 0;
}

MMRESULT
WINAPI
OwaveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveInGetDevCapsW");
	return 0;
}

MMRESULT
WINAPI
OwaveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveInGetErrorTextW");
	return 0;
}

MMRESULT
WINAPI
OwaveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveOutGetDevCapsW");
	return 0;
}

MMRESULT
WINAPI
OwaveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveOutGetErrorTextW");
	return 0;
}

BOOL
WINAPI
OwglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wglUseFontBitmapsW");
	return 0;
}

BOOL
WINAPI
OwglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
										   FLOAT, int, LPGLYPHMETRICSFLOAT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wglUseFontOutlinesW");
	return 0;
}

void
WINAPI
OWinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WinExecErrorW");
	return;
}

DWORD
APIENTRY
OWNetAddConnectionW(
	 LPCWSTR   lpRemoteName,
	 LPCWSTR   lpPassword,
	 LPCWSTR   lpLocalName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetAddConnection2W(
	 LPNETRESOURCEW lpNetResource,
	 LPCWSTR       lpPassword,
	 LPCWSTR       lpUserName,
	 DWORD          dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnection2W");
	return 0;
}

DWORD
APIENTRY
OWNetAddConnection3W(
	 HWND           hwndOwner,
	 LPNETRESOURCEW lpNetResource,
	 LPCWSTR       lpPassword,
	 LPCWSTR       lpUserName,
	 DWORD          dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnection3W");
	return 0;
}

DWORD
APIENTRY
OWNetCancelConnectionW(
	 LPCWSTR lpName,
	 BOOL     fForce
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetCancelConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetCancelConnection2W(
	 LPCWSTR lpName,
	 DWORD    dwFlags,
	 BOOL     fForce
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetCancelConnection2W");
	return 0;
}

DWORD
APIENTRY
OWNetConnectionDialog1W(
	LPCONNECTDLGSTRUCTW lpConnDlgStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetConnectionDialog1W");
	return 0;
}

DWORD
APIENTRY
OWNetDisconnectDialog1W(
	LPDISCDLGSTRUCTW lpConnDlgStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetDisconnectDialog1W");
	return 0;
}

DWORD
APIENTRY
OWNetEnumResourceW(
	 HANDLE  hEnum,
	 LPDWORD lpcCount,
	 LPVOID  lpBuffer,
	 LPDWORD lpBufferSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetEnumResourceW");
	return 0;
}

DWORD
APIENTRY
OWNetGetConnectionW(
	 LPCWSTR lpLocalName,
	 LPWSTR  lpRemoteName,
	 LPDWORD  lpnLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetGetLastErrorW(
	 LPDWORD    lpError,
	 LPWSTR    lpErrorBuf,
	 DWORD      nErrorBufSize,
	 LPWSTR    lpNameBuf,
	 DWORD      nNameBufSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetLastErrorW");
	return 0;
}

DWORD
APIENTRY
OWNetGetNetworkInformationW(
	LPCWSTR          lpProvider,
	LPNETINFOSTRUCT   lpNetInfoStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetNetworkInformationW");
	return 0;
}

DWORD
APIENTRY
OWNetGetProviderNameW(
	DWORD   dwNetType,
	LPWSTR lpProviderName,
	LPDWORD lpBufferSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetProviderNameW");
	return 0;
}

DWORD
APIENTRY
OWNetGetUniversalNameW(
	 LPCWSTR lpLocalPath,
	 DWORD    dwInfoLevel,
	 LPVOID   lpBuffer,
	 LPDWORD  lpBufferSize
	 )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetUniversalNameW");
	return 0;
}

DWORD
APIENTRY
OWNetGetUserW(
	 LPCWSTR  lpName,
	 LPWSTR   lpUserName,
	 LPDWORD   lpnLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetUserW");
	return 0;
}

DWORD
APIENTRY
OWNetOpenEnumW(
	 DWORD          dwScope,
	 DWORD          dwType,
	 DWORD          dwUsage,
	 LPNETRESOURCEW lpNetResource,
	 LPHANDLE       lphEnum
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetOpenEnumW");
	return 0;
}

DWORD
APIENTRY
OWNetSetConnectionW(
	LPCWSTR    lpName,
	DWORD       dwProperties,
	LPVOID      pvValues
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetSetConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetUseConnectionW(
	HWND            hwndOwner,
	LPNETRESOURCEW  lpNetResource,
	LPCWSTR        lpUserID,
	LPCWSTR        lpPassword,
	DWORD           dwFlags,
	LPWSTR         lpAccessName,
	LPDWORD         lpBufferSize,
	LPDWORD         lpResult
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetUseConnectionW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleW(
	HANDLE hConsoleOutput,
	CONST VOID *lpBuffer,
	DWORD nNumberOfCharsToWrite,
	LPDWORD lpNumberOfCharsWritten,
	LPVOID lpReserved
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleInputW(
	HANDLE hConsoleInput,
	CONST INPUT_RECORD *lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleInputW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleOutputW(
	HANDLE hConsoleOutput,
	CONST CHAR_INFO *lpBuffer,
	COORD dwBufferSize,
	COORD dwBufferCoord,
	PSMALL_RECT lpWriteRegion
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleOutputW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	LPCWSTR lpCharacter,
	DWORD nLength,
	COORD dwWriteCoord,
	LPDWORD lpNumberOfCharsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleOutputCharacterW");
	return 0;
}

BOOL
WINAPI
OWritePrivateProfileSectionW(
	LPCWSTR lpAppName,
	LPCWSTR lpString,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WritePrivateProfileSectionW");
	return 0;
}

BOOL
WINAPI
OWritePrivateProfileStructW(
	LPCWSTR lpszSection,
	LPCWSTR lpszKey,
	LPVOID   lpStruct,
	UINT     uSizeStruct,
	LPCWSTR szFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WritePrivateProfileStructW");
	return 0;
}

BOOL
WINAPI
OWriteProfileSectionW(
	LPCWSTR lpAppName,
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteProfileSectionW");
	return 0;
}

BOOL
WINAPI
OWriteProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteProfileStringW");
	return 0;
}

int
WINAPI
OwvsprintfW(
	LPWSTR,
	LPCWSTR,
	va_list arglist)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wvsprintfW");
	return 0;
}

DWORD
WINAPI
ODdeQueryStringW(
	DWORD idInst,
	HSZ hsz,
	LPWSTR psz,
	DWORD cchMax,
	int iCodePage)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DdeQueryStringW");
	return 0;
}

int WINAPI
OGetClipboardFormatNameW(
	UINT format,
	LPWSTR pwsz,
	int cchMaxCount)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetClipboardFormatNameW");
	return 0;
}

int
WINAPI
OGetKeyNameTextW(
	LONG lParam,
	LPWSTR lpString,
	int nSize)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetKeyNameTextW");
	return 0;
}

int
WINAPI
OGetMenuStringW(
	HMENU hMenu,
	UINT uIDItem,
	LPWSTR lpString,
	int nMaxCount,
	UINT uFlag)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuStringW");
	return 0;
}

int
WINAPI
OGetTextFaceW(
	HDC    hdc,
	int    cch,
	LPWSTR lpFaceName)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuStringW");
	return 0;
}

#endif    //ifdef DEBUG

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\dispatch.cpp ===
/*

    File: Dispatch.cpp

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:
        Dispatch helpers.  stolen from HTMED tree

*/

#include "stdafx.h"

#include "resource.h"
#include "dispatch.h"

//#include "viewhdrs.h"

#define RETURN return
#define SetLastError(x,y) SetLastError(x)

HRESULT
CallDispatchMethod(
        IDispatch * pDisp,
        DISPID dispid,
        VARIANT * pvarFirst,
        char * pstrSig,
        va_list val)
{
    HRESULT     hr;
    int         c;
    int         i;
    VARIANT *   pvar;
    VARIANT *   pvarOut         = NULL;
    VARIANT     avar[10];
    VARIANT     varOut;
    void *      pvOut = NULL;
    DISPPARAMS  dp;
    EXCEPINFO   ei;
    UINT        uArgErr;

    _ASSERTE(pDisp);

    VariantInit(&varOut);

    if (pstrSig)
    {
        c = strlen(pstrSig);
        //_ASSERTE(c > 0);
        //_ASSERTE(c <= DIM(avar));

        if (pstrSig[c - 1] & VTS_RETURN_FLAG)
        {
            pvarOut = &varOut;
            c--;
        }

        for (i = 0, pvar = avar + c - 1; i < c; i++, pvar--)
        {
            pvar->vt = pstrSig[i];
            switch (pstrSig[i])
            {
            case VT_I2:
                pvar->iVal = va_arg(val, short);
                break;

            case VT_I4:
                pvar->lVal = va_arg(val, long);
                break;

            case VT_BSTR:
                pvar->bstrVal = va_arg(val, BSTR);
                break;

            case VT_DISPATCH:
                pvar->pdispVal = va_arg(val, IDispatch *);
                break;

            case VT_UNKNOWN:
                pvar->punkVal = va_arg(val, IUnknown *);
                break;

            case VT_BOOL:
                pvar->boolVal = va_arg(val, VARIANT_BOOL);
                break;

            case VT_BSTR | VTS_BYREF_FLAG:
            case VT_DISPATCH | VTS_BYREF_FLAG:
            case VT_UNKNOWN | VTS_BYREF_FLAG:
                pvar->vt = (VARTYPE)((pstrSig[i] & (VTS_BYREF_FLAG - 1)) | VT_BYREF);
                pvar->ppdispVal = va_arg(val, IDispatch **);

                // Passing an uninitialized BSTR or object will crash when the callee
                // frees the existing value as it's supposed to.
                // This has been a common source of hard-to-find bugs, but
                // this _ASSERTE can be removed if we need to pass an in/out string.
                _ASSERTE(*pvar->ppdispVal == NULL);
                break;

            case VT_I2 | VTS_BYREF_FLAG:
            case VT_I4 | VTS_BYREF_FLAG:
            case VT_BOOL | VTS_BYREF_FLAG:
            case VT_VARIANT | VTS_BYREF_FLAG:
                pvar->vt = (VARTYPE)((pstrSig[i] & (VTS_BYREF_FLAG - 1)) | VT_BYREF);
                pvar->ppdispVal = va_arg(val, IDispatch **);
                break;

            default:
                _ASSERTE(FALSE && "Unsupported variant type");
                break;
            }
        }

        if (pvarOut)
        {
            pvOut = va_arg(val, void *);
        }
    }
    else
    {
        c = 0;
    }

    if (pvarFirst)
    {
    //  _ASSERTE(c >= 0);
    //  _ASSERTE(c < DIM(avar));
        avar[c++] = *pvarFirst;
    }

    dp.rgvarg = avar;
    dp.cArgs = c;
    dp.rgdispidNamedArgs = NULL;
    dp.cNamedArgs = 0;

    memset(&ei, 0, sizeof (ei));

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            LOCALE_SYSTEM_DEFAULT,
            DISPATCH_METHOD,
            &dp,
            pvarOut,
            &ei,
            &uArgErr);
    if (hr)
    {
        SetLastError(hr, &ei);
        goto Error;
    }

    //  If we're returning a value, coerce it to the correct
    //    type

    if (pvarOut)
    {
#pragma warning(disable: 4310) // cast truncates constant value
        hr = VariantChangeTypeEx(
                &varOut,
                &varOut,
                LOCALE_SYSTEM_DEFAULT,
                0,
                (VARTYPE)(pstrSig[c] & (char) ~VTS_RETURN_FLAG));
#pragma warning(default: 4310) // cast truncates constant value
        if (hr)
            goto Error;

#pragma warning(disable: 4310) // cast truncates constant value
        switch (pstrSig[c] & (char) ~VTS_RETURN_FLAG)
#pragma warning(default: 4310) // cast truncates constant value
        {
        case VT_I2:
            * (short *) pvOut = varOut.iVal;
            break;

        case VT_I4:
            * (long *) pvOut = varOut.lVal;
            break;

        case VT_BSTR:
            * (BSTR *) pvOut = varOut.bstrVal;
            break;

        case VT_DISPATCH:
            * (IDispatch **) pvOut = varOut.pdispVal;
            break;

        case VT_UNKNOWN:
            * (IUnknown **) pvOut = varOut.punkVal;
            break;

        case VT_BOOL:
            * (VARIANT_BOOL *) pvOut = varOut.boolVal;
            break;

        default:
            _ASSERTE(FALSE && "Unsupported type");
            break;
        }

        varOut.vt = VT_EMPTY;
    }

Error:
    VariantClear(&varOut);

    RETURN(hr);
}


HRESULT __cdecl
CallDispatchMethod(IDispatch * pDisp, DISPID dispid, char * pstrSig, ...)
{
    HRESULT     hr;
    va_list     val;

    va_start(val, pstrSig);

    hr = CallDispatchMethod(pDisp, dispid, NULL, pstrSig, val);

    va_end(val);

    return hr;
}


HRESULT
CallDispatchMethod(
        IDispatch * pDisp,
        WCHAR * pstrMethod,
        VARIANT * pvarFirst,
        char * pstrSig,
        va_list val)
{
    HRESULT     hr;
    DISPID      dispid;

    //  NOTE that depending on the dispatch implementation, this
    //    method call can fail with more than one error code
    //    (notably DISP_E_MEMBERNOTFOUND and TYPE_E_ELEMENTNOTFOUND,
    //    including others).  Since we want to reliably detect a
    //    missing method, we map all errors to DISP_E_MEMBERNOTFOUND.

    hr = pDisp->GetIDsOfNames(
            IID_NULL,
            &pstrMethod,
            1,
            LOCALE_SYSTEM_DEFAULT,
            &dispid);
    if (hr)
    {
#if DBG == 1
        switch (hr)
        {
        case DISP_E_MEMBERNOTFOUND:
        case DISP_E_UNKNOWNNAME:
        case TYPE_E_ELEMENTNOTFOUND:
        case E_NOTIMPL:
        case RPC_E_SERVER_DIED:
            break;

        default:
            _ASSERTE(FALSE && "Unexpected error code from GetIDsOfNames.");
            break;
        }
#endif

        hr = DISP_E_MEMBERNOTFOUND;
        goto Error;
    }

    hr = CallDispatchMethod(pDisp, dispid, pvarFirst, pstrSig, val);
    if (hr)
        goto Error;

Error:
    return hr;
}


HRESULT __cdecl
CallDispatchMethod(
        IDispatch * pDisp,
        WCHAR * pstrMethod,
        char * pstrSig,
        ...)
{
    HRESULT     hr;
    va_list     val;

    va_start(val, pstrSig);

    hr = CallDispatchMethod(pDisp, pstrMethod, NULL, pstrSig, val);

    va_end(val);

    return hr;
}


HRESULT __cdecl
CallDispatchMethod(
        IDispatch * pDisp,
        WCHAR * pstrMethod,
        VARIANT * pvarFirst,
        char * pstrSig,
        ...)
{
    HRESULT     hr;
    va_list     val;

    va_start(val, pstrSig);

    hr = CallDispatchMethod(pDisp, pstrMethod, pvarFirst, pstrSig, val);

    va_end(val);

    return hr;
}


HRESULT
GetDispatchProperty(
        IDispatch * pDisp,
        WCHAR * pstrProperty,
        VARENUM vt,
        void * pv)
{
    HRESULT     hr;
    DISPID      dispid;

    hr = pDisp->GetIDsOfNames(
            IID_NULL,
            &pstrProperty,
            1,
            LOCALE_SYSTEM_DEFAULT,
            &dispid);
    if (hr)
    {
#if DBG == 1
        switch (hr)
        {
        case DISP_E_MEMBERNOTFOUND:
        case DISP_E_UNKNOWNNAME:
        case TYPE_E_ELEMENTNOTFOUND:
        case E_NOTIMPL:
            break;

        default:
            _ASSERTE(FALSE && "Unexpected error code from GetIDsOfNames.");
            break;
        }
#endif

        RETURN(DISP_E_MEMBERNOTFOUND);
    }

    return GetDispatchProperty(pDisp, dispid, vt, pv);
}


HRESULT
GetDispatchProperty(
        IDispatch * pDisp,
        DISPID dispidProperty,
        VARENUM vt,
        void * pv)
{
    HRESULT         hr;
    VARIANT         var;
    DISPPARAMS      dp = { NULL, NULL, 0, 0 };
    EXCEPINFO       ei;
    UINT            uArgErr;

#if DBG == 1
    switch (vt)
    {
    case VT_I4:
    case VT_DISPATCH:
    case VT_UNKNOWN:
    case VT_BSTR:
        break;

    }
#endif

    VariantInit(&var);

    hr = pDisp->Invoke(
            dispidProperty,
            IID_NULL,
            LOCALE_SYSTEM_DEFAULT,
            DISPATCH_PROPERTYGET|DISPATCH_METHOD,
            &dp,
            &var,
            &ei,
            &uArgErr);
    if (hr)
        goto Error;

    if (vt != VT_VARIANT)
    {
        hr = VariantChangeTypeEx(
                &var,
                &var,
                LOCALE_SYSTEM_DEFAULT,
                0,
                (VARTYPE)vt);
        if (hr)
            goto Error;
    }

    switch (vt)
    {
    case VT_I2:
        * (short *) pv = var.iVal;
        break;

    case VT_I4:
        * (int *) pv = var.lVal;
        break;

    case VT_DISPATCH:
        * (IDispatch **) pv = var.pdispVal;
        break;

    case VT_UNKNOWN:
        * (IUnknown **) pv = var.punkVal;
        break;

    case VT_BSTR:
        * (BSTR *) pv = var.bstrVal;
        break;

    case VT_BOOL:
        * (VARIANT_BOOL *) pv = var.boolVal;
        break;
    case VT_VARIANT:
        VariantCopy( (VARIANT *) pv, &var);
        break;
    default:
        _ASSERTE(FALSE && "Unsupported type");
        break;
    }

Error:
    RETURN(hr);
}


HRESULT
PutDispatchProperty(
        IDispatch * pDisp,
        DISPID dispidProperty,
        VARENUM vt,
        va_list val)
{
    VARIANT         var;
    DISPPARAMS      dp;
    EXCEPINFO       ei;
    UINT            uArgErr;
    DISPID          dispidPropertyPut   = DISPID_PROPERTYPUT;

    var.vt = (VARTYPE)vt;
    switch (vt)
    {
    case VT_I2:
        var.iVal = va_arg(val, short);
        break;

    case VT_I4:
        var.lVal = va_arg(val, int);
        break;

    case VT_DISPATCH:
        var.pdispVal = va_arg(val, IDispatch *);
        break;

    case VT_UNKNOWN:
        var.punkVal = va_arg(val, IUnknown *);
        break;

    case VT_BSTR:
        var.bstrVal = va_arg(val, BSTR);
        break;

    case VT_BOOL:
        var.boolVal = va_arg(val, VARIANT_BOOL);
        break;
    case VT_VARIANT:
        VariantCopy(&var, &(va_arg(val, VARIANT)));
        break;
    default:
        _ASSERTE(FALSE && "Unsupported type");
        break;
    }

    dp.rgvarg = &var;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    dp.rgdispidNamedArgs = &dispidPropertyPut;

    RETURN(pDisp->Invoke(
            dispidProperty,
            IID_NULL,
            LOCALE_SYSTEM_DEFAULT,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            &ei,
            &uArgErr));
}


HRESULT
__cdecl
PutDispatchProperty(
        IDispatch * pDisp,
        DISPID dispidProperty,
        VARENUM vt,
        ...)
{
    HRESULT     hr;
    va_list     val;

    va_start(val, vt);

    hr = PutDispatchProperty(pDisp, dispidProperty, vt, val);

    va_end(val);

    RETURN(hr);
}


HRESULT
__cdecl
PutDispatchProperty(
        IDispatch * pDisp,
        WCHAR * pstrProperty,
        VARENUM vt,
        ...)
{
    HRESULT     hr;
    DISPID      dispid;
    va_list     val;

    hr = pDisp->GetIDsOfNames(
            IID_NULL,
            &pstrProperty,
            1,
            LOCALE_SYSTEM_DEFAULT,
            &dispid);
    if (hr)
    {
#if DBG == 1
        switch (hr)
        {
        case DISP_E_MEMBERNOTFOUND:
        case DISP_E_UNKNOWNNAME:
        case TYPE_E_ELEMENTNOTFOUND:
        case E_NOTIMPL:
            break;

        default:
            _ASSERTE(FALSE && "Unexpected error code from GetIDsOfNames.");
            break;
        }
#endif

        RETURN(DISP_E_MEMBERNOTFOUND);
    }

    va_start(val, vt);

    hr = PutDispatchProperty(pDisp, dispid, vt, val);

    va_end(val);

    RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\win95wrp.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __WIN95WRP_CPP__

#ifndef __WIN95WRP_H__
#define __WIN95WRP_H__

/* HACK! - wininet.h includes iedial.h, and iedial.h includes ocidl.h,
  and ocidl.h defines IProvideClassInfo::GetClassInfo.  If we did not
  pre-reroute GetClassInfoW, then what would happen is that
  ocidl would define
    IProvideClassInfo::GetClassInfo ->
    IProvideClassInfo::GetClassInfoW
  and then we would define GetClassInfoW to OGetClassInfoW, so when <atlcom.h>
  implements IProvideClassInfo, it declares
    IProvideClassInfo::GetClassInfo ->
    IProvideClassInfo::GetClassInfoW ->
    IProvideClassInfo::OGetClassInfoW
  which doesn't match the interface definition, so the compiler yells at us.
 */
#define GetClassInfoW OGetClassInfoW

#include <urlmon.h>
#include <wininet.h>

extern "C"{

BOOL WINAPI OAppendMenuW(HMENU hMenu, UINT uFlags, UINT uIDnewItem, LPCWSTR lpnewItem);
LRESULT WINAPI OCallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
DWORD WINAPI OCharLowerBuffW(LPWSTR lpsz, DWORD cchLength);
LPWSTR WINAPI OCharLowerW(LPWSTR lpsz);
LPWSTR WINAPI OCharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);
BOOL WINAPI OCharToOemW(LPCWSTR lpszSrc, LPSTR lpszDst);
LPWSTR WINAPI OCharUpperW(LPWSTR lpsz);
BOOL WINAPI OCopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
BOOL WINAPI OCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
HDC WINAPI OCreateDCW(LPCWSTR lpszDriver, LPCWSTR lpszDevice, LPCWSTR lpszOutput, CONST DEVMODEW *lpInitData);
BOOL WINAPI OCreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
HDC WINAPI OCreateEnhMetaFileW(HDC hdc, LPCWSTR lpFileName, CONST RECT *lpRect, LPCWSTR lpDescription);
HANDLE WINAPI OCreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
HANDLE WINAPI OCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
HFONT WINAPI OCreateFontIndirectW(CONST LOGFONTW * plfw);
HFONT OCreateFontW(int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline, DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision, DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCWSTR lpszFace);
HWND WINAPI OCreateMDIWindowW(LPWSTR lpClassName, LPWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);
HDC WINAPI OCreateMetaFileW(LPCWSTR lpstr);
HANDLE WINAPI OCreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
HWND WINAPI OCreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
HSZ WINAPI ODdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);
UINT WINAPI ODdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes);
LRESULT WINAPI ODefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ODefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ODefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI ODeleteFileW(LPCWSTR pwsz);
LRESULT WINAPI ODialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
LRESULT WINAPI ODialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
LRESULT WINAPI ODispatchMessageW(CONST MSG *lpMsg);
int WINAPI ODrawTextW(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);
int WINAPI ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);
DWORD WINAPI OExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
VOID WINAPI OFatalAppExitW(UINT uAction, LPCWSTR lpMessageText);
HANDLE WINAPI OFindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
HANDLE WINAPI OFindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
BOOL WINAPI OFindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
HRSRC WINAPI OFindResourceW(HINSTANCE hModule, LPCWSTR lpName, LPCWSTR lpType);
HWND WINAPI OFindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);
DWORD WINAPI OFormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
BOOL APIENTRY OGetCharABCWidthsFloatW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPABCFLOAT lpABC);
BOOL APIENTRY OGetCharABCWidthsW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPABC lpABC);
BOOL APIENTRY OGetCharWidthFloatW(HDC hdc, UINT iFirstChar, UINT iLastChar, PFLOAT pBuffer);
BOOL WINAPI OGetCharWidthW(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer);
BOOL WINAPI OGetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass);
BOOL WINAPI OGetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSEXW lpWndClass);
DWORD WINAPI OGetClassLongW(HWND hWnd, int nIndex);
DWORD WINAPI OSetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong);
int WINAPI OGetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);
DWORD WINAPI OGetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
UINT WINAPI OGetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int nMaxCount);
DWORD WINAPI OGetFileAttributesW(LPCWSTR lpFileName);
DWORD WINAPI OGetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
DWORD WINAPI OGetGlyphOutlineW(HDC hdc, UINT uChar, UINT uFormat, LPGLYPHMETRICS lpgm, DWORD cbBuffer, LPVOID lpvBuffer, CONST MAT2 *lpmat2);
DWORD WINAPI OGetKerningPairsW(HDC hdc, DWORD nNumPairs, LPKERNINGPAIR lpkrnpair);
BOOL WINAPI OGetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DWORD WINAPI OGetModuleFileNameW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize);
HMODULE WINAPI OGetModuleHandleW(LPCWSTR lpModuleName);
UINT APIENTRY OGetOutlineTextMetricsW(HDC hdc, UINT cbData, LPOUTLINETEXTMETRICW lpOTM);
UINT WINAPI OGetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
DWORD WINAPI OGetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
int WINAPI OGetObjectW(HGDIOBJ hgdiobj, int cbBuffer, LPVOID lpvObject);
BOOL WINAPI OGetOpenFileNameW(LPOPENFILENAMEW lpofn);
UINT WINAPI OGetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);
HANDLE WINAPI OGetPropW(HWND hWnd, LPCWSTR lpString);
BOOL WINAPI OGetSaveFileNameW(LPOPENFILENAMEW lpofn);
DWORD WINAPI OGetTabbedTextExtentW(HDC hDC, LPCWSTR lpString, int nCount, int nTabPositions, LPINT lpnTabStopPositions);
UINT WINAPI OGetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
DWORD WINAPI OGetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
BOOL APIENTRY OGetTextExtentPoint32W(HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize);
BOOL APIENTRY OGetTextExtentPointW(HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize);
BOOL APIENTRY OGetTextExtentExPointW(HDC hdc, LPCWSTR lpszStr, int cchString, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE pSize);
LONG WINAPI OGetWindowLongW(HWND hWnd, int nIndex);
BOOL WINAPI OGetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);
BOOL WINAPI OGetUserNameW(LPWSTR lpBuffer, LPDWORD nSize);
BOOL WINAPI OGetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
int WINAPI OGetWindowTextLengthW(HWND hWnd);
int WINAPI OGetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
ATOM WINAPI OGlobalAddAtomW(LPCWSTR lpString);
UINT WINAPI OGlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
BOOL WINAPI OGrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
BOOL WINAPI OInsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem);
BOOL WINAPI OIsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);
BOOL WINAPI OIsCharAlphaNumericW(WCHAR wch);
BOOL WINAPI OIsCharAlphaW(WCHAR wch);
BOOL WINAPI OIsDialogMessageW(HWND hDlg, LPMSG lpMsg);
int WINAPI OLCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
HACCEL WINAPI OLoadAcceleratorsW(HINSTANCE hInst, LPCWSTR lpTableName);
HBITMAP WINAPI OLoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);
HCURSOR WINAPI OLoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
HICON WINAPI OLoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
HINSTANCE WINAPI OLoadLibraryW(LPCWSTR pwszFileName);
HMODULE WINAPI OLoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
HMENU WINAPI OLoadMenuIndirectW(CONST MENUTEMPLATEW *lpMenuTemplate);
HMENU WINAPI OLoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);
int WINAPI OLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax);
LPWSTR WINAPI OlstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
int WINAPI OlstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
int WINAPI OlstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR WINAPI OlstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
LPWSTR WINAPI OlstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
int WINAPI OlstrlenW(LPCWSTR lpString);
UINT WINAPI OMapVirtualKeyW(UINT uCode, UINT uMapType);
int WINAPI OMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
int WINAPI OMessageBoxIndirectW(LPMSGBOXPARAMSW lpmbp);
BOOL WINAPI OModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem);
BOOL WINAPI OMoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
BOOL WINAPI OMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
HANDLE WINAPI OLoadImageW(HINSTANCE hinst, LPCWSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
BOOL WINAPI OOemToCharW(LPCSTR lpszSrc, LPWSTR lpszDst);
VOID WINAPI OOutputDebugStringW(LPCWSTR lpOutputString);
BOOL WINAPI OPeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
BOOL WINAPI OPostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OPostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);
LONG APIENTRY ORegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
LONG APIENTRY ORegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
LONG APIENTRY ORegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
LONG APIENTRY ORegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult);
LONG APIENTRY ORegDeleteKeyW(HKEY hKey, LPCWSTR pwszSubKey);
LONG APIENTRY ORegDeleteValueW(HKEY hKey, LPWSTR lpValueName);
ATOM WINAPI ORegisterClassW(CONST WNDCLASSW *lpWndClass);
ATOM WINAPI ORegisterClassExW(CONST WNDCLASSEXW * lpWndClass);
BOOL WINAPI OUnregisterClassW(LPCTSTR  lpClassName, HINSTANCE  hInstance);
UINT WINAPI ORegisterClipboardFormatW(LPCWSTR lpszFormat);
UINT WINAPI ORegisterWindowMessageW(LPCWSTR lpString);
LONG APIENTRY ORegOpenKeyExW(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
LONG APIENTRY ORegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
LONG APIENTRY ORegQueryValueW(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue, PLONG lpcbValue);
LONG APIENTRY ORegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE* lpData, DWORD cbData);
LONG APIENTRY ORegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
LONG APIENTRY ORegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HANDLE WINAPI ORemovePropW(HWND hWnd, LPCWSTR lpString);
LRESULT WINAPI OSendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI OSendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OSendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OSetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
BOOL WINAPI OSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
BOOL WINAPI OSetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);
BOOL WINAPI OSetMenuItemInfoW(HMENU hMenu, UINT uItem, BOOL fByPosition, LPCMENUITEMINFOW lpcmii);
LONG WINAPI OSetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong); 
HHOOK WINAPI OSetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);
BOOL WINAPI OSetWindowTextW(HWND hWnd, LPCWSTR lpString);
LONG WINAPI OTabbedTextOutW(HDC hDC, int X, int Y, LPCWSTR lpString, int nCount, int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
// FOR OLE CTL: THIS MAGLES INTERFACE MEMBERS BY SAME NAME
//int WINAPI OTranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
SHORT WINAPI OVkKeyScanW(WCHAR ch);
BOOL WINAPI OWinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, DWORD dwData);
BOOL WINAPI OWritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
int WINAPIV OwsprintfW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...);
BOOL WINAPI OGetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
LONG APIENTRY ORegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
HANDLE WINAPI OCreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
LRESULT WINAPI ODefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI OGetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
BOOL WINAPI OSetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData);
HRESULT WINAPI OStgCreateDocfile(const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, IStorage ** ppstgOpen);
int WINAPI OStartDocW(HDC hDC, CONST DOCINFOW * pdiDocW);
BOOL WINAPI OSystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
LPWSTR WINAPI OCharNextW(LPCWSTR lpsz);

// Added by VK -- 12/1/98
HRESULT __stdcall OURLOpenBlockingStreamW(LPUNKNOWN pCaller, LPCWSTR wszURL, LPSTREAM *ppStream, DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
BOOL WINAPI OInternetCreateUrlW(LPURL_COMPONENTSW lpUrlComponents, DWORD dwFlags, LPWSTR lpwszUrl, LPDWORD lpdwUrlLength);
BOOL WINAPI OInternetCrackUrlW(LPCWSTR lpwszUrl, DWORD dwUrlLength, DWORD dwFlags, LPURL_COMPONENTSW lpUrlComponents);
BOOL WINAPI ODeleteUrlCacheEntryW(LPCWSTR lpwszUrlName);

// Added by VK -- 8/10/99
HINTERNET WINAPI OInternetOpenW(LPCWSTR lpszAgent, DWORD dwAccessType, LPCWSTR lpszProxy, LPCWSTR lpszProxyBypass, DWORD dwFlags);
HINTERNET WINAPI OInternetOpenUrlW(HINTERNET hInternet, LPCWSTR lpszUrl, LPCWSTR lpszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext);

#ifdef DEBUG
int WINAPI ODlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType);
int WINAPI ODlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype);
BOOL WINAPI ODlgDirSelectComboBoxExW(HWND hDlg, LPWSTR lpString, int nCount, int nIDComboBox);
BOOL WINAPI ODlgDirSelectExW(HWND hDlg, LPWSTR lpString, int nCount, int nIDListBox);
#endif

} // extern "C"

#define AppendMenuW OAppendMenuW
#define CallWindowProcW OCallWindowProcW
#define CharLowerBuffW OCharLowerBuffW
#define CharLowerW OCharLowerW
#define CharNextW OCharNextW
#define CharPrevW OCharPrevW
#define CharToOemW OCharToOemW
#define CharUpperW OCharUpperW
#define CopyFileW OCopyFileW
#define CreateDCW OCreateDCW
#define CreateDirectoryExW OCreateDirectoryExW
#define CreateDirectoryW OCreateDirectoryW
#define CreateEnhMetaFileW OCreateEnhMetaFileW
#define CreateEventW OCreateEventW
#define CreateFileMappingW OCreateFileMappingW
#define CreateFileW OCreateFileW
#define CreateFontIndirectW OCreateFontIndirectW
#define CreateFontW OCreateFontW
#define CreateMDIWindowW OCreateMDIWindowW
#define CreateMetaFileW OCreateMetaFileW
#define CreateSemaphoreW OCreateSemaphoreW
#define CreateWindowExW OCreateWindowExW
#define DdeCreateStringHandleW ODdeCreateStringHandleW
#define DdeInitializeW ODdeInitializeW
#define DefFrameProcW ODefFrameProcW
#define DefMDIChildProcW ODefMDIChildProcW
#define DefWindowProcW ODefWindowProcW
#define DeleteFileW ODeleteFileW
#define DialogBoxIndirectParamW ODialogBoxIndirectParamW
#define DialogBoxParamW ODialogBoxParamW
#define DispatchMessageW ODispatchMessageW
#define DrawTextExW ODrawTextExW
#define DrawTextW ODrawTextW
#define ExpandEnvironmentStringsW OExpandEnvironmentStringsW
#define FatalAppExitW OFatalAppExitW
#define FindFirstChangeNotificationW OFindFirstChangeNotificationW
#define FindFirstFileW OFindFirstFileW
#define FindNextFileW OFindNextFileW
#define FindResourceW OFindResourceW
#define FindWindowW OFindWindowW
#define FormatMessageW OFormatMessageW
#define GetCharABCWidthsFloatW OGetCharABCWidthsFloatW
#define GetCharABCWidthsW OGetCharABCWidthsW
#define GetCharWidthFloatW OGetCharWidthFloatW
#define GetCharWidthW OGetCharWidthW
// HACKHACK(VK)  Next two temporarily commented out due to change in WinINet (including defines)
// Remove before 5.5 B3.  Temporary safety fix, long term maintenance problem:
//#define GetClassInfoW OGetClassInfoW
//#define GetClassInfoExW OGetClassInfoExW
#define GetClassLongW OGetClassLongW
#define GetClassNameW OGetClassNameW
#define GetCurrentDirectoryW OGetCurrentDirectoryW
#define GetDlgItemTextW OGetDlgItemTextW
#define GetFileAttributesW OGetFileAttributesW
#define GetFullPathNameW OGetFullPathNameW
#define GetGlyphOutlineW OGetGlyphOutlineW
#define GetKerningPairsW OGetKerningPairsW
#define GetLocaleInfoW OGetLocaleInfoW
#define GetMessageW OGetMessageW
#define GetModuleFileNameW OGetModuleFileNameW
#define GetModuleHandleW OGetModuleHandleW
#define GetObjectW OGetObjectW
#define GetOpenFileNameW OGetOpenFileNameW
#define GetOutlineTextMetricsW OGetOutlineTextMetricsW
#define GetPrivateProfileIntW OGetPrivateProfileIntW
#define GetPrivateProfileStringW OGetPrivateProfileStringW
#define GetProfileIntW OGetProfileIntW
#define GetPropW OGetPropW
#define GetSaveFileNameW OGetSaveFileNameW
#define GetTabbedTextExtentW OGetTabbedTextExtentW
#define GetTempFileNameW OGetTempFileNameW
#define GetTempPathW OGetTempPathW
#define GetTextExtentPoint32W OGetTextExtentPoint32W
#define GetTextExtentPointW OGetTextExtentPointW
#define GetTextExtentExPointW OGetTextExtentExPointW
#define GetTextMetricsW OGetTextMetricsW
#define GetUserNameW OGetUserNameW
#define GetVersionExW OGetVersionExW
#define GetVolumeInformationW OGetVolumeInformationW
#define GetWindowLongW OGetWindowLongW
#define GetWindowTextLengthW OGetWindowTextLengthW
#define GetWindowTextW OGetWindowTextW
#define GlobalAddAtomW OGlobalAddAtomW
#define GlobalGetAtomNameW OGlobalGetAtomNameW
#define GrayStringW OGrayStringW
#define InsertMenuW OInsertMenuW
#define IsBadStringPtrW OIsBadStringPtrW
#define IsCharAlphaNumericW OIsCharAlphaNumericW
#define IsCharAlphaW OIsCharAlphaW
#define IsDialogMessageW OIsDialogMessageW
#define LCMapStringW OLCMapStringW
#define LoadAcceleratorsW OLoadAcceleratorsW
#define LoadBitmapW OLoadBitmapW
#define LoadCursorW OLoadCursorW
#define LoadIconW OLoadIconW
#define LoadImageW OLoadImageW
#define LoadLibraryExW OLoadLibraryExW
#define LoadLibraryW OLoadLibraryW
#define LoadMenuIndirectW OLoadMenuIndirectW
#define LoadMenuW OLoadMenuW
#define LoadStringW OLoadStringW
#define lstrcatW OlstrcatW
#define lstrcmpiW OlstrcmpiW
#define lstrcmpW OlstrcmpW
#define lstrcpynW OlstrcpynW
#define lstrcpyW OlstrcpyW
#define lstrlenW OlstrlenW
#define MapVirtualKeyW OMapVirtualKeyW
#define MessageBoxW OMessageBoxW
#define MessageBoxIndirectW OMessageBoxIndirectW
#define ModifyMenuW OModifyMenuW
#define MoveFileExW OMoveFileExW
#define MoveFileW OMoveFileW
#define OemToCharW OOemToCharW
#define OutputDebugStringW OOutputDebugStringW
#define PeekMessageW OPeekMessageW
#define PostMessageW OPostMessageW
#define PostThreadMessageW OPostThreadMessageW
#define RegCreateKeyExW ORegCreateKeyExW
#define RegCreateKeyW ORegCreateKeyW
#define RegDeleteKeyW ORegDeleteKeyW
#define RegDeleteValueW ORegDeleteValueW
#define RegEnumKeyW ORegEnumKeyW
#define RegEnumValueW ORegEnumValueW
#define RegEnumKeyExW ORegEnumKeyExW
#define RegisterClassW ORegisterClassW
#define RegisterClassExW ORegisterClassExW
#define RegisterClipboardFormatW ORegisterClipboardFormatW
#define RegisterWindowMessageW ORegisterWindowMessageW
#define RegOpenKeyExW ORegOpenKeyExW
#define RegOpenKeyW ORegOpenKeyW
#define RegQueryInfoKeyW ORegQueryInfoKeyW
#define RegQueryValueExW ORegQueryValueExW
#define RegQueryValueW ORegQueryValueW
#define RegSetValueExW ORegSetValueExW
#define RegSetValueW ORegSetValueW
#define RemovePropW ORemovePropW
#define SendDlgItemMessageW OSendDlgItemMessageW
#define SendMessageW OSendMessageW
#define SendNotifyMessageW OSendNotifyMessageW
#define SetDlgItemTextW OSetDlgItemTextW
#define SetFileAttributesW OSetFileAttributesW
#define SetLocaleInfoW OSetLocaleInfoW
#define SetMenuItemInfoW OSetMenuItemInfoW
#define SetPropW OSetPropW
#define SetWindowLongW OSetWindowLongW
#define SetWindowsHookExW OSetWindowsHookExW
#define SetWindowTextW OSetWindowTextW
#define StartDocW OStartDocW
#define StgCreateDocfile OStgCreateDocfile
#define SystemParametersInfoW OSystemParametersInfoW
#define TabbedTextOutW OTabbedTextOutW
// #define TranslateAcceleratorW OTranslateAcceleratorW	FOR OLE CTL: THIS MAGLES INTERFACE MEMBERS BY SAME NAME
#define UnregisterClassW OUnregisterClassW
#define VkKeyScanW OVkKeyScanW
#define WinHelpW OWinHelpW
#define WritePrivateProfileStringW OWritePrivateProfileStringW
#define wsprintfW OwsprintfW

// Added by VK -- 12/1/98
#define URLOpenBlockingStreamW OURLOpenBlockingStreamW
#define InternetCreateUrlW OInternetCreateUrlW
#define InternetCrackUrlW OInternetCrackUrlW
#define DeleteUrlCacheEntryW ODeleteUrlCacheEntryW

// Added by VK -- 8/10/99
#define InternetOpenW OInternetOpenW
#define InternetOpenUrlW OInternetOpenUrlW


// These are the currently unsupported APIs
// These will assert in the debug version and map directly 
// to Windows in the retail version
#ifdef DEBUG
#define AbortSystemShutdownW OAbortSystemShutdownW
#define AccessCheckAndAuditAlarmW OAccessCheckAndAuditAlarmW
#define AddFontResourceW OAddFontResourceW
#define AddFormW OAddFormW
#define AddJobW OAddJobW
#define AddMonitorW OAddMonitorW
#define AddPortW OAddPortW
#define AddPrinterConnectionW OAddPrinterConnectionW
#define AddPrinterDriverW OAddPrinterDriverW
#define AddPrinterW OAddPrinterW
#define AddPrintProcessorW OAddPrintProcessorW
#define AddPrintProvidorW OAddPrintProvidorW
#define AdvancedDocumentPropertiesW OAdvancedDocumentPropertiesW
#define auxGetDevCapsW OauxGetDevCapsW
#define BackupEventLogW OBackupEventLogW
#define BeginUpdateResourceW OBeginUpdateResourceW
#define BuildCommDCBAndTimeoutsW OBuildCommDCBAndTimeoutsW
#define BuildCommDCBW OBuildCommDCBW
#define CallMsgFilterW OCallMsgFilterW
#define CallNamedPipeW OCallNamedPipeW
#define ChangeDisplaySettingsW OChangeDisplaySettingsW
#define ChangeMenuW OChangeMenuW
#define CharToOemBuffW OCharToOemBuffW
#define CharUpperBuffW OCharUpperBuffW
#define ChooseColorW OChooseColorW
#define ChooseFontW OChooseFontW
#define ClearEventLogW OClearEventLogW
#define CommConfigDialogW OCommConfigDialogW
#define CompareStringW OCompareStringW
#define ConfigurePortW OConfigurePortW
#define CopyAcceleratorTableW OCopyAcceleratorTableW
#define CopyEnhMetaFileW OCopyEnhMetaFileW
#define CopyMetaFileW OCopyMetaFileW
#define CreateAcceleratorTableW OCreateAcceleratorTableW
#define CreateColorSpaceW OCreateColorSpaceW
#define CreateDesktopW OCreateDesktopW
#define CreateDialogIndirectParamW OCreateDialogIndirectParamW
#define CreateDialogParamW OCreateDialogParamW
#define CreateICW OCreateICW
#define CreateMailslotW OCreateMailslotW
#define CreateMutexW OCreateMutexW
#define CreateNamedPipeW OCreateNamedPipeW
#define CreateProcessW OCreateProcessW
#define CreateProcessAsUserW OCreateProcessAsUserW
#define CreatePropertySheetPageW OCreatePropertySheetPageW
#define CreateScalableFontResourceW OCreateScalableFontResourceW
#define CreateStatusWindowW OCreateStatusWindowW
#define CreateWindowStationW OCreateWindowStationW
#define DceErrorInqTextW ODceErrorInqTextW
#define DdeQueryStringW   ODdeQueryStringW
#define DefDlgProcW ODefDlgProcW
#define DefineDosDeviceW ODefineDosDeviceW
#define DeleteFormW ODeleteFormW
#define DeleteMonitorW ODeleteMonitorW
#define DeletePortW ODeletePortW
#define DeletePrinterConnectionW ODeletePrinterConnectionW
#define DeletePrinterDriverW ODeletePrinterDriverW
#define DeletePrintProcessorW ODeletePrintProcessorW
#define DeletePrintProvidorW ODeletePrintProvidorW
#define DeviceCapabilitiesW ODeviceCapabilitiesW
#define DlgDirListComboBoxW ODlgDirListComboBoxW
#define DlgDirListW ODlgDirListW
#define DlgDirSelectComboBoxExW ODlgDirSelectComboBoxExW
#define DlgDirSelectExW ODlgDirSelectExW
#define DocumentPropertiesW ODocumentPropertiesW
#define DoEnvironmentSubstW ODoEnvironmentSubstW
#define DragQueryFileW ODragQueryFileW
#define DrawStateW ODrawStateW
#define EndUpdateResourceW OEndUpdateResourceW
#define EnumCalendarInfoW OEnumCalendarInfoW
#define EnumDateFormatsW OEnumDateFormatsW
#define EnumDesktopsW OEnumDesktopsW
#define EnumDisplaySettingsW OEnumDisplaySettingsW
#define EnumFontFamiliesExW OEnumFontFamiliesExW
#define EnumFontFamiliesW OEnumFontFamiliesW
#define EnumFontsW OEnumFontsW
#define EnumFormsW OEnumFormsW
#define EnumICMProfilesW OEnumICMProfilesW
#define EnumJobsW OEnumJobsW
#define EnumMonitorsW OEnumMonitorsW
#define EnumPortsW OEnumPortsW
#define EnumPrinterDriversW OEnumPrinterDriversW
#define EnumPrintersW OEnumPrintersW
#define EnumPrintProcessorDatatypesW OEnumPrintProcessorDatatypesW
#define EnumPrintProcessorsW OEnumPrintProcessorsW
#define EnumPropsExW OEnumPropsExW
#define EnumPropsW OEnumPropsW
#define EnumProtocolsW OEnumProtocolsW
#define EnumResourceLanguagesW OEnumResourceLanguagesW
#define EnumResourceNamesW OEnumResourceNamesW
#define EnumResourceTypesW OEnumResourceTypesW
#define EnumSystemCodePagesW OEnumSystemCodePagesW
#define EnumSystemLocalesW OEnumSystemLocalesW
#define EnumTimeFormatsW OEnumTimeFormatsW
#define EnumWindowStationsW OEnumWindowStationsW
#define ExtractAssociatedIconW OExtractAssociatedIconW
#define ExtractIconW OExtractIconW
#define ExtractIconExW OExtractIconExW
#define FillConsoleOutputCharacterW OFillConsoleOutputCharacterW
#define FindEnvironmentStringW OFindEnvironmentStringW
#define FindExecutableW OFindExecutableW
#define FindResourceExW OFindResourceExW
#define FindTextW OFindTextW
#define FindWindowExW OFindWindowExW
#define FoldStringW OFoldStringW
#define GetBinaryTypeW OGetBinaryTypeW
#define GetCharacterPlacementW OGetCharacterPlacementW
#define GetCharWidth32W OGetCharWidth32W
#define GetCommandLineW OGetCommandLineW
#define GetClipboardFormatNameW OGetClipboardFormatNameW
#define GetCompressedFileSizeW OGetCompressedFileSizeW
#define GetComputerNameW OGetComputerNameW
#define GetConsoleTitleW OGetConsoleTitleW
#define GetCurrencyFormatW OGetCurrencyFormatW
#define GetDateFormatW OGetDateFormatW
#define GetDefaultCommConfigW OGetDefaultCommConfigW
#define GetDiskFreeSpaceW OGetDiskFreeSpaceW
#define GetDriveTypeW OGetDriveTypeW
#define GetEnhMetaFileDescriptionW OGetEnhMetaFileDescriptionW
#define GetEnhMetaFileW OGetEnhMetaFileW
#define GetEnvironmentVariableW OGetEnvironmentVariableW
#define GetExpandedNameW OGetExpandedNameW
#define GetFileSecurityW OGetFileSecurityW
#define GetFileTitleW OGetFileTitleW
#define GetFileVersionInfoW OGetFileVersionInfoW
#define GetFileVersionInfoSizeW OGetFileVersionInfoSizeW
#define GetFormW OGetFormW
#define GetICMProfileW OGetICMProfileW
#define GetJobW OGetJobW
#define GetKeyboardLayoutNameW OGetKeyboardLayoutNameW
#define GetKeyNameTextW OGetKeyNameTextW
#define GetLogColorSpaceW OGetLogColorSpaceW
#define GetLogicalDriveStringsW OGetLogicalDriveStringsW
#define GetMenuItemInfoW OGetMenuItemInfoW
#define GetMenuStringW OGetMenuStringW
#define GetMetaFileW OGetMetaFileW
#define GetNameByTypeW OGetNameByTypeW
#define GetNamedPipeHandleStateW OGetNamedPipeHandleStateW
#define GetNumberFormatW OGetNumberFormatW
#define GetPrinterW OGetPrinterW
#define GetPrinterDataW OGetPrinterDataW
#define GetPrinterDriverDirectoryW OGetPrinterDriverDirectoryW
#define GetPrinterDriverW OGetPrinterDriverW
#define GetPrintProcessorDirectoryW OGetPrintProcessorDirectoryW
#define GetPrivateProfileSectionNamesW OGetPrivateProfileSectionNamesW
#define GetPrivateProfileSectionW OGetPrivateProfileSectionW
#define GetPrivateProfileStructW OGetPrivateProfileStructW
#define GetProfileSectionW OGetProfileSectionW
#define GetProfileStringW OGetProfileStringW
#define GetShortPathNameW OGetShortPathNameW
#define GetStartupInfoW OGetStartupInfoW
#define GetStringTypeExW OGetStringTypeExW
#define GetSystemDirectoryW OGetSystemDirectoryW
#define GetTextFaceW OGetTextFaceW
#define GetTimeFormatW OGetTimeFormatW
#define GetTypeByNameW OGetTypeByNameW
#define GetUserObjectInformationW OGetUserObjectInformationW
#define GetWindowsDirectoryW OGetWindowsDirectoryW
#define GlobalFindAtomW OGlobalFindAtomW
#define ImageList_LoadImageW OImageList_LoadImageW
#define ImmConfigureIMEW OImmConfigureIMEW
#define ImmEnumRegisterWordW OImmEnumRegisterWordW
#define ImmEscapeW OImmEscapeW
#define ImmGetCandidateListCountW OImmGetCandidateListCountW
#define ImmGetCandidateListW OImmGetCandidateListW
#define ImmGetCompositionFontW OImmGetCompositionFontW
#define ImmGetCompositionStringW OImmGetCompositionStringW
#define ImmGetConversionListW OImmGetConversionListW
#define ImmGetDescriptionW OImmGetDescriptionW
#define ImmGetGuideLineW OImmGetGuideLineW
#define ImmGetIMEFileNameW OImmGetIMEFileNameW
#define ImmGetRegisterWordStyleW OImmGetRegisterWordStyleW
#define ImmInstallIMEW OImmInstallIMEW
#define ImmIsUIMessageW OImmIsUIMessageW
#define ImmRegisterWordW OImmRegisterWordW
#define ImmSetCompositionFontW OImmSetCompositionFontW
#define ImmSetCompositionStringW OImmSetCompositionStringW
#define ImmUnregisterWordW OImmUnregisterWordW
#define InitiateSystemShutdownW OInitiateSystemShutdownW
#define InsertMenuItemW OInsertMenuItemW
#define IsCharLowerW OIsCharLowerW
#define IsCharUpperW OIsCharUpperW
#define I_RpcServerUnregisterEndpointW OI_RpcServerUnregisterEndpointW
#define joyGetDevCapsW OjoyGetDevCapsW
#define LoadCursorFromFileW OLoadCursorFromFileW
#define LoadKeyboardLayoutW OLoadKeyboardLayoutW
#define LogonUserW OLogonUserW
#define LZOpenFileW OLZOpenFileW
#define MapVirtualKeyExW OMapVirtualKeyExW
#define MIMEAssociationDialogW OMIMEAssociationDialogW
#define MultinetGetConnectionPerformanceW OMultinetGetConnectionPerformanceW
#define ObjectCloseAuditAlarmW OObjectCloseAuditAlarmW
#define ObjectOpenAuditAlarmW OObjectOpenAuditAlarmW
#define ObjectPrivilegeAuditAlarmW OObjectPrivilegeAuditAlarmW
#define OemToCharBuffW OOemToCharBuffW
#define OpenBackupEventLogW OOpenBackupEventLogW
#define OpenDesktopW OOpenDesktopW
#define OpenEventLogW OOpenEventLogW
#define OpenEventW OOpenEventW
#define OpenFileMappingW OOpenFileMappingW
#define OpenMutexW OOpenMutexW
#define OpenPrinterW OOpenPrinterW
#define OpenSemaphoreW OOpenSemaphoreW
#define OpenWindowStationW OOpenWindowStationW
#define PageSetupDlgW OPageSetupDlgW
#define PeekConsoleInputW OPeekConsoleInputW
#define PolyTextOutW OPolyTextOutW
#define PrintDlgW OPrintDlgW
#define PrinterMessageBoxW OPrinterMessageBoxW
#define PrivilegedServiceAuditAlarmW OPrivilegedServiceAuditAlarmW
#define PropertySheetW OPropertySheetW
#define QueryDosDeviceW OQueryDosDeviceW
#define ReadConsoleInputW OReadConsoleInputW
#define ReadConsoleOutputCharacterW OReadConsoleOutputCharacterW
#define ReadConsoleOutputW OReadConsoleOutputW
#define ReadConsoleW OReadConsoleW
#define ReadEventLogW OReadEventLogW
#define RegConnectRegistryW ORegConnectRegistryW
#define RegisterEventSourceW ORegisterEventSourceW
#define RegLoadKeyW ORegLoadKeyW
#define RegQueryMultipleValuesW ORegQueryMultipleValuesW
#define RegReplaceKeyW ORegReplaceKeyW
#define RegRestoreKeyW ORegRestoreKeyW
#define RegSaveKeyW ORegSaveKeyW
#define RegUnLoadKeyW ORegUnLoadKeyW
#define RemoveDirectoryW ORemoveDirectoryW
#define RemoveFontResourceW ORemoveFontResourceW
#define ReplaceTextW OReplaceTextW
#define ReportEventW OReportEventW
#define ResetDCW OResetDCW
#define ResetPrinterW OResetPrinterW
#define RpcBindingFromStringBindingW ORpcBindingFromStringBindingW
#define RpcBindingInqAuthClientW ORpcBindingInqAuthClientW
#define RpcBindingToStringBindingW ORpcBindingToStringBindingW
#define RpcEpRegisterNoReplaceW ORpcEpRegisterNoReplaceW
#define RpcMgmtEpEltInqNextW ORpcMgmtEpEltInqNextW
#define RpcMgmtInqServerPrincNameW ORpcMgmtInqServerPrincNameW
#define RpcNetworkInqProtseqsW ORpcNetworkInqProtseqsW
#define RpcNetworkIsProtseqValidW ORpcNetworkIsProtseqValidW
#define RpcNsBindingInqEntryNameW ORpcNsBindingInqEntryNameW
#define RpcProtseqVectorFreeW ORpcProtseqVectorFreeW
#define RpcServerInqDefaultPrincNameW ORpcServerInqDefaultPrincNameW
#define RpcServerUseProtseqEpW ORpcServerUseProtseqEpW
#define RpcServerUseProtseqIfW ORpcServerUseProtseqIfW
#define RpcServerUseProtseqW ORpcServerUseProtseqW
#define RpcStringBindingComposeW ORpcStringBindingComposeW
#define RpcStringBindingParseW ORpcStringBindingParseW
#define RpcStringFreeW ORpcStringFreeW
#define ScrollConsoleScreenBufferW OScrollConsoleScreenBufferW
#define SearchPathW OSearchPathW
#define SendMessageCallbackW OSendMessageCallbackW
#define SendMessageTimeoutW OSendMessageTimeoutW
#define SetClassLongW OSetClassLongW
#define SetComputerNameW OSetComputerNameW
#define SetConsoleTitleW OSetConsoleTitleW
#define SetCurrentDirectoryW OSetCurrentDirectoryW
#define SetDefaultCommConfigW OSetDefaultCommConfigW
#define SetEnvironmentVariableW OSetEnvironmentVariableW
#define SetFileSecurityW OSetFileSecurityW
#define SetFormW OSetFormW
#define SetICMProfileW OSetICMProfileW
#define SetJobW OSetJobW
#define SetPrinterDataW OSetPrinterDataW
#define SetPrinterW OSetPrinterW
#define SetUserObjectInformationW OSetUserObjectInformationW
#define SetVolumeLabelW OSetVolumeLabelW
#define SetWindowsHookW OSetWindowsHookW
#define SHBrowseForFolderW OSHBrowseForFolderW
#define Shell_NotifyIconW OShell_NotifyIconW
#define ShellAboutW OShellAboutW
#define ShellExecuteW OShellExecuteW
#define ShellExecuteExW OShellExecuteExW
#define SHFileOperationW OSHFileOperationW
#define SHGetFileInfoW OSHGetFileInfoW
#define SHGetNewLinkInfoW OSHGetNewLinkInfoW
#define SHGetPathFromIDListW OSHGetPathFromIDListW
#define sndPlaySoundW OsndPlaySoundW
#define StartDocPrinterW OStartDocPrinterW
#define StgCreateDocfile OStgCreateDocfile
#define TranslateURLW OTranslateURLW
#define UpdateICMRegKeyW OUpdateICMRegKeyW
#define URLAssociationDialogW OURLAssociationDialogW
#define UuidFromStringW OUuidFromStringW
#define VerFindFileW OVerFindFileW
#define VerInstallFileW OVerInstallFileW
#define VerLanguageNameW OVerLanguageNameW
#define VerQueryValueW OVerQueryValueW
#define VkKeyScanExW OVkKeyScanExW
#define WaitNamedPipeW OWaitNamedPipeW
#define waveInGetDevCapsW OwaveInGetDevCapsW
#define waveInGetErrorTextW OwaveInGetErrorTextW
#define waveOutGetDevCapsW OwaveOutGetDevCapsW
#define waveOutGetErrorTextW OwaveOutGetErrorTextW
#define wglUseFontBitmapsW OwglUseFontBitmapsW
#define wglUseFontOutlinesW OwglUseFontOutlinesW
#define WinExecErrorW OWinExecErrorW
#define WNetAddConnection2W OWNetAddConnection2W
#define WNetAddConnection3W OWNetAddConnection3W
#define WNetAddConnectionW OWNetAddConnectionW
#define WNetCancelConnection2W OWNetCancelConnection2W
#define WNetCancelConnectionW OWNetCancelConnectionW
#define WNetConnectionDialog1W OWNetConnectionDialog1W
#define WNetDisconnectDialog1W OWNetDisconnectDialog1W
#define WNetEnumResourceW OWNetEnumResourceW
#define WNetGetConnectionW OWNetGetConnectionW
#define WNetGetLastErrorW OWNetGetLastErrorW
#define WNetGetNetworkInformationW OWNetGetNetworkInformationW
#define WNetGetProviderNameW OWNetGetProviderNameW
#define WNetGetUniversalNameW OWNetGetUniversalNameW
#define WNetGetUserW OWNetGetUserW
#define WNetOpenEnumW OWNetOpenEnumW
#define WNetSetConnectionW OWNetSetConnectionW
#define WNetUseConnectionW OWNetUseConnectionW
#define WriteConsoleInputW OWriteConsoleInputW
#define WriteConsoleOutputCharacterW OWriteConsoleOutputCharacterW
#define WriteConsoleOutputW OWriteConsoleOutputW
#define WriteConsoleW OWriteConsoleW
#define WritePrivateProfileSectionW OWritePrivateProfileSectionW
#define WritePrivateProfileStructW OWritePrivateProfileStructW
#define WriteProfileSectionW OWriteProfileSectionW
#define WriteProfileStringW OWriteProfileStringW
#define wvsprintfW OwvsprintfW
#endif // DEBUG

#endif // __WIN95WRP_H__

#else // __WIN95WRP_CPP__

#undef AppendMenuW
#undef CallWindowProcW
#undef CharLowerBuffW
#undef CharLowerW
#undef CharNextW
#undef CharPrevW
#undef CharToOemW
#undef CharUpperW
#undef CopyFileW
#undef CreateDCW
#undef CreateDirectoryExW
#undef CreateDirectoryW
#undef CreateEnhMetaFileW
#undef CreateEventW
#undef CreateFileMappingW
#undef CreateFileW
#undef CreateFontIndirectW
#undef CreateFontW
#undef CreateMDIWindowW
#undef CreateMetaFileW
#undef CreateSemaphoreW
#undef CreateWindowExW
#undef DdeCreateStringHandleW
#undef DdeInitializeW
#undef DefFrameProcW
#undef DefMDIChildProcW
#undef DefWindowProcW
#undef DeleteFileW
#undef DialogBoxIndirectParamW
#undef DialogBoxParamW
#undef DispatchMessageW
#undef DrawTextExW
#undef DrawTextW
#undef ExpandEnvironmentStringsW
#undef FatalAppExitW
#undef FindFirstChangeNotificationW
#undef FindFirstFileW
#undef FindNextFileW
#undef FindResourceW
#undef FindWindowW
#undef FormatMessageW
#undef GetCharABCWidthsFloatW
#undef GetCharABCWidthsW
#undef GetCharWidthFloatW
#undef GetCharWidthW
#undef GetClassInfoW
#undef GetClassInfoExW
#undef GetClassLongW
#undef GetClassNameW
#undef GetCurrentDirectoryW
#undef GetDlgItemTextW
#undef GetFileAttributesW
#undef GetFullPathNameW
#undef GetGlyphOutlineW
#undef GetKerningPairsW
#undef GetLocaleInfoW
#undef GetMessageW
#undef GetModuleFileNameW
#undef GetModuleHandleW
#undef GetObjectW
#undef GetOpenFileNameW
#undef GetOutlineTextMetricsW
#undef GetPrivateProfileIntW
#undef GetPrivateProfileStringW
#undef GetProfileIntW
#undef GetPropW
#undef GetSaveFileNameW
#undef GetTabbedTextExtentW
#undef GetTempFileNameW
#undef GetTempPathW
#undef GetTextExtentPoint32W
#undef GetTextExtentPointW
#undef GetTextExtentExPointW
#undef GetTextMetricsW
#undef GetUserNameW
#undef GetVersionExW
#undef GetVolumeInformationW
#undef GetWindowLongW
#undef GetWindowTextLengthW
#undef GetWindowTextW
#undef GlobalAddAtomW
#undef GlobalGetAtomNameW
#undef GrayStringW
#undef InsertMenuW
#undef IsBadStringPtrW
#undef IsCharAlphaNumericW
#undef IsCharAlphaW
#undef IsDialogMessageW
#undef LCMapStringW
#undef LoadAcceleratorsW
#undef LoadBitmapW
#undef LoadCursorW
#undef LoadIconW
#undef LoadImageW
#undef LoadLibraryExW
#undef LoadLibraryW
#undef LoadMenuIndirectW
#undef LoadMenuW
#undef LoadStringW
#undef lstrcatW
#undef lstrcmpiW
#undef lstrcmpW
#undef lstrcpynW
#undef lstrcpyW
#undef lstrlenW
#undef MapVirtualKeyW
#undef MessageBoxW
#undef MessageBoxIndirectW
#undef ModifyMenuW
#undef MoveFileExW
#undef MoveFileW
#undef OemToCharW
#undef OutputDebugStringW
#undef PeekMessageW
#undef PostMessageW
#undef PostThreadMessageW
#undef RegCreateKeyExW
#undef RegCreateKeyW
#undef RegDeleteKeyW
#undef RegDeleteValueW
#undef RegEnumKeyW
#undef RegEnumValueW
#undef RegEnumKeyExW
#undef RegisterClassW
#undef RegisterClassExW
#undef RegisterClipboardFormatW
#undef RegisterWindowMessageW
#undef RegOpenKeyExW
#undef RegOpenKeyW
#undef RegQueryInfoKeyW
#undef RegQueryValueExW
#undef RegQueryValueW
#undef RegSetValueExW
#undef RegSetValueW
#undef RemovePropW
#undef SendDlgItemMessageW
#undef SendMessageW
#undef SendNotifyMessageW
#undef SetDlgItemTextW
#undef SetFileAttributesW
#undef SetLocaleInfoW
#undef SetMenuItemInfoW
#undef SetPropW
#undef SetWindowLongW
#undef SetWindowsHookExW
#undef SetWindowTextW
#undef StartDocW
#undef StgCreateDocfileW
#undef SystemParametersInfoW
#undef TabbedTextOutW
//#undef TranslateAcceleratorW	FOR OLE CTL: THIS MAGLES INTERFACE MEMBERS BY SAME NAME
#undef UnregisterClassW
#undef VkKeyScanW
#undef WinHelpW
#undef WritePrivateProfileStringW
#undef wsprintfW

// Added by VK -- 12/1/98
#undef URLOpenBlockingStreamW
#undef InternetCreateUrlW
#undef InternetCrackUrlW
#undef DeleteUrlCacheEntryW

// Added by VK -- 8/10/99
#undef InternetOpenW
#undef InternetOpenUrlW


// These are the currently unsupported APIs
// These will assert in the debug version and map directly 
// to Windows in the retail version
#ifdef DEBUG
#undef AbortSystemShutdownW
#undef AccessCheckAndAuditAlarmW
#undef AddFontResourceW
#undef AddFormW
#undef AddJobW
#undef AddMonitorW
#undef AddPortW
#undef AddPrinterConnectionW
#undef AddPrinterDriverW
#undef AddPrinterW
#undef AddPrintProcessorW
#undef AddPrintProvidorW
#undef AdvancedDocumentPropertiesW
#undef auxGetDevCapsW
#undef BackupEventLogW
#undef BeginUpdateResourceW
#undef BuildCommDCBAndTimeoutsW
#undef BuildCommDCBW
#undef CallMsgFilterW
#undef CallNamedPipeW
#undef ChangeDisplaySettingsW
#undef ChangeMenuW
#undef CharToOemBuffW
#undef CharUpperBuffW
#undef ChooseColorW
#undef ChooseFontW
#undef ClearEventLogW
#undef CommConfigDialogW
#undef CompareStringW
#undef ConfigurePortW
#undef CopyAcceleratorTableW
#undef CopyEnhMetaFileW
#undef CopyMetaFileW
#undef CreateAcceleratorTableW
#undef CreateColorSpaceW
#undef CreateDesktopW
#undef CreateDialogIndirectParamW
#undef CreateDialogParamW
#undef CreateICW
#undef CreateMailslotW
#undef CreateMutexW
#undef CreateNamedPipeW
#undef CreateProcessW
#undef CreateProcessAsUserW
#undef CreatePropertySheetPageW
#undef CreateScalableFontResourceW
#undef CreateStatusWindowW
#undef CreateWindowStationW
#undef DceErrorInqTextW
#undef DdeQueryStringW
#undef DefDlgProcW
#undef undefDosDeviceW
#undef DeleteFormW
#undef DeleteMonitorW
#undef DeletePortW
#undef DeletePrinterConnectionW
#undef DeletePrinterDriverW
#undef DeletePrintProcessorW
#undef DeletePrintProvidorW
#undef DeviceCapabilitiesW
#undef DlgDirListComboBoxW
#undef DlgDirListW
#undef DlgDirSelectComboBoxExW
#undef DlgDirSelectExW
#undef DocumentPropertiesW
#undef DoEnvironmentSubstW
#undef DragQueryFileW
#undef DrawStateW
#undef EndUpdateResourceW
#undef EnumCalendarInfoW
#undef EnumDateFormatsW
#undef EnumDesktopsW
#undef EnumDisplaySettingsW
#undef EnumFontFamiliesExW
#undef EnumFontFamiliesW
#undef EnumFontsW
#undef EnumFormsW
#undef EnumICMProfilesW
#undef EnumJobsW
#undef EnumMonitorsW
#undef EnumPortsW
#undef EnumPrinterDriversW
#undef EnumPrintersW
#undef EnumPrintProcessorDatatypesW
#undef EnumPrintProcessorsW
#undef EnumPropsExW
#undef EnumPropsW
#undef EnumProtocolsW
#undef EnumResourceLanguagesW
#undef EnumResourceNamesW
#undef EnumResourceTypesW
#undef EnumSystemCodePagesW
#undef EnumSystemLocalesW
#undef EnumTimeFormatsW
#undef EnumWindowStationsW
#undef ExtractAssociatedIconW
#undef ExtractIconW
#undef ExtractIconExW
#undef FillConsoleOutputCharacterW
#undef FindEnvironmentStringW
#undef FindExecutableW
#undef FindResourceExW
#undef FindTextW
#undef FindWindowExW
#undef FoldStringW
#undef GetBinaryTypeW
#undef GetCharacterPlacementW
#undef GetCharWidth32W
#undef GetCommandLineW
#undef GetClipboardFormatNameW
#undef GetCompressedFileSizeW
#undef GetComputerNameW
#undef GetConsoleTitleW
#undef GetCurrencyFormatW
#undef GetDateFormatW
#undef GetDefaultCommConfigW
#undef GetDiskFreeSpaceW
#undef GetDriveTypeW
#undef GetEnhMetaFileDescriptionW
#undef GetEnhMetaFileW
#undef GetEnvironmentVariableW
#undef GetExpandedNameW
#undef GetFileSecurityW
#undef GetFileTitleW
#undef GetFileVersionInfoW
#undef GetFileVersionInfoSizeW
#undef GetFormW
#undef GetICMProfileW
#undef GetJobW
#undef GetKeyboardLayoutNameW
#undef GetKeyNameTextW
#undef GetLogColorSpaceW
#undef GetLogicalDriveStringsW
#undef GetMenuItemInfoW
#undef GetMenuStringW
#undef GetMetaFileW
#undef GetNameByTypeW
#undef GetNamedPipeHandleStateW
#undef GetNumberFormatW
#undef GetPrinterW
#undef GetPrinterDataW
#undef GetPrinterDriverDirectoryW
#undef GetPrinterDriverW
#undef GetPrintProcessorDirectoryW
#undef GetPrivateProfileSectionNamesW
#undef GetPrivateProfileSectionW
#undef GetPrivateProfileStructW
#undef GetProfileSectionW
#undef GetProfileStringW
#undef GetShortPathNameW
#undef GetStartupInfoW
#undef GetStringTypeExW
#undef GetSystemDirectoryW
#undef GetTextFaceW
#undef GetTimeFormatW
#undef GetTypeByNameW
#undef GetUserObjectInformationW
#undef GetWindowsDirectoryW
#undef GlobalFindAtomW
#undef ImageList_LoadImageW
#undef ImmConfigureIMEW
#undef ImmEnumRegisterWordW
#undef ImmEscapeW
#undef ImmGetCandidateListCountW
#undef ImmGetCandidateListW
#undef ImmGetCompositionFontW
#undef ImmGetCompositionStringW
#undef ImmGetConversionListW
#undef ImmGetDescriptionW
#undef ImmGetGuideLineW
#undef ImmGetIMEFileNameW
#undef ImmGetRegisterWordStyleW
#undef ImmInstallIMEW
#undef ImmIsUIMessageW
#undef ImmRegisterWordW
#undef ImmSetCompositionFontW
#undef ImmSetCompositionStringW
#undef ImmUnregisterWordW
#undef InitiateSystemShutdownW
#undef InsertMenuItemW
#undef IsCharLowerW
#undef IsCharUpperW
#undef I_RpcServerUnregisterEndpointW
#undef joyGetDevCapsW
#undef LoadCursorFromFileW
#undef LoadKeyboardLayoutW
#undef LogonUserW
#undef LZOpenFileW
#undef MapVirtualKeyExW
#undef MIMEAssociationDialogW
#undef MultinetGetConnectionPerformanceW
#undef ObjectCloseAuditAlarmW
#undef ObjectOpenAuditAlarmW
#undef ObjectPrivilegeAuditAlarmW
#undef OemToCharBuffW
#undef OpenBackupEventLogW
#undef OpenDesktopW
#undef OpenEventLogW
#undef OpenEventW
#undef OpenFileMappingW
#undef OpenMutexW
#undef OpenPrinterW
#undef OpenSemaphoreW
#undef OpenWindowStationW
#undef PageSetupDlgW
#undef PeekConsoleInputW
#undef PolyTextOutW
#undef PrintDlgW
#undef PrinterMessageBoxW
#undef PrivilegedServiceAuditAlarmW
#undef PropertySheetW
#undef QueryDosDeviceW
#undef ReadConsoleInputW
#undef ReadConsoleOutputCharacterW
#undef ReadConsoleOutputW
#undef ReadConsoleW
#undef ReadEventLogW
#undef RegConnectRegistryW
#undef RegisterEventSourceW
#undef RegLoadKeyW
#undef RegQueryMultipleValuesW
#undef RegReplaceKeyW
#undef RegRestoreKeyW
#undef RegSaveKeyW
#undef RegUnLoadKeyW
#undef RemoveDirectoryW
#undef RemoveFontResourceW
#undef ReplaceTextW
#undef ReportEventW
#undef ResetDCW
#undef ResetPrinterW
#undef RpcBindingFromStringBindingW
#undef RpcBindingInqAuthClientW
#undef RpcBindingToStringBindingW
#undef RpcEpRegisterNoReplaceW
#undef RpcMgmtEpEltInqNextW
#undef RpcMgmtInqServerPrincNameW
#undef RpcNetworkInqProtseqsW
#undef RpcNetworkIsProtseqValidW
#undef RpcNsBindingInqEntryNameW
#undef RpcProtseqVectorFreeW
#undef RpcServerInqDefaultPrincNameW
#undef RpcServerUseProtseqEpW
#undef RpcServerUseProtseqIfW
#undef RpcServerUseProtseqW
#undef RpcStringBindingComposeW
#undef RpcStringBindingParseW
#undef RpcStringFreeW
#undef ScrollConsoleScreenBufferW
#undef SearchPathW
#undef SendMessageCallbackW
#undef SendMessageTimeoutW
#undef SetClassLongW
#undef SetComputerNameW
#undef SetConsoleTitleW
#undef SetCurrentDirectoryW
#undef SetDefaultCommConfigW
#undef SetEnvironmentVariableW
#undef SetFileSecurityW
#undef SetFormW
#undef SetICMProfileW
#undef SetJobW
#undef SetPrinterDataW
#undef SetPrinterW
#undef SetUserObjectInformationW
#undef SetVolumeLabelW
#undef SetWindowsHookW
#undef SHBrowseForFolderW
#undef Shell_NotifyIconW
#undef ShellAboutW
#undef ShellExecuteW
#undef ShellExecuteExW
#undef SHFileOperationW
#undef SHGetFileInfoW
#undef SHGetNewLinkInfoW
#undef SHGetPathFromIDListW
#undef sndPlaySoundW
#undef StartDocPrinterW
#undef StgCreateDocfileW
#undef TranslateURLW
#undef UpdateICMRegKeyW
#undef URLAssociationDialogW
#undef UuidFromStringW
#undef VerFindFileW
#undef VerInstallFileW
#undef VerLanguageNameW
#undef VerQueryValueW
#undef VkKeyScanExW
#undef WaitNamedPipeW
#undef waveInGetDevCapsW
#undef waveInGetErrorTextW
#undef waveOutGetDevCapsW
#undef waveOutGetErrorTextW
#undef wglUseFontBitmapsW
#undef wglUseFontOutlinesW
#undef WinExecErrorW
#undef WNetAddConnection2W
#undef WNetAddConnection3W
#undef WNetAddConnectionW
#undef WNetCancelConnection2W
#undef WNetCancelConnectionW
#undef WNetConnectionDialog1W
#undef WNetDisconnectDialog1W
#undef WNetEnumResourceW
#undef WNetGetConnectionW
#undef WNetGetLastErrorW
#undef WNetGetNetworkInformationW
#undef WNetGetProviderNameW
#undef WNetGetUniversalNameW
#undef WNetGetUserW
#undef WNetOpenEnumW
#undef WNetSetConnectionW
#undef WNetUseConnectionW
#undef WriteConsoleInputW
#undef WriteConsoleOutputCharacterW
#undef WriteConsoleOutputW
#undef WriteConsoleW
#undef WritePrivateProfileSectionW
#undef WritePrivateProfileStructW
#undef WriteProfileSectionW
#undef WriteProfileStringW
#undef wvsprintfW
#endif // DEBUG

#endif // __WIN95WRP_CPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedctl\trifilter.cpp ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"
#include "DHTMLEd.h"
#include "DHTMLEdit.h"
#include "site.h"
#include "proxyframe.h"

#define AGENT_SIGNATURE (TEXT("Mozilla/4.0 (compatible; MSIE 5.01; DHTML Editing Control)"))

#define CP_20127 20127      // Code page for us-ascii
#define CP_1252  1252

//	Check to see if a buffer starts with a byte order Unicode character.
//	This implementation is processor byte-order independant.
//
static BOOL StartsWithByteOrderMark ( LPVOID pvData )
{
	CHAR	*pchData	= (CHAR*)pvData;

#pragma warning(disable: 4310) // cast truncates constant value
	if ( ( (char)0xff == pchData[0] ) && ( (char)0xfe == pchData[1] ) )
#pragma warning(default: 4310) // cast truncates constant value
	{
		return TRUE;
	}
	return FALSE;
}


//	Given a pointer to a buffer assumed to hold at least two bytes,
//	write a Unicode byte order mark to it.
//	This implementation is processor byte-order independant.
//
static void InsertByteOrderMark ( LPVOID pvData )
{
	CHAR	*pchData	= (CHAR*)pvData;

#pragma warning(disable: 4310) // cast truncates constant value
	pchData[0] = (CHAR)0xff;
	pchData[1] = (CHAR)0xfe;
#pragma warning(default: 4310) // cast truncates constant value
}


HRESULT
CSite::HrFileToStream(LPCTSTR fileName, LPSTREAM* ppiStream)
{
	HRESULT hr = S_OK;
	HANDLE hFile = NULL;
	HGLOBAL hMem = NULL;
	DWORD cbData = 0;
	LPVOID pbData = NULL;
	BOOL memLocked = FALSE;
	DWORD bytesRead = 0;
	BOOL bResult = FALSE;
	BOOL  bfUnicode = FALSE;

	hFile = CreateFile(
				fileName,
				GENERIC_READ,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				0,
				NULL);

	if(INVALID_HANDLE_VALUE == hFile)
	{
		DWORD ec = ::GetLastError();
		if ( ERROR_BAD_NETPATH == ec ) ec = ERROR_PATH_NOT_FOUND;
		hr = HRESULT_FROM_WIN32(ec);
		return hr;
	}

	cbData = GetFileSize(hFile, NULL);

	if (0xFFFFFFFF == cbData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto cleanup;
	}


	// If the file is empty, create a zero length stream, but the global block must be non-zero in size.
	// VID98BUG 23121
	hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, ( 0 == cbData ) ? 2 : cbData );
#if _DEBUG
	size = GlobalSize(hMem);
#endif

	if (NULL == hMem)
	{
		_ASSERTE(hMem);
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	pbData = GlobalLock(hMem);

	_ASSERTE(pbData);

	if (NULL == pbData)
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	bResult = ReadFile(hFile, pbData, cbData, &bytesRead, NULL) ; 

	_ASSERTE(bResult);

	if (FALSE == bResult)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto cleanup;
	}

	_ASSERTE(bytesRead == cbData);

	BfFlipBytesIfBigEndianUnicode ( (CHAR*)pbData, bytesRead );

	if ( IsUnicode ( pbData, (int)cbData ) )
	{
		bfUnicode = TRUE;
	}
	else
	{
		bfUnicode = FALSE;
	}


cleanup:


	::CloseHandle((HANDLE) hFile);

	if (hr != E_OUTOFMEMORY)
		memLocked = GlobalUnlock(hMem);

	_ASSERTE(FALSE == memLocked);

	if (SUCCEEDED(hr))
	{
		if (SUCCEEDED(hr = CreateStreamOnHGlobal(hMem, TRUE, ppiStream)))
		{
			ULARGE_INTEGER ui = {0};

			_ASSERTE(ppiStream);

			ui.LowPart = cbData;
			ui.HighPart = 0x00;
			hr = (*ppiStream)->SetSize(ui);

			_ASSERTE(SUCCEEDED(hr));
		}

		if ( SUCCEEDED ( hr ) )
		{
			SetSaveAsUnicode ( bfUnicode );
			if ( !bfUnicode )
			{
				hr = HrConvertStreamToUnicode ( *ppiStream );
				_ASSERTE(SUCCEEDED(hr));
			}
		}
	}
	else // if failed
	{
		hMem = GlobalFree(hMem);
		_ASSERTE(NULL == hMem);
	}

	return hr;
}


//	Determine which method of URL fetch to use.  We have one for https, and another for other protocols.
//
HRESULT
CSite::HrURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream)
{
	HRESULT			hr = S_OK;
	URL_COMPONENTS	urlc;

	_ASSERTE ( szURL );
	_ASSERTE ( ppiStream );

	memset ( &urlc, 0, sizeof ( urlc ) );
	urlc.dwStructSize = sizeof ( urlc );

	hr = InternetCrackUrl ( szURL, 0, 0, &urlc );
	if ( SUCCEEDED ( hr ) )
	{
		if ( INTERNET_SCHEME_HTTPS == urlc.nScheme )
		{
			hr = HrSecureURLToStream ( szURL, ppiStream );
		}
		else
		{
			hr = HrNonSecureURLToStream ( szURL, ppiStream );
		}
	}
	return hr;
}



//	This version utilizes WinINet, which does not create cache files so is usable with https.
//	However, pluggable protocols cannot be stacked on the WinINet fucntions.
//
#define BUFFLEN 4096
HRESULT
CSite::HrSecureURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream)
{
	HRESULT		hr		= S_OK;

	_ASSERTE ( szURL );
	_ASSERTE ( ppiStream );
	*ppiStream = NULL;

	// Create a new read/write stream:
	hr = CreateStreamOnHGlobal ( NULL, TRUE, ppiStream );

	if ( SUCCEEDED ( hr ) && *ppiStream )
	{
		CHAR			*pBuff			= NULL;
		DWORD			dwRead			= 0;
		ULONG			ulStreamLen		= 0;
		ULONG			ulStreamWrite	= 0;
		ULARGE_INTEGER	ui				= {0};
		BOOL			bfUnicode		= FALSE;

		pBuff = new CHAR[BUFFLEN];
		if ( NULL == pBuff )
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			HINTERNET hSession = InternetOpen ( AGENT_SIGNATURE, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0 );
			if ( NULL == hSession )
			{
				// InternetOpen failed
				hr = HRESULT_FROM_WIN32 ( GetLastError () );
				_ASSERTE ( FAILED ( hr ) );	// Make sure error returned wasn't NO_ERR
			}
			else
			{
				// Do not allow redirects in the SFS control.
				DWORD dwFlags = m_pFR->GetControl()->IsSafeForScripting () ? INTERNET_FLAG_NO_AUTO_REDIRECT : 0;
				
				HINTERNET hFile = InternetOpenUrl ( hSession, szURL, NULL, 0, dwFlags, 0 );
				if ( NULL == hFile )
				{
					// InternetOpenURL failed
					hr = HRESULT_FROM_WIN32 ( GetLastError () );
					_ASSERTE ( FAILED ( hr ) );	// Make sure error returned wasn't NO_ERR
				}
				else
				{
					// Read in data and write it to the stream to return.
					while ( InternetReadFile ( hFile, pBuff, BUFFLEN, &dwRead ) )
					{
						if ( 0 == dwRead )
						{
							break;
						}
						hr = (*ppiStream)->Write ( pBuff, dwRead, &ulStreamWrite );
						_ASSERTE ( dwRead == ulStreamWrite );

						if ( SUCCEEDED ( hr ) )
						{
							ulStreamLen += ulStreamWrite;
						}
						else
						{
							// Failed to read the data.  Make sure the error is not overwritten.
							goto READFILE_BAILOUT;
						}
					}


					ui.LowPart	= ulStreamLen;
					ui.HighPart	= 0x00;
					hr = (*ppiStream)->SetSize(ui);

					hr = HrConvertStreamToUnicode ( *ppiStream );
					bfUnicode = ( S_FALSE == hr );
					if ( SUCCEEDED ( hr ) )
					{
						hr = S_OK;	// the S_FALSE result wouldn't make much sense to caller of this function.
					}
					SetSaveAsUnicode ( bfUnicode );

READFILE_BAILOUT:
					InternetCloseHandle ( hFile );
				}

				InternetCloseHandle ( hSession );
			}
			delete [] pBuff;
		}
	}

	// If an error is being returned, cleat the stream here.
	if ( FAILED ( hr ) && ( NULL != *ppiStream ) )
	{
		(*ppiStream)->Release();
		*ppiStream = NULL;
	}

	return hr;
}


//  This version utilizes URLMon, which makes stacking pluggable protocols possible.
// However, it cannot be used with https because it creates a cache file.
//
HRESULT
CSite::HrNonSecureURLToStream(LPCTSTR szURL, LPSTREAM* ppiStream)
{
	HRESULT		hr				= S_OK;
	IStream*	piStreamOrig	= NULL;

	*ppiStream = NULL;

	// Use the degenerate IBindStatusCallback implemented on the proxyframe exclusively
	// to provide IAuthenticate.
	IBindStatusCallback* piBSCB = NULL;
	m_pFR->QueryInterface ( IID_IBindStatusCallback, (void**)&piBSCB );

	m_pFR->ClearSFSRedirect ();

#ifdef LATE_BIND_URLMON_WININET
	PFNURLOpenBlockingStream pfnURLOpenBlockingStream = m_pFR->m_pfnURLOpenBlockingStream;
	_ASSERTE ( pfnURLOpenBlockingStream );
	hr = (*pfnURLOpenBlockingStream)( NULL, szURL, &piStreamOrig, 0, piBSCB );
#else
	hr = URLOpenBlockingStream ( NULL, szURL, &piStreamOrig, 0, piBSCB );
#endif // LATE_BIND_URLMON_WININET

	if ( NULL != piBSCB )
	{
		piBSCB->Release ();
		piBSCB = NULL;
	}

	// If SFSRedirect got set, this is the SFS control and a redirect was detected.  Abort for security!
	if ( m_pFR->GetSFSRedirect () )
	{
		if ( NULL != piStreamOrig )
		{
			piStreamOrig->Release ();
			piStreamOrig = NULL;
		}
		hr = DE_E_ACCESS_DENIED;
	}

	if ( SUCCEEDED ( hr ) )
	{
		ULONG	cbStreamSize	= 0;
		HGLOBAL	hGlob			= NULL;
		STATSTG stat;

		// TriEdit will call GetHGlobalFromStream on the stream, which will fail.
		// We need to recopy it into this process.
		if ((hr = piStreamOrig->Stat(&stat, STATFLAG_NONAME)) == S_OK)
		{
			cbStreamSize = stat.cbSize.LowPart;
			// If the file is empty, create a zero length stream, but the global block must be non-zero in size.
			hGlob = GlobalAlloc ( GHND, ( 0 == cbStreamSize ) ? 2 : cbStreamSize );
			if ( NULL == hGlob )
			{
				DWORD ec = ::GetLastError();
				hr = HRESULT_FROM_WIN32(ec);
			}
			else
			{
				void* pBuff = GlobalLock ( hGlob );
				if ( NULL == pBuff )
				{
					DWORD ec = ::GetLastError();
					hr = HRESULT_FROM_WIN32(ec);
				}
				else
				{
					ULONG	cbBytesRead = 0;

					hr = piStreamOrig->Read ( pBuff, cbStreamSize, &cbBytesRead );
					_ASSERTE ( SUCCEEDED ( hr ) );
					_ASSERTE ( cbBytesRead == cbStreamSize );

					if ( SUCCEEDED ( hr ) )
					{
						// We now have a global to creat a NEW stream from, locally.
						hr = CreateStreamOnHGlobal ( hGlob, TRUE, ppiStream );

						if ( SUCCEEDED ( hr ) )
						{
							// Convert it to Unicode if necessary.  Set SaveAsUnicode so it can be saved properly.
							hr = HrConvertStreamToUnicode ( *ppiStream );
							BOOL bfUnicode = ( S_FALSE == hr );
							if ( SUCCEEDED ( hr ) )
							{
								hr = S_OK;	// the S_FALSE result wouldn't make much sense to caller of this function.
							}
							SetSaveAsUnicode ( bfUnicode );
						}
					}
				}

				GlobalUnlock ( hGlob );
			}

			if ( FAILED ( hr ) && hGlob!=NULL )
			{
				GlobalFree ( hGlob );
			}
			piStreamOrig->Release();
		}
	}
	return hr;
}


//	Post V1.0 change:
//	The stream will now always be Unicode.
//	We should save the file as Unicode only if it was loaded as Unicode from File or URL,
//	otherwise convert to MBCS string.
//
HRESULT
CSite::HrStreamToFile(LPSTREAM pStream, LPCTSTR fileName)
{
	HRESULT	hr				= S_OK;
	HANDLE	hFile			= NULL;
	HGLOBAL hMem			= NULL;
	WCHAR	*pwcData		= NULL;
	DWORD	bytesWritten	= 0;
	BOOL	bResult			= FALSE;
	STATSTG	statStg			= {0};
            
	UINT unCP = GetCurrentCodePage();


        // WINSE BUG 22289: If us-ascii (20127) encoding is used and it's not available on the system,
        // MLang uses 1252 during conversion to Unicode. But it cannot convert to Unicode using 20127. 
        // So callers may fail to do conversion.In this case pretend using 1252.
        if ( unCP == CP_20127 && !IsValidCodePage(CP_20127) )
            unCP = CP_1252;

        hFile = CreateFile(fileName,
			        GENERIC_WRITE,
			        FILE_SHARE_WRITE, 
			        NULL,
			        CREATE_ALWAYS,
			        FILE_ATTRIBUTE_NORMAL,
			        NULL);

        if (INVALID_HANDLE_VALUE == hFile)
        {
	        DWORD ec = ::GetLastError();

	        if ( ERROR_BAD_NETPATH == ec ) ec = ERROR_PATH_NOT_FOUND;
	        hr = HRESULT_FROM_WIN32(ec);
	        return hr;
        }

        if (FAILED(hr = pStream->Stat(&statStg, STATFLAG_NONAME)))
        {
	        _ASSERTE(SUCCEEDED(hr));
	        return hr;
        }

	if (FAILED(hr = GetHGlobalFromStream(pStream, &hMem)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	pwcData = (WCHAR*)GlobalLock(hMem);
	if (NULL == pwcData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		_ASSERTE(pwcData);
		return hr;		
	}

	_ASSERTE ( IsUnicode ( pwcData, statStg.cbSize.LowPart ) );

	// Should it be converted to MBCS?
	if ( GetSaveAsUnicode () )
	{
		bResult = WriteFile(hFile, pwcData, statStg.cbSize.LowPart, &bytesWritten, NULL);
		_ASSERTE(bytesWritten == statStg.cbSize.LowPart);
	}
	else
	{
		UINT cbOrigSize	= statStg.cbSize.LowPart / sizeof ( WCHAR );
		UINT cbNewSize	= 0;
		char *pchTemp	= NULL;

		// Substract one for the byte order mark if it begins the stream.  (It should.)
		if ( StartsWithByteOrderMark ( pwcData ) )
		{
			pwcData++;	// Skip the byte order mark WCHAR
			cbOrigSize--;
		}

		if ( NULL != m_piMLang )
		{
			DWORD dwMode	= 0;

			hr = m_piMLang->ConvertStringFromUnicode ( &dwMode, unCP, pwcData, &cbOrigSize, NULL, &cbNewSize );
			if ( S_FALSE == hr )
			{
				// This indicates that a conversion was not available.  Happens for default CP_ACP if test is typed into new page!
				hr = S_OK;
				goto fallback;
			}

			_ASSERTE ( 0 != cbNewSize );
			if ( SUCCEEDED ( hr ) )
			{
				pchTemp = new char [cbNewSize];
				_ASSERTE ( pchTemp );
				if ( NULL != pchTemp )
				{
					hr = m_piMLang->ConvertStringFromUnicode ( &dwMode, unCP, pwcData, &cbOrigSize, pchTemp, &cbNewSize );
					bResult = WriteFile(hFile, pchTemp, cbNewSize, &bytesWritten, NULL);
					_ASSERTE(bytesWritten == cbNewSize);
					delete [] pchTemp;
				}
			}
		}
		else
		{
fallback:
			cbNewSize = ::WideCharToMultiByte ( unCP, 0, pwcData, cbOrigSize, NULL, 0, NULL, NULL );
			_ASSERTE ( 0 != cbNewSize );
			pchTemp = new char [cbNewSize];
			_ASSERTE ( pchTemp );
			if ( NULL != pchTemp )
			{
				::WideCharToMultiByte ( unCP, 0, pwcData, cbOrigSize, pchTemp, cbNewSize, NULL, NULL );
				bResult = WriteFile(hFile, pchTemp, cbNewSize, &bytesWritten, NULL);
				_ASSERTE(bytesWritten == cbNewSize);
				delete [] pchTemp;
			}
		}
	}


	if (FALSE == bResult)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto cleanup;
	}



cleanup:

	::CloseHandle(hFile);
	// Reference count of hMem not checked here
	// since we can't assume how many times the
	// Stream has locked it
	GlobalUnlock(hMem); 
	return hr;
}


//	Post V1.0 change:
//	The stream is always Unicode now.
//
HRESULT
CSite::HrBstrToStream(BSTR bstrSrc, LPSTREAM* ppStream)
{
	HRESULT hr = S_OK;
	HGLOBAL hMem = NULL;
	ULONG	cbMBStr = 0;
	ULONG	cbBuff = 0;
	LPVOID	pStrDest = NULL;
	LPVOID	pCopyPos = NULL;
	ULARGE_INTEGER ui = {0};

	_ASSERTE(bstrSrc);
	_ASSERTE(ppStream);

	cbMBStr = SysStringLen ( bstrSrc ) * sizeof (OLECHAR);
	cbBuff  = cbMBStr;

	// If the Unicode string does not contain a byte order mark at the beginning, it is
	// misinterpreted by Trident.  When DocumentHTML was set with Japanese text, the
	// BSTR was fed in without the byte order mark and was misinterpreted. (Possibly as UTF-8?)
	// Now, the byte-order mark is prepended to all non-empty strings.

	if ( 2 <= cbMBStr )
	{
		if ( !StartsWithByteOrderMark ( bstrSrc ) )
		{
			cbBuff += 2;	// Reserve space for the byte order mark we'll add.
		}
	}

	// If the file is empty, create a zero length stream, but the global block must be non-zero in size.
	hMem = GlobalAlloc ( GMEM_MOVEABLE|GMEM_ZEROINIT, ( 0 == cbBuff ) ? 2 : cbBuff );

	_ASSERTE(hMem);

	if (NULL == hMem)
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}

	pStrDest = GlobalLock(hMem);

	_ASSERTE(pStrDest);

	if (NULL == pStrDest)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		GlobalFree(hMem);
		goto cleanup;
	}

	// Insert the byte order mark if it is not already there
	pCopyPos = pStrDest;
	if ( cbMBStr != cbBuff )
	{
		InsertByteOrderMark ( pStrDest );
		pCopyPos = &((char*)pCopyPos)[2];	// Advance copy target two bytes.
	}
	memcpy ( pCopyPos, bstrSrc, cbMBStr );
	GlobalUnlock(hMem);

	if (FAILED(hr = CreateStreamOnHGlobal(hMem, TRUE, ppStream)))
	{
		_ASSERTE(SUCCEEDED(hr));
		goto cleanup;
	}

	_ASSERTE(ppStream);

	ui.LowPart = cbBuff;
	ui.HighPart = 0x00;

	hr = (*ppStream)->SetSize(ui);


	_ASSERTE((*ppStream));

cleanup:

	return hr;
}


//	Post V1.0 change:
//	The stream is expected to be in Unicode now.
//	Just copy the contents to a BSTR.
//	Exception: the stream can begin with FFFE (or theoretically FEFF, but then I think we'd be broken.)
//	If the byte order mark begins the stream, don't copy it to the BSTR UNLESS bfRetainByteOrderMark
//	is set.  This should be retained in the case where we're loading an interal BSTR to be returned
//	to the pluggable protocol.  If the byte order mark is missing in that case, IE5 does not properly
//	convert the string.
//
HRESULT
CSite::HrStreamToBstr(LPSTREAM pStream, BSTR* pBstr, BOOL bfRetainByteOrderMark)
{
	HRESULT hr			= S_OK;
	HGLOBAL hMem		= NULL;
	WCHAR	*pwcData	= NULL;
	STATSTG statStg		= {0};

	_ASSERTE(pStream);
	_ASSERTE(pBstr);

	*pBstr = NULL;

	if (FAILED(hr = GetHGlobalFromStream(pStream, &hMem)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	hr = pStream->Stat(&statStg, STATFLAG_NONAME);
	_ASSERTE(SUCCEEDED(hr));

	pwcData = (WCHAR*)GlobalLock(hMem);

	_ASSERTE(pwcData);
	
	if (NULL == pwcData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		return hr;		
	}

	_ASSERTE ( IsUnicode ( pwcData, statStg.cbSize.LowPart ) );

	if ( !bfRetainByteOrderMark && StartsWithByteOrderMark ( pwcData ) )
	{
		pwcData++;	// Skip the first WCHAR
		statStg.cbSize.LowPart -= sizeof(WCHAR);	// This is a byte count rather than a WCHAR count.
	}

	*pBstr = SysAllocStringLen ( pwcData, statStg.cbSize.LowPart / sizeof(WCHAR) );
	
	GlobalUnlock(hMem); 
	return hr;
}


#ifdef _DEBUG_HELPER
static void ExamineStream ( IStream* piStream, char* pchNameOfStream )
{
	HGLOBAL hMem	= NULL;
	LPVOID	pvData	= NULL;
	HRESULT	hr		= S_OK;

	_ASSERTE ( pchNameOfStream );
	hr = GetHGlobalFromStream(piStream, &hMem);
	pvData = GlobalLock ( hMem );
	// Examine *(char*)pvData
	GlobalUnlock ( hMem );
}
#endif


HRESULT
CSite::HrFilter(BOOL bDirection, LPSTREAM pSrcStream, LPSTREAM* ppFilteredStream, DWORD dwFilterFlags)
{
	_ASSERTE(m_pObj);
	_ASSERTE(pSrcStream);
	_ASSERTE(ppFilteredStream);

	HRESULT hr		= S_OK;
	STATSTG statStg	= {0};

	// Test for the exceptional case of an empty stream.  Opening an empyt file can cause this.
	hr = pSrcStream->Stat(&statStg, STATFLAG_NONAME);
	_ASSERTE(SUCCEEDED(hr));

	if ( 0 == statStg.cbSize.HighPart && 0 == statStg.cbSize.LowPart )
	{
		*ppFilteredStream = pSrcStream;
		pSrcStream->AddRef ();
		return S_OK;
	}

	CComQIPtr<ITriEditDocument, &IID_ITriEditDocument> piTriEditDoc(m_pObj);
	CComQIPtr<IStream, &IID_IStream> piFilteredStream;
	DWORD dwTriEditFlags = 0;

#ifdef _DEBUG_HELPER
	ExamineStream ( pSrcStream, "pSrcStream" );
#endif

	if (dwFilterFlags == filterNone)
	{
		pSrcStream->AddRef();
		*ppFilteredStream = pSrcStream;
		return hr;
	}

	// dwTriEditFlags |= dwFilterMultiByteStream; // loading an ANSI Stream NOT ANY MORE.  The stream is ALWAYS Unicode now.

	if (dwFilterFlags & filterDTCs)
		dwTriEditFlags |= dwFilterDTCs;

	if (dwFilterFlags & filterASP)
		dwTriEditFlags |= dwFilterServerSideScripts;

	if (dwFilterFlags & preserveSourceCode)
		dwTriEditFlags |= dwPreserveSourceCode;

	if (dwFilterFlags & filterSourceCode)
		dwTriEditFlags |= filterSourceCode;

	if (!piTriEditDoc)
		return E_NOINTERFACE;

	CComBSTR bstrBaseURL;
	m_pFR->GetBaseURL ( bstrBaseURL );

	if (TRUE == bDirection)
	{
		if (FAILED(hr = piTriEditDoc->FilterIn(pSrcStream, (LPUNKNOWN*) &piFilteredStream, dwTriEditFlags, bstrBaseURL)))
		{
			goto cleanup;
		}
	}
	else
	{
		if (FAILED(hr = piTriEditDoc->FilterOut(pSrcStream, (LPUNKNOWN*) &piFilteredStream, dwTriEditFlags, bstrBaseURL)))
		{
			_ASSERTE(SUCCEEDED(hr));
			goto cleanup;
		}
	}

	*ppFilteredStream = piFilteredStream;

#ifdef _DEBUG_HELPER
	ExamineStream ( *ppFilteredStream, "*ppFilteredStream" );
#endif

	_ASSERTE((*ppFilteredStream));
	if (!(*ppFilteredStream))
	{
		hr = E_NOINTERFACE;
		goto cleanup;
	}

	(*ppFilteredStream)->AddRef();

cleanup:

	return hr;
}



// Attempts to open the file specified by the UNC path
// This method is a crude way of seeing if a given file
// is available and current permissions allow for opening
// Returns:
// S_OK is file is available and it can be opened for reading
// else
// HRESULT containing Win32 facility and error code from ::GetLastError()
HRESULT
CSite::HrTestFileOpen(BSTR path)
{
	USES_CONVERSION;
	HRESULT hr = S_OK;
	LPTSTR pFileName = NULL;
	HANDLE hFile = NULL;

	pFileName = OLE2T(path);

	_ASSERTE(pFileName);

	hFile = CreateFile(
				pFileName,
				GENERIC_READ,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				0,
				NULL);

	if(INVALID_HANDLE_VALUE == hFile)
	{
		DWORD ec = ::GetLastError();

		if ( ERROR_BAD_NETPATH == ec ) ec = ERROR_PATH_NOT_FOUND;
		hr = HRESULT_FROM_WIN32(ec);
	}

	::CloseHandle(hFile);

	return hr;
}


//******************************************************************************************
//
//	Unicode Utilities
//
//	Post V1.0, we changed the internal data format from (unchecked, assumed) MBCS to Unicode.
//	The Stream and associated Trident is always Unicode.
//
//******************************************************************************************


//	This can be called without knowing if the stream is already Unicode or not.
//	Convert stream in place.  Assume the stream is created with CreateStreamOnHGlobal.
//	Convert without using ATL macros.  They give out at about 200KB.
//	If the stream was already Unicode, return S_FALSE.
//
HRESULT CSite::HrConvertStreamToUnicode ( IStream* piStream )
{
	HRESULT hr			= S_OK;
	HGLOBAL hMem		= NULL;
	LPVOID	pbData		= NULL;
	STATSTG statStg		= {0};
	UINT	cwcNewStr	= 0;
	WCHAR	*pwcUnicode	= NULL;

	_ASSERTE(piStream);

	// The stream MUST be created on a global
	if (FAILED(hr = GetHGlobalFromStream(piStream, &hMem)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	hr = piStream->Stat(&statStg, STATFLAG_NONAME);
	_ASSERTE(SUCCEEDED(hr));

	if ( 0 == statStg.cbSize.HighPart && 4 > statStg.cbSize.LowPart )
	{
		return S_FALSE;	// If it's not even four bytes long, leave as is.
	}

	pbData = GlobalLock(hMem);

	_ASSERTE(pbData);
	
	if (NULL == pbData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		return hr;		
	}

	// If the stream was already Unicode, do nothing!
	if ( IsUnicode ( pbData, statStg.cbSize.LowPart ) )
	{
		hr = S_FALSE;
		goto exit;
	}
	
	// If IMultilanguage2 is available, try to determine its code page.
	if ( NULL != m_piMLang )
	{
		DetectEncodingInfo	rdei[8];
		int					nScores		= 8;
		DWORD				dwMode		= 0;
		UINT				uiInSize	= statStg.cbSize.LowPart;
		HRESULT				hrCharset	= E_FAIL;

		// Check to see if there's an embedded META charset tag.
		// Only if the appropriate TriEdit is installed will this work.
		// We need access to MLang to make sense out of the result, too.
		_ASSERTE ( m_pObj );
		CComQIPtr<ITriEditExtendedAccess, &IID_ITriEditExtendedAccess> pItex ( m_pObj );
		if ( pItex )
		{
			CComBSTR	bstrCodePage;

			hrCharset = pItex->GetCharsetFromStream ( piStream, &bstrCodePage );
			
			// If "Unicode" is returned, it's got to be bogus.
			// We would have mangled Unicode in the initial translation.
			// This turns out to be a not-so-rare special case.  Outlook produced such files.
			if ( S_OK == hrCharset )
			{
				MIMECSETINFO	mcsi;

				if ( 0 == _wcsicmp ( L"unicode", bstrCodePage ) )
				{
					hrCharset = S_FALSE;
				}
				else
				{
					hrCharset = m_piMLang->GetCharsetInfo ( bstrCodePage, &mcsi );
					if ( SUCCEEDED ( hrCharset ) )
					{
						m_cpCodePage = mcsi.uiInternetEncoding;
					}
				}
			}
			
		}

		// If we found the charset via GetCharsetFromStream, don't use MLang.
		if ( S_OK != hrCharset )
		{

			hr = m_piMLang->DetectCodepageInIStream ( MLDETECTCP_HTML, 0, piStream, rdei, &nScores );

			if ( FAILED ( hr ) )
			{
				goto fallback;	// Use default ANSI code page
			}

			m_cpCodePage = rdei[0].nCodePage;
		}

		hr = m_piMLang->ConvertStringToUnicode ( &dwMode, m_cpCodePage, (char*)pbData, &uiInSize, NULL, &cwcNewStr );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( S_OK != hr )	// S_FALSE for conversion not supported (no such language pack), E_FAIL for internal error.
		{
			goto fallback;	// Use default ANSI code page
		}

		// Create the buffer to convert to.
		pwcUnicode = new WCHAR[cwcNewStr+1];	// One extra character for the byte order mark.
		_ASSERTE ( pwcUnicode );
		if ( NULL == pwcUnicode )
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		InsertByteOrderMark ( pwcUnicode );

		hr = m_piMLang->ConvertStringToUnicode ( &dwMode, m_cpCodePage, (char*)pbData, &uiInSize, &pwcUnicode[1], &cwcNewStr );
		_ASSERTE ( SUCCEEDED ( hr ) );
		if ( S_OK != hr )	// S_FALSE for conversion not supported (no such language pack), E_FAIL for internal error.
		{
			delete [] pwcUnicode;	// This will be reallocated.
			pwcUnicode = NULL;
			goto fallback;	// Use default ANSI code page
		}
	}
	else
	{
fallback:	// If we attempt to use MLang but fail, we must STILL convert to Unicode...

		// Set code page to default:
		m_cpCodePage = CP_ACP;

		// Count how many wide characters are required:
		cwcNewStr = ::MultiByteToWideChar(GetCurrentCodePage (), 0, (char*)pbData, statStg.cbSize.LowPart, NULL, 0);
		_ASSERTE ( 0 != cwcNewStr );
		if ( 0 == cwcNewStr )
		{
#ifdef _DEBUG
			DWORD dwError = GetLastError ();
			_ASSERTE ( 0 == dwError );
#endif
			goto exit;
		}

		// Create the buffer to convert to.
		pwcUnicode = new WCHAR[cwcNewStr+1];	// One extra character for the byte order mark.
		_ASSERTE ( pwcUnicode );
		if ( NULL == pwcUnicode )
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		InsertByteOrderMark ( pwcUnicode );

		// Create the wide string.  Write starting at position [1], preserving the byte order character.
		cwcNewStr = ::MultiByteToWideChar(GetCurrentCodePage (), 0, (char*)pbData, statStg.cbSize.LowPart, &pwcUnicode[1], cwcNewStr);
		if ( 0 == cwcNewStr )
		{
#ifdef _DEBUG
			DWORD dwError = GetLastError ();
			_ASSERTE ( 0 == dwError );
#endif
			goto exit1;
		}
	}

	// We've successfully read the data in, now replace the stream.  pwcUnicode contains the data.
	ULARGE_INTEGER ui;
	ui.LowPart = (cwcNewStr+1) * 2;	// + 1 for the byte order mark at the beginning.
	ui.HighPart = 0x00;
	hr = piStream->SetSize ( ui );
	_ASSERTE ( SUCCEEDED ( hr ) );
	if ( SUCCEEDED ( hr ) )
	{
		GlobalUnlock(hMem);
		pbData = GlobalLock(hMem);
		memcpy ( pbData, pwcUnicode, (cwcNewStr+1) * 2 );	// Copy string + byte order mark

		// Reposition the mark to the beginning of the stream
		LARGE_INTEGER	liIn	= {0};
		ULARGE_INTEGER	uliOut	= {0};
		piStream->Seek ( liIn, STREAM_SEEK_SET, &uliOut );
	}

exit1:
	delete [] pwcUnicode;

exit:
	GlobalUnlock(hMem);
	return hr;
}



//	Test the buffer to see if it contains a Unicode string.  It's assumed to if:
//	It starts with the byte order marker FFFE or
//	It contains NULL bytes before the last four bytes.
//	If it's less than or equal to four bytes, do not consider it Unicode.
//
BOOL CSite::IsUnicode ( void* pData, int cbSize )
{
	BOOL	bfUnicode	= FALSE;
	CHAR	*pchData	= (CHAR*)pData;

	if ( 4 < cbSize )
	{

	#pragma warning(disable: 4310) // cast truncates constant value
		if ( ( (char)0xff == pchData[0] ) && ( (char)0xfe == pchData[1] ) )
			bfUnicode = TRUE;
		if ( ( (char)0xfe == pchData[0] ) && ( (char)0xff == pchData[1] ) )
	#pragma warning(default: 4310) // cast truncates constant value
		{
			// Reverse order Unicode?  Will this be encountered?
			_ASSERTE ( ! ( (char)0xfe == pchData[0] ) && ( (char)0xff == pchData[1] ) );
			bfUnicode = FALSE;
		}

		if ( ! bfUnicode )
		{
			bfUnicode = FALSE;

			for ( int i = 0; i < cbSize - 4; i++ )
			{
				if ( 0 == pchData[i] )
				{
					bfUnicode = TRUE;
					break;
				}
			}
		}
	}
	return bfUnicode;
}


//	Given a buffer of characters, detect whether its a BigEndian Unicode stream by the first word (FEFF).
//	If not, return FALSE.
//	If so, flip all words to LittleEndian order (FFFE) and return true.
//	Note: this is a storage convention, not an encoding.  This may be encountered in disk files, not in downloads.
//	A Unicode stream should contain an even number of bytes!  If not, we'll assert, but continue.
//
BOOL CSite::BfFlipBytesIfBigEndianUnicode ( CHAR* pchData, int cbSize )
{
	_ASSERTE ( pchData );

	// See if it's Unicode stored in reverse order.
#pragma warning(disable: 4310) // cast truncates constant value
	if ( ( (CHAR)0xFE == pchData[0] ) && ( (CHAR)0xFF == pchData[1] ) )
#pragma warning(default: 4310) // cast truncates constant value
	{
		// A Unicode stream must contain an even number of characters.
		_ASSERTE ( 0 != ( cbSize & 1 ) );

		// This stream is populated with reversed Unicode.  Flip it in place.
		// Subtract 1 from initial byte count to avoid overrunning odd length buffer.
		CHAR chTemp = '\0';
		for ( int iPos = 0; iPos < cbSize - 1; iPos += 2 )
		{
			chTemp = pchData[iPos];
			pchData[iPos] = pchData[iPos+1];
			pchData[iPos+1] = chTemp;
		}
		return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\dispatch.h ===
/*

    File: Dispatch.h

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:
        Dispatch helpers.

*/

//  Defines

#define VTS_I2              "\x02"
#define VTS_I4              "\x03"
#define VTS_BSTR            "\x08"
#define VTS_DISPATCH        "\x09"
#define VTS_BOOL            "\x0b"
#define VTS_VARIANT         "\x0c"
#define VTS_UNKNOWN         "\x0d"

#define VTS_I2_BYREF        "\x42"
#define VTS_I4_BYREF        "\x43"
#define VTS_BSTR_BYREF      "\x48"
#define VTS_DISPATCH_BYREF  "\x49"
#define VTS_BOOL_BYREF      "\x4b"
#define VTS_VARIANT_BYREF   "\x4c"
#define VTS_UNKNOWN_BYREF   "\x4d"

#define VTS_I2_RETURN       "\x82"
#define VTS_I4_RETURN       "\x83"
#define VTS_BSTR_RETURN     "\x88"
#define VTS_DISPATCH_RETURN "\x89"
#define VTS_BOOL_RETURN     "\x8b"
#define VTS_UNKNOWN_RETURN  "\x8d"

#define VTS_BYREF_FLAG      0x40
#define VTS_RETURN_FLAG     0x80


// Functions

HRESULT         CallDispatchMethod(
                        IDispatch * pDisp,
                        DISPID dispid,
                        VARIANT * pvarFirst,
                        char * pstrSig,
                        va_list val);

HRESULT __cdecl CallDispatchMethod(
                        IDispatch * pDisp,
                        DISPID dispid,
                        char * pstrSig,
                        ...);

HRESULT         CallDispatchMethod(
                        IDispatch * pDisp,
                        WCHAR * pstrMethod,
                        VARIANT * pvarFirst,
                        char * pstrSig,
                        va_list val);

HRESULT __cdecl CallDispatchMethod(
                        IDispatch * pDisp,
                        WCHAR * pstrMethod,
                        char * pstrSig,
                        ...);

HRESULT __cdecl CallDispatchMethod(
                        IDispatch * pDisp,
                        WCHAR * pstrMethod,
                        VARIANT * pvarFirst,
                        char * pstrSig,
                        ...);

HRESULT         GetDispatchProperty(
                        IDispatch * pDisp,
                        WCHAR * pstrProperty,
                        VARENUM vt,
                        void * pv);

HRESULT         GetDispatchProperty(
                        IDispatch * pDisp,
                        DISPID dispidProperty,
                        VARENUM vt,
                        void * pv);

HRESULT __cdecl PutDispatchProperty(
                        IDispatch * pDisp,
                        WCHAR * pstrProperty,
                        VARENUM vt,
                        ...);

HRESULT __cdecl PutDispatchProperty(
                        IDispatch * pDisp,
                        DISPID dispidProperty,
                        VARENUM vt,
                        ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\document.cpp ===
// Document.cpp : Implementation of CTriEditDocument
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"

#include "triedit.h"
#include "Document.h"
#include "util.h"

#ifdef IE5_SPACING
#include "dispatch.h"
#include <mshtmdid.h>
#include <mshtmcid.h>
#endif //IE5_SPACING

/////////////////////////////////////////////////////////////////////////////
// CTriEditDocument

CTriEditDocument::CTriEditDocument()
{
    m_pUnkTrident = NULL;
    m_pOleObjTrident = NULL;
    m_pCmdTgtTrident = NULL;
    m_pDropTgtTrident = NULL;
#ifdef IE5_SPACING
    m_pTridentPersistStreamInit = NULL;
    m_pMapArray = NULL;
    m_hgMap = NULL;
    m_pspNonDSP = NULL;
    m_hgSpacingNonDSP = NULL;
    m_ichspNonDSPMax = 0;
    m_ichspNonDSP = 0;
#endif //IE5_SPACING

    m_pClientSiteHost = NULL;
    m_pUIHandlerHost = NULL;
    m_pDragDropHandlerHost = NULL;

    m_pUIHandler = NULL;

    m_pTokenizer = NULL;
    m_hwndTrident = NULL;

    m_fUIHandlerSet = FALSE;
    m_fInContextMenu = FALSE;

    m_fDragRectVisible = FALSE;
    m_fConstrain = FALSE;
    m_f2dDropMode = FALSE;
    m_eDirection = CONSTRAIN_NONE;
    m_ptAlign.x = 1;
    m_ptAlign.y = 1;
    m_pihtmlElement = NULL;
    m_pihtmlStyle = NULL;
    m_hbrDragRect = NULL;
    m_fLocked = FALSE;
    m_hgDocRestore = NULL;
}

HRESULT CTriEditDocument::FinalConstruct()
{
    HRESULT hr;
    IUnknown *pUnk = GetControllingUnknown();

    hr = CoCreateInstance(CLSID_HTMLDocument, pUnk, CLSCTX_INPROC_SERVER,
               IID_IUnknown, (void**)&m_pUnkTrident);

    if (SUCCEEDED(hr)) 
    {
        _ASSERTE(NULL != m_pUnkTrident);

                // When we cache Trident pointers, we do a GetControllingUnknown()->Release()
                // since the addref will increment our outer unknown pointer and not Trident
                // We compensate for this by doing a corresponding GetControllingUnknown()->AddRef()
                // in our FinalRelease.  Though these cancel out, it is necessary to do this in order
                // to ensure that our FinalRelease will get called.

        // Cache Trident's IOleObject pointer

        hr = m_pUnkTrident->QueryInterface(IID_IOleObject, (void **)&m_pOleObjTrident);
        _ASSERTE(S_OK == hr && NULL != m_pOleObjTrident);
        pUnk->Release();

        // Cache Trident's IOleCommandTarget pointer

        hr = m_pUnkTrident->QueryInterface(IID_IOleCommandTarget, (void **)&m_pCmdTgtTrident);
        _ASSERTE(S_OK == hr && NULL != m_pCmdTgtTrident);
        pUnk->Release();

        // Allocate UI handler sub-object
        m_pUIHandler = new CTriEditUIHandler(this);
        if (NULL == m_pUIHandler)
            hr = E_OUTOFMEMORY;

#ifdef IE5_SPACING
        // Get IPersistStreamInit
        hr = m_pUnkTrident->QueryInterface(IID_IPersistStreamInit, (void **) &m_pTridentPersistStreamInit);
        _ASSERTE(S_OK == hr && NULL != m_pTridentPersistStreamInit);
        pUnk->Release(); // PuruK - REVIEW Why do we need to do this?
        SetFilterInDone(FALSE);
#endif //IE5_SPACING

        // Allocate buffer for saving document's contents before <BODY> tag
        // Trident replaces all content before <BODY> tag by its own header
        m_hgDocRestore = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbHeader);
        if (NULL == m_hgDocRestore)
        {
            delete m_pUIHandler;
            hr = E_OUTOFMEMORY;
        }

    }

    _ASSERTE(SUCCEEDED(hr));

    return hr;
}

void CTriEditDocument::FinalRelease()
{
    IUnknown *pUnk = GetControllingUnknown();

    // Release host interface pointers
    SAFERELEASE(m_pClientSiteHost);
    SAFERELEASE(m_pUIHandlerHost);
    SAFERELEASE(m_pDragDropHandlerHost);

    // Release internal interface pointers
    SAFERELEASE(m_pTokenizer);

    // Release 2d drop related pointers
    ReleaseElement();
    
    // Release Trident interface pointers
    SAFERELEASE(m_pDropTgtTrident);

    pUnk->AddRef();
    SAFERELEASE(m_pOleObjTrident);
    pUnk->AddRef();
    SAFERELEASE(m_pCmdTgtTrident);
#ifdef IE5_SPACING
    pUnk->AddRef(); // REVIEW - PuruK - Why do we need to do this?
    SAFERELEASE(m_pTridentPersistStreamInit);
#endif //IE5_SPACING

    SAFERELEASE(m_pUnkTrident);

    // Delete UI handler sub-object
    if (m_pUIHandler != NULL)
    {
        // Assert that the ref count on the sub-object is 1
        // If this isn't 1, then Trident is holding on to this pointer
        _ASSERTE(m_pUIHandler->m_cRef == 1);
        delete m_pUIHandler;
    }

    if (m_hgDocRestore != NULL)
    {
        GlobalUnlock(m_hgDocRestore);
        GlobalFree(m_hgDocRestore);
    }

#ifdef IE5_SPACING
    if (m_hgMap != NULL)
    {
        GlobalUnlock(m_hgMap);
        GlobalFree(m_hgMap);
        m_hgMap = NULL;
    }
    if (m_hgSpacingNonDSP != NULL)
    {
        GlobalUnlock(m_hgSpacingNonDSP);
        GlobalFree(m_hgSpacingNonDSP);
        m_hgSpacingNonDSP = NULL;
    }
#endif
}

#ifdef IE5_SPACING
void CTriEditDocument::FillUniqueID(BSTR bstrUniqueID, BSTR bstrDspVal, int ichNonDSP, MAPSTRUCT *pMap, int iMapCur, BOOL fLowerCase, int iType)
{
    memcpy((BYTE *)pMap[iMapCur].szUniqueID, (BYTE *)bstrUniqueID, min(wcslen(bstrUniqueID), cchID)*sizeof(WCHAR));
    if (iType == INDEX_DSP)
    {
        memcpy((BYTE *)pMap[iMapCur].szDspID, (BYTE *)bstrDspVal, min(wcslen(bstrDspVal), cchID)*sizeof(WCHAR));
        _ASSERTE(ichNonDSP == -1);
        pMap[iMapCur].ichNonDSP = ichNonDSP;
    }
    else if (iType == INDEX_COMMENT)
    {
        pMap[iMapCur].ichNonDSP = ichNonDSP;
    }
    else if (iType == INDEX_AIMGLINK)
    {
        memcpy((BYTE *)pMap[iMapCur].szDspID, (BYTE *)bstrDspVal, min(wcslen(bstrDspVal), cchID)*sizeof(WCHAR));
        pMap[iMapCur].ichNonDSP = ichNonDSP;
    }
    else if (iType == INDEX_OBJ_COMMENT)
    {
        pMap[iMapCur].ichNonDSP = ichNonDSP;
    }
    else
        _ASSERTE(FALSE);
    pMap[iMapCur].fLowerCase = fLowerCase;
    _ASSERTE(iType >= INDEX_NIL && iType < INDEX_MAX);
    pMap[iMapCur].iType = iType;
}

BOOL CTriEditDocument::FGetSavedDSP(BSTR bstrUniqueID, BSTR *pbstrDspVal, int *pichNonDSP, MAPSTRUCT *pMap, BOOL *pfLowerCase, int *pIndex)
{
    BOOL fRet = FALSE;
    int i;

    // TODO - find a faster way than this linear search...
    for (i = 0; i < m_iMapCur; i++)
    {
        if (0 == _wcsnicmp(pMap[i].szUniqueID, bstrUniqueID, wcslen(bstrUniqueID)))
        {
            fRet = TRUE;
            if (pMap[i].iType == INDEX_DSP)
            {
                *pbstrDspVal = SysAllocString(pMap[i].szDspID);
                *pichNonDSP = -1;
            }
            else if (pMap[i].iType == INDEX_COMMENT)
            {
                *pbstrDspVal = (BSTR)NULL;
                *pichNonDSP = pMap[i].ichNonDSP;
            }
            else if (pMap[i].iType == INDEX_AIMGLINK)
            {
                *pbstrDspVal = SysAllocString(pMap[i].szDspID);
                *pichNonDSP = pMap[i].ichNonDSP;
                _ASSERTE(*pichNonDSP != -1);
            }
            else if (pMap[i].iType == INDEX_OBJ_COMMENT)
            {
                *pbstrDspVal = (BSTR)NULL;
                *pichNonDSP = pMap[i].ichNonDSP;
                _ASSERTE(*pichNonDSP != -1);
            }
            *pfLowerCase = pMap[i].fLowerCase;
            *pIndex = pMap[i].iType;

            goto LRet;
        }
    }

LRet:
    return(fRet);
}

void 
CTriEditDocument::FillNonDSPData(BSTR pOuterTag)
{
    int len = 0;

    _ASSERTE(m_ichspNonDSPMax != -1);
    _ASSERTE(m_ichspNonDSP != -1);
    _ASSERTE(m_hgSpacingNonDSP != NULL);
    _ASSERTE(m_pspNonDSP != NULL);

    // even if pOuterTag is NULL, we still need to store the fact that we have
    // zero bytes of data.
    if (pOuterTag != NULL)
        len = wcslen(pOuterTag);

    if ((int)(m_ichspNonDSP + len + sizeof(int)) > m_ichspNonDSPMax)
    {
        HGLOBAL hgSpacingNonDSP;

        //reallocate & set m_ichspNonDSPMax
        GlobalUnlock(m_hgSpacingNonDSP);
        hgSpacingNonDSP = m_hgSpacingNonDSP;
#pragma prefast(suppress: 308, "noise")
        m_hgSpacingNonDSP = GlobalReAlloc(m_hgSpacingNonDSP, (m_ichspNonDSP + len + sizeof(int)+MIN_SP_NONDSP)*sizeof(WCHAR), GMEM_MOVEABLE|GMEM_ZEROINIT);
        // if this alloc failed, we may still want to continue
        if (m_hgSpacingNonDSP == NULL)
        {
            GlobalFree(hgSpacingNonDSP);
            goto LRet;
        }
        else
        {
            m_pspNonDSP = (WCHAR *)GlobalLock(m_hgSpacingNonDSP);
            _ASSERTE(m_pspNonDSP != NULL);
            m_ichspNonDSPMax = (m_ichspNonDSP + len + sizeof(int)+MIN_SP_NONDSP);
        }
        _ASSERTE(m_ichspNonDSP < m_ichspNonDSPMax);
    }

    memcpy((BYTE *)(m_pspNonDSP+m_ichspNonDSP), (BYTE *)&len, sizeof(int));
    m_ichspNonDSP += sizeof(int)/sizeof(WCHAR);
    memcpy((BYTE *)(m_pspNonDSP+m_ichspNonDSP), (BYTE *)pOuterTag, len*sizeof(WCHAR));
    m_ichspNonDSP += len;

LRet:
    return;

}

void 
CTriEditDocument::ReSetinnerHTMLComment(IHTMLCommentElement *pCommentElement, IHTMLElement* /*pElement*/, int ichspNonDSP)
{
    WCHAR *pStrComment = NULL;
//#ifdef DEBUG
//  CComBSTR bstrOuter, bstrOuterBefore;
//#endif //DEBUG
    int cchComment = 0;

    // get the ich, get the saved comment, set it
    memcpy((BYTE *)&cchComment, (BYTE *)(m_pspNonDSP+ichspNonDSP), sizeof(int));
    _ASSERTE(cchComment > 0);
//#ifdef DEBUG
//  pElement->get_outerHTML(&bstrOuterBefore);
//#endif //DEBUG
    pStrComment = new WCHAR[cchComment + 1];
    if (pStrComment == NULL)
		return;

    memcpy((BYTE *)pStrComment, (BYTE *)(m_pspNonDSP+ichspNonDSP+sizeof(int)/sizeof(WCHAR)), cchComment*sizeof(WCHAR));
    pStrComment[cchComment] = '\0';
    pCommentElement->put_text((BSTR)pStrComment);
//#ifdef DEBUG
//  pElement->get_outerHTML(&bstrOuter);
//#endif //DEBUG
    if (pStrComment)
        delete pStrComment;
//#ifdef DEBUG
//  bstrOuter.Empty();
//  bstrOuterBefore.Empty();
//#endif //DEBUG

}

void 
CTriEditDocument::SetinnerHTMLComment(IHTMLCommentElement *pCommentElement, IHTMLElement* /*pElement*/, BSTR pOuterTag)
{
    WCHAR *pStr = NULL;
    WCHAR *pStrComment = NULL;
    LPCWSTR rgComment[] =
    {
        L"TRIEDITPRECOMMENT-",
        L"-->",
        L"<!--",
    };
//#ifdef DEBUG
//  CComBSTR bstrOuter, bstrInnerBefore, bstrInnerAfter, bstrOuterBefore;
//#endif //DEBUG

    // special case - 
    // send pOuterTag as NULL, if we want to get rid of the comment completely
    if (pOuterTag == NULL)
    {
        pCommentElement->put_text((BSTR)pOuterTag);
        goto LRet;
    }

    //remove the TRIEDITCOMMENT stuff from pOuterTag and set the outerHTML properly
    pStr = wcsstr(pOuterTag, rgComment[0]);
    if (pStr != NULL)
    {
        pStrComment = new WCHAR[wcslen(pOuterTag)-(SAFE_PTR_DIFF_TO_INT(pStr-pOuterTag)+wcslen(rgComment[0]))+wcslen(rgComment[1])+wcslen(rgComment[2])+1];
        if (pStrComment != NULL)
        {
            memcpy( (BYTE *)pStrComment, 
                    (BYTE *)(rgComment[2]),
                    (wcslen(rgComment[2]))*sizeof(WCHAR)
                    );
            memcpy( (BYTE *)(pStrComment+wcslen(rgComment[2])), 
                    (BYTE *)(pStr+wcslen(rgComment[0])),
                    (wcslen(pOuterTag)-(SAFE_PTR_DIFF_TO_INT(pStr-pOuterTag)+wcslen(rgComment[0]))-wcslen(rgComment[1]))*sizeof(WCHAR)
                    );
            memcpy( (BYTE *)(pStrComment+wcslen(rgComment[2])+wcslen(pOuterTag)-(pStr-pOuterTag+wcslen(rgComment[0]))-wcslen(rgComment[1])),
                    (BYTE *)(rgComment[1]),
                    (wcslen(rgComment[1]))*sizeof(WCHAR)
                    );
            pStrComment[wcslen(pOuterTag)-(pStr-pOuterTag+wcslen(rgComment[0]))-wcslen(rgComment[1])+wcslen(rgComment[1])+wcslen(rgComment[2])] = '\0';
//#ifdef DEBUG
//          pElement->get_innerHTML(&bstrInnerBefore);
//          pElement->get_outerHTML(&bstrOuterBefore);
//#endif //DEBUG
            pCommentElement->put_text((BSTR)pStrComment);
//#ifdef DEBUG
//          pElement->get_outerHTML(&bstrOuter);
//          pElement->get_innerHTML(&bstrInnerAfter);
//#endif //DEBUG
            delete pStrComment;
        }
    }
LRet:
//#ifdef DEBUG
//  bstrOuter.Empty(); 
//  bstrInnerBefore.Empty();
//  bstrInnerAfter.Empty();
//  bstrOuterBefore.Empty();
//#endif //DEBUG
    return;
}

void
CTriEditDocument::RemoveEPComment(IHTMLObjectElement *pObjectElement, BSTR bstrAlt, 
                                  int cch, BSTR *pbstrAltComment, BSTR *pbstrAltNew)
{
    int ich = 0;
    WCHAR *pAltNew = NULL;
    WCHAR *pStrAlt = bstrAlt;
    WCHAR *pStr = NULL;
    WCHAR *pStrEnd = NULL;
    WCHAR *pStrComment = NULL;
    LPCWSTR rgComment[] =
    {
        L"<!--ERRORPARAM",
        L"ERRORPARAM-->",
    };

    if (bstrAlt == (BSTR)NULL || pObjectElement == NULL)
        return;

    // look for ERRORPARAM
    pStr = wcsstr(bstrAlt, rgComment[0]);
    pStrEnd = wcsstr(bstrAlt, rgComment[1]);
    if (pStr != NULL && pStrEnd != NULL)
    {
        pStrEnd += wcslen(rgComment[1]);
        pStrComment = new WCHAR[SAFE_PTR_DIFF_TO_INT(pStrEnd-pStr)+1];
        if (pStrComment == NULL)
            goto LRetNull;
        memcpy((BYTE *)pStrComment, (BYTE *)pStr, SAFE_PTR_DIFF_TO_INT(pStrEnd-pStr)*sizeof(WCHAR));
        pStrComment[pStrEnd-pStr] = '\0';
        *pbstrAltComment = SysAllocString(pStrComment);
        delete pStrComment;

        pAltNew = new WCHAR[cch+1]; // max size
        if (pAltNew == NULL)
            goto LRetNull;
        // remove stuff from pStr till pStrEnd & copy into *pbstrAltNew
        if (pStr > pStrAlt)
        {
            memcpy((BYTE *)pAltNew, (BYTE *)pStrAlt, SAFE_PTR_DIFF_TO_INT(pStr-pStrAlt)*sizeof(WCHAR));
            ich += SAFE_PTR_DIFF_TO_INT(pStr-pStrAlt);
        }
        if ((pStrAlt+cch)-pStrEnd > 0)
        {
            memcpy((BYTE *)(pAltNew+ich), (BYTE *)pStrEnd, SAFE_PTR_DIFF_TO_INT((pStrAlt+cch)-pStrEnd)*sizeof(WCHAR));
            ich += SAFE_PTR_DIFF_TO_INT((pStrAlt+cch)-pStrEnd);
        }
        pAltNew[ich] = '\0';
        *pbstrAltNew = SysAllocString(pAltNew);
        delete pAltNew;
    }
    else
    {
LRetNull:
		*pbstrAltNew = (bstrAlt) ? SysAllocString(bstrAlt) : (BSTR)NULL;
        *pbstrAltComment = (BSTR)NULL;
    }

} /* CTriEditDocument::RemoveEPComment() */

HRESULT 
CTriEditDocument::SetObjectComment(IHTMLObjectElement *pObjectElement, BSTR bstrAltNew)
{
    HRESULT hr;

    _ASSERTE(pObjectElement != NULL);
    hr = pObjectElement->put_altHtml(bstrAltNew);
    return(hr);

} /* CTriEditDocument::SetObjectComment() */

void
CTriEditDocument::AppendEPComment(IHTMLObjectElement *pObjectElement, int ichspNonDSP)
{
    CComBSTR bstrAltNew;
    int cch;
    WCHAR *pStrSaved = NULL;
    HRESULT hr;
    
    // get current altHtml from the tree
    hr = pObjectElement->get_altHtml(&bstrAltNew);
    if (hr != S_OK || bstrAltNew == (BSTR)NULL)
        goto LRet;
    
    // get saved altHtml in m_pspNonDSP
    memcpy((BYTE *)&cch, (BYTE *)(m_pspNonDSP+ichspNonDSP), sizeof(int));
    if (cch <= 0)
        goto LRet;
    pStrSaved = new WCHAR[cch + 1];
    if (pStrSaved == NULL)
        goto LRet;
    memcpy((BYTE *)pStrSaved, (BYTE *)(m_pspNonDSP+ichspNonDSP+sizeof(int)/sizeof(WCHAR)), cch*sizeof(WCHAR));
    pStrSaved[cch] = '\0';
    
    // append saved altHtml
    bstrAltNew += pStrSaved;

    // save it back in the tree
    hr = pObjectElement->put_altHtml(bstrAltNew);
    if (pStrSaved)
        delete pStrSaved;

LRet:
    return;
} /* CTriEditDocument::AppendEPComment() */


void 
CTriEditDocument::MapUniqueID(BOOL fGet)
{
    CComPtr<IHTMLDocument2> pHTMLDoc;
    CComPtr<IHTMLElementCollection> pHTMLCollection;
    CComPtr<IDispatch> pDispControl;
    CComPtr<IHTMLElement> pElement;
    CComPtr<IHTMLUniqueName> pUniqueName;
    CComPtr<IHTMLCommentElement> pCommentElement;
    CComPtr<IHTMLObjectElement> pObjectElement;

    HRESULT hr;
    //CComBSTR bstrUniqueID;
    WCHAR *pAttr = NULL;
    WCHAR *pAttrL = NULL;
    WCHAR *pAttrDSU = NULL;
    long len;
    int i;
    LPCWSTR szDSP[] =
    {
        L"DESIGNTIMESP",
        L"designtimesp",
        L"DESIGNTIMEURL",
    };
    LPCWSTR szComment[] =
    {
        L"<!--TRIEDITCOMMENT",
        L"<!--ERRORPARAM",
        L"<!--ERROROBJECT",
    };
    VARIANT var, vaName, vaIndex;

    if (!IsIE5OrBetterInstalled())
        goto LRet;

    pHTMLDoc = NULL;
    hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void **) &pHTMLDoc);
    if (hr != S_OK)
        goto LRet;


    pHTMLDoc->get_all(&pHTMLCollection);
    if (hr != S_OK)
        goto LRet;

    pAttr = new WCHAR[wcslen(szDSP[0])+1];
    memcpy((BYTE *)pAttr, (BYTE *)szDSP[0], wcslen(szDSP[0])*sizeof(WCHAR));
    pAttr[wcslen(szDSP[0])] = '\0';
    pAttrL = new WCHAR[wcslen(szDSP[1])+1];
    memcpy((BYTE *)pAttrL, (BYTE *)szDSP[1], wcslen(szDSP[1])*sizeof(WCHAR));
    pAttrL[wcslen(szDSP[1])] = '\0';
    pAttrDSU = new WCHAR[wcslen(szDSP[2])+1];
    memcpy((BYTE *)pAttrDSU, (BYTE *)szDSP[2], wcslen(szDSP[2])*sizeof(WCHAR));
    pAttrDSU[wcslen(szDSP[2])] = '\0';

    pHTMLCollection->get_length(&len);

    if (len == 0)
        goto LRet;

    if (!fGet)
    {
        // now we know that we atleast have one element, lets allocate space for saving
        // UniqueID's & designtimesp's
        if (m_pMapArray == NULL) // this is the first time we are here
        {
            _ASSERTE(m_hgMap == NULL);
            m_hgMap = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, MIN_MAP*sizeof(MAPSTRUCT));
            if (m_hgMap == NULL)
                goto LRet;
            m_cMapMax = MIN_MAP;
        }
        _ASSERTE(m_hgMap != NULL);
        m_pMapArray = (MAPSTRUCT *) GlobalLock(m_hgMap);
        _ASSERTE(m_pMapArray != NULL);
        // even if we allocate the space for m_hgMap here or not, we should start from 0
        m_iMapCur = 0;
        // zeroise the array
        memset((BYTE *)m_pMapArray, 0, m_cMapMax*sizeof(MAPSTRUCT));
        
        if (m_pspNonDSP == NULL) // this is the first time we are here
        {
            _ASSERTE(m_hgSpacingNonDSP == NULL);
            m_hgSpacingNonDSP = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, MIN_SP_NONDSP*sizeof(WCHAR));
            if (m_hgSpacingNonDSP == NULL)
                goto LRet;
            m_ichspNonDSPMax = MIN_SP_NONDSP;
        }
        _ASSERTE(m_hgSpacingNonDSP != NULL);
        m_pspNonDSP = (WCHAR *) GlobalLock(m_hgSpacingNonDSP);
        _ASSERTE(m_pspNonDSP != NULL);
        // even if we allocate the space for m_hgSpacingNonDSP here or not, we should start from 0
        m_ichspNonDSP = 0;
        // zeroise the array
        memset((BYTE *)m_pspNonDSP, 0, m_ichspNonDSPMax*sizeof(WCHAR));
    }
    else // if (fGet)
    {
        if (m_iMapCur < 1) // we don't have any mappings saved
            goto LRet;
        m_pMapArray = (MAPSTRUCT *)GlobalLock(m_hgMap);
        _ASSERTE(m_pMapArray != NULL);

        m_pspNonDSP = (WCHAR *)GlobalLock(m_hgSpacingNonDSP);
        _ASSERTE(m_pspNonDSP != NULL);
    }

    // loop through all the elemets and fill m_pMapArray
    for (i = 0; i < len; i++)
    {
        VARIANT_BOOL fSuccess;

        if (!fGet)
        {
            // reallocate m_hgMap if needed
            if (m_iMapCur == m_cMapMax - 1)
            {
                HGLOBAL hgMap;
                GlobalUnlock(m_hgMap);
                hgMap = m_hgMap;
#pragma prefast(suppress:308, "noise")
                m_hgMap = GlobalReAlloc(m_hgMap, (m_cMapMax+MIN_MAP)*sizeof(MAPSTRUCT), GMEM_MOVEABLE|GMEM_ZEROINIT);
                // if this alloc failed, we may still want to continue
                if (m_hgMap == NULL)
                {
                    GlobalFree(hgMap);
                    goto LRet;
                }
                else
                {
                    m_pMapArray = (MAPSTRUCT *)GlobalLock(m_hgMap);
                    _ASSERTE(m_pMapArray != NULL);
                    m_cMapMax += MIN_MAP;
                }
            }
            _ASSERTE(m_iMapCur < m_cMapMax);
        }

        VariantInit(&vaName);
        VariantInit(&vaIndex);

        V_VT(&vaName) = VT_ERROR;
        V_ERROR(&vaName) = DISP_E_PARAMNOTFOUND;

        V_VT(&vaIndex) = VT_I4;
        V_I4(&vaIndex) = i;

        pDispControl = NULL;
        hr = pHTMLCollection->item(vaIndex, vaName, &pDispControl);
        VariantClear(&vaName);
        VariantClear(&vaIndex);
        // Trident has a bug that if the object was nested inside <scripts> tags,
        // it returns S_OK with pDispControl as NULL. (See VID BUG 11303)
        if (hr == S_OK && pDispControl != NULL)
        {
            pElement = NULL;
            hr = pDispControl->QueryInterface(IID_IHTMLElement, (void **) &pElement);
            if (hr == S_OK && pElement != NULL)
            {
//#ifdef DEBUG
//              CComBSTR bstrTagName, bstrClsName;
//
//              hr = pElement->get_className(&bstrClsName);
//              hr = pElement->get_tagName(&bstrTagName);
//#endif //DEBUG
                if (!fGet) // saving the data
                {
                    BOOL fLowerCase = FALSE;

                    VariantInit(&var);
                    // KNOWN (and postponed) TRIDENT BUG - ideally, we should be able to look for hr's value here,
                    // but trident returns S_OK even if it can't get the attribute!!!
                    hr = pElement->getAttribute(pAttr, 0, &var); // look for DESIGNTIMESP (upper or lower case'd)
                    if (var.vt == VT_BSTR)
                    {
                        CComVariant varT;

                        hr = pElement->getAttribute(pAttrL, 1, &varT); // look for lowercase designtimesp
                        if (varT.vt == VT_BSTR)
                            fLowerCase = TRUE;
                    }
                    if (var.vt == VT_BSTR && var.bstrVal != NULL)
                    {
                        CComBSTR bstrUniqueID;
                        CComVariant varDSU;
                        int iType = INDEX_DSP; // initial value
                        int ich = -1; // initial value;
//#ifdef DEBUG
//                      CComBSTR pOuterTag;
//#endif //DEBUG

                        pUniqueName = NULL;
                        hr = pDispControl->QueryInterface(IID_IHTMLUniqueName, (void **) &pUniqueName);
                        if (hr == S_OK && pUniqueName != NULL)
                            hr = pUniqueName->get_uniqueID(&bstrUniqueID);
                        if (pUniqueName)
                            pUniqueName.Release();
                        //pHTMLDoc3->get_uniqueID(&bstrUniqueID);

//#ifdef DEBUG
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
//#endif //DEBUG
                        // at this point, we know that this tag had designtimesp.
                        // It may also have additional triedit attributes like designtimeurl
                        // lets check for those as well
                        hr = pElement->getAttribute(pAttrDSU, 0, &varDSU); // look for DESIGNTIMEURL (upper or lower case'd)
                        if (   hr == S_OK 
                            && varDSU.vt == VT_BSTR 
                            && varDSU.bstrVal != NULL
                            )
                        {
                            // we found 'designtimeurl'
                            iType = INDEX_AIMGLINK;
                            ich = m_ichspNonDSP;

                            FillNonDSPData(varDSU.bstrVal);
//#ifdef DEBUG
//                          pElement->get_outerHTML(&pOuterTag);
//                          pOuterTag.Empty();
//#endif //DEBUG
                            // now remove designtimeurl & its value
                            hr = pElement->removeAttribute(pAttrDSU, 0, &fSuccess);
//#ifdef DEBUG
//                          pElement->get_outerHTML(&pOuterTag);
//                          pOuterTag.Empty();
//#endif //DEBUG
                        }

                        // fill ID mapping structure
                        FillUniqueID(bstrUniqueID, var.bstrVal, ich, m_pMapArray, m_iMapCur, fLowerCase, iType);
                        bstrUniqueID.Empty();
                        m_iMapCur++;
//#ifdef DEBUG
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
//#endif //DEBUG
                        // Now, remove designtimesp and its value
                        hr = pElement->removeAttribute(pAttr, 0, &fSuccess);
//#ifdef DEBUG
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
//#endif //DEBUG
                        bstrUniqueID.Empty();
                    }
                    else if (var.vt == VT_NULL)
                    {
                        CComBSTR bstrUniqueID;
                        CComBSTR pOuterTag;
//#ifdef DEBUG
//                      CComBSTR pOuter;
//#endif // DEBUG

                        // see if this is a comment and save it
                        pElement->get_outerHTML(&pOuterTag);
                        if (   pOuterTag != NULL
                            && 0 == _wcsnicmp(pOuterTag, szComment[0], wcslen(szComment[0]))
                            )
                        {
                            pUniqueName = NULL;
                            hr = pDispControl->QueryInterface(IID_IHTMLUniqueName, (void **) &pUniqueName);
                            if (hr == S_OK && pUniqueName != NULL)
                                hr = pUniqueName->get_uniqueID(&bstrUniqueID);
                            if (pUniqueName)
                                pUniqueName.Release();

                            // fill ID mapping structure
                            FillUniqueID(bstrUniqueID, NULL, m_ichspNonDSP, m_pMapArray, m_iMapCur, fLowerCase, INDEX_COMMENT);
                            bstrUniqueID.Empty();
                            m_iMapCur++;

                            FillNonDSPData(pOuterTag);
                            // now, remove the comment spacing stuff and set_outerHTML
                            hr = pDispControl->QueryInterface(IID_IHTMLCommentElement, (void **) &pCommentElement);
                            if (hr == S_OK && pCommentElement != NULL)
                                SetinnerHTMLComment(pCommentElement, pElement, pOuterTag);
//#ifdef DEBUG
//                          pElement->get_outerHTML(&pOuter);
//                          pOuter.Empty();
//#endif //DEBUG
                            if (pCommentElement)
                                pCommentElement.Release();
                        }
                        else if (      S_OK == pDispControl->QueryInterface(IID_IHTMLObjectElement, (void **) &pObjectElement)
                                    && pObjectElement != NULL
                                    )
                        {
                            BSTR bstrAlt, bstrAltNew, bstrAltComment;

                            bstrAlt = bstrAltNew = bstrAltComment = NULL;
                            pUniqueName = NULL;
                            hr = pDispControl->QueryInterface(IID_IHTMLUniqueName, (void **) &pUniqueName);
                            if (hr == S_OK && pUniqueName != NULL)
                                hr = pUniqueName->get_uniqueID(&bstrUniqueID);
                            if (pUniqueName)
                                pUniqueName.Release();

                            // fill ID mapping structure
                            FillUniqueID(bstrUniqueID, NULL, m_ichspNonDSP, m_pMapArray, m_iMapCur, FALSE, INDEX_OBJ_COMMENT);
                            bstrUniqueID.Empty();
                            m_iMapCur++;

                            pObjectElement->get_altHtml(&bstrAlt);
                            // remove <!--ERRORPARAM ...ERRORPARAM-->
                            // ASSUME (FOR NOW) that we won't see TRIEDITCOMMENT or others here
                            RemoveEPComment(pObjectElement, bstrAlt, SysStringLen(bstrAlt), &bstrAltComment, &bstrAltNew);

                            FillNonDSPData(bstrAltComment);
                            SysFreeString(bstrAltComment);

                            hr = SetObjectComment(pObjectElement, bstrAltNew);
                            SysFreeString(bstrAltNew);

                            SysFreeString(bstrAlt);
//#ifdef DEBUG
//                          pObjectElement->get_altHtml(&bstrAlt);
//                          bstrAlt.Empty();
//#endif //DEBUG
                        }
                        if (pObjectElement)
                            pObjectElement.Release();

                        bstrUniqueID.Empty();
                        pOuterTag.Empty();
                    }
                    VariantClear(&var);
                }
                else // if (fGet)
                {
                    BOOL fLowerCase = FALSE;
                    int index, ichNonDSP;
                    CComBSTR bstrUniqueID;

                    pUniqueName = NULL;
                    hr = pDispControl->QueryInterface(IID_IHTMLUniqueName, (void **) &pUniqueName);
                    if (hr == S_OK && pUniqueName != NULL)
                        hr = pUniqueName->get_uniqueID(&bstrUniqueID);
                    if (pUniqueName)
                        pUniqueName.Release();

                    // get the uniqueID
                    //pHTMLDoc3->get_uniqueID(&bstrUniqueID);
                    // see if we have it in m_hgMap, if we do, get corresponding designtimesp ID
                    // if we don't have a DSP for this uniqueID, this is newly inserted element
                    VariantInit(&var);
                    if (FGetSavedDSP(bstrUniqueID, &(var.bstrVal), &ichNonDSP, m_pMapArray, &fLowerCase, &index))
                    {
//#ifdef DEBUG
//                      CComBSTR pOuterTag;
//#endif //DEBUG
                        // insert (correct case) "designtimesp = xxxx" in the tag by setting attribute/value
                        var.vt = VT_BSTR;
#ifdef DEBUG
                        if (index == INDEX_DSP)
                            _ASSERTE(var.bstrVal != NULL && ichNonDSP == -1);
                        else if (index == INDEX_COMMENT)
                            _ASSERTE(var.bstrVal == (BSTR)NULL && ichNonDSP != -1);
                        else if (index == INDEX_AIMGLINK)
                            _ASSERTE(var.bstrVal != NULL && ichNonDSP != -1);
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
#endif //DEBUG
                        if (index == INDEX_DSP)
                        {
                            if (fLowerCase)
                                hr = pElement->setAttribute(pAttrL, var, 1);
                            else
                                hr = pElement->setAttribute(pAttr, var, 1);
                        }
                        else if (index == INDEX_COMMENT)
                        {
                            hr = pDispControl->QueryInterface(IID_IHTMLCommentElement, (void **) &pCommentElement);
                            if (hr == S_OK && pCommentElement != NULL)
                                ReSetinnerHTMLComment(pCommentElement, pElement, ichNonDSP);
                            if (pCommentElement)
                                pCommentElement.Release();
                        }
                        else if (index == INDEX_AIMGLINK)
                        {
                            CComVariant varDSU;
                            WCHAR *pchDSU;
                            int cchDSU = 0;

                            if (fLowerCase)
                                hr = pElement->setAttribute(pAttrL, var, 1);
                            else
                                hr = pElement->setAttribute(pAttr, var, 1);

                            // put designtimeurl as well
                            // get the data from ichNonDSP and setAttribute
                            _ASSERTE(ichNonDSP != -1);
                            memcpy((BYTE *)&cchDSU, (BYTE *)(m_pspNonDSP+ichNonDSP), sizeof(INT));
                            _ASSERTE(cchDSU > 0);
                            pchDSU = new WCHAR[cchDSU+1];
                            memcpy((BYTE *)pchDSU, (BYTE *)(m_pspNonDSP+ichNonDSP+sizeof(int)/sizeof(WCHAR)), cchDSU*sizeof(WCHAR));
                            pchDSU[cchDSU] = '\0';
                            varDSU.bstrVal = SysAllocString(pchDSU);
                            varDSU.vt = VT_BSTR;
                            hr = pElement->setAttribute(pAttrDSU, varDSU, 1);
                            delete pchDSU;
                        } //else if (index == INDEX_AIMGLINK)
                        else if (index == INDEX_OBJ_COMMENT)
                        {
                            hr = pDispControl->QueryInterface(IID_IHTMLObjectElement, (void **) &pObjectElement);
                            if (pObjectElement != NULL)
                            {
                                AppendEPComment(pObjectElement, ichNonDSP);
                            }
                            else // something is not right, just ignore
                            {
                                _ASSERTE(FALSE);
                            }
                            if (pObjectElement)
                                pObjectElement.Release();
                        }
//#ifdef DEBUG
//                      pElement->get_outerHTML(&pOuterTag);
//                      pOuterTag.Empty();
//#endif //DEBUG
                    } // if (FGetSavedDSP())
                    VariantClear(&var);
                    bstrUniqueID.Empty();
                } // end of else case of 'if (!fGet)'
//#ifdef DEBUG
//              bstrTagName.Empty();
//              bstrClsName.Empty();
//#endif //DEBUG
            } // if (hr == S_OK && pElement != NULL)
            if (pElement)
                pElement.Release();
        } // if (hr == S_OK && pDispControl != NULL)
        if (pDispControl)
            pDispControl.Release();
    } // for (i ...)

LRet:
    if (pAttr != NULL)
        delete pAttr; 
    if (pAttrL != NULL)
        delete pAttrL;
    if (pAttrDSU != NULL)
        delete pAttrDSU;
    if (pHTMLCollection)
        pHTMLCollection.Release();
    if (pHTMLDoc)
        pHTMLDoc.Release();
    if (m_hgMap != NULL)
        GlobalUnlock(m_hgMap);
    if (m_hgSpacingNonDSP != NULL)
        GlobalUnlock(m_hgSpacingNonDSP);


    return;
}

/////////////////////////////////////////////////////////////////////
//
STDMETHODIMP
CTridentEventSink::Invoke(DISPID dispid, REFIID, LCID, USHORT, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*)
{
    switch(dispid)
    {
    case DISPID_HTMLDOCUMENTEVENTS_ONREADYSTATECHANGE:
        {
            CComBSTR p;
            HRESULT hr;
            LPCWSTR szComplete[] =
            {
                L"complete",
            };

            //look for READYSTATE_COMPLETE)
            hr = m_pHTMLDocument2->get_readyState(&p);
            if (   hr == S_OK
                && (p != NULL)
                && 0 == _wcsnicmp(p, szComplete[0], wcslen(szComplete[0]))
                && m_pTriEditDocument->FIsFilterInDone()
                )
            {
                CComVariant varDirty;

                // we know that the document is loaded.
                // get pointer to DOM and access all tags
                // create a table that holds mapping from designtimespID to uniqueID
                // save the mapping and remove designtimesp attribute

                // at the time of save, fill in the designtimesp's for each uniqueID

                m_pTriEditDocument->MapUniqueID(/*fGet*/FALSE);
                m_pTriEditDocument->SetFilterInDone(FALSE);
                // set the document to be CLEAN (non-DIRTY), we don't care about hr
                varDirty.bVal = FALSE;
                varDirty.vt = VT_BOOL;
                hr = m_pTriEditDocument->Exec(&CGID_MSHTML, IDM_SETDIRTY, MSOCMDEXECOPT_DODEFAULT, &varDirty, NULL);
            }
            p.Empty();
        }
        break;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////
//
HRESULT 
CBaseTridentEventSink::Advise(IUnknown* pUnkSource, REFIID riidEventInterface)
{
    HRESULT hr = E_FAIL;
    
    if(NULL == pUnkSource)
    {
        _ASSERTE(FALSE);
        return E_INVALIDARG;
    }

    if(m_dwCookie > 0)
    {
        _ASSERTE(FALSE);
        return E_UNEXPECTED;
    }

    hr = AtlAdvise(pUnkSource, static_cast<IUnknown*>(this), riidEventInterface, &m_dwCookie);
    if(SUCCEEDED(hr) && m_dwCookie > 0)
    {
        m_iidEventInterface = riidEventInterface;

        m_pUnkSource = pUnkSource; // no addref. Advise already addref'ed it
        return S_OK;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////
//
void 
CBaseTridentEventSink::Unadvise(void)
{
    if(0 == m_dwCookie)
        return;

    AtlUnadvise(m_pUnkSource, m_iidEventInterface, m_dwCookie);
    m_dwCookie = 0; 
    m_pUnkSource = NULL;
}






//------------------------------------------------------------------------------
// IPersistStreamInit
//------------------------------------------------------------------------------



STDMETHODIMP CTriEditDocument::Load(LPSTREAM pStm)
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::Load"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      
    return m_pTridentPersistStreamInit->Load(pStm);
}

STDMETHODIMP CTriEditDocument::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::Save"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      

    // before we deligate Save to Trident, do the preFiltering stuff
    if (m_hgMap != NULL)
    {
        MapUniqueID(/*fGet*/TRUE);
    }

    return m_pTridentPersistStreamInit->Save(pStm, fClearDirty);
}

STDMETHODIMP CTriEditDocument::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::GetSizeMax"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      
    return m_pTridentPersistStreamInit->GetSizeMax(pcbSize);
}

STDMETHODIMP CTriEditDocument::IsDirty()
{
    //ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::IsDirty\n"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      
    return m_pTridentPersistStreamInit->IsDirty();
}

STDMETHODIMP CTriEditDocument::InitNew()
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::InitNew\n"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);      
    return(m_pTridentPersistStreamInit->InitNew());
}

STDMETHODIMP CTriEditDocument::GetClassID(CLSID *pClassID)
{
    ATLTRACE(_T("CTriEditDocument::IPersistStreamInit::GetClassID\n"));
    _ASSERTE(m_pTridentPersistStreamInit != NULL);
    *pClassID = GetObjectCLSID();
    return S_OK;
}
#endif //IE5_SPACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\document.h ===
// Document.h : Declaration of the CTriEditDocument
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __DOCUMENT_H_
#define __DOCUMENT_H_

#include "resource.h"       // main symbols

#include "token.h"
#include "triedcid.h"
#include "trixacc.h"

#include <mshtmhst.h>

#define grfInSingleRow          0x00000001 // selection is in any number of cells within a single row
#define grfSelectOneCell        0x00000002 // only one single cell is selected
#define grpSelectEntireRow      0x00000004 // selection is any number of whole rows being selected

#define IE5_SPACING 
#ifdef IE5_SPACING
class CTridentEventSink;
#endif //IE5_SPACING

typedef enum {
    CONSTRAIN_NONE,
    CONSTRAIN_HORIZONTAL,
    CONSTRAIN_VERTICAL
} ENUMCONSTRAINDIRECTION;

DEFINE_GUID(GUID_TriEditCommandGroup,
0x2582f1c0, 0x84e, 0x11d1, 0x9a, 0xe, 0x0, 0x60, 0x97, 0xc9, 0xb3, 0x44);

//for use with IDM_TRIED_LOCK_ELEMENT
#define DESIGN_TIME_LOCK L"Design_Time_Lock"

// The following definition is used in LockElement while invalidating the element.
// This size is dependent on Trident's grab handle size.
// This value should be atleast as big as Trident's grab handle size.
#define ELEMENT_GRAB_SIZE 12

#ifndef SAFERELEASE
#define SAFERELEASE(a) if (a) {a->Release();a=NULL;}
#endif  //SAFERELEASE

#include "zorder.h"

#ifdef IE5_SPACING
// move followign defines in a new header file - uniqueid,h
#define INDEX_NIL       0
#define INDEX_DSP       1
#define INDEX_COMMENT   2
#define INDEX_AIMGLINK  3
#define INDEX_OBJ_COMMENT   4
#define INDEX_MAX       5

#define  MIN_MAP    20
#define cchID       20
struct MAPSTRUCT
{
    WCHAR szUniqueID[cchID];
    WCHAR szDspID[cchID];
    int ichNonDSP;
    BOOL fLowerCase;
    int iType;
};
#define MIN_SP_NONDSP   0x800
#endif //IE5_SPACING

class CTriEditUIHandler;

/////////////////////////////////////////////////////////////////////////////
// CTriEditDocument
class ATL_NO_VTABLE CTriEditDocument :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTriEditDocument, &CLSID_TriEditDocument>,
    public IDispatchImpl<ITriEditDocument, &IID_ITriEditDocument, &LIBID_TRIEDITLib>,
    public IOleObject,
    public IOleCommandTarget,
    public IDropTarget,
    public ITriEditExtendedAccess
#ifdef IE5_SPACING
    ,
    public IPersistStreamInit,
    public IPersistStream
#endif //IE5_SPACING
{
public:

    // IOleObject

    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */);
    STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */);
    STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */);
    STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */);
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* lpmsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */, HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */);

    // IOleCommandTarget
    STDMETHOD(QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    STDMETHOD(Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);

    // IDropTarget
    STDMETHOD(DragEnter)(IDataObject *pDataObject, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(void);
    STDMETHOD(Drop)(IDataObject *pDataObject, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

#ifdef IE5_SPACING
    //  IPersistStreamInit, IPersistStream
    //
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER * pcbSize);
    STDMETHOD(InitNew)();
    STDMETHOD(GetClassID)(CLSID *pClassID);
#endif //IE5_SPACING

    // ITriEditDocument

    STDMETHOD(FilterIn)(IUnknown *pUnkOld, IUnknown **ppUnkNew, DWORD dwFlags, BSTR bstrBaseURL);
    STDMETHOD(FilterOut)(IUnknown *pUnkOld, IUnknown **ppUnkNew, DWORD dwFlags, BSTR bstrBaseURL);

    // ITriEditExtendedAccess
    STDMETHOD(GetCharsetFromStream)(IStream* piStream, BSTR* pbstrCodePage);

    DECLARE_GET_CONTROLLING_UNKNOWN()

    // ATL helper functions override

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    HRESULT FinalConstruct();   // for aggregation
    void FinalRelease();        // for aggregation

#ifdef IE5_SPACING
    // methods for mapping unique IDs and designtimesp's
    void MapUniqueID(BOOL fGet);
    void FillUniqueID(BSTR bstrUniqueID, BSTR bstrDspVal, int ichNonDSP, MAPSTRUCT *pMap, int iMapCur, BOOL fLowerCase, int iType);
    BOOL FGetSavedDSP(BSTR bstrUniqueID, BSTR *pbstrDspVal, int *pichNonDSP, MAPSTRUCT *pMap, BOOL *pfLowerCase, int *pIndex);
    BOOL FIsFilterInDone() {return(m_fFilterInDone);}
    void SetFilterInDone(BOOL fSet) {m_fFilterInDone = fSet;}
    void FillNonDSPData(BSTR pOuterTag);
    void SetinnerHTMLComment(IHTMLCommentElement *pCommentElement, IHTMLElement *pElement, BSTR pOuterTag);
    void ReSetinnerHTMLComment(IHTMLCommentElement *pCommentElement, IHTMLElement *pElement, int ichspNonDSP);
    void RemoveEPComment(IHTMLObjectElement *pObjectElement, BSTR bstrAlt, int cch, BSTR *pbstrAltComment, BSTR *pbstrAltNew);
    HRESULT  SetObjectComment(IHTMLObjectElement *pObjectElement, BSTR bstrAltNew);
    void AppendEPComment(IHTMLObjectElement *pObjectElement, int ichspNonDSP);
#endif //IE5_SPACING

protected:
    // Trident interface pointers
    IUnknown *m_pUnkTrident;
    IOleObject *m_pOleObjTrident;
    IOleCommandTarget *m_pCmdTgtTrident;
    IDropTarget *m_pDropTgtTrident;
#ifdef IE5_SPACING
    IPersistStreamInit *m_pTridentPersistStreamInit;
#endif //IE5_SPACING

    // Host interface pointers
    IOleClientSite *m_pClientSiteHost;
    IDocHostUIHandler *m_pUIHandlerHost;
    IDocHostDragDropHandler *m_pDragDropHandlerHost;

    // Pointer to our UI handler sub-object
    CTriEditUIHandler *m_pUIHandler;

    // General hosting related data
    BOOL m_fUIHandlerSet;
    BOOL m_fInContextMenu;

    // 2D editing data
    IHTMLElement* m_pihtmlElement;
    IHTMLStyle* m_pihtmlStyle;
    RECT m_rcElement;
    RECT m_rcElementOrig;
    RECT m_rcElementParent;

    BOOL m_fConstrain;
    ENUMCONSTRAINDIRECTION m_eDirection;
    HWND m_hwndTrident;
    HBRUSH m_hbrDragRect;
    BOOL m_fDragRectVisible;
    RECT m_rcDragRect;

    POINT m_ptClickOrig;
    POINT m_ptClickLast;
    POINT m_ptConstrain;

    POINT m_ptScroll;
    POINT m_ptAlign;
    BOOL m_fLocked;

    //for 2D drop mode.
    BOOL m_f2dDropMode;

#ifdef IE5_SPACING
    CTridentEventSink *m_pTridentEventSink;
    IHTMLDocument2  *m_pHTMLDocument2;
    MAPSTRUCT *m_pMapArray;
    HGLOBAL m_hgMap;
    int m_cMapMax;
    int m_iMapCur;
    WCHAR *m_pspNonDSP;
    HGLOBAL m_hgSpacingNonDSP;
    int m_ichspNonDSPMax;
    int m_ichspNonDSP;
#endif //IE5_SPACING

private:
    // Filtering related members
    ITokenGen *m_pTokenizer;
    HGLOBAL m_hgDocRestore;
    HRESULT DoFilter(HGLOBAL hOld, HGLOBAL *phNew, IStream *pStmNew, DWORD dwFlags, FilterMode mode, int cbSizeIn, UINT* pcbSizeOut, BSTR bstrBaseURL);

    //Stubs for IOleCommandTarget commands
    HRESULT Is2DElement(IHTMLElement* pihtmlElement, BOOL* pf2D);
    HRESULT NudgeElement(IHTMLElement* pihtmlElement, LPPOINT ptNudge);
    HRESULT SetAlignment(LPPOINT pptAlign);
    HRESULT LockElement(IHTMLElement* pihtmlElement, BOOL fLock);
    HRESULT Make1DElement(IHTMLElement* pihtmlElement);
    HRESULT Make2DElement(IHTMLElement* pihtmlElement, POINT *ppt = NULL);
    HRESULT Constrain(BOOL fConstrain);
    HRESULT DoVerb(VARIANTARG *pvarargIn, BOOL fQueryStatus);

    //Z-Ordering related functions
    static int _cdecl CompareProc(const void* arg1, const void* arg2);
    HRESULT GetZIndex(IHTMLElement* pihtmlElement, LONG* plZindex);
    HRESULT SetZIndex(IHTMLElement* pihtmlElement, LONG lZindex);
    HRESULT AssignZIndex(IHTMLElement *pihtmlElement, int nZIndexMode);
    HRESULT PropagateZIndex(CZOrder* pczOrder, LONG lZIndex, BOOL fZindexNegative = FALSE);
    BOOL IsEqualZIndex(CZOrder* pczOrder,LONG lIndex);

    // table editing
    HRESULT IsSelectionInTable(IDispatch **ppTable=NULL);
    HRESULT FillInSelectionCellsInfo(struct SELCELLINFO * pselStart, struct SELCELLINFO *pselEnd);
    ULONG GetSelectionTypeInTable(void);
    HRESULT CopyStyle(IDispatch *pFrom, IDispatch *pTo);
    HRESULT CopyProperty(IDispatch *pFrom, IDispatch *pTo);
    HRESULT DeleteTableRows(void);
    HRESULT InsertTableRow(void);
    HRESULT DeleteTableCols(void);
    HRESULT InsertTableCol(void);
    HRESULT InsertTableCell(void);
    HRESULT DeleteTableCells(void);
    HRESULT MergeTableCells(void);
    HRESULT SplitTableCell(void);
    HRESULT SplitTableCell(IDispatch *srpTable, INT iRow, INT index);
    HRESULT MergeTableCells(IDispatch* srpTable, INT iRow, INT iIndexStart, INT iIndexEnd);
    HRESULT InsertTable(VARIANTARG *pvarargIn=NULL);
    HRESULT MapCellToFirstRowCell(IDispatch *srpTable, struct SELCELLINFO *pselinfo);
    HRESULT GetTableRowElementAndTableFromCell(IDispatch *srpCell, LONG *pindexRow = NULL, IDispatch **srpRow=NULL,IDispatch **srpTable=NULL);
    BOOL FEnableInsertTable(void);
    HRESULT DeleteTable(IHTMLElement *pTable);
    inline HRESULT DeleteRowEx(IHTMLElement *pTable, LONG index);
    inline HRESULT DeleteCellEx(IHTMLElement *pTable, IDispatch *pRow, LONG indexRow, LONG indexCell);
    
    //Helpers
    void SetUpDefaults(void);
    void SetUpGlyphTable(BOOL);
    HRESULT MapTriEditCommand(ULONG cmdTriEdit, ULONG *pcmdTrident);
    void Draw2DDragRect(BOOL fDraw);
    HRESULT GetElement(BOOL fDragDrop = FALSE);
    void ReleaseElement(void);
    HRESULT GetScrollPosition(void);
    HRESULT DragScroll(POINT pt);
    HRESULT CalculateNewDropPosition(POINT *pt);
    BOOL IsDragSource(void);
    BOOL IsDesignMode(void);
    HRESULT IsLocked(IHTMLElement* pihtmlElement, BOOL* pfLocked);
    HRESULT ConstrainXY(LPPOINT lppt);
    HRESULT SnapToGrid(LPPOINT lppt);
    HRESULT GetElementPosition(IHTMLElement* pihtmlElement, LPRECT prc);
    STDMETHOD (GetDocument)(IHTMLDocument2** ppihtmlDoc2);
    STDMETHOD (GetAllCollection)(IHTMLElementCollection** ppihtmlCollection);
    STDMETHOD (GetCollectionElement)(IHTMLElementCollection* ppihtmlCollection,
        LONG iIndex,
        IHTMLElement** ppihtmlElem);
    STDMETHOD (Is2DCapable)(IHTMLElement* pihtmlElement, BOOL* pfBool);
    STDMETHOD (GetTridentWindow)();
    STDMETHOD (SelectElement)(IHTMLElement* pihtmlElement, IHTMLElement* pihtmlElementParent);
    HRESULT IsElementDTC(IHTMLElement *pihtmlElement);
    HRESULT GetCharset(HGLOBAL hgUHTML, int cbSizeIn, BSTR* pbstrCharset);
#ifdef IE5_SPACING
    BOOL m_fFilterInDone;
#endif //IE5_SPACING

    // utility inlines
    inline BOOL IsIE5OrBetterInstalled()
    {
        BOOL fIsIE5AndBeyond = FALSE;
        CComPtr<IHTMLDocument3> pHTMLDoc3 = NULL;

        // check if we have IE5 or better installed
        if (   m_pUnkTrident != NULL
            && S_OK == m_pUnkTrident->QueryInterface(IID_IHTMLDocument3, (void **) &pHTMLDoc3)
            && pHTMLDoc3 != NULL
            )
        {
            fIsIE5AndBeyond = TRUE;
        }
        return(fIsIE5AndBeyond);
    }

public:
    CTriEditDocument();

DECLARE_AGGREGATABLE(CTriEditDocument)
DECLARE_REGISTRY_RESOURCEID(IDR_TRIEDITDOCUMENT)

BEGIN_COM_MAP(CTriEditDocument)
    COM_INTERFACE_ENTRY(ITriEditDocument)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IOleCommandTarget)
    COM_INTERFACE_ENTRY(IDropTarget)
    COM_INTERFACE_ENTRY(ITriEditExtendedAccess)
#ifdef IE5_SPACING
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(IPersistStream)
#endif //IE5_SPACING
    COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_pUnkTrident)
END_COM_MAP()

friend class CTriEditUIHandler;

};

class CTriEditUIHandler : public IDocHostUIHandler
{

public:
    ULONG            m_cRef;
    CTriEditDocument *m_pDoc;

    CTriEditUIHandler(CTriEditDocument *pDoc) { m_cRef = 1; m_pDoc = pDoc; }
    ~CTriEditUIHandler(void) {}

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDocHostUIHandler

    STDMETHOD(GetHostInfo)(DOCHOSTUIINFO* pInfo);
    STDMETHOD(ShowUI)(DWORD dwID, IOleInPlaceActiveObject* pActiveObject,
                        IOleCommandTarget* pCommandTarget, IOleInPlaceFrame* pFrame,
                        IOleInPlaceUIWindow* pDoc);
    STDMETHOD(HideUI)();
    STDMETHOD(UpdateUI)();
    STDMETHOD(EnableModeless)(BOOL fEnable);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow);
    STDMETHOD(ShowContextMenu)(DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget,
                                 IDispatch* pDispatchObjectHit);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, const GUID __RPC_FAR *pguidCmdGroup, DWORD nCmdID);
    STDMETHOD(GetOptionKeyPath)(LPOLESTR* pbstrKey, DWORD dw);
    STDMETHOD(GetDropTarget)(IDropTarget __RPC_FAR *pDropTarget,
                               IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget);
    STDMETHOD(GetExternal)(IDispatch **ppDispatch);
    STDMETHOD(TranslateUrl)(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    STDMETHOD(FilterDataObject)(IDataObject *pDO, IDataObject **ppDORet);
};

#ifdef IE5_SPACING
/////////////////////////////////////////////////////////////////////
//
class ATL_NO_VTABLE CBaseTridentEventSink :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatch
{
public:

BEGIN_COM_MAP(CBaseTridentEventSink)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    // IDispatch
    STDMETHOD(GetTypeInfoCount)(UINT *) 
        { return E_NOTIMPL;}
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **)  
        { return E_NOTIMPL;}
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR**, UINT, LCID, DISPID*)  
        { return E_NOTIMPL;}
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, USHORT, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*)
         { return S_OK; }

public:
    HRESULT Advise(IUnknown* pUnkSource, REFIID riidEventInterface);
    void    Unadvise(void);

    CBaseTridentEventSink()
        {
            m_dwCookie = 0;
            m_pUnkSource  = NULL;

            ::ZeroMemory(&m_iidEventInterface, sizeof(m_iidEventInterface));
        }
            

protected:
    DWORD               m_dwCookie;
    IUnknown*           m_pUnkSource;

    GUID                m_iidEventInterface;
public:
    IHTMLDocument2*     m_pHTMLDocument2;
    CTriEditDocument*   m_pTriEditDocument;
};

class CTridentEventSink: public CBaseTridentEventSink
{
public:
    // IDispatch
    STDMETHOD(Invoke)(DISPID dispid, REFIID, LCID, USHORT, DISPPARAMS*, VARIANT*, EXCEPINFO*, UINT*);
};
#endif //IE5_SPACING

#endif //__DOCUMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\fmtinfo.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __FMTINFO_H__
#define __FMTINFO_H__


#define RGB_BLACK       RGB(0x00, 0x00, 0x00)
#define RGB_WHITE       RGB(0xFF, 0xFF, 0xFF)
#define RGB_RED         RGB(0xFF, 0x00, 0x00)
#define RGB_GREEN       RGB(0x00, 0xFF, 0x00)
#define RGB_BLUE        RGB(0x00, 0x00, 0xFF)
#define RGB_YELLOW      RGB(0xFF, 0xFF, 0x00)
#define RGB_MAGENTA     RGB(0xFF, 0x00, 0xFF)
#define RGB_CYAN        RGB(0x00, 0xFF, 0xFF)
#define RGB_LIGHTGRAY   RGB(0xC0, 0xC0, 0xC0)
#define RGB_GRAY        RGB(0x80, 0x80, 0x80)
#define RGB_DARKRED     RGB(0x80, 0x00, 0x00)
#define RGB_DARKGREEN   RGB(0x00, 0x80, 0x00)
#define RGB_DARKBLUE    RGB(0x00, 0x00, 0x80)
#define RGB_LIGHTBROWN  RGB(0x80, 0x80, 0x00)
#define RGB_DARKMAGENTA RGB(0x80, 0x00, 0x80)
#define RGB_DARKCYAN    RGB(0x00, 0x80, 0x80)

// IMPORTANT: These macros depend heavily on the order of things in colors.cpp.
//    1) The order of colors in window must be Source Text, Text Selection, Text Highlight.
#define AUTO_TEXT           { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT },  { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define AUTO_SELECTION      { TRUE, FALSE, FALSE, TRUE, FALSE, 0 },                 { TRUE, FALSE, FALSE, TRUE, FALSE, 0 }
#define AUTO_HIGHLIGHT      { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },   { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define AUTO_REF(n)         { TRUE, FALSE, FALSE, FALSE, FALSE, n },    { TRUE, FALSE, FALSE, FALSE, FALSE, n }
#define AUTO_REF_SRC(n)     { TRUE, FALSE, TRUE, FALSE, FALSE, n },     { TRUE, FALSE, TRUE, FALSE, FALSE, n }

#define BACKAUTO_TEXT           { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT }, { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define BACKAUTO_SELECTION      { FALSE, FALSE, FALSE, TRUE, FALSE, 0 },                    { TRUE, FALSE, FALSE, TRUE, FALSE, 0 }
#define BACKAUTO_HIGHLIGHT      { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },  { TRUE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define BACKAUTO_REF(n)         { FALSE, FALSE, FALSE, FALSE, FALSE, n },   { TRUE, FALSE, FALSE, FALSE, FALSE, n }
#define BACKAUTO_REF_SRC(n)     { FALSE, FALSE, TRUE, FALSE, FALSE, n },    { TRUE, FALSE, TRUE, FALSE, FALSE, n }

#define NOTAUTO_TEXT        { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOWTEXT }, { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_WINDOW }
#define NOTAUTO_SELECTION   { FALSE, FALSE, FALSE, TRUE, FALSE, 0 },    { FALSE, FALSE, FALSE, TRUE, FALSE, 0 }
#define NOTAUTO_HIGHLIGHT   { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHTTEXT },  { FALSE, TRUE, FALSE, FALSE, FALSE, COLOR_HIGHLIGHT }

#define NOTAUTO_REF(n)      { FALSE, FALSE, FALSE, FALSE, FALSE, n },       { FALSE, FALSE, FALSE, FALSE, FALSE, n }
#define NOTAUTO_REF_SRC(n)  { FALSE, FALSE, TRUE, FALSE, FALSE, n },        { FALSE, FALSE, TRUE, FALSE, FALSE, n }

struct AUTO_COLOR
{
    WORD    bOn:1;      // Is auto color being used now?
    WORD    bSys:1;     // Get the color from the system(1) or from a window(0)?
    WORD    bSrc:1;     // If bSys == 0, use this window(0) or the Source Window(1)?
    WORD    bRev:1;     // If from this window, reverse fore/background(1)?
    WORD    bUpd:1;     // Used by UpdateAutoColors().
    WORD    index:5;    // Index into element list(bSys==0) or COLOR_* value (bSys==1).
};



#endif /* __FMTINFO_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\guids.h ===
// guids.h: definitions of GUIDs/IIDs/CLSIDs used in TriEdit
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//

//#ifndef __GUIDS_H__
//#define __GUIDS_H__

// IID_ITokenGen for interface in token.h
DEFINE_GUID(IID_ITokenGen,
0x1106aec0, 0xfe30, 0x11d0, 0xb0, 0x79, 0x00, 0x60, 0x08, 0x05, 0x8a, 0x0e);

// IID_IPersistTextStream and IID_IActiveDesigner for DTC filtering
DEFINE_GUID(IID_IPersistTextStream,
0x56223fe3, 0xd397, 0x11cf, 0xa4, 0x2e, 0x00, 0xaa, 0x00, 0xc0, 0x09, 0x40);

DEFINE_GUID(IID_IActiveDesigner,
0x51aae3e0, 0x7486, 0x11cf, 0xa0, 0xc2, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

// Page Transition DTC
DEFINE_GUID(CLSID_PageTr,
0x8EA785B1, 0x4738, 0x11D1, 0xB4, 0x7C, 0x0, 0xA0, 0xC9, 0x59, 0xBB, 0x15);

// Trident's Command Set
DEFINE_GUID(CMDSETID_Forms3,
0xDE4BA900, 0x59CA, 0x11CF, 0x95, 0x92, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

// TriEditParse
DEFINE_GUID(CLSID_TriEditParse, 
0x010E6CBE, 0xFE2B, 0x11D0, 0xB0, 0x79, 0x00, 0x60, 0x08, 0x05, 0x8A, 0x0E);

#define IE5_SPACING
#ifdef IE5_SPACING
// ie5 specific - temporary use
DEFINE_GUID(IID_IHTMLUniqueName, 
0x3050f4d0, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DEFINE_GUID(IID_IHTMLDocument3, 
0x3050f485, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);
#endif //IE5_SPACING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\filter.cpp ===
// filter.cpp : Implementation of filtering/parsing of the document
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#include "stdafx.h"

#include "triedit.h"
#include "Document.h"
#include "guids.h"
#include "HtmParse.h"

STDMETHODIMP CTriEditDocument::FilterIn(IUnknown *pUnkOld, IUnknown **ppUnkNew, DWORD dwFlags, BSTR bstrBaseURL)
{
    HGLOBAL hOld, hNew;
    HRESULT hr;
    IStream *pStmOld;
    UINT    chSize;
    ULARGE_INTEGER li;
    int cbSizeIn = -1;
    STATSTG stat;

    if (pUnkOld == NULL)
        return E_INVALIDARG;

    hr = pUnkOld->QueryInterface(IID_IStream, (void **) &pStmOld);
    if (hr != S_OK)
        return E_INVALIDARG;

    if ((hr = pStmOld->Stat(&stat, STATFLAG_NONAME)) == S_OK)
    {
        cbSizeIn = stat.cbSize.LowPart;
        _ASSERTE(stat.cbSize.HighPart == 0); // This will ensure that we don't have a doc larger than 4 gigabytes
    }

    if (GetHGlobalFromStream(pStmOld, &hOld) != S_OK)
    {
        pStmOld->Release();
        return E_INVALIDARG;
    }

    if (!(dwFlags & dwFilterUsePstmNew))
        *ppUnkNew = NULL;

    hr = DoFilter(hOld, &hNew, (IStream*) *ppUnkNew, dwFlags, modeInput, cbSizeIn, &chSize, bstrBaseURL);
#ifdef IE5_SPACING
    if (!(dwFlags & dwFilterNone) && hr == S_OK)
        SetFilterInDone(TRUE);
#endif //IE5_SPACING
    if (hr != S_OK)
    {
        pStmOld->Release();
        return hr;
    }

    if (!(dwFlags & dwFilterUsePstmNew))
    {
        _ASSERTE(hNew != NULL);
        hr = CreateStreamOnHGlobal(hNew, TRUE, (IStream **) ppUnkNew);
        if (FAILED(hr))
            GlobalFree(hNew);
    }
        
    if (SUCCEEDED(hr))
    {
        li.LowPart = chSize;
        li.HighPart = 0;
        (*((IStream**)ppUnkNew))->SetSize(li);
    }

    pStmOld->Release();
    return hr;
}

STDMETHODIMP CTriEditDocument::FilterOut(IUnknown *pUnkOld, IUnknown **ppUnkNew, DWORD dwFlags, BSTR bstrBaseURL)
{
    HGLOBAL hOld, hNew;
    HRESULT hr;
    IStream *pStmOld;
    UINT    chSize;
    ULARGE_INTEGER li;
    int cbSizeIn = -1;
    STATSTG stat;

    if (pUnkOld == NULL)
        return E_INVALIDARG;

    hr = pUnkOld->QueryInterface(IID_IStream, (void **) &pStmOld);
    if (hr != S_OK)
        return E_INVALIDARG;

    if ((hr = pStmOld->Stat(&stat, STATFLAG_NONAME)) == S_OK)
    {
        cbSizeIn = stat.cbSize.LowPart;
        _ASSERTE(stat.cbSize.HighPart == 0); // This will ensure that we don't have a doc larger than 4 gigabytes
    }

    if (GetHGlobalFromStream(pStmOld, &hOld) != S_OK)
    {
        pStmOld->Release();
        return E_INVALIDARG;
    }

    if (!(dwFlags & dwFilterUsePstmNew))
        *ppUnkNew = NULL;

    hr = DoFilter(hOld, &hNew, (IStream *) *ppUnkNew, dwFlags, modeOutput, cbSizeIn, &chSize, bstrBaseURL);
    if (hr != S_OK)
    {
        pStmOld->Release();
        return hr;
    }

    if (!(dwFlags & dwFilterUsePstmNew))
    {
        _ASSERTE(hNew != NULL);
        hr = CreateStreamOnHGlobal(hNew, TRUE, (IStream **) ppUnkNew);
        if (FAILED(hr))
            GlobalFree(hNew);
    }

    if (SUCCEEDED(hr))
    {
        li.LowPart = chSize;
        li.HighPart = 0;
        (*((IStream**)ppUnkNew))->SetSize(li);
    }

    pStmOld->Release();
    return hr;
}

HRESULT CTriEditDocument::DoFilter(HGLOBAL hOld, HGLOBAL *phNew, IStream *pStmNew, DWORD dwFlags, FilterMode mode, int cbSizeIn, UINT* pcbSizeOut, BSTR bstrBaseURL)
{
    HRESULT hr;
    HGLOBAL hgTokArray;
    UINT cMaxToken;

    // Create tokenizer if it hasn't yet been created
    if (m_pTokenizer == NULL)
    {
        hr = ::CoCreateInstance(CLSID_TriEditParse, NULL, CLSCTX_INPROC_SERVER, IID_ITokenGen, (void **)&m_pTokenizer);
        if (hr != S_OK)
            return hr;
    }

    _ASSERTE(m_pTokenizer != NULL);

    _ASSERTE(dwFilterDefaults == 0);
    if ((dwFlags & ~(dwFilterMultiByteStream|dwFilterUsePstmNew)) == dwFilterDefaults) // means that caller wants us to set the flags
    {
        dwFlags |= (dwFilterDTCs|dwFilterServerSideScripts|dwPreserveSourceCode);
    }

    hr = m_pTokenizer->hrTokenizeAndParse(hOld, phNew, pStmNew, dwFlags, mode, cbSizeIn, pcbSizeOut, m_pUnkTrident, &hgTokArray, &cMaxToken, &m_hgDocRestore, bstrBaseURL, 0/*dwReserved*/);

    if (hgTokArray != NULL)
    {
        GlobalFree(hgTokArray); // hrTokenizeAndParse() would have unlocked it.
    }

    return hr;
}


//	Parse the document for a charset specification.
//	They can take the following forms:
//		<META CHARSET=XXX>
//		<META HTTP_EQUIV CHARSET=XXX>
//		<META HTTP_EQUIV="Content-type" CONTENT="text/html; charset=XXX">
//		<META HTTP_EQUIV="Charset" CONTENT="text/html; charset=XXX">
//
//	Return S_OK if found, S_FALSE if not found.  Error on exceptional cases.

HRESULT CTriEditDocument::GetCharset(HGLOBAL hgUHTML, int cbSizeIn, BSTR* pbstrCharset)
{
	HRESULT hr = E_FAIL;
	HGLOBAL hgTokArray = NULL; // holds the token array
	UINT cMaxToken; // size of token array
	UINT cbSizeOut = 0; // init
	HGLOBAL hNew = NULL; // not really used. need to pass as params to hrTokenizeAndParse()
	int iArray = 0;
	TOKSTRUCT *pTokArray;
	BOOL fFoundContent = FALSE;
	BOOL fFoundCharset = FALSE;
	HRESULT	hrCharset = S_FALSE;	// This is the error code to return if no other error occurs

	_ASSERTE ( bstrIn );
	_ASSERTE ( pbstrCharset );
	_ASSERTE ( hgUHTML );

	if ( ( cbSizeIn <= 0 ) || ( NULL == hgUHTML ) )
		goto LRet;

	*pbstrCharset = NULL;

	// step 1. generate a token array
	// Create tokenizer if it hasn't yet been created
	if (m_pTokenizer == NULL)
	{
		CoCreateInstance(CLSID_TriEditParse, NULL, CLSCTX_INPROC_SERVER, IID_ITokenGen, (void **)&m_pTokenizer);
		if (m_pTokenizer == NULL)
		{
			hr = E_FAIL;
			goto LRet;
		}
	}

	hr = m_pTokenizer->hrTokenizeAndParse(	hgUHTML, &hNew, NULL, dwFilterNone, 
												modeInput, cbSizeIn, &cbSizeOut, m_pUnkTrident, 
												&hgTokArray, &cMaxToken, NULL, NULL, 
												PARSE_SPECIAL_HEAD_ONLY );

	if (hr != S_OK || hgTokArray == NULL)
		goto LRet;
	pTokArray = (TOKSTRUCT *) GlobalLock(hgTokArray);
	if (pTokArray == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto LRet;
	}

	// step 2. look for TokAttrib_CHARSET in the META tag it.
	iArray = 0;
	while (iArray < (int)cMaxToken) // we won't go this far and will get the META tag before we hit </head>
	{
		// If a META tag is found with a CONTENT attribute, explore it.
		if ( ( pTokArray[iArray].token.tok == TokAttrib_CONTENT )
			&& pTokArray[iArray].token.tokClass == tokAttr)
		{
			fFoundContent = TRUE;			
		}
		// If a META tag is fount with a CHARSET attribute, explor it as well.
		if ( ( pTokArray[iArray].token.tok == TokAttrib_CHARSET )
			&& pTokArray[iArray].token.tokClass == tokAttr)
		{
			fFoundCharset = TRUE;			
		}

		if ( ( fFoundContent || fFoundCharset )
			&& (   pTokArray[iArray].token.tokClass == tokValue
				|| pTokArray[iArray].token.tokClass == tokString
				)
			)
		{
			// get its value, put it in pbstrCharset and return
			int cwContent = pTokArray[iArray].token.ibTokMac-pTokArray[iArray].token.ibTokMin;
			WCHAR *pwContent = new WCHAR[cwContent+1];
			WCHAR* pwCharset = NULL; // This represents a movable pointer, not an allocation.

			if (pwContent != NULL)
			{
				pwContent[0]   = WCHAR('\0');
				WCHAR* pwcText = (WCHAR*)GlobalLock ( hgUHTML );
				if ( NULL == pwcText )
				{
					hr = E_OUTOFMEMORY;
					goto LRet;
				}
				memcpy(	(BYTE *)pwContent, 
						(BYTE *)&pwcText[pTokArray[iArray].token.ibTokMin], 
						cwContent*sizeof(WCHAR));
				pwContent[cwContent] = WCHAR('\0');

				GlobalUnlock ( hgUHTML );
				_wcslwr ( pwContent );

				if ( fFoundCharset )
				{
					pwCharset = pwContent;
				}

				// If it's a CONTENT attribute, this string actually contains something like
				// "text/html; charset=something".  We need to return only the "something" part.
				if ( fFoundContent )
				{
					// Find the "charset", case insensitive.
					pwCharset = wcsstr ( pwContent, L"charset" );

					// Find the equal sign following the charset
					if ( NULL != pwCharset )
					{
						pwCharset = wcsstr ( pwContent, L"=" );
					}

					// Find the charset name itself. There could be spaces between the = and the name.
					if ( NULL != pwCharset )
					{
						WCHAR wc = '\0';

						// Skip the equal sign we just found:
						pwCharset++;

						// Pick up a character.  It should never be \0, but could be for ill formed HTML.
						while ( WCHAR('\0') != ( wc = *pwCharset ) )
						{
							if ( iswspace(wc) || WCHAR('\'') == wc )
							{
								pwCharset++;
							}
							else
							{
								break;
							}
						}
					}

					// Now terminate the charset name.  It could have trailing spaces, a closing quote, a semi-colon, etc.
					if ( NULL != pwCharset )
					{
						pwCharset = wcstok ( pwCharset, L" \t\r\n\"\';" );	// First token not containing whitespace, quote or semicolon
					}
				}

				// If it was not found, try again.
				if ( NULL == pwCharset )
				{
					delete [] pwContent;
					fFoundContent = FALSE;
					fFoundCharset = FALSE;
					continue;
				}

				*pbstrCharset = SysAllocString(pwCharset);
				if (*pbstrCharset != NULL)
				{
					hrCharset = S_OK;
				}
				else
				{
					hr = E_OUTOFMEMORY;
				}
				delete [] pwContent;
			}
			break; // even if we didn't succeed in above allocations, we should quit because we already found the charset
		}
		iArray++;
	}

LRet:
	if (hgTokArray != NULL)
	{
		GlobalUnlock(hgTokArray);
		GlobalFree(hgTokArray);
	}
	if (hNew != NULL)
		GlobalFree(hNew); // hrTokenizeAndParse() would have unlocked it.

	// If no error occurred, return S_OK or S_FALSE indicating if the charset was found:
	if ( SUCCEEDED ( hr ) )
	{
		hr = hrCharset;
	}
	return(hr);

} /* CDocument::GetCharset() */


//	Given a stream, created on a global, find any META charset tag that might exist in it.
//	The input stream may be in Unicode or MBCS: Unicode streams MUST be byte-order prefixed.
//	The stream pos will not be affected by this operation, nor will its contents be changed.
//	If the stream is in Unicode, in either byte order, the charset "unicode" is returned,
//	because this routine is primarily of interest in converting streams to unicode.
//
//	If the input stream is empty, or if no META charset tag exists, return S_FALSE and NULL
//	for pbstrCharset.
//	If a charset tag is found, return S_OK and allocate a SysString for pbstrCharset.
//	The caller must call SysFreeString if pbstrCharset is returned.
//
HRESULT CTriEditDocument::GetCharsetFromStream(IStream* pStream, BSTR* pbstrCharset)
{
	HRESULT	hr			= S_OK;
	STATSTG	statStg		= {0};
	HGLOBAL hMem		= NULL;
	CHAR*	pbData		= NULL;
	WCHAR*	pwcUnicode	= NULL;
	HGLOBAL	hgUHTML		= NULL;
	UINT	cbNewSize	= 0;

	_ASSERTE ( pbstrCharset );
	*pbstrCharset = NULL;

	if (FAILED(hr = pStream->Stat(&statStg, STATFLAG_NONAME)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	if ( 0 == statStg.cbSize.LowPart )
	{
		return S_FALSE;
	}

	if (FAILED(hr = GetHGlobalFromStream(pStream, &hMem)))
	{
		_ASSERTE(SUCCEEDED(hr));
		return hr;
	}

	pbData = (CHAR*)GlobalLock(hMem);
	if (NULL == pbData)
	{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		_ASSERTE(pbData);
		return hr;		
	}

	// If the stream is already in Unicode, that's all we need to know.
	if ( 0xfffe == *((WCHAR*)pbData) )
	{
		*pbstrCharset = SysAllocString ( L"Unicode" );
		hr = S_OK;
		goto LRet;
	}

	// Convert the SBCS or MBCS stream to Unicode as ANSI.
	// This will be adequate for finding the charset META tag.

	cbNewSize = ::MultiByteToWideChar ( CP_ACP, 0, pbData, statStg.cbSize.LowPart, NULL, 0 );
	if ( 0 == cbNewSize )
	{
		hr = E_FAIL;
		goto LRet;
	}

	// Create the buffer to convert to.
	hgUHTML = GlobalAlloc ( GMEM_MOVEABLE|GMEM_ZEROINIT, (cbNewSize + 1) * sizeof(WCHAR) );
	_ASSERTE ( hgUHTML );
	if ( NULL == hgUHTML )
	{
		hr = E_OUTOFMEMORY;
		goto LRet;
	}

	pwcUnicode = (WCHAR*)GlobalLock ( hgUHTML );
	_ASSERTE ( pwcUnicode );
	if ( NULL == hgUHTML )
	{
		hr = E_OUTOFMEMORY;
		goto LRet;
	}

	// Create the wide string.
	cbNewSize = ::MultiByteToWideChar ( CP_ACP, 0, pbData, statStg.cbSize.LowPart, pwcUnicode, cbNewSize);
	if ( 0 == cbNewSize )
	{
		hr = E_FAIL;
		goto LRet;
	}

	hr = GetCharset ( hgUHTML, cbNewSize * sizeof(WCHAR), pbstrCharset );

LRet:
	if ( NULL != hgUHTML )	{
		GlobalUnlock ( hgUHTML );
		GlobalFree ( hgUHTML );
	}

	GlobalUnlock ( hMem );
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\idroptgt.cpp ===
//------------------------------------------------------------------------------
// idroptgt.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      7-15-97     created     (bash)
//
// Implementation of IDropTarget
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include <ocidl.h>
#include <string.h>

#include "triedit.h"
#include "document.h"
#include "privcid.h"
#include "dispatch.h"
#include "trace.h"
#include "undo.h"

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DragEnter (IDropTarget method)
//
// In design mode, accept drags that originate within Trident. Allow unlocked
// 2D positioned elements to be dragged using a dashed outline as a drag 
// rectangle. If TriEdit's constrained dragging mode has been enabled using
// the Constrain method then the drag will be constrained to points which are
// even multiples of the values in m_ptConstrain. 
//

STDMETHODIMP CTriEditDocument::DragEnter(IDataObject *pDataObject,
                        DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = GetElement(TRUE /* fInDragDrop */);

    m_fLocked = FALSE;
    m_eDirection = CONSTRAIN_NONE;

    if (SUCCEEDED(hr) &&
        m_pihtmlElement &&
        SUCCEEDED(hr=GetTridentWindow()))
    {
        BOOL f2D = FALSE;
        LONG lWidth;
        LONG lHeight;
        IHTMLElement* pihtmlElementParent=NULL;
        HBITMAP hbmp;

        _ASSERTE(m_pihtmlStyle);
        if (IsDesignMode() &&           //Are we in design mode?
            m_pihtmlStyle &&            //abort if don't have style
            IsDragSource() &&           //abort if Trident isn't source of drag
            SUCCEEDED(Is2DElement(m_pihtmlElement, &f2D)) && f2D &&
            SUCCEEDED(IsLocked(m_pihtmlElement, &m_fLocked)) && !m_fLocked &&
            SUCCEEDED(GetScrollPosition()) &&
            SUCCEEDED(GetElementPosition(m_pihtmlElement, &m_rcElement)))
        {
            //first, let's get a pattern brush to use for the move rectangle
            hbmp = LoadBitmap(_Module.GetModuleInstance(), (LPCWSTR)IDR_FEEDBACKRECTBMP);
            _ASSERTE(hbmp);
            m_hbrDragRect = CreatePatternBrush(hbmp);
            _ASSERTE(m_hbrDragRect);
            DeleteObject(hbmp);

            ::SetRect(&m_rcElementParent, 0, 0, 0, 0);
            hr = m_pihtmlElement->get_offsetParent(&pihtmlElementParent);
            if (SUCCEEDED(hr) && pihtmlElementParent)
            {
                GetElementPosition(pihtmlElementParent, &m_rcElementParent);
            }
            SAFERELEASE(pihtmlElementParent);

            lWidth  = m_rcElement.right - m_rcElement.left;
            lHeight = m_rcElement.bottom - m_rcElement.top;

            //this is where we'll initially draw the drag rectangle
            m_rcDragRect = m_rcElementOrig = m_rcElement;

            //convert clicked point to client coordinates
            m_ptClickLast.x = pt.x;
            m_ptClickLast.y = pt.y;
            ScreenToClient(m_hwndTrident, &m_ptClickLast);

            //save point in doc coordinates where clicked.
            m_ptClickOrig = m_ptClickLast;
            m_ptClickOrig.x += m_ptScroll.x;
            m_ptClickOrig.y += m_ptScroll.y;

            if (m_fConstrain)
            {
                m_ptConstrain.x = m_rcElement.left;
                m_ptConstrain.y = m_rcElement.top;
            }

            #define BORDER_WIDTH 7

            if (m_ptClickOrig.x < (m_rcDragRect.left - BORDER_WIDTH))
            {
                m_rcDragRect.left   = m_ptClickOrig.x;
                m_rcDragRect.right  = m_rcDragRect.left + lWidth;
            }
            else if (m_ptClickOrig.x > (m_rcDragRect.right + BORDER_WIDTH))
            {
                m_rcDragRect.right  = m_ptClickOrig.x;
                m_rcDragRect.left   = m_rcDragRect.right - lWidth;
            }

            if (m_ptClickOrig.y < (m_rcDragRect.top  - BORDER_WIDTH))
            {
                m_rcDragRect.top    = m_ptClickOrig.y;
                m_rcDragRect.bottom = m_rcDragRect.top  + lHeight;
            }
            else if (m_ptClickOrig.y > (m_rcDragRect.bottom + BORDER_WIDTH))
            {
                m_rcDragRect.bottom = m_ptClickOrig.y;
                m_rcDragRect.top    = m_rcDragRect.bottom - lHeight;
            }

            m_rcElement = m_rcDragRect;

            //Trace("DragEnter: m_rcElement(%d,%d,%d,%d)", m_rcElement.left, m_rcElement.top, m_rcElement.right, m_rcElement.bottom);
            //Trace("DragEnter: m_rcDragRect(%d,%d,%d,%d)", m_rcDragRect.left, m_rcDragRect.top, m_rcDragRect.right, m_rcDragRect.bottom);
            //Trace("DragEnter: m_ptClickLast(%d,%d)", m_ptClickLast.x, m_ptClickLast.y);
            //Trace("DragEnter: m_ptClickOrig(%d,%d)", m_ptClickOrig.x, m_ptClickOrig.y);

            //now draw the selection rect
            Draw2DDragRect(TRUE);
            *pdwEffect = DROPEFFECT_MOVE;
            hr = S_OK;
        }
        else
        if (!m_fLocked)
        {
            //something is hosed. just bail
            ReleaseElement();
        }
    }

    if (!m_pihtmlElement && NULL != m_pDropTgtTrident)
    {
        hr = m_pDropTgtTrident->DragEnter(pDataObject, grfKeyState, pt, pdwEffect);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DragOver (IDropTarget method)
// 
// Provide feedback during a drag, updating the drag rectangle, and scrolling
// the document as needed.


STDMETHODIMP CTriEditDocument::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_UNEXPECTED;
    POINT ptClient;

    if (m_pihtmlElement &&
        !m_fLocked &&
        SUCCEEDED(GetScrollPosition()))  //we are handling the drag-drop
    {
            ptClient.x = pt.x;
            ptClient.y = pt.y;
            ScreenToClient(m_hwndTrident, &ptClient);

            // scroll if required
            if (S_OK == DragScroll(ptClient))
            {
                *pdwEffect = DROPEFFECT_MOVE | DROPEFFECT_SCROLL;
            }
            else
            {
                if (ptClient.x != m_ptClickLast.x || ptClient.y != m_ptClickLast.y)
                {
                    //update the last click position
                    m_ptClickLast.x = ptClient.x;
                    m_ptClickLast.y = ptClient.y;
    
                    //Trace("DragOver: m_ptClickLast(%d,%d)", m_ptClickLast.x, m_ptClickLast.y);
    
                    //erase the move rectangle
                    Draw2DDragRect(FALSE);
    
                    ConstrainXY(&ptClient);
                    SnapToGrid(&ptClient);

                    //redraw the move rectangle
                    Draw2DDragRect(TRUE);
                }
        *pdwEffect = DROPEFFECT_MOVE;
            }
        hr = S_OK;
        }

    if (!m_pihtmlElement && NULL != m_pDropTgtTrident)
    {
            hr = m_pDropTgtTrident->DragOver(grfKeyState, pt, pdwEffect);
    }   

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DragLeave (IDropTarget method)
// 
// If currently dragging, erase the drag rectangle.
//

STDMETHODIMP CTriEditDocument::DragLeave()
{
    HRESULT hr = E_UNEXPECTED;

    if (m_pihtmlElement && !m_fLocked)
    {
        //erase the move rectangle
        Draw2DDragRect(FALSE);

        if (m_hbrDragRect)
        {
            DeleteObject(m_hbrDragRect);
            m_hbrDragRect = NULL;
        }
        hr = S_OK;
    }
    else if (!m_pihtmlElement && NULL != m_pDropTgtTrident)
    {
        hr = m_pDropTgtTrident->DragLeave();
    }
    ReleaseElement();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Drop (IDropTarget method)
//
// After a successful drag of an unlocked element, erase the drag rectangle
// and then handle the actual drop by moving or creating an item. Newly
// created items will be 2D positionable.
//

STDMETHODIMP CTriEditDocument::Drop(IDataObject *pDataObject,
                        DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = E_UNEXPECTED;

    if (m_pihtmlElement && !m_fLocked)
    {
        _ASSERTE(m_pihtmlElement);
        _ASSERTE(m_pihtmlStyle);

        //erase the move rectangle
        Draw2DDragRect(FALSE);

        if (m_hbrDragRect)
        {
            DeleteObject(m_hbrDragRect);
            m_hbrDragRect = NULL;
        }

        if (m_pihtmlStyle)
        {
            POINT ptOrig, ptMove;

            m_rcDragRect.left   = m_rcDragRect.left   - m_rcElementParent.left;
            m_rcDragRect.top    = m_rcDragRect.top    - m_rcElementParent.top;
            m_rcDragRect.right  = m_rcDragRect.right  - m_rcElementParent.right;
            m_rcDragRect.bottom = m_rcDragRect.bottom - m_rcElementParent.bottom;

            ptOrig.x = m_rcElementOrig.left;
            ptOrig.y = m_rcElementOrig.top;
            ptMove.x = m_rcDragRect.left;
            ptMove.y = m_rcDragRect.top;
            CUndoDrag* pUndoDrag = new CUndoDrag(m_pihtmlStyle, ptOrig, ptMove);
            if (pUndoDrag)      //constructor sets m_cRef=1
            {
                hr = AddUndoUnit(m_pUnkTrident, pUndoDrag);
                _ASSERTE(SUCCEEDED(hr));
                pUndoDrag->Release();
            }

            m_pihtmlStyle->put_pixelLeft(m_rcDragRect.left);
            m_pihtmlStyle->put_pixelTop(m_rcDragRect.top);
        }

        //cleanup
        hr = S_OK;
    }

    if (!m_pihtmlElement && NULL != m_pDropTgtTrident)
    {
        hr = m_pDropTgtTrident->Drop(pDataObject, grfKeyState, pt, pdwEffect);

        // The following is to workaround a Trident bug where they don't
        // set the focus to their window upon the drop
        if (S_OK == hr)
        {
            CComPtr<IOleInPlaceSite> pInPlaceSite;
            CComPtr<IOleInPlaceFrame> pInPlaceFrame;
            CComPtr<IOleInPlaceUIWindow> pInPlaceWindow;
            RECT posRect, clipRect;
            OLEINPLACEFRAMEINFO frameInfo;
            HWND hwnd, hwndFrame;
            
            if (S_OK == m_pClientSiteHost->QueryInterface(IID_IOleInPlaceSite, (void **)&pInPlaceSite))
            {
                _ASSERTE(NULL != pInPlaceSite.p);
                if (S_OK == pInPlaceSite->GetWindowContext(&pInPlaceFrame, &pInPlaceWindow, &posRect, &clipRect, &frameInfo))
                {
                    if (NULL != pInPlaceWindow.p)
                        pInPlaceWindow->GetWindow(&hwnd);
                    else
                    {
                        _ASSERTE(NULL != pInPlaceFrame.p);
                        pInPlaceFrame->GetWindow(&hwnd);
                    }
                    // We need to walk up the parent chain till we find a frame window to work around a Vegas bug
                    // Note that this is generic enough to do the right thing for all of our clients
                    hwndFrame = hwnd;
                    do
                    {
                        if (GetWindowLong(hwndFrame, GWL_STYLE) & WS_THICKFRAME)
                            break;
                        hwndFrame = GetParent(hwndFrame);
                    } 
                    while (hwndFrame);

                    SetFocus(hwndFrame && IsWindow(hwndFrame) ? hwndFrame : hwnd);
                }
            }
        }

        // Handle 2d drop mode here
        if (S_OK == hr && !IsDragSource())
        {
            BOOL f2DCapable = FALSE;
            BOOL f2D = FALSE;

            GetElement();

            // we do the following if we are in 2DDropMode and the element is 2DCapable 
            // and the element is not already 2D or a DTC
            if (m_f2dDropMode && m_pihtmlElement &&
                SUCCEEDED(Is2DCapable(m_pihtmlElement, &f2DCapable)) && f2DCapable &&
                SUCCEEDED(Is2DElement(m_pihtmlElement, &f2D)) && !f2D &&
                FAILED(IsElementDTC(m_pihtmlElement)))
            {
                HRESULT hr;
                POINT ptClient;
                            
                ptClient.x = pt.x;
                ptClient.y = pt.y;

                if (SUCCEEDED(hr = CalculateNewDropPosition(&ptClient)))
                    hr = Make2DElement(m_pihtmlElement, &ptClient);
                else
                    hr = Make2DElement(m_pihtmlElement);

                _ASSERTE(SUCCEEDED(hr));
            }
    
            if (m_pihtmlElement)
            {
                BOOL f2D = FALSE;
                VARIANT var;
                POINT ptClient;

                ptClient.x = pt.x;
                ptClient.y = pt.y;
                                       
                if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2D)) && f2D)
                {
                    if (SUCCEEDED(CalculateNewDropPosition(&ptClient)))
                    {
                        IHTMLElement *pihtmlElementParent = NULL;

                        m_pihtmlElement->get_offsetParent(&pihtmlElementParent);

                        if(pihtmlElementParent)
                        {
                            RECT rcParent;

                            if (SUCCEEDED(GetElementPosition(pihtmlElementParent, &rcParent)))
                            {
                                m_pihtmlStyle->put_pixelLeft(ptClient.x - rcParent.left);
                                m_pihtmlStyle->put_pixelTop(ptClient.y - rcParent.top);
                            }
                            SAFERELEASE(pihtmlElementParent);
                        }
                    }

                    VariantInit(&var);
                    var.vt = VT_I4;
                    var.lVal = 0; 
                    m_pihtmlStyle->put_zIndex(var);
                    AssignZIndex(m_pihtmlElement, MADE_ABSOLUTE);
                }
            }
        }
    }

    ReleaseElement();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetElement
//
// Fetch the current Trident element and its style into m_pihtmlElement and 
// m_pihtmlStyle, respectively. If currently in mid-drag-drop (as indicated
// by fInDragDrop) then do not accept an HTML element of type "Text" as
// the currrent element. Returns S_OK or a Trident error.
//

HRESULT CTriEditDocument::GetElement(BOOL fInDragDrop)
{
    IHTMLDocument2* pihtmlDoc2=NULL;
    IHTMLSelectionObject* pihtmlSelObj=NULL;
    IHTMLTxtRange* pihtmlTxtRange=NULL;
    IHTMLControlRange* pihtmlControlRange=NULL;
    IHTMLElement* pihtmlBodyElement=NULL;
    IUnknown* punkBody=NULL;
    IUnknown* punkElement=NULL;
    IDispatch* pidisp=NULL;
    BSTR bstrType=NULL;

    ReleaseElement();           //cleanup just in case...
    _ASSERTE(m_pUnkTrident);

    HRESULT hr = GetDocument(&pihtmlDoc2);

    if (FAILED(hr))
        goto CleanUp;

    hr = pihtmlDoc2->get_selection(&pihtmlSelObj);

    if (FAILED(hr))
        goto CleanUp;

    _ASSERTE(pihtmlSelObj);
    hr = pihtmlSelObj->get_type(&bstrType);
    _ASSERTE(SUCCEEDED(hr));

    if (FAILED(hr) || !bstrType || (fInDragDrop && _wcsicmp(bstrType, L"Text")==0))
        goto CleanUp;

    hr = pihtmlSelObj->createRange(&pidisp);

    if (FAILED(hr) || !pidisp)
        goto CleanUp;

    hr = pidisp->QueryInterface(IID_IHTMLTxtRange, (LPVOID*)&pihtmlTxtRange);

    if (SUCCEEDED(hr))
    {
        _ASSERTE(pihtmlTxtRange);
        hr = pihtmlTxtRange->parentElement(&m_pihtmlElement);
        goto CleanUp;
    }

    hr = pidisp->QueryInterface(IID_IHTMLControlRange, (LPVOID*)&pihtmlControlRange);

    if (SUCCEEDED(hr))
    {
        _ASSERTE(pihtmlControlRange);
        hr = pihtmlControlRange->commonParentElement(&m_pihtmlElement);
    }

CleanUp:
    hr = E_FAIL;

    if (m_pihtmlElement)
    {
        //get the body element
        hr = pihtmlDoc2->get_body(&pihtmlBodyElement);
        _ASSERTE(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            //get their IUnknowns
            hr = pihtmlBodyElement->QueryInterface(IID_IUnknown, (LPVOID*)&punkBody);
            _ASSERTE(SUCCEEDED(hr));
            hr = m_pihtmlElement->QueryInterface(IID_IUnknown, (LPVOID*)&punkElement);
            _ASSERTE(SUCCEEDED(hr));

            //If they're equivalent, the body element is the current element
            //and we don't want it.
            if (punkBody == punkElement)
            {
                hr = E_FAIL;
            }
        }

        // VID98 bug 2647: if type is none, don't bother to cache style.
        // This is to workaround trident crash bug
        if (SUCCEEDED(hr) && bstrType && _wcsicmp(bstrType, L"None")!=0)
        {
            hr = m_pihtmlElement->get_style(&m_pihtmlStyle);
            _ASSERTE(SUCCEEDED(hr));
            _ASSERTE(m_pihtmlStyle);
        }
        if (FAILED(hr) || !m_pihtmlStyle)
        {
            ReleaseElement();
        }
        hr = S_OK;
    }
    SAFERELEASE(pihtmlDoc2);
    SAFERELEASE(pihtmlSelObj);
    SAFERELEASE(pidisp);
    SAFERELEASE(pihtmlTxtRange);
    SAFERELEASE(pihtmlControlRange);
    SAFERELEASE(pihtmlBodyElement);
    SAFERELEASE(punkBody);
    SAFERELEASE(punkElement);
    SysFreeString(bstrType);
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::ReleaseElement
//
// Release any cached reference to the current Trident element and its
// associated style. No return value.
//

void CTriEditDocument::ReleaseElement(void)
{
    SAFERELEASE(m_pihtmlElement);
    SAFERELEASE(m_pihtmlStyle);
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Draw2DDragRect
//
// After giving the drag-drop handler host a chance to draw the drag rectangle,
// draw the rectangle if the handler choose not to do so. No return value.
//

void CTriEditDocument::Draw2DDragRect(BOOL fDraw)
{
    RECT rect = m_rcDragRect;

    // S_FALSE means that the host has already drawn its own feedback
    if (m_pDragDropHandlerHost && m_pDragDropHandlerHost->DrawDragFeedback(&rect) == S_FALSE)
        return;

    if ((fDraw == m_fDragRectVisible) || (NULL == m_hwndTrident) || (NULL == m_hbrDragRect))
        return;

    HDC hdc = GetDC(m_hwndTrident);
    _ASSERTE(hdc);
    HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, m_hbrDragRect);
    _ASSERTE(hbrOld);

    //BUGS:M3-2723\The Drag Rectangle Must be at Least 8x8 pixels
    LONG lWidth  = max((rect.right - rect.left), 16);
    LONG lHeight = max((rect.bottom - rect.top), 16);

    SetWindowOrgEx(hdc, m_ptScroll.x, m_ptScroll.y, NULL);

    //A Value of 2 is added to the rect's left and top in all the following PatBlt function
    //to work around a rounding off bug caused by trident.

    PatBlt( hdc, rect.left + 2, rect.top + 2,
            lWidth, 1, PATINVERT);

    PatBlt( hdc, rect.left + 2, rect.top + lHeight + 1, //(2 - 1)
            lWidth, 1, PATINVERT);

    PatBlt( hdc, rect.left + 2, rect.top + 3,//(2 + 1)
            1, lHeight - (2 * 1), PATINVERT);

    PatBlt( hdc, rect.left + lWidth + 1 /*(2 - 1)*/, rect.top + 3, //(2 + 1)
            1, lHeight - (2 * 1), PATINVERT);

    m_fDragRectVisible = !m_fDragRectVisible;

    SelectObject(hdc, hbrOld);
    ReleaseDC(m_hwndTrident, hdc);
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetScrollPosition
//
// Get the Trident document's scroll position and store it in m_ptScroll. 
// Return S_OK or a Trident error code.
//

HRESULT CTriEditDocument::GetScrollPosition(void)
{
    IHTMLDocument2* pihtmlDoc2=NULL;
    IHTMLTextContainer* pihtmlTextContainer=NULL;
    IHTMLElement* pihtmlElement=NULL;
    HRESULT hr = E_FAIL;

    _ASSERTE(m_pUnkTrident);
    if (SUCCEEDED(GetDocument(&pihtmlDoc2)))
    {
        if (SUCCEEDED(pihtmlDoc2->get_body(&pihtmlElement)))
        {
            _ASSERTE(pihtmlElement);
            if (pihtmlElement)
            {
                if (SUCCEEDED(pihtmlElement->QueryInterface(IID_IHTMLTextContainer,
                    (LPVOID*)&pihtmlTextContainer)))
                {
                    _ASSERTE(pihtmlTextContainer);
                    if (pihtmlTextContainer)
                    {
                        hr = pihtmlTextContainer->get_scrollLeft(&m_ptScroll.x);
                        _ASSERTE(SUCCEEDED(hr));
                        hr = pihtmlTextContainer->get_scrollTop(&m_ptScroll.y);
                        _ASSERTE(SUCCEEDED(hr));
                        hr = S_OK;
                    }
                }
            }
        }
    }
    SAFERELEASE(pihtmlDoc2);
    SAFERELEASE(pihtmlTextContainer);
    SAFERELEASE(pihtmlElement);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DragScroll
//
// Scroll the Trident document so as to make the given point visible. If a
// drag rectangle is visible it will be erased before any scrolling occurs;
// the caller is responsible for redrawing the rectangle. Returns S_OK if the
// document was scrolled, S_FALSE if not scrolling was required, or a
// Trident error.
//

#define nScrollInset 5

HRESULT CTriEditDocument::DragScroll(POINT pt)
{
    RECT rectClient, rect;
    long x = 0, y = 0;
    IHTMLDocument2* pihtmlDoc2=NULL;
    IHTMLWindow2* pihtmlWindow2=NULL;

    GetClientRect(m_hwndTrident, &rectClient);
    rect = rectClient;
    InflateRect(&rect, -nScrollInset, -nScrollInset);
    if (PtInRect(&rectClient, pt) && !PtInRect(&rect, pt))
    {
        // determine direction of scroll along both X & Y axis
        if (pt.x < rect.left)
            x = -nScrollInset;
        else if (pt.x >= rect.right)
            x = nScrollInset;
        if (pt.y < rect.top)
            y = -nScrollInset;
        else if (pt.y >= rect.bottom)
            y = nScrollInset;
    }

    if (x == 0 && y == 0) // no scrolling required    
        return S_FALSE;

    _ASSERTE(m_pUnkTrident);
    if (SUCCEEDED(GetDocument(&pihtmlDoc2)))
    {
        _ASSERTE(pihtmlDoc2);
        if (SUCCEEDED(pihtmlDoc2->get_parentWindow(&pihtmlWindow2)))
        {
            _ASSERTE(pihtmlWindow2);

            // erase move rectangle before scrolling
            Draw2DDragRect(FALSE);

            pihtmlWindow2->scrollBy(x,y);
        }
    }

    SAFERELEASE(pihtmlDoc2);
    SAFERELEASE(pihtmlWindow2);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsDragSource
//
// Return TRUE if the current OLE drag-drop was originated by Trident, or
// FALSE otherwise.
//


BOOL CTriEditDocument::IsDragSource(void)
{
    BOOL fDragSource = FALSE;
    HRESULT hr;
    VARIANT var;

    if (m_pUnkTrident)
    {
        IOleCommandTarget* pioleCmdTarget;
        if (SUCCEEDED(m_pUnkTrident->QueryInterface(IID_IOleCommandTarget,
                (LPVOID*)&pioleCmdTarget)))
        {
            _ASSERTE(pioleCmdTarget);
            if (pioleCmdTarget)
            {
                VariantInit(&var);
                var.vt = VT_BOOL;
                var.boolVal = FALSE;
                hr = pioleCmdTarget->Exec( &CMDSETID_Forms3,
                              IDM_SHDV_ISDRAGSOURCE,
                              MSOCMDEXECOPT_DONTPROMPTUSER,
                              NULL,
                              &var );
                _ASSERTE(SUCCEEDED(hr));
                fDragSource = (var.boolVal) ? TRUE:FALSE;
                pioleCmdTarget->Release();
            }
        }
    }
    return fDragSource;
}


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::ConstrainXY
//
// If TriEdit's constrained dragging mode is enabled, constrain the 
// rectangle of the current element (m_rcElement) vis-a-vis the given
// point according to the current constraint direction, first computing
// the constraint direction if necessary. Return S_OK.
//

HRESULT CTriEditDocument::ConstrainXY(LPPOINT lppt)  //pt is in client coordinates
{
    POINT ptRel;

    if (m_fConstrain)
    {
        if (CONSTRAIN_NONE == m_eDirection)
        {
            ptRel.x = (lppt->x + m_ptScroll.x) - m_ptClickOrig.x;
            ptRel.y = (lppt->y + m_ptScroll.y) - m_ptClickOrig.y;

            if ((ptRel.x && !ptRel.y) || (abs(ptRel.x) > abs(ptRel.y)))
                m_eDirection = CONSTRAIN_HORIZONTAL;
            else
            if ((!ptRel.y && ptRel.y) || (abs(ptRel.y) > abs(ptRel.x)))
                m_eDirection = CONSTRAIN_VERTICAL;
            else
                m_eDirection = CONSTRAIN_HORIZONTAL;

            if (m_eDirection == CONSTRAIN_VERTICAL)
            {
                LONG lWidth = m_rcElement.right - m_rcElement.left;
                
                m_ptClickOrig.x = m_rcElement.left = m_ptConstrain.x;
                m_rcElement.right = m_rcElement.left + lWidth;
            }
            else
            {
                LONG lHeight = m_rcElement.bottom - m_rcElement.top;

                m_ptClickOrig.y = m_rcElement.top = m_ptConstrain.y;
                m_rcElement.bottom = m_rcElement.top + lHeight;
            }
        }
        switch(m_eDirection)
        {
            case CONSTRAIN_HORIZONTAL:
                lppt->y = (m_ptClickOrig.y - m_ptScroll.y);
                break;

            case CONSTRAIN_VERTICAL:
                lppt->x = (m_ptClickOrig.x - m_ptScroll.x);
                break;
        }
    }
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SnapToGrid
//
// Snap the appropriate edge of the current HTML element (m_rcElement) to the
// given point, modulo the current TriEdit grid setting. Return S_OK.
//

HRESULT CTriEditDocument::SnapToGrid(LPPOINT lppt)  //pt is in client coordinates
{
    POINT ptRel;
    POINT ptDoc;

    _ASSERTE(lppt);

    //determine relative movement
    ptRel.x = (lppt->x + m_ptScroll.x) - m_ptClickOrig.x;
    ptRel.y = (lppt->y + m_ptScroll.y) - m_ptClickOrig.y;
    ptDoc.x = m_rcElement.left - m_rcElementParent.left + ptRel.x;
    ptDoc.y = m_rcElement.top - m_rcElementParent.top + ptRel.y;

    if (ptRel.x < 0)        //LEFT
    {
        if (ptDoc.x % m_ptAlign.x)
            ptDoc.x -= (ptDoc.x % m_ptAlign.x);
        else
            ptDoc.x -= m_ptAlign.x;
    }
    else
    if (ptRel.x > 0)        //RIGHT
    {
        if (ptDoc.x % m_ptAlign.x)
            ptDoc.x += m_ptAlign.x - (ptDoc.x % m_ptAlign.x);
        else
            ptDoc.x += m_ptAlign.x;
    }

    if (ptRel.y < 0)        //UP
    {
        if (ptDoc.y % m_ptAlign.y)
            ptDoc.y -= (ptDoc.y % m_ptAlign.y);
        else
            ptDoc.y -= m_ptAlign.y;
    }
    else
    if (ptRel.y > 0)        //DOWN
    {
        if (ptDoc.y % m_ptAlign.y)
            ptDoc.y += m_ptAlign.y - (ptDoc.y % m_ptAlign.y);
        else
            ptDoc.y += m_ptAlign.y;
    }

    m_rcDragRect.left   = m_rcElementParent.left + ptDoc.x;
    m_rcDragRect.top    = m_rcElementParent.top + ptDoc.y;
    m_rcDragRect.right  = m_rcDragRect.left + (m_rcElement.right  - m_rcElement.left);
    m_rcDragRect.bottom = m_rcDragRect.top + (m_rcElement.bottom - m_rcElement.top);

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsDesignMode
//
// Return TRUE if Trident is in design (edit) mode, or FALSE if it is in
// browse mode.
//

BOOL CTriEditDocument::IsDesignMode(void)
{
    HRESULT hr;
    OLECMD olecmd;

    olecmd.cmdID = IDM_EDITMODE;
    hr = m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL);

    return (SUCCEEDED(hr) && (olecmd.cmdf & OLECMDF_LATCHED));
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetElementPosition
//
// Return (under prc) the position of the given HTML element in document
// coordinates. Return S_OK or a Trident error code as the return value.
//

HRESULT CTriEditDocument::GetElementPosition(IHTMLElement* pihtmlElement, LPRECT prc)
{
    IHTMLElement* pelem = NULL;
    IHTMLElement* pelemNext = NULL;
    POINT ptExtent;
    HRESULT hr;

    _ASSERTE(pihtmlElement && prc);
    if(!pihtmlElement || !prc)
        return E_POINTER;

    if(FAILED(pihtmlElement->get_offsetLeft(&prc->left)))
        return(E_FAIL);
    if(FAILED(pihtmlElement->get_offsetTop(&prc->top)))
        return(E_FAIL);

    hr = pihtmlElement->get_offsetParent(&pelemNext);

    while (SUCCEEDED(hr) && pelemNext)
    {
        POINT pt;

        if(FAILED(hr = pelemNext->get_offsetLeft(&pt.x)))
            goto QuickExit;
        if(FAILED(hr = pelemNext->get_offsetTop(&pt.y)))
            goto QuickExit;
        prc->left += pt.x;
        prc->top += pt.y;
        pelem = pelemNext;
        pelemNext = NULL;
        hr = pelem->get_offsetParent(&pelemNext);
        SAFERELEASE(pelem);
    }

    if (FAILED(hr = pihtmlElement->get_offsetWidth(&ptExtent.x)))
        goto QuickExit;
    if (FAILED(hr = pihtmlElement->get_offsetHeight(&ptExtent.y)))
        goto QuickExit;

    prc->right  = prc->left + ptExtent.x;
    prc->bottom = prc->top  + ptExtent.y;

QuickExit:
    _ASSERTE(SUCCEEDED(hr));
    SAFERELEASE(pelem);
    SAFERELEASE(pelemNext);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetTridentWindow
//
// Fetch the IOleWindow interface of the Trident instance in to m_hwndTrident.
// Return S_OK or the Trident error code.
//

STDMETHODIMP CTriEditDocument::GetTridentWindow()
{
    LPOLEWINDOW piolewinTrident;
    HRESULT hr = E_FAIL;

    if( m_pOleObjTrident &&
        SUCCEEDED(hr = m_pOleObjTrident->QueryInterface(IID_IOleWindow, (LPVOID*)&piolewinTrident)))
    {
        m_hwndTrident = NULL;
        hr = piolewinTrident->GetWindow(&m_hwndTrident);
        _ASSERTE(m_hwndTrident != NULL);
        piolewinTrident->Release();
    }

    _ASSERTE(SUCCEEDED(hr));
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::CalculateNewDropPosition
//
// Adjust the given point to adjust for the fact that the Trident document may
// be scrolled. Return S_OK or a Trident error code.

HRESULT CTriEditDocument::CalculateNewDropPosition(POINT *pt)
{
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(hr = GetTridentWindow()) && 
        ScreenToClient(m_hwndTrident, pt) &&
        SUCCEEDED(hr = GetScrollPosition()))
    {
        pt->x += m_ptScroll.x;
        pt->y += m_ptScroll.y;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\idhuihnd.cpp ===
//------------------------------------------------------------------------------
// idhuihnd.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      6-27-97     created     (bash)
//
// Implementation of IDocHostUIHandler.
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include "triedit.h"
#include "document.h"

STDMETHODIMP CTriEditUIHandler::QueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;

    if ( IID_IDocHostUIHandler == riid || IID_IUnknown == riid )
    {
        *ppv = this;
    }

    if ( NULL != *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CTriEditUIHandler::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CTriEditUIHandler::Release(void)
{
    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    return 0;
}

STDMETHODIMP CTriEditUIHandler::GetHostInfo(DOCHOSTUIINFO* pInfo)
{
    ATLTRACE(_T("IDocHostUIImpl::GetHostInfo\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->GetHostInfo(pInfo);

// REVIEW(MikhailA): remove this as soon as we start using IE5 headers VS-wide
#define DOCHOSTUIFLAG_TABSTOPONBODY 0x0800 // MikhailA: From IE5 headers

    pInfo->dwFlags = DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_TABSTOPONBODY;
    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;

    return S_OK;
}

STDMETHODIMP CTriEditUIHandler::ShowUI(DWORD dwID, IOleInPlaceActiveObject* pActiveObject,
                    IOleCommandTarget* /*pCommandTarget*/, IOleInPlaceFrame* pFrame,
                    IOleInPlaceUIWindow* pDoc)
{
    // ATLTRACE(_T("IDocHostUIImpl::ShowUI\n"));  Turn this off for now

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->ShowUI(dwID, pActiveObject, static_cast<IOleCommandTarget*>(m_pDoc), pFrame, pDoc);

    return S_FALSE;
}

STDMETHODIMP CTriEditUIHandler::HideUI()
{
    // ATLTRACE(_T("IDocHostUIImpl::HideUI\n"));  Turn this off for now

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->HideUI();

    return S_OK;
}

STDMETHODIMP CTriEditUIHandler::UpdateUI()
{
    // ATLTRACE(_T("IDocHostUIImpl::UpdateUI\n"));  Turn this off for now

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->UpdateUI();

    return S_OK;
}

STDMETHODIMP CTriEditUIHandler::EnableModeless(BOOL fEnable)
{
    ATLTRACE(_T("IDocHostUIImpl::EnableModeless\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->EnableModeless(fEnable);
    
    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    ATLTRACE(_T("IDocHostUIImpl::OnDocWindowActivate\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->OnDocWindowActivate(fActivate);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    ATLTRACE(_T("IDocHostUIImpl::OnFrameWindowActivate\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->OnFrameWindowActivate(fActivate);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow)
{
    ATLTRACE(_T("IDocHostUIImpl::ResizeBorder\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->ResizeBorder(prcBorder, pUIWindow, fFrameWindow);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::ShowContextMenu(DWORD dwID, POINT* pptPosition, IUnknown* pCommandTarget,
                             IDispatch* pDispatchObjectHit)
{
    ATLTRACE(_T("IDocHostUIImpl::ShowContextMenu\n"));

    if (m_pDoc->m_pUIHandlerHost)
    {
        HRESULT hr = S_OK;

        // Work around a Trident bug where they call ShowContextMenu recursively under some circumstances
        if (!m_pDoc->m_fInContextMenu)
        {
            m_pDoc->m_fInContextMenu = TRUE;
            hr = m_pDoc->m_pUIHandlerHost->ShowContextMenu(dwID, pptPosition, pCommandTarget, pDispatchObjectHit);
            m_pDoc->m_fInContextMenu = FALSE;
        }

        ATLTRACE(_T("Returning From IDocHostUIImpl::ShowContextMenu\n"));
        return hr;
    }

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::TranslateAccelerator(LPMSG lpMsg, const GUID __RPC_FAR *pguidCmdGroup, DWORD nCmdID)
{
    // ATLTRACE(_T("IDocHostUIImpl::TranslateAccelerator\n"));  Turn this off for now.

    // This is where we would add code if we wanted to handle any accelerators in TriEdit
    
    HRESULT hr  = S_FALSE;  // Defualt return value: not handled

    if (m_pDoc->m_pUIHandlerHost)
    {
        hr = m_pDoc->m_pUIHandlerHost->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
    }

    // Kill ctrl-g and ctrl-h before they reach Trident: erronious handling attempts to bring up
    // non-existant html dialogs for Go and Replace.
    if ( ( S_FALSE == hr ) && ( lpMsg->message == WM_KEYDOWN ) )
    {
        BOOL fControl = (0x8000 & GetKeyState(VK_CONTROL));
        BOOL fShift = (0x8000 & GetKeyState(VK_SHIFT));
        if ( fControl && !fShift )
        {
            switch ( lpMsg->wParam )
            {
                case 'G':
                case 'H':
                    hr = S_OK;  // Consider them handled.
                default:
                    break;
            }
        }
    }

    return hr;
}

STDMETHODIMP CTriEditUIHandler::GetOptionKeyPath(LPOLESTR* pbstrKey, DWORD dw)
{
    ATLTRACE(_T("IDocHostUIImpl::GetOptionKeyPath\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->GetOptionKeyPath(pbstrKey, dw);
    
    *pbstrKey = NULL;
    return S_FALSE;
}

STDMETHODIMP CTriEditUIHandler::GetDropTarget(IDropTarget __RPC_FAR *pDropTarget,
                           IDropTarget __RPC_FAR *__RPC_FAR *ppDropTarget)
{
    ATLTRACE(_T("IDocHostUIImpl::GetDropTarget\n"));

    SAFERELEASE(m_pDoc->m_pDropTgtTrident);

    m_pDoc->m_pDropTgtTrident = pDropTarget;
    m_pDoc->m_pDropTgtTrident->AddRef();

    if (NULL == m_pDoc->m_pUIHandlerHost ||
        S_OK != m_pDoc->m_pUIHandlerHost->GetDropTarget(static_cast<IDropTarget*>(m_pDoc), ppDropTarget))
    {
        *ppDropTarget = static_cast<IDropTarget*>(m_pDoc);
        (*ppDropTarget)->AddRef();
    }

    return S_OK;
}

STDMETHODIMP CTriEditUIHandler::GetExternal(IDispatch **ppDispatch)
{
    ATLTRACE(_T("IDocHostUIImpl::GetExternal\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->GetExternal(ppDispatch);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    ATLTRACE(_T("IDocHostUIImpl::TranslateUrl\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut);

    return E_NOTIMPL;
}

STDMETHODIMP CTriEditUIHandler::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    ATLTRACE(_T("IDocHostUIImpl::FilterDataObject\n"));

    if (m_pDoc->m_pUIHandlerHost)
        return m_pDoc->m_pUIHandlerHost->FilterDataObject(pDO, ppDORet);

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\icmdtgt.cpp ===
//------------------------------------------------------------------------------
// icmdtgt.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      7-19-97     created     (bash)
//
// Implementation of IOleCommandTarget
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include <mshtmcid.h>
#include <designer.h>

//#include "mfcincl.h"
#include "triedit.h"
#include "document.h"
#include "triedcid.h"       //TriEdit Command IDs here.
#include "dispatch.h"
#include "undo.h"

#define CMDSTATE_NOTSUPPORTED  0
#define CMDSTATE_DISABLED      OLECMDF_SUPPORTED
#define CMDSTATE_UP           (OLECMDF_SUPPORTED | OLECMDF_ENABLED)
#define CMDSTATE_DOWN         (OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_LATCHED)
#define CMDSTATE_NINCHED      (OLECMDF_SUPPORTED | OLECMDF_ENABLED | OLECMDF_NINCHED)

// Mapping from TriEdit to Trident commands
typedef struct {
ULONG cmdTriEdit;
ULONG cmdTrident;    
} CMDMAP;

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::MapTriEditCommand 
//
// Map the given TriEdit IDM to the equivalent Trident IDM. 
//
// Return:
//   Mapped command under *pCmdTrident and S_OK for a valid command.
//   E_FAIL for an invalid command.
//

HRESULT CTriEditDocument::MapTriEditCommand(ULONG cmdTriEdit, ULONG *pCmdTrident)
{
    static CMDMAP rgCmdMap[] = {
        { IDM_TRIED_ACTIVATEACTIVEXCONTROLS, IDM_NOACTIVATENORMALOLECONTROLS }, 
        { IDM_TRIED_ACTIVATEAPPLETS, IDM_NOACTIVATEJAVAAPPLETS },
        { IDM_TRIED_ACTIVATEDTCS, IDM_NOACTIVATEDESIGNTIMECONTROLS },
        { IDM_TRIED_BACKCOLOR, IDM_BACKCOLOR },
        { IDM_TRIED_BLOCKFMT, IDM_BLOCKFMT },
        { IDM_TRIED_BOLD, IDM_BOLD },
        { IDM_TRIED_BROWSEMODE, IDM_BROWSEMODE },
        { IDM_TRIED_COPY, IDM_COPY },
        { IDM_TRIED_CUT, IDM_CUT },
        { IDM_TRIED_DELETE, IDM_DELETE },
        { IDM_TRIED_EDITMODE, IDM_EDITMODE },
        { IDM_TRIED_FIND, IDM_FIND },
        { IDM_TRIED_FONT, IDM_FONT },
        { IDM_TRIED_FONTNAME, IDM_FONTNAME },
        { IDM_TRIED_FONTSIZE, IDM_FONTSIZE },
        { IDM_TRIED_FORECOLOR, IDM_FORECOLOR },
        { IDM_TRIED_GETBLOCKFMTS, IDM_GETBLOCKFMTS },
        { IDM_TRIED_HYPERLINK, IDM_HYPERLINK },
        { IDM_TRIED_IMAGE, IDM_IMAGE },
        { IDM_TRIED_INDENT, IDM_INDENT },
        { IDM_TRIED_ITALIC, IDM_ITALIC },
        { IDM_TRIED_JUSTIFYCENTER, IDM_JUSTIFYCENTER },
        { IDM_TRIED_JUSTIFYLEFT, IDM_JUSTIFYLEFT },
        { IDM_TRIED_JUSTIFYRIGHT, IDM_JUSTIFYRIGHT },
        { IDM_TRIED_ORDERLIST, IDM_ORDERLIST },
        { IDM_TRIED_OUTDENT, IDM_OUTDENT },
        { IDM_TRIED_PASTE, IDM_PASTE },
        { IDM_TRIED_PRINT, IDM_PRINT },
        { IDM_TRIED_REDO, IDM_REDO },
        { IDM_TRIED_REMOVEFORMAT, IDM_REMOVEFORMAT },
        { IDM_TRIED_SELECTALL, IDM_SELECTALL },
        { IDM_TRIED_SHOWBORDERS, IDM_SHOWZEROBORDERATDESIGNTIME },
        { IDM_TRIED_SHOWDETAILS, IDM_SHOWALLTAGS },
        { IDM_TRIED_UNDERLINE, IDM_UNDERLINE },
        { IDM_TRIED_UNDO, IDM_UNDO },
        { IDM_TRIED_UNLINK, IDM_UNLINK },
        { IDM_TRIED_UNORDERLIST, IDM_UNORDERLIST }
    };

    if (NULL == pCmdTrident)
        return E_POINTER;

    for (int i=0; i < sizeof(rgCmdMap)/sizeof(CMDMAP); ++i)
    {
        if (cmdTriEdit == rgCmdMap[i].cmdTriEdit)
        {
            *pCmdTrident = rgCmdMap[i].cmdTrident;
            return S_OK;
        }
    }

    return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SetUpDefaults
//
// Set Trident flags to the TriEdit default values:
//
//      IDM_PRESERVEUNDOALWAYS                  On
//      IDM_NOFIXUPURLSONPASTE                  On
//      IDM_NOACTIVATEDESIGNTIMECONTROLS        Off
//      IDM_NOACTIVATEJAVAAPPLETS               On
//      IDM_NOACTIVATENORMALOLECONTROLS         On
//
//
// No return value.

void CTriEditDocument::SetUpDefaults()
{
    VARIANT var;

    // Turn on Trident's preserve undo flag for setting properties
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = TRUE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             6049, // IDM_PRESERVEUNDOALWAYS
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);

    // Turn on Trident's url fixup flag for paste and drag-drop
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = TRUE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             2335, // IDM_NOFIXUPURLSONPASTE
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);

    // Set up defaults for Activating DTCs but not Applets or other ActiveX Controls
    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = FALSE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_NOACTIVATEDESIGNTIMECONTROLS,
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = TRUE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_NOACTIVATEJAVAAPPLETS,
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);

    V_VT(&var) = VT_BOOL;
    V_BOOL(&var) = TRUE;

    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_NOACTIVATENORMALOLECONTROLS,
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);
}

///////////////////////////////////////////////////////////////////////////////
//
//
// CTriEditDocument::SetUpGlyphTable
//
// Load the glyphs from the DLL and install them in Trident's table. No return
// value.
//

void CTriEditDocument::SetUpGlyphTable(BOOL fDetails)
{
    VARIANT var;
    const int RuleMax = 100; // This needs to be updated if we ever have a long rule
    const int PathMax = 256; // For %program files%\common files\microsoft shared\triedit\triedit.dll
    int iGlyphTableStart = IDS_GLYPHTABLESTART;
    int iGlyphTableEnd = fDetails ? IDS_GLYPHTABLEEND : IDS_GLYPHTABLEFORMEND;
    TCHAR szPathName[PathMax];
    TCHAR szRule[RuleMax + PathMax];
    TCHAR szGlyphTable[(RuleMax + PathMax) * (IDS_GLYPHTABLEEND - IDS_GLYPHTABLESTART + 1)];
    TCHAR *pchGlyphTable, *pchTemp;

    // Get full path name for triedit.dll
    ::GetModuleFileName(_Module.GetModuleInstance(),
            szPathName,
            sizeof(szPathName)
            );

    // Load glyph table
    pchGlyphTable = szGlyphTable;
    for (int i = iGlyphTableStart; i <= iGlyphTableEnd; i++)
    {
        ::LoadString(_Module.GetModuleInstance(), i, szRule, RuleMax);
        pchTemp = wcsstr(szRule, _T("!"));
        if (pchTemp) // else bad rule, ignore
        {
            *pchTemp = 0;
            // Copy upto the "!"
            wcscpy(pchGlyphTable, szRule);
            pchGlyphTable += wcslen(szRule);
            // Append pathname
            wcscpy(pchGlyphTable, szPathName);
            pchGlyphTable += wcslen(szPathName);
            // Skip past "!"
            pchTemp = pchTemp + 1;
            // Copy remaining characters
            wcscpy(pchGlyphTable, pchTemp);
            pchGlyphTable += wcslen(pchTemp);
        }
    }
     
    // First empty the glyph table
    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_EMPTYGLYPHTABLE,
             OLECMDEXECOPT_DONTPROMPTUSER,
             NULL,
             NULL);
    
    V_VT(&var) = VT_BSTR;
    V_BSTR(&var) = SysAllocString(szGlyphTable);
    m_pCmdTgtTrident->Exec(&CMDSETID_Forms3,
             IDM_ADDTOGLYPHTABLE,
             OLECMDEXECOPT_DONTPROMPTUSER,
             &var,
             NULL);
    VariantInit(&var);

}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::QueryStatus
//
// Report on the status of the given array of TriEdit and Trident commands. 
// Pass Trident commands on to Trident. Fix the Trident return value to
// compensate for some inconsistencies. Return S_OK if all goes well, or
// E_FAIL if not.
//


STDMETHODIMP CTriEditDocument::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                                           OLECMD prgCmds[], OLECMDTEXT *pCmdText)

{
    OLECMD *pCmd;
    INT c;
    HRESULT hr;

    if (pguidCmdGroup && IsEqualGUID((const GUID&)*pguidCmdGroup, GUID_TriEditCommandGroup))
    {
        // Loop through each command in the ary, setting the status of each.
        for (pCmd = prgCmds, c = cCmds; --c >= 0; pCmd++)
        {
            // Assume this is a valid command and set default command status to DISABLED.
            // The state will get reset to UP, DOWN or NOTSUPPORTED in the switch statement below.
            pCmd->cmdf = CMDSTATE_DISABLED;
        
            switch(pCmd->cmdID)
            {
                case IDM_TRIED_IS_1D_ELEMENT:   
                case IDM_TRIED_IS_2D_ELEMENT:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement)
                        {
                            pCmd->cmdf = CMDSTATE_UP;
                        }
                        break;
                    }

                case IDM_TRIED_SET_ALIGNMENT:
                    {
                        pCmd->cmdf = CMDSTATE_UP;
                        break;
                    }

                case IDM_TRIED_LOCK_ELEMENT:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement)
                        {
                            BOOL f2d=FALSE;
                            if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)) && f2d)
                            {
                                BOOL fLocked=FALSE;
                                pCmd->cmdf =
                                        (SUCCEEDED(IsLocked(m_pihtmlElement, &fLocked)) && fLocked)
                                        ? CMDSTATE_DOWN : CMDSTATE_UP;
                            }
                        }
                        break;
                    }
                case IDM_TRIED_CONSTRAIN:
                    {
                        pCmd->cmdf = (m_fConstrain) ? CMDSTATE_DOWN : CMDSTATE_UP;
                        break;
                    }

                case IDM_TRIED_SEND_TO_BACK:
                case IDM_TRIED_SEND_TO_FRONT:
                case IDM_TRIED_SEND_BACKWARD:
                case IDM_TRIED_SEND_FORWARD:
                case IDM_TRIED_SEND_BEHIND_1D:
                case IDM_TRIED_SEND_FRONT_1D:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement)
                        {
                            BOOL f2d=FALSE;

                            if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)) && f2d)
                            {
                                pCmd->cmdf = CMDSTATE_UP;
                            }
                        }
                        break;
                    }

                case IDM_TRIED_NUDGE_ELEMENT:
                    {
                        BOOL f2d = FALSE;

                        if (SUCCEEDED(GetElement()) && m_pihtmlElement
                            && SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)) && f2d)
                        {
                            BOOL fLock = FALSE;

                            if (!(SUCCEEDED(IsLocked(m_pihtmlElement, &fLock)) && fLock))
                                pCmd->cmdf = CMDSTATE_UP;
                        }
                        break;
                    }

                case IDM_TRIED_MAKE_ABSOLUTE:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement)
                        {
                            BOOL f2d = FALSE;

                            if (SUCCEEDED(IsElementDTC(m_pihtmlElement)))
                                break;

                            if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)))
                            {
                                BOOL f2dCapable=FALSE;
                                if ( f2d )
                                {
                                    pCmd->cmdf = CMDSTATE_DOWN;
                                }
                                else if (SUCCEEDED(Is2DCapable(m_pihtmlElement, &f2dCapable)) && f2dCapable)
                                {
                                    pCmd->cmdf = CMDSTATE_UP;
                                }
                            }
                        }
                        break;
                    }

                case IDM_TRIED_SET_2D_DROP_MODE:
                    {
                        pCmd->cmdf = (m_f2dDropMode) ? CMDSTATE_DOWN : CMDSTATE_UP;
                        break;
                    }

                case IDM_TRIED_INSERTROW:
                case IDM_TRIED_DELETEROWS:
                case IDM_TRIED_INSERTCELL:
                case IDM_TRIED_DELETECELLS:
                case IDM_TRIED_INSERTCOL:
                    {
                        pCmd->cmdf = (IsSelectionInTable() == S_OK && GetSelectionTypeInTable() != -1)? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_MERGECELLS:
                    {
                        ULONG grf = IsSelectionInTable() == S_OK ? GetSelectionTypeInTable() : 0;
                        pCmd->cmdf =  ( (grf != -1) && (!(grf & grfSelectOneCell) && (grf & (grfInSingleRow|grpSelectEntireRow))))  ? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_SPLITCELL:
                    {
                        ULONG grf = IsSelectionInTable() == S_OK ? GetSelectionTypeInTable() : 0;
                        pCmd->cmdf = ((grf != -1) && (grf & grfSelectOneCell)) ? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_DELETECOLS:
                    {
                        ULONG grf = IsSelectionInTable() == S_OK ? GetSelectionTypeInTable() : 0;
                        pCmd->cmdf = ((grf != -1) && (grf & grfInSingleRow)) ? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_INSERTTABLE:
                    {
                        pCmd->cmdf = FEnableInsertTable() ? CMDSTATE_UP : CMDSTATE_DISABLED;
                        break;
                    }

                case IDM_TRIED_DOVERB:
                    {
                        if (SUCCEEDED(GetElement()) && m_pihtmlElement && SUCCEEDED(DoVerb(NULL, TRUE)))
                            pCmd->cmdf = CMDSTATE_UP;

                        break;
                    }

                case IDM_TRIED_ACTIVATEACTIVEXCONTROLS:
                case IDM_TRIED_ACTIVATEAPPLETS:
                case IDM_TRIED_ACTIVATEDTCS:
                case IDM_TRIED_BACKCOLOR:
                case IDM_TRIED_BLOCKFMT:
                case IDM_TRIED_BOLD:
                case IDM_TRIED_BROWSEMODE:
                case IDM_TRIED_COPY:
                case IDM_TRIED_CUT:
                case IDM_TRIED_DELETE:
                case IDM_TRIED_EDITMODE:
                case IDM_TRIED_FIND:
                case IDM_TRIED_FONT:
                case IDM_TRIED_FONTNAME:
                case IDM_TRIED_FONTSIZE:
                case IDM_TRIED_FORECOLOR:
                case IDM_TRIED_GETBLOCKFMTS:
                case IDM_TRIED_HYPERLINK:
                case IDM_TRIED_IMAGE:
                case IDM_TRIED_INDENT:
                case IDM_TRIED_ITALIC:
                case IDM_TRIED_JUSTIFYCENTER:
                case IDM_TRIED_JUSTIFYLEFT:
                case IDM_TRIED_JUSTIFYRIGHT:
                case IDM_TRIED_ORDERLIST:
                case IDM_TRIED_OUTDENT:
                case IDM_TRIED_PASTE:
                case IDM_TRIED_PRINT:
                case IDM_TRIED_REDO:
                case IDM_TRIED_REMOVEFORMAT:
                case IDM_TRIED_SELECTALL:
                case IDM_TRIED_SHOWBORDERS:
                case IDM_TRIED_SHOWDETAILS:
                case IDM_TRIED_UNDERLINE:
                case IDM_TRIED_UNDO:
                case IDM_TRIED_UNLINK:
                case IDM_TRIED_UNORDERLIST:
                    {
                        // We will return E_UNEXPECTED if Trident's command target is not available
                        hr = E_UNEXPECTED;

                        _ASSERTE(m_pCmdTgtTrident);
                        if (m_pCmdTgtTrident)
                        {
                            OLECMD olecmd;
                            
                            olecmd.cmdf = pCmd->cmdf;
                            if (SUCCEEDED(MapTriEditCommand(pCmd->cmdID, &olecmd.cmdID)))
                            {
                                hr = m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, pCmdText);
                            }
                            pCmd->cmdf = olecmd.cmdf;
                        }
                        
                        if (FAILED(hr))
                            return hr;

                        // Trident returns NOTSUPPORTED sometimes when they really mean DISABLED, so we fix this up here.
                        if (pCmd->cmdf == CMDSTATE_NOTSUPPORTED)
                            pCmd->cmdf = CMDSTATE_DISABLED;

                        // Trident returns CMDSTATE_DISABLED for IDM_TRIED_GETBLOCKFMTS but this command should never be disabled
                        if (pCmd->cmdID == IDM_TRIED_GETBLOCKFMTS)
                            pCmd->cmdf = CMDSTATE_UP;

                        // Trident bug: Trident returns the wrong value for IDM_TRIED_SHOWBORDERS,
                        // IDM_TRIED_SHOWDETAILS and the IDM_TRIED_ACTIVATE* commands, so we fix
                        // them up here.  We don't have code for IDM_TRIED_ACTIVATE* since the logic
                        // of the Trident commands is actually reverse in these cases.

                        if (pCmd->cmdID == IDM_TRIED_SHOWBORDERS ||
                            pCmd->cmdID == IDM_TRIED_SHOWDETAILS)
                        {
                            if (pCmd->cmdf == CMDSTATE_UP)
                                pCmd->cmdf = CMDSTATE_DOWN;
                            else if (pCmd->cmdf == CMDSTATE_DOWN)
                                pCmd->cmdf = CMDSTATE_UP;
                        }

                        break;
                    }

                default:
                    {
                        pCmd->cmdf = CMDSTATE_NOTSUPPORTED;
                        break;
                    }
            } // switch
        } // for

        return S_OK;
    }
    else if (m_pCmdTgtTrident)
    {
        hr = m_pCmdTgtTrident->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
        if (hr != S_OK)
            return hr;

        // Loop through each command in the ary, fixing up the status of each.
        for (pCmd = prgCmds, c = cCmds; --c >= 0; pCmd++)
        {
            // Trident returns NOTSUPPORTED sometimes when they really mean DISABLED.
            if (pCmd->cmdf == CMDSTATE_NOTSUPPORTED)
                pCmd->cmdf = CMDSTATE_DISABLED;

            if (pguidCmdGroup && IsEqualGUID((const GUID&)*pguidCmdGroup, CMDSETID_Forms3))
            {
                // Trident returns CMDSTATE_DISABLED for IDM_GETBLOCKFMTS but this command should never be disabled
                if (pCmd->cmdID == IDM_GETBLOCKFMTS)
                    pCmd->cmdf = CMDSTATE_UP;

                // Trident bug: Trident returns the wrong value for IDM_SHOWZEROBORDER*,
                // IDM_SHOWALLTAGS and the IDM_NOACTIVATE* commands, so we fix
                // them up here.

                if (pCmd->cmdID == IDM_NOACTIVATENORMALOLECONTROLS ||
                    pCmd->cmdID == IDM_NOACTIVATEJAVAAPPLETS ||
                    pCmd->cmdID == IDM_NOACTIVATEDESIGNTIMECONTROLS ||
                    pCmd->cmdID == IDM_SHOWZEROBORDERATDESIGNTIME ||
                    pCmd->cmdID == IDM_SHOWALLTAGS)
                {
                    if (pCmd->cmdf == CMDSTATE_UP)
                        pCmd->cmdf = CMDSTATE_DOWN;
                    else if (pCmd->cmdf == CMDSTATE_DOWN)
                        pCmd->cmdf = CMDSTATE_UP;
                }
            }
        }

        return S_OK;
    }

    return E_UNEXPECTED;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Exec
//
// Perform the given TriEdit or Trident command. Pass Trident commands on to
// Trident for execution. Return S_OK if all goes well or E_FAIL if not.
//

STDMETHODIMP CTriEditDocument::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    if (pguidCmdGroup && IsEqualGUID((const GUID&)*pguidCmdGroup, GUID_TriEditCommandGroup) &&
        m_pUnkTrident)
    {
        HRESULT hr = GetElement();

        switch(nCmdID)
        {
            case IDM_TRIED_IS_1D_ELEMENT:   //[out,VT_BOOL]
                if (pvaOut && m_pihtmlElement &&
                    SUCCEEDED(VariantChangeType(pvaOut, pvaOut, 0, VT_BOOL)))
                {
                    hr = Is2DElement(m_pihtmlElement, (BOOL*)&pvaOut->boolVal);
                    _ASSERTE(SUCCEEDED(hr));
                    if (SUCCEEDED(hr))
                    {
                        pvaOut->boolVal = !pvaOut->boolVal;
                    }
                }
                break;
           case IDM_TRIED_IS_2D_ELEMENT:   //[out,VT_BOOL]
                if (pvaOut && m_pihtmlElement &&
                    SUCCEEDED(VariantChangeType(pvaOut, pvaOut, 0, VT_BOOL)))
                {
                    hr = Is2DElement(m_pihtmlElement, (BOOL*)&pvaOut->boolVal);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_NUDGE_ELEMENT:   //[in,VT_BYREF (VARIANT.byref=LPPOINT)]
                {
                    BOOL fLock = FALSE;
                    IsLocked(m_pihtmlElement, &fLock);
                    if (!pvaIn)
                        hr = E_FAIL;
                    else if (!fLock && VT_BYREF == pvaIn->vt && pvaIn->byref)
                    {
                        hr = NudgeElement(m_pihtmlElement, (LPPOINT)pvaIn->byref);
                        _ASSERTE(SUCCEEDED(hr));
                    }
                }
                break;
            case IDM_TRIED_SET_ALIGNMENT:   //[in,VT_BYREF (VARIANT.byref=LPPOINT)]
                if (!pvaIn)
                    hr = E_FAIL;
                else if (VT_BYREF == pvaIn->vt && pvaIn->byref)
                {
                    hr = SetAlignment((LPPOINT)pvaIn->byref);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_LOCK_ELEMENT:
                if (m_pihtmlElement)
                {
                    BOOL f2d=FALSE;
                    BOOL fLocked=TRUE;
                    if (SUCCEEDED(Is2DElement(m_pihtmlElement, &f2d)) && f2d &&
                            SUCCEEDED(IsLocked(m_pihtmlElement, &fLocked)))
                    {
                        hr = LockElement(m_pihtmlElement, !fLocked);
                        _ASSERTE(SUCCEEDED(hr));
                    }
                }
                break;
            case IDM_TRIED_SEND_TO_BACK:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_TO_BACK);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_TO_FRONT:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_TO_FRONT);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_BACKWARD:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_BACKWARD);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_FORWARD:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_FORWARD);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_BEHIND_1D:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_BEHIND_1D);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_SEND_FRONT_1D:
                if (m_pihtmlElement)
                {
                    hr = AssignZIndex(m_pihtmlElement, SEND_FRONT_1D);
                    _ASSERTE(SUCCEEDED(hr));
                }
                break;
            case IDM_TRIED_CONSTRAIN:
                if (!pvaIn)
                    hr = E_FAIL;
                else if (SUCCEEDED(hr = VariantChangeType(pvaIn, pvaIn, 0, VT_BOOL)))
                {
                    hr = Constrain((BOOL)pvaIn->boolVal);
                }
                break;
            case IDM_TRIED_SET_2D_DROP_MODE:
                if (!pvaIn)
                    hr = E_FAIL;
                else if (SUCCEEDED(hr = VariantChangeType(pvaIn, pvaIn, 0, VT_BOOL)))
                {
                    m_f2dDropMode = pvaIn->boolVal;
                }
                break;
            case IDM_TRIED_INSERTROW:
                hr = InsertTableRow();
                break;
            case IDM_TRIED_INSERTCOL:
                hr = InsertTableCol();
                break;
            case IDM_TRIED_INSERTCELL:
                hr = InsertTableCell();
                break;
            case IDM_TRIED_DELETEROWS:
                hr = DeleteTableRows();
                break;
            case IDM_TRIED_DELETECOLS:
                hr = DeleteTableCols();
                break;
            case IDM_TRIED_DELETECELLS:
                hr = DeleteTableCells();
                break;
            case IDM_TRIED_MERGECELLS:
                hr = MergeTableCells();
                break;
            case IDM_TRIED_SPLITCELL:
                hr = SplitTableCell();
                break;
            case IDM_TRIED_INSERTTABLE:
                hr = InsertTable(pvaIn);
                break;
            case IDM_TRIED_DOVERB:
                if (m_pihtmlElement)
                    hr = DoVerb(pvaIn, FALSE);
                else
                    hr = E_FAIL;
                break;
            case IDM_TRIED_MAKE_ABSOLUTE:
                if (m_pihtmlElement)
                {
                    BOOL f2d = FALSE;
                    hr = Is2DElement(m_pihtmlElement, &f2d);

                    if (SUCCEEDED(hr))
                    {
                        BOOL f2dCapable=FALSE;
                        if ( f2d )
                        {
                            hr = Make1DElement(m_pihtmlElement);
                            _ASSERTE(SUCCEEDED(hr));
                        }
                        else if (SUCCEEDED(Is2DCapable(m_pihtmlElement, &f2dCapable)) && f2dCapable)
                        {
                            hr = Make2DElement(m_pihtmlElement);
                            _ASSERTE(SUCCEEDED(hr));
                        }

                    }

                }
                break;

            case IDM_TRIED_ACTIVATEACTIVEXCONTROLS:
            case IDM_TRIED_ACTIVATEAPPLETS:
            case IDM_TRIED_ACTIVATEDTCS:
            case IDM_TRIED_BACKCOLOR:
            case IDM_TRIED_BLOCKFMT:
            case IDM_TRIED_BOLD:
            case IDM_TRIED_BROWSEMODE:
            case IDM_TRIED_COPY:
            case IDM_TRIED_CUT:
            case IDM_TRIED_DELETE:
            case IDM_TRIED_EDITMODE:
            case IDM_TRIED_FIND:
            case IDM_TRIED_FONT:
            case IDM_TRIED_FONTNAME:
            case IDM_TRIED_FONTSIZE:
            case IDM_TRIED_FORECOLOR:
            case IDM_TRIED_GETBLOCKFMTS:
            case IDM_TRIED_HYPERLINK:
            case IDM_TRIED_IMAGE:
            case IDM_TRIED_INDENT:
            case IDM_TRIED_ITALIC:
            case IDM_TRIED_JUSTIFYCENTER:
            case IDM_TRIED_JUSTIFYLEFT:
            case IDM_TRIED_JUSTIFYRIGHT:
            case IDM_TRIED_ORDERLIST:
            case IDM_TRIED_OUTDENT:
            case IDM_TRIED_PASTE:
            case IDM_TRIED_PRINT:
            case IDM_TRIED_REDO:
            case IDM_TRIED_REMOVEFORMAT:
            case IDM_TRIED_SELECTALL:
            case IDM_TRIED_SHOWBORDERS:
            case IDM_TRIED_SHOWDETAILS:
            case IDM_TRIED_UNDERLINE:
            case IDM_TRIED_UNDO:
            case IDM_TRIED_UNLINK:
            case IDM_TRIED_UNORDERLIST:
                {
                    ULONG cmdTrident;
                    VARIANT varColor;

                    // We will return E_FAIL if Trident's command target is not available
                    hr = E_FAIL;

                    _ASSERTE(m_pCmdTgtTrident);
                    if (m_pCmdTgtTrident && (SUCCEEDED(MapTriEditCommand(nCmdID, &cmdTrident))))
                    {
                        if (nCmdID == IDM_TRIED_ACTIVATEACTIVEXCONTROLS ||
                            nCmdID == IDM_TRIED_ACTIVATEAPPLETS ||
                            nCmdID == IDM_TRIED_ACTIVATEDTCS)
                        {
                            if (pvaIn && pvaIn->vt == VT_BOOL)
                                pvaIn->boolVal = !pvaIn->boolVal;
                        }
                       
                        // Trident bug: When you exec the forecolor, fontname or fontsize command, they also change the backcolor,
                        // so we apply a workaround here.  The workaround is to save the old backcolor and exec it later.
                        if (pvaIn && (nCmdID == IDM_TRIED_FORECOLOR || nCmdID == IDM_TRIED_FONTNAME || nCmdID == IDM_TRIED_FONTSIZE))
                        {
                            HRESULT hrT;
 
                            VariantInit(&varColor);
                            V_VT(&varColor) = VT_I4;

                            hrT = m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_BACKCOLOR, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &varColor);
                            _ASSERTE(SUCCEEDED(hrT));
                        }

                        // Trident bug: When you exec the block format command with "Normal", they don't remove OL and UL tags
                        if (pvaIn && nCmdID == IDM_TRIED_BLOCKFMT && pvaIn->vt == VT_BSTR && (_wcsicmp(pvaIn->bstrVal, L"Normal") == 0))
                        {
                            OLECMD olecmd;

                            olecmd.cmdID = IDM_ORDERLIST;
                            olecmd.cmdf = CMDSTATE_NOTSUPPORTED;
                            if (S_OK == m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL) && olecmd.cmdf == CMDSTATE_DOWN)
                                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_ORDERLIST, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
                            
                            olecmd.cmdID = IDM_UNORDERLIST;
                            olecmd.cmdf = CMDSTATE_NOTSUPPORTED;
                            if (S_OK == m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL) && olecmd.cmdf == CMDSTATE_DOWN)
                                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_UNORDERLIST, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
                        }

                        hr = m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, cmdTrident, nCmdExecOpt, pvaIn, pvaOut);

                        if (pvaIn && (nCmdID == IDM_TRIED_FORECOLOR || nCmdID == IDM_TRIED_FONTNAME || nCmdID == IDM_TRIED_FONTSIZE))
                        {
                            HRESULT hrT;

                            hrT = m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_BACKCOLOR, OLECMDEXECOPT_DONTPROMPTUSER, &varColor, NULL);
                            _ASSERTE(SUCCEEDED(hrT));
                        }
                        else if (nCmdID == IDM_TRIED_SHOWDETAILS && pvaIn && pvaIn->vt == VT_BOOL)
                        {
                            SetUpGlyphTable(pvaIn->boolVal);
                        }

                        // Trident bug: They enable the justify commands but not actually support them.
                        // We workaround this by returning S_OK for these no matter what Trident returns.
                        if (nCmdID == IDM_TRIED_JUSTIFYLEFT || nCmdID == IDM_TRIED_JUSTIFYCENTER || nCmdID == IDM_TRIED_JUSTIFYRIGHT)
                            hr = S_OK;
                    }

                    break;
                }

            default:
                hr = E_FAIL;
                break;
        }

        if (pvaIn)
            VariantClear(pvaIn);

        // We shouldn't return any unexpected error codes here, so return E_FAIL
        if (FAILED(hr))
            hr = E_FAIL;

        return hr;
    }
    else if (m_pCmdTgtTrident)
    {
        HRESULT hr;
        BOOL fTridentCmdSet;
        VARIANT varColor;

        fTridentCmdSet = pguidCmdGroup && IsEqualGUID((const GUID&)*pguidCmdGroup, CMDSETID_Forms3);

#ifdef NEEDED
        if (fTridentCmdSet)
        {
            if (nCmdID == IDM_PARSECOMPLETE)
                OnObjectModelComplete();
            return S_OK;
        }
#endif //NEEDED

        // Trident bug: When you exec the forecolor, fontname or fontsize command, they also change the backcolor,
        // so we apply a workaround here.  The workaround is to save the old backcolor and exec it later.
        if (pvaIn && fTridentCmdSet && (nCmdID == IDM_FORECOLOR || nCmdID == IDM_FONTNAME || nCmdID == IDM_FONTSIZE))
        {
            HRESULT hrT;

            VariantInit(&varColor);
            V_VT(&varColor) = VT_I4;

            hrT = m_pCmdTgtTrident->Exec(pguidCmdGroup, IDM_BACKCOLOR, OLECMDEXECOPT_DONTPROMPTUSER, NULL, &varColor);
            _ASSERTE(SUCCEEDED(hrT));
        }

        // Trident bug: When you exec the block format command with "Normal", they don't remove OL and UL tags
        if (pvaIn && fTridentCmdSet && nCmdID == IDM_BLOCKFMT && pvaIn->vt == VT_BSTR && (_wcsicmp(pvaIn->bstrVal, L"Normal") == 0))
        {
            OLECMD olecmd;

            olecmd.cmdID = IDM_ORDERLIST;
            olecmd.cmdf = CMDSTATE_NOTSUPPORTED;
            if (S_OK == m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL) && olecmd.cmdf == CMDSTATE_DOWN)
                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_ORDERLIST, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
            
            olecmd.cmdID = IDM_UNORDERLIST;
            olecmd.cmdf = CMDSTATE_NOTSUPPORTED;
            if (S_OK == m_pCmdTgtTrident->QueryStatus(&CMDSETID_Forms3, 1, &olecmd, NULL) && olecmd.cmdf == CMDSTATE_DOWN)
                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_UNORDERLIST, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        }

        hr = m_pCmdTgtTrident->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut);

        if (pvaIn && fTridentCmdSet && (nCmdID == IDM_FORECOLOR || nCmdID == IDM_FONTNAME || nCmdID == IDM_FONTSIZE))
        {
            HRESULT hrT;

            hrT = m_pCmdTgtTrident->Exec(pguidCmdGroup, IDM_BACKCOLOR, OLECMDEXECOPT_DONTPROMPTUSER, &varColor, NULL);
            _ASSERTE(SUCCEEDED(hrT));
        }
        else if ((nCmdID == IDM_SHOWALLTAGS || nCmdID == IDM_SHOWMISCTAGS) && pvaIn && pvaIn->vt == VT_BOOL)
        {
            SetUpGlyphTable(pvaIn->boolVal);
        }

        // Trident bug: They enable the justify commands but not actually support them.
        // We workaround this by returning S_OK for these no matter what Trident returns.
        if (fTridentCmdSet && (nCmdID == IDM_JUSTIFYLEFT || nCmdID == IDM_JUSTIFYCENTER || nCmdID == IDM_JUSTIFYRIGHT))
            hr = S_OK;

        return hr;
    }

    return E_UNEXPECTED;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Is2DElement
//
// Test the given HTML element to ascertain if it is 2D positioned or not.
// Return:
//      S_OK and *pf2D = TRUE if the element is 2D positioned.
//      S_OK and *pf2D = FALSE if the element is not 2D positioned.
//

HRESULT CTriEditDocument::Is2DElement(IHTMLElement* pihtmlElement, BOOL* pf2D)
{
    IHTMLStyle* pihtmlStyle = NULL;
    BSTR bstrPosition = NULL;
    BOOL f2DCapable;
    _ASSERTE(pihtmlElement);
    _ASSERTE(pf2D);

    *pf2D = FALSE;

    if (SUCCEEDED(Is2DCapable(pihtmlElement, &f2DCapable)))
    {
        if (f2DCapable && SUCCEEDED(pihtmlElement->get_style(&pihtmlStyle)))
        {
            _ASSERTE(pihtmlStyle);
            if (SUCCEEDED(pihtmlStyle->get_position(&bstrPosition)))
            {
                if (bstrPosition)
                {
                    *pf2D = (_wcsicmp(bstrPosition, L"absolute") == 0);
                    SysFreeString(bstrPosition);
                }
            SAFERELEASE(pihtmlStyle);
            }
        }
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEDitDocument::NudgeElement
//
// Move the given HTML element (which must be 2D positioned) as indicated
// by pptNudge, further adjusted by the grid spacing in m_ptAlign. Returns
// S_OK if all goes well; E_UNEXPECTED otherwise.
//

HRESULT CTriEditDocument::NudgeElement(IHTMLElement* pihtmlElement, LPPOINT pptNudge)
{
    HRESULT hr = E_UNEXPECTED;
    IHTMLStyle* pihtmlStyle = NULL;
    long x, y;

    _ASSERTE(pihtmlElement);
    _ASSERTE(pptNudge);
    if (pihtmlElement)
    {
        if (SUCCEEDED(pihtmlElement->get_style(&pihtmlStyle)) &&
            pihtmlStyle &&
            SUCCEEDED(pihtmlStyle->get_pixelTop(&y)) &&
            SUCCEEDED(pihtmlStyle->get_pixelLeft(&x)))
        {
            if (x == 0 || y == 0)
            {
                IHTMLElement *pihtmlElementParent = NULL;
                RECT rcElement, rcParent;

                if (SUCCEEDED(pihtmlElement->get_offsetParent(&pihtmlElementParent))
                    && pihtmlElementParent)
                {
                    if (SUCCEEDED(GetElementPosition(pihtmlElement, &rcElement)))
                    {
                        ::SetRect(&rcParent, 0, 0, 0, 0);

                        if (SUCCEEDED(GetElementPosition(pihtmlElementParent, &rcParent)))
                        {
                            x = rcElement.left - rcParent.left;
                            y = rcElement.top - rcParent.top;
                        }
                    }
                    pihtmlElementParent->Release();
                }
            }

            x += pptNudge->x;
            y += pptNudge->y;
            if (pptNudge->x != 0)
            {
                if (x >= 0)
                    x -= (x % m_ptAlign.x);
                else
                    x -= (((x % m_ptAlign.x) ? m_ptAlign.x : 0) + (x % m_ptAlign.x));
            }
            if (pptNudge->y != 0)
            {
                if (y >= 0)
                    y -= (y % m_ptAlign.y);
                else
                    y -= (((y % m_ptAlign.y) ? m_ptAlign.y : 0) + (y % m_ptAlign.y));
            }
            pihtmlStyle->put_pixelTop(y);
            pihtmlStyle->put_pixelLeft(x);
            return S_OK;
        }
    }
    SAFERELEASE(pihtmlStyle);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SetAlignment
//
// Set the TriEdit alignment values as indicated. Return S_OK if all goes
// well; or E_POINTER if a bad pointer is supplied.
//

HRESULT CTriEditDocument::SetAlignment(LPPOINT pptAlign)
{
    _ASSERTE(pptAlign);
    if (pptAlign)
    {
        m_ptAlign.x = max(pptAlign->x, 1);
        m_ptAlign.y = max(pptAlign->y, 1);
        return S_OK;
    }
    return E_POINTER;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::LockElement
//
// Set or clear the TriEdit design-time locking flag (an expando attribute) as
// indicated by fLock. Return S_OK if all goes well; E_FAIL if not. Note that
// setting the locking flag also sets the top and left attributes if they
// were not already set.
//

HRESULT CTriEditDocument::LockElement(IHTMLElement* pihtmlElement, BOOL fLock)
{
    IHTMLStyle* pihtmlStyle=NULL;
    HRESULT hr = E_FAIL;
    VARIANT var;
    VARIANT_BOOL fSuccess = FALSE;

    if (pihtmlElement)
    {
        hr = pihtmlElement->get_style(&pihtmlStyle);
        _ASSERTE(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            _ASSERTE(pihtmlStyle);
            if (pihtmlStyle)
            {
                if(!fLock)
                {
                    hr = pihtmlStyle->removeAttribute(DESIGN_TIME_LOCK, 0, &fSuccess);
                    _ASSERTE(fSuccess);
                }
                else
                {
                    // Trident doesn't persist the Design_Time_Lock attribute
                    // if left, top, width and height properties are not present as part of
                    // the elements style attribute. Hence as a part of locking the element 
                    // we also assign the top and left styles only if they don't exist.

                    LONG lTop, lLeft;

                    pihtmlStyle->get_pixelTop(&lTop);
                    pihtmlStyle->get_pixelLeft(&lLeft);

                    if (lTop == 0 || lLeft == 0)
                    {
                        IHTMLElement *pihtmlElementParent = NULL;

                        if (SUCCEEDED(pihtmlElement->get_offsetParent(&pihtmlElementParent))
                            && pihtmlElementParent)
                        {
                            if (SUCCEEDED(GetElementPosition(pihtmlElement, &m_rcElement)))
                            {
                                RECT rcParent;
                                ::SetRect(&rcParent, 0, 0, 0, 0);
    
                                if (SUCCEEDED(GetElementPosition(pihtmlElementParent, &rcParent)))
                                {
                                    m_rcElement.left   = m_rcElement.left - rcParent.left;
                                    m_rcElement.top    = m_rcElement.top  - rcParent.top;
                                    pihtmlStyle->put_pixelTop(m_rcElement.top);
                                    pihtmlStyle->put_pixelLeft(m_rcElement.left);
                                }
                            }
                            pihtmlElementParent->Release();
                        }
                    }

                    VariantInit(&var);
                    var.vt = VT_BSTR;
                    var.bstrVal = SysAllocString(L"True");
                    hr = pihtmlStyle->setAttribute(DESIGN_TIME_LOCK, var, 0);
                    hr = SUCCEEDED(hr) ? S_OK:E_FAIL;
                }
                pihtmlStyle->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            RECT rcElement;

            hr = GetElementPosition(pihtmlElement, &rcElement);
            _ASSERTE(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
            {
                 InflateRect(&rcElement, ELEMENT_GRAB_SIZE, ELEMENT_GRAB_SIZE);
                 if( SUCCEEDED(hr = GetTridentWindow()))
                 {
                     _ASSERTE(m_hwndTrident);
                     InvalidateRect(m_hwndTrident,&rcElement, FALSE);
                 }
            }

            // Trident doesn't set itself to be dirty, so force the dirty state.
            VariantInit(&var);
            var.vt = VT_BOOL;
            var.boolVal = TRUE; 
            if (m_pCmdTgtTrident)           
                m_pCmdTgtTrident->Exec(&CMDSETID_Forms3, IDM_SETDIRTY, 0, &var, NULL);
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsLocked
//
// Test the given HTML element to ascertain if it is design-time locked or not.
// Return:
//      S_OK and *pfLocked = TRUE if the element is design-time locked.
//      S_OK and *pfLocked = FALSE if the element is not design-time locked.
//

HRESULT CTriEditDocument::IsLocked(IHTMLElement* pihtmlElement, BOOL* pfLocked)
{
    IHTMLStyle* pihtmlStyle=NULL;
    BSTR bstrAttributeName = NULL;
    HRESULT hr = E_FAIL;
    VARIANT var;

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = NULL;

    if (pihtmlElement)
    {
        hr = pihtmlElement->get_style(&pihtmlStyle);
        _ASSERTE(SUCCEEDED(hr));
        if (SUCCEEDED(hr))
        {
            _ASSERTE(pihtmlStyle);
            if (pihtmlStyle)
            {
                bstrAttributeName = SysAllocString(DESIGN_TIME_LOCK);

                if (bstrAttributeName)
                {
                    hr = pihtmlStyle->getAttribute(bstrAttributeName, 0, &var);
                    _ASSERTE(SUCCEEDED(hr));
                    if (var.bstrVal == NULL)
                        *pfLocked = FALSE;
                    else
                        *pfLocked = TRUE;
                    SysFreeString(bstrAttributeName);
                }
                pihtmlStyle->Release();
            }
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//
// CTriEditDocument::Make1DElement
//
// Set the given HTML element to layout in the flow. As a side effect this
// also removes any design-time lock on the element. Return S_OK if all goes
// well; E_UNEXPECTED otherwise.
//

HRESULT CTriEditDocument::Make1DElement(IHTMLElement* pihtmlElement)
{
    IHTMLStyle* pihtmlStyle=NULL;
    VARIANT_BOOL fSuccess = FALSE;
    VARIANT var;
    HRESULT hr;

    if (pihtmlElement)
    {
        pihtmlElement->get_style(&pihtmlStyle);
        _ASSERTE(pihtmlStyle);
        if (pihtmlStyle)
        {
            VariantInit(&var);
            var.vt = VT_I4;
            var.lVal = 0; 
            hr = pihtmlStyle->put_zIndex(var);
            _ASSERTE(SUCCEEDED(hr));

            pihtmlStyle->removeAttribute(DESIGN_TIME_LOCK, 0, &fSuccess);
            pihtmlStyle->removeAttribute(L"position", 0, &fSuccess);
            pihtmlStyle->Release();
        }
    }
    
    return (fSuccess? S_OK: E_UNEXPECTED);
}

///////////////////////////////////////////////////////////////////////////////
//
//
// CTriEditDocument::Make2DElement
//
// Set the given HTML element to be positioned. Return S_OK if all goes
// well; E_FAIL otherwise.
//

HRESULT CTriEditDocument::Make2DElement(IHTMLElement* pihtmlElement, POINT *ppt)
{

    IHTMLElement* pihtmlElementParent = NULL;
    IHTMLElementCollection* pihtmlCollection = NULL;
    IHTMLElement* pihtmlElementNew = NULL;
    IHTMLStyle* pihtmlElementStyle = NULL;
    VARIANT var;
    LONG lSourceIndex;
    HRESULT hr = E_FAIL;
    BSTR bstrOuterHtml = NULL;

    _ASSERTE(pihtmlElement);

    if(!pihtmlElement)
    {
        return E_FAIL;
    }
    
    hr = pihtmlElement->get_style(&pihtmlElementStyle);
    _ASSERTE(SUCCEEDED(hr) && pihtmlElementStyle);

    if (FAILED(hr) || !pihtmlElementStyle)
    {
        return E_FAIL;
    }

    // The reason to save the source index here is that once we call put_outerHTML
    // the element is lost, we later use the source index to get back the element from the collection.  
    // Note that the source index remains the same after put_outerHTML.
    hr = pihtmlElement->get_sourceIndex(&lSourceIndex); 
    _ASSERTE(SUCCEEDED(hr) && (lSourceIndex != -1));
    
    if (lSourceIndex == -1 || FAILED(hr))
    {
        return E_FAIL;
    }

    hr = pihtmlElement->get_offsetParent(&pihtmlElementParent);
    _ASSERTE(SUCCEEDED(hr) && pihtmlElementParent);

    if (SUCCEEDED(hr) && pihtmlElementParent)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(L"absolute");
        hr = pihtmlElementStyle->setAttribute(L"position", var, 1);

        if (var.bstrVal)
            SysFreeString(var.bstrVal);

        _ASSERTE(SUCCEEDED(hr));

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr = GetElementPosition(pihtmlElement, &m_rcElement)))
            {
                IHTMLTable* pihtmlTable = NULL;
                IHTMLElement* pihtmlElementTemp = NULL, *pihtmlElementPrev = NULL;
                RECT rcParent;
                BOOL f2d = FALSE;
                BOOL fIsIE5AndBeyond = IsIE5OrBetterInstalled();

                ::SetRect(&rcParent, 0, 0, 0, 0);

                pihtmlElementTemp = pihtmlElementParent;
                pihtmlElementTemp->AddRef();

                // Handle tables specially since the offset parent may have been the TD or the TR
                while (pihtmlElementTemp)
                {
                    if (SUCCEEDED(pihtmlElementTemp->QueryInterface(IID_IHTMLTable, (void **)&pihtmlTable)) && pihtmlTable)
                        break;

                    pihtmlElementPrev = pihtmlElementTemp;
                    pihtmlElementPrev->get_offsetParent(&pihtmlElementTemp);
                    SAFERELEASE(pihtmlElementPrev);
                }

                // If parent is a 2d element, we need to offset its top and left
                if (pihtmlElementTemp && SUCCEEDED(Is2DElement(pihtmlElementTemp, &f2d)) && f2d)
                {
                    GetElementPosition(pihtmlElementTemp, &rcParent);
                }
                else if (SUCCEEDED(Is2DElement(pihtmlElementParent, &f2d)) && f2d)
                {
                    GetElementPosition(pihtmlElementParent, &rcParent);
                }

                SAFERELEASE(pihtmlTable);
                SAFERELEASE(pihtmlElementTemp);
                SAFERELEASE(pihtmlElementPrev);

                m_rcElement.left   = (ppt ? ppt->x : m_rcElement.left) - rcParent.left;
                m_rcElement.top    = (ppt ? ppt->y : m_rcElement.top) - rcParent.top;

                // We need to call get_outerHTML and put_outerHTML to work around a Trident bug
                // We should not really have to call these here, but the element doesn't get
                // updated unless we do this.
                if (fIsIE5AndBeyond || SUCCEEDED(hr = pihtmlElement->get_outerHTML(&bstrOuterHtml)))
                {
                    if (fIsIE5AndBeyond || SUCCEEDED(hr = pihtmlElement->put_outerHTML(bstrOuterHtml)))
                    {
                        hr = GetAllCollection(&pihtmlCollection);
                        _ASSERTE(SUCCEEDED(hr));
                        _ASSERTE(pihtmlCollection);

                        if (SUCCEEDED(hr) && pihtmlCollection)
                        {
                            hr = GetCollectionElement(pihtmlCollection, lSourceIndex, &pihtmlElementNew);
                            _ASSERTE(SUCCEEDED(hr));
                            _ASSERTE(pihtmlElementNew);

                            if (SUCCEEDED(hr) && pihtmlElementNew)
                            {
                                hr = SelectElement(pihtmlElementNew, pihtmlElementParent);

                                GetElement(); // to update m_pihtmlElement and friends after the above SelectElement

                                if (SUCCEEDED(hr))
                                {
                                    hr = AssignZIndex(pihtmlElementNew,  MADE_ABSOLUTE);
                                    _ASSERTE(SUCCEEDED(hr));

                                    if (SUCCEEDED(hr))
                                    {
                                        SAFERELEASE(pihtmlElementStyle);
                                        if (SUCCEEDED(hr = pihtmlElementNew->get_style(&pihtmlElementStyle)))
                                        {
                                            pihtmlElementStyle->put_pixelLeft(m_rcElement.left);
                                            pihtmlElementStyle->put_pixelTop(m_rcElement.top);
                                            VariantInit(&var);
                                            var.vt = VT_BOOL;
                                            var.boolVal = FALSE;
                                            pihtmlElementNew->scrollIntoView(var);
                                         }

                                    }

                                }

                            }

                        }

                    }

                }

            }

        }

    }
               
    if (bstrOuterHtml)                  
        SysFreeString(bstrOuterHtml);

    SAFERELEASE(pihtmlElementParent);
    SAFERELEASE(pihtmlElementStyle);
    SAFERELEASE(pihtmlElementNew);
    SAFERELEASE(pihtmlCollection);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::Constrain
// 
// Set the TriEdit constraint flag as indicated by fConstrain. Also, reset
// the constraint direction to CONSTRAIN_NONE. Return S_OK.

HRESULT CTriEditDocument::Constrain(BOOL fConstrain)
{
    m_fConstrain = (fConstrain) ? TRUE:FALSE;
    m_eDirection = CONSTRAIN_NONE;
    return S_OK;
}

typedef struct SELCELLINFO
   {
       LONG cCellIndex; // cell index in a row
       LONG cRowIndex; // which row is this cell in
       CComPtr<IDispatch> srpCell; // cell element
       CComPtr<IDispatch> srpRow; // row element
       CComPtr<IDispatch> srpTable;
   } SELCELLINFO;


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetTableRowElementAndTableFromCell
//
// Given the IDispatch pointer to an element within a table, return the
// row index in *pindexRow (if pindexRow is not NULL) and/or the 
// actual row element in *psrpRow (if psrpRow is not NULL) of the
// element within the table. If psrpTable is not NULL, return the
// table containing the element therein. Return S_OK if all goes well,
// or E_FAIL if something goes wrong.
//

HRESULT CTriEditDocument::GetTableRowElementAndTableFromCell(IDispatch *srpCell, LONG *pindexRow , IDispatch **psrpRow, IDispatch **psrpTable)
{
   CComPtr<IDispatch>    srpParent,srpElement;
   HRESULT hr = E_FAIL;
   CComBSTR bstrTag;

    _ASSERTE(srpCell != NULL);

    if (pindexRow == NULL && psrpRow == NULL)
        goto Fail;

    srpParent = srpCell;

    while (srpParent != NULL)
    {
        srpElement.Release();
        if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&srpElement)))
            goto Fail;

        if (srpElement == NULL)
            {
            hr = E_FAIL;
            goto Fail;
            }

        bstrTag.Empty();
        if (FAILED(hr = GetDispatchProperty(srpElement, L"tagName", VT_BSTR, &bstrTag)))
            goto Fail;

        if (lstrcmpi(_T("TR"), OLE2T(bstrTag)) == 0)
        {
            if (psrpRow != NULL)
            {
                *psrpRow = srpElement;
                (*psrpRow)->AddRef();
            }

            if (pindexRow != NULL)
            {
                if (FAILED(hr = GetDispatchProperty(srpElement, L"rowIndex", VT_I4, pindexRow)))
                    goto Fail;
            }
            break;
        }
        srpParent = srpElement;
    }

   if (psrpTable != NULL)
   {
       srpParent = srpElement;
       while (srpParent != NULL)
       {
            srpElement.Release();
            if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&srpElement)))
                goto Fail;

            if (srpElement == NULL)
                {
                hr = E_FAIL;
                goto Fail;
                }

            bstrTag.Empty();
            if (FAILED(hr = GetDispatchProperty(srpElement, L"tagName", VT_BSTR, &bstrTag)))
                goto Fail;

            if (lstrcmpi(_T("TABLE"), OLE2T(bstrTag)) == 0)
            {
                if (psrpTable != NULL)
                {
                    *psrpTable = srpElement;
                    (*psrpTable)->AddRef();
                }
                break;
            }
            srpParent = srpElement;
        }
   }

Fail:

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::FEnableInsertTable
//
// Return TRUE if the Trident selection is within a table and if the selection
// type and location will allow elements to be inserted within the table. 
// Return FALSE otherwise.
//

BOOL CTriEditDocument::FEnableInsertTable(void)
{
    BOOL fRet = FALSE;
    CComPtr<IDispatch>    srpRange,srpParent,srpElement;
    CComPtr<IHTMLSelectionObject>    srpSel;
    CComPtr<IHTMLDocument2>    srpiHTMLDoc;
    CComBSTR    bstr;
    CComBSTR    bstrTag;

    if (FAILED(m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&srpiHTMLDoc)))
        goto Fail;

    if (FAILED(srpiHTMLDoc->get_selection(&srpSel)))
        goto Fail;

    if (FAILED(GetDispatchProperty(srpSel, L"type", VT_BSTR, &bstr)))
        goto Fail;

    if (lstrcmpi(_T("CONTROL"), OLE2T(bstr)) == 0)
    {
        return FALSE;
    }

    if (FAILED(CallDispatchMethod(srpSel, L"createRange", VTS_DISPATCH_RETURN, (void**)&srpRange)))
        goto Fail;

    if (srpRange == NULL)
        goto Fail;
        
    srpParent = srpRange;

    while (srpParent != NULL)
    {
        srpElement.Release();
        if (FAILED(GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&srpElement)))
            goto Fail;

        if (srpElement == NULL)
            break;

        bstrTag.Empty();
        if (FAILED(GetDispatchProperty(srpElement, L"tagName", VT_BSTR, &bstrTag)))
            goto Fail;

        if (lstrcmpi(_T("INPUT"), OLE2T(bstrTag)) == 0)
        {
           return FALSE;
        }
        srpParent = srpElement;
    }

    // if the selection is inside a table, make sure only one  cell is selected
    if (IsSelectionInTable() == S_OK)
    {
        UINT grf = GetSelectionTypeInTable();
        if (grf != -1 && !(grf & grfSelectOneCell)) 
            return FALSE;
    }
    
    fRet = TRUE;

Fail:
    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsSelectionInTable
//
// Return S_OK if the Trident selection is within a table. Return
// E_FAIL otherwise.
//

HRESULT CTriEditDocument::IsSelectionInTable(IDispatch **ppTable)
{
    HRESULT    hr=0;
    CComPtr<IHTMLSelectionObject>    srpSel;
    CComPtr<IDispatch>    srpRange,srpParent,srpElement;
    CComPtr<IHTMLDocument2>    srpiHTMLDoc;
    CComBSTR    bstrTag;
    BOOL  fTable= FALSE;

    if (FAILED(hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&srpiHTMLDoc)))
        goto Fail;

    if (FAILED(hr = srpiHTMLDoc->get_selection(&srpSel)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpSel, L"createRange", VTS_DISPATCH_RETURN, (void**)&srpRange)))
        goto Fail;

    srpParent = srpRange;
    
    while (srpParent != NULL)
    {
        srpElement.Release();
        if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&srpElement)))
            goto Fail;

        if (srpElement == NULL)
            break;

        bstrTag.Empty();
        if (FAILED(hr = GetDispatchProperty(srpElement, L"tagName", VT_BSTR, &bstrTag)))
            goto Fail;

        if (lstrcmpi(_T("TABLE"), OLE2T(bstrTag)) == 0)
        {
            if (ppTable != NULL)
            {
                *ppTable = srpElement;
                (*ppTable)->AddRef();
            }
            fTable = TRUE;
            break;
        }
        else if (lstrcmpi(_T("CAPTION"), OLE2T(bstrTag)) == 0)
        {
            fTable = FALSE;
            break;
        }

        srpParent = srpElement;
    }

Fail:

    return fTable ? S_OK : E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::FillInSelectionCellsInfo
//
// Fill *pSelStart with the information concerning the table cell containing
// the beginning of the Trident selection and *pSelSle with the information
// on the table cell at the end of the selection. Return S_OK if all goes well,
// or E_FAIL otherwise.

HRESULT   CTriEditDocument::FillInSelectionCellsInfo(struct SELCELLINFO * pselStart, struct SELCELLINFO *pselEnd)
{
    CComPtr<IHTMLDocument2>  srpiHTMLDoc;
    CComPtr<IHTMLSelectionObject>   srpSel;
    CComPtr<IHTMLTxtRange>      srpRange[2];
    CComPtr<IDispatch>    srpParent;
    CComBSTR       bstrText, bstrTag;;
    LONG cReturn=0;
    HRESULT i=0, hr=0;
    LONG cCharSelected=0;
    WCHAR *pData = NULL;
    BOOL fContain = FALSE;

    if (FAILED(hr = IsSelectionInTable()))
        goto Fail;

    if (FAILED(hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&srpiHTMLDoc)))
        goto Fail;

    if (FAILED(hr = srpiHTMLDoc->get_selection(&srpSel)))
        goto Fail;

    for (i=0; i<2 ; i++)
    {
		// BUG 568250.  We HAD treated the dispatch like a text range, this now crashes.
		CComPtr<IDispatch> srpDisp;
        if (FAILED(hr = CallDispatchMethod(srpSel, L"createRange", VTS_DISPATCH_RETURN, (void**)&srpDisp)))
		{
             goto Fail;
		}
		else
		{
			if (FAILED(hr = srpDisp->QueryInterface(&srpRange[i])))
				goto Fail;
		}
    }

    bstrText.Empty();
    hr = srpRange[0]->get_text(&bstrText);
    if (FAILED(hr))
    goto Fail;

    cCharSelected = bstrText ? ocslen(bstrText) : 0;
    pData = (WCHAR *) bstrText;

    // VID98 bug 3117: trident use '0x0D' to mark column/row and this char is ignored when
    // move range so we need to deduct these characters
    while (pData != NULL && *pData !='\0')
    {
        if (*pData == 0x0D)
            cCharSelected--;
        pData++;
    }

    if (pselStart != NULL)
    {
        hr = srpRange[0]->collapse(TRUE);
        if (FAILED(hr))
        goto Fail;

        srpParent = srpRange[0];
        while (srpParent != NULL)
        {
            pselStart->srpCell.Release();
            if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&pselStart->srpCell)))
                goto Fail;

            if (pselStart->srpCell == NULL)
                {
                hr = E_FAIL;
                goto Fail;
                }

            bstrTag.Empty();
            if (FAILED(hr = GetDispatchProperty(pselStart->srpCell, L"tagName", VT_BSTR, &bstrTag)))
                goto Fail;

            if (lstrcmpi(_T("TD"), OLE2T(bstrTag)) == 0 || lstrcmpi(_T("TH"), OLE2T(bstrTag)) == 0)
            {
                break;
            }
          
            srpParent = pselStart->srpCell;
        }

        _ASSERTE(pselStart->srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(pselStart->srpCell, L"cellIndex", VT_I4, &pselStart->cCellIndex)))
            goto Fail;

        pselStart->srpRow.Release();
        if (FAILED(hr = GetTableRowElementAndTableFromCell(pselStart->srpCell, &pselStart->cRowIndex, &pselStart->srpRow, &pselStart->srpTable)))
            goto Fail;
    }

    if (pselEnd != NULL)
    {
        hr = srpRange[1]->collapse(FALSE);
        if (FAILED(hr))
            goto Fail;

        if (cCharSelected != 0)
        {
            hr = srpRange[1]->moveStart(L"Character", -1, &cReturn);
            if (FAILED(hr))
                goto Fail;
    
            hr = srpRange[1]->moveEnd(L"Character", -1, &cReturn);
            if (FAILED(hr))
                goto Fail;
        }

        srpParent = srpRange[1];
        while (srpParent != NULL)
        {
            pselEnd->srpCell.Release();
            if (FAILED(hr = GetDispatchProperty(srpParent, L"parentElement", VT_DISPATCH, (void**)&pselEnd->srpCell)))
                goto Fail;

            if (pselEnd->srpCell == NULL)
                {
                hr = E_FAIL;
                goto Fail;
                }

            bstrTag.Empty();
            if (FAILED(hr = GetDispatchProperty(pselEnd->srpCell, L"tagName", VT_BSTR, &bstrTag)))
                goto Fail;
            
            if (lstrcmpi(_T("TD"), OLE2T(bstrTag)) == 0 || lstrcmpi(_T("TH"), OLE2T(bstrTag)) == 0)
            {
                break;
            }
            srpParent = pselEnd->srpCell;
        }

        _ASSERTE(pselEnd->srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(pselEnd->srpCell, L"cellIndex", VT_I4, &pselEnd->cCellIndex)))
            goto Fail;

        pselEnd->srpRow.Release();
        if (FAILED(hr =  GetTableRowElementAndTableFromCell(pselEnd->srpCell, &pselEnd->cRowIndex, &pselEnd->srpRow, &pselEnd->srpTable)))
            goto Fail;
    }

    if (pselEnd != NULL && pselStart != NULL)
    {
    // VID 98 bug 3116: we need to check if first cell and last cell are in the same table. If they are not
    // the row index and cell index we just got do not make sense
        if (FAILED(hr = CallDispatchMethod(pselEnd->srpTable, L"contains", VTS_DISPATCH VTS_BOOL_RETURN, pselStart->srpRow, &fContain)))
            goto Fail;

        if (!fContain)
           return E_FAIL;

        fContain = FALSE;
        if (FAILED(hr = CallDispatchMethod(pselStart->srpTable, L"contains", VTS_DISPATCH VTS_BOOL_RETURN, pselEnd->srpRow, &fContain)))
            goto Fail;

        if (!fContain)
           return E_FAIL;
    }


Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetSelectionTypeInTable
//
// Return a set of flags that characterize the current selection. Return
// -1 if something goes wrong. The flags are as follows:
//
//      grfInSingleRow          Selection is comprised of one or more cells 
//                              within a single row.
//
//      grfSelectOneCell        Selection is comprised of a single cell.
//
//      grpSelectEntireRow      Selection is comprised of one or more 
//                              complete rows.

ULONG    CTriEditDocument::GetSelectionTypeInTable(void)
{
    CComPtr<IDispatch>    srpCells;
    struct SELCELLINFO    selinfo[2]; // 0 is start cell, 1 is end cell
    LONG cCells=0;
    HRESULT hr=0;
    ULONG grf=0;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (selinfo[0].cRowIndex == selinfo[1].cRowIndex)
    {
        grf |= grfInSingleRow;
        if (selinfo[0].cCellIndex == selinfo[1].cCellIndex)
            grf |= grfSelectOneCell;
    }
    else
    {
        grf &= ~grfInSingleRow;
    }

    if (selinfo[0].cCellIndex != 0)
        grf &= ~grpSelectEntireRow;
    else
    {
        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[1].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        if (selinfo[1].cCellIndex != cCells-1)
            grf &= ~grpSelectEntireRow;
        else
            grf |= grpSelectEntireRow;
    }



Fail:
    return FAILED(hr) ? -1 : grf;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::CopyProperty
//
// Copy properties from the pFrom element on to the pTo element. Return S_OK.
//

HRESULT CTriEditDocument::CopyProperty(IDispatch *pFrom, IDispatch *pTo)
{
    CComVariant varProp;
    CComBSTR bstrProp;
    VARIANT_BOOL bProp;

    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"align", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"align", VT_BSTR, bstrProp);
    }
    
    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"vAlign", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"vAlign", VT_BSTR, bstrProp);
    }

    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"background", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"background", VT_BSTR, bstrProp);
    }

    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"lang", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"lang", VT_BSTR, bstrProp);
    }   

    bstrProp.Empty();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"className", VT_BSTR, (void **)&bstrProp)))
    {
        if (lstrcmpW(bstrProp, L""))
            PutDispatchProperty(pTo, L"className", VT_BSTR, bstrProp);
    }   
    
    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"bgColor", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"bgColor", VT_VARIANT, varProp);

    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"borderColor", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"borderColor", VT_VARIANT, varProp);
    
    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"borderColorLight", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"borderColorLight", VT_VARIANT, varProp);

    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"borderColorDark", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"borderColorDark", VT_VARIANT, varProp);

    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"height", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"height", VT_VARIANT, varProp);

    varProp.Clear();
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"width", VT_VARIANT, (void **)&varProp)))
        PutDispatchProperty(pTo, L"width", VT_VARIANT, varProp);

    
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"noWrap", VT_BOOL, (void **)&bProp)))
    {
#pragma warning(disable: 4310) // cast truncates constant value
        if (bProp == VARIANT_TRUE) 
#pragma warning(default: 4310) // cast truncates constant value
            PutDispatchProperty(pTo, L"noWrap", VT_BOOL, bProp);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::CopyStyle
//
// Copy style properties from style element pFrom on to style element pTo.
// Return S_OK.
//      

HRESULT CTriEditDocument::CopyStyle(IDispatch *pFrom, IDispatch *pTo)
{
    CComPtr<IDispatch>  srpStyleTo, srpStyleFrom;
  
    if (SUCCEEDED(GetDispatchProperty(pFrom, L"style", VT_DISPATCH, (void **)&srpStyleFrom)))
    {
        if (SUCCEEDED(GetDispatchProperty(pTo, L"style", VT_DISPATCH, (void **)&srpStyleTo)))
        {
            CComVariant varProp;
            CComBSTR bstrProp;

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"backgroundAttachment", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"backgroundAttachment", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"backgroundImage", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"backgroundImage", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"backgroundRepeat", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"backgroundRepeat", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"borderBottom", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"borderBottom", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"borderLeft", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"borderLeft", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"borderTop", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"borderTop", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"borderRight", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"borderRight", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontFamily", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"fontFamily", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontStyle", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"fontStyle", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontVariant", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"fontVariant", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontWeight", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"fontWeight", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"textAlign", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"textAlign", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"textTransform", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"textTransform", VT_BSTR, bstrProp);
            }   

            bstrProp.Empty();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"textDecoration", VT_BSTR, (void **)&bstrProp)))
            {
                if (lstrcmpW(bstrProp, L""))
                    PutDispatchProperty(srpStyleTo, L"textDecoration", VT_BSTR, bstrProp);
            }   
            
            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"backgroundcolor", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"backgroundcolor", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"color", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"color", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"fontSize", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"fontSize", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"height", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"height", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"letterSpacing", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"letterSpacing", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"lineHeight", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"lineHeight", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"paddingRight", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"paddingRight", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"paddingBottom", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"paddingBottom", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"paddingLeft", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"paddingLeft", VT_VARIANT, varProp);

            varProp.Clear();
            if (SUCCEEDED(GetDispatchProperty(srpStyleFrom, L"paddingTop", VT_VARIANT, (void **)&varProp)))
                PutDispatchProperty(srpStyleTo, L"paddingTop", VT_VARIANT, varProp);
        }
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteTableRows
//
// Delete the table row(s) contained within the Trident selection. The 
// entire operation is a single undo unit. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::DeleteTableRows(void)
{
    HRESULT    hr = S_OK;
    CComPtr<IHTMLElement>       srpTable;
    struct SELCELLINFO    selinfo[2]; // 0 is start cell, 1 is end cell
    INT i=0;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    if (FAILED(hr = IsSelectionInTable((IDispatch**)&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;
            
    undoPackMgr.Start();
    
    for(i= selinfo[0].cRowIndex; i <= selinfo[1].cRowIndex; i++)
    {
        if (FAILED(hr = DeleteRowEx(srpTable, selinfo[0].cRowIndex)))
            goto Fail;
    }
    
Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteRowEx
//
// Delete the indicated table row. If the row is the only row in the table,
// delete the whole table. Return S_OK or a Trident error.
//

inline HRESULT CTriEditDocument::DeleteRowEx(IHTMLElement *pTable, LONG index)
{
    HRESULT    hr = S_OK;
    CComPtr<IDispatch> srpRows;
    INT cRows = 0;

    if (FAILED(hr = GetDispatchProperty(pTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpRows, L"length", VT_I4, &cRows)))
        goto Fail;

    // if this is the only row in the table, delete the whole table
    if (cRows == 1)
    {
        _ASSERT(index == 0);
        hr = DeleteTable(pTable);
    }
    else
    {
        if (FAILED(hr = CallDispatchMethod(pTable, L"deleteRow", VTS_I4, index)))
            goto Fail;
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteCellEx
//
// Delete the indicated cell from the indicated row of the given table. If
// the cell is the only row in the table, delete the whole table. Return
// S_OK or a Trident error.
//

inline HRESULT CTriEditDocument::DeleteCellEx(IHTMLElement *pTable, IDispatch *pRow, LONG indexRow, LONG indexCell)
{
    HRESULT    hr = S_OK;
    CComPtr<IDispatch> srpCells;
    INT cCells = 0;

    if (FAILED(hr = GetDispatchProperty(pRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
        goto Fail;

    // if this is the only cell in the table, delete the whole row
    if (cCells == 1)
    {
        _ASSERT(indexCell == 0);
        hr = DeleteRowEx(pTable, indexRow);
    }
    else
    {
        if (FAILED(hr = CallDispatchMethod(pRow, L"deleteCell", VTS_I4, indexCell)))
            goto Fail;
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteTable
//
// Delete the given table. Return S_OK if all goes well; E_FAIL if something
// goes wrong.
//

HRESULT CTriEditDocument::DeleteTable(IHTMLElement *pTable)
{
    CComPtr<IHTMLElement>   srpParent;
    HRESULT hr = E_FAIL;

    _ASSERTE(pTable != NULL);

    if (pTable  == NULL)
        goto Fail;
        
    if (FAILED(hr=pTable->get_offsetParent(&srpParent)))
        goto Fail;

    _ASSERTE(srpParent != NULL);
    if (FAILED(hr = SelectElement(pTable, srpParent)))
        goto Fail;
        
    hr = Exec(&CMDSETID_Forms3, IDM_DELETE, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
    
Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::InsertTableRow
//
// Insert a new table row in to the table which contains the Trident selection,
// in the row preceding the selection. The new row will have the same number of
// cells as the row containing the selection. The colSpan of each new cell
// will be copied from the row containing the selection. The entire operation
// is a single undo unit. Returns S_OK or a Trident error.
//

HRESULT CTriEditDocument::InsertTableRow(void)
{
    HRESULT    hr = S_OK;
    CComPtr<IDispatch> srpCell,srpCellNew, srpTable,srpCells,srpRows,srpNewRow,srpCellsNew;
    LONG ccolSpan=0;
    LONG cCells=0,i=0;
    struct SELCELLINFO    selinfo;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable(&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo, NULL)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpTable, L"insertRow", VTS_I4, selinfo.cRowIndex)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, selinfo.cRowIndex, &srpNewRow)))
        goto Fail;

    CopyStyle(selinfo.srpRow, srpNewRow);
    
    // get the number of cells contains in the selected row
    if (FAILED(hr = GetDispatchProperty(selinfo.srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
        goto Fail;

    // now insert cells
    for (i=cCells-1; i >=0; i--)
    {
         if (FAILED(hr = CallDispatchMethod(srpNewRow, L"insertCell", VTS_I4, 0)))
             goto Fail;

         srpCell.Release();
         if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
             goto Fail;

         srpCellsNew.Release();
         if (FAILED(hr = GetDispatchProperty(srpNewRow, L"cells", VT_DISPATCH, (void**)&srpCellsNew)))
             goto Fail;
         srpCellNew.Release();
         if (FAILED(hr = CallDispatchMethod(srpCellsNew, L"Item", VTS_I4 VTS_DISPATCH_RETURN, 0, &srpCellNew)))
             goto Fail;

         CopyStyle(srpCell, srpCellNew);
         CopyProperty(srpCell, srpCellNew);
         
         {
         VARIANT width;
         VariantInit(&width);
         if (SUCCEEDED(hr = GetDispatchProperty(srpCell, L"width", VT_VARIANT, &width)))
             PutDispatchProperty(srpCellNew, L"width", VT_VARIANT, width);
         }

         if (SUCCEEDED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &ccolSpan)))
             PutDispatchProperty(srpCellNew, L"colSpan", VT_I4, ccolSpan);
    }

Fail:
       return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::MapCellToFirstRowCell
//
// Given a table cell in pselInfo, return (by modifying pselInfo) the cell in
// the first row with the same column position, accounting for colSpans. Return
// S_OK or a Trident error.
//

HRESULT CTriEditDocument::MapCellToFirstRowCell(IDispatch *srpTable, struct SELCELLINFO *pselinfo)
{
    HRESULT hr = 0;
    CComPtr<IDispatch> srpCell, srpCells,srpRow,srpRows;
    INT i=0,iCellIndex=0,iColSpanCurRow=0,cSpan=0,iColSpanFirstRow=0,crowSpan=0;

    _ASSERTE(pselinfo != NULL);
    // if current selection is not first row, find the corresponding first row cell index
    if (pselinfo->cRowIndex == 0)
        return S_OK;

    srpCells.Release();
    _ASSERTE(pselinfo->srpRow != NULL);
    if (FAILED(hr = GetDispatchProperty(pselinfo->srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    for (i=0; i < pselinfo->cCellIndex ; i++)
    {
        srpCell.Release();
        _ASSERTE(srpCells != NULL);
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
            goto Fail;

        _ASSERTE(srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cSpan)))
            goto Fail;

        iColSpanCurRow += cSpan;
    }

    srpRows.Release();
     _ASSERTE(srpTable != NULL);

    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    _ASSERTE(srpRows != NULL);
    srpRow.Release();
    if (FAILED(hr = CallDispatchMethod(srpRows, L"Item",VTS_I4 VTS_DISPATCH_RETURN, 0, &srpRow)))
        goto Fail;

    srpCells.Release();
    if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    iCellIndex=-1;
    while(iColSpanCurRow >= iColSpanFirstRow)
    {
        iCellIndex++;
        srpCell.Release();
        _ASSERTE(srpCells != NULL);
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, iCellIndex, &srpCell)))
            goto Fail;

        // we might hit the end. If so, first row is shorter than curret row and there's no mapping first row, bail out...
        if (srpCell == NULL)
        {
        hr = E_FAIL;
        goto Fail;
        }

        _ASSERTE(srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cSpan)))
            goto Fail;

        iColSpanFirstRow += cSpan;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &crowSpan)))
            goto Fail;

        if (crowSpan > pselinfo->cRowIndex)
        {
            iColSpanCurRow += cSpan;
        }

    }

    pselinfo->srpCell = srpCell;
    pselinfo->srpRow.Release();
    if (FAILED(hr = GetTableRowElementAndTableFromCell(pselinfo->srpCell, NULL, &pselinfo->srpRow)))
        goto Fail;

    pselinfo->cRowIndex = 0;
    _ASSERTE(iCellIndex >= 0);
    pselinfo->cCellIndex = iCellIndex;

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::InsertTableCol
//
// Insert a new column in to the table containing the selection, at the column
// of the selection. The entire operation is a single undo unit. Return S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::InsertTableCol(void)
{
    HRESULT    hr = S_OK;
    CComPtr<IDispatch>               srpCellNew, srpTable,srpRows,srpRow,srpCells,srpCell;
    LONG    cRows=0,i=0, j=0, iColSpanInsert=0, iColSpanCur=0, cSpan=0,crowSpan = 0, cCells=0;
    struct SELCELLINFO    selinfo;
    INT *pccolFix = NULL;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable(&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo, NULL)))
        goto Fail;

    MapCellToFirstRowCell(srpTable, &selinfo);

    srpCells.Release();
    _ASSERTE(selinfo.srpRow != NULL);
    if (FAILED(hr = GetDispatchProperty(selinfo.srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    _ASSERTE(srpTable != NULL);
    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
       goto Fail;

    _ASSERTE(srpRows != NULL);
    if (FAILED(hr = GetDispatchProperty(srpRows, L"length", VT_I4, &cRows)))
       goto Fail;

    pccolFix = new INT[cRows];
    _ASSERTE(pccolFix != NULL);
    for (i=0; i< cRows; i++)
        *(pccolFix+i) = 0;

    for (i=0; i < selinfo.cCellIndex; i++)
    {
        srpCell.Release();
        _ASSERTE(srpCells != NULL);
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))             goto Fail;

        _ASSERTE(srpCell != NULL);
        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cSpan)))
            goto Fail;

        iColSpanInsert += cSpan;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &crowSpan)))
            goto Fail;

    // if someone before the current cell has row span, this needs to propogate to
    // the next spanned rows
        if (crowSpan > 1)
            {
            for (j= selinfo.cRowIndex+1; j < (selinfo.cRowIndex+crowSpan); j++)
                *(pccolFix+j) += cSpan;
            }
    }

    for (i=0; i < cRows;)
    {
        srpRow.Release();
         _ASSERTE(srpRows != NULL);
        if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpRow)))
            goto Fail;

        srpCells.Release();
        _ASSERTE(srpRow != NULL);
        if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        _ASSERTE(srpCells != NULL);
        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        iColSpanCur =  *(pccolFix+i);
        for (j=0; j < cCells; j++)
        {
            srpCell.Release();
            if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, &srpCell)))             goto Fail;

             _ASSERTE(srpCell != NULL);
            if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cSpan)))
                goto Fail;

            if (iColSpanCur >= iColSpanInsert)
                break;

            iColSpanCur += cSpan;
        }

        _ASSERTE(srpRow != NULL);
        if (FAILED(hr = CallDispatchMethod(srpRow, L"insertCell", VTS_I4, j)))
            goto Fail;

        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        srpCellNew.Release();
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, &srpCellNew)))
            goto Fail;

                
        if (!(!srpCell))
        {
            CopyStyle(srpCell, srpCellNew);
            CopyProperty(srpCell, srpCellNew);
            
            {
            VARIANT height;
            VariantInit(&height);
            if (SUCCEEDED(hr = GetDispatchProperty(srpCell, L"height", VT_VARIANT, &height)))
                PutDispatchProperty(srpCellNew, L"height", VT_VARIANT, height);
             }

            if (SUCCEEDED(GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &cSpan)))
                PutDispatchProperty(srpCellNew, L"rowSpan", VT_I4, cSpan);
        }

        // cSpan might be 0 if we are inserting a cell into an empty row
        i += max(1, cSpan);
    }

Fail:
    if (pccolFix != NULL)
        delete [] pccolFix;
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteTableCols
//
// Delete the table columns that are contained within the Trident selection.
// The entire operation is a single undo unit. Return S_OK or a Trident error. 
//

HRESULT CTriEditDocument::DeleteTableCols(void)
{
    CComPtr<IDispatch>       srpRows,srpRow,srpCells,srpCell;
    CComPtr<IHTMLElement>   srpTable;
    struct SELCELLINFO          selinfo[2]; // 0 is start cell, 1 is end cell
    LONG cRows=0, i=0, j=0, k=0, cCells=0;
    HRESULT      hr=0;
    LONG iColSpanStart=0, iColSpanEnd=0,cColSpan=0,iColSpanCur=0, crowSpan=0;
    INT *  pccolFixStart=NULL, *pccolFixEnd = NULL;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable((IDispatch**)&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (!FAILED(MapCellToFirstRowCell(srpTable, &selinfo[1])))
        MapCellToFirstRowCell(srpTable, &selinfo[0]);

    _ASSERTE(selinfo[0].srpRow != NULL);
    if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    _ASSERTE(srpCells != NULL);
    if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
        goto Fail;

    _ASSERTE(selinfo[1].cRowIndex == selinfo[0].cRowIndex);
    _ASSERTE(selinfo[1].cCellIndex >= selinfo[0].cCellIndex);

    srpRows.Release();
    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
       goto Fail;

    _ASSERTE(srpRows != NULL);
    if (FAILED(hr = GetDispatchProperty(srpRows, L"length", VT_I4, &cRows)))
       goto Fail;

    pccolFixEnd = new INT[cRows];
    pccolFixStart = new INT[cRows];
    for (i=0; i< cRows; i++)
        {
        *(pccolFixStart+i) = 0;
        *(pccolFixEnd+i) = 0;
        }

    for (i=0; i<= selinfo[1].cCellIndex; i++)
    {
        srpCell.Release();
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))             goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cColSpan)))
            goto Fail;
        if (i < selinfo[0].cCellIndex)
           iColSpanStart += cColSpan;

        if (i <= selinfo[1].cCellIndex)
           iColSpanEnd += cColSpan;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &crowSpan)))
            goto Fail;

        if (crowSpan > 1)
        {
            if (i < selinfo[0].cCellIndex)
            {
                for (j= selinfo[0].cRowIndex+1; j < selinfo[0].cRowIndex+crowSpan; j++)
                    *(pccolFixStart+j) += cColSpan;
            }

            if (i <= selinfo[1].cCellIndex)
            {
                for (j= selinfo[0].cRowIndex+1; j < selinfo[0].cRowIndex+crowSpan; j++)
                    *(pccolFixEnd+j) += cColSpan;
            }
        }
    }

    for (j=cRows-1; j >= 0; j--)
    {
        srpRow.Release();
        if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, &srpRow)))
            goto Fail;

        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        iColSpanCur = 0;
        _ASSERTE(iColSpanEnd-*(pccolFixEnd+j) >= 0);
        _ASSERTE(iColSpanStart-*(pccolFixStart+j) >= 0);

        for (i=0, k=0; iColSpanCur <= (iColSpanEnd-*(pccolFixEnd+j)) && k < cCells ; i++, k++)
        {
            srpCell.Release();
            if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
                goto Fail;
            if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &cColSpan)))
                goto Fail;

            if (iColSpanCur >= (iColSpanStart-*(pccolFixStart+j)) && iColSpanCur < (iColSpanEnd-*(pccolFixEnd+j)))
            {
                if (FAILED(hr = DeleteCellEx(srpTable, srpRow, j, i)))
                    goto Fail;
                i--; // we've deleted one cell, need to decrement cell index
            }

            iColSpanCur += cColSpan;
        }
    }

Fail:
    if (pccolFixStart != NULL)
     {
         delete [] pccolFixStart;
     }

    if (pccolFixEnd != NULL)
     {
         delete [] pccolFixEnd;
     }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::InsertTableCell
//
// Insert a table cell before the cell containing the Trident selection; copy
// the properties and style of the cell containing the selection to the new
// cell. The entire operation is a single undo unit. Returns S_OK or a Trident
// error.
//

HRESULT CTriEditDocument::InsertTableCell(void)
{
    HRESULT    hr = S_OK;
    struct SELCELLINFO    selinfo;
    CComPtr<IDispatch>    srpCellNew, srpCells;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();
    
    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo, NULL)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(selinfo.srpRow, L"insertCell", VTS_I4, selinfo.cCellIndex)))
       goto Fail;

    srpCells.Release();
    if (FAILED(hr = GetDispatchProperty(selinfo.srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    srpCellNew.Release();
    if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, selinfo.cCellIndex, &srpCellNew)))
        goto Fail;

    CopyStyle(selinfo.srpCell, srpCellNew);
    CopyProperty(selinfo.srpCell, srpCellNew);

Fail:

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DeleteTableCells
//
// Delete the table cells contained within the Trident selection. Delete entire
// rows as indicated. The entire operation is a single undo unit. Return
// S_OK or a Trident error.
//

HRESULT CTriEditDocument::DeleteTableCells(void)
{
    CComPtr<IHTMLElement>       srpTable,srpCells;
    struct SELCELLINFO          selinfo[2]; // 0 is start cell, 1 is end cell
    LONG i=0, cCells=0;
    HRESULT      hr=0;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable((IDispatch**)&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (selinfo[0].cRowIndex == selinfo[1].cRowIndex) // same row
    {
        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        // if the selection is select all the cells in this row, delete the whole row instead
        if ( cCells == selinfo[1].cCellIndex+1 && selinfo[0].cCellIndex == 0)
        {
            if (FAILED(hr = DeleteRowEx(srpTable, selinfo[0].cRowIndex)))
                goto Fail;
        }
        else // delete cell by cell
        {
            for (i = selinfo[1].cCellIndex; i >= selinfo[0].cCellIndex; i--)
            {
                if (FAILED(hr = DeleteCellEx(srpTable, selinfo[0].srpRow, selinfo[0].cRowIndex, i)))
                    goto Fail;
            }
         }
    }
    else
    {
        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[1].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

        // if the selection ends at the last cell of the row, delete the whole row instead
        if ( cCells == selinfo[1].cCellIndex+1)
        {
            if (FAILED(hr = DeleteRowEx(srpTable, selinfo[1].cRowIndex)))
                goto Fail;
        }
        else // delete cell by cell
        {
            for (i = selinfo[1].cCellIndex; i >= 0; i--)
            {
                if (FAILED(hr = DeleteCellEx(srpTable, selinfo[1].srpRow, selinfo[1].cRowIndex, i)))
                    goto Fail;
            }
        }
        
        for (i = selinfo[1].cRowIndex-1; i > selinfo[0].cRowIndex; i--)
        {
            if (FAILED(hr = DeleteRowEx(srpTable, i)))
                goto Fail;
        }

       
        if (selinfo[0].cCellIndex == 0) // if the selection is from first cell of a row across other rows, delete the whole row instead
        {
            if (FAILED(hr = DeleteRowEx(srpTable, selinfo[0].cRowIndex)))
                goto Fail;
        }
        else // delete cell by cell
        {
            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

            for (i = cCells-1; i >= selinfo[0].cCellIndex; i--)
            {
                if (FAILED(hr = DeleteCellEx(srpTable, selinfo[0].srpRow, selinfo[0].cRowIndex, i)))
                    goto Fail;
            }
        }
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::MergeTableCells
//
// Merge the indicated cells in to a single cell, and adjust its colSpan.
// The cells must be within a single table row. The innerHTML of all merged cells
// is concatenated and placed in the remaining cell. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::MergeTableCells(IDispatch* srpTable, INT iRow, INT iIndexStart, INT iIndexEnd)
{
    CComPtr<IDispatch>    srpCells,srpRows,srpCurRow,srpCell;
    INT ccolSpanTotal=0, i=0, ccolSpan=0;
    HRESULT      hr=0;
    CComBSTR    bstrText;
    CComBSTR    bstrMergedText;

    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, iRow, &srpCurRow)))
        goto Fail;

    srpCells.Release();
    if (FAILED(hr = GetDispatchProperty(srpCurRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    bstrMergedText.Empty();
    ccolSpanTotal = 0;

    for (i = iIndexEnd; i >= iIndexStart; i--)
    {
        srpCell.Release();
        if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
            goto Fail;

        bstrText.Empty();
        if (FAILED(hr = GetDispatchProperty(srpCell, L"innerHTML", VT_BSTR, &bstrText)))
            goto Fail;
        bstrText += bstrMergedText;
        bstrMergedText = bstrText;

        if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &ccolSpan)))
            goto Fail;
        ccolSpanTotal += ccolSpan;

        if (i != iIndexStart)
        {
              if (FAILED(hr = DeleteCellEx((IHTMLElement*)srpTable, srpCurRow, iRow, i)))
                  goto Fail;
        }
        else
        {
            if (FAILED(hr = PutDispatchProperty(srpCell, L"colSpan", VT_I4, ccolSpanTotal)))
                goto Fail;
            if (FAILED(hr = PutDispatchProperty(srpCell, L"innerHTML", VT_BSTR, bstrMergedText)))
                goto Fail;
        }
    }
Fail:
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::MergeTableCells
//
// Merge the cells in the Trident selection in to a single cell, and adjust that
// cell's colSpan. The cells must be within a single table row. The innerHTML of
// all merged cells is concatenated and placed in the remaining cell. Return S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::MergeTableCells(void)
{
    CComPtr<IDispatch>       srpCell, srpCells,srpElement,srpRows,srpRow;
    CComPtr<IHTMLElement>   srpTable;
    struct SELCELLINFO          selinfo[2]; // 0 is start cell, 1 is end cell
    LONG i=0, cCells=0;
    HRESULT      hr=0;
    CComBSTR    bstrText;
    CComBSTR    bstrMergedText;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable((IDispatch**)&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (selinfo[0].cRowIndex == selinfo[1].cRowIndex)
    {
        if (selinfo[1].cCellIndex == selinfo[0].cCellIndex)
            {
                hr = S_OK;
                goto Fail;
            }

        if (FAILED(hr = MergeTableCells(srpTable, selinfo[0].cRowIndex, selinfo[0].cCellIndex, selinfo[1].cCellIndex)))
            goto Fail;
    }
    else
    {
        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[1].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = MergeTableCells(srpTable, selinfo[1].cRowIndex, 0, selinfo[1].cCellIndex)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
            goto Fail;

        for (i = selinfo[1].cRowIndex-1; i > selinfo[0].cRowIndex; i--)
        {
            srpElement.Release();
            if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpElement)))
                goto Fail;

            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(srpElement, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

            if (FAILED(hr = MergeTableCells(srpTable, i, 0, cCells-1)))
                goto Fail;
        }

        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        if (FAILED(hr = MergeTableCells(srpTable, selinfo[0].cRowIndex, selinfo[0].cCellIndex, cCells-1)))
            goto Fail;

        bstrMergedText.Empty();
        for (i = selinfo[0].cRowIndex; i <= selinfo[1].cRowIndex; i++)
        {
            srpRows.Release();
            if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
                goto Fail;

            srpRow.Release();
            if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, selinfo[0].cRowIndex, &srpRow)))
                goto Fail;

            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            srpCell.Release();
            if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, 0, &srpCell)))
                goto Fail;

            bstrText.Empty();
            if (FAILED(hr = GetDispatchProperty(srpCell, L"innerHTML", VT_BSTR, &bstrText)))
                goto Fail;
            bstrMergedText += L"<P>";
            bstrMergedText += bstrText;
            bstrMergedText += L"</P>";

            if (i != selinfo[1].cRowIndex)
            {
                if (FAILED(hr = DeleteRowEx(srpTable, selinfo[0].cRowIndex)))
                    goto Fail;
            }
        }
        if (FAILED(hr = PutDispatchProperty(srpCell, L"innerHTML", VT_BSTR, bstrMergedText)))
            goto Fail;
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SplitTableCell 
//
// Split the indicated table cell in to two cells and adjust the colSpan
// of the relevant cells in the other rows as needed. The entire operation is
// a single undo unit. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::SplitTableCell(IDispatch *srpTable, INT iRow, INT index)
{
    CComPtr<IDispatch>       srpCellSplit, srpCells,srpCell,srpElement,srpRows,srpRow,srpCurRow,srpCellNew;
    INT cRows=0,i=0,j=0,ccolSpan=0,ccolSpanCur=0,crowSpan=0, cCells=0;
    HRESULT      hr=0;
    CComBSTR    bstrText;
    INT *pccolFix = NULL;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();
    
    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpRows, L"length", VT_I4, &cRows)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, iRow, &srpCurRow)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpCurRow, L"insertCell", VTS_I4, index+1)))
        goto Fail;

    srpCells.Release();
    if (FAILED(hr = GetDispatchProperty(srpCurRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
        goto Fail;

    srpCellNew.Release();
    if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, index+1, &srpCellNew)))
        goto Fail;
                
    srpCellSplit.Release();
    if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, index, (void**)&srpCellSplit)))
        goto Fail;

    ccolSpan=0;
    if (FAILED(hr = GetDispatchProperty(srpCellSplit, L"colSpan", VT_I4, &ccolSpan)))
        goto Fail;

    CopyStyle(srpCellSplit, srpCellNew);
    CopyProperty(srpCellSplit, srpCellNew);
    
    if (ccolSpan == 1)
    {
        INT ccolSpanStart = 0,ccolSpanEnd=0;
        INT ccolSpanTmp = 0, cRowSpan = 0;

        pccolFix = new INT[cRows];
        for (j=0; j < cRows; j++)
            *(pccolFix+j) = 0;

        for (j=0; j<index;j++)
        {
            srpCell.Release();
            if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, (void**)&srpCell)))
                goto Fail;

            ccolSpanTmp = 0;
            if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &ccolSpanTmp)))
                goto Fail;
            ccolSpanStart += ccolSpanTmp;

            if (FAILED(hr = GetDispatchProperty(srpCell, L"rowSpan", VT_I4, &cRowSpan)))
                goto Fail;

            if (cRowSpan > 1)
                for (i = index+1; i < index+cRowSpan; i++)
                    *(pccolFix+i) += ccolSpanTmp;
        }

        ccolSpanEnd = ccolSpanStart + ccolSpan;

        for (j=0; j < cRows; j++)
        {
            if (j == iRow)
                continue;

            srpRow.Release();
            if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, j, &srpRow)))
                goto Fail;

            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

            ccolSpanCur = *(pccolFix+j);
            for(i=0 ; i < cCells; i++)
            {
                srpCell.Release();
                if (FAILED(hr = CallDispatchMethod(srpCells, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpCell)))
                    goto Fail;

                ccolSpan=0;
                if (FAILED(hr = GetDispatchProperty(srpCell, L"colSpan", VT_I4, &ccolSpan)))
                    goto Fail;

                if (ccolSpanStart <= ccolSpanCur && ccolSpanCur < ccolSpanEnd)
                {
                    if (FAILED(hr = PutDispatchProperty(srpCell, L"colSpan", VT_I4, ccolSpan+1)))
                        goto Fail;
                }

                if (ccolSpanCur >= ccolSpanEnd)
                    break;

                ccolSpanCur += ccolSpan;
            }
         }
     }
     else
     {
         if (FAILED(hr = PutDispatchProperty(srpCellNew, L"colSpan", VT_I4, ccolSpan/2)))
             goto Fail;

         if (FAILED(hr = PutDispatchProperty(srpCellSplit, L"colSpan", VT_I4, ccolSpan-ccolSpan/2)))
             goto Fail;
     }

    
      // now copy row span
     if (FAILED(hr = GetDispatchProperty(srpCellSplit, L"rowSpan", VT_I4, &crowSpan)))
         goto Fail;

     if (FAILED(hr = PutDispatchProperty(srpCellNew, L"rowSpan", VT_I4, crowSpan)))
         goto Fail;

Fail:
     if (pccolFix != NULL)
     {
         delete [] pccolFix;
      }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SplitTableCell 
//
// Split the table cell in the Trident selection in to two cells and adjust the
// colSpan of the relevant cells in the other rows as needed. The entire operation
// is a single undo unit. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::SplitTableCell(void)
{
    CComPtr<IDispatch>       srpCell, srpTable,srpCells,srpElement,srpRows,srpRow;
    struct SELCELLINFO          selinfo[2]; // 0 is start cell, 1 is end cell
    LONG i=0, j=0,cCells=0;
    HRESULT      hr=0;
    CUndoPackManager undoPackMgr(m_pUnkTrident);

    undoPackMgr.Start();

    if (FAILED(hr = IsSelectionInTable(&srpTable)))
        goto Fail;

    if (FAILED(hr = FillInSelectionCellsInfo(&selinfo[0], &selinfo[1])))
        goto Fail;

    if (FAILED(hr = GetDispatchProperty(srpTable, L"rows", VT_DISPATCH, (void**)&srpRows)))
        goto Fail;

    if (selinfo[0].cRowIndex == selinfo[1].cRowIndex)
    {
        for (i = selinfo[1].cCellIndex; i >= selinfo[0].cCellIndex; i--)
        {
           if (FAILED(hr = SplitTableCell(srpTable, selinfo[0].cRowIndex, i)))
               goto Fail;
        }
    }
    else
    {
        for (i = selinfo[1].cCellIndex; i >= 0; i--)
        {
            if (FAILED(hr = SplitTableCell(srpTable, selinfo[1].cRowIndex, i)))
               goto Fail;
        }

        for (i = selinfo[1].cRowIndex-1; i > selinfo[0].cRowIndex; i--)
        {
            srpElement.Release();
            if (FAILED(hr = CallDispatchMethod(srpRows, L"Item", VTS_I4 VTS_DISPATCH_RETURN, i, &srpElement)))
                goto Fail;

            srpCells.Release();
            if (FAILED(hr = GetDispatchProperty(srpElement, L"cells", VT_DISPATCH, (void**)&srpCells)))
                goto Fail;

            if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
                goto Fail;

            for (j = cCells-1; j >= 0; j--)
            {
                if (FAILED(hr = SplitTableCell(srpTable, i, j)))
                    goto Fail;
            }
        }

        srpCells.Release();
        if (FAILED(hr = GetDispatchProperty(selinfo[0].srpRow, L"cells", VT_DISPATCH, (void**)&srpCells)))
            goto Fail;

        if (FAILED(hr = GetDispatchProperty(srpCells, L"length", VT_I4, &cCells)))
            goto Fail;

        for (i = cCells-1; i >= selinfo[0].cCellIndex; i--)
        {
            if (FAILED(hr = SplitTableCell(srpTable, selinfo[0].cRowIndex, i)))
               goto Fail;
        }
    }

Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::InsertTable
//
// Insert a table in to the document at the selection point. All parameters
// are optional and taken from members of pvarargIn as follows:
//
//      pvarargIn[0]    I4   - Number of rows; default 0.
//      pvarargIn[1]    I4   - Number of columns; default 0.
//      pvarargIn[2]    BSTR - Table tag attributes; default "".
//      pvarargIn[3]    BSTR - Table cell attributes; default "".
//      pvarargIn[4]    BSTR - Table caption; default "".
//
// pvarArgIn must be sipplied even if the default values are to be used for
// all parameters. The entire operation is a single undo unit. The wait cursor
// is displayed since this can be a fairly time-consuming operation. Returns S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::InsertTable(VARIANTARG *pvarargIn)
{
    HRESULT    hr=0;
    CComPtr<IHTMLSelectionObject>    srpSel;
    CComPtr<IDispatch> srpRange;
    CComPtr<IDispatch>    srpCell;
    CComPtr<IHTMLDocument2>    srpiHTMLDoc;
    CComBSTR    bstrHtml;
    CComBSTR    bstrTblAttr;
    CComBSTR    bstrTCellAttr;
    CComBSTR    bstrCaption;
    int i=0, j=0, iRow=0, iCol=0;
    VARIANT rgvar[5];
    HCURSOR hOldCursor;

    if (pvarargIn == NULL)
        return E_FAIL;

    hOldCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

    for(i = 0; i < sizeof(rgvar)/sizeof(VARIANT); i++)
        VariantInit(&rgvar[i]);

    // default
    iRow=1;
    iCol=1;
    bstrTCellAttr.Empty();
    bstrTblAttr.Empty();

    if (pvarargIn != NULL)
    {
        LONG lLBound=0, lUBound=0,lIndex=0;
        SAFEARRAY *psa;
        LONG cParam; // number of parameters host passes in

        psa = V_ARRAY(pvarargIn);
        SafeArrayGetLBound(psa, 1, &lLBound);
        SafeArrayGetUBound(psa, 1, &lUBound);
        cParam = 0;
        _ASSERTE(lLBound == 0);
        _ASSERTE(lUBound -  lLBound < 5);
        for (lIndex = lLBound; lIndex <= lUBound && cParam < sizeof(rgvar)/sizeof(VARIANT); lIndex++)
        {
             SafeArrayGetElement(psa, &lIndex, &rgvar[cParam++]);
        }

        // first element: number of rows
        if (cParam >= 1)
            iRow = V_I4(&rgvar[0]);
        // 2'rd element: number of columns
        if (cParam >= 2)
            iCol = V_I4(&rgvar[1]);
        // 3'rd element: table tag attributes
        if (cParam >= 3)
            bstrTblAttr = V_BSTR(&rgvar[2]);
        // 4'th element: table cell tag attributes
        if (cParam >= 4)
            bstrTCellAttr = V_BSTR(&rgvar[3]);
        if (cParam >= 5)
            bstrCaption = V_BSTR(&rgvar[4]);
    }

    if (iRow < 0 || iCol < 0)
        goto Fail;

    bstrHtml.Empty();
    bstrHtml += "<TABLE ";
    if (bstrTblAttr != NULL)
        bstrHtml += bstrTblAttr;
    bstrHtml += ">";

    if (bstrCaption != NULL)
    {
         bstrHtml += "<CAPTION>";
         bstrHtml += bstrCaption;
         bstrHtml += "</CAPTION>";
    }

    bstrHtml +="<TBODY>";

    for (i=0; i<iRow; i++)
    {
        bstrHtml += "<TR>";
        for (j=0; j<iCol; j++)
        {
            bstrHtml += "<TD ";
            if (bstrTCellAttr != NULL)
                bstrHtml += bstrTCellAttr;
            bstrHtml +="></TD>";
        }
        bstrHtml += "</TR>";
    }
    bstrHtml += "</TBODY></TABLE>";

    if (FAILED(hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&srpiHTMLDoc)))
        goto Fail;

    if (FAILED(hr = srpiHTMLDoc->get_selection(&srpSel)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpSel, L"createRange", VTS_DISPATCH_RETURN, (void**)&srpRange)))
        goto Fail;

    if (FAILED(hr = CallDispatchMethod(srpRange, L"pasteHTML", VTS_BSTR, bstrHtml)))
        goto Fail;

Fail:

    for(i = 0; i < sizeof(rgvar)/sizeof(VARIANT); i++)
        VariantClear(&rgvar[i]);

    ::SetCursor(hOldCursor);
    return hr;

}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::DoVerb
//
// Execute the verb in pvarargIn (or OLEIVERB_PRIMARY if pvarargIn is NULL)
// on the current object (which must QI for IHTMLObjectElement). Return E_FAIL
// or the code returned as a result of executing the verb,
//

HRESULT CTriEditDocument::DoVerb(VARIANTARG *pvarargIn, BOOL fQueryStatus)
{
    LONG iVerb;
    IHTMLObjectElement *piHTMLObjectElement = NULL;
    IDispatch *pDisp = NULL;
    IOleObject *pOleObj = NULL;
    HRESULT hr = E_FAIL;

    _ASSERTE(m_pihtmlElement != NULL);

    if (SUCCEEDED(m_pihtmlElement->QueryInterface(IID_IHTMLObjectElement, (void **)&piHTMLObjectElement)) && piHTMLObjectElement)
    {
        if (SUCCEEDED(piHTMLObjectElement->get_object(&pDisp)) && pDisp)
        {
            if (SUCCEEDED(pDisp->QueryInterface(IID_IOleObject, (void **)&pOleObj)) && pOleObj)
            {
                if (fQueryStatus) // In the query status case, we're done
                    hr = S_OK;
                else
                {
                    if (pvarargIn == NULL)
                        iVerb = OLEIVERB_PRIMARY;
                    else if (pvarargIn->vt == VT_I4)
                        iVerb = V_I4(pvarargIn);    
                    else
                    {
                        hr = E_INVALIDARG;
                        goto LSkipDoVerb;
                    }

                    GetTridentWindow();
                    _ASSERTE(m_hwndTrident != NULL);

                    hr = pOleObj->DoVerb(iVerb, NULL, NULL, 0, m_hwndTrident, NULL);
                }
LSkipDoVerb:
                pOleObj->Release();
            }
            pDisp->Release();
        }
        piHTMLObjectElement->Release();
    }

    return hr;

}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetDocument
//
// Return the IHTMLDocument pointer (under *ppihtmlDocument) and S_OK, or
// E_FAIL/E_POINTER.
//

STDMETHODIMP CTriEditDocument::GetDocument(IHTMLDocument2** ppihtmlDocument)
{
    _ASSERTE(ppihtmlDocument);
    if (ppihtmlDocument)
    {
        if (m_pUnkTrident)
        {
            return m_pUnkTrident->QueryInterface(IID_IHTMLDocument2,
                        (LPVOID*)ppihtmlDocument);
        }
        return E_FAIL;
    }
    return E_POINTER;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetAllColllection
//
// Return the all collection of the HTML document (under *ppihtmlCollection),
// or E_FAIL.
//

STDMETHODIMP CTriEditDocument::GetAllCollection(IHTMLElementCollection** ppihtmlCollection)
{
    IHTMLDocument2* pihtmlDoc2;
    HRESULT hr=E_FAIL;

    _ASSERTE(ppihtmlCollection);
    if (ppihtmlCollection && SUCCEEDED(GetDocument(&pihtmlDoc2)))
    {
        _ASSERTE(pihtmlDoc2);
        hr = pihtmlDoc2->get_all(ppihtmlCollection);
        pihtmlDoc2->Release();
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetCollectionElement
//
// Return the indicated element from the given collection under *ppihtmlElement.
// Return S_OK if all goes well,or E_FAIL or a Triedent error on error.
//

STDMETHODIMP CTriEditDocument::GetCollectionElement(
    IHTMLElementCollection* pihtmlCollection,
    LONG iElem, IHTMLElement** ppihtmlElement)
{
    VARIANT var;
    VARIANT varEmpty;
    IDispatch* pidispElement=NULL;
    HRESULT hr = E_FAIL;

    _ASSERTE(pihtmlCollection && iElem >= 0 && ppihtmlElement);
    if (!pihtmlCollection || iElem < 0 || !ppihtmlElement)
        return E_POINTER;

    *ppihtmlElement = NULL;     //initialize [out] parameter

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = iElem;

    VariantInit(&varEmpty);
    varEmpty.vt = VT_EMPTY;

    hr = pihtmlCollection->item(var, varEmpty, &pidispElement);
    if (SUCCEEDED(hr))
    {
        if (pidispElement)
        {
            hr = pidispElement->QueryInterface(IID_IHTMLElement, (LPVOID*)ppihtmlElement);
            pidispElement->Release();
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//
// CTriEditDocument::Is2DCapable
//
// Return (under *pfBool) TRUE if the given HTML element can be positioned
// out of the flow as a 2D element, or FALSE if not. Return S_OK in either
// case. Return E_FAIL or a Trident error if something goes wrong.
// 

STDMETHODIMP CTriEditDocument::Is2DCapable(IHTMLElement* pihtmlElement, BOOL* pfBool)
{
    HRESULT hr= E_FAIL;
    CComBSTR bstrTag;

    _ASSERTE(pihtmlElement);

    if (!pihtmlElement || !pfBool)
        return E_POINTER;

    *pfBool = FALSE;

     bstrTag.Empty();
     if (FAILED(hr = GetDispatchProperty(pihtmlElement, L"tagName", VT_BSTR, &bstrTag)))
            return E_FAIL;

     if (lstrcmpi(_T("APPLET"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("BUTTON"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("DIV"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("EMBED"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("FIELDSET"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("HR"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("IFRAME"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("IMG"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("INPUT"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("MARQUEE"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("OBJECT"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("SELECT"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("SPAN"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("TABLE"), OLE2T(bstrTag)) == 0 ||
         lstrcmpi(_T("TEXTAREA"), OLE2T(bstrTag)) == 0 )
    {
        *pfBool = TRUE;
        return S_OK;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SelectElement
//
// Select the given element within Trident as a site selection. Return S_OK or
// a Trident error.
//

STDMETHODIMP CTriEditDocument::SelectElement(IHTMLElement* pihtmlElement, IHTMLElement* pihtmlElementParent)
{
    IHTMLControlElement* picont=NULL;
    IHTMLElement* piParent=NULL;
    IDispatch* pidisp=NULL;
    IHTMLTextContainer* pitext=NULL;
    IHTMLControlRange* pirange=NULL;
    HRESULT hr;
    CComBSTR bstrTag;

    if ( !pihtmlElement || !pihtmlElementParent )
        return E_FAIL;
    
    hr = pihtmlElement->QueryInterface(IID_IHTMLControlElement, (LPVOID*)&picont);

    if ( FAILED(hr) )
        goto CleanUp;

    _ASSERTE(picont);

    hr = pihtmlElementParent->QueryInterface(IID_IHTMLTextContainer, (LPVOID*)&pitext);

    if ( FAILED(hr) )
        goto CleanUp;

    _ASSERTE(pitext);

    hr = pitext->createControlRange(&pidisp);

    if ( FAILED(hr) )
        goto CleanUp;

    _ASSERTE(pitext);

    hr = pidisp->QueryInterface(IID_IHTMLControlRange, (LPVOID*)&pirange);

    if ( FAILED(hr) )
        goto CleanUp;

    _ASSERTE(pirange);

    hr = pirange->add(picont);

    if ( FAILED(hr) )
        goto CleanUp;

    hr = pirange->select();

CleanUp:
    SAFERELEASE(picont);
    SAFERELEASE(piParent);
    SAFERELEASE(pidisp);
    SAFERELEASE(pitext);
    SAFERELEASE(pirange);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsElementDTC
//
// Return S_OK if the given element is a DTC (Design-Time Control) or E_FAIL 
// if not.
//

HRESULT CTriEditDocument::IsElementDTC(IHTMLElement *pihtmlElement)
{
    IHTMLObjectElement *piHTMLObjectElement = NULL;
    IDispatch *pDisp = NULL;
    IActiveDesigner *piActiveDesigner = NULL;
    IUnknown *piUnk = NULL;

    if (SUCCEEDED(pihtmlElement->QueryInterface(IID_IHTMLObjectElement, (void **)&piHTMLObjectElement)) && piHTMLObjectElement)
    {
        if (SUCCEEDED(piHTMLObjectElement->get_object(&pDisp)) && pDisp)
        {
            if (SUCCEEDED(pDisp->QueryInterface(IID_IUnknown, (void **)&piUnk)) && piUnk)
            {
                if (SUCCEEDED(piUnk->QueryInterface(IID_IActiveDesigner, (void **)&piActiveDesigner)) && piActiveDesigner)
                {
                    piHTMLObjectElement->Release();
                    pDisp->Release();
                    piUnk->Release();
                    piActiveDesigner->Release();
                    return S_OK;
                }
                piUnk->Release();
            }
            pDisp->Release();
        }
        piHTMLObjectElement->Release();
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\htmparse.cpp ===
// HtmParse.cpp : Implementation of CHtmParse
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
#include "stdafx.h"

#include <designer.h>
#include <time.h> // for random number generation

#include "triedit.h"
#include "HtmParse.h"
#include "table.h"
#include "lexer.h"
#include "guids.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CTriEditParse
#undef ASSERT
#define ASSERT(b) _ASSERTE(b)

#ifdef NEEDED
inline int 
indexPrevtokTagStart(int index, TOKSTRUCT *pTokArray)
{
    while (    (index >= 0)
            && (pTokArray[index].token.tokClass != tokTag)
            && (pTokArray[index].token.tok != TokTag_START)
            )
    {
            index--;
    }
    return(index);
}

inline int
indexPrevTokElem(int index, TOKSTRUCT *pTokArray)
{
    while (    (index >= 0)
            && (pTokArray[index].token.tokClass != tokElem)
            )
    {
            index--;
    }
    return(index);
}
#endif //NEEDED

BOOL
FIsWhiteSpaceToken(WCHAR *pwOld, int indexStart, int indexEnd)
{
    BOOL fWhiteSpace = TRUE;
    int index;

    for (index = indexStart; index < indexEnd; index++)
    {
        if (   pwOld[index] != ' '
            && pwOld[index] != '\t'
            && pwOld[index] != '\r'
            && pwOld[index] != '\n'
            )
        {
            fWhiteSpace = FALSE;
            break;
        }
    }
    return (fWhiteSpace);
} /* FIsWhiteSpaceToken() */

inline void GlobalUnlockFreeNull(HGLOBAL *phg)
{
    GlobalUnlock(*phg); // do we need to check if this was already Unlocked?
    GlobalFree(*phg);
    *phg = NULL;
}

BOOL
FIsAbsURL(LPOLESTR pstr)
{
    LPCWSTR szHttp[] = {L"http:"};
    LPCWSTR szFile[] = {L"file:"};
    BOOL fRet = FALSE;

    if (pstr == NULL)
        goto LRet;

    if (   0 == _wcsnicmp(szHttp[0], pstr, wcslen(szHttp[0]))
        || 0 == _wcsnicmp(szFile[0], pstr, wcslen(szFile[0]))
        )
    {
        fRet = TRUE;
        goto LRet;
    }
LRet:
    return(fRet);
}

BOOL
FURLNeedSpecialHandling(TOKSTRUCT *pTokArray, int iArray, LPWSTR pwOld, int cMaxToken, int *pichURL, int *pcchURL)
{
    int index = iArray+1;
    int iHref = -1;
    int iURL = -1;
    BOOL fRet = FALSE;
    BOOL fCodeBase = FALSE;

    while (    index < cMaxToken
            && pTokArray[index].token.tok != TokTag_CLOSE
            && pTokArray[index].token.tokClass != tokTag
            ) // look for TokAttrib_HREF
    {
        if (   iHref == -1
            && (   pTokArray[index].token.tok == TokAttrib_HREF
                || pTokArray[index].token.tok == TokAttrib_SRC
                || pTokArray[index].token.tok == TokAttrib_CODEBASE
                )
            && pTokArray[index].token.tokClass == tokAttr
            )
        {
            iHref = index;
            // special case - if we have CODEBASE attribute, we always want special processing
            if (pTokArray[index].token.tok == TokAttrib_CODEBASE)
                fCodeBase = TRUE;
        }
        if (   iHref != -1
            && pTokArray[index].token.tok == 0
            && (pTokArray[index].token.tokClass == tokString || pTokArray[index].token.tokClass == tokValue)
            )
        {
            iURL = index;
            break;
        }
        index++;
    }
    if (iURL != -1) // its set properly
    {
        int cchURL;
        WCHAR *pszURL;
        BOOL fQuote = (pwOld[pTokArray[iURL].token.ibTokMin] == '"');

        cchURL = (fQuote)
                ? pTokArray[iURL].token.ibTokMac-pTokArray[iURL].token.ibTokMin-2
                : pTokArray[iURL].token.ibTokMac-pTokArray[iURL].token.ibTokMin;
        *pichURL = (fQuote)
                ? pTokArray[iURL].token.ibTokMin+1
                : pTokArray[iURL].token.ibTokMin;
        // special case - if the quoted value happens to be a serverside script,
        // we can ignore it here and decalre that we don't need to do any special 
        // processing.
        if (   ((pTokArray[iURL].token.ibTokMac-pTokArray[iURL].token.ibTokMin) == 1)
            || (cchURL < 0)
            )
        {
            *pcchURL = 0;
            goto LRet;
        }
        *pcchURL = cchURL;
        // special case - if we have CODEBASE attribute, we always want special processing
        // we don't need to see if its URL is absolute or not...
        if (fCodeBase)
        {
            fRet = TRUE;
            goto LRet;
        }

        pszURL = new WCHAR [cchURL+1];

        ASSERT(pszURL != NULL);
        memcpy( (BYTE *)pszURL,
                (BYTE *)&pwOld[pTokArray[iURL].token.ibTokMin + ((fQuote)? 1 : 0)],
                (cchURL)*sizeof(WCHAR));
        pszURL[cchURL] = '\0';
        if (!FIsAbsURL((LPOLESTR)pszURL))
            fRet = TRUE;
        delete pszURL;
    } // if (iURL != -1)

LRet:
    return(fRet);
}


// Copied from hu_url.cpp 
//-----------------------------------------------------------------------------
// Useful directory separator check
//-----------------------------------------------------------------------------
inline BOOL IsDirSep(CHAR ch)
{
    return ('\\' == ch || '/' == ch);
}

inline BOOL IsDirSep(WCHAR ch)
{
    return (L'\\' == ch || L'/' == ch);
}



//-----------------------------------------------------------------------------
//  UtilConvertToRelativeURL
//
//  Returns an item-relative URL.
//      The URL is returned identical if
//          the projects don't match
//          the protocols don't match
//
//  Assumes that protocol-less URLs are "http:". Must specify "file:" explicitly
//  to play with file URLs. 
//-----------------------------------------------------------------------------

static LPOLESTR
SkipServer(LPOLESTR pstr)
{
    pstr = wcschr(pstr, L'/');
    if (pstr == NULL)
        return NULL;
    pstr = wcschr(pstr+1, L'/');
    if (pstr == NULL)
        return NULL;
    pstr = wcschr(pstr+1, L'/');

    return pstr;            // positioned on the slash if there was one.
}

static LPOLESTR
SkipFile(LPOLESTR pstr)
{
    LPOLESTR    pstrT;

    pstrT = wcspbrk(pstr, L":\\/");
    if (pstr == NULL || pstrT == NULL)
        return pstr;

    // Guard against the case "//\\".

    if (pstrT == pstr &&
            IsDirSep(pstr[0]) &&
            IsDirSep(pstr[1]))
    {
        if (IsDirSep(pstr[2]) && IsDirSep(pstr[3]))
        {
            pstrT = pstr + 2;           // saw a "//\\"
        }
        else if (pstr[2] != L'\0'  && pstr[3] == L':')
        {
            pstrT = pstr + 3;           // saw a "//c:"
        }
    }

    ASSERT(!wcschr(pstrT + 1, ':')); // better not be more colons!
    if (*pstrT == ':')  // drive letter possibility
    {
        return pstrT + 1;               // point at the character after the colon
    }
    if (pstrT[0] == pstrT[1])           // double slash?
    {
        // Skip server part. 

        pstrT = wcspbrk(pstrT + 2, L"\\/");
        if (pstrT == NULL)
            return pstr;                // malformed!

        // Skip share part.

        pstrT = wcspbrk(pstrT + 1, L"\\/");
        if (pstrT == NULL)
            return pstr;                // malformed!

        return pstrT;
    }

    return pstr;
}

static LPOLESTR
FindLastSlash(LPOLESTR pstr)
{
    LPOLESTR    pstrSlash;      // '/'
    LPOLESTR    pstrWhack;      // '\'

    pstrSlash = wcsrchr(pstr, L'/');
    pstrWhack = wcsrchr(pstr, L'\\');

    return pstrSlash > pstrWhack
            ? pstrSlash
            : pstrWhack;
}

HRESULT
UtilConvertToRelativeURL(
    LPOLESTR    pstrDestURL,        // URL to 'relativize'
    LPOLESTR    pstrDestFolder,     // URL to be relative to.
    LPOLESTR    pstrDestProject,    // Project to be relative to.
    BSTR *      pbstrRelativeURL)
{
    HRESULT     hr = S_OK;
    LPOLESTR    pstrFolder;
    LPOLESTR    pstrURL;
    LPOLESTR    pchLastSlash;
    CComBSTR    strWork;
    int         cch;
    int         cchFolder;
    int         i;
    int         ichLastSlash;
    bool        fAbsoluteURL = false;
    bool        fAbsoluteFolder = false;
    bool        fFileURL = false;

    // If there's a ':' in the URL we're relativizing, it's assumed
    // to contain a protocol. If the protocol isn't "http:".

    if (!FIsAbsURL(pstrDestURL)) // VID6 - bug 22895
        goto Copy;

    pstrURL = pstrDestURL;
    if (wcschr(pstrDestURL, L':'))
    {
        // Check the protocol against the two we understand. If it is some other thing,
        // we punt.

        if (wcsncmp(pstrDestURL, L"http:", 5) != 0)
        {
            if (wcsncmp(pstrDestURL, L"file:", 5) != 0)
                goto Copy;

            // File URLs are normalized by skipping any '\\server\share' part.

            fFileURL = true;
            pstrURL = SkipFile(pstrDestURL + 5); // 5 skips the 'file:' prefix
        }
        else if (pstrDestProject != NULL)
        {
            // Project-relative URLs had better match the project prefix.

            cch = wcslen(pstrDestProject);
            if (_wcsnicmp(pstrDestURL, pstrDestProject, cch) != 0)
                goto Copy;

            // Project-relative URLs are normalized by skipping the project prefix.

            pstrURL = pstrDestURL + cch - 1;
            ASSERT(*pstrURL == '/');
        }
        else
        {
            // Generic 'http:' URLs skip the server part only.

            pstrURL = SkipServer(pstrDestURL);
            ASSERT(*pstrURL == '/');
        }

        if (!pstrURL)
            goto Copy;
        fAbsoluteURL = true;
    }

    // If the folder contains an 'http:' prefix, then find the server and skip that part.
    // otherwise it's assumed the folder is already in a project-relative format.

    pstrFolder = pstrDestFolder;

    if (NULL == pstrFolder)
        goto Copy;

    if (wcsncmp(pstrDestFolder, L"file://", 7) == 0)
    {
        if (!fFileURL)
            goto Copy;

        pstrFolder = SkipFile(pstrDestFolder + 5);
        fAbsoluteFolder = true;
    }
    else if (wcsncmp(pstrDestFolder, L"http://", 7) == 0)
    {
        if (pstrDestProject != NULL)
        {
            // If a project was passed in, make sure the place we're relativizing to has the same path.
            // If they don't match, we're in trouble.

            cch = wcslen(pstrDestProject);
            if (_wcsnicmp(pstrDestFolder, pstrDestProject, cch) != 0)
                goto Copy;
            pstrFolder = pstrDestFolder + cch - 1;
        }
        else
        {
            pstrFolder = SkipServer(pstrDestFolder);
        }
        ASSERT(pstrFolder);
        ASSERT(*pstrFolder == '/');
        fAbsoluteFolder = true;
    }

    // If both the URL and the folder had absolute paths, we need to ensure
    // that the servers are the same.

    if (fAbsoluteFolder && fAbsoluteURL)
    {
        if (pstrURL - pstrDestURL != pstrFolder - pstrDestFolder ||
                _wcsnicmp(pstrDestURL, pstrDestFolder, SAFE_PTR_DIFF_TO_INT(pstrURL - pstrDestURL)) != 0)
            goto Copy;
    }

    // From now on, ignore the item at the end of pstrFolder

    pchLastSlash = FindLastSlash(pstrFolder);
    ASSERT(pchLastSlash);
    cchFolder = 1 + SAFE_PTR_DIFF_TO_INT(pchLastSlash - pstrFolder);

    // Both folder and item are now relative to the server root.

    // Locate the last slash in the URL. 

    pchLastSlash = FindLastSlash(pstrURL);

    if (pchLastSlash == NULL)
        ichLastSlash = 0;
    else
        ichLastSlash = 1 + SAFE_PTR_DIFF_TO_INT(pchLastSlash - pstrURL);

    // Find any common directories. 

    cch = min(cchFolder, ichLastSlash);
    ichLastSlash = -1;
    for (i = 0; i < cch && pstrFolder[i] == pstrURL[i]; ++i)
    {
        if (IsDirSep(pstrFolder[i]))
            ichLastSlash = i;
    }

    // ichLastSlash should point beyond at last slash of the last common folder.

    // For each remaining slash, append a ../ to the path.

    for (; i < cchFolder; ++i)
    {
        if (IsDirSep(pstrFolder[i]))
        {
            strWork += (fFileURL ? L"..\\" : L"../");
        }
    }

    if (-1 == ichLastSlash)
    {   // no common parts, append all of the destination
        strWork += pstrURL;
    }
    else
    {   // append only the non-match part of the destination

        strWork += (pstrURL + ichLastSlash + 1);
    }


Cleanup:
    *pbstrRelativeURL = strWork.Copy();
    if (!*pbstrRelativeURL && ::wcslen(strWork) > 0)
        hr = E_OUTOFMEMORY;

    return hr;

Copy:
    strWork = pstrDestURL;
    goto Cleanup;
}




long CTriEditParse::m_bInit = 0;

CTriEditParse::CTriEditParse()
{
    m_rgSublang = 0;
    m_fHasTitleIn = FALSE;
    m_hgPTDTC = NULL;
    m_cchPTDTC = 0;
    m_ichBeginHeadTagIn = -1;
    m_ispInfoBase = 0;

    if(0 == m_bInit++)
        InitSublanguages();
}

CTriEditParse::~CTriEditParse()
{
    // save last variant as default if it's not ASP
    if (NULL != m_rgSublang)
    {
        for( int i= 0; NULL != m_rgSublang[i].szSubLang; i++)
        {
            delete [] (LPTSTR)(m_rgSublang[i].szSubLang);
        }
        delete [] m_rgSublang;
    }
    ASSERT(0 != m_bInit);

    if(0 == --m_bInit)
    {
        ATLTRACE(_T("Releasing tables\n"));

        // delete dynamically allocated tables
        for (int i = 0; NULL != g_arpTables[i]; i++)
            delete g_arpTables[i];
        delete g_pTabDefault;

        m_bInit = 0;
    }

}


// copied from CColorHtml::NextToken
STDMETHODIMP CTriEditParse::NextToken
(
    LPCWSTR pszText,
    UINT    cbText,
    UINT*   pcbCur,
    DWORD*  pLXS,
    TXTB*   pToken
)
{
    ASSERT(pszText != NULL);
    ASSERT(pcbCur != NULL);
    ASSERT(pLXS != NULL);
    ASSERT(pToken != NULL);
    USES_CONVERSION;

    if(pszText == NULL || pcbCur == NULL || pLXS == NULL || pToken == NULL)
        return E_INVALIDARG;

    if(0 == cbText)
        return S_FALSE;

    SetTable(*pLXS); // set g_pTable according to state

#ifdef _UNICODE
    *pcbCur = GetToken(pszText, cbText, *pcbCur, pLXS, *pToken);
#else   // _UNICODE
    int     cch;
    LPTSTR  pszTemp;

    // get the converted length
    cch = WideCharToMultiByte(CP_ACP, 0, pszText, cbText,
        NULL, 0, NULL, NULL);
    pszTemp = new char[cch + 1];

    ZeroMemory(pszTemp, cch + 1);
    // copy the wide char to multibyte
    WideCharToMultiByte(CP_ACP, 0, pszText, cbText, pszTemp, cch,
        NULL, NULL);

    *pcbCur = GetToken(pszTemp, cch, *pcbCur, pLXS, *pToken);

    delete [] pszTemp;
#endif  // _UNICODE

    return (*pcbCur < cbText) ? NOERROR : S_FALSE;
}



// set g_pTable according to state
void CTriEditParse::SetTable(DWORD lxs)
{
    ASSERT(SubLangIndexFromLxs(lxs) < sizeof g_arpTables/sizeof g_arpTables[0]);
    g_pTable = g_arpTables[SubLangIndexFromLxs(lxs)];

    ASSERT(g_pTable != NULL);
}

void CTriEditParse::InitSublanguages()
{
	#define cHTML2Len 2048

    g_pTabDefault = new CStaticTableSet(ALL, IDS_HTML);
    int cl = CV_FIXED;
    CTableSet * rgpts[CV_MAX +1];
    memset(rgpts, 0, sizeof rgpts);

    CTableSet* ptabset; // current
    CTableSet* ptabBackup; // backup default

    memset(g_arpTables, 0, sizeof g_arpTables);

    m_rgSublang = new SUBLANG[cl+2]; // 0th + list + empty terminator
    ASSERT(NULL != m_rgSublang);
	if (NULL != m_rgSublang)
		memset(m_rgSublang, 0, (cl+2)*sizeof SUBLANG);

    UINT iLang = 1;
    TCHAR strDefault[cHTML2Len];

    // Microsoft browsers
    // Internet Explorer 3
    ptabset = MakeTableSet(rgpts, IEXP3, IDS_IEXP3);
    SetLanguage( strDefault, m_rgSublang, ptabset, iLang, IDR_HTML, CLSID_NULL );

    // Set backup default as IE 3
    ptabBackup = ptabset;
    if (lstrlen(strDefault) == 0)
    {
        ASSERT(lstrlen(ptabBackup->Name()) != 0);
        lstrcpy(strDefault, ptabBackup->Name());
    }

    // User's additions

    for (int n = 0; rgpts[n]; n++)
    {
        ptabset = rgpts[n];
        SetLanguage( strDefault, m_rgSublang, ptabset, iLang, 0, CLSID_NULL );
        ptabBackup = ptabset;
    }

    // HTML 2.0 base (if not overridden)
    {
        TCHAR strHTML2[cHTML2Len];
        ::LoadString(   _Module.GetModuleInstance(),
                        IDS_RFC1866,
                        strHTML2,
                        cHTML2Len
                        );
        if (!FindTable(rgpts,strHTML2))
        {
            ptabset = new CStaticTableSet(HTML2, IDS_RFC1866);
            SetLanguage( strDefault, m_rgSublang, ptabset, iLang, 0, CLSID_NULL);
        }
    }

    if (NULL == g_arpTables[0])
    {
        ASSERT(NULL != ptabBackup); // error: didn't get a default!

        //Find the backup in the tables
        int i;
        for (i = 1; NULL != g_arpTables[i]; i++)
        {
            if (g_arpTables[i] == ptabBackup)
                break;
        }

        ASSERT(NULL != g_arpTables[i]); // must be in table

        // Set default
        g_arpTables[0] = g_pTable = g_arpTables[i];
        m_rgSublang[0] = m_rgSublang[i];
        m_rgSublang[0].lxsInitial = LxsFromSubLangIndex(0);

        // Move the rest down to fill the hole
        for (; g_arpTables[i]; i++)
        {
            g_arpTables[i] = g_arpTables[i+1];
            m_rgSublang[i] = m_rgSublang[i+1];
            m_rgSublang[i].lxsInitial = LxsFromSubLangIndex(i);
        }
    }
    ASSERT(NULL != g_arpTables[0]);

    // set global ASP sublang ptr
    // start at 1, since the default is at 0, and should never be ASP
    for (int i = 1; NULL != m_rgSublang[i].szSubLang; i++)
    {
        if (m_rgSublang[i].nIdTemplate == IDR_ASP)
        {
            g_psublangASP = &m_rgSublang[i];
            break;
        }
    }
}

// Reallocs are expensive, so when we Realloc, should we add some more pad so that 
// we wont have to call Realloc very often?

HRESULT
ReallocBuffer(HGLOBAL *phg, DWORD cbNew, UINT uFlags)
{
    HRESULT hr = S_OK;
    HGLOBAL hg;

    ASSERT(*phg != NULL);
    ASSERT(cbNew != 0); // will we ever get this?
    GlobalUnlock(*phg);
    hg = *phg;
#pragma prefast(suppress:308, "noise")
    *phg = GlobalReAlloc(*phg, cbNew, uFlags);
    if (*phg == NULL)
    {
#ifdef DEBUG
        hr = GetLastError();
#endif // DEBUG
        GlobalFree(hg);
        hr = E_OUTOFMEMORY;
    }

    return(hr);
} /* ReallocBuffer() */

HRESULT
ReallocIfNeeded(HGLOBAL *phg, WCHAR **ppwNew, UINT cbNeed, UINT uFlags)
{
    HRESULT hr = S_OK;

    ASSERT(*phg != NULL);
    if (GlobalSize(*phg) < cbNeed)
    {
        hr = ReallocBuffer(phg, cbNeed, uFlags);
        if (hr == E_OUTOFMEMORY)
            goto LRet;
        ASSERT(*phg != NULL);
        *ppwNew = (WCHAR *)GlobalLock(*phg);
    }
LRet:
    return(hr);

} /* ReallocIfNeeded() */

void
CTriEditParse::fnRestoreSSS(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
             TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft, 
             INT *pcSSSOut, UINT *pichNewCur, UINT *pichBeginCopy,
             DWORD /*dwFlags*/)
{
    // Server Side Script case
    // This occurs inside <%  %>. we assume simple SSS
    // remove the added <SCRIPT LANGUAGE=SERVERASP> & </SCRIPT> text around it
    UINT iArray = *piArrayStart;
    INT i;
    UINT ichScrStart, ichScrEnd, indexScrStart, indexScrEnd;
    UINT ichSSSStart, ichSSSEnd;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT cSSSOut = *pcSSSOut;
    LPCWSTR szSSS[] = {L"SERVERASP", L"\"SERVERASP\""};
    LPCWSTR szSSSSp[] = {L"SERVERASPSP"};
    BOOL fSpecialSSS = FALSE;
    LPWSTR pwNew = *ppwNew;
    INT iMatchMax;
    UINT cbNeed;
    UINT ichScrWspBegin, ichScrWspEnd, ichSp;

    ASSERT(cSSSOut >= 0); // make sure that this was initilized
    if (cSSSOut == 0)
        goto LRetOnly;

    //{TokTag_START, TokElem_SCRIPT, TokTag_CLOSE, TokElem_SCRIPT, fnRestoreSSS}
    ichScrStart = ichScrEnd = indexScrStart = indexScrEnd = ichSSSStart = ichSSSEnd = 0;
    ichScrWspBegin = ichScrWspEnd = 0;
    while (cSSSOut > 0)
    {
        // start at iArray of pTokArray and look for TokElem_SCRIPT
        //while (pTokArray[iArray].token.tok != ft.tokBegin2)
        //  iArray++;
        ASSERT(iArray < ptep->m_cMaxToken);
        if (pTokArray[iArray].token.tok != TokElem_SCRIPT)
            goto LRet;

        // Here's the deal - we have to ignore all SSS that appear
        // as values inside client scripts or insize objects/dtcs
        // so, we need to skip this TokElem_SCRIPT tag if we found '</' before TokElem_SCRIPT
        if (   pTokArray[iArray].token.tok == TokElem_SCRIPT
            && pTokArray[iArray-1].token.tok != TokTag_START
            )
        {
            ASSERT(pTokArray[iArray].token.tokClass == tokElem);
            iArray++; // so that we don't come here again with the same iArray
            ptep->m_fDontDeccItem = TRUE; // we can do things differently here next time around
            ptep->m_cSSSOut++;
            goto LRet;
        }

        //ASSERT(pTokArray[iArray].token.tok == TokElem_SCRIPT);
        i = iArray; // the position at which we found ft.tokBegin2
        // look for the special LANGUAGE arrtibute that we had set.
        // if that doesn't exist, this is not the SSS we want
        // we don't really need to look for this till ptep->m_cMaxToken,
        // but this will cover boundary cases
        iMatchMax = (pTokArray[iArray].iNextprev == -1)? ptep->m_cMaxToken : pTokArray[iArray].iNextprev;
        while (i < iMatchMax)
        {
            if (pTokArray[i].token.tok == TokAttrib_LANGUAGE)
            {
                ASSERT(pTokArray[i].token.tokClass == tokAttr);
                break;
            }
            i++;
        }
        if (i < iMatchMax)
        {
            // make sure that the next one is tokOpEqual
            ASSERT(pTokArray[i+1].token.tokClass == tokOp);
            //ASSERT(((pwOld+pTokArray[i+1].token.ibTokMin)*sizeof(WCHAR)) == '=');
            // get the next value and compare it with szSSS[]
            // note that this may also match with szSSSSp[]
            if (   0 != _wcsnicmp(szSSS[0], &pwOld[pTokArray[i+2].token.ibTokMin], wcslen(szSSS[0]))
                && 0 != _wcsnicmp(szSSS[1], &pwOld[pTokArray[i+2].token.ibTokMin], wcslen(szSSS[1]))
                )
            {
                iArray = i;
                goto LNextSSS; // not this one
            }
        }
        else // error case
        {
            iArray++;
            goto LRet;
        }
        // compare with szSSSSp[] and set fSpecialSSS
        if (0 == _wcsnicmp(szSSSSp[0], &pwOld[pTokArray[i+2].token.ibTokMin], wcslen(szSSSSp[0])))
            fSpecialSSS = TRUE;
        i = iArray; // we are OK, so lets look for < before SCRIPT tag
        while (i >= 0)
        {
            // do we need to do anything else here?
            if (pTokArray[i].token.tok == ft.tokBegin)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_START);
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                break;
            }
            i--;
        }
        if (i >= 0) // found TokTag_START token
        {
            ichScrStart = pTokArray[i].token.ibTokMin;
            indexScrStart = i;
        }
        else // error case
        {
            // we found SCRIPT, but didn't find < of <SCRIPT
            // we can't process this SSS, so quit
            goto LRet;
        }

        // now lets look for <! that would be after <SCRIPT LANGUAGE = SERVERASP>
        while (i < (int)ptep->m_cMaxToken)
        {
            if (   pTokArray[i].token.tok == TokTag_CLOSE
                && pTokArray[i].token.tokClass == tokTag
                )
                ichScrWspBegin = pTokArray[i].token.ibTokMac; // if we had saved white space, it would begin here

            if (pTokArray[i].token.tok == TokTag_BANG)
            {
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                ASSERT(pTokArray[i+1].token.tokClass == tokComment);
                //we can assert for next 2 chars as --
                ichSSSStart = pTokArray[i].token.ibTokMin;
                break;
            }
            i++;
        }
        if (i >= (int)ptep->m_cMaxToken) // didn't find <!
        {
            goto LRet;
        }
        // look for ending -->
        while (i < (int)ptep->m_cMaxToken)
        {
            if (pTokArray[i].token.tok == TokTag_CLOSE && pTokArray[i].token.tokClass == tokTag)
            {
                //we can assert for next 2 chars as --
                ASSERT(*(pwOld+pTokArray[i].token.ibTokMin-1) == '-');
                ASSERT(*(pwOld+pTokArray[i].token.ibTokMin-2) == '-');
                ichSSSEnd = pTokArray[i].token.ibTokMac;
                break;
            }
            i++;
        }
        if (i >= (int)ptep->m_cMaxToken) // didn't find >
        {
            goto LRet;
        }

        // now look for ft.tokEnd2 & ft.tokEnd (i.e. TokElem_SCRIPT & >)
        while (pTokArray[i].token.tok != ft.tokEnd2)
        {
            if (pTokArray[i].token.tok == TokTag_END && pTokArray[i].token.tokClass == tokTag)
                ichScrWspEnd = pTokArray[i].token.ibTokMin; // past the last white space
            i++;
        }
        ASSERT(i < (int)ptep->m_cMaxToken);
        ASSERT(pTokArray[i].token.tok == TokElem_SCRIPT);
        ASSERT(pTokArray[i].token.tokClass == tokElem);
        // go forward and look for > of SCRIPT>
        // as additional check, we can also check that previous token is </
        while (i < (int)ptep->m_cMaxToken)
        {
            if (pTokArray[i].token.tok == ft.tokEnd)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_CLOSE);
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                break;
            }
            i++;
        }
        if (i < (int)ptep->m_cMaxToken) // found TokTag_CLOSE
        {
            ichScrEnd = pTokArray[i].token.ibTokMac;
            indexScrEnd = i;
        }
        else // error case
        {
            // we found SCRIPT, but didn't find > of SCRIPT>
            // we can't process this SSS, so quit
            goto LRet;
        }
        iArray = i+1; // set it for next run

        cbNeed = (ichNewCur+(ichScrStart-ichBeginCopy)+(ichSSSEnd-ichSSSStart))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        // do the Blts
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to begining of SSS
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichScrStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichScrStart-ichBeginCopy);
        ichBeginCopy = ichScrEnd; // make it ready for next copy

        if (fSpecialSSS)
        {
            // in special case, we need to make space for the <%@...%> at the begining of pwNew
            // so, we move all the above stuff (ichNewCur chars) by (ichSSSEnd-ichSSSStart-3).
            memmove((BYTE *)(&pwNew[ichSSSEnd-ichSSSStart-3]),
                    (BYTE *)pwNew,
                    (ichNewCur)*sizeof(WCHAR)
                    );
            // we now copy <%@...%> at the begining of the doc instead of at ichNewCur
            // now skip <SCRIPT LANGUAGE=SERVERASP> & only copy <% ....%>
            // note that we have to get rid of 3 extra chars we had added when we converted going in Trident
            memcpy( (BYTE *)(pwNew),
                    (BYTE *)&pwOld[ichSSSStart+2],/*get rid of 2 extra chars we had added at the begining*/
                    (ichSSSEnd-ichSSSStart-3)*sizeof(WCHAR));
            pwNew[0] = '<'; pwNew[1] = '%'; // note that we have moved the SSS to the begining of the doc
            ichNewCur += ichSSSEnd-ichSSSStart-3; // here we got rid of 1 extra char that was added
            pwNew[(ichSSSEnd-ichSSSStart-3)-2] = '%';
            pwNew[(ichSSSEnd-ichSSSStart-3)-1] = '>';
            // change <!-- to <% and --> to %>
        }
        else
        {
            // in pwNew get rid of white space characters from ichNewCur backwards
            ichSp = ichNewCur-1;
            while (    (   pwNew[ichSp] == ' '  || pwNew[ichSp] == '\r' 
                        || pwNew[ichSp] == '\n' || pwNew[ichSp] == '\t'
                        )
                    )
            {
                ichSp--;
            }
            ichSp++; // compensate for the last decrement, ichSp points to the 1st white-space character
            ichNewCur = ichSp;
            // copy pre-script white space
            if (ichScrWspBegin > 0 && ichSSSStart > ichScrWspBegin) // has been set
            {
                memcpy( (BYTE *)&pwNew[ichNewCur], 
                        (BYTE *)&pwOld[ichScrWspBegin],
                        (ichSSSStart-ichScrWspBegin)*sizeof(WCHAR));
                ichNewCur += ichSSSStart-ichScrWspBegin;
            }
            // now skip <SCRIPT LANGUAGE=SERVERASP> & only copy <% ....%>
            // note that we have to get rid of 3 extra chars we had added when we converted going in Trident
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichSSSStart+2]),/*get rid of 2 extra chars we had added at the begining*/
                    (ichSSSEnd-ichSSSStart-3)*sizeof(WCHAR));
            pwNew[ichNewCur] = '<';
            pwNew[ichNewCur+1] = '%'; 
            ichNewCur += ichSSSEnd-ichSSSStart-3; // here we got rid of 1 extra char that was added
            pwNew[ichNewCur-2] = '%';
            pwNew[ichNewCur-1] = '>';
            // copy post-script white space
            if (ichScrWspEnd > 0 && ichScrWspEnd > ichSSSEnd) // has been set
            {
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[ichSSSEnd],
                        (ichScrWspEnd-ichSSSEnd)*sizeof(WCHAR));
                ichNewCur += ichScrWspEnd-ichSSSEnd;
            }

            // increment iArray & ichBeginCopy till the next non-whitespace token
            while (iArray < (int)ptep->m_cMaxToken)
            {
                UINT ich;
                BOOL fNonWspToken = FALSE; // assume the next token to be whitespace
                // scan entire token and see if it has all white-space characters
                for (ich = pTokArray[iArray].token.ibTokMin; ich < pTokArray[iArray].token.ibTokMac; ich++)
                {
                    if (   pwOld[ich] != ' '    && pwOld[ich] != '\t'
                        && pwOld[ich] != '\r'   && pwOld[ich] != '\n'
                        )
                    {
                        fNonWspToken = TRUE;
                        break;
                    }
                }
                if (fNonWspToken)
                {
                    ichBeginCopy = pTokArray[iArray].token.ibTokMin;
                    break;
                }
                iArray++;
            }
        }

        cSSSOut--;
    } // while (cSSSOut > 0)

LNextSSS:
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
LRetOnly:
    return;

} /* fnRestoreSSS() */

void
CTriEditParse::fnSaveSSS(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
             TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft, 
             INT *pcSSSIn, UINT *pichNewCur, UINT *pichBeginCopy,
             DWORD /*dwFlags*/)
{
    // Server Side Script case
    // This occur inside <%  %>. We assume simple SSS
    // add <SCRIPT LANGUAGE=SERVERASP> & </SCRIPT> around it
    // tag used for saving the SSS.
    /* 2 spaces at the end of 1st element are important */
    LPCWSTR rgSSSTags[] =
    {
        L"\r\n<SCRIPT LANGUAGE=\"SERVERASP\">",
        L"\r\n<SCRIPT LANGUAGE=\"SERVERASPSP\">",
        L"</SCRIPT>\r\n"
    };
    UINT iArray = *piArrayStart;
    UINT i;
    UINT ichSSSStart, ichSSSEnd, indexSSSStart, indexSSSEnd;
    HGLOBAL hgSSS = NULL;
    WCHAR *pSSS;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT cSSSIn = *pcSSSIn;
    LPWSTR pwNew = *ppwNew;
    int indexSSSTag;
    UINT cbNeed;
    UINT ichSp;

    ASSERT(cSSSIn >= 0); // make sure that this was initilized
    if (cSSSIn == 0)
        goto LRetOnly;
    
    ichSSSStart = ichSSSEnd = indexSSSStart = indexSSSEnd = 0;

    while (cSSSIn > 0)
    {
        INT cbMin = 0x4fff; // init & increment size of hgSSS
        INT cchCurSSS = 0;
        int index;

        // handle special case here - if the script is inside <xmp> tag, we shouldn't convert the script
        // NOTE that we are only handling <xmp> <%...%> </xmp> case here
        // we don't have to worry about nested xmp's because its not valid html.
        // such invalid cases are <xmp>...<xmp> </xmp> <% %> </xmp> OR <xmp>...<xmp> <% %> </xmp> </xmp>
        // handle TokElem_PLAINTEXT as well
        index = iArray;
        while (index >= 0)
        {
            if (   (pTokArray[index].token.tok == TokElem_XMP || pTokArray[index].token.tok == TokElem_PLAINTEXT)
                && pTokArray[index].token.tokClass == tokElem
                && pTokArray[index].iNextprev > iArray
                )
            {
                iArray++;
                goto LRet;
            }
            index--;
        }

        // start at the begining of pTokArray and look for first <%
        ASSERT(ft.tokBegin2 == -1);
        ASSERT(ft.tokEnd2 == -1);
        // Here both supporting tokens are -1, so we simply look for main tokens.
        i = iArray;
        while (i < ptep->m_cMaxToken)
        {
            // do we need to do anything else here?
            if (pTokArray[i].token.tok == ft.tokBegin)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_SSSOPEN);
                ASSERT(pTokArray[i].token.tokClass == tokSSS);
                break;
            }
            i++;
        }
        if (i < ptep->m_cMaxToken) // found TokTag_SSSOPEN token
        {
            ichSSSStart = pTokArray[i].token.ibTokMin;
            indexSSSStart = i;
        }

        // look for ft.tokEnd
        if (pTokArray[i].iNextprev != -1)
        {
            // NOTE that this will give us topmost nested level of the SSS
            indexSSSEnd = pTokArray[i].iNextprev;
            ichSSSEnd = pTokArray[indexSSSEnd].token.ibTokMac;
            ASSERT(indexSSSEnd < ptep->m_cMaxToken);
            // this will be a wierd case where the iNextprev is incorrectly pointing to another token
            // but lets handle that case.
            if (pTokArray[indexSSSEnd].token.tok != TokTag_SSSCLOSE)
                goto LFindSSSClose; // find it by looking at each token
        }
        else // actually, this is an error case, but rather than just giving assert, try to find the token
        {
LFindSSSClose:
            while (i < ptep->m_cMaxToken)
            {
                if (pTokArray[i].token.tok == ft.tokEnd)
                {
                    ASSERT(pTokArray[i].token.tok == TokTag_SSSCLOSE);
                    ASSERT(pTokArray[i].token.tokClass == tokSSS);
                    break;
                }
                i++;
            }
            if (i < ptep->m_cMaxToken) // found TokTag_SSSCLOSE token
            {
                ichSSSEnd = pTokArray[i].token.ibTokMac;
                indexSSSEnd = i;
            }
            else // error case 
            {
                goto LRet; // didn't find %>, but exhausted the token array
            }
        }
        iArray = indexSSSEnd; // set for for next SSS

        // now insert text from rgSSSTags[] into the source
        // 0. Allocate a local buffer
		cbNeed =	wcslen(rgSSSTags[0]) + wcslen(rgSSSTags[0]) + wcslen(rgSSSTags[2])
					+ (ichSSSEnd-ichSSSStart) + cbMin;
		hgSSS = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbNeed*sizeof(WCHAR));
        if (hgSSS == NULL)
            goto LErrorRet;
        pSSS = (WCHAR *) GlobalLock(hgSSS);
        ASSERT(pSSS != NULL);

        // NOTE - This flag would have been set to TRUE only if, 
        // we have found <%@ as the 1st SSS in the document
        indexSSSTag = 0;
        if (ptep->m_fSpecialSSS)
        {
            ptep->m_fSpecialSSS = FALSE;
            indexSSSTag = 1;
        }

        //-------------------------------------------------------------------------------
        // ASSUMPTION - The big assumption we are making is that IE5 doesn't change 
        // anything inside the client sctipt. So far we have seen that.
        // In the worst case, if they start mucking with the contents of client script, 
        // we will loose the spacing, but there will be NO DATA LOSS.
        // 
        // Based on this assumption, we simply save the pre-post script spacing as is
        // and expect to restore it on the way out.
        //-------------------------------------------------------------------------------

        // 1. Insert <SCRIPT> from rgSSSTags[indexSSSTag]
        wcscpy(&pSSS[cchCurSSS], rgSSSTags[indexSSSTag]);
        cchCurSSS += wcslen(rgSSSTags[indexSSSTag]);
        // insert the white space as it occurs in pwOld, ichSSSStart is '<' of '<%', walk backwards
        ichSp = ichSSSStart-1;
        while (    (   pwOld[ichSp] == ' '  || pwOld[ichSp] == '\r' 
                    || pwOld[ichSp] == '\n' || pwOld[ichSp] == '\t'
                    )
                )
        {
            ichSp--;
        }
        ichSp++; // compensate for the last decrement
        if ((int)(ichSSSStart-ichSp) > 0)
        {
            wcsncpy(&pSSS[cchCurSSS], &pwOld[ichSp], ichSSSStart-ichSp);
            cchCurSSS += ichSSSStart-ichSp;
        }
        // now add TokTag_BANG '<!'
        pSSS[cchCurSSS++] = '<';
        pSSS[cchCurSSS++] = '!';
        // 2. copy the script from pwOld
        wcsncpy(&pSSS[cchCurSSS], &pwOld[ichSSSStart], ichSSSEnd-ichSSSStart);
        pSSS[cchCurSSS] = '-';
        pSSS[cchCurSSS+1] = '-';
        cchCurSSS += (ichSSSEnd-ichSSSStart);
        pSSS[cchCurSSS] = pSSS[cchCurSSS-1]; //note : -1 is '>'
        pSSS[cchCurSSS-2] = '-';
        pSSS[cchCurSSS-1] = '-';
        cchCurSSS++; // we are adding one extra character
        // insert the white space as it occurs in pwOld, ichSSSEnd is past '%>', walk forward
        ichSp = ichSSSEnd;
        while (    (ichSp < pTokArray[ptep->m_cMaxToken-1].token.ibTokMac-1)
                && (   pwOld[ichSp] == ' '  || pwOld[ichSp] == '\r' 
                    || pwOld[ichSp] == '\n' || pwOld[ichSp] == '\t'
                    )
                )
        {
            ichSp++;
        }
        if ((int)(ichSp-ichSSSEnd) > 0)
        {
            wcsncpy(&pSSS[cchCurSSS], &pwOld[ichSSSEnd], ichSp-ichSSSEnd);
            cchCurSSS += ichSp-ichSSSEnd;
        }
        // 3. Insert </SCRIPT> from rgSSSTags[2]
        wcscpy(&pSSS[cchCurSSS], rgSSSTags[2]);
        cchCurSSS += wcslen(rgSSSTags[2]);



        /* REALLOCATE pwNew IF NEEDED here, use cache value for GlobalSize(*phgNew) and don't forget to update it too */
        cbNeed = (ichNewCur+(ichSSSStart-ichBeginCopy)+(cchCurSSS))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LErrorRet;

                    
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew

        if ((int)(ichSSSStart-ichBeginCopy) >= 0)
        {
            // copy till begining of the <%
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichBeginCopy]),
                    (ichSSSStart-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += ichSSSStart-ichBeginCopy;
            ichBeginCopy = ichSSSEnd; // set it for next script

            // copy the converted SSS
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(pSSS),
                    cchCurSSS*sizeof(WCHAR));
            ichNewCur += cchCurSSS;
        }

        if (hgSSS != NULL)
            GlobalUnlockFreeNull(&hgSSS);

        cSSSIn--;
    } // while(cSSSIn > 0)

LErrorRet:
    if (hgSSS != NULL)
        GlobalUnlockFreeNull(&hgSSS);
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

LRetOnly:   
    return;

} /* fnSaveSSS() */

void
CTriEditParse::fnRestoreDTC(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
             TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft, 
             INT *piObj, UINT *pichNewCur, UINT *pichBeginCopy,
             DWORD dwFlags)
{
    // OBJECTS case - (These were converted from DTCs in modeInput
    // if we get OBJECT, search backwards (carefully) for tokTag/TokTag_START (<) in pTokArray
    // once we find that, remember the ibTokMin for Object conversion
    // look for the /OBJECT (i.e. look for OBJECT and look for previous /) and
    // once we get those two next to each other, wait for upcoming toktag_CLOSE which will end that Object
    // remember ibTokMac at that position. This is the OBJECT range.
    // First, insert the startspan text
    // Then generate and insert the endspan text (note that we may have to extend our
    // buffer becausethe generated text mey not fit.
    // Do the appropriate Blts to adjust the buffer.

    UINT cchObjStart, indexObjStart, cchObjEnd, indexObjEnd;
    HGLOBAL hgDTC = NULL;
    WCHAR *pDTC;
    UINT iArray = *piArrayStart;
    INT i;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    HRESULT hr;
    LPWSTR pwNew = *ppwNew;
    UINT cbNeed;

    long iControlMac;
    CComPtr<IHTMLDocument2> pHTMLDoc;
    CComPtr<IHTMLElementCollection> pHTMLColl;
    CComPtr<IDispatch> pDispControl;
    CComPtr<IActiveDesigner> pActiveDesigner;
    VARIANT vaName, vaIndex;
    // DTC tag used for saving the DTC.
    LPCWSTR rgDTCTags[] =
    {
        L"<!--METADATA TYPE=\"DesignerControl\" startspan\r\n",
        L"\r\n-->\r\n",
        L"\r\n<!--METADATA TYPE=\"DesignerControl\" endspan-->"
    };
    LPCWSTR rgCommentRT[] =
    {
        L"DTCRUNTIME",
        L"--DTCRUNTIME ",
        L" DTCRUNTIME--",
    };
    int ichRT, cchRT, ichRTComment, cchRTComment, indexRTComment;

    ichRTComment = ichRT = -1;
    indexRTComment = -1;
    cchRT = cchRTComment = 0;

    cchObjStart = indexObjStart = cchObjEnd = indexObjEnd = 0;

    // start at the begining of pTokArray and look for first OBJECT
    //while (pTokArray[iArray].token.tok != ft.tokBegin2)
    //  iArray++;
    ASSERT(iArray < ptep->m_cMaxToken);

    if (pTokArray[iArray].token.tok != TokElem_OBJECT)
        goto LRet;

    //ASSERT(pTokArray[iArray].token.tok == TokElem_OBJECT);
    i = iArray; // the position at which we found ft.tokBegin2
    while (i >=0)
    {
        // do we need to do anything else here?
        if (pTokArray[i].token.tok == ft.tokBegin)
        {
            ASSERT(pTokArray[i].token.tok == TokTag_START);
            ASSERT(pTokArray[i].token.tokClass == tokTag);
            break;
        }
        i--;
    }
    if (i >= 0) // found TokTag_START token
    {
        cchObjStart = pTokArray[i].token.ibTokMin;
        indexObjStart = i;
    }
    i = pTokArray[iArray].iNextprev;
    if (i == -1) // no matching end, skip this <OBJECT>
        goto LRet;
    ASSERT(pTokArray[pTokArray[iArray].iNextprev].token.tok == TokElem_OBJECT);
    ASSERT(pTokArray[pTokArray[iArray].iNextprev].token.tokClass == tokElem);
    ASSERT(pTokArray[i-1].token.tok == TokTag_END);
    // from this ith position, look for ft.tokEnd
    while (i < (int)ptep->m_cMaxToken)
    {
        if (pTokArray[i].token.tok == ft.tokEnd)
        {
            ASSERT(pTokArray[i].token.tok == TokTag_CLOSE);
            ASSERT(pTokArray[i].token.tokClass == tokTag);
            break;
        }
        i++;
    }
    if (i < (int)ptep->m_cMaxToken) // found TokTag_CLOSE token
    {
        cchObjEnd = pTokArray[i].token.ibTokMac;
        indexObjEnd = i;
    }
    
    // look for the special comment that has the runtime text saved
    // we will need it if SaveRuntimeText() failed
    i = indexObjStart;
    while (i < (int)indexObjEnd)
    {
        if (   pTokArray[i].token.tok == TokTag_BANG
            && pTokArray[i].token.tokClass == tokTag)
        {
            // found the comment, now make sure that this is the comment with DTCRUNTIME
            if (   (pwOld[pTokArray[i+1].token.ibTokMin] == '-')
                && (pwOld[pTokArray[i+1].token.ibTokMin+1] == '-')
                && (0 == _wcsnicmp(rgCommentRT[0], &pwOld[pTokArray[i+1].token.ibTokMin+2], wcslen(rgCommentRT[0])))
                && (pwOld[pTokArray[i+1].token.ibTokMac-1] == '-')
                && (pwOld[pTokArray[i+1].token.ibTokMac-2] == '-')
                && (0 == _wcsnicmp(rgCommentRT[0], &pwOld[pTokArray[i+1].token.ibTokMac-2-wcslen(rgCommentRT[0])], wcslen(rgCommentRT[0])))
                )
            {
                ichRT = pTokArray[i+1].token.ibTokMin + wcslen(rgCommentRT[1]);
                cchRT = pTokArray[i+1].token.ibTokMac-pTokArray[i+1].token.ibTokMin - wcslen(rgCommentRT[2]) - wcslen(rgCommentRT[1]);
                indexRTComment = i;
                ichRTComment = pTokArray[i].token.ibTokMin;
                cchRTComment = pTokArray[i+2].token.ibTokMac-pTokArray[i].token.ibTokMin;
                break;
            }
        }
        i++;
    }

    iArray = indexObjEnd; // set it for the next Object

    // now, replace the OBJECT - Insert startspan and endspan stuff
    pHTMLDoc = NULL;
    hr = ptep->m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void **) &pHTMLDoc);
    if (hr != S_OK)
        goto LErrorRet;

    pHTMLColl = NULL;
    hr = pHTMLDoc->get_applets(&pHTMLColl);
    if (hr != S_OK)
    {
        goto LErrorRet;
    }

    pHTMLColl->get_length(&iControlMac);
    ASSERT(*piObj <= iControlMac);

    hr = S_FALSE;
    VariantInit(&vaName);
    VariantInit(&vaIndex);

    V_VT(&vaName) = VT_ERROR;
    V_ERROR(&vaName) = DISP_E_PARAMNOTFOUND;

    V_VT(&vaIndex) = VT_I4;
    V_I4(&vaIndex) = *piObj;
    *piObj += 1; // get it ready for the next control
    ptep->m_iControl = *piObj; // get it ready for the next control

    pDispControl = NULL;
    hr = pHTMLColl->item(vaIndex, vaName, &pDispControl);
    // Trident has a bug that if the object was nested inside <scripts> tags,
    // it returns S_OK with pDispControl as NULL. (See VID BUG 11303)
    if (hr != S_OK || pDispControl == NULL)
    {
        goto LErrorRet;
    }
    pActiveDesigner = NULL;
    hr = pDispControl->QueryInterface(IID_IActiveDesigner, (void **) &pActiveDesigner);
    if (hr != S_OK) // release pActiveDesigner
    {
        pActiveDesigner.Release();
        pDispControl.Release();
    }

    if (hr == S_OK) // Found the control!
    {        
        // This is a DTC
        IStream *pStm;
        HGLOBAL hg = NULL;
        INT cbMin = 0x8fff; // init & increment size of hgDTC
        INT cchCurDTC = 0;

#ifdef DEBUG
        CComPtr<IHTMLElement> pHTMLElem = NULL;

        hr = pDispControl->QueryInterface(IID_IHTMLElement, (void **) &pHTMLElem);
        if (hr != S_OK)
        {   
            goto LErrorRet;
        }

        // get the index for TokAttrib_ID from pTokArray
        // from here get the actual value for future comparison

        i = indexObjStart;
        // actually, this has to exist before TokElem_PARAM,
        // but this takes care of boundary cases
        while (i < (int)indexObjEnd)
        {
            if (pTokArray[i].token.tok == TokAttrib_CLASSID)
            {
                ASSERT(pTokArray[i].token.tokClass == tokAttr);
                break;
            }
            i++;
        }

        if (i < (int)indexObjEnd -1) // found TokAttrib_CLASSID
        {
            CComPtr<IPersistPropertyBag> pPersistPropBag;
            INT ichClsid;

            // make sure that the next one is tokOpEqual
            ASSERT(pTokArray[i+1].token.tokClass == tokOp);
            // make sure that the next one is the id and get that value
            //ASSERT(pTokArray[i].token.tok == );

            // Is there any other way to skip "clsid:" string that appears before the clsid?
            ichClsid = pTokArray[i+2].token.ibTokMin + strlen("clsid:");

            pPersistPropBag = NULL;
            hr = pDispControl->QueryInterface(IID_IPersistPropertyBag, (void **) &pPersistPropBag);
            if (hr == S_OK)
            {
                CLSID clsid;
                LPOLESTR szClsid;

                if (S_OK == pPersistPropBag->GetClassID(&clsid))
                {
                    if (S_OK == StringFromCLSID(clsid, &szClsid))
                        ASSERT(0 == _wcsnicmp(szClsid+1/* for {*/, &pwOld[ichClsid], sizeof(CLSID)));
                    ::CoTaskMemFree(szClsid);
                }
            }

        }
#endif // DEBUG

        ASSERT(*piObj <= iControlMac);
        // Do the Blts. 
        // 0. Allocate a local buffer
        hgDTC = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, ((cchObjEnd-cchObjStart)+cbMin)*sizeof(WCHAR)); // stack
        if (hgDTC == NULL)
            goto LErrorRet;
        pDTC= (WCHAR *) GlobalLock(hgDTC);
        ASSERT(pDTC != NULL);

        if (!(dwFlags & dwFilterDTCsWithoutMetaTags))
        {
            INT indexTokOp = -1;
            INT indexClsId = -1;

            // 1. Insert MetaData1 tag from rgDTCTags[0]
            wcscpy(&pDTC[cchCurDTC], rgDTCTags[0]);
            cchCurDTC += wcslen(rgDTCTags[0]);

            // 2. copy the <OBJECT> </OBJECT> from pwOld

            // Split the copy into 3 parts...
            // part 1 - copy from cchObjStart till = following the ClassId
            // part 2 - add a quote around the classId value (if needed) and copy the value
            // part 3 - copy rest of the object till cchObjEnd

            // VID98-BUG 5649 - Fix DaVinci bug by adding quote around classId's.
            // NOTE - we want to make sure that the classId value is inside quotes,
            // if there is one for this <OBJECT> tag,

            // we actually don't need to go this far, but thats the indexObjEnd is the 
            // only index know
            for (i = indexObjStart; i < (INT)indexObjEnd; i++)
            {
                if (   pTokArray[i].token.tok == TokAttrib_CLASSID
                    && pTokArray[i].token.tokClass == tokAttr)
                {
                    indexClsId = i;
                }
                if (   pwOld[pTokArray[i].token.ibTokMin] == '='
                    && pTokArray[i].token.tokClass == tokOp
                    && indexTokOp == -1)
                {
                    indexTokOp = i;
                }
            } // for ()
            // following are simply error cases, we won't run into them unless we have
            // incomplete HTML
            if (   indexClsId == -1 /* we didn't have clsid for this <OBJECT> */
                || indexTokOp == -1 /* rare but possible error case of incomplete HTML */
                )
            {
                if (ichRTComment == -1)
                {
                    wcsncpy(&pDTC[cchCurDTC], &pwOld[cchObjStart], cchObjEnd - cchObjStart);
                    cchCurDTC += cchObjEnd - cchObjStart;
                }
                else
                {
                    wcsncpy(&pDTC[cchCurDTC], &pwOld[cchObjStart], ichRTComment - cchObjStart);
                    cchCurDTC += ichRTComment - cchObjStart;

                    wcsncpy(&pDTC[cchCurDTC], &pwOld[ichRTComment+cchRTComment], cchObjEnd - (ichRTComment+cchRTComment));
                    cchCurDTC += cchObjEnd - (ichRTComment+cchRTComment);
                }
            }
            else
            {
                LPCWSTR szClsId[] =
                {
                    L"clsid:",
                };
    
                ASSERT(indexTokOp != -1);
                // copy till '=' of 'classid=clsid:XXXX'
                memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                        (BYTE *)(&pwOld[cchObjStart]),
                        (pTokArray[indexTokOp].token.ibTokMac-cchObjStart)*sizeof(WCHAR));
                cchCurDTC += (pTokArray[indexTokOp].token.ibTokMac-cchObjStart);

                if (0 == _wcsnicmp(szClsId[0], &pwOld[pTokArray[indexTokOp+1].token.ibTokMin], wcslen(szClsId[0])))
                {
                    ASSERT(pwOld[pTokArray[indexTokOp+1].token.ibTokMin] != '"');
                    pDTC[cchCurDTC] = '"';
                    cchCurDTC++;

                    memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                            (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMin]),
                            (pTokArray[indexTokOp+1].token.ibTokMac - pTokArray[indexTokOp+1].token.ibTokMin)*sizeof(WCHAR));
                    cchCurDTC += pTokArray[indexTokOp+1].token.ibTokMac - pTokArray[indexTokOp+1].token.ibTokMin;

                    pDTC[cchCurDTC] = '"';
                    cchCurDTC++;

                    if (ichRTComment == -1)
                    {
                        ASSERT((int)(cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMac) >= 0);
                        memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMac]),
                                (cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMac)*sizeof(WCHAR));
                        cchCurDTC += (cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMac);
                    }
                    else
                    {
                        if (indexRTComment == -1)
                        {
                            ASSERT((int)(ichRTComment-pTokArray[indexTokOp+1].token.ibTokMac) >= 0);
                            memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                    (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMac]),
                                    (ichRTComment-pTokArray[indexTokOp+1].token.ibTokMac)*sizeof(WCHAR));
                            cchCurDTC += (ichRTComment-pTokArray[indexTokOp+1].token.ibTokMac);

                            ASSERT((int)(cchObjEnd-(ichRTComment+cchRTComment)) >= 0);
                            memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                    (BYTE *)(&pwOld[ichRTComment+cchRTComment]),
                                    (cchObjEnd-(ichRTComment+cchRTComment))*sizeof(WCHAR));
                            cchCurDTC += (cchObjEnd-(ichRTComment+cchRTComment));
                        }
                        else
                        {
                            // format and copy from indexTokOp+2 till indexRTComment
                            for (i = indexTokOp+2; i < indexRTComment; i++)
                            {
                                memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                        (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                                cchCurDTC += pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin;
                                if (pTokArray[i].token.tok == TokTag_CLOSE && pTokArray[i].token.tokClass == tokTag)
                                {
                                    // Don't bother checking for existing EOLs...
                                    // add \r\n
                                    pDTC[cchCurDTC++] = '\r';
                                    pDTC[cchCurDTC++] = '\n';
                                    pDTC[cchCurDTC++] = '\t';
                                }

                            }

                            // copy from end of the comment till </object>
                            ASSERT((int)(cchObjEnd-(ichRTComment+cchRTComment)) >= 0);
                            memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                    (BYTE *)(&pwOld[ichRTComment+cchRTComment]),
                                    (cchObjEnd-(ichRTComment+cchRTComment))*sizeof(WCHAR));
                            cchCurDTC += (cchObjEnd-(ichRTComment+cchRTComment));
                        }
                    }
                }
                else
                {
                    if (ichRTComment == -1)
                    {
                        ASSERT((int)(cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMin) >= 0);
                        memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMin]),
                                (cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMin)*sizeof(WCHAR));
                        cchCurDTC += (cchObjEnd-pTokArray[indexTokOp+1].token.ibTokMin);
                    }
                    else
                    {
                        ASSERT((int)(ichRTComment-pTokArray[indexTokOp+1].token.ibTokMin) >= 0);
                        memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                (BYTE *)(&pwOld[pTokArray[indexTokOp+1].token.ibTokMin]),
                                (ichRTComment-pTokArray[indexTokOp+1].token.ibTokMin)*sizeof(WCHAR));
                        cchCurDTC += (ichRTComment-pTokArray[indexTokOp+1].token.ibTokMin);

                        ASSERT((int)(cchObjEnd-(ichRTComment+cchRTComment)) >= 0);
                        memcpy( (BYTE *)(&pDTC[cchCurDTC]),
                                (BYTE *)(&pwOld[ichRTComment+cchRTComment]),
                                (cchObjEnd-(ichRTComment+cchRTComment))*sizeof(WCHAR));
                        cchCurDTC += (cchObjEnd-(ichRTComment+cchRTComment));
                    }
                }
            }

            // 3. Insert MetaData2 tag from rgDTCtags[1]
            wcscpy(&pDTC[cchCurDTC], rgDTCTags[1]);
            cchCurDTC += wcslen(rgDTCTags[1]);
        }

        // 4. Add runtime text (copy code from old stuff)
        if ((hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm)) != S_OK)
            goto LErrorRet;
    
        ASSERT(pActiveDesigner != NULL);
        if ((hr = pActiveDesigner->SaveRuntimeState(IID_IPersistTextStream, IID_IStream, pStm)) == S_OK)
        {
            if ((hr = GetHGlobalFromStream(pStm, &hg)) != S_OK)
                goto LErrorRet;

            STATSTG stat;
            if ((hr = pStm->Stat(&stat, STATFLAG_NONAME)) != S_OK)
                goto LErrorRet;
        
            int cch = stat.cbSize.LowPart / sizeof(WCHAR);

            // before we put stuff from hg into pDTC, 
            // lets make sure that its big enough
            cbNeed = (cchCurDTC+cch)*sizeof(WCHAR)+cbBufPadding;
            if (GlobalSize(hgDTC) < cbNeed)
            {
                hr = ReallocBuffer( &hgDTC, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT);
                if (hr == E_OUTOFMEMORY)
                    goto LErrorRet;
                ASSERT(hgDTC != NULL);
                pDTC = (WCHAR *)GlobalLock(hgDTC);
            }

            wcsncpy(&pDTC[cchCurDTC], (LPCWSTR) GlobalLock(hg), cch);
            cchCurDTC += cch;
            
            // HACK - BUG fix 9844
            // Some DTCs add a NULL at the end of their runtime text
            if (pDTC[cchCurDTC-1] == '\0')
                cchCurDTC--;

            GlobalUnlock(hg);
        }
        else if (hr == S_FALSE)
        {
            // copy the commented runtime text into pDTC & incremtn cchCurDTC
            if (ichRTComment != -1 && ichRT != -1) // we have the runtime text
            {
                ASSERT(cchRT >= 0);
                cbNeed = (cchCurDTC+cchRT)*sizeof(WCHAR)+cbBufPadding;
                if (GlobalSize(hgDTC) < cbNeed)
                {
                    hr = ReallocBuffer( &hgDTC, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT);
                    if (hr == E_OUTOFMEMORY)
                        goto LErrorRet;
                    ASSERT(hgDTC != NULL);
                    pDTC = (WCHAR *)GlobalLock(hgDTC);
                }
                wcsncpy(&pDTC[cchCurDTC], &pwOld[ichRT], cchRT);
                cchCurDTC += cchRT;
            }
        }

        if (!(dwFlags & dwFilterDTCsWithoutMetaTags))
        {
            // 5. Insert MetaData2 tag from rgDTCtags[2]
            wcscpy(&pDTC[cchCurDTC], rgDTCTags[2]);
            cchCurDTC += wcslen(rgDTCTags[2]);
        }
        
        // now insert/replace contents of pDTC into pwNew
        // we are insert/replacing (cchObjEnd-cchObjStart) wchars
        // by cchCurDTC wchars, so realloc pwNew first

        
        
        /* Reallocate pwNew IF NEEDED here use cache value for GlobalSize(*phgNew) and don't forget to update it too */
        cbNeed = (ichNewCur+(cchObjStart-ichBeginCopy)+(cchCurDTC))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LErrorRet;

        
        // cchObjStart/End are actually ich's
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew

        // copy till begining of the <OBJECT>
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (cchObjStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += cchObjStart-ichBeginCopy;
        ichBeginCopy = cchObjEnd; // set it for next object

        CComPtr<IPersistPropertyBag> pPersistPropBag = NULL;

        hr = pDispControl->QueryInterface(IID_IPersistPropertyBag, (void **) &pPersistPropBag);
        if (hr == S_OK)
        {
            CLSID clsid;

            if (S_OK == pPersistPropBag->GetClassID(&clsid))
            {
                if (IsEqualCLSID(clsid, CLSID_PageTr))
                {
                    if (ptep->m_cchPTDTC != 0)
                    {
                        // Note that there is no need to realloc here since our buffer will already be bigger than we need it to be.
                        if (cchCurDTC != ptep->m_cchPTDTC)
                        {
                            memmove((BYTE *)(pwNew+ptep->m_ichPTDTC+cchCurDTC),
                                    (BYTE *)(pwNew+ptep->m_ichPTDTC+ptep->m_cchPTDTC),
                                    (ichNewCur-ptep->m_ichPTDTC-ptep->m_cchPTDTC)*sizeof(WCHAR));

                            ichNewCur += cchCurDTC-ptep->m_cchPTDTC;
                        }

                        memcpy( (BYTE *)(pwNew+ptep->m_ichPTDTC),
                                (BYTE *)(pDTC),
                                cchCurDTC*sizeof(WCHAR));
                
                        ptep->m_cchPTDTC = 0; 
                        ptep->m_ichBeginHeadTagIn = 0;  // reset, so that if we had multiple PTDTCs, 
                                                        //we won't try to stuff them inside HEAD
                        goto LSkipDTC;
                    }
                    else // this is the case where the PTDTC didn't exist before going to Trident
                    {
                        // we need to move this between <head> </head> tags if they exist
                        if (ptep->m_ichBeginHeadTagIn > 0) // we had HEAD tag in Source view
                        {
                            int ichInsertPTDTC = ptep->m_ichBeginHeadTagIn;

                            // insert the control immediately after the <HEAD> tag
                            //in pwNew look for '>' after ichInsertPTDTC
                            while (pwNew[ichInsertPTDTC] != '>')
                                ichInsertPTDTC++;
                            ichInsertPTDTC++; // skip '>'

                            ASSERT(ichInsertPTDTC < (INT)ichNewCur);
                            memmove((BYTE *)(pwNew+ichInsertPTDTC+cchCurDTC),
                                    (BYTE *)(pwNew+ichInsertPTDTC),
                                    (ichNewCur-ichInsertPTDTC)*sizeof(WCHAR));
                            ichNewCur += cchCurDTC;
                            memcpy( (BYTE *)(pwNew+ichInsertPTDTC),
                                    (BYTE *)(pDTC),
                                    cchCurDTC*sizeof(WCHAR));

                            ptep->m_ichBeginHeadTagIn = 0;
                            goto LSkipDTC;
                        }
                    }

                } // else if (IsEqualCLSID(clsid, CLSID_PageTr))
            } // if (S_OK == pPersistPropBag->GetClassID(&clsid))
        } // if (hr == S_OK)

        // copy the converted DTC
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(pDTC),
                cchCurDTC*sizeof(WCHAR));
        ichNewCur += cchCurDTC;

LSkipDTC:

        if (hgDTC != NULL)
            GlobalUnlockFreeNull(&hgDTC);

    } // if (hr == S_OK)
    else // this object was not a DTC
    {
        // we don't need to do the same for DTC's, but lets visit this in next release
        LPCWSTR rgComment[] =
        {
            L"ERRORPARAM",
            L"--ERRORPARAM ",
            L" ERRORPARAM--",
        };
        BOOL fFoundParam = FALSE;
        INT iParam = -1;
        INT ichObjStartEnd, iCommentStart, iCommentEnd;
        UINT iObjTagEnd;
        INT cComment, iFirstComment, iComment;

        iCommentStart = iCommentEnd = iComment = -1;
        // loop through indexObjStart till indexObjEnd to see if we have any <PARAM> tags
        for (i = indexObjStart; i < (INT)indexObjEnd; i++)
        {
            if (   pTokArray[i].token.tok == TokElem_PARAM
                && pTokArray[i].token.tokClass == tokElem)
            {
                fFoundParam = TRUE;
                iParam = i;
                break;
            }
        } // for ()
        if (fFoundParam)
            ASSERT(iParam != -1);

        // We need to copy till end of <OBJECT...> irrespective of if we find <PARAM>s or not.
        // copy till end of <OBJECT...> tag and set ichBeginCopy to be after the commented <PARAM> tags
        // calculate ichObjStartEnd
        iObjTagEnd = indexObjStart;
        while (iObjTagEnd < indexObjEnd)
        {
            if (   pTokArray[iObjTagEnd].token.tok == TokTag_CLOSE
                && pTokArray[iObjTagEnd].token.tokClass == tokTag)
                break;
            iObjTagEnd++;
        }
        if (iObjTagEnd >= indexObjEnd) // error case
            goto LErrorRet;
        ichObjStartEnd = pTokArray[iObjTagEnd].token.ibTokMac;
        
        cbNeed = (ichNewCur+ichObjStartEnd-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        ASSERT((INT)(ichObjStartEnd-ichBeginCopy) >= 0);
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichObjStartEnd-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichObjStartEnd-ichBeginCopy);
        ichBeginCopy = ichObjStartEnd;
        iArray = iObjTagEnd + 1;

        // generally, we don't expect Trident to move the comment from where it was put
        // but if it does, be prepared.
        // NOTE - Lets not worry about the following case for this release becasue prior assumption
        // Also, should we look for more comments if the first one wasn't the magic one?
        // Would Trident move it form where it originally inserted? 
        
        // ASSUMPTION - that Trident doesn't muck with the contents inside a comment block
        // if rgComment[0] matches and rgComment[1] does not, Trident may have mucked with the 
        // comment contents. This invalidates our original assumption.
        // NOTE - We can get away with ignoring this case for thie release
        i = iObjTagEnd;
        cComment = 0;
        iFirstComment = -1;
        while ((UINT)i < indexObjEnd)
        {
            if (   pTokArray[i].token.tok == TokTag_BANG
                && pTokArray[i].token.tokClass == tokTag)
            {
                cComment++;
                if (iFirstComment == -1)
                    iFirstComment = i;
            }
            i++;
        }
        if (cComment == 0) // error, didn't find the comment
            goto LErrorRet;

        // early return cases
        // 1. see if these are comments or not.They could be anything that start with '<!'
        // e.g. <!DOCTYPE
        i = iFirstComment;
        while (i < (INT)indexObjEnd)
        {
            if (   (i < (INT)ptep->m_cMaxToken)
                && (pwOld[pTokArray[i].token.ibTokMin] == '-')
                && (pwOld[pTokArray[i].token.ibTokMin+1] == '-')
                && (0 == _wcsnicmp(rgComment[0], &pwOld[pTokArray[i].token.ibTokMin+2], wcslen(rgComment[0])))
                )
            {
                ASSERT(i-1 >= 0);
                iCommentStart = i-1; // this is a comment we are interested in
            }
            else
                goto LNextComment;

            // The first part matched, look at the end of the comment
            if (   (pwOld[pTokArray[i].token.ibTokMac-1] == '-')
                && (pwOld[pTokArray[i].token.ibTokMac-2] == '-')
                && (0 == _wcsnicmp( rgComment[0], 
                                    &pwOld[pTokArray[i].token.ibTokMac-(wcslen(rgComment[0])+2)], 
                                    wcslen(rgComment[0])
                                    )
                                )
                )
            {
                iCommentEnd = i + 1;
                iComment = i;
                ASSERT(iCommentEnd < (INT)ptep->m_cMaxToken);
                break;
            }
            else // error case (our assumption was not valid). ignore and return with iArraySav+1
                goto LNextComment;
LNextComment:
            i++;
        } // while ()


        // HANDLE THIS CASE - WHAT IF WE DIDN'T FIND A SINGLE COMMENT????


        if (fFoundParam)
        {
            if (iCommentStart != -1 && iCommentEnd != -1)
            {
                cbNeed = (ichNewCur+(pTokArray[iCommentEnd].token.ibTokMac-pTokArray[iObjTagEnd].token.ibTokMin)+(iCommentStart-iObjTagEnd)*3/*for eol,tab*/+(pTokArray[iObjTagEnd].token.ibTokMac-ichBeginCopy))*sizeof(WCHAR)+cbBufPadding;
                if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                    goto LErrorRet;

                // we need to format the param tags because trident puts them on one line
                // copy till the first param tag
                memcpy( (BYTE *)(&pwNew[ichNewCur]),
                        (BYTE *)(&pwOld[ichBeginCopy]),
                        (pTokArray[iObjTagEnd].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
                ichNewCur += (pTokArray[iObjTagEnd].token.ibTokMac-ichBeginCopy);
                // From here, copy each param tag and insert an EOL after each. 
                // Stop at iCommentStart
                for (i = iObjTagEnd+1; i < iCommentStart; i++)
                {
                    // if its TokTag_START, insert EOL
                    if (   pTokArray[i].token.tok == TokTag_START
                        && pTokArray[i].token.tokClass == tokTag
                        )
                    {
                        pwNew[ichNewCur] = '\r';
                        ichNewCur++;
                        pwNew[ichNewCur] = '\n';
                        ichNewCur++;
                        pwNew[ichNewCur] = '\t'; // replace this with appropriate alignment
                        ichNewCur++;
                    }
                    // copy the tag
                    memcpy( (BYTE *)(&pwNew[ichNewCur]),
                            (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                } // for ()

                // from here, look for extra spaces/tabs/eols that trident has accumulated
                // at the end of the PARAM tags and remove them.
                for (i = iCommentEnd+1; i <= (int)indexObjEnd; i++)
                {
                    if (   (pTokArray[i].token.tokClass == tokIDENTIFIER && pTokArray[i].token.tok == 0)
                        || (   pTokArray[i].token.tokClass == tokOp 
                            && pTokArray[i].token.tok == 0 
                            && pwOld[pTokArray[i].token.ibTokMin] == 0x0a
                            && pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin == 1
                            )
                        )
                    {
                        int iChar;
                        BOOL fCopy = FALSE;

                        // see if all the characters in this token are spaces/tabs/eols
                        for (iChar = pTokArray[i].token.ibTokMin; iChar < (int)pTokArray[i].token.ibTokMac; iChar++)
                        {
                            if (   pwOld[iChar] != ' '
                                && pwOld[iChar] != '\r'
                                && pwOld[iChar] != '\n'
                                && pwOld[iChar] != '\t'
                                )
                            {
                                // we need to copy this token
                                fCopy = TRUE;
                                break;
                            }
                        } // for (iChar)
                        if (fCopy)
                        {
                            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                                    (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                                    (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                            ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                        }
                    }
                    else
                    {
                        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                                (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                        if (pTokArray[i].token.tok == TokTag_CLOSE && pTokArray[i].token.tokClass == tokTag)
                        {
                            pwNew[ichNewCur++] = '\r';
                            pwNew[ichNewCur++] = '\n';
                        }
                    }
                } // for ()
                ichBeginCopy = pTokArray[indexObjEnd].token.ibTokMac;
                iArray = indexObjEnd + 1;
            }
        }
        else
        {
            if (iCommentStart != -1 && iCommentEnd != -1 && iComment != -1)
            {
                INT cchComment1, cchComment2;
                INT ichCommentStart, ichParamStart, cchCommentToken;

                // We didn't have any <PARAM> for this object. It means one of the following
                // (a)Trident deleted those or (b)it didn't have any before going to Trident
                // If Trident deleted those, we should have them in form of a comment.
                // If we didn't have those  before doing to Trident, we won't have that magic comment
                // BUT by the time we come here, we are sure that we have found the magic comment

                // ASSUME that trident won't move the comment from its original place
                // NOTE - In this release, we don't need to handle the case of Trident moving the comment location
                // which was originally placed just after <OBJECT ...>

                // remove the comment tokens surrounding the <PARAM>s.
                cchComment1 = wcslen(rgComment[1]);
                cchComment2 = wcslen(rgComment[2]);
                // remove cchComment1 chars from begining of pwOld[pTokArray[i+1].token.ibTokMin
                // remove cchComment2 chars from the end of pwOld[pTokArray[i+1].token.ibTokMac
                // and copy the rest into pwNew

                ichCommentStart = pTokArray[iCommentStart].token.ibTokMin;
                ichParamStart = pTokArray[iCommentStart+1].token.ibTokMin+cchComment1;
                ASSERT((INT)(ichCommentStart-ichBeginCopy) >= 0);
                cbNeed = (ichNewCur+ichCommentStart-ichBeginCopy+pTokArray[iComment].token.ibTokMac-pTokArray[iComment].token.ibTokMin)*sizeof(WCHAR)+cbBufPadding;
                if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                    goto LRet;
                // copy till begining of the comment
                memcpy( (BYTE *)(pwNew+ichNewCur),
                        (BYTE *)(pwOld+ichBeginCopy),
                        (ichCommentStart-ichBeginCopy)*sizeof(WCHAR));
                ichNewCur += ichCommentStart-ichBeginCopy;
                ichBeginCopy = pTokArray[iCommentEnd].token.ibTokMac;

                cchCommentToken = pTokArray[iComment].token.ibTokMac-pTokArray[iComment].token.ibTokMin;
                ASSERT((INT)(cchCommentToken-cchComment1-cchComment2) >= 0);
                memcpy( (BYTE *)(&pwNew[ichNewCur]),
                        (BYTE *)&(pwOld[ichParamStart]),
                        (cchCommentToken-cchComment1-cchComment2)*sizeof(WCHAR));
                ichNewCur += pTokArray[iComment].token.ibTokMac-pTokArray[iComment].token.ibTokMin-cchComment1-cchComment2;
                iArray = iCommentEnd + 1;
            }
        } // if (!fFoundParam)
    } // else of if (hr == S_OK)

LErrorRet:
    //free hgDTC if its not NULL
    if (hgDTC != NULL)
        GlobalUnlockFreeNull(&hgDTC);

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

//LRetOnly:   
    return;

} /* fnRestoreDTC() */

void
CTriEditParse::fnSaveDTC(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
          INT *pcDTC, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    // DTC case -
    // if we get STARTSPAN, search backwords (carefully) for tokTag_BANG in pTokArray
    // once we find that, remember the ibTokMin for DTC replacement
    // once we get a ENDSPAN tagID, wait for upcoming toktag_CLOSE which will end DTC
    // remember ibTokMac at that position. This is the DTC range.
    // In pTokArray, start at METADATA and look for matching OBJECT & /OBJECT tokIDs
    // Blt the OBJECT block over to ibTokMin and NULL remaining area in DEBUG build

    UINT indexDTCStart, indexDTCEnd, cchDTCStart, cchDTCEnd;
    UINT indexObjectStart, indexObjectEnd, cchObjectStart, cchObjectEnd;
    BOOL fFindFirstObj;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    INT cDTC = *pcDTC;
    INT i;
    INT ichClsid = 0; // init
    LPOLESTR szClsid;
    UINT iStartSpan;
    LPWSTR pwNew = *ppwNew;
    LPCWSTR rgCommentRT[] =
    {
        L" <!--DTCRUNTIME ",
        L" DTCRUNTIME--> ",
        L"-->",
    };
    LPCWSTR szDesignerControl[] =
    {
        L"\"DesignerControl\"",
        L"DesignerControl",
    };
    BOOL fDesignerControlFound;
    UINT iArraySav = iArray;

    UINT ichObjectEndBegin, indexRTMac, indexRTStart;
    BOOL fFirstDash;
    UINT cbNeed;

    indexDTCStart = indexDTCEnd = cchDTCStart = cchDTCEnd = 0;
    indexObjectStart = indexObjectEnd = cchObjectStart = cchObjectEnd = 0;

    ASSERT(cDTC >= 0); // make sure that this was initilized
    if (cDTC == 0)
        goto LRetOnly;
    while (cDTC > 0)
    {
        // start at iArray of pTokArray and look for STARTSPAN
        //while (pTokArray[iArray].token.tok != ft.tokBegin2)
        //  iArray++;
        ASSERT(iArray < ptep->m_cMaxToken);
        
        if (pTokArray[iArray].token.tok != TokAttrib_STARTSPAN)
            goto LRet; // something is wrong

        iStartSpan = iArray;
        ASSERT(pTokArray[iArray].token.tok == TokAttrib_STARTSPAN);
        ASSERT(pTokArray[iArray].token.tokClass == tokAttr);
        i = iArray; // the position at which we found ft.tokBegin2
        fDesignerControlFound = FALSE;
        while (i >= 0)
        {
            // do we need to do anything else here?
            if (pTokArray[i].token.tok == ft.tokBegin)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_BANG);
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                break;
            }
            if (   (   pTokArray[i].token.tokClass == tokString
                    && 0 == _wcsnicmp(szDesignerControl[0], &pwOld[pTokArray[i].token.ibTokMin], wcslen(szDesignerControl[0]))
                    )
                || (   pTokArray[i].token.tokClass == tokValue
                    && 0 == _wcsnicmp(szDesignerControl[1], &pwOld[pTokArray[i].token.ibTokMin], wcslen(szDesignerControl[1]))
                    )
                )
            {
                fDesignerControlFound = TRUE;
            }

            i--;
        }
        if (i >= 0) // found TokTag_BANG token
        {
            cchDTCStart = pTokArray[i].token.ibTokMin;
            indexDTCStart = i;
        }
        else // error case 
        {
            // we found STARTSPAN, but didn't find <! of <!--METADATA
            // we can't process this DTC, so quit
            goto LRet;
        }
        if (!fDesignerControlFound)
        {
            // we didn't find DesignerControl for the DTC, which means this is not the DTC we care about
            // we can't process this DTC, so quit
            iArray = iArraySav + 1;
            goto LRet;
        }

        // now, look for ft.tokEnd2 i.e. TokAttrib_ENDSPAN
        if (   pTokArray[iStartSpan].iNextprev != -1 /* validate */
            && pTokArray[pTokArray[iStartSpan].iNextprev].token.tok == ft.tokEnd2)
        {
            ASSERT(pTokArray[pTokArray[iStartSpan].iNextprev].token.tokClass == tokAttr);
            i = iStartSpan;
            while (i < (int)ptep->m_cMaxToken && pTokArray[i].token.tok != TokElem_OBJECT)
                i++;
            if (i < (int)ptep->m_cMaxToken) // found the first <OBJECT> tag
                indexObjectStart = i;
            i = pTokArray[iStartSpan].iNextprev;
        }
        else // actually, we should have found ft.tokEnd2 in the if case, but if stack unwinding didn't happen correctly...
        {
            // on the way, look for 1st <OBJECT> tag
            fFindFirstObj = TRUE;
            i = iArray;
            while (pTokArray[i].token.tok != ft.tokEnd2)
            {
                if (fFindFirstObj && pTokArray[i].token.tok == TokElem_OBJECT)
                {
                    ASSERT(pTokArray[i].token.tokClass == tokElem);
                    indexObjectStart = i;
                    fFindFirstObj = FALSE;
                }
                i++;
                if (i >= (int)ptep->m_cMaxToken)
                    break;
            }
            if (i >= (int)ptep->m_cMaxToken)
            {
                // we didn't find ENDSPAN before hitting ptep->m_cMaxToken
                // we can't process this DTC, so quit
                goto LRet;
            }
        }
        ASSERT(pTokArray[i].token.tok == TokAttrib_ENDSPAN);
        ASSERT(pTokArray[i].token.tokClass == tokAttr);

        // from this i'th  position, look backwards to find '<!' of '<!--METADATA ...endspan...'
        indexRTMac = i;
        while (indexRTMac > indexObjectStart)
        {
            if (   pTokArray[indexRTMac].token.tok == TokTag_BANG
                && pTokArray[indexRTMac].token.tokClass == tokTag
                )
            {
                break;
            }
            indexRTMac--;
        }
        if (indexRTMac <= indexObjectStart) // error case
            goto LRet;
        
        // save this ith position to find last </OBJECT> tag
        indexObjectEnd = indexObjectStart;
        // from this ith poistion, look for ft.tokEnd
        while (i < (int)ptep->m_cMaxToken)
        {
            if (pTokArray[i].token.tok == ft.tokEnd)
            {
                ASSERT(pTokArray[i].token.tok == TokTag_CLOSE);
                ASSERT(pTokArray[i].token.tokClass == tokTag);
                break;
            }
            i++;
        }
        if (i < (int)ptep->m_cMaxToken) // found TokTag_CLOSE token
        {
            cchDTCEnd = pTokArray[i].token.ibTokMac;
            indexDTCEnd = i;
        }
        else
        {
            // we didn't find TokTag_CLOSE after ENDSPAN,
            // we can't process this DTC, so quit
            goto LRet;
        }
        // look forward from indexObjectEnd for the </OBJECT> tag
        while (indexObjectEnd < ptep->m_cMaxToken)
        {
            if (   pTokArray[indexObjectEnd].token.tok == TokElem_OBJECT
                && pTokArray[indexObjectEnd].token.tokClass == tokElem
                && pTokArray[indexObjectEnd-1].token.tok == TokTag_END /* </ */
                )
                break;
            indexObjectEnd++;
        }
        if (indexObjectEnd >= ptep->m_cMaxToken) // didn't find </OBJECT>, error case
        {
            goto LRet;
        }
        if (indexObjectEnd > indexObjectStart) // </OBJECT> found
        {
            // get ibTokMin of the previous < tag for indexObjectStart
            i = indexObjectStart;
            // generally, the previous tag should be the one we want, 
            // but this covers the boundary cases
            while (i > (int)indexDTCStart) 
            {
                if (pTokArray[i].token.tok == TokTag_START)
                {
                    ASSERT(pTokArray[i].token.tokClass == tokTag);
                    break;
                }
                i--;
            }
            //ASSERT(i > (int)indexDTCStart+1); // atleast
            cchObjectStart = pTokArray[i].token.ibTokMin;
            // get ibTokMac of the next > tag for indexObjectEnd
            i = indexObjectEnd;
            // generally, the next tag should be the one we want, 
            // but this covers the boundary cases
            while (i < (int)indexDTCEnd)
            {
                if (pTokArray[i].token.tok == TokTag_CLOSE)
                {
                    ASSERT(pTokArray[i].token.tokClass == tokTag);
                    break;
                }
                i++;
            }
            ASSERT(i < (int)indexDTCEnd -1); // atleast
            cchObjectEnd = pTokArray[i].token.ibTokMac; // do we need -1 here?
        }
        else
            goto LRet;

        // from indexObjectEnd look backwards to get tokTag_END
        indexRTStart = i+1;
        i = indexObjectEnd;
        while (i > (int)indexObjectStart) // we don't have to go this far
        {
            if (   pTokArray[i].token.tok == TokTag_END
                && pTokArray[i].token.tokClass == tokTag
                )
            {
                break;
            }
            i--;
        }
        if (i <= (int)indexObjectStart) // error case, do we care?
            goto LRet;
        ichObjectEndBegin = pTokArray[i].token.ibTokMin;

        iArray = indexDTCEnd; // set it for next DTC entry
        
        // now Replace the DTC

        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to begining of DTC
        if ((int)(cchDTCStart-ichBeginCopy) >= 0)
        {
            cbNeed = (ichNewCur+cchDTCStart-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
            if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                goto LSkipCopy;
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichBeginCopy]),
                    (cchDTCStart-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (cchDTCStart-ichBeginCopy);
            ichBeginCopy = cchDTCEnd; // make it ready for next copy
        }

        i = indexObjectStart;

        while (i < (int)indexObjectEnd)
        {
            if (pTokArray[i].token.tok == TokAttrib_CLASSID)
            {
                ASSERT(pTokArray[i].token.tokClass == tokAttr);
                break;
            }
            i++;
        }

        if (i < (int)indexObjectEnd -1) // found TokAttrib_CLASSID
        {
            // make sure that the next one is tokOpEqual
            ASSERT(pTokArray[i+1].token.tokClass == tokOp);
            // make sure that the next one is the id and get that value
            //ASSERT(pTokArray[i].token.tok == );

            // Is there any other way to skip "clsid:" string that appears before the clsid?
            ichClsid = pTokArray[i+2].token.ibTokMin + strlen("clsid:");
            // This is a HACK to fix DaVinci's bug, where they can't handle non-quoted
            // classId
            if (pwOld[pTokArray[i+2].token.ibTokMin] == '"')
                ichClsid++;
        }

        if (ptep->m_fInHdrIn)
        {
            if (       (S_OK == StringFromCLSID(CLSID_PageTr, &szClsid))
                        && (0 == _wcsnicmp(szClsid+1/* for {*/, &pwOld[ichClsid], sizeof(CLSID)))
                        )
            {
                // copy the object part of the DTC into m_pPTDTC
                if (ptep->m_pPTDTC != NULL) // means that we have more than one PTDTC on the page
                    goto LMultPTDTC;

                ptep->m_hgPTDTC = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, (cchObjectEnd-cchObjectStart)*sizeof(WCHAR));
                // if the allocation failed, just don't copy into ptep->m_hgPTDTC
                if (ptep->m_hgPTDTC != NULL)
                {
                    ptep->m_pPTDTC = (WORD *) GlobalLock(ptep->m_hgPTDTC);
                    ASSERT(ptep->m_pPTDTC != NULL);
                    memcpy( (BYTE *)(ptep->m_pPTDTC),
                            (BYTE *)(&pwOld[cchObjectStart]),
                            (cchObjectEnd-cchObjectStart)*sizeof(WCHAR));
                    ptep->m_cchPTDTCObj = cchObjectEnd-cchObjectStart;
                    ptep->m_ichPTDTC = cchDTCStart; // with respect to the saved header
                    ptep->m_cchPTDTC = cchDTCEnd - cchDTCStart;

                    ::CoTaskMemFree(szClsid);
                    goto LSkipCopy;
                }
            }
LMultPTDTC:
            ::CoTaskMemFree(szClsid);
        }

        cbNeed = (ichNewCur+(cchObjectEnd-cchObjectStart)+(pTokArray[indexRTMac].token.ibTokMin-cchObjectEnd)+wcslen(rgCommentRT[0])+wcslen(rgCommentRT[1]))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LSkipCopy;
        // STEP 1 - copy till the begining of </OBJECT>
        ASSERT((int)(ichObjectEndBegin-cchObjectStart) >= 0);
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[cchObjectStart]),
                (ichObjectEndBegin-cchObjectStart)*sizeof(WCHAR));
        ichNewCur += ichObjectEndBegin-cchObjectStart;

        // STEP 2 - Insert the runtime text as a comment
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(rgCommentRT[0]),
                wcslen(rgCommentRT[0])*sizeof(WCHAR));
        ichNewCur += wcslen(rgCommentRT[0]);

        // we need to loop thr indexRTStart & indexRTMac and copy token by token
        // and modify TokTag_BANG on the way
        fFirstDash = TRUE;
        while (indexRTStart < indexRTMac)
        {
            // (4/14/98)
            // VID-BUG 17453 Fotm Manager DTC puts in 0x0d (\r) as an end of line instead of
            // putting 0x0d 0xa (\r\n) as an end of line. 
            // In this case, the token thats generated is tokIdentifier => "0x0d - - >" 
            // instead of getting 3 separate tokens for the normal case as "0x0d 0x0a"
            // & "- -" & ">".
            // Two ways to fix this problem ...
            // 1. Handle this would be in our tokenizer that treats "0x0d" as an
            //    end of line as well. But at this time, its not a safe change to do.
            // 2. In the below if condition, add the fact that we may have "0x0d" followed
            //    by "-->" for end of metadata comment.
            if (   fFirstDash
                && (   (0 == _wcsnicmp(rgCommentRT[2], &pwOld[pTokArray[indexRTStart].token.ibTokMin], wcslen(rgCommentRT[2])))
                    || (   (0 == _wcsnicmp(rgCommentRT[2], &pwOld[pTokArray[indexRTStart].token.ibTokMin+1], wcslen(rgCommentRT[2])))
                        && (pwOld[pTokArray[indexRTStart].token.ibTokMin] == 0x0d)
                        )
                    )
                )
            {
                indexRTStart++;
                fFirstDash = FALSE;
                continue;
            }

            memcpy( (BYTE *)&pwNew[ichNewCur],
                    (BYTE *)&pwOld[pTokArray[indexRTStart].token.ibTokMin],
                    (pTokArray[indexRTStart].token.ibTokMac-pTokArray[indexRTStart].token.ibTokMin)*sizeof(WCHAR)
                    );
            ichNewCur += pTokArray[indexRTStart].token.ibTokMac-pTokArray[indexRTStart].token.ibTokMin;
            if (   pTokArray[indexRTStart].token.tok == TokTag_BANG 
                && pTokArray[indexRTStart].token.tokClass == tokTag
                )
            {
                pwNew[ichNewCur-2] = '?';
            }
            if (   pTokArray[indexRTStart].token.tok == TokTag_CLOSE 
                && pTokArray[indexRTStart].token.tokClass == tokTag
                && pwOld[pTokArray[indexRTStart-1].token.ibTokMac-1] == '-'
                && pwOld[pTokArray[indexRTStart-1].token.ibTokMac-2] == '-'
                )
            {
                pwNew[ichNewCur-1] = '?';
            }
            // following is a hack for the NavBar DTC
            if (   pTokArray[indexRTStart].token.tok == TokElem_METADATA
                && pTokArray[indexRTStart].token.tokClass == tokElem
                )
            {
                pwNew[ichNewCur-1] = '?';
            }
            indexRTStart++;
        } // while ()

        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(rgCommentRT[1]),
                wcslen(rgCommentRT[1])*sizeof(WCHAR));
        ichNewCur += wcslen(rgCommentRT[1]);

        // STEP 3 - copy the rest of the object, i.e. the </OBJECT> tag
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichObjectEndBegin]),
                (cchObjectEnd-ichObjectEndBegin)*sizeof(WCHAR));
        ichNewCur += cchObjectEnd-ichObjectEndBegin;

LSkipCopy:
        cDTC--;
    } // while (cDTC > 0)

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
LRetOnly:
    return;
} /* fnSaveDTC() */

void
CTriEditParse::fnSaveHtmlTag(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    BOOL fFoundTag, fFoundHtmlBegin;
    INT i;
    UINT cchHtml, iHtmlBegin, iHtmlEnd;
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT cbNeed;

    // assert that iArray'th element in pTokArry is TokTag_HTML
    // Look for any non -1 tags before iArray
    // if we find any, it indicates that we have some stuff before <HTML> that trident doesn't like
    // in pwNew, move all ichNewCur bytes (copied so far) to make space for <HTML> at the begining
    // copy from pwOld <HTML location=> tag
    // adjust ichNewCur and ichBeginCopy

    // **** don't bother about maintaning info about <HTML> tag's location for Restore
    ASSERT(pTokArray[iArray].token.tok == TokElem_HTML);
    iHtmlBegin = i = iArray-1; // init
    fFoundTag = fFoundHtmlBegin = FALSE;
    while (i >= 0)
    {
        if (pTokArray[i].token.tokClass == tokElem || pTokArray[i].token.tokClass == tokSSS)
        {
            fFoundTag = TRUE;
            break;
        }
        if (!fFoundHtmlBegin && pTokArray[i].token.tok == ft.tokBegin) // look for < of <HTML>
        {
            fFoundHtmlBegin = TRUE;
            iHtmlBegin = i; // generally, this should be the right before TokElem_HTML
        }
        i--;
    }
    if (!fFoundHtmlBegin) // we didn't find < for <HTML>, so we are in deep trouble, lets quit here
    {
        goto LRet;
    }
    if (!fFoundTag) // we didn't find any tag before TokElem_HTML, so we don't need to do anything, quit
    {
        goto LRet;
    }

    // move <HTML> tag at the begining of pwNew
    i = iHtmlBegin; // iArray;
    ASSERT(pTokArray[i].token.tok == TokTag_START);
    ASSERT(pTokArray[i].token.tokClass == tokTag);
    
    // look for > of <HTML>
    while (i < (int)ptep->m_cMaxToken) // generally, this will be the very next tag, but this covers boundary cases
    {
        if (pTokArray[i].token.tok == ft.tokEnd)
            break;
        i++;
    }
    if (i >= (int)ptep->m_cMaxToken) // error case, didn't find > of <HTML>, so quit
    {
        iArray++; // so that we won't come back here for the same token
        goto LRet;
    }
    iHtmlEnd = i; // found > of <HTML>
    iArray = i; // set it after > of <HTML>

    cbNeed = (ichNewCur+pTokArray[iHtmlBegin].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;
    // copy till begining of the <HTML>
    memcpy( (BYTE *)(&pwNew[ichNewCur]),
            (BYTE *)(&pwOld[ichBeginCopy]),
            (pTokArray[iHtmlBegin].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += pTokArray[iHtmlBegin].token.ibTokMin-ichBeginCopy;
    ichBeginCopy = pTokArray[iHtmlEnd].token.ibTokMac; // set it for next thing

    // move all the stuff from pwNew+0 till pwNew+ichNewCur by cchHtml (make space for <HTML>)
    cchHtml = pTokArray[iHtmlEnd].token.ibTokMac-pTokArray[iHtmlBegin].token.ibTokMin;
    memmove((BYTE *)(&pwNew[cchHtml]),
            (BYTE *)pwNew,
            ichNewCur*sizeof(WCHAR));
    ichNewCur += cchHtml;

    // copy <HTML>
    memcpy( (BYTE *)pwNew,
            (BYTE *)(&pwOld[pTokArray[iHtmlBegin].token.ibTokMin]), 
            cchHtml*sizeof(WCHAR));

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

} /* fnSaveHtmlTag() */

void
CTriEditParse::fnRestoreHtmlTag(CTriEditParse* /*ptep*/, LPWSTR /*pwOld*/,
          LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT* /*piArrayStart*/, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*pichBeginCopy*/,
          DWORD /*dwFlags*/)
{
    // **** 
    // because we didn't save any info about <HTML> tag's location for Restore, we just return
    return;

} /* fnRestoreHtmlTag() */

void
CTriEditParse::fnSaveNBSP(CTriEditParse* /*ptep*/, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    LPCWSTR szNBSP[] = {L"&NBSP"};
    LPCWSTR szNBSPlower[] = {L"&nbsp;"};
    INT ichNbspStart, ichNbspEnd;
    UINT cbNeed;

    // see if pwOld[pTokArray->token.ibtokMin] matches with "&nbsp", 
    // and convert it to lower case
    ASSERT(pTokArray[iArray].token.tokClass == tokEntity);
    if (0 == _wcsnicmp(szNBSP[0], &pwOld[pTokArray[iArray].token.ibTokMin], wcslen(szNBSP[0])))
    {
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to begining of &nbsp

        // check if we have enough memory - If not, realloc
        ichNbspStart = pTokArray[iArray].token.ibTokMin;
        ichNbspEnd = pTokArray[iArray].token.ibTokMac;
        cbNeed = (ichNewCur+ichNbspStart-ichBeginCopy+wcslen(szNBSPlower[0]))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LErrorRet;

        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichNbspStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichNbspStart-ichBeginCopy);
        ichBeginCopy = ichNbspEnd; // make it ready for next copy
        
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(szNBSPlower[0]),
                (wcslen(szNBSPlower[0]))*sizeof(WCHAR));
        ichNewCur += wcslen(szNBSPlower[0]);
    }
LErrorRet:
    iArray++; // so that we won't look at the same token again

//LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

} /* fnSaveNBSP() */

void
CTriEditParse::fnRestoreNBSP(CTriEditParse* /*ptep*/, LPWSTR /*pwOld*/,
          LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT* /*piArrayStart*/, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*pichBeginCopy*/,
          DWORD /*dwFlags*/)
{
    return;
} /* fnRestoreNBSP() */


BOOL
FIsSpecialTag(TOKSTRUCT *pTokArray, int iTag, WCHAR* /*pwOld*/)
{
    BOOL fRet = FALSE;

    if (   (   pTokArray[iTag].token.tokClass == tokSpace
			|| pTokArray[iTag].token.tokClass == tokComment)
        && pTokArray[iTag].token.tok == 0
        && iTag > 0
        && (   pTokArray[iTag-1].token.tok == TokTag_START 
            || pTokArray[iTag-1].token.tok == TokTag_PI
			|| (   pTokArray[iTag-1].token.tok == TokTag_BANG
				&& pTokArray[iTag+1].token.tok == TokTag_CLOSE
				&& pTokArray[iTag+1].token.tokClass == tokTag
				)
			)
        && pTokArray[iTag-1].token.tokClass == tokTag
        )
    {
        fRet = TRUE;
#ifdef WFC_FIX
        int cch = pTokArray[iTag].token.ibTokMac-pTokArray[iTag].token.ibTokMin;
        WCHAR *pStr = new WCHAR[cch+1];
        WCHAR *pFound = NULL;

        // see if this is xml tag
        // for now we will check tags that have a ':' in them.
        // NOTE - This will get changed when parser change to recognise xml tags is made
        if (pStr != NULL)
        {
            memcpy( (BYTE *)pStr, 
                    (BYTE *)&pwOld[pTokArray[iTag].token.ibTokMin],
                    cch*sizeof(WCHAR));
            pStr[cch] = '\0';
            pFound = wcschr(pStr, ':');
            if (pFound)
                fRet = TRUE;

            delete pStr;
        }
#endif //WFC_FIX
    }
    return(fRet);
}

void
GetTagRange(TOKSTRUCT *pTokArray, int iArrayLast, int *piTag, int *pichTokTagClose, BOOL fMatch)
{
    int index = *piTag;
    int iTokTagClose = -1;

    if (fMatch) // we should look fot pTokArray[iTag].iNextprev
    {
        if (pTokArray[*piTag].iNextprev == -1)
            goto LRet;
        index = pTokArray[*piTag].iNextprev; // that way, we will look for '>' after matching end
    }
    // look for TokTag_CLOSE, from iTag onwards
    while (index < iArrayLast)
    {
        if (   pTokArray[index].token.tokClass == tokTag
            && pTokArray[index].token.tok == TokTag_CLOSE)
        {
            iTokTagClose = index;
            break;
        }
        index++;
    }
    if (iTokTagClose != -1) // we found it
    {
        *pichTokTagClose = pTokArray[iTokTagClose].token.ibTokMac;
        *piTag = iTokTagClose + 1;
    }
LRet:
    return;
} /* GetTagRange() */


void CTriEditParse::fnSaveHdr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT cchBeforeBody = 0;
    UINT i, iFound;
    WCHAR *pHdr;
    UINT cbNeed;

    if (ptep->m_hgDocRestore == NULL)
        goto LRetOnly;

    // lock
    pHdr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore);
    ASSERT(pHdr != NULL);

    // look forward to make sure that we don't have multiple <BODY> tags
    // this may be a result of a typo in user's document or trident inserting it
    i = iArray+1;
    iFound = iArray;
    while (i < ptep->m_cMaxToken)
    {
        if (   (pTokArray[i].token.tok == TokElem_BODY)
            && (pTokArray[i].token.tokClass == tokElem)
            && (pTokArray[i-1].token.tok == TokTag_START)
            && (pTokArray[i-1].token.tokClass == tokTag)
            )
        {
            iFound = i;
            break;
        }
        i++;
    }
    if (iFound > iArray) // this means that we found the last <BODY> tag Trident inserted
        iArray = iFound;

    ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    // what if we DON'T have a <BODY> tag at all. We would have found </BODY> here.
    // If thats the case, we just don't save anything
    ASSERT(iArray-1 >= 0);
    if (pTokArray[iArray-1].token.tok != TokTag_START)
        cchBeforeBody = 0;
    else
        cchBeforeBody = pTokArray[iArray].token.ibTokMin;

    // realloc if needed
    if (cchBeforeBody*sizeof(WCHAR)+sizeof(int) > GlobalSize(ptep->m_hgDocRestore))
    {
        HGLOBAL hgDocRestore;
        GlobalUnlock(ptep->m_hgDocRestore);
        hgDocRestore = ptep->m_hgDocRestore;
#pragma prefast(suppress:308, "noise")
        ptep->m_hgDocRestore = GlobalReAlloc(ptep->m_hgDocRestore, cchBeforeBody*sizeof(WCHAR)+sizeof(int), GMEM_MOVEABLE|GMEM_ZEROINIT);
        // if this alloc failed, we may still want to continue
        if (ptep->m_hgDocRestore == NULL)
        {
            GlobalFree(hgDocRestore);
            goto LRet;
        }
        else
        {
            pHdr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore); // do we need to unlock this first?
            ASSERT(pHdr != NULL);
        }
    }

    // copy from pwOld
    memcpy( (BYTE *)pHdr,
            (BYTE *)&cchBeforeBody,
            sizeof(INT));
    memcpy( (BYTE *)(pHdr)+sizeof(INT),
            (BYTE *)pwOld,
            cchBeforeBody*sizeof(WCHAR));

    // reconstruct the pre_BODY part of the document
    // NOTE  - for next time around ...
    // If we get the title & body tags from pwNew instead of pwOld, we won't
    // loose the DESIGNTIMESPs for those 2 tags
    if (cchBeforeBody > 0)
    {
        int iTag = 0;
        int ichTokTagClose = -1;
        BOOL fMatch = FALSE;
        LPCWSTR rgSpaceTags[] =
        {
            L" DESIGNTIMESP=",
            L" designtimesp=",
        };
        WCHAR szIndex[cchspBlockMax]; // will we have more than 20 digit numbers as number of DESIGNTIMESPx?

        int index = iArray;
        int ichBodyTokenStart, ichBodyTokenEnd;
        LPCWSTR rgPreBody[] = {L"<BODY",};

        memset((BYTE *)pwNew, 0, ichNewCur*sizeof(WCHAR));
        // if we have a unicode stream, we should preserve 0xff,0xfe that occurs at the
        // beginning of the file
        ichNewCur = 0;
        if (ptep->m_fUnicodeFile)
        {
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, sizeof(WCHAR));
            ichNewCur = 1;
        }

        // loop through all tags starting from index of '<' of <html> till iArray
        // if the tag we see is one of the following, then copy that tag into pwNew
        // ------------------------------------------------------------------------
        // <HTML>, <HEAD>..</HEAD>, <TITLE>..</TITLE>, <STYLE>..</STYLE>, 
        // <LINK>, <BASE>, <BASEFONT>
        // ------------------------------------------------------------------------
        iTag = 0;
        ichTokTagClose = -1;
        while (iTag < (int)iArray)
        {
            if (   pTokArray[iTag].token.tokClass == tokAttr
                && pTokArray[iTag].token.tok == TokAttrib_STARTSPAN)
            {
                GetTagRange(pTokArray, iArray, &iTag, &ichTokTagClose, TRUE);
            }
            else if (   (   (pTokArray[iTag].token.tokClass == tokElem)
                    && (   pTokArray[iTag].token.tok == TokElem_HTML
                        || pTokArray[iTag].token.tok == TokElem_HEAD
                        || pTokArray[iTag].token.tok == TokElem_META
                        || pTokArray[iTag].token.tok == TokElem_LINK
                        || pTokArray[iTag].token.tok == TokElem_BASE
                        || pTokArray[iTag].token.tok == TokElem_BASEFONT
                        || pTokArray[iTag].token.tok == TokElem_TITLE
                        || pTokArray[iTag].token.tok == TokElem_STYLE
                        || pTokArray[iTag].token.tok == TokElem_OBJECT
                        )
                    )
                || (FIsSpecialTag(pTokArray, iTag, pwOld))
                )
            {
                int iTagSav = iTag;

                fMatch = FALSE;
                ichTokTagClose = -1;
                if (   pTokArray[iTag].token.tok == TokElem_TITLE
                    || pTokArray[iTag].token.tok == TokElem_STYLE
                    || pTokArray[iTag].token.tok == TokElem_OBJECT
                    )
                    fMatch = TRUE;
                GetTagRange(pTokArray, iArray, &iTag, &ichTokTagClose, fMatch);
                if (ichTokTagClose != -1)
                {
                    // copy the stuff into pwNew
                    pwNew[ichNewCur++] = '<';
                    if (   pTokArray[iTagSav-1].token.tok == TokTag_END
                        && pTokArray[iTagSav-1].token.tokClass == tokTag)
                    {
                        pwNew[ichNewCur++] = '/';
                    }
					else if (	   pTokArray[iTagSav-1].token.tok == TokTag_PI
								&& pTokArray[iTagSav-1].token.tokClass == tokTag)
					{
						pwNew[ichNewCur++] = '?';
					}
					else if (	   pTokArray[iTagSav-1].token.tok == TokTag_BANG
								&& pTokArray[iTagSav-1].token.tokClass == tokTag)
					{
						pwNew[ichNewCur++] = '!';
					}
                    memcpy( (BYTE *)&pwNew[ichNewCur], 
                            (BYTE *)&pwOld[pTokArray[iTagSav].token.ibTokMin],
                            (ichTokTagClose-pTokArray[iTagSav].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += ichTokTagClose-pTokArray[iTagSav].token.ibTokMin;
                    // do we want to add \r\n after each tag we copy?
                }
                else
                    goto LNext;
            }
            else
            {
LNext:
                iTag++;
            }
        } // while (iTag < (int)iArray)


        // we know that iArray is currently pointing to tokElem_BODY
        // go backwards and look for '<', so that we can copy from that point
        ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
        ASSERT(pTokArray[iArray].token.tokClass == tokElem);
        index = iArray;
        while (index >= 0)
        {
            if (   pTokArray[index].token.tok == TokTag_START
                && pTokArray[index].token.tokClass == tokTag)
            {
                break;
            }
            index--;
        }
        if (index < 0) // error case, we didn't find '<' before BODY
            goto LSkipBody;
        ichBodyTokenStart = pTokArray[index].token.ibTokMin;

        // now go forward till we get the '>' of <BODY>, we don't have to go this far, 
        // but this covers boundary cases
        index = iArray;
        while (index < (int)ptep->m_cMaxToken)
        {
            if (   pTokArray[index].token.tok == TokTag_CLOSE
                && pTokArray[index].token.tokClass == tokTag)
            {
                break;
            }
            index++;
        }
        if (index > (int)ptep->m_cMaxToken) // error case, we didn't find '>' before BODY
            goto LSkipBody;
        ichBodyTokenEnd = pTokArray[index-1].token.ibTokMac; // BUG 15391 - don't copy TokTag_CLOSE here, it gets added later
    
        // blt part of the <BODY> tag into pwNew. (BUG 15391 - excluding the ending >)
        ASSERT(ichBodyTokenEnd-ichBodyTokenStart >= 0);
        memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)&pwOld[ichBodyTokenStart], (ichBodyTokenEnd-ichBodyTokenStart)*sizeof(WCHAR));
        ichNewCur += (ichBodyTokenEnd-ichBodyTokenStart); 

        // only if spacing flag is set
        if (dwFlags & dwPreserveSourceCode)
        {
            // BUG 15391 - insert DESIGNTIMESP with (ptep->m_ispInfoBlock+ptep->m_ispInfoBase-1) & add '>' at the end
            ASSERT(wcslen(rgSpaceTags[1]) == wcslen(rgSpaceTags[0]));
            if (iswupper(pwOld[pTokArray[iArray].token.ibTokMin]) != 0) // upper case  - BUG 15389
            {
                memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgSpaceTags[0], wcslen(rgSpaceTags[0])*sizeof(WCHAR));
                ichNewCur += wcslen(rgSpaceTags[0]);
            }
            else
            {
                memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgSpaceTags[1], wcslen(rgSpaceTags[1])*sizeof(WCHAR));
                ichNewCur += wcslen(rgSpaceTags[1]);
            }
            (WCHAR)_itow(ptep->m_ispInfoBlock+ptep->m_ispInfoBase-1, szIndex, 10);
            ASSERT(wcslen(szIndex) < sizeof(szIndex));
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(szIndex),
                    wcslen(szIndex)*sizeof(WCHAR));
            ichNewCur += wcslen(szIndex);
        }
        goto LBodyCopyDone;

LSkipBody:
        // if we skipped copying <BODY> tag, we must put in a dummy <BODY> at ichNewCur
        memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgPreBody[0], wcslen(rgPreBody[0])*sizeof(WCHAR));
        ichNewCur = wcslen(rgPreBody[0]);

LBodyCopyDone:
        pwNew[ichNewCur++] = '>'; //ending '>' that we skipped copying before
        // set ichBeginCopy and iArray appropriately
        iArray = index+1;
        ichBeginCopy = pTokArray[iArray].token.ibTokMin;
    }

    // Copy everything upto and including <BODY>

//LSkipCopy:

    if (ptep->m_pPTDTC != NULL) // we had saved PageTransitionDTC in a temporary
    {
        ASSERT(ptep->m_cchPTDTCObj >= 0);
        cbNeed = (ichNewCur+ptep->m_cchPTDTCObj)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        memcpy( (BYTE *)&pwNew[ichNewCur],
                (BYTE *)ptep->m_pPTDTC,
                ptep->m_cchPTDTCObj*sizeof(WCHAR));
        ichNewCur += ptep->m_cchPTDTCObj;
        GlobalUnlockFreeNull(&(ptep->m_hgPTDTC));
    }

    ptep->m_fInHdrIn = FALSE;

LRet:
    // unlock
    GlobalUnlock(ptep->m_hgDocRestore);

    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

LRetOnly:
    return;

} /* fnSaveHdr() */

void 
CTriEditParse::fnRestoreHdr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT cchBeforeBody = 0;
    WCHAR *pHdr;
    INT ichBodyStart, ichBodyEnd;
    UINT i, iFound;
    UINT cbNeed;

    if (ptep->m_hgDocRestore == NULL)
        goto LRetOnly;

    // lock, copy, unlock
    pHdr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore);
    ASSERT(pHdr != NULL);

    ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    
    // HACK to fix a TRIDENT misbehaviour
    // If we had any text before <BODY> tag going into Trident, it will add 2nd <BODY>
    // tag before this text comming out of Trident without looking forward and 
    // recognizing that a <BODY> tag already exists. Ideally, Trident should move teh
    // <BODY> tag at appropriate place rather than inserting a 2nd one.
    // Lets assume that Trident will insert only one extra <BODY> tag.
    i = iArray + 1; // we know iArray is the 1st <BODY> tag
    iFound = iArray;
    while (i < ptep->m_cMaxToken)
    {
        if (   (pTokArray[i].token.tok == ft.tokBegin2) /*TokElem_BODY*/
            && (pTokArray[i-1].token.tok == TokTag_START)
            )
        {
            iFound = i;
            break;
        }
        i++;
    }
    if (iFound > iArray) // this means that we found the last <BODY> tag Trident inserted
        iArray = iFound;

    memcpy((BYTE *)&cchBeforeBody, (BYTE *)pHdr, sizeof(INT));

    // realloc if needed
    ichBodyStart = pTokArray[iArray].token.ibTokMin;
    ichBodyEnd = pTokArray[iArray].token.ibTokMac;
    cbNeed = (ichNewCur+cchBeforeBody+ichBodyEnd-ichBodyStart)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LErrorRet;

    if (cchBeforeBody > 0)
    {
        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to begining of &nbsp
        memcpy( (BYTE *)(pwNew),
                (BYTE *)(pHdr)+sizeof(INT),
                cchBeforeBody*sizeof(WCHAR));
        
        // fill 0s from pwNew+cchBeforeBody till pwNew+ichNewCur-1 (inclusive)
        if ((int)ichNewCur-cchBeforeBody > 0)
            memset((BYTE *)(pwNew+cchBeforeBody), 0, (ichNewCur-cchBeforeBody)*sizeof(WCHAR));

        ichNewCur = cchBeforeBody; // note that we are initializing ichNewCur here ***
        ichBeginCopy = ichBodyEnd; // make it ready for next copy
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBodyStart]),
                (ichBodyEnd-ichBodyStart)*sizeof(WCHAR));
        ichNewCur += (ichBodyEnd-ichBodyStart);  
    }
    else // if we didn't save anything, it means that we had no pre-BODY stuff in the doc (bug 15393)
    {
        if (ptep->m_fUnicodeFile && ichNewCur == 0)
        {
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, sizeof(WCHAR));
            ichNewCur = ichBeginCopy = 1;
        }
        // actually, we should get the '>' of <body> tag instead of using iArray+1
        if (dwFlags & dwFilterSourceCode)
            ichBeginCopy = pTokArray[iArray+1].token.ibTokMac; // '>' of <BODY> tag
        else
        {
#ifdef NEEDED // VID6 - bug 22781 (This is going to generate some debate, so #ifdef instead of removing.
            LPCWSTR rgPreBody[] =
            {
                L"<HTML>\r\n<HEAD><TITLE></TITLE></HEAD>\r\n",
            };
            ASSERT(ichNewCur >= 0); // make sure its not invalid
            memcpy( (BYTE *)&pwNew[ichNewCur], (BYTE *)rgPreBody[0], wcslen(rgPreBody[0])*sizeof(WCHAR));
            ichNewCur += wcslen(rgPreBody[0]);
#endif //NEEDED
            // Note that we had not saved any thing before going to design view because there was
            // no <BODY> tag. we should now copy from current pwOld[ichBeginCopy] till 
            // the new pwOld[ichBeginCopy] into pwNew[ichNewCur] and then set ichBeginCopy.
            if (pTokArray[iArray-1].token.ibTokMin > ichBeginCopy)
            {
                memcpy( (BYTE *)&pwNew[ichNewCur], 
                        (BYTE *)&pwOld[ichBeginCopy], 
                        (pTokArray[iArray-1].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
                ichNewCur += pTokArray[iArray-1].token.ibTokMin-ichBeginCopy;
            }
            ichBeginCopy = pTokArray[iArray-1].token.ibTokMin; // '<' of <BODY> tag
        }
    }

LErrorRet:
    // unlock
    GlobalUnlock(ptep->m_hgDocRestore);

    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
LRetOnly:
    return;

} /* fnRestoreHdr() */


void CTriEditParse::fnSaveFtr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT cchAfterBody = 0;
    INT cchBeforeBody = 0;
    INT cchPreEndBody = 0;
    WCHAR *pFtr;
    INT ichStart, ichEnd;
    UINT iArraySav = iArray;
    UINT cbNeed;

    if (ptep->m_hgDocRestore == NULL)
        goto LRetOnly;

    // lock
    pFtr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore);
    ASSERT(pFtr != NULL);
    ichStart = pTokArray[iArray-1].token.ibTokMin; // init
    ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    ASSERT(pTokArray[iArray-1].token.tok == TokTag_END);
    // what if we DON'T have a </BODY> tag at all. Lets handle the error case here
    // If thats the case, we just don't save anything
    ASSERT(iArray-1 >= 0);
    if (pTokArray[iArray-1].token.tok != TokTag_END)
    {
        cchAfterBody = 0;
        cchPreEndBody = 0;
    }
    else
    {
        // following was added for Bug fix for 7542
        cchAfterBody = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac-pTokArray[iArray].token.ibTokMac;
        
        // now calculate the space required to save stuff from before </BODY> 
        // till the previous meaningful token
        ichStart = ichEnd = pTokArray[iArray-1].token.ibTokMin;
        ichStart--; // now ichStart is pointing to a character before </BODY>
        while (    (ichStart >= 0)
                && (   pwOld[ichStart] == ' '
                    || pwOld[ichStart] == '\r'
                    || pwOld[ichStart] == '\n'
                    || pwOld[ichStart] == '\t'
                    )
                )
        {
            ichStart--;
        }
        ichStart++; // the current char is not one of the above, so increment
        if (ichStart == ichEnd) // we didn't have anyspace, eol, tab between </BODY> & previous token
        {
            cchPreEndBody = 0;
        }
        else
        {
            ASSERT(ichEnd - ichStart > 0);
            cchPreEndBody = ichEnd - ichStart;
        }
    }

    // get cchBeforeBody if pre-BODY part was saved, and adjust pFtr for saving
    memcpy((BYTE *)&cchBeforeBody, (BYTE *)pFtr, sizeof(INT));
    pFtr += cchBeforeBody + sizeof(INT)/sizeof(WCHAR);

    // realloc if needed
    if ((cchPreEndBody+cchAfterBody+cchBeforeBody)*sizeof(WCHAR)+3*sizeof(int) > GlobalSize(ptep->m_hgDocRestore))
    {
        HGLOBAL hgDocRestore;
        GlobalUnlock(ptep->m_hgDocRestore);
        hgDocRestore = ptep->m_hgDocRestore;
#pragma prefast(suppress:308, "noise")
        ptep->m_hgDocRestore = GlobalReAlloc(ptep->m_hgDocRestore, (cchPreEndBody+cchAfterBody+cchBeforeBody)*sizeof(WCHAR)+3*sizeof(int), GMEM_MOVEABLE|GMEM_ZEROINIT);
        // if this alloc failed, we may still want to continue
        if (ptep->m_hgDocRestore == NULL)
        {
            GlobalFree(hgDocRestore);
            goto LRet;
        }
        else
        {
            pFtr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore); // do we need to unlock this first?
            ASSERT(pFtr != NULL);
            // remember to set pFtr to be after cchBeforeBody
            pFtr += cchBeforeBody + sizeof(INT)/sizeof(WCHAR);
        }
    }

    // copy from pwOld
    memcpy( (BYTE *)pFtr,
            (BYTE *)&cchAfterBody,
            sizeof(INT));
    memcpy( (BYTE *)(pFtr)+sizeof(INT),
            (BYTE *)(pwOld+pTokArray[iArray].token.ibTokMac),
            cchAfterBody*sizeof(WCHAR));
    pFtr += cchAfterBody + sizeof(INT)/sizeof(WCHAR);

    memcpy( (BYTE *)pFtr,
            (BYTE *)&cchPreEndBody,
            sizeof(INT));
    memcpy( (BYTE *)(pFtr)+sizeof(INT),
            (BYTE *)&(pwOld[ichStart]),
            cchPreEndBody*sizeof(WCHAR));

    // the very next token from TokElem_BODY will be TokTag_CLOSE in most cases, but just in case...
    while (iArray < ptep->m_cMaxToken)
    {
        if (pTokArray[iArray].token.tok == TokTag_CLOSE && pTokArray[iArray].token.tokClass == tokTag)
            break;
        iArray++;
    }
    if (iArray >= ptep->m_cMaxToken)
    {
        iArray = iArraySav+1; // atleast copy till that point
        goto LRet;
    }

    // copy till '>' of </BODY> from pwOld into pwNew
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);

    cbNeed = (ichNewCur+pTokArray[iArray].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    memcpy( (BYTE *)&(pwNew[ichNewCur]),
            (BYTE *)&(pwOld[ichBeginCopy]),
            (pTokArray[iArray].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += pTokArray[iArray].token.ibTokMac-ichBeginCopy;
    ichBeginCopy = pTokArray[iArray].token.ibTokMac;

    iArray = ptep->m_cMaxToken - 1;
    ichBeginCopy = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac; // we don't want to copy anything after this

LRet:
    // unlock
    GlobalUnlock(ptep->m_hgDocRestore);

    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

LRetOnly:
    return;

} /* fnSaveFtr() */

void CTriEditParse::fnRestoreFtr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT cchAfterBody = 0;
    INT cchBeforeBody = 0;
    WCHAR *pFtr;
    INT ichBodyEnd;
    UINT i, iFound;
    INT ichInsEOL = -1; // initilize
    UINT cbNeed;

    if (ptep->m_hgDocRestore == NULL)
        goto LRetOnly;

    // lock, copy, unlock
    pFtr = (WCHAR *)GlobalLock(ptep->m_hgDocRestore);
    ASSERT(pFtr != NULL);

    ASSERT(pTokArray[iArray].token.tok == TokElem_BODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    
    // HACK to fix a TRIDENT misbehaviour
    // If we had any text before <BODY> tag going into Trident, it will add 2nd <BODY>
    // tag before this text comming out of Trident without looking forward and 
    // recognizing that a <BODY> tag already exists. Ideally, Trident should move teh
    // <BODY> tag at appropriate place rather than inserting a 2nd one.
    // Lets assume that Trident will insert only one extra <\BODY> tag.
    i = iArray + 1; // we know iArray is the 1st <\BODY> tag
    iFound = iArray;
    while (i < ptep->m_cMaxToken)
    {
        if (   (pTokArray[i].token.tok == ft.tokBegin2) /*TokElem_BODY*/
            && (pTokArray[i-1].token.tok == TokTag_END)
            )
        {
            iFound = i;
            break;
        }
        i++;
    }
    if (iFound > iArray) // this means that we found the last <BODY> tag Trident inserted
        iArray = iFound;

    memcpy((BYTE *)&cchBeforeBody, (BYTE *)pFtr, sizeof(INT));
    pFtr += cchBeforeBody + sizeof(INT)/sizeof(WCHAR);
    memcpy((BYTE *)&cchAfterBody, (BYTE *)pFtr, sizeof(INT));
    pFtr += sizeof(INT)/sizeof(WCHAR);
    ichBodyEnd = pTokArray[iArray].token.ibTokMac;
    // if (cchAfterBody == 0) // get the size of our own header

    // realloc if needed
    cbNeed = (ichNewCur+cchAfterBody+(ichBodyEnd-ichBeginCopy)+2/* for EOL*/)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LErrorRet;

    if (cchAfterBody > 0)
    {
        LPCWSTR rgSpaceTags[] = {L"DESIGNTIMESP"};
        int cchTag, index, indexDSP;

        // ichBeginCopy is a position in pwOld and
        // ichNewCur is a position in pwNew
        // copy from ichBeginCopy to end of HTML document
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichBodyEnd-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichBodyEnd-ichBeginCopy);
        ichBeginCopy = ichBodyEnd;

        // now that we have copied 'BODY' of </BODY> tag, lets make sure its of correct case (bug 18248)
        indexDSP = -1;
        index = pTokArray[iArray].iNextprev;
        cchTag = wcslen(rgSpaceTags[0]);
        if (index != -1 && index < (int)iArray) // we have matching <BODY> tag prior to this one
        {
            // get the designtimesp attribute
            while (index < (int)iArray) // we will never come this far, but thats the only known position at this point
            {
                if (pTokArray[index].token.tok == TokTag_CLOSE)
                    break;
                if (   (pTokArray[index].token.tok == 0)
                    && (pTokArray[index].token.tokClass == tokSpace)
                    && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[index].token.ibTokMin], cchTag))
                    )
                {
                    indexDSP = index;
                    break;
                }
                index++;
            } // while
            if (indexDSP != -1) // we found DESIGNTIMESP attribute
            {
                // look for the case of designtimesp
                if (iswupper(pwOld[pTokArray[indexDSP].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
                    _wcsupr(&pwNew[ichNewCur-4]); // length of BODY tag name
                else
                    _wcslwr(&pwNew[ichNewCur-4]); // length of BODY tag name
            }
        }

        // we know that the following condition will be met most of the times, but just to cover
        // incomplete HTML cases...
        if (   (pTokArray[iArray].token.tok == ft.tokBegin2) /*TokElem_BODY*/
            && (pTokArray[iArray-1].token.tok == TokTag_END)
            )
        {
            ichInsEOL = ichNewCur - (pTokArray[iArray].token.ibTokMac - pTokArray[iArray-1].token.ibTokMin);
        }

        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)pFtr,
                (cchAfterBody)*sizeof(WCHAR));
        ichNewCur += (cchAfterBody);

        // we had saved spacing info before </BODY>
        if (ichInsEOL != -1)
        {
            INT cchPreEndBody = 0;

            pFtr += cchAfterBody;
            cchPreEndBody = *(int *)pFtr;
            if (cchPreEndBody > 0)
            {
                INT ichT = ichInsEOL-1;
                WCHAR *pw = NULL;
                INT cchSubStr = 0;
                WCHAR *pwStr = NULL;
                WCHAR *pwSubStr = NULL;

                pFtr += sizeof(INT)/sizeof(WCHAR); // pFtr now points to Pre </BODY> stuff
                // This is kind of hacky - but I don't see a way out, atleast 
                // If the contents in pFtr at cchPreEndBody are subset of the
                // contents before </BODY> and after any previous text/tokens,
                // then we shouldn't do the following memcpy()
                while (    ichT >= 0 /* validation */
                        && (       pwNew[ichT] == ' '
                                || pwNew[ichT] == '\n'
                                || pwNew[ichT] == '\r'
                                || pwNew[ichT] == '\t'
                                )
                            )
                {
                    ichT--;
                    cchSubStr++;
                }
                ichT++; // compensate the last decrement
                if (cchSubStr > 0)
                {
                    ASSERT(ichT >= 0);
                    pwStr = new WCHAR [cchSubStr+1];
                    memcpy((BYTE *)pwStr, (BYTE *)(&pwNew[ichT]), cchSubStr*sizeof(WCHAR));
                    pwStr[cchSubStr] = '\0';
                    pwSubStr = new WCHAR [cchPreEndBody+1];
                    memcpy((BYTE *)pwSubStr, (BYTE *)pFtr, cchPreEndBody*sizeof(WCHAR));
                    pwSubStr[cchPreEndBody] = '\0';
                    pw = wcsstr(pwStr, pwSubStr);
                }
                if (pw == NULL) // means that the substring wasn't found
                {
                    // allocate more memory if needed
                    cbNeed = (ichNewCur+cchPreEndBody)*sizeof(WCHAR)+cbBufPadding;
                    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                        goto LErrorRet;


                    memmove((BYTE *)(&pwNew[ichInsEOL+cchPreEndBody]),
                            (BYTE *)(&pwNew[ichInsEOL]),
                            (ichNewCur-ichInsEOL)*sizeof(WCHAR));
                    memcpy( (BYTE *)(&pwNew[ichInsEOL]),
                            (BYTE *)(pFtr),
                            (cchPreEndBody)*sizeof(WCHAR));
                    ichNewCur += cchPreEndBody;
                }
                if (pwStr != NULL)
                    delete pwStr;
                if (pwSubStr != NULL)
                    delete pwSubStr;
            } // if (cchPreEndBody > 0)
        } // if (ichInsEOL != -1)

        ichBeginCopy = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac; // we don't want to copy anything after this
        iArray = ptep->m_cMaxToken - 1;

        // WISH LIST Item for space preservation        
        // we know that ptep->m_ispInfoBlock was the last spacing block that was recovered.
        // This block (like all others) has 4 parts (1)pre '<' (2)between '<>' & order info
        // (3)post '>' (4)pre matching '</'
        // At this point we care about (3) & (4)
        // first of all, get ichBeginNext (ich past '>') & ichBeginMatch (ich before '</')
        // apply the saved spacing info to the contents of pwNew

        // The difficult part is to get these ich's without parsing pwNew.
    }
    else
    {
        // copy our own Footer
        if (dwFlags & dwFilterSourceCode)
        {
            int ichBodyStart, index, ichBodyTagEnd;

            // get the '</' of </body>
            index = iArray;
            while (index >= 0) // we won't go this far, but just in case we have invalid html
            {
                if (   pTokArray[index].token.tok == TokTag_END
                    && pTokArray[index].token.tokClass == tokTag
                    )
                {
                    break;
                }
                index--;
            }
            if (index >= 0)
            {
                ichBodyStart = pTokArray[index].token.ibTokMin;
                // copy till the current token's begining, see if we have enough space
                if (ichBodyStart > (int)ichBeginCopy)
                {
                    cbNeed = (ichNewCur+ichBodyStart-ichBeginCopy+1/*for null at the end*/)*sizeof(WCHAR)+cbBufPadding;
                    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                        goto LErrorRet;
                    memcpy( (BYTE *)(&pwNew[ichNewCur]),
                            (BYTE *)(&pwOld[ichBeginCopy]),
                            (ichBodyStart-ichBeginCopy)*sizeof(WCHAR));
                    ichNewCur += (ichBodyStart-ichBeginCopy);
                    ichBeginCopy = ichBodyStart; // setting this is redundant, but it makes the code readable.
                }
                else if (ichBodyEnd > (int)ichBeginCopy)
                {
                    index = iArray;
                    while (index <= (int)ptep->m_cMaxToken) // we won't go this far, but just in case we have invalid html
                    {
                        if (   pTokArray[index].token.tok == TokTag_CLOSE
                            && pTokArray[index].token.tokClass == tokTag
                            )
                        {
                            break;
                        }
                        index++;
                    }
                    if (index < (int)ptep->m_cMaxToken)
                    {
                        ichBodyTagEnd = pTokArray[index].token.ibTokMac;
                        cbNeed = (ichNewCur+ichBodyTagEnd-ichBeginCopy+1/*for null at the end*/)*sizeof(WCHAR)+cbBufPadding;
                        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                            goto LErrorRet;
                        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                                (BYTE *)(&pwOld[ichBeginCopy]),
                                (ichBodyTagEnd-ichBeginCopy)*sizeof(WCHAR));
                        ichNewCur += (ichBodyTagEnd-ichBeginCopy);
                        ichBeginCopy = ichBodyTagEnd; // setting this is redundant, but it makes the code readable.
                    }
                }

                // add a null at the end 
                // to keep the code in ssync with the if (cchAfterBody > 0) case
                pwNew[ichNewCur++] = '\0';

                ichBeginCopy = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac; // we don't want to copy anything after this
                iArray = ptep->m_cMaxToken - 1;
            } // if (index >= 0)
        } // if (dwFlags & dwFilterSourceCode)
    }


    if (ptep->m_cchPTDTC != 0)
    {
        // this means that we didn't encounter the DTC on way out from Trident
        // but they were there when we went to Trident. The user must have deleted
        // the DTCs while in Design view
        ASSERT(ptep->m_ichPTDTC != 0);
        // remove m_cchPTDTC WCHARS from m_ichPTDTC
        memset( (BYTE *)&pwNew[ptep->m_ichPTDTC],
                0,
                ptep->m_cchPTDTC*sizeof(WCHAR)
                );
        memmove((BYTE *)&pwNew[ptep->m_ichPTDTC],
                (BYTE *)&pwNew[ptep->m_ichPTDTC+ptep->m_cchPTDTC],
                (ichNewCur-(ptep->m_ichPTDTC+ptep->m_cchPTDTC))*sizeof(WCHAR)
                );
        ichNewCur -= ptep->m_cchPTDTC;
        ptep->m_cchPTDTC = 0;
    }

LErrorRet:
    // unlock
    GlobalUnlock(ptep->m_hgDocRestore);

    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
LRetOnly:
    return;

} /* fnRestoreFtr() */


void CTriEditParse::fnSaveObject(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    // scan till the end of the object. 
    // If we find '<% %>' blocks inside, put a comment with a special tag around it,
    // else simply copy that object as is and exit
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT ichObjectStart, ichObjectEnd, iObjectStart, iObjectEnd, i;
    BOOL fSSSFound = FALSE;
    UINT iArraySav = iArray;
    UINT cbNeed;

    ichObjectStart = ichObjectEnd = iObjectStart = iObjectEnd = 0;
    
    if (       pTokArray[iArray-1].token.tok == TokTag_END
            && pTokArray[iArray-1].token.tokClass == tokTag
            )
    {
        iArray++;
        goto LRet;
    }
    ASSERT(pTokArray[iArray].token.tok == TokElem_OBJECT); // we should be at the object tag
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    iObjectStart = iArray;

    if (pTokArray[iArray].iNextprev != -1)
    {
        // NOTE that this will give us topmost nested level of the OBJECT, if we had nested objects
        iObjectEnd = pTokArray[iArray].iNextprev;
        ASSERT(iObjectEnd < (INT)ptep->m_cMaxToken);
        ASSERT((iObjectEnd-1 >= 0) && pTokArray[iObjectEnd-1].token.tok == TokTag_END);

        // this will be a wierd case where the iNextprev is incorrectly pointing to another token
        // but lets handle that case.
        if (pTokArray[iObjectEnd].token.tok != TokElem_OBJECT)
            goto LFindObjectClose; // find it by looking at each token
    }
    else // actually, this is an error case, but rather than just giving assert, try to find the token
    {
LFindObjectClose:
        i = iObjectStart+1;
        while (i < (INT)ptep->m_cMaxToken)
        {
            // this may not give us the correct matching </OBJECT> if we had nested objects.
            // but we don't have that knowledge at this point any way.
            if (   pTokArray[i].token.tok == TokElem_OBJECT
                && pTokArray[i].token.tokClass == tokElem
                && (i-1 >= 0) /* validation */
                && pTokArray[i-1].token.tok == TokTag_END
                )
            {
                break;
            }
            i++;
        }
        if (i < (INT)ptep->m_cMaxToken) // found TokElem_OBJECT token
            iObjectEnd = i;
        else // error case 
            goto LRet; // didn't find OBJECT, but exhausted the token array
    }
    // at this point iObjectStart & iObjectEnd point to OBJECT of <OBJECT> and iObjectEnd respectively
    // look for '<' in <OBJECT> & and '>' in </OBJECT>
    i = iObjectStart;
    while (i >= 0)
    {
        if (   pTokArray[i].token.tok == TokTag_START
            && pTokArray[i].token.tokClass == tokTag
            )
            break;
        i--;
    }
    if (i < 0) // error case
        goto LRet;
    iObjectStart = i;
    ichObjectStart = pTokArray[iObjectStart].token.ibTokMin;

    i = iObjectEnd;
    while (i <= (INT)ptep->m_cMaxToken)
    {
        if (   pTokArray[i].token.tok == TokTag_CLOSE
            && pTokArray[i].token.tokClass == tokTag
            )
            break;
        i++;
    }
    if (i >= (INT)ptep->m_cMaxToken) // error case
        goto LRet;
    iObjectEnd = i;
    ichObjectEnd = pTokArray[iObjectEnd].token.ibTokMac;
    ASSERT(ichObjectEnd > ichObjectStart);

    // look for <% %> between iObjectStart & iObjectEnd
    for (i = iObjectStart; i <= iObjectEnd; i++)
    {
        if (   pTokArray[i].token.tok == TokTag_SSSOPEN
            && pTokArray[i].token.tokClass == tokSSS
            )
        {
            fSSSFound = TRUE;
            break;
        }
    }
    if (fSSSFound) // this object can't be displayed in Trident, so convert it
    {
        LPCWSTR rgComment[] =
        {
            L"<!--ERROROBJECT ",
            L" ERROROBJECT-->",
        };

        //if (dwFlags & dwPreserveSourceCode)
        //{
            // in this case, we would have already copied <OBJECT ... DESIGNTIMESP=x>
            // and ichNewCur is adjusted accordingly
            // get ich that points after <OBJECT> in pwOld

            // I don't like this, but don't see a way out...
            // look back in pwNew and get ich that points to '<' of <OBJECT ... DESIGNTIMESP=x>
            // insert the comment there
        //}
        //else
        //{
            ASSERT((INT)(ichObjectStart-ichBeginCopy) > 0);
            cbNeed = (ichNewCur+ichObjectEnd-ichBeginCopy+wcslen(rgComment[0])+wcslen(rgComment[1]))*sizeof(WCHAR)+cbBufPadding;
            if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                goto LNoCopy;

            // copy till begining of <OBJECT>
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichBeginCopy]),
                    (ichObjectStart-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += ichObjectStart-ichBeginCopy;

            // copy the comment begining
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(rgComment[0]),
                    wcslen(rgComment[0])*sizeof(WCHAR));
            ichNewCur += wcslen(rgComment[0]);
            
            // copy from <OBJECT> to </OBJECT>
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[ichObjectStart]),
                    (ichObjectEnd-ichObjectStart)*sizeof(WCHAR));
            ichNewCur += ichObjectEnd-ichObjectStart;
            
            // copy the comment end
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(rgComment[1]),
                    wcslen(rgComment[1])*sizeof(WCHAR));
            ichNewCur += wcslen(rgComment[1]);
        //}
    }
    else
    {
        // We always save its contents into our buffer and replace it on the way back if need be
        // save cchClsId, clsId, cchParam, PARAM_Tags
        INT cchParam, ichParam, iParamStart, iParamEnd;
        INT ichObjStartEnd; // ich at the end of <OBJECT .....>
        LPCWSTR rgComment[] =
        {
            L"<!--ERRORPARAM ",
            L" ERRORPARAM-->",
        };
        INT iObjTagEnd = -1;

        iParamStart = iObjectStart;
        while (iParamStart < iObjectEnd)
        {
            //if (   pTokArray[iParamStart].token.tok == TokAttrib_CLASSID
            //  && pTokArray[iParamStart].token.tokClass == tokAttr)
            //  iClsId = iParamStart;
            if (   pTokArray[iParamStart].token.tok == TokElem_PARAM
                && pTokArray[iParamStart].token.tokClass == tokElem)
                break;
            iParamStart++;
        }
        if (iParamStart >= iObjectEnd) // don't see any <PARAM> tags, so don't save
            goto LSkipSave;

        while (iParamStart > iObjectStart) // generally this will the previous token, but cover all cases
        {
            if (   pTokArray[iParamStart].token.tok == TokTag_START
                && pTokArray[iParamStart].token.tokClass == tokTag)
                break;
            iParamStart--;
        }
        if (iParamStart <= iObjectStart) // error
            goto LSkipSave;
        ichParam = pTokArray[iParamStart].token.ibTokMin;

        iParamEnd = iObjectEnd;
        while (iParamEnd > iObjectStart)
        {
            if (   pTokArray[iParamEnd].token.tok == TokElem_PARAM
                && pTokArray[iParamEnd].token.tokClass == tokElem)
                break;
            iParamEnd--;
        }
        while (iParamEnd < iObjectEnd) // generally this will the previous token, but cover all cases
        {
            if (   pTokArray[iParamEnd].token.tok == TokTag_CLOSE
                && pTokArray[iParamEnd].token.tokClass == tokTag)
                break;
            iParamEnd++;
        }
        if (iParamEnd >= iObjectEnd) // error
            goto LSkipSave;
        cchParam = pTokArray[iParamEnd].token.ibTokMac - ichParam;
        ASSERT(cchParam > 0);

        // calculate ichObjStartEnd
        iObjTagEnd = iObjectStart;
        while (iObjTagEnd < iParamStart)
        {
            if (   pTokArray[iObjTagEnd].token.tok == TokTag_CLOSE
                && pTokArray[iObjTagEnd].token.tokClass == tokTag)
                break;
            iObjTagEnd++;
        }
        if (iObjTagEnd >= iParamStart) // error case
            goto LSkipSave;
        ichObjStartEnd = pTokArray[iObjTagEnd].token.ibTokMac;

        // realloc if needed
        cbNeed = (ichNewCur+cchParam+(ichObjStartEnd-ichBeginCopy)+wcslen(rgComment[0])+wcslen(rgComment[1]))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LSkipSave;

        // 1. copy <OBJECT ...> tag into pwNew
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichObjStartEnd-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichObjStartEnd-ichBeginCopy);
        ichBeginCopy = ichObjStartEnd;
#ifdef ERROR_PARAM
        // 2. now insert the <PARAM> tags as a comment at pwNew[ichNewCur]
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(rgComment[0]),
                wcslen(rgComment[0])*sizeof(WCHAR));
        ichNewCur += wcslen(rgComment[0]);

        // we should copy <PARAM> tags ONLY. We may have things other than the tags 
        // in between. e.g. comments
        // Look for TokElem_PARAM between iParamStart & iParamEnd
        ASSERT(pTokArray[iParamStart].token.tok == TokTag_START);
        ASSERT(pTokArray[iParamEnd].token.tok == TokTag_CLOSE);
        // Find PARAM tag, get the '<' & '>' for that PARAM and copy that to pwNew
        // repeat
        index = iParamStart;
        iPrev = iParamStart;
        while (index <= iParamEnd)
        {
            INT iStart, iEnd;

            iStart = iEnd = -1; // that way, its easy to make sure that this is initilized
            // get PARAM
            while (    (       pTokArray[index].token.tok != TokElem_PARAM
                            || pTokArray[index].token.tokClass != tokElem)
                    && (index <= iParamEnd)
                    )
                    index++;
            if (index > iParamEnd)
                goto LDoneCopy;
            // get '<' before the PARAM
            while (    (       pTokArray[index].token.tok != TokTag_START
                            || pTokArray[index].token.tokClass != tokTag)
                    && (index >= iPrev)
                    )
                    index--;
            if (index < iPrev)
                goto LDoneCopy;
            iStart = index;

            // get matching '>'
            while (    (       pTokArray[index].token.tok != TokTag_CLOSE
                            || pTokArray[index].token.tokClass != tokTag)
                    && (index <= iParamEnd)
                    )
                index++;

            if (index > iParamEnd)
                goto LDoneCopy;
            iEnd = index;
            ASSERT(iEnd > iStart);
            ASSERT(iStart != -1);
            ASSERT(iEnd != -1);
            memcpy( (BYTE *)(&pwNew[ichNewCur]),
                    (BYTE *)(&pwOld[pTokArray[iStart].token.ibTokMin]),
                    (pTokArray[iEnd].token.ibTokMac-pTokArray[iStart].token.ibTokMin)*sizeof(WCHAR));
            ichNewCur += (pTokArray[iEnd].token.ibTokMac-pTokArray[iStart].token.ibTokMin);
            iPrev = iEnd + 1;
        }
LDoneCopy:

        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(rgComment[1]),
                wcslen(rgComment[1])*sizeof(WCHAR));
        ichNewCur += wcslen(rgComment[1]);
#endif //ERROR_PARAM

        // fake iArraySav to be iObjTagEnd, that way we will st iArray correctly before we leave
        ASSERT(iObjTagEnd != -1);
        iArraySav = (UINT)iObjTagEnd;

LSkipSave:
        iArray = iArraySav + 1;
        goto LRet;
    }

LNoCopy:
    ichBeginCopy = ichObjectEnd; // set it for next copy
    iArray = iObjectEnd+1; // set it after </OBJECT>

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

//LRetOnly:
    return;

} /* fnSaveObject() */

void 
CTriEditParse::fnRestoreObject(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    // look for the special tag after the '<!--'
    // if we find it, this was an object, remove the comments around it
    // else simply copy the comment and return
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT iArraySav = iArray;
    INT ichCommentStart, ichCommentEnd, iCommentStart, iCommentEnd, cchComment1, cchComment2;
    INT ichObjectStart;
    LPCWSTR rgComment[] =
    {
        L"ERROROBJECT",
        L"--ERROROBJECT ",
        L" ERROROBJECT--",
        L"TRIEDITCOMMENT-",
        L"TRIEDITCOMMENTEND-",
        L"TRIEDITPRECOMMENT-",
    };
    BOOL fSimpleComment = FALSE;
    UINT cbNeed;

    ichCommentStart = ichCommentEnd = iCommentStart = iCommentEnd = 0;
    ASSERT(pTokArray[iArray].token.tok == TokTag_BANG); // we should be at the comment
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);

    // ASSUMPTION - that Trident doesn't muck with the contents inside a comment block

    // if rgComment[0] matches and rgComment[1] does not, Trident may have mucked with the 
    // comment contents. This invalidates our original assumption.
    // NOTE - In this version, we can get away by assuming that trident doesn't muck with the comments

    // early return cases
    // 1. see if this is a comment or not. It could be anything that starts with '<!'
    // e.g. <!DOCTYPE
    if (   (iArray+1 < (INT)ptep->m_cMaxToken)
        && (pwOld[pTokArray[iArray+1].token.ibTokMin] == '-')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+1] == '-')
        && (0 == _wcsnicmp(rgComment[0], &pwOld[pTokArray[iArray+1].token.ibTokMin+2], wcslen(rgComment[0])))
        )
    {
        iCommentStart = iArray; // this is a comment we are interested in
    }
    else if (      (iArray+1 < (INT)ptep->m_cMaxToken)
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] == '-')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin+1] == '-')
                && (0 == _wcsnicmp(rgComment[3], &pwOld[pTokArray[iArray+1].token.ibTokMin+2], wcslen(rgComment[3])))
                )
    {
        fSimpleComment = TRUE; // BUG 14056 - Instead of going to LRet, process the comment for space preservation. We will save 3 strings that look similar to text run
    }
    else
    {
        iArray = iArraySav + 1; // not this one
        goto LRet;
    }
    // The first part matched, look at the end of the comment
    if (   (pwOld[pTokArray[iArray+1].token.ibTokMac-1] == '-')
        && (pwOld[pTokArray[iArray+1].token.ibTokMac-2] == '-')
        && (0 == _wcsnicmp( rgComment[0], 
                            &pwOld[pTokArray[iArray+1].token.ibTokMac-(wcslen(rgComment[0])+2)], 
                            wcslen(rgComment[0])
                            )
                        )
        )
    {
        iCommentEnd = iArray + 2;
        ASSERT(iCommentEnd < (INT)ptep->m_cMaxToken);
    }
    else // error case (our assumption was not valid). ignore and return with iArraySav+1
    {
        if (!fSimpleComment)
        {
            iArray = iArraySav + 1; // not this one
            goto LRet;
        }
    }

    if (!fSimpleComment)
    {
        // found the correct one
        cchComment1 = wcslen(rgComment[1]);
        cchComment2 = wcslen(rgComment[2]);
        // remove cchComment1 chars from begining of pwOld[pTokArray[iArray+1].token.ibTokMin
        // remove cchComment2 chars from the end of pwOld[pTokArray[iArray+1].token.ibTokMac
        // and copy the rest into pwNew

        // copy till begining of the comment
        ichCommentStart = pTokArray[iCommentStart].token.ibTokMin;
        ichObjectStart = pTokArray[iCommentStart+1].token.ibTokMin+cchComment1;
        ASSERT((INT)ichCommentStart-ichBeginCopy >= 0);

        cbNeed = (ichNewCur+(ichCommentStart-ichBeginCopy)+(pTokArray[iArray+1].token.ibTokMac-pTokArray[iArray+1].token.ibTokMin))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;

        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(pwOld+ichBeginCopy),
                (ichCommentStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += ichCommentStart-ichBeginCopy;
        ichBeginCopy = pTokArray[iCommentEnd].token.ibTokMac;

        ASSERT((INT)(pTokArray[iArray+1].token.ibTokMac-pTokArray[iArray+1].token.ibTokMin-cchComment1-cchComment2) >= 0);
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)&(pwOld[ichObjectStart]),
                (pTokArray[iArray+1].token.ibTokMac-pTokArray[iArray+1].token.ibTokMin-cchComment1-cchComment2)*sizeof(WCHAR));
        ichNewCur += pTokArray[iArray+1].token.ibTokMac-pTokArray[iArray+1].token.ibTokMin-cchComment1-cchComment2;
        iArray = iCommentEnd + 1;
    }
    else
    {
        int ichspBegin, ichspEnd, ichCopy;
        WCHAR *pwstr = NULL;

        // part 1 - copy till begining of the comment & apply spacing
        iCommentStart = iArraySav;
        ASSERT(pTokArray[iArraySav].token.tok == TokTag_BANG);
        ASSERT(pTokArray[iArraySav].token.tokClass == tokTag);

        iCommentEnd = iCommentStart + 2;
        ASSERT(pTokArray[iCommentEnd].token.tok == TokTag_CLOSE);
        ASSERT(pTokArray[iCommentEnd].token.tokClass == tokTag);

        ichCommentStart = pTokArray[iCommentStart].token.ibTokMin;
        ASSERT((INT)ichCommentStart-ichBeginCopy >= 0);
        cbNeed = (ichNewCur+ichCommentStart-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        memcpy( (BYTE *)&pwNew[ichNewCur],
                (BYTE *)&pwOld[ichBeginCopy],
                (ichCommentStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += ichCommentStart-ichBeginCopy;

        // make sure that we have enough space
        // to make this calculation simple, we assume the extreme case where every
        // character in the comment had end of line after it. i.e. we will insert
        // 2 characters ('\r\n') after each character in the comment when we restore 
        // the spacing. That means, as long as we have enough space for
        // (pTokArray[iCommentEnd].token.ibTokMac-pTokArray[iCommentStart].token.ibTokMin)*3
        // we are fine
        cbNeed = (ichNewCur+3*(pTokArray[iCommentEnd].token.ibTokMac-pTokArray[iCommentStart].token.ibTokMin))*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;

        
        // apply spacing for pre comment part
        // remove extsting spacing before the comment & add the saved spacing
        // note that we already have copied till the begining of the comment
        ichNewCur--;
        while (    (   pwNew[ichNewCur] == ' '  || pwNew[ichNewCur] == '\t'
                    || pwNew[ichNewCur] == '\r' || pwNew[ichNewCur] == '\n'
                    )
                )
        {
            ichNewCur--;
        }
        ichNewCur++; // compensate, ichNewCur points to non-white space characher
        // now, start writing out the saved spacing
        // look for rgComment[4] & rgComment[5]
        ichspBegin = pTokArray[iCommentStart+1].token.ibTokMin + 2/*for --*/ + wcslen(rgComment[3]);
        pwstr = wcsstr(&pwOld[ichspBegin], rgComment[4]);// pwstr points just after the spacing info block
        if (pwstr == NULL) // didn't find the substring
        {
            // copy the entire comment as is
            memcpy( (BYTE *)&pwNew[ichNewCur],
                    (BYTE *)&pwOld[pTokArray[iCommentStart+1].token.ibTokMin],
                    (pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2)*sizeof(WCHAR));
            ichNewCur += pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2;
            goto LCommentEnd;
        }
        ichspBegin = SAFE_PTR_DIFF_TO_INT(pwstr+wcslen(rgComment[4])-pwOld);
        pwstr = wcsstr(&pwOld[ichspBegin], rgComment[5]);// pwstr points just after the spacing info block
        if (pwstr == NULL) // didn't find the substring
        {
            // copy the entire comment as is
            memcpy( (BYTE *)&pwNew[ichNewCur],
                    (BYTE *)&pwOld[pTokArray[iCommentStart+1].token.ibTokMin],
                    (pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2)*sizeof(WCHAR));
            ichNewCur += pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2;
            goto LCommentEnd;
        }
        ichCopy = SAFE_PTR_DIFF_TO_INT(pwstr-pwOld) + wcslen(rgComment[5]); // actual comment begins at ichCopy
        ichspEnd = SAFE_PTR_DIFF_TO_INT(pwstr-pwOld);
        ASSERT(ichspEnd >= ichspBegin);
        while (ichspBegin < ichspEnd)
        {
            switch(pwOld[ichspBegin])
            {
            case chCommentSp:
                pwNew[ichNewCur++] = ' ';
                break;
            case chCommentTab:
                pwNew[ichNewCur++] = '\t';
                break;
            case chCommentEOL:
                pwNew[ichNewCur++] = '\r';
                pwNew[ichNewCur++] = '\n';
                break;
            case ',':
                ASSERT(FALSE);
                break;
            }
            ichspBegin++;
        }
        // now pre comment spacing is restored
        

        pwNew[ichNewCur++] = '<';
        pwNew[ichNewCur++] = '!';
        pwNew[ichNewCur++] = '-';
        pwNew[ichNewCur++] = '-';

        // part 2 - copy the comment and apply spacing
        // from pTokArray[iCommentStart+1].token,ibTokMIn, look for rgComment[4]
        // thats where we keep our spacing info. Exclude this stuff while copying the comment
        ichspBegin = pTokArray[iCommentStart+1].token.ibTokMin + 2/*for --*/ + wcslen(rgComment[3]);
        // locate rgComment[4] that will be somewhere in iCommentStart'th token
        pwstr = wcsstr(&pwOld[ichspBegin], rgComment[4]);// pwstr points just after the spacing info block
        if (pwstr == NULL) // didn't find the substring
        {
            // copy the entire comment as is
            memcpy( (BYTE *)&pwNew[ichNewCur],
                    (BYTE *)&pwOld[pTokArray[iCommentStart+1].token.ibTokMin],
                    (pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2)*sizeof(WCHAR));
            ichNewCur += pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2;
            goto LCommentEnd;
        }
        ichspEnd = SAFE_PTR_DIFF_TO_INT(pwstr - pwOld);
        ASSERT(ichspEnd >= ichspBegin);

        while (ichspBegin < ichspEnd)
        {
            switch(pwOld[ichspBegin])
            {
            case chCommentSp:
                pwNew[ichNewCur++] = ' ';
                break;
            case chCommentTab:
                pwNew[ichNewCur++] = '\t';
                break;
            case chCommentEOL:
                pwNew[ichNewCur++] = '\r';
                pwNew[ichNewCur++] = '\n';
                break;
            case ',':
                while (    pwOld[ichCopy] == ' '    || pwOld[ichCopy] == '\t'
                        || pwOld[ichCopy] == '\r'   || pwOld[ichCopy] == '\n'
                        )
                {
                    if (ichCopy >= (int)(pTokArray[iCommentStart+1].token.ibTokMac-2)) // we are done with copying
                        goto LCommentEnd;
                    ichCopy++;
                }
                while (    pwOld[ichCopy] != ' '    && pwOld[ichCopy] != '\t'
                        && pwOld[ichCopy] != '\r'   && pwOld[ichCopy] != '\n'
                        )
                {
                    if (ichCopy >= (int)(pTokArray[iCommentStart+1].token.ibTokMac-2)) // we are done with copying
                        goto LCommentEnd;
                    pwNew[ichNewCur++] = pwOld[ichCopy++];
                }
                break;
            }
            ichspBegin++;
        }

LCommentEnd:
        // part 3 - copy the end of comment
        pwNew[ichNewCur++] = '-';
        pwNew[ichNewCur++] = '-';
        pwNew[ichNewCur++] = '>';

        // set iArray & ichBeginCopy for next run
        ichBeginCopy = pTokArray[iCommentEnd].token.ibTokMac;
        iArray = iCommentEnd + 1;
    }

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

//LRetOnly:
    return;

} /* fnRestoreObject()*/


void 
CTriEditParse::fnSaveSpace(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT iArray = (INT)*piArrayStart;
    INT ichEnd, ichBegin;
    LPWSTR pwNew = *ppwNew;
    INT iArraySav = iArray;
    LPCWSTR rgSpaceTags[] =
    {
        L" DESIGNTIMESP=",
        L" DESIGNTIMESP1=",
        L" designtimesp=",
    };
    INT iArrayElem = -1;
    INT iArrayMatch, iArrayPrevTag;
    INT ichEndMatch, ichBeginMatch, ichEndPrev, ichBeginPrev, ichEndNext, ichBeginNext, ichEndTag, ichBeginTag;
    WCHAR szIndex[cchspBlockMax]; // will we have more than 20 digit numbers as number of DESIGNTIMESPx?
    UINT cbNeed;
    int cchURL = 0;
    int ichURL = 0;

    //  {-1, TokTag_START, tokTag, TokTag_CLOSE, -1, tokClsIgnore, fnSaveSpace},

    ASSERT(dwFlags &dwPreserveSourceCode);

    // special cases where we don't need to save spacing, because Trident doesn't muck with 
    // the spacing in these cases. If this changes in future, remove these cases.
    // If this case is removed, then make sure that fnSaveObject() changes accordingly
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (pTokArray[iArray+1].token.tok == TokElem_OBJECT)
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is an OBJECT tag
        iArray = iArraySav + 1;
        goto LRet;
    }
    // trident munges custom attributes inside STYLE tag, so DESIGNTIMESP gets out of place
    // so lets not save any spacing info for TokElem_STYLE
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (pTokArray[iArray+1].token.tok == TokElem_STYLE)
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is an STYLE tag
        iArray = iArraySav + 1;
        goto LRet;
    }
    // trident overwrites PARAM tags, so we can skip saving spacing info
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (pTokArray[iArray+1].token.tok == TokElem_PARAM)
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is an PARAM tag
        iArray = iArraySav + 1;
        goto LRet;
    }

    // we should skip saving for <applet>
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (   pTokArray[iArray+1].token.tok == TokElem_APPLET
            )
            && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is an APPLET tag
        iArray = iArraySav + 1;
        goto LRet;
    }
    // we special case textarea tags, so we should skip saving spacing info
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (pTokArray[iArray+1].token.tok == TokElem_TEXTAREA)
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        )
    {
        // (iArray+1)th token is TEXTAREA tag
        iArray = iArraySav + 1;
        goto LRet;
    }
    // we special case A/IMG/LINK tags with Relative URLs ONLY, so we should skip saving spacing info
    if (   (iArray+1 < (INT)ptep->m_cMaxToken) /* validation */
        && (   pTokArray[iArray+1].token.tok == TokElem_A
            || pTokArray[iArray+1].token.tok == TokElem_IMG
            || pTokArray[iArray+1].token.tok == TokElem_LINK
            )
        && (pTokArray[iArray+1].token.tokClass == tokElem)
        && (FURLNeedSpecialHandling(pTokArray, iArray, pwOld, (int)ptep->m_cMaxToken, &ichURL, &cchURL))
        )
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // step 1
    // look for > that matches with <. we already are at ft.tokBegin2 i.e. <
    ASSERT(pTokArray[iArray].token.tok == TokTag_START);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    ichBeginTag = pTokArray[iArray].token.ibTokMac;
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (pTokArray[iArray].token.tok == ft.tokEnd && pTokArray[iArray].token.tokClass == tokTag) // ft.tokEnd2 is -1
            break;
        if (pTokArray[iArray].token.tokClass == tokElem)
            iArrayElem = iArray;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // didn't find >
    {
        goto LRet;
    }
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE); // found >
    ASSERT(pTokArray[iArray].token.tokClass == tokTag); // found >
    ichEndTag = ichBegin = pTokArray[iArray].token.ibTokMin;
    ichEnd = pTokArray[iArray].token.ibTokMac;

    // step 2
    // look for > before iArraySav. Boundary case will be for the first < in the document
    // save the spacing info
    ASSERT(pTokArray[iArraySav].token.tok == TokTag_START);
    ASSERT(pTokArray[iArraySav].token.tokClass == tokTag);
    ichEndPrev = pTokArray[iArraySav].token.ibTokMin;
    ichBeginPrev = ichEndPrev-1;
    // look for previous TokTag_CLOSE
    // if the tag ending tag, ichBeginPrev becomes ibTokMac of '>' tag
    // if the tag is starting tag, ichBeginPrev becomes ibTokMac+(white space just after that tag)
    iArrayPrevTag = iArraySav; // this is TokTag_START
    while (iArrayPrevTag >= 0)
    {
        if (       (   pTokArray[iArrayPrevTag].token.tokClass == tokTag 
                    && pTokArray[iArrayPrevTag].token.tok == TokTag_CLOSE
                    )
                || (   pTokArray[iArrayPrevTag].token.tokClass == tokSSS 
                    && pTokArray[iArrayPrevTag].token.tok == TokTag_SSSCLOSE
                    )/* VID6 - bug 22787 */
                )
        {
            break;
        }
        iArrayPrevTag--;
    }
    if (iArrayPrevTag < 0) // handle error case
    {
        // leave the old behaviour as is for V1
        while (ichBeginPrev >= 0)
        {
            if (   pwOld[ichBeginPrev] != ' '
                && pwOld[ichBeginPrev] != '\r'
                && pwOld[ichBeginPrev] != '\n'
                && pwOld[ichBeginPrev] != '\t'
                )
                break;
            ichBeginPrev--;
        }
        goto LGotEndNext;
    }
    ichBeginPrev = pTokArray[iArrayPrevTag].token.ibTokMac - 1;

LGotEndNext:
    if (ichBeginPrev < 0)
        ichBeginPrev = 0;
    else
        ichBeginPrev++;


    // step 3
    // look for TokTag_START after iArray(which currently is TokTag_CLOSE)
    // save spacing info
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    //iArrayNextStart = iArray;
    ichBeginNext = pTokArray[iArray].token.ibTokMac;
    ASSERT(ichBeginNext == ichEnd);
    ichEndNext = ichBeginNext;
    while (ichEndNext < (INT)pTokArray[ptep->m_cMaxToken-1].token.ibTokMac)
    {
        if (   pwOld[ichEndNext] != ' '
            && pwOld[ichEndNext] != '\r'
            && pwOld[ichEndNext] != '\n'
            && pwOld[ichEndNext] != '\t'
            )
            break;
        ichEndNext++;
    }

    if (ichEndNext >= (INT)pTokArray[ptep->m_cMaxToken-1].token.ibTokMac)
        ichEndNext = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac;

    // step 4
    // if iArrayElem != -1, look for pTokArray[iArrayElem].iNextprev. If its not -1, set iArrayMatch
    // look for previous TokTag_START/TokTag_END. look for previous TokTag_CLOSE
    // save spacing info
    if (iArrayElem == -1) // this can happen if we have incomplete HTML
    {
        ichEndMatch = ichBeginMatch = 0;
        goto LSkipMatchCalc;
    }
    iArrayMatch = pTokArray[iArrayElem].iNextprev;
    if (iArrayMatch != -1) // match was set while tokenizing
    {
        ichBeginMatch = ichEndMatch = 0; //init
        ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
        ASSERT(pTokArray[iArray].token.tokClass == tokTag);
        while (iArrayMatch >= iArray) // iArray is TokTag_CLOSE of the current tag (i.e. '>')
        {
            if (   pTokArray[iArrayMatch].token.tokClass == tokTag
                && (   pTokArray[iArrayMatch].token.tok == TokTag_START
                    || pTokArray[iArrayMatch].token.tok == TokTag_END
                    )
                )
                break;
            iArrayMatch--;
        }
        if (iArrayMatch > iArray) // did find '</' or '<' after the current tag
        {
            ichEndMatch = pTokArray[iArrayMatch].token.ibTokMin;
            ichBeginMatch = ichEndMatch; // init
            // look for '>' and set ichBeginMatch
            while (iArrayMatch >= iArray) // iArray is TokTag_CLOSE of the current tag (i.e. '>')
            {
                if (   (   pTokArray[iArrayMatch].token.tokClass == tokTag
                        && pTokArray[iArrayMatch].token.tok == TokTag_CLOSE
                        )
                    || (   pTokArray[iArrayMatch].token.tokClass == tokSSS
                        && pTokArray[iArrayMatch].token.tok == TokTag_SSSCLOSE
                        )/* VID6 - bug 22787 */
                    )
                    break;
                iArrayMatch--;
            }
            if (iArrayMatch >= iArray) // they may very well be the same
            {
                ichBeginMatch = pTokArray[iArrayMatch].token.ibTokMac;
                ASSERT(ichBeginMatch <= ichEndMatch);
                ASSERT(ichBeginMatch >= ichEnd);
            }
        }
    }
    else
    {
        // don't bother saving any info from here
        ichEndMatch = ichBeginMatch = 0;
    }
LSkipMatchCalc:
    if (ichEndPrev > ichBeginPrev)
        ptep->hrMarkSpacing(pwOld, ichEndPrev, &ichBeginPrev);
    else
        ptep->hrMarkSpacing(pwOld, ichEndPrev, &ichEndPrev);

    if (ichEndTag > ichBeginTag)
    {
        INT ichBeginTagSav = ichBeginTag;

        ptep->hrMarkSpacing(pwOld, ichEndTag, &ichBeginTag);
        // iArray'th token is TokTag_CLOSE & iArraySav is TokTag_START
        ptep->hrMarkOrdering(pwOld, pTokArray, iArraySav, iArray, ichEndTag, &ichBeginTagSav);
    }
    else
    {
        INT ichEndTagSav = ichEndTag;

        ptep->hrMarkSpacing(pwOld, ichEndTag, &ichEndTag);
        // iArray'th token is TokTag_CLOSE & iArraySav is TokTag_START
        ptep->hrMarkOrdering(pwOld, pTokArray, iArraySav, iArray, ichEndTagSav, &ichEndTagSav);
    }

    if (ichEndNext > ichBeginNext)
        ptep->hrMarkSpacing(pwOld, ichEndNext, &ichBeginNext);
    else
        ptep->hrMarkSpacing(pwOld, ichEndNext, &ichEndNext);

    if (ichEndMatch > ichBeginMatch)
        ptep->hrMarkSpacing(pwOld, ichEndMatch, &ichBeginMatch);
    else
        ptep->hrMarkSpacing(pwOld, ichEndMatch, &ichEndMatch);



    // realloc if needed
    cbNeed = (ichNewCur+ichBegin-ichBeginCopy+3*wcslen(rgSpaceTags[0])+(ichEnd-ichBegin))*sizeof(WCHAR);
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LErrorRet;
    // ichBeginCopy is a position in pwOld and
    // ichNewCur is a position in pwNew
    // copy from ichBeginCopy to >
    ASSERT((INT)(ichBegin-ichBeginCopy) >= 0);
    if ((INT)(ichBegin-ichBeginCopy) > 0)
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(pwOld+ichBeginCopy),
                (ichBegin-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichBegin-ichBeginCopy);
    }
    ichBeginCopy = ichEnd; // make it ready for next copy

    // BUG 15389 - Ideal fix will be to save the exact tag and restore it when we switch back,
    // but it will be a bigger change at this point, So we simply look at first character of the tag.
    // If it is uppercase, write DESIGNTIMESP, else write designtimesp
    // ASSUMPTION is that Trident doesn't change the case of unknown attribute & so far its TRUE.
    // ASSUMPTION is that we don't have extra spaces between '<' & the tag name.
    ASSERT(wcslen(rgSpaceTags[0]) == wcslen(rgSpaceTags[2]));
    if (iswupper(pwOld[pTokArray[iArraySav+1].token.ibTokMin]) != 0) // upper case
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[0]),
                (wcslen(rgSpaceTags[0]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[0]);
    }
    else
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[2]),
                (wcslen(rgSpaceTags[2]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[2]);
    }

    (WCHAR)_itow(ptep->m_ispInfoBlock+ptep->m_ispInfoBase, szIndex, 10);
    ptep->m_ispInfoBlock++;

    ASSERT(wcslen(szIndex) < sizeof(szIndex));
    ASSERT(sizeof(szIndex) == cchspBlockMax*sizeof(WCHAR));
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(szIndex),
            wcslen(szIndex)*sizeof(WCHAR));
    ichNewCur += wcslen(szIndex);


    // if (m_ispInfoIn == 0), then we have the last block of SPINFO, lets save it here
    if (ptep->m_ispInfoIn == 0)
    {
        ASSERT(FALSE);
        // realloc if needed
        cbNeed = (ichNewCur+ichBegin-ichBeginCopy+2*wcslen(rgSpaceTags[1]))*sizeof(WCHAR);
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LErrorRet;
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[1]),
                (wcslen(rgSpaceTags[1]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[1]);

        *(WCHAR *)(pwNew+ichNewCur) = 'Z'; // ptep->m_ispInfoIn;
        ichNewCur++;
    }

    ASSERT((INT)(ichEnd-ichBegin) > 0);
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+ichBegin),
            (ichEnd-ichBegin)*sizeof(WCHAR));
    ichNewCur += (ichEnd-ichBegin);

    // restore iArray
    iArray = iArraySav+1;

LErrorRet:
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = (UINT)iArray;
} /* fnSaveSpace() */


void
CTriEditParse::fnRestoreSpace(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT iArray = (INT)*piArrayStart;
    UINT ichBegin, ichspInfoEndtagEnd;
    LPWSTR pwNew = *ppwNew;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
        L"DESIGNTIMESP1",
    };
    INT iArraySav = iArray;
    WORD *pspInfoEnd, *pspInfoOrder;
    INT cchwspInfo; // spInfo block size in wide chars
    INT cchRange; // number of char for which this spInfo was saved
    BOOL fMatch = FALSE;
    BOOL fMatchLast = FALSE;
    INT cchtok, cchtag, itoktagStart, ichtoktagStart, iArrayValue, index;
    WCHAR szIndex[cchspBlockMax];
    INT cwOrderInfo = 0;
    UINT cbNeed;
    INT ichNewCurSav = -1; // init to -1 so that we will know when its set.
    int ichNewCurAtIndex0 = -1; // we need to adjust the saved ichNewCur because it gets invalidated
                                // as soon as the tag moves as a result of restoring pre-tag spaces.
    
    ASSERT(dwFlags & dwPreserveSourceCode);

    // take care of the matching end token's spacing
    if (       pTokArray[iArray].token.tok == ft.tokBegin2
            && pTokArray[iArray].token.tokClass == tokTag
            )
    {
        ASSERT(ft.tokBegin2 == TokTag_END);
        fnRestoreSpaceEnd(  ptep, pwOld, ppwNew, pcchNew, phgNew, pTokArray, piArrayStart, 
                            ft, pcHtml, pichNewCur, pichBeginCopy, dwFlags);
        goto LRetOnly;

    }

    // we already are at (token.tok == tokSpace), which may be DESIGNTIMESPx
    ASSERT(pTokArray[iArray].token.tok == 0);
    ASSERT(pTokArray[iArray].token.tokClass == tokSpace);
    cchtok = pTokArray[iArray].token.ibTokMac - pTokArray[iArray].token.ibTokMin;
    cchtag = wcslen(rgSpaceTags[0]);
    if (cchtag == cchtok)
    {
        if (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[iArray].token.ibTokMin], cchtag))
        {
            fMatch = TRUE;// match
        }
        else
            goto LNoMatch;
    }
    else if (cchtag+1 == cchtok)
    {
        if (0 == _wcsnicmp(rgSpaceTags[1], &pwOld[pTokArray[iArray].token.ibTokMin], cchtag+1))
        {
            fMatchLast = TRUE;// match
        }
        else
            goto LNoMatch;
    }
    else
    {
LNoMatch:
        iArray = iArraySav + 1;
        goto LRet;
    }

    ASSERT(fMatch || fMatchLast); // one of them has to be TRUE
    // found DESIGNTIMESPx. Now, go backwords and look for ft.tokBegin
    itoktagStart = iArray;
    ASSERT(ft.tokBegin == TokTag_START);
    while (itoktagStart >= 0)
    {
        if (       pTokArray[itoktagStart].token.tok == ft.tokBegin
                && pTokArray[itoktagStart].token.tokClass == tokTag
                )
        {
            break;
        }
        itoktagStart--;
    }
    if (itoktagStart < 0) // didn't find '<' before DESIGNTIMESPx
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // found '<' before DESIGNTIMESPx
    // the spacing info saved was for the portion of the document before the '<'
    ASSERT(pTokArray[itoktagStart].token.tok == TokTag_START);
    ASSERT(pTokArray[itoktagStart].token.tokClass == tokTag);
    // we already know that iArray'th token is DESIGNTIMESPx, so get past the '=' that follows it
    // ASSUMPTION - the value of attribute DESIGNTIMESPx will NOT get munged by Trident.
    // NOTE - the above assumption is correct for this release of Trident
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '=')
        {
            ASSERT(pTokArray[iArray].token.tokClass == tokOp);
            break;
        }
        else if (*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '>') // gone too far
            goto LSkip1;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // didn't find = after DESIGNTIMESPx
    {
LSkip1:
        iArray = iArraySav + 1;
        goto LRet;
    }
    iArrayValue = -1;
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   (iArrayValue == -1)
            && (   (pTokArray[iArray].token.tokClass == tokValue)
                || (pTokArray[iArray].token.tokClass == tokString)
                )
            )
            iArrayValue = iArray;
        else if (      pTokArray[iArray].token.tok == TokTag_CLOSE
                    && pTokArray[iArray].token.tokClass == tokTag
                    )
        {
            ASSERT(*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '>');
            break;
        }
        iArray++;
    }
    if (iArrayValue == -1 || iArray >= (int)ptep->m_cMaxToken) // didn't find tokValue after DESIGNTIMESPx
    {
        // BUG 9040
        //if (iArray >= (int)ptep->m_cMaxToken && iArrayValue != -1)
        //{
            // SOLUTION 1
            // overwrite the stuff from pwOld[pTokArray[iArraySav].token.ibTokMin]
            // to pwOld[pTokArray[iArrayValue].token.ibTokMac - 1]
            // SOLUTION 2
            // look for DESIGNTIMESP from pwOld[pTokArray[itokTagStart].token.ibTokMac - 1]
            // to pwOld[pTokArray[iArray].token.ibTokMac - 1] and overwrite all of those 
            // strings with spaces. We could NULL those and do the blts, but why bother
            // when the html isn't valid! 

            // make sure that all DESIGNTIMESPs are stripped off if we encountered this error case
        //}
        iArray = iArraySav + 1;
        goto LRet;
    }

    // we know that 4 blocks of info was saved for each DESIGNTIMESPx attribute
    // before tag, within tag, after tag, before matching end-tag
    // even if no info was saved, the block will still exist with 2 words (size,# of char)
    ichspInfoEndtagEnd = pTokArray[iArray].token.ibTokMac;

    // first copy the document till DESIGNTIMESPx
    // skip DESIGNTIMESPx and its value and set ichBeginCopy to be after that

    // NOTE - token before iArraySav'th one should be tokSpace with lenght 1 
    // and with a value of chSpace (unless Trident has modified it). If thats TRUE,
    // we should skip that too, because we added it when we put in DESIGNTIMESPx.
    
    // fix Trident's behaviour - If Trident sees unknown tag(s) it puts it(them) at the end 
    // and inserts EOL before those. In this case, we would have inserted a space before DESIGNTIMESP
    // and Trident would have inserted EOL. If thats not the case, we will ignore it.
    if (   (iArraySav-1 > 0) /* validation */
        && (    (      (pTokArray[iArraySav-1].token.ibTokMac - pTokArray[iArraySav-1].token.ibTokMin == 1)
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin] == ' ')
                    )
            ||  (      (pTokArray[iArraySav-1].token.ibTokMac - pTokArray[iArraySav-1].token.ibTokMin == 3)
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin] == ' ')
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin+1] == '\r')
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin+2] == '\n')
                    )
                )
        )
    {
        ichBegin = pTokArray[iArraySav-1].token.ibTokMin;
    }
    else
        ichBegin = pTokArray[iArraySav].token.ibTokMin;
    ASSERT(ichBegin >= ichBeginCopy);

    cbNeed = (ichNewCur+(ichBegin-ichBeginCopy))*sizeof(WCHAR) + cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // BUG 15389 - look at the case of DESIGNTIMESP & convert the tag into upper/lower case...
    //memcpy(   (BYTE *)(pwNew+ichNewCur),
    //      (BYTE *)(pwOld+ichBeginCopy),
    //      (ichBegin-ichBeginCopy)*sizeof(WCHAR));
    //ichNewCur += (ichBegin-ichBeginCopy);
    if (ichBegin >= ichBeginCopy )
    {
        // step 1 - copy from ichBeginCopy to '<' of the current tag
        if ((int)(pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy) > 0)
        {
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+ichBeginCopy),
                    (pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy);
            ichNewCurSav = ichNewCur+1; // used as a peg to get preceding tokTag_START i.e. '<'
        }
        // step 2 - convert current tag into upper/lower case & copy it
        if (ichBeginCopy < pTokArray[itoktagStart+1].token.ibTokMin)
        {
            ASSERT((int)(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin) > 0);
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+pTokArray[itoktagStart+1].token.ibTokMin),
                    (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)*sizeof(WCHAR));
            if (iswupper(pwOld[pTokArray[iArraySav].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
            {
                // convert the tag into upper case. ASSUME that the tag is at itoktagStart+1
                _wcsupr(&pwNew[ichNewCur]);
            }
            else
            {
                // convert the tag into lower case. ASSUME that the tag is at itoktagStart+1
                _wcslwr(&pwNew[ichNewCur]);
            }
            ichNewCur += (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin);
        }
        else // this tag is alreay been copied
        {
            // hack
            if (pTokArray[itoktagStart+1].token.ibTokMac == ichBeginCopy) // means we are just past the current tag
            {
                if (iswupper(pwOld[pTokArray[iArraySav].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
                {
                    ASSERT(ichNewCur >= (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin));
                    // convert the tag into upper case. ASSUME that the tag is at itoktagStart+1
                    _wcsupr(&pwNew[ichNewCur-(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)]);
                }
                else
                {
                    ASSERT(ichNewCur >= (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin));
                    // convert the tag into lower case. ASSUME that the tag is at itoktagStart+1
                    _wcslwr(&pwNew[ichNewCur-(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)]);
                }
            }
        }
        // step 3 - copy from after the tag (which is at ichtoktagStart+1) to ichBegin
        if ((int)(ichBegin-pTokArray[itoktagStart+1].token.ibTokMac) > 0)
        {
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+pTokArray[itoktagStart+1].token.ibTokMac),
                    (ichBegin-pTokArray[itoktagStart+1].token.ibTokMac)*sizeof(WCHAR));
            ichNewCur += (ichBegin-pTokArray[itoktagStart+1].token.ibTokMac);
        }
    }
    // set ichBeginCopy
    ichBeginCopy = ichspInfoEndtagEnd; // make it ready for next copy

    // copy the rest of the tag (skipping DESIGNTIMESPx = value)
    ASSERT((INT)(ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac) >= 0);
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMac),
            (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac)*sizeof(WCHAR));
    ichNewCur += (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac);
    
    memset((BYTE *)szIndex, 0, sizeof(szIndex));
    // check if the value has quotes around it and don't copy them to szIndex
    if (   pwOld[pTokArray[iArrayValue].token.ibTokMin] == '"'
        && pwOld[pTokArray[iArrayValue].token.ibTokMac-1] == '"'
        )
    {
        memcpy( (BYTE *)szIndex,
                (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin+1),
                (pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin-2)*sizeof(WCHAR));
    }
    else
    {
        memcpy( (BYTE *)szIndex,
                (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin),
                (pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin)*sizeof(WCHAR));
    }
    ptep->m_ispInfoBlock = _wtoi(szIndex);
    ptep->m_ispInfoBlock -= ptep->m_ispInfoBase;
    if (ptep->m_ispInfoBlock < 0)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // NOTE - we can cache this info in a link list at the begining
    // get to the ptep->m_ispInfoBlock'th block from ptep->m_pspInfoOutStart
    ASSERT(ptep->m_cchspInfoTotal >= 0);
    pspInfoEnd = ptep->m_pspInfoOutStart + ptep->m_cchspInfoTotal;
    ptep->m_pspInfoOut = ptep->m_pspInfoOutStart;
    for (index = 0; index < ptep->m_ispInfoBlock; index++)
    {
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before <
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // between <>
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // Order Info
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // after >
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before matching </

        // we somehow have gone beyond the data that was saved for spacing
        if (ptep->m_pspInfoOut >= pspInfoEnd)
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    }

    // get the Order Info
    pspInfoOrder = ptep->m_pspInfoOut;
    pspInfoOrder += *(WORD *)pspInfoOrder; // skip info saved for spacing before '<'
    pspInfoOrder += *(WORD *)pspInfoOrder; // skip info saved for spacing between '<>'
    // now pspInfoOrder is at correct place
    cwOrderInfo = *(WORD *)pspInfoOrder++;
    ASSERT(cwOrderInfo >= 1);
    // process this info
    if (cwOrderInfo > 1) // means that we saved some info
    {
        INT cchNewCopy;

        cchNewCopy = (ichBegin-pTokArray[itoktagStart].token.ibTokMin) + (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac);
        ptep->FRestoreOrder(pwNew, pwOld, pspInfoOrder, &ichNewCur, cwOrderInfo, pTokArray, itoktagStart, iArray, iArraySav, iArrayValue, cchNewCopy, phgNew);
    }
    ichtoktagStart = ichNewCur; // init
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    for (index = 0; index < 4; index++)
    {
        BOOL fLookback = FALSE;

        cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
        cchRange = *(WORD *)ptep->m_pspInfoOut++;
        if (cchwspInfo == 2) // we didn't save any spacing info
        {
            if (index == 0) // special case BUG 8741
            {
                // Note that we didn't save anything before this tag. which means that
                // we had '>' or some text immediately before the < tag. 
                ichtoktagStart = ichNewCur;
                while (ichtoktagStart >= 0)
                {
                    if (pwNew[ichtoktagStart] == '<')
                    {
                        ichtoktagStart--;
                        break;
                    }
                    ichtoktagStart--;
                }
                if (ichtoktagStart >= 0)
                {
                    int cws = 0;
                    int ichtagStart = ichtoktagStart;

                    // remove any such white space trident inserts.
                    while (    pwNew[ichtoktagStart] == ' '
                            || pwNew[ichtoktagStart] == '\r'
                            || pwNew[ichtoktagStart] == '\n'
                            || pwNew[ichtoktagStart] == '\t')
                    {
                        cws++;
                        ichtoktagStart--;
                    }
                    if (cws > 0)
                    {
                        ASSERT((int)(ichNewCur-ichtagStart-1) >= 0);
                        //ichtokTagStart now points to either '>' or a non-whitespace char
                        memmove((BYTE*)&pwNew[ichtoktagStart+1],
                                (BYTE*)&pwNew[ichtoktagStart+1+cws],
                                (ichNewCur-ichtagStart-1)*sizeof(WCHAR));
                        ichNewCur -= cws;
                    }
                } // if (ichtoktagStart >= 0)
            } // if (index == 0)
            goto LNext;
        }

        // note that ichtoktagStart is a position in pwNew
        switch (index)
        {
        case 0: // before < of the tag
            fLookback = TRUE;
            ichtoktagStart = (ichNewCurSav == -1)?ichNewCur:ichNewCurSav;// handle < ... <%..%>...> case correctly
            ichNewCurAtIndex0 = ichNewCur; // lets save the ichNewCur before we restore pre-tag spacing
            while (ichtoktagStart >= 0)
            {
                if (pwNew[ichtoktagStart] == '<' && pwNew[ichtoktagStart+1] != '%')
                {
                    ichtoktagStart--;
                    break;
                }
                ichtoktagStart--;
            }
            if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
            {
                ptep->m_pspInfoOut += cchwspInfo-2;
                continue;
            }
            break;
        case 1: // between <> of the tag
            fLookback = FALSE;
            // NOTE - we can assume that in 'case 0' we had put ichtoktagStart is just before '<'
            // so that we can avoid this while loop. but what if we skipped case '0'?

            // adjust ichNewCurSav to reflect the pre-tag spacing so that it doesn't become invalid
            // we may need to adjust it in ichNewCur-ichNewCurAtIndex0 < 0 case as well, but lets not
            // add code at this stage that we don't have to. (4/30/98)
            if (ichNewCurAtIndex0 != -1 && ichNewCurSav != -1 && ichNewCur-ichNewCurAtIndex0 > 0)
                ichNewCurSav = ichNewCurSav + (ichNewCur-ichNewCurAtIndex0);
            ichtoktagStart = (ichNewCurSav == -1)?ichNewCur:ichNewCurSav;// handle < ... <%..%>...> case correctly
            while (ichtoktagStart >= 0)
            {
                if (pwNew[ichtoktagStart] == '<' && pwNew[ichtoktagStart+1] != '%')
                {
                    ichtoktagStart++;
                    break;
                }
                ichtoktagStart--;
            }
            if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
            {
                ptep->m_pspInfoOut += cchwspInfo-2; // for spacing info
                ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // for Order Info
                continue;
            }
            break;
        case 2: // after > of the tag
            // Observation - Trident messes up the document in following way - 
            //    If we had an EOL after '>' which is followed by HTML text, 
            //    trident eats that EOL
            // BUT
            //    If we had a space/tab before that EOL trident doesn't eat it!!!
            // so I have added the conditions
            // && (pwOld[pTokArray[iArray+1].token.ibTokMin] != ' ')
            // && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\t')

            // here is the deal - If the next tone happens to be plain text, there is no danger
            // of applying the same format twice.( i.e. once for after '>' and the next time for
            // before the next '<')
            if (   (iArray+1 < (INT)ptep->m_cMaxToken) /*validation*/
                && pTokArray[iArray+1].token.tok == 0
                && pTokArray[iArray+1].token.tokClass == tokIDENTIFIER
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\r')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != ' ')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\t')
                )
            {
                fLookback = FALSE;
                ichtoktagStart = ichNewCur;
                while (ichtoktagStart >= 0)
                {
                    if (pwNew[ichtoktagStart] == '>')
                    {
                        ichtoktagStart++;
                        break;
                    }
                    ichtoktagStart--;
                }
                if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
                {
                    ptep->m_pspInfoOut += cchwspInfo-2;
                    continue;
                }
            }
            else
            {
                ptep->m_pspInfoOut += cchwspInfo-2; // we ignore this info
                continue;
            }
            break;
        case 3: // before matching end tag
            ptep->m_pspInfoOut += cchwspInfo-2; // we ignore this info
            continue;
            //fLookback = TRUE;
            //ichtoktagStart = 0; // we ignore this info
            break;
        }

        if (index == 3) // skip this info, because we have not reached matching end tag yet
            ptep->m_pspInfoOut += cchwspInfo-2;
        //else if (index == 0)
        //  ptep->FRestoreSpacingInHTML(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, fLookback, index);
        else
            ptep->FRestoreSpacing(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, fLookback, index);

LNext:
        if (index == 1) // we have already processed this info, just move the pointer ahead
            ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut;

    } // for ()

    iArray++; // go part > of this tag for the next round

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = (UINT)iArray;

LRetOnly:
    return;

} /* fnRestoreSpace() */




void
CTriEditParse::fnRestoreSpaceEnd(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy, DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT iArray = (INT)*piArrayStart;
    LPWSTR pwNew = *ppwNew;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
    };
    INT iArraySav = iArray;
    INT iArrayMatch, i, itoktagStart;
    BOOL fMatch = FALSE;
    INT cchtag;
    WORD *pspInfoEnd;
    INT cchwspInfo; // spInfo block size in wide chars
    INT cchRange; // number of char for which this spInfo was saved
    INT ichtoktagStart, iArrayValue, index;
    WCHAR szIndex[cchspBlockMax];
    int iDSP = -1;
    UINT cbNeed;
    
    ASSERT(dwFlags & dwPreserveSourceCode);

    // take care of the matching end token's spacing
    ASSERT(pTokArray[iArray].token.tok == ft.tokBegin2);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    ASSERT(ft.tokBegin2 == TokTag_END);

    // We already are at (token.tok == TokTag_END)
    // Get the tokElem after the current token and find its matching begin token
    // If we don't find the begin token, we don't have spacing for this end token, return
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (pTokArray[iArray].token.tokClass == tokElem) // generally this will be the next token
            break;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    
    if (pTokArray[iArray].iNextprev == -1)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    iArrayMatch = pTokArray[iArray].iNextprev;
    // look for 'DESIGNTIMESP' from iArrayMatch till the next '>'
    // If we don't find 'DESIGNTIMESP', this is an error case, return.
    i = iArrayMatch;
    cchtag = wcslen(rgSpaceTags[0]);
    while (    i < iArraySav /* boundary case */
            && (   pTokArray[i].token.tokClass != tokTag
                || pTokArray[i].token.tok != TokTag_CLOSE
                )
            )
    {

        if (   pTokArray[i].token.tokClass == tokSpace
            && cchtag == (int)(pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin)
            && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[i].token.ibTokMin], cchtag))
            )
        {
            fMatch = TRUE;
            break;
        }
        i++;
    }
    if (!fMatch)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // at this point pTokArray[i] is 'DESIGNTIMESP'
    iDSP = i; // save for later use when we convert the tokElem to upper/lower case
    itoktagStart = i;
    while (itoktagStart >= 0)
    {
        if (       pTokArray[itoktagStart].token.tok == ft.tokBegin
                && pTokArray[itoktagStart].token.tokClass == tokTag
                )
        {
            break;
        }
        itoktagStart--;
    }
    if (itoktagStart < 0) // didn't find '<' before DESIGNTIMESPx
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // found '<' before DESIGNTIMESPx
    ASSERT(pTokArray[itoktagStart].token.tok == TokTag_START);
    ASSERT(pTokArray[itoktagStart].token.tokClass == tokTag);
    // we already know that i'th token is DESIGNTIMESPx, so get past the '=' that follows it
    // ASSUMPTION - the value of attribute DESIGNTIMESPx will NOT get munged by Trident.
    // NOTE - The above assumption is correct for this Trident release.
    while (i < iArraySav)
    {
        if (*(WORD *)(pwOld+pTokArray[i].token.ibTokMin) == '=')
        {
            ASSERT(pTokArray[i].token.tokClass == tokOp);
            break;
        }
        else if (*(WORD *)(pwOld+pTokArray[i].token.ibTokMin) == '>') // gone too far
            goto LSkip1;
        i++;
    }
    if (i >= iArraySav) // didn't find = after DESIGNTIMESPx
    {
LSkip1:
        iArray = iArraySav + 1;
        goto LRet;
    }
    iArrayValue = -1;
    while (i < iArraySav)
    {
		if (   (iArrayValue == -1)
			&& (   pTokArray[i].token.tokClass == tokValue 
				|| pTokArray[i].token.tokClass == tokString)
			)
            iArrayValue = i;
        else if (      pTokArray[i].token.tok == TokTag_CLOSE
                    && pTokArray[i].token.tokClass == tokTag
                    )
        {
            ASSERT(*(WORD *)(pwOld+pTokArray[i].token.ibTokMin) == '>');
            break;
        }
        i++;
    }
    if (iArrayValue == -1)/*BUG 7951 || i >= iArraySav)*/ // didn't find tokValue after DESIGNTIMESPx
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // we know that iArraySav'th token is '</', copy till that token and apply spacing
    cbNeed = (ichNewCur+pTokArray[iArraySav].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;
    ASSERT(pTokArray[iArraySav].token.ibTokMin >= ichBeginCopy);
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+ichBeginCopy),
            (pTokArray[iArraySav].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += (pTokArray[iArraySav].token.ibTokMin-ichBeginCopy);
    ichtoktagStart = ichNewCur-1;
    
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+pTokArray[iArraySav].token.ibTokMin),
            (pTokArray[iArraySav].token.ibTokMac-pTokArray[iArraySav].token.ibTokMin)*sizeof(WCHAR));
    ichNewCur += (pTokArray[iArraySav].token.ibTokMac-pTokArray[iArraySav].token.ibTokMin);
    ichBeginCopy = pTokArray[iArraySav].token.ibTokMac; // make it ready for next copy

    // we know that 4 blocks of info was saved for each DESIGNTIMESPx attribute
    // before tag, within tag, after tag, before matching end-tag
    // even if no info was saved, the block will still exist with 2 words (size,# of char)
    memset((BYTE *)szIndex, 0, sizeof(szIndex));
	// check if the value has quotes around it and don't copy them to szIndex
	if (   pwOld[pTokArray[iArrayValue].token.ibTokMin] == '"'
		&& pwOld[pTokArray[iArrayValue].token.ibTokMac-1] == '"'
		)
	{
		memcpy( (BYTE *)szIndex,
				(BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin+1),
				(pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin-2)*sizeof(WCHAR));
	}
	else
	{
		memcpy( (BYTE *)szIndex,
				(BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin),
				(pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin)*sizeof(WCHAR));
	}
    ptep->m_ispInfoBlock = _wtoi(szIndex);
    ptep->m_ispInfoBlock -= ptep->m_ispInfoBase;
    if (ptep->m_ispInfoBlock < 0)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // NOTE - we can cache this info in a link list at the begining
    // get to the ptep->m_ispInfoBlock'th block from ptep->m_pspInfoOutStart
    ASSERT(ptep->m_cchspInfoTotal >= 0);
    pspInfoEnd = ptep->m_pspInfoOutStart + ptep->m_cchspInfoTotal;
    ptep->m_pspInfoOut = ptep->m_pspInfoOutStart;
    for (index = 0; index < ptep->m_ispInfoBlock; index++)
    {
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before <
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // between <>
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // Order Info
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // after >
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before matching </

        // we somehow have gone beyond the data that was saved for spacing
        if (ptep->m_pspInfoOut >= pspInfoEnd)
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    }

    // skip pre '<' data
    cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
    cchRange = *(WORD *)ptep->m_pspInfoOut++;
    ptep->m_pspInfoOut += cchwspInfo - 2;
    // skip '<...>' data
    cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
    cchRange = *(WORD *)ptep->m_pspInfoOut++;
    ptep->m_pspInfoOut += cchwspInfo - 2;
    ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // for Order Info
    // skip post '>' data
    cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
    cchRange = *(WORD *)ptep->m_pspInfoOut++;
    ptep->m_pspInfoOut += cchwspInfo - 2;
    // now we are at matching </...> of the token
    cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
    cchRange = *(WORD *)ptep->m_pspInfoOut++;
    if (cchwspInfo == 2) // we didn't save any spacing info
    {
        // here is a little story. If we didn't save any spacing information for this end
        // tag, that means we didn't have any white-space before it. Lets go back from
        // pwNew[ichNewCur-1] and remove the white-space.
        // NOTE - Ideally, this needs to get folded into FRestoreSpacing, but 
        // FRestorespacing gets called from other places too so this is late in
        // the game to that kind of change.
        // we know that pwNew[ichNewCur-1] is '/' & pwNew[ichNewCur-2] is '<'
        if ((int)(ichNewCur-2) >= 0 && pwNew[ichNewCur-1] == '/' && pwNew[ichNewCur-2] == '<')
        {
            ichNewCur = ichNewCur - 3;
            while (    (   pwNew[ichNewCur] == ' '  || pwNew[ichNewCur] == '\t'
                        || pwNew[ichNewCur] == '\r' || pwNew[ichNewCur] == '\n'
                        )
                    )
            {
                ichNewCur--;
            }
            ichNewCur++; // compensate, ichNewCur points to non-white space characher
            pwNew[ichNewCur++] = '<';
            pwNew[ichNewCur++] = '/';
        }

        iArray = iArraySav + 1;
        goto LRestoreCaseAndRet;
    }
    ptep->FRestoreSpacing(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, /*fLookback*/TRUE, /*index*/3);

    iArray = iArraySav + 1; // go past '</', we have already copied the doc till this point
    
LRestoreCaseAndRet:
    // BUG 15389 - we need to start copying the tokElem as well with proper upper/lower case
    // we should combine this memcpy with the above ones, but I want to keep the
    // code separate
    if (pTokArray[iArray].token.tokClass == tokElem && iDSP != -1)
    {
        // except for </BODY> tag because we need to restore post-end-BODY stuff in fnRestoreFtr()
        if (pTokArray[iArray].token.tok != TokElem_BODY && pTokArray[iArray].token.tok != tokElem)
        {
        cbNeed = (ichNewCur+pTokArray[iArray].token.ibTokMac-pTokArray[iArray].token.ibTokMin)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(pwOld+pTokArray[iArray].token.ibTokMin),
                (pTokArray[iArray].token.ibTokMac-pTokArray[iArray].token.ibTokMin)*sizeof(WCHAR));
        // convert into upper/lower case appropriately to match the opening tag's case
        if (iswupper(pwOld[pTokArray[iDSP].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
        {
            _wcsupr(&pwNew[ichNewCur]);
        }
        else
        {
            _wcslwr(&pwNew[ichNewCur]);
        }
        ichNewCur += (pTokArray[iArray].token.ibTokMac-pTokArray[iArray].token.ibTokMin);

        // set ichBeginCopy & iArray for next run
        ichBeginCopy = pTokArray[iArray].token.ibTokMac;
        iArray++;
        }
    }




LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = (UINT)iArray;

//LRetOnly:
    return;

} /* fnRestoreSpaceEnd() */



void
CTriEditParse::fnSaveTbody(CTriEditParse* /*ptep*/,
          LPWSTR /*pwOld*/, LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*hBeginCopy*/,
          DWORD /*dwFlags*/)
{
    UINT iArray = *piArrayStart;

    ASSERT(pTokArray[iArray].token.tok == TokElem_TBODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    iArray++;

    *piArrayStart = iArray;
    return;

} /* fnSaveTbody() */

void
CTriEditParse::fnRestoreTbody(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    // see if we have DESIGNTIMESP as an attribute for <TBODY>. If we do, ignore this one because
    // we know it existed before going to trident. Else, remove this one because trident inserted 
    // it.
    // NOTE - If Trident inserted it, we also have to remove the matching </TBODY>

    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    INT iArray = (INT)*piArrayStart;
    LPWSTR pwNew = *ppwNew;
    INT ichTBodyStart, ichTBodyEnd;
    BOOL fFoundDSP = FALSE;
    INT iArraySav = iArray;
    INT cchtag;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
    };
    BOOL fBeginTBody = FALSE;
    UINT cbNeed;

    ichTBodyStart = pTokArray[iArray].token.ibTokMin; // init
    ASSERT(pTokArray[iArray].token.tok == TokElem_TBODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    // look for '<' or '</' before TBODY
    while (iArray >= 0) // generally, it will be the previous token, but just in case...
    {
        if (   (pTokArray[iArray].token.tok == TokTag_START)
            && (pTokArray[iArray].token.tokClass == tokTag)
            )
        {
            fBeginTBody = TRUE;
            ichTBodyStart = pTokArray[iArray].token.ibTokMin;
            break;
        }
        else if (      (pTokArray[iArray].token.tok == TokTag_END)
                    && (pTokArray[iArray].token.tokClass == tokTag)
                    )
        {
            if (ptep->m_iTBodyMax > 0) // we have atleast one saved <TBODY>
            {
                ASSERT(ptep->m_pTBodyStack != NULL);
                if (ptep->m_pTBodyStack[ptep->m_iTBodyMax-1] == (UINT)iArraySav) // this was the matching </TBODY>
                {
                    // we want to remove it
                    ichTBodyStart = pTokArray[iArray].token.ibTokMin;
                    break;
                }
                else // this one doesn't match with the saved one, so quit
                {
                    iArray = iArraySav + 1;
                    goto LRet;
                }
            }
            else // we don't have any saved <TBODY>, so quit
            {
                iArray = iArraySav + 1;
                goto LRet;
            }
        }
        iArray--;
    } // while ()
    if (iArray < 0) // this can happen only if we have incomplete HTML. Handle error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    ichTBodyEnd = pTokArray[iArraySav].token.ibTokMac; // init
    iArray = iArraySav;
    ASSERT(pTokArray[iArray].token.tok == TokElem_TBODY);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    cchtag = wcslen(rgSpaceTags[0]);
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   (pTokArray[iArray].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[iArray].token.tokClass == tokTag)
            )
        {
            ichTBodyEnd = pTokArray[iArray].token.ibTokMac;
            break;
        }
        // look for DESIGNTIMESP
        if (   (pTokArray[iArray].token.tok == 0)
            && (pTokArray[iArray].token.tokClass == tokSpace)
            && (cchtag == (INT)(pTokArray[iArray].token.ibTokMac - pTokArray[iArray].token.ibTokMin))
            && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[iArray].token.ibTokMin], cchtag))
            )
        {
            fFoundDSP = TRUE; 
            break;
        }
        else if (pTokArray[iArray].token.tokClass == tokAttr)
        {
            // look for any attribute before '>'
            // Even if Trident inserted this <TBODY>, the user may have set some TBODY properties
            // If thats the case, we don't want to remove this <TBODY>
            fFoundDSP = TRUE; // fake it to be fFoundDSP
            break;
        }

        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    if (fFoundDSP)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // we found '>', but didn't find DESIGNTIMESP
    // At this point we are sure that this was added by trident
    ASSERT(iArray < (int)ptep->m_cMaxToken);
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    ASSERT(!fFoundDSP);

    if (fBeginTBody)
    {
        // copy till ichTBodyStart, skip from ichTBodyStart till ichTBodyEnd, set ichBeginCopy accordingly
        // get the iArray for the matching </TBODY> and save it on stack
        
        if (ptep->m_pTBodyStack == NULL) // first time, so allocate it
        {
            ASSERT(ptep->m_hgTBodyStack == NULL);
            ptep->m_hgTBodyStack = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cTBodyInit*sizeof(UINT));
            if (ptep->m_hgTBodyStack == NULL)
            {
                // not enough memory, so lets keep all <TBODY> elements
                goto LRet;
            }
            ptep->m_pTBodyStack = (UINT *)GlobalLock(ptep->m_hgTBodyStack);
            ASSERT(ptep->m_pTBodyStack != NULL);
            ptep->m_iMaxTBody = cTBodyInit;
            ptep->m_iTBodyMax = 0;
        }
        else
        {
            ASSERT(ptep->m_hgTBodyStack != NULL);
            // see if we need to realloc it
            if (ptep->m_iTBodyMax+1 >= ptep->m_iMaxTBody)
            {
                HRESULT hrRet;

                hrRet = ReallocBuffer(  &ptep->m_hgTBodyStack,
                                        (ptep->m_iMaxTBody+cTBodyInit)*sizeof(UINT),
                                        GMEM_MOVEABLE|GMEM_ZEROINIT);
                if (hrRet == E_OUTOFMEMORY)
                    goto LRet;
                ptep->m_iMaxTBody += cTBodyInit;
                ptep->m_pTBodyStack = (UINT *)GlobalLock(ptep->m_hgTBodyStack);
                ASSERT(ptep->m_pTBodyStack != NULL);
            }
        }
        if (pTokArray[iArraySav].iNextprev != -1) // handle error case
        {
            ptep->m_pTBodyStack[ptep->m_iTBodyMax] = pTokArray[iArraySav].iNextprev;
            ptep->m_iTBodyMax++;
        }
        else
        {
            // don't delete this <TBODY> and its matching </TBODY>
            goto LRet;
        }
    }
    else
    {
        // if this was a matching </TBODY> for the one trident inserted, we don't copy it to pwNew
        ASSERT(ptep->m_iTBodyMax > 0);
        // look in ptep->m_pTBodyStack and see if you find this iArray
        ASSERT(ptep->m_pTBodyStack[ptep->m_iTBodyMax-1] == (UINT)iArraySav);
        // assume that we never can have tangled TBODY's
        ptep->m_pTBodyStack[ptep->m_iTBodyMax-1] = 0;
        ptep->m_iTBodyMax--;
    }
    // now do the actual skipping
    cbNeed = (ichNewCur+ichTBodyStart-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;
    if ((INT)(ichTBodyStart-ichBeginCopy) > 0)
    {
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[ichBeginCopy]),
                (ichTBodyStart-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (ichTBodyStart-ichBeginCopy);
    }
    ichBeginCopy = ichTBodyEnd;
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    iArray++; // iArray was at '>' of TBODY, so set it to be the next one. 


LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnRestoreTbody() */

void
CTriEditParse::fnSaveApplet(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    int indexAppletEnd, ichAppletEnd, indexAppletTagClose, index;
    UINT cbNeed;
    int cchURL = 0;
    int ichURL = 0;
    LPCWSTR rgDspURL[] = 
    {
        L" DESIGNTIMEURL=",
        L" DESIGNTIMEURL2=",
    };

    indexAppletTagClose = -1;
    ASSERT(pTokArray[iArray].token.tok == TokElem_APPLET);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);

    // get the ending '>' of the </applet>
    indexAppletEnd = pTokArray[iArraySav].iNextprev;
    if (indexAppletEnd == -1) // error case, we don't have matching </applet> tag
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // validity check - the matching tag is not '</applet>'
    if (indexAppletEnd-1 >= 0 && pTokArray[indexAppletEnd-1].token.tok != TokTag_END)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // get ending '>' of the <applet ...>
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   (pTokArray[iArray].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[iArray].token.tokClass == tokTag)
            )
        {
            indexAppletTagClose = iArray;
            break;
        }
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // invalid case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    iArray = indexAppletEnd;
    while (iArray < (int)ptep->m_cMaxToken) // generally, it will be the next token, but just in case...
    {
        if (   (pTokArray[iArray].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[iArray].token.tokClass == tokTag)
            )
        {
            break;
        }
        iArray++;
    }
    indexAppletEnd = iArray;
    ichAppletEnd = pTokArray[indexAppletEnd].token.ibTokMac;

    // step 1 - if the applet needs special URL processing, act on it.
    if (!FURLNeedSpecialHandling(pTokArray, iArraySav, pwOld, (int)ptep->m_cMaxToken, &ichURL, &cchURL))
        goto LStep2;
    else // save the URL as an attribute value of DESIGNTIMEURL
    {
        // make sure we have enough space in pwNew.
        // copy from ichBeginCopy till current token's ending '>'.
        // index points to APPLET
        index = indexAppletTagClose;
        cbNeed = (ichNewCur+pTokArray[index].token.ibTokMin-ichBeginCopy+wcslen(rgDspURL[0])+cchURL+3/*eq,quotes*/)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
        // index points to '>'
        if ((int) (pTokArray[index].token.ibTokMin-ichBeginCopy) > 0)
        {
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichBeginCopy], 
                    (pTokArray[index].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[index].token.ibTokMin-ichBeginCopy);
        }

        if (cchURL != 0)
        {
            // add 'DESIGNTIMEURL=' followed by the current URL as quoted value
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)rgDspURL[0], 
                    wcslen(rgDspURL[0])*sizeof(WCHAR));
            ichNewCur += wcslen(rgDspURL[0]);

            pwNew[ichNewCur++] = '"';
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichURL], 
                    cchURL*sizeof(WCHAR));
            ichNewCur += cchURL;
            pwNew[ichNewCur++] = '"';
        }

        if (dwFlags & dwPreserveSourceCode)
            ptep->SaveSpacingSpecial(ptep, pwOld, &pwNew, phgNew, pTokArray, iArraySav-1, &ichNewCur);

        // add ending '>' and set ichBeginCopy, iArray, ichNewCur appropriately
        memcpy( (BYTE *)&pwNew[ichNewCur], 
                (BYTE *)&pwOld[pTokArray[index].token.ibTokMin], 
                (pTokArray[index].token.ibTokMac-pTokArray[index].token.ibTokMin)*sizeof(WCHAR));
        ichNewCur += (pTokArray[index].token.ibTokMac-pTokArray[index].token.ibTokMin);

        iArray = index+1; // redundant, but makes code more understandable
        ichBeginCopy = pTokArray[index].token.ibTokMac;
    }

    // step2 - copy the applet
LStep2:
    cbNeed = (ichNewCur+ichAppletEnd-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    memcpy( (BYTE *)(&pwNew[ichNewCur]),
            (BYTE *)(&pwOld[ichBeginCopy]),
            (ichAppletEnd-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += (ichAppletEnd-ichBeginCopy);
    ichBeginCopy = ichAppletEnd;
    iArray = indexAppletEnd;

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnSaveApplet() */


void
CTriEditParse::fnRestoreApplet(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
        L"DESIGNTIMEURL",
    };
    int indexAppletStart, ichAppletStart, indexAppletEnd, i, indexAppletTagClose;
    UINT cchtag, cbNeed, cchURL;
    int indexDSU = -1; // init
    int indexDSUEnd = -1; // init
    int indexDSP = -1; // init
    int indexDSPEnd = -1; // init
    int indexCB = -1; // init (CODEBASE index)
    int indexCBEnd = -1; // init (CODEBASE index)
    BOOL fCodeBaseFound = FALSE;

    ASSERT(pTokArray[iArray].token.tok == TokElem_APPLET);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    indexAppletTagClose = iArraySav;
    // get the matching </applet> tag
    indexAppletEnd = pTokArray[iArraySav].iNextprev;
    if (indexAppletEnd == -1) // error case, we don't have matching </applet> tag
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // get ending '>' of the <applet ...>
    i = iArraySav;
    while (i < (int)ptep->m_cMaxToken)
    {
        if (   (pTokArray[i].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[i].token.tokClass == tokTag)
            )
        {
            indexAppletTagClose = i;
            break;
        }
        i++;
    }
    if (i >= (int)ptep->m_cMaxToken) // invalid case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // look for DESIGNTIMESP & DESIGNTIMEURL inside the <applet> tag
    cchtag = wcslen(rgSpaceTags[0]);
    cchURL = wcslen(rgSpaceTags[1]);
    for (i = iArraySav; i < indexAppletTagClose; i++)
    {
        if (       pTokArray[i].token.tok == 0
                && pTokArray[i].token.tokClass == tokSpace
                && cchtag == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[i].token.ibTokMin], cchtag))
                )
        {
            indexDSP = i;
        }
        else if (      pTokArray[i].token.tok == 0
                    && pTokArray[i].token.tokClass == tokSpace
                    && cchURL == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                    && (0 == _wcsnicmp(rgSpaceTags[1], &pwOld[pTokArray[i].token.ibTokMin], cchURL))
                    )
        {
            indexDSU = i;
        }
        else if (      pTokArray[i].token.tok == TokAttrib_CODEBASE
                    && pTokArray[i].token.tokClass == tokAttr
                    )
        {
            indexCB = i;
        }
    } // for ()

    // look for '<' before APPLET
    i = iArraySav;
    while (i >= 0) // generally, it will be the previous token, but just in case...
    {
        if (   (pTokArray[i].token.tok == TokTag_START)
            && (pTokArray[i].token.tokClass == tokTag)
            )
        {
            break;
        }
        i--;
    } // while ()
    if (i < 0) // this can happen only if we have incomplete HTML. Handle error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    indexAppletStart = i;
    ichAppletStart = pTokArray[indexAppletStart].token.ibTokMin;

    // look for '>' of </applet>
    i = indexAppletEnd;
    while (i < (int)ptep->m_cMaxToken) // generally, it will be the next token, but just in case...
    {
        if (   (pTokArray[i].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[i].token.tokClass == tokTag)
            )
        {
            break;
        }
        i++;
    }
    if (i >= (int)ptep->m_cMaxToken) // this can happen only if we have incomplete HTML. Handle error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    indexAppletEnd = i;

    // step 1 - copy till indexAppletStart
    cbNeed = (ichNewCur+ichAppletStart-ichBeginCopy+3*(indexAppletEnd-indexAppletStart))*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    memcpy( (BYTE *)(&pwNew[ichNewCur]),
            (BYTE *)(&pwOld[ichBeginCopy]),
            (ichAppletStart-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += (ichAppletStart-ichBeginCopy);

    // step 2 - if (indexDSU != -1), we need to go and restore the CODEBASE atrtribute
    // if (indexDSU == -1), we need to remove CODEBASE attribute
    ASSERT(indexAppletTagClose != -1);

    // get indexDSUEnd
    if (indexDSU != -1)
    {
        i = indexDSU;
        while (i < indexAppletTagClose)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexDSUEnd = i;
                break;
            }
            i++;
        }
        if (indexDSUEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    } /* if (indexDSU != -1)*/
    
    // get indexDSPEnd
    if (indexDSP != -1)
    {
        i = indexDSP;
        indexDSPEnd = -1;
        while (i < indexAppletTagClose)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexDSPEnd = i;
                break;
            }
            i++;
        }
        if (indexDSPEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    } /* if (indexDSP != -1) */

    // get indexCBEnd
    if (indexCB != -1)
    {
        i = indexCB;
        while (i < indexAppletTagClose)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexCBEnd = i;
                break;
            }
            i++;
        }
        if (indexCBEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
    } /* if (indexCB != -1) */

    // if we didn't find DESIGNTIMEURL attribute, that means CODEBASE attribute
    // should be removed because it didn't exist in source view
    i = indexAppletStart;
    while (i <= indexAppletTagClose)
    {
        if (   (indexDSU != -1)
            && (i >= indexDSU && i <= indexDSUEnd)
            )
        {
            i++; // don't copy this token
        }
        else if (      (indexDSP != -1)
                    && (i >= indexDSP && i <= indexDSPEnd)
                    )
        {
            i++; // don't copy this token
        }
        else if (      pTokArray[i].token.tok == TokAttrib_CODEBASE
                    && pTokArray[i].token.tokClass == tokAttr
                    && !fCodeBaseFound
                    )
        {
            if (indexDSU == -1) // DESIGNTIMEURL not found, so skip CODEBASE
            {
                ASSERT(i == indexCB);
                i = indexCBEnd+1;
            }
            else
            {
                fCodeBaseFound = TRUE;
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
        }
        else if (      pTokArray[i].token.tok == 0 
                    && pTokArray[i].token.tokClass == tokString || pTokArray[i].token.tokClass == tokValue
                    && fCodeBaseFound
                    )
        {
            int ichURL, ichURLEnd, ichDSURL, ichDSURLEnd;
            // if the url is now absloute and is just an absolute version of 
            // the one at indexDSUEnd, we need to replace it.
            ichURL = (pwOld[pTokArray[i].token.ibTokMin] == '"')
                    ? pTokArray[i].token.ibTokMin+1
                    : pTokArray[i].token.ibTokMin;
            ichURLEnd = (pwOld[pTokArray[i].token.ibTokMac-1] == '"')
                    ? pTokArray[i].token.ibTokMac-1
                    : pTokArray[i].token.ibTokMac;
            if (FIsAbsURL((LPOLESTR)&pwOld[ichURL]))
            {
                WCHAR *pszURL1 = NULL;
                WCHAR *pszURL2 = NULL;
                int ich;

                ichDSURL = (pwOld[pTokArray[indexDSUEnd].token.ibTokMin] == '"')
                        ? pTokArray[indexDSUEnd].token.ibTokMin+1
                        : pTokArray[indexDSUEnd].token.ibTokMin;
                ichDSURLEnd = (pwOld[pTokArray[indexDSUEnd].token.ibTokMac-1] == '"')
                        ? pTokArray[indexDSUEnd].token.ibTokMac-1
                        : pTokArray[indexDSUEnd].token.ibTokMac;

                // just for comparison purposes, don't look at '/' or '\' separators
                // between filenames & directories...
                pszURL1 = new WCHAR[ichDSURLEnd-ichDSURL + 1];
                pszURL2 = new WCHAR[ichDSURLEnd-ichDSURL + 1];
                if (pszURL1 == NULL || pszURL2 == NULL)
                    goto LResumeCopy;
                memcpy((BYTE *)pszURL1, (BYTE *)&pwOld[ichDSURL], (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                memcpy((BYTE *)pszURL2, (BYTE *)&pwOld[ichURLEnd-(ichDSURLEnd-ichDSURL)], (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                pszURL1[ichDSURLEnd-ichDSURL] = '\0';
                pszURL2[ichDSURLEnd-ichDSURL] = '\0';
                for (ich = 0; ich < ichDSURLEnd-ichDSURL; ich++)
                {
                    if (pszURL1[ich] == '/')
                        pszURL1[ich] = '\\';
                    if (pszURL2[ich] == '/')
                        pszURL2[ich] = '\\';
                }

                if (0 == _wcsnicmp(pszURL1, pszURL2, ichDSURLEnd-ichDSURL))
                {
                    pwNew[ichNewCur++] = '"';
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[ichDSURL],
                            (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                    ichNewCur += (ichDSURLEnd-ichDSURL);
                    pwNew[ichNewCur++] = '"';
                }
                else // copy it as it is
                {
LResumeCopy:
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                if (pszURL1 != NULL)
                    delete pszURL1;
                if (pszURL2 != NULL)
                    delete pszURL2;
            }
            else // its realtive, simply copy it
            {
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
            }
            i++;
        }
        else // all other tokens
        {
            // ****NOTE - we can actually do pretty printing here 
            // instead of fixing the special cases****

            // fix Trident's behaviour - If Trident sees unknown tag(s) it puts it(them) at the end 
            // and inserts EOL before those. In this case, we would have inserted a space before DESIGNTIMESP
            // and Trident would have inserted EOL. If thats not the case, we will ignore it.
            if (   (pTokArray[i].token.tokClass == tokSpace)
                && (pTokArray[i].token.tok == 0)
                && (FIsWhiteSpaceToken(pwOld, pTokArray[i].token.ibTokMin, pTokArray[i].token.ibTokMac))
                )
            {
                if (i != indexDSU-1) // else skip the copy
                    pwNew[ichNewCur++] = ' '; // convert space+\r+\n into space
                i++;
            }
            else
            {
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
        }
    } // while ()

    // we have spacing save dfor this tag, lets restore it
    if (   (indexDSP != -1)
        && (dwFlags & dwPreserveSourceCode)
        ) 
        ptep->RestoreSpacingSpecial(ptep, pwOld, &pwNew, phgNew, pTokArray, indexDSP, &ichNewCur);

    // step 3 - format all stuff between <applet> ... </applet>
    pwNew[ichNewCur] = '\r';
    ichNewCur++;
    pwNew[ichNewCur] = '\n';
    ichNewCur++;
    pwNew[ichNewCur] = '\t'; // replace this with appropriate alignment
    ichNewCur++;
    for (i = indexAppletTagClose+1; i <= indexAppletEnd; i++)
    {
        // copy the tag
        memcpy( (BYTE *)(&pwNew[ichNewCur]),
                (BYTE *)(&pwOld[pTokArray[i].token.ibTokMin]),
                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
        ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
        // if its was TokTag_CLOSE, insert EOL
        if (   pTokArray[i].token.tok == TokTag_CLOSE
            && pTokArray[i].token.tokClass == tokTag)
        {
            pwNew[ichNewCur] = '\r';
            ichNewCur++;
            pwNew[ichNewCur] = '\n';
            ichNewCur++;
            pwNew[ichNewCur] = '\t'; // replace this with appropriate alignment
            ichNewCur++;
        }
    } // for ()

    // remember to set iArray appropriately
    iArray = indexAppletEnd + 1;
    ichBeginCopy = pTokArray[indexAppletEnd].token.ibTokMac;

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnRestoreApplet() */

void
CTriEditParse::RestoreSpacingSpecial(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR *ppwNew, HGLOBAL* /*phgNew*/,
            TOKSTRUCT *pTokArray, UINT iArray, UINT *pichNewCur)
{
    LPWSTR pwNew = *ppwNew;
    UINT ichNewCur = *pichNewCur;
    UINT iArraySav = iArray;
    UINT ichspInfoEndtagEnd, ichBegin;
    WCHAR szIndex[cchspBlockMax]; // will we have more than 20 digit numbers as number of DESIGNTIMESPx?
    WORD *pspInfoEnd, *pspInfoOrder;
    INT cwOrderInfo = 0;
    UINT ichNewCurSav = 0xFFFFFFFF;
    INT cchwspInfo; // spInfo block size in wide chars
    INT cchRange; // number of char for which this spInfo was saved
    INT ichtoktagStart, iArrayValue, index, itoktagStart;
    int ichNewCurAtIndex0 = -1; // we need to adjust the saved ichNewCur because it gets invalidated
                                // as soon as the tag moves as a result of restoring pre-tag spaces.

    itoktagStart = iArray; // init
    // found DESIGNTIMESPx. Now, go backwords and look for TokTag_START
    while (itoktagStart >= 0)
    {
        if (       pTokArray[itoktagStart].token.tok == TokTag_START
                && pTokArray[itoktagStart].token.tokClass == tokTag
                )
        {
            break;
        }
        itoktagStart--;
    }
    if (itoktagStart < 0) // didn't find '<' before DESIGNTIMESPx
        goto LRet;

    // found '<' before DESIGNTIMESPx
    // the spacing info saved was for the portion of the document before the '<'
    ASSERT(pTokArray[itoktagStart].token.tok == TokTag_START);
    ASSERT(pTokArray[itoktagStart].token.tokClass == tokTag);
    // we already know that iArray'th token is DESIGNTIMESPx, so get past the '=' that follows it
    // ASSUMPTION - the value of attribute DESIGNTIMESPx will NOT get munged by Trident.
    // NOTE - the above assumption is correct for this release of Trident
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '=')
        {
            ASSERT(pTokArray[iArray].token.tokClass == tokOp);
            break;
        }
        else if (*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '>') // gone too far
            goto LSkip1;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // didn't find = after DESIGNTIMESPx
    {
LSkip1:
        goto LRet;
    }
    iArrayValue = -1; // init
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   (iArrayValue == -1)
            && (   (pTokArray[iArray].token.tokClass == tokValue)
                || (pTokArray[iArray].token.tokClass == tokString)
                )
            )
            iArrayValue = iArray;
        else if (      pTokArray[iArray].token.tok == TokTag_CLOSE
                    && pTokArray[iArray].token.tokClass == tokTag
                    )
        {
            ASSERT(*(WORD *)(pwOld+pTokArray[iArray].token.ibTokMin) == '>');
            break;
        }
        iArray++;
    }
    if (iArrayValue == -1 || iArray >= (int)ptep->m_cMaxToken) // didn't find tokValue after DESIGNTIMESPx
    {
        // BUG 9040
        //if (iArray >= (int)ptep->m_cMaxToken && iArrayValue != -1)
        //{
            // SOLUTION 1
            // overwrite the stuff from pwOld[pTokArray[iArraySav].token.ibTokMin]
            // to pwOld[pTokArray[iArrayValue].token.ibTokMac - 1]
            // SOLUTION 2
            // look for DESIGNTIMESP from pwOld[pTokArray[itokTagStart].token.ibTokMac - 1]
            // to pwOld[pTokArray[iArray].token.ibTokMac - 1] and overwrite all of those 
            // strings with spaces. We could NULL those and do the blts, but why bother
            // when the html isn't valid! 

            // make sure that all DESIGNTIMESPs are stripped off if we encountered this error case
        //}
        goto LRet;
    }

    // we know that 4 blocks of info was saved for each DESIGNTIMESPx attribute
    // before tag, within tag, after tag, before matching end-tag
    // even if no info was saved, the block will still exist with 2 words (size,# of char)
    ichspInfoEndtagEnd = pTokArray[iArray].token.ibTokMac;

    // first copy the document till DESIGNTIMESPx
    // skip DESIGNTIMESPx and its value and set ichBeginCopy to be after that

    // NOTE - token before iArraySav'th one should be tokSpace with lenght 1 
    // and with a value of chSpace (unless Trident has modified it). If thats TRUE,
    // we should skip that too, because we added it when we put in DESIGNTIMESPx.
    
    // fix Trident's behaviour - If Trident sees unknown tag(s) it puts it(them) at the end 
    // and inserts EOL before those. In this case, we would have inserted a space before DESIGNTIMESP
    // and Trident would have inserted EOL. If thats not the case, we will ignore it.
    if (   (iArraySav-1 > 0) /* validation */
        && (    (      (pTokArray[iArraySav-1].token.ibTokMac - pTokArray[iArraySav-1].token.ibTokMin == 1)
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin] == ' ')
                    )
            ||  (      (pTokArray[iArraySav-1].token.ibTokMac - pTokArray[iArraySav-1].token.ibTokMin == 3)
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin] == ' ')
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin+1] == '\r')
                    && (pwOld[pTokArray[iArraySav-1].token.ibTokMin+2] == '\n')
                    )
                )
        )
    {
        ichBegin = pTokArray[iArraySav-1].token.ibTokMin;
    }
    else
        ichBegin = pTokArray[iArraySav].token.ibTokMin;

#ifdef NEEDED
    ASSERT(ichBegin >= ichBeginCopy);

    cbNeed = (ichNewCur+(ichBegin-ichBeginCopy))*sizeof(WCHAR) + cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
    {
        iArray = iArraySav + 1;
        goto LRet;
    }
    // BUG 15389 - look at the case of DESIGNTIMESP & convert the tag into upper/lower case...
    //memcpy(   (BYTE *)(pwNew+ichNewCur),
    //      (BYTE *)(pwOld+ichBeginCopy),
    //      (ichBegin-ichBeginCopy)*sizeof(WCHAR));
    //ichNewCur += (ichBegin-ichBeginCopy);
    if (ichBegin-ichBeginCopy >= 0)
    {
        // step 1 - copy from ichBeginCopy to '<' of the current tag
        if ((int)(pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy) > 0)
        {
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+ichBeginCopy),
                    (pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[itoktagStart].token.ibTokMac-ichBeginCopy);
            ichNewCurSav = ichNewCur+1; // used as a peg to get preceding tokTag_START i.e. '<'
        }
        // step 2 - convert current tag into upper/lower case & copy it
        if (ichBeginCopy < pTokArray[itoktagStart+1].token.ibTokMin)
        {
            ASSERT((int)(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin) > 0);
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+pTokArray[itoktagStart+1].token.ibTokMin),
                    (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)*sizeof(WCHAR));
            if (iswupper(pwOld[pTokArray[iArraySav].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
            {
                // convert the tag into upper case. ASSUME that the tag is at itoktagStart+1
                _wcsupr(&pwNew[ichNewCur]);
            }
            else
            {
                // convert the tag into lower case. ASSUME that the tag is at itoktagStart+1
                _wcslwr(&pwNew[ichNewCur]);
            }
            ichNewCur += (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin);
        }
        else // this tag is alreay been copied
        {
            // hack
            if (pTokArray[itoktagStart+1].token.ibTokMac == ichBeginCopy) // means we are just past the current tag
            {
                if (iswupper(pwOld[pTokArray[iArraySav].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
                {
                    ASSERT(ichNewCur >= (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin));
                    // convert the tag into upper case. ASSUME that the tag is at itoktagStart+1
                    _wcsupr(&pwNew[ichNewCur-(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)]);
                }
                else
                {
                    ASSERT(ichNewCur >= (pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin));
                    // convert the tag into lower case. ASSUME that the tag is at itoktagStart+1
                    _wcslwr(&pwNew[ichNewCur-(pTokArray[itoktagStart+1].token.ibTokMac-pTokArray[itoktagStart+1].token.ibTokMin)]);
                }
            }
        }
        // step 3 - copy from after the tag (which is at ichtoktagStart+1) to ichBegin
        if ((int)(ichBegin-pTokArray[itoktagStart+1].token.ibTokMac) > 0)
        {
            memcpy( (BYTE *)(pwNew+ichNewCur),
                    (BYTE *)(pwOld+pTokArray[itoktagStart+1].token.ibTokMac),
                    (ichBegin-pTokArray[itoktagStart+1].token.ibTokMac)*sizeof(WCHAR));
            ichNewCur += (ichBegin-pTokArray[itoktagStart+1].token.ibTokMac);
        }
    }
    // set ichBeginCopy
    ichBeginCopy = ichspInfoEndtagEnd; // make it ready for next copy

    // copy the rest of the tag (skipping DESIGNTIMESPx = value)
    ASSERT((INT)(ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac) >= 0);
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMac),
            (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac)*sizeof(WCHAR));
    ichNewCur += (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac);
#endif //NEEDED 

    memset((BYTE *)szIndex, 0, sizeof(szIndex));
    // check if the value has quotes around it and don't copy them to szIndex
    if (   pwOld[pTokArray[iArrayValue].token.ibTokMin] == '"'
        && pwOld[pTokArray[iArrayValue].token.ibTokMac-1] == '"'
        )
    {
        memcpy( (BYTE *)szIndex,
                (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin+1),
                (pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin-2)*sizeof(WCHAR));
    }
    else
    {
        memcpy( (BYTE *)szIndex,
                (BYTE *)(pwOld+pTokArray[iArrayValue].token.ibTokMin),
                (pTokArray[iArrayValue].token.ibTokMac-pTokArray[iArrayValue].token.ibTokMin)*sizeof(WCHAR));
    }
    ptep->m_ispInfoBlock = _wtoi(szIndex);
    ptep->m_ispInfoBlock -= ptep->m_ispInfoBase;
    if (ptep->m_ispInfoBlock < 0)
        goto LRet;

    // NOTE - we can cache this info in a link list at the begining
    // get to the ptep->m_ispInfoBlock'th block from ptep->m_pspInfoOutStart
    ASSERT(ptep->m_cchspInfoTotal >= 0);
    pspInfoEnd = ptep->m_pspInfoOutStart + ptep->m_cchspInfoTotal;
    ptep->m_pspInfoOut = ptep->m_pspInfoOutStart;
    for (index = 0; index < ptep->m_ispInfoBlock; index++)
    {
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before <
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // between <>
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // Order Info
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // after >
        ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // before matching </

        // we somehow have gone beyond the data that was saved for spacing
        if (ptep->m_pspInfoOut >= pspInfoEnd)
        {
            goto LRet;
        }
    }

    // get the Order Info
    pspInfoOrder = ptep->m_pspInfoOut;
    pspInfoOrder += *(WORD *)pspInfoOrder; // skip info saved for spacing before '<'
    pspInfoOrder += *(WORD *)pspInfoOrder; // skip info saved for spacing between '<>'
    // now pspInfoOrder is at correct place
    cwOrderInfo = *(WORD *)pspInfoOrder++;
    ASSERT(cwOrderInfo >= 1);
    // process this info
#ifdef NEEDED
    if (cwOrderInfo > 1) // means that we saved some info
    {
        INT cchNewCopy;

        cchNewCopy = (ichBegin-pTokArray[itoktagStart].token.ibTokMin) + (ichspInfoEndtagEnd-pTokArray[iArrayValue].token.ibTokMac);
        ptep->FRestoreOrder(pwNew, pwOld, pspInfoOrder, &ichNewCur, cwOrderInfo, pTokArray, itoktagStart, iArray, iArraySav, iArrayValue, cchNewCopy, phgNew);
    }
#endif //NEEDED
    ichtoktagStart = ichNewCur; // init
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    for (index = 0; index < 4; index++)
    {
        BOOL fLookback = FALSE;

        cchwspInfo = *(WORD *)ptep->m_pspInfoOut++;
        cchRange = *(WORD *)ptep->m_pspInfoOut++;
        if (cchwspInfo == 2) // we didn't save any spacing info
        {
            if (index == 0) // special case BUG 8741
            {
                // Note that we didn't save anything before this tag. which means that
                // we had '>' or some text immediately before the < tag. 
                ichtoktagStart = ichNewCur;
                while (ichtoktagStart >= 0)
                {
                    if (pwNew[ichtoktagStart] == '<')
                    {
                        ichtoktagStart--;
                        break;
                    }
                    ichtoktagStart--;
                }
                if (ichtoktagStart >= 0)
                {
                    int cws = 0;
                    int ichtagStart = ichtoktagStart;

                    // remove any such white space trident inserts.
                    while (    pwNew[ichtoktagStart] == ' '
                            || pwNew[ichtoktagStart] == '\r'
                            || pwNew[ichtoktagStart] == '\n'
                            || pwNew[ichtoktagStart] == '\t')
                    {
                        cws++;
                        ichtoktagStart--;
                    }
                    if (cws > 0)
                    {
                        ASSERT((int)(ichNewCur-ichtagStart-1) >= 0);
                        //ichtokTagStart now points to either '>' or a non-whitespace char
                        memmove((BYTE*)&pwNew[ichtoktagStart+1],
                                (BYTE*)&pwNew[ichtoktagStart+1+cws],
                                (ichNewCur-ichtagStart-1)*sizeof(WCHAR));
                        ichNewCur -= cws;
                    }
                } // if (ichtoktagStart >= 0)
            } // if (index == 0)
            goto LNext;
        }

        // note that ichtoktagStart is a position in pwNew
        switch (index)
        {
        case 0: // before < of the tag
            fLookback = TRUE;
            ichtoktagStart = (ichNewCurSav == -1)?ichNewCur:ichNewCurSav;// handle < ... <%..%>...> case correctly
            ichNewCurAtIndex0 = ichNewCur; // lets save the ichNewCur before we restore pre-tag spacing
            while (ichtoktagStart >= 0)
            {
                if (pwNew[ichtoktagStart] == '<' && pwNew[ichtoktagStart+1] != '%')
                {
                    ichtoktagStart--;
                    break;
                }
                ichtoktagStart--;
            }
            if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
            {
                ptep->m_pspInfoOut += cchwspInfo-2;
                continue;
            }
            break;
        case 1: // between <> of the tag
            fLookback = FALSE;
            // NOTE - we can assume that in 'case 0' we had put ichtoktagStart is just before '<'
            // so that we can avoid this while loop. but what if we skipped case '0'?

            // adjust ichNewCurSav to reflect the pre-tag spacing so that it doesn't become invalid
            // we may need to adjust it in ichNewCur-ichNewCurAtIndex0 < 0 case as well, but lets not
            // add code at this stage that we don't have to. (4/30/98)
            if (ichNewCurAtIndex0 != -1 && ichNewCurSav != -1 && ichNewCur-ichNewCurAtIndex0 > 0)
                ichNewCurSav = ichNewCurSav + (ichNewCur-ichNewCurAtIndex0);
            ichtoktagStart = (ichNewCurSav == -1)?ichNewCur:ichNewCurSav;// handle < ... <%..%>...> case correctly
            while (ichtoktagStart >= 0)
            {
                if (pwNew[ichtoktagStart] == '<' && pwNew[ichtoktagStart+1] != '%')
                {
                    ichtoktagStart++;
                    break;
                }
                ichtoktagStart--;
            }
            if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
            {
                ptep->m_pspInfoOut += cchwspInfo-2; // for spacing info
                ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut; // for Order Info
                continue;
            }
            break;
        case 2: // after > of the tag
            // Observation - Trident messes up the document in following way - 
            //    If we had an EOL after '>' which is followed by HTML text, 
            //    trident eats that EOL
            // BUT
            //    If we had a space/tab before that EOL trident doesn't eat it!!!
            // so I have added the conditions
            // && (pwOld[pTokArray[iArray+1].token.ibTokMin] != ' ')
            // && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\t')

            // here is the deal - If the next tone happens to be plain text, there is no danger
            // of applying the same format twice.( i.e. once for after '>' and the next time for
            // before the next '<')
            if (   (iArray+1 < (INT)ptep->m_cMaxToken) /*validation*/
                && pTokArray[iArray+1].token.tok == 0
                && pTokArray[iArray+1].token.tokClass == tokIDENTIFIER
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\r')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != ' ')
                && (pwOld[pTokArray[iArray+1].token.ibTokMin] != '\t')
                )
            {
                fLookback = FALSE;
                ichtoktagStart = ichNewCur;
                while (ichtoktagStart >= 0)
                {
                    if (pwNew[ichtoktagStart] == '>')
                    {
                        ichtoktagStart++;
                        break;
                    }
                    ichtoktagStart--;
                }
                if (ichtoktagStart < 0) // looks to be an error, don't try to restore the spacing
                {
                    ptep->m_pspInfoOut += cchwspInfo-2;
                    continue;
                }
            }
            else
            {
                ptep->m_pspInfoOut += cchwspInfo-2; // we ignore this info
                continue;
            }
            break;
        case 3: // before matching end tag
            ptep->m_pspInfoOut += cchwspInfo-2; // we ignore this info
            continue;
            //fLookback = TRUE;
            //ichtoktagStart = 0; // we ignore this info
            break;
        }

        if (index == 3) // skip this info, because we have not reached matching end tag yet
            ptep->m_pspInfoOut += cchwspInfo-2;
        //else if (index == 0)
        //  ptep->FRestoreSpacingInHTML(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, fLookback, index);
        else
            ptep->FRestoreSpacing(pwNew, pwOld, &ichNewCur, &cchwspInfo, cchRange, ichtoktagStart, fLookback, index);

LNext:
        if (index == 1) // we have already processed this info, just move the pointer ahead
            ptep->m_pspInfoOut += *(WORD *)ptep->m_pspInfoOut;

    } // for ()

LRet:
    *ppwNew = pwNew; // in case this changed
    *pichNewCur = ichNewCur;

} /* RestoreSpacingSpecial() */

void
CTriEditParse::SaveSpacingSpecial(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR *ppwNew, HGLOBAL *phgNew,
            TOKSTRUCT *pTokArray, INT iArray, UINT *pichNewCur)
{
    UINT ichNewCur = *pichNewCur;
    LPWSTR pwNew = *ppwNew;
    int iArrayPrevTag, iArrayMatch;
    UINT iArrayElem, iArrayTagStart;
    INT ichEndMatch, ichBeginMatch, ichEndPrev, ichBeginPrev, ichEndNext, ichBeginNext, ichEndTag, ichBeginTag, ichBegin, ichEnd;
    UINT cbNeed;
    WCHAR szIndex[cchspBlockMax]; // will we have more than 20 digit numbers as number of DESIGNTIMESPx?
    LPCWSTR rgSpaceTags[] =
    {
        L" DESIGNTIMESP=",
        L" DESIGNTIMESP1=",
        L" designtimesp=",
    };

    iArrayElem = 0xFFFFFFFF; // init
    //
    // look for TokTag_START
    while (iArray >= 0)
    {
        if (   pTokArray[iArray].token.tokClass == tokTag 
            && pTokArray[iArray].token.tok == TokTag_START
            )
        {
            break;
        }
        iArray--;
    }
    if (iArray < 0) // error case
        goto LRet;
    iArrayTagStart = iArray;
    //

    // step 1
    // look for > that matches with <. we already are at ft.tokBegin2 i.e. <
    ASSERT(pTokArray[iArray].token.tok == TokTag_START);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    ichBeginTag = pTokArray[iArray].token.ibTokMac;
    while (iArray < (int)ptep->m_cMaxToken)
    {
        if (   pTokArray[iArray].token.tok == TokTag_CLOSE 
            && pTokArray[iArray].token.tokClass == tokTag) // ft.tokEnd2 is -1
            break;
        if (pTokArray[iArray].token.tokClass == tokElem)
            iArrayElem = iArray;
        iArray++;
    }
    if (iArray >= (int)ptep->m_cMaxToken) // didn't find >
    {
        goto LRet;
    }
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE); // found >
    ASSERT(pTokArray[iArray].token.tokClass == tokTag); // found >
    ichEndTag = ichBegin = pTokArray[iArray].token.ibTokMin;
    ichEnd = pTokArray[iArray].token.ibTokMac;

    // step 2
    // look for > before iArrayTagStart. Boundary case will be for the first < in the document
    // save the spacing info
    ASSERT(pTokArray[iArrayTagStart].token.tok == TokTag_START);
    ASSERT(pTokArray[iArrayTagStart].token.tokClass == tokTag);
    ichEndPrev = pTokArray[iArrayTagStart].token.ibTokMin;
    ichBeginPrev = ichEndPrev-1;
    // look for previous TokTag_CLOSE
    // if the tag ending tag, ichBeginPrev becomes ibTokMac of '>' tag
    // if the tag is starting tag, ichBeginPrev becomes ibTokMac+(white space just after that tag)
    iArrayPrevTag = iArrayTagStart; // this is TokTag_START
    while (iArrayPrevTag >= 0)
    {
        if (       (   pTokArray[iArrayPrevTag].token.tokClass == tokTag 
                    && pTokArray[iArrayPrevTag].token.tok == TokTag_CLOSE
                    )
                || (   pTokArray[iArrayPrevTag].token.tokClass == tokSSS 
                    && pTokArray[iArrayPrevTag].token.tok == TokTag_SSSCLOSE
                    )/* VID6 - bug 22787 */
                )
        {
            break;
        }
        iArrayPrevTag--;
    }
    if (iArrayPrevTag < 0) // handle error case
    {
        // leave the old behaviour as is for V1
        while (ichBeginPrev >= 0)
        {
            if (   pwOld[ichBeginPrev] != ' '
                && pwOld[ichBeginPrev] != '\r'
                && pwOld[ichBeginPrev] != '\n'
                && pwOld[ichBeginPrev] != '\t'
                )
                break;
            ichBeginPrev--;
        }
        goto LGotEndNext;
    }
    ichBeginPrev = pTokArray[iArrayPrevTag].token.ibTokMac - 1;

LGotEndNext:
    if (ichBeginPrev < 0)
        ichBeginPrev = 0;
    else
        ichBeginPrev++;


    // step 3
    // look for TokTag_START after iArray(which currently is TokTag_CLOSE)
    // save spacing info
    ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    //iArrayNextStart = iArray;
    ichBeginNext = pTokArray[iArray].token.ibTokMac;
    ASSERT(ichBeginNext == ichEnd);
    ichEndNext = ichBeginNext;
    while (ichEndNext < (INT)pTokArray[ptep->m_cMaxToken-1].token.ibTokMac)
    {
        if (   pwOld[ichEndNext] != ' '
            && pwOld[ichEndNext] != '\r'
            && pwOld[ichEndNext] != '\n'
            && pwOld[ichEndNext] != '\t'
            )
            break;
        ichEndNext++;
    }

    if (ichEndNext >= (INT)pTokArray[ptep->m_cMaxToken-1].token.ibTokMac)
        ichEndNext = pTokArray[ptep->m_cMaxToken-1].token.ibTokMac;

    // step 4
    // if iArrayElem != -1, look for pTokArray[iArrayElem].iNextprev. If its not -1, set iArrayMatch
    // look for previous TokTag_START/TokTag_END. look for previous TokTag_CLOSE
    // save spacing info
    if (iArrayElem == -1) // this can happen if we have incomplete HTML
    {
        ichEndMatch = ichBeginMatch = 0;
        goto LSkipMatchCalc;
    }
    iArrayMatch = pTokArray[iArrayElem].iNextprev;
    if (iArrayMatch != -1) // match was set while tokenizing
    {
        ichBeginMatch = ichEndMatch = 0; //init
        ASSERT(pTokArray[iArray].token.tok == TokTag_CLOSE);
        ASSERT(pTokArray[iArray].token.tokClass == tokTag);
        while (iArrayMatch >= iArray) // iArray is TokTag_CLOSE of the current tag (i.e. '>')
        {
            if (   pTokArray[iArrayMatch].token.tokClass == tokTag
                && (   pTokArray[iArrayMatch].token.tok == TokTag_START
                    || pTokArray[iArrayMatch].token.tok == TokTag_END
                    )
                )
                break;
            iArrayMatch--;
        }
        if (iArrayMatch > iArray) // did find '</' or '<' after the current tag
        {
            ichEndMatch = pTokArray[iArrayMatch].token.ibTokMin;
            ichBeginMatch = ichEndMatch; // init
            // look for '>' and set ichBeginMatch
            while (iArrayMatch >= iArray) // iArray is TokTag_CLOSE of the current tag (i.e. '>')
            {
                if (   (   pTokArray[iArrayMatch].token.tokClass == tokTag
                        && pTokArray[iArrayMatch].token.tok == TokTag_CLOSE
                        )
                    || (   pTokArray[iArrayMatch].token.tokClass == tokSSS
                        && pTokArray[iArrayMatch].token.tok == TokTag_SSSCLOSE
                        )/* VID6 - bug 22787 */
                    )
                    break;
                iArrayMatch--;
            }
            if (iArrayMatch >= iArray) // they may very well be the same
            {
                ichBeginMatch = pTokArray[iArrayMatch].token.ibTokMac;
                ASSERT(ichBeginMatch <= ichEndMatch);
                ASSERT(ichBeginMatch >= ichEnd);
            }
        }
    }
    else
    {
        // don't bother saving any info from here
        ichEndMatch = ichBeginMatch = 0;
    }
LSkipMatchCalc:
    if (ichEndPrev > ichBeginPrev)
        ptep->hrMarkSpacing(pwOld, ichEndPrev, &ichBeginPrev);
    else
        ptep->hrMarkSpacing(pwOld, ichEndPrev, &ichEndPrev);

    if (ichEndTag > ichBeginTag)
    {
        INT ichBeginTagSav = ichBeginTag;

        ptep->hrMarkSpacing(pwOld, ichEndTag, &ichBeginTag);
        // iArray'th token is TokTag_CLOSE & iArrayTagStart is TokTag_START
        ptep->hrMarkOrdering(pwOld, pTokArray, iArrayTagStart, iArray, ichEndTag, &ichBeginTagSav);
    }
    else
    {
        INT ichEndTagSav = ichEndTag;

        ptep->hrMarkSpacing(pwOld, ichEndTag, &ichEndTag);
        // iArray'th token is TokTag_CLOSE & iArrayTagStart is TokTag_START
        ptep->hrMarkOrdering(pwOld, pTokArray, iArrayTagStart, iArray, ichEndTagSav, &ichEndTagSav);
    }

    if (ichEndNext > ichBeginNext)
        ptep->hrMarkSpacing(pwOld, ichEndNext, &ichBeginNext);
    else
        ptep->hrMarkSpacing(pwOld, ichEndNext, &ichEndNext);

    if (ichEndMatch > ichBeginMatch)
        ptep->hrMarkSpacing(pwOld, ichEndMatch, &ichBeginMatch);
    else
        ptep->hrMarkSpacing(pwOld, ichEndMatch, &ichEndMatch);

    // realloc if needed
    cbNeed = (ichNewCur+3*wcslen(rgSpaceTags[0])+(ichEnd-ichBegin))*sizeof(WCHAR);
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    if (iswupper(pwOld[pTokArray[iArrayTagStart+1].token.ibTokMin]) != 0) // upper case
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[0]),
                (wcslen(rgSpaceTags[0]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[0]);
    }
    else
    {
        memcpy( (BYTE *)(pwNew+ichNewCur),
                (BYTE *)(rgSpaceTags[2]),
                (wcslen(rgSpaceTags[2]))*sizeof(WCHAR));
        ichNewCur += wcslen(rgSpaceTags[2]);
    }

    (WCHAR)_itow(ptep->m_ispInfoBlock+ptep->m_ispInfoBase, szIndex, 10);
    ptep->m_ispInfoBlock++;

    ASSERT(wcslen(szIndex) < sizeof(szIndex));
    ASSERT(sizeof(szIndex) == cchspBlockMax*sizeof(WCHAR));
    memcpy( (BYTE *)(pwNew+ichNewCur),
            (BYTE *)(szIndex),
            wcslen(szIndex)*sizeof(WCHAR));
    ichNewCur += wcslen(szIndex);



LRet:
    //*pcchNew = ichNewCur;
    *ppwNew = pwNew;
    *pichNewCur = ichNewCur;

    return;
} /* SaveSpacingSpecial() */


void
CTriEditParse::fnSaveAImgLink(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT cbNeed;

    int cchURL = 0;
    int ichURL = 0;
    int index = iArray;
    LPCWSTR rgDspURL[] = 
    {
        L" DESIGNTIMEURL=",
    };

    ASSERT(    pTokArray[iArray].token.tok == TokElem_A
            || pTokArray[iArray].token.tok == TokElem_IMG
            || pTokArray[iArray].token.tok == TokElem_LINK);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);

    if (!FURLNeedSpecialHandling(pTokArray, iArray, pwOld, (int)ptep->m_cMaxToken, &ichURL, &cchURL))
        iArray++;
    else // save the URL as an attribute value of DESIGNTIMEURL
    {
        // make sure we have enough space in pwNew.
        // copy from ichBeginCopy till current token's ending '>'.
        // index points to A/IMG/LINK
        while (index < (int)ptep->m_cMaxToken)
        {
            if (   pTokArray[index].token.tok == TokTag_CLOSE
                && pTokArray[index].token.tokClass == tokTag
                )
                break;
            index++;
        }
        if (index >= (int)ptep->m_cMaxToken) // invalid HTML, we didn't find '>'
        {
            iArray++;
            goto LRet;
        }
        cbNeed = (ichNewCur+pTokArray[index].token.ibTokMin-ichBeginCopy+wcslen(rgDspURL[0])+cchURL+3/*eq,quotes*/)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        {
            iArray++;
            goto LRet;
        }
        // index points to '>'
        if ((int) (pTokArray[index].token.ibTokMin-ichBeginCopy) > 0)
        {
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichBeginCopy], 
                    (pTokArray[index].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[index].token.ibTokMin-ichBeginCopy);
        }

        if (cchURL != 0)
        {
            // add 'DESIGNTIMEURL=' followed by the current URL as quoted value
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)rgDspURL[0], 
                    wcslen(rgDspURL[0])*sizeof(WCHAR));
            ichNewCur += wcslen(rgDspURL[0]);

            pwNew[ichNewCur++] = '"';
            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichURL], 
                    cchURL*sizeof(WCHAR));
            ichNewCur += cchURL;
            pwNew[ichNewCur++] = '"';
        }

        if (dwFlags & dwPreserveSourceCode)
            ptep->SaveSpacingSpecial(ptep, pwOld, &pwNew, phgNew, pTokArray, iArray-1, &ichNewCur);

        // add ending '>' and set ichBeginCopy, iArray, ichNewCur appropriately
        memcpy( (BYTE *)&pwNew[ichNewCur], 
                (BYTE *)&pwOld[pTokArray[index].token.ibTokMin], 
                (pTokArray[index].token.ibTokMac-pTokArray[index].token.ibTokMin)*sizeof(WCHAR));
        ichNewCur += (pTokArray[index].token.ibTokMac-pTokArray[index].token.ibTokMin);

        iArray = index+1;
        ichBeginCopy = pTokArray[index].token.ibTokMac;
    }

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;
    return;

} /* fnSaveAImgLink() */

void
CTriEditParse::fnRestoreAImgLink(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD dwFlags)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    LPCWSTR rgTags[] =
    {
        L"DESIGNTIMESP",
        L"DESIGNTIMEREF",
        L"DESIGNTIMEURL",
    };
    int indexStart, indexEnd, i, indexDSR, indexDSP, indexDSU;
    UINT cchsptag, cchhreftag, cchdsurltag;
    CComBSTR bstrRelativeURL;
    BOOL fHrefSrcFound = FALSE;
    UINT cbNeed;

    // we know that DESIGNTIMESP is not saved for these tags, but check it just to be sure.
    // if we find DESIGNTIMEREF, it means that the HREF was dragged on the page while in design view.
    ASSERT(    pTokArray[iArray].token.tok == TokElem_A
            || pTokArray[iArray].token.tok == TokElem_IMG
            || pTokArray[iArray].token.tok == TokElem_LINK);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);

    indexDSP = indexDSR = indexDSU = -1;
    //get the start tag
    indexStart = iArray;
    while (indexStart >= 0) // generally, it will be the previous token, but just in case...
    {
        if (   (pTokArray[indexStart].token.tok == TokTag_START)
            && (pTokArray[indexStart].token.tokClass == tokTag)
            )
        {
            break;
        }
        indexStart--;
    } // while ()
    if (indexStart < 0) // this can happen only if we have incomplete HTML. Handle error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    indexEnd = iArray;
    while (indexEnd < (int)ptep->m_cMaxToken) // generally, it will be the next token, but just in case...
    {
        if (   (pTokArray[indexEnd].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[indexEnd].token.tokClass == tokTag)
            )
        {
            break;
        }
        indexEnd++;
    }
    if (indexEnd >= (int)ptep->m_cMaxToken) // error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // look for DESIGNTIMEREF inside the tags
    cchsptag = wcslen(rgTags[0]);
    cchhreftag = wcslen(rgTags[1]);
    cchdsurltag = wcslen(rgTags[2]);
    for (i = iArray; i < indexEnd; i++)
    {
        if (       pTokArray[i].token.tok == 0
                && pTokArray[i].token.tokClass == tokSpace
                && cchsptag == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                && (0 == _wcsnicmp(rgTags[0], &pwOld[pTokArray[i].token.ibTokMin], cchsptag))
                )
        {
            indexDSP = i;
            if (indexDSR != -1 && indexDSU != -1) // already initilized
                break;
        }
        else if (  pTokArray[i].token.tok == 0
                && pTokArray[i].token.tokClass == tokSpace
                && cchhreftag == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                && (0 == _wcsnicmp(rgTags[1], &pwOld[pTokArray[i].token.ibTokMin], cchhreftag))
                )
        {
            indexDSR = i;
            if (indexDSP != -1 && indexDSU != -1) // already initilized
                break;
        }
        else if (  pTokArray[i].token.tok == 0
                && pTokArray[i].token.tokClass == tokSpace
                && cchhreftag == pTokArray[i].token.ibTokMac - pTokArray[i].token.ibTokMin
                && (0 == _wcsnicmp(rgTags[2], &pwOld[pTokArray[i].token.ibTokMin], cchdsurltag))
                )
        {
            indexDSU = i;
            if (indexDSP != -1 && indexDSR != -1) // already initilized
                break;
        }
    } // for ()

    // Here is the deal - If we found DESIGNTIMESP, it means that this A/Img/Link existed
    // while in source view. And in that case, we shouldn't find DESIGNTIMEREF. With the
    // same token, if we found DESINTIMEREF, it means that this A/Img/Link was dropped
    // while in design view, so DESIGNTIMESP shouldn't be there. They are mutually exclusive.
    
    // Also, DESIGNTIMEURL can exist only if the href was there while in source view
    // and its value was relative. This can coexist with DESIGNTIMESP, 
    // but not with DESIGNTIMEREF.
    if (indexDSP != -1 && indexDSU == -1) // we found DESIGNTIMESP, but not DESIGNTIMEURL
    {
        ASSERT(indexDSR == -1); // based on above statement, this better be true
        iArray = iArraySav + 1;
        goto LRet;
    }
    if (indexDSR == -1 && indexDSU == -1)
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    if (indexDSR != -1)
    {
        ASSERT(indexDSU == -1); // this better be TRUE, because the 2 are mutually exclusive
        // at this point we know that we have DESIGNTIMEREF (that was put in as part 
        // of drag-drop operation while in design view)
        // modify the href and copy the tag.
        if ((int) (pTokArray[indexStart].token.ibTokMin-ichBeginCopy) > 0)
        {
            cbNeed = (ichNewCur+pTokArray[indexStart].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
            if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                goto LRet;

            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichBeginCopy], 
                    (pTokArray[indexStart].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[indexStart].token.ibTokMin-ichBeginCopy);
        }

        cbNeed = (ichNewCur+pTokArray[indexEnd].token.ibTokMac-pTokArray[indexStart].token.ibTokMin)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;

        // trident mucks with the spacing of these tags and we didn't save any spacing info
        // soput endofline at the end of the tag.
        //pwNew[ichNewCur++] = '\r';
        //pwNew[ichNewCur++] = '\n';
        i = indexStart;

        while (i <= indexEnd)
        {
            if (i == indexDSR)
                i++; // don't copy this token
            else if (      (   pTokArray[i].token.tok == TokAttrib_HREF 
                            || pTokArray[i].token.tok == TokAttrib_SRC
                            )
                        && pTokArray[i].token.tokClass == tokAttr
                        && !fHrefSrcFound
                        )
            {
                fHrefSrcFound = TRUE;
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
            else if (      pTokArray[i].token.tok == 0 
                        && pTokArray[i].token.tokClass == tokString
                        && fHrefSrcFound
                        )
            {
                HRESULT hr;
                int cchURL;
                WCHAR *pszURL;
                BOOL fQuote = (pwOld[pTokArray[i].token.ibTokMin] == '"');

                cchURL = (fQuote)
                        ? pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin-2
                        : pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin;
                pszURL = new WCHAR [cchURL+1];

                fHrefSrcFound = FALSE;
                if (ptep->m_bstrBaseURL != NULL) // get the relative URL
                {
                    // get the URL string from pwOld and pass it in to relativise
                    memcpy( (BYTE *)pszURL,
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin + ((fQuote)? 1 : 0)],
                            (cchURL)*sizeof(WCHAR));
                    pszURL[cchURL] = '\0';
                    hr = UtilConvertToRelativeURL((LPOLESTR)pszURL, ptep->m_bstrBaseURL, NULL, &bstrRelativeURL);
                    if (SUCCEEDED(hr))
                    {
                        // can we assume that bstrRelativeURL is NULL terminated?
                        LPWSTR pszRelativeURL = bstrRelativeURL;
                        if (wcslen(pszRelativeURL) == 0)
                        {
                            memcpy( (BYTE *)&pwNew[ichNewCur],
                                    (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                                    (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                            ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                        }
                        else
                        {
                            pwNew[ichNewCur++] = '"';
                            memcpy( (BYTE *)&pwNew[ichNewCur],
                                    (BYTE *)pszRelativeURL,
                                    wcslen(pszRelativeURL)*sizeof(WCHAR));
                            ichNewCur += wcslen(pszRelativeURL);
                            pwNew[ichNewCur++] = '"';
                        }
                    }
                    else
                    {
                        memcpy( (BYTE *)&pwNew[ichNewCur],
                                (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                    }
                }
                else
                {
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                delete pszURL;
                i++;
            }
            else // all other tokens
            {
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
        }
        // trident mucks with the spacing of these tags and we didn't save any spacing info
        // so put endofline at the end of the tag.
        //pwNew[ichNewCur++] = '\r';
        //pwNew[ichNewCur++] = '\n';
    }
    else // DESIGNTIMEURL case
    {
        int indexDSUEnd, indexDSPEnd;
        // we found DESIGNTIMEURL. It means, we had this URL while in source view and it was
        // a relative URL then.
        // Check if trident has made it absolute. If it has and the filename is same, 
        // we need to restore it. In all other cases, simply copy the URL and return.
        ASSERT(indexDSR == -1); // this better be TRUE, because the 2 are mutually exclusive
        if ((int) (pTokArray[indexStart].token.ibTokMin-ichBeginCopy) > 0)
        {
            cbNeed = (ichNewCur+pTokArray[indexStart].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
            if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
                goto LRet;

            memcpy( (BYTE *)&pwNew[ichNewCur], 
                    (BYTE *)&pwOld[ichBeginCopy], 
                    (pTokArray[indexStart].token.ibTokMin-ichBeginCopy)*sizeof(WCHAR));
            ichNewCur += (pTokArray[indexStart].token.ibTokMin-ichBeginCopy);
        }

        cbNeed = (ichNewCur+pTokArray[indexEnd].token.ibTokMac-pTokArray[indexStart].token.ibTokMin)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;
        // get indexDSUEnd
        i = indexDSU;
        indexDSUEnd = -1;
        while (i < indexEnd)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexDSUEnd = i;
                break;
            }
            i++;
        }
        if (indexDSUEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }
        
        // get indexDSPEnd
        i = indexDSP;
        indexDSPEnd = -1;
        while (i < indexEnd)
        {
            if (   pTokArray[i].token.tok == 0 
                && (pTokArray[i].token.tokClass == tokValue || pTokArray[i].token.tokClass == tokString)
                )
            {
                indexDSPEnd = i;
                break;
            }
            i++;
        }
        if (indexDSPEnd == -1) // we have malformed html
        {
            iArray = iArraySav + 1;
            goto LRet;
        }

        i = indexStart;
        while (i <= indexEnd)
        {
            if (   (i >= indexDSU && i <= indexDSUEnd)
                || (i >= indexDSP && i <= indexDSPEnd)
                )
                i++; // don't copy this token
            else if (      (   pTokArray[i].token.tok == TokAttrib_HREF 
                            || pTokArray[i].token.tok == TokAttrib_SRC
                            )
                        && pTokArray[i].token.tokClass == tokAttr
                        && !fHrefSrcFound
                        )
            {
                fHrefSrcFound = TRUE;
                memcpy( (BYTE *)&pwNew[ichNewCur],
                        (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                i++;
            }
            else if (      pTokArray[i].token.tok == 0 
                        && pTokArray[i].token.tokClass == tokString
                        && fHrefSrcFound
                        )
            {
                int ichURL, ichURLEnd, ichDSURL, ichDSURLEnd;
                // if the url is now absloute and is just an absolute version of 
                // the one at indexDSUEnd, we need to replace it.
                ichURL = (pwOld[pTokArray[i].token.ibTokMin] == '"')
                        ? pTokArray[i].token.ibTokMin+1
                        : pTokArray[i].token.ibTokMin;
                ichURLEnd = (pwOld[pTokArray[i].token.ibTokMac-1] == '"')
                        ? pTokArray[i].token.ibTokMac-1
                        : pTokArray[i].token.ibTokMac;
                if (FIsAbsURL((LPOLESTR)&pwOld[ichURL]))
                {
                    WCHAR *pszURL1 = NULL;
                    WCHAR *pszURL2 = NULL;
                    int ich;

                    ichDSURL = (pwOld[pTokArray[indexDSUEnd].token.ibTokMin] == '"')
                            ? pTokArray[indexDSUEnd].token.ibTokMin+1
                            : pTokArray[indexDSUEnd].token.ibTokMin;
                    ichDSURLEnd = (pwOld[pTokArray[indexDSUEnd].token.ibTokMac-1] == '"')
                            ? pTokArray[indexDSUEnd].token.ibTokMac-1
                            : pTokArray[indexDSUEnd].token.ibTokMac;

                    // just for comparison purposes, don't look at '/' or '\' separators
                    // between filenames & directories...
                    pszURL1 = new WCHAR[ichDSURLEnd-ichDSURL + 1];
                    pszURL2 = new WCHAR[ichDSURLEnd-ichDSURL + 1];
                    if (pszURL1 == NULL || pszURL2 == NULL)
                        goto LResumeCopy;
                    memcpy((BYTE *)pszURL1, (BYTE *)&pwOld[ichDSURL], (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                    memcpy((BYTE *)pszURL2, (BYTE *)&pwOld[ichURLEnd-(ichDSURLEnd-ichDSURL)], (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                    pszURL1[ichDSURLEnd-ichDSURL] = '\0';
                    pszURL2[ichDSURLEnd-ichDSURL] = '\0';
                    for (ich = 0; ich < ichDSURLEnd-ichDSURL; ich++)
                    {
                        if (pszURL1[ich] == '/')
                            pszURL1[ich] = '\\';
                        if (pszURL2[ich] == '/')
                            pszURL2[ich] = '\\';
                    }

                    if (0 == _wcsnicmp(pszURL1, pszURL2, ichDSURLEnd-ichDSURL))
                    {
                        pwNew[ichNewCur++] = '"';
                        memcpy( (BYTE *)&pwNew[ichNewCur],
                                (BYTE *)&pwOld[ichDSURL],
                                (ichDSURLEnd-ichDSURL)*sizeof(WCHAR));
                        ichNewCur += (ichDSURLEnd-ichDSURL);
                        pwNew[ichNewCur++] = '"';
                    }
                    else // copy it as it is
                    {
LResumeCopy:
                        memcpy( (BYTE *)&pwNew[ichNewCur],
                                (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                    }
                    if (pszURL1 != NULL)
                        delete pszURL1;
                    if (pszURL2 != NULL)
                        delete pszURL2;
                }
                else // its realtive, simply copy it
                {
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                i++;
            }
            else // all other tokens
            {
                // ****NOTE - we can actually do pretty printing here 
                // instead of fixing the special cases****

                // fix Trident's behaviour - If Trident sees unknown tag(s) it puts it(them) at the end 
                // and inserts EOL before those. In this case, we would have inserted a space before DESIGNTIMESP
                // and Trident would have inserted EOL. If thats not the case, we will ignore it.
                if (   (pTokArray[i].token.tokClass == tokSpace)
                    && (pTokArray[i].token.tok == 0)
                    && (FIsWhiteSpaceToken(pwOld, pTokArray[i].token.ibTokMin, pTokArray[i].token.ibTokMac))
                    )
                {
                    if (i != indexDSU-1) // else skip the copy
                        pwNew[ichNewCur++] = ' '; // convert space+\r+\n into space
                    i++;
                }
                else
                {
                    memcpy( (BYTE *)&pwNew[ichNewCur],
                            (BYTE *)&pwOld[pTokArray[i].token.ibTokMin],
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    ichNewCur += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                    i++;
                }
            }
        } // while (i <= indexEnd)
    } // end of DESIGNTIMEURL case

    // we have spacing save dfor this tag, lets restore it
    if (   (indexDSP != -1)
        && (dwFlags & dwPreserveSourceCode)
        ) 
        ptep->RestoreSpacingSpecial(ptep, pwOld, &pwNew, phgNew, pTokArray, indexDSP, &ichNewCur);


    // remember to set iArray appropriately
    iArray = indexEnd + 1;
    ichBeginCopy = pTokArray[indexEnd].token.ibTokMac;

LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnRestoreAImgLink() */



void
CTriEditParse::fnSaveComment(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{
    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    UINT iCommentStart, iCommentEnd;
    LPCWSTR rgComment[] =
    {
        L"TRIEDITCOMMENT-",
        L"TRIEDITCOMMENTEND-",
        L"TRIEDITPRECOMMENT-",
    };
    int ichSp, cchComment;
    UINT cbNeed;

    // REMOVE METADATA from here, we don't need it because we are checking for end
    // of comment too.

    ASSERT(pTokArray[iArray].token.tok == TokTag_BANG);
    ASSERT(pTokArray[iArray].token.tokClass == tokTag);
    // early return cases
    // 1. see if this is a comment or not. It could be anything that starts with '<!'
    // e.g. <!DOCTYPE
    if (   (iArray+1 < (INT)ptep->m_cMaxToken)
        && (pwOld[pTokArray[iArray+1].token.ibTokMin] == '-')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+1] == '-')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+2] == '[')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+3] == 'i')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+3] == 'I')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+4] == 'f')
        && (pwOld[pTokArray[iArray+1].token.ibTokMin+4] == 'F')
        )
    {
        iCommentStart = iArray; // this is a comment we are interested in
    }
    else
    {
        iArray = iArraySav + 1; // not this one
        goto LRet;
    }
    iCommentEnd = iArray + 2;
    ASSERT(iCommentEnd < (INT)ptep->m_cMaxToken);
    if (   pTokArray[iCommentEnd].token.tok != TokTag_CLOSE 
        && pTokArray[iCommentEnd].token.tokClass != tokTag)
    {
        // we have found something that looks like a comment to begin with, but its
        // something else like a DTC, webbot stuff or some thing else...
        iArray = iArraySav + 1; // not this one
        goto LRet;
    }

    // write the spacing info, reallocate pwNew if needed
    cchComment = pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin;
    cbNeed = (ichNewCur+2*cchComment+wcslen(rgComment[0])+wcslen(rgComment[1])+(pTokArray[iCommentStart].token.ibTokMac-ichBeginCopy+2))*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;

    // write till '<!--' part of the comment
    memcpy( (BYTE *)&pwNew[ichNewCur],
            (BYTE *)&pwOld[ichBeginCopy],
            (pTokArray[iCommentStart].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
    ichNewCur += pTokArray[iCommentStart].token.ibTokMac-ichBeginCopy;
    pwNew[ichNewCur++] = '-';
    pwNew[ichNewCur++] = '-';
    
    // write the spacing info keyword
    memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgComment[0], wcslen(rgComment[0])*sizeof(WCHAR));
    ichNewCur += wcslen(rgComment[0]);
    //write spacing block
    ichSp = pTokArray[iCommentStart+1].token.ibTokMin+2; // exclude -- from <!--comment
    while (ichSp < (int)(pTokArray[iCommentStart+1].token.ibTokMac-2))// exclude -- from comment-->
    {
        switch (pwOld[ichSp++])
        {
        case ' ':
            pwNew[ichNewCur++] = chCommentSp;
            break;
        case '\t':
            pwNew[ichNewCur++] = chCommentTab;
            break;
        case '\r':
            pwNew[ichNewCur++] = chCommentEOL;
            break;
        case '\n':
            break;
        default:
            if (pwNew[ichNewCur-1] != ',')
                pwNew[ichNewCur++] = ',';
            break;
        } // switch()
    }

    // write the spacing info keyword
    memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgComment[1], wcslen(rgComment[1])*sizeof(WCHAR));
    ichNewCur += wcslen(rgComment[1]);

    //write spacing block for pre comment
    // go back from pwOld[ichSp] and see where we have the last non-white space
    ichSp = pTokArray[iCommentStart].token.ibTokMin-1;
    while (    (ichSp >= 0)
            && (   pwOld[ichSp] == ' '  || pwOld[ichSp] == '\t'
                || pwOld[ichSp] == '\r' || pwOld[ichSp] == '\n'
                )
            )
    {
        ichSp--;
    }
    ichSp++; // compensate because ichSp points to non-white space character at this point
    ASSERT(pTokArray[iCommentStart].token.ibTokMin >= (UINT)ichSp);
    cbNeed = (ichNewCur+2*(pTokArray[iCommentStart].token.ibTokMin-ichSp)+wcslen(rgComment[2]))*sizeof(WCHAR)+cbBufPadding;
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
        goto LRet;
    while (ichSp < (int)(pTokArray[iCommentStart].token.ibTokMin))
    {
        switch (pwOld[ichSp++])
        {
        case ' ':
            pwNew[ichNewCur++] = chCommentSp;
            break;
        case '\t':
            pwNew[ichNewCur++] = chCommentTab;
            break;
        case '\r':
            pwNew[ichNewCur++] = chCommentEOL;
            break;
        case '\n':
            break;
        default:
            if (pwNew[ichNewCur-1] != ',')
                pwNew[ichNewCur++] = ',';
            break;
        } // switch()
    }
    // write the spacing info keyword
    memcpy((BYTE *)&pwNew[ichNewCur], (BYTE *)rgComment[2], wcslen(rgComment[2])*sizeof(WCHAR));
    ichNewCur += wcslen(rgComment[2]);
    
    // write the comment
    memcpy( (BYTE *)&pwNew[ichNewCur],
            (BYTE *)&pwOld[pTokArray[iCommentStart+1].token.ibTokMin+2], 
            (pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2)*sizeof(WCHAR));
    ichNewCur += pTokArray[iCommentStart+1].token.ibTokMac-pTokArray[iCommentStart+1].token.ibTokMin-2;

    // write the ending '>'
    pwNew[ichNewCur++] = '>'; // alternatively, we could write iCommentEnd'th token

    // set iArray & ichBeginCopy
    iArray = iCommentEnd+1;
    ichBeginCopy = pTokArray[iCommentEnd].token.ibTokMac;
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnSaveComment() */

void
CTriEditParse::fnRestoreComment(CTriEditParse* /*ptep*/,
          LPWSTR /*pwOld*/, LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT* /*piArrayStart*/, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*pichBeginCopy*/,
          DWORD /*dwFlags*/)
{
    ASSERT(FALSE); // this case is handled by fnRestoreObject(), so we shouldn't reach here
    return;

} /* fnRestoreComment() */

void
CTriEditParse::fnSaveTextArea(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
          TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT *pichNewCur, UINT *pichBeginCopy,
          DWORD /*dwFlags*/)
{

    UINT ichNewCur = *pichNewCur;
    UINT ichBeginCopy = *pichBeginCopy;
    UINT iArray = *piArrayStart;
    LPWSTR pwNew = *ppwNew;
    UINT iArraySav = iArray;
    UINT cbNeed;
    UINT iTextAreaEnd;

    // look for TEXTAREA block and simply copy it into pwNew. Thereby avoiding the
    // space preservation & stuff.

    ASSERT(pTokArray[iArray].token.tok == TokElem_TEXTAREA);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);
    iTextAreaEnd = pTokArray[iArray].iNextprev;
    if (iTextAreaEnd == -1) // we don't have matching </textarea>
    {
        // ignore this case
        iArray = iArraySav + 1;
        goto LRet;
    }

    // NOTE that we don't even need to get get the '<' before the textarea here because we are
    // not doing anything special with them. We simply are going to copy everything inside the
    // textarea to pwNew. So, we start copying from ichBeginCopy and copy till end of the 
    // textarea block.

    // get the '>' after the matching end textarea, generally this will be right after iTextAreaEnd
    while (iTextAreaEnd < (int)ptep->m_cMaxToken)
    {
        if (   (pTokArray[iTextAreaEnd].token.tok == TokTag_CLOSE) /* > */
            && (pTokArray[iTextAreaEnd].token.tokClass == tokTag)
            )
        {
            break;
        }
        iTextAreaEnd++;
    }
    if (iTextAreaEnd >= (int)ptep->m_cMaxToken) // error case
    {
        iArray = iArraySav + 1;
        goto LRet;
    }

    // copy the textarea block into pwNew. Make sure that we have enough space in pwNew
    // NOTE - pTokArray[iTextAreaEnd].token.ibTokMac should be larger than ichBeginCopy,
    // but at this point in the game the assert is of no use, because no one is using 
    // debug builds (6/10/98)
    if ((int) (pTokArray[iTextAreaEnd].token.ibTokMac-ichBeginCopy) > 0)
    {
        cbNeed = (ichNewCur+pTokArray[iTextAreaEnd].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR)+cbBufPadding;
        if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
            goto LRet;

        memcpy( (BYTE *)&pwNew[ichNewCur], 
                (BYTE *)&pwOld[ichBeginCopy], 
                (pTokArray[iTextAreaEnd].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (pTokArray[iTextAreaEnd].token.ibTokMac-ichBeginCopy);
    }

    // set iArray & ichBeginCopy
    iArray = iTextAreaEnd+1;
    ichBeginCopy = pTokArray[iTextAreaEnd].token.ibTokMac;
LRet:
    *pcchNew = ichNewCur;
    *ppwNew = pwNew;

    *pichNewCur = ichNewCur;
    *pichBeginCopy = ichBeginCopy;
    *piArrayStart = iArray;

    return;

} /* fnSaveTextArea() */

void
CTriEditParse::fnRestoreTextArea(CTriEditParse* /*ptep*/,
          LPWSTR /*pwOld*/, LPWSTR* /*ppwNew*/, UINT* /*pcchNew*/, HGLOBAL* /*phgNew*/, 
          TOKSTRUCT* /*pTokArray*/, UINT *piArrayStart, FilterTok /*ft*/,
          INT* /*pcHtml*/, UINT* /*pichNewCur*/, UINT* /*pichBeginCopy*/,
          DWORD /*dwFlags*/)
{
    UINT iArray = *piArrayStart;

    // ideally, (for next version) we should restore the trident-converted &gt's & stuff
    // for now, we are simply going to ignore this tag on the way back from trident
    // NOTE that we never put in designtimesp's in this block, so we souldn't have to look
    // for them here.

    ASSERT(pTokArray[iArray].token.tok == TokElem_TEXTAREA);
    ASSERT(pTokArray[iArray].token.tokClass == tokElem);

    iArray++; // skip this textarea tag

    *piArrayStart = iArray;
    return;

} /* fnRestoreTextArea() */

void
CTriEditParse::FilterHtml(LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew,
                          HGLOBAL *phgNew, TOKSTRUCT *pTokArray, 
                          FilterMode mode, DWORD dwFlags)
{
    UINT iArray = 0;
    UINT ichNewCur = 0;
    UINT ichBeginCopy = 0;
    HRESULT hr;
    INT index = 0;
    INT iItem;
    INT cItems = 0;
    INT cRuleMid = cRuleMax / 2; // ASSUME that cRuleMax is an even number

    FilterRule fr[cRuleMax] =
    {
    // make sure that modeInput and modeOutput have the matching entries.
    // modeInput entries
    {TokTag_BANG, TokAttrib_STARTSPAN, tokClsIgnore, TokTag_CLOSE, TokAttrib_ENDSPAN, tokClsIgnore, fnSaveDTC},
    {TokTag_SSSOPEN, -1, tokClsIgnore, TokTag_SSSCLOSE, -1, tokClsIgnore, fnSaveSSS},
    {TokTag_START, TokElem_HTML, tokClsIgnore, TokTag_CLOSE, TokElem_HTML, tokClsIgnore, fnSaveHtmlTag},
    {-1, -1, tokEntity, -1, -1, tokEntity, fnSaveNBSP},
    {-1, TokElem_BODY, tokElem, -1, -1, tokClsIgnore, fnSaveHdr},
    {TokTag_END, TokElem_BODY, tokElem, -1, -1, tokClsIgnore, fnSaveFtr},
    {-1, TokTag_START, tokTag, TokTag_CLOSE, -1, tokClsIgnore, fnSaveSpace},
    {TokTag_START, TokElem_OBJECT, tokElem, TokTag_CLOSE, TokElem_OBJECT, tokElem, fnSaveObject},
    {TokTag_START, TokElem_TBODY, tokElem, TokTag_CLOSE, -1, tokTag, fnSaveTbody},
    {-1, TokElem_APPLET, tokElem, -1, -1, -1, fnSaveApplet},
    {TokTag_START, TokElem_A, tokElem, TokTag_CLOSE, TokAttrib_HREF, tokTag, fnSaveAImgLink},
    {-1, TokTag_BANG, tokTag, -1, -1, tokClsIgnore, fnSaveComment},
    {TokTag_START, TokElem_TEXTAREA, tokElem, TokTag_CLOSE, TokElem_TEXTAREA, tokClsIgnore, fnSaveTextArea},

    // modeOutput entries
    {TokTag_START, TokElem_OBJECT, tokClsIgnore, TokTag_CLOSE, TokElem_OBJECT, tokClsIgnore, fnRestoreDTC},
    {TokTag_START, TokElem_SCRIPT, tokClsIgnore, TokTag_CLOSE, TokElem_SCRIPT, tokClsIgnore, fnRestoreSSS},
    {-1, -1, tokClsIgnore, -1, -1, tokClsIgnore, fnRestoreHtmlTag},
    {-1, -1, tokEntity, -1, -1, tokEntity, fnRestoreNBSP},
    {-1, TokElem_BODY, tokElem, -1, -1, tokClsIgnore, fnRestoreHdr},
    {TokTag_END, TokElem_BODY, tokElem, -1, -1, tokClsIgnore, fnRestoreFtr},
    {TokTag_START, TokTag_END, tokSpace, TokTag_CLOSE, -1, tokClsIgnore, fnRestoreSpace},
    {-1, TokTag_BANG, tokTag, TokTag_CLOSE, -1, tokTag, fnRestoreObject},
    {TokTag_START, TokElem_TBODY, tokElem, TokTag_CLOSE, -1, tokTag, fnRestoreTbody},
    {TokTag_START, TokElem_APPLET, tokElem, TokTag_CLOSE, -1, tokTag, fnRestoreApplet},
    {TokTag_START, TokElem_A, tokElem, TokTag_CLOSE, TokAttrib_HREF, tokTag, fnRestoreAImgLink},
    {-1, TokTag_BANG, tokTag, TokTag_CLOSE, -1, tokTag, fnRestoreObject},
    {TokTag_START, TokElem_TEXTAREA, tokElem, TokTag_CLOSE, TokElem_TEXTAREA, tokClsIgnore, fnRestoreTextArea},
    };
    
    memcpy(m_FilterRule, fr, sizeof(FilterRule)*cRuleMax);
    ASSERT(pwOld != NULL);
    ASSERT(*ppwNew != NULL);

    if (mode == modeInput)
    {
        cItems = m_cDTC + m_cSSSIn + m_cHtml + m_cNbsp + m_cHdr + m_cFtr + m_cObjIn + m_ispInfoIn + m_cAppletIn + m_cAImgLink;
        while (cItems > 0)
        {
            if (iArray >= m_cMaxToken) // this will catch error cases
                break;

            while (iArray < m_cMaxToken)
            {   
                // its OK to enumerate the comparison rules, but once we have
                // a lot of rules, this needs to be made into a function
                if (pTokArray[iArray].token.tok == m_FilterRule[0].ft.tokBegin2 && m_cDTC > 0)
                {
                    m_cDTC--;
                    iItem = 1;
                    index = 0;
                    break;
                }
                else if (     (m_FilterRule[1].ft.tokBegin2 != -1)
                            ? (pTokArray[iArray].token.tok == m_FilterRule[1].ft.tokBegin2 && m_cSSSIn > 0)
                            : (pTokArray[iArray].token.tok == m_FilterRule[1].ft.tokBegin && m_cSSSIn > 0)
                            )
                {
                    m_cSSSIn--;
                    iItem = 1;
                    index = 1;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[2].ft.tokBegin2 && m_cHtml > 0)
                {
                    m_cHtml--;
                    iItem = 1;
                    index = 2;
                    break;
                }
                else if (      m_FilterRule[3].ft.tokBegin == -1 
                            && m_FilterRule[3].ft.tokBegin2 == -1
                            && m_FilterRule[3].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_cNbsp > 0)
                {
                    m_cNbsp--;
                    iItem = 1;
                    index = 3;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[4].ft.tokBegin2 && m_cHdr > 0)
                {
                    m_cHdr--;
                    iItem = 1;
                    index = 4;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[5].ft.tokBegin2
                            && pTokArray[iArray-1].token.tok == m_FilterRule[5].ft.tokBegin
                            && m_cFtr > 0
                            )
                {
                    m_cFtr--;
                    iItem = 1;
                    index = 5;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[6].ft.tokBegin2 
                            && m_FilterRule[6].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_ispInfoIn > 0
                            && (dwFlags & dwPreserveSourceCode)
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = 6;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[7].ft.tokBegin2 
                            && pTokArray[iArray].token.tokClass == m_FilterRule[7].ft.tokClsBegin
                            && pTokArray[iArray-1].token.tok == TokTag_START
                            && pTokArray[iArray-1].token.tokClass == tokTag
                            && m_cObjIn > 0
                            )
                {
                    m_cObjIn--;
                    iItem = 1;
                    index = 7;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[8].ft.tokBegin2
                            && pTokArray[iArray].token.tokClass == m_FilterRule[8].ft.tokClsBegin
                            && pTokArray[iArray-1].token.tok == TokTag_START
                            && pTokArray[iArray-1].token.tokClass == tokTag
                            && (dwFlags & dwPreserveSourceCode)
                            )
                {
                    cItems++; //to compensate for cItems-- after the pfn() call
                    iItem = 1;
                    index = 8;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[9].ft.tokBegin2 
                            && m_FilterRule[9].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_cAppletIn > 0
                            )
                {
                    cItems++; //to compensate for cItems-- after the pfn() call
                    m_cAppletIn--;
                    index = 9;
                    break;
                }
                else if (      (   pTokArray[iArray].token.tok == m_FilterRule[10].ft.tokBegin2
                                || pTokArray[iArray].token.tok == TokElem_IMG
                                || pTokArray[iArray].token.tok == TokElem_LINK)
                            && m_FilterRule[10].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_cAImgLink > 0
                            && (pTokArray[iArray-1].token.tok == m_FilterRule[10].ft.tokBegin)
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = 10;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[11].ft.tokBegin2 
                            && m_FilterRule[11].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = 11;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[12].ft.tokBegin2 
                            && m_FilterRule[12].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && pTokArray[iArray-1].token.tok == m_FilterRule[12].ft.tokBegin
                            && pTokArray[iArray-1].token.tokClass == tokTag
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = 12;
                    break;
                }

                iArray++;
            }
            if (iArray < m_cMaxToken) // we found a match
            {
                // call that function
                m_FilterRule[index].pfn(    this, pwOld, ppwNew, pcchNew, phgNew, pTokArray, 
                                            &iArray, m_FilterRule[index].ft, &iItem, 
                                            &ichNewCur, &ichBeginCopy,
                                            dwFlags);
            }

            cItems--;
        } // while (cItems > 0)
    }
    else if (mode == modeOutput)
    {
        cItems = m_cObj + m_cSSSOut + m_cHtml + m_cNbsp + m_cHdr + m_cFtr + m_cComment + m_ispInfoOut + m_cAppletOut + m_cAImgLink;
        while (cItems > 0)
        {
            if (iArray >= m_cMaxToken) // this will catch error cases
                break;

            while (iArray < m_cMaxToken)
            {   
                // its OK to enumerate the comparison rules, but once we have
                // a lot of rules, this needs to be made into a function
                if (   pTokArray[iArray].token.tok == m_FilterRule[cRuleMid].ft.tokBegin2
                    && pTokArray[iArray-1].token.tok == TokTag_START
                    && m_cObj > 0
                        )
                {
                    m_cObj--;
                    index = cRuleMid;
                    iItem = m_iControl;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+1].ft.tokBegin2 && m_cSSSOut > 0)
                {
                    m_cSSSOut--;
                    iItem = 1;
                    index = cRuleMid+1;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+2].ft.tokBegin2 && m_cHtml > 0)
                {
                    m_cHtml--;
                    iItem = 1;
                    index = cRuleMid+2;
                    break;
                }
                else if (      m_FilterRule[cRuleMid+3].ft.tokBegin == -1 
                            && m_FilterRule[cRuleMid+3].ft.tokBegin2 == -1
                            && m_FilterRule[cRuleMid+3].ft.tokClsBegin == tokEntity
                            && m_cNbsp > 0)
                {
                    m_cNbsp--;
                    iItem = 1;
                    index = cRuleMid+3;
                    break;
                }
                else if (pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+4].ft.tokBegin2 && m_cHdr > 0)
                {
                    m_cHdr--;
                    iItem = 1;
                    index = cRuleMid+4;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+5].ft.tokBegin2 
                            && pTokArray[iArray-1].token.tok == m_FilterRule[cRuleMid+5].ft.tokBegin
                            && m_cFtr > 0)
                {
                    m_cFtr--;
                    iItem = 1;
                    index = cRuleMid+5;
                    break;
                }
                else if (      (       pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+6].ft.tokClsBegin
                                    || (       pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+6].ft.tokBegin2
                                            && pTokArray[iArray].token.tokClass == tokTag
                                            )
                                    )
                            && (dwFlags & dwPreserveSourceCode)
                            )
                {
                    index = cRuleMid+6;
                    cItems++; // to compensate for cItems-- after the pfn() call
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+7].ft.tokBegin2 
                            && pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+7].ft.tokClsBegin
                            && m_cComment > 0
                            )
                {
                    m_cComment--;
                    iItem = 1;
                    index = cRuleMid+7;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+8].ft.tokBegin2 
                            && pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+8].ft.tokClsBegin
                            && (dwFlags & dwPreserveSourceCode)
                            )
                {
                    // Note that TBody filtering is tied in with space preservation.
                    // In ideal world it shouldn't be, but thats acceptable to the most.
                    // If this view changes, we need to add some other designtime attribute 
                    // along with spacing attributes. This will be somewhat big change than 
                    // simply adding an attribute because then we need to change the code to 
                    // start going backwards in the token array in the main loop.
                    iItem = 1;
                    index = cRuleMid+8;
                    cItems++; //  to compensate for cItems-- after the pfn() call
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+9].ft.tokBegin2
                            && pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+9].ft.tokClsBegin
                            && pTokArray[iArray-1].token.tok == m_FilterRule[cRuleMid+9].ft.tokBegin
                            && m_cAppletOut > 0
                            )
                {
                    cItems++; //  to compensate for cItems-- after the pfn() call
                    m_cAppletOut--;
                    index = cRuleMid+9;
                    break;
                }
                else if (      (   pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+10].ft.tokBegin2
                                || pTokArray[iArray].token.tok == TokElem_IMG
                                || pTokArray[iArray].token.tok == TokElem_LINK)
                            && m_FilterRule[cRuleMid+10].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && m_cAImgLink > 0
                            && (pTokArray[iArray-1].token.tok == m_FilterRule[cRuleMid+10].ft.tokBegin)
                            )
                {
                    index = cRuleMid+10;
                    cItems++; //  to compensate for cItems-- after the pfn() call
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+11].ft.tokBegin2 
                            && pTokArray[iArray].token.tokClass == m_FilterRule[cRuleMid+11].ft.tokClsBegin
                            )
                {
                    // actually, we won't reach here - just a dummy
                    cItems++; //  to compensate for cItems-- after the pfn() call
                    index = cRuleMid+11;
                    break;
                }
                else if (      pTokArray[iArray].token.tok == m_FilterRule[cRuleMid+12].ft.tokBegin2 
                            && m_FilterRule[cRuleMid+12].ft.tokClsBegin == pTokArray[iArray].token.tokClass
                            && pTokArray[iArray-1].token.tok == m_FilterRule[cRuleMid+12].ft.tokBegin
                            && pTokArray[iArray-1].token.tokClass == tokTag
                            )
                {
                    cItems++; // to compensate for cItems-- after the pfn() call
                    index = cRuleMid+12;
                    break;
                }


                iArray++;
            }
            if (iArray < m_cMaxToken) // we found a match
            {
                // call that function
                m_FilterRule[index].pfn(    this, pwOld, ppwNew, pcchNew, phgNew, pTokArray, 
                                            &iArray, m_FilterRule[index].ft, &iItem, 
                                            &ichNewCur, &ichBeginCopy,
                                            dwFlags);
            }

            if (m_fDontDeccItem) // we can do things differently next time
            {
                m_fDontDeccItem = FALSE;
                cItems++;
            }
            cItems--;
        } // while (cItems > 0)
    }
    else
        ASSERT(FALSE);


    if (cItems == 0) // everything ok, copy rest of the doc
    {
LIncorrectcItems:
        // copy rest of the stuff into pwNew
        /* REALLOCATE pwNew IF NEEDED here use cache value for GlobalSize(*phgNew) and don't forget to update it too */
        if (GlobalSize(*phgNew) < (ichNewCur+pTokArray[m_cMaxToken-1].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR))
        {
            hr = ReallocBuffer( phgNew,
                                (ichNewCur+pTokArray[m_cMaxToken-1].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR),
                                GMEM_MOVEABLE|GMEM_ZEROINIT);
            if (hr == E_OUTOFMEMORY)
                goto LCopyAndRet;
            ASSERT(*phgNew != NULL);
            *ppwNew = (WCHAR *)GlobalLock(*phgNew);
        }
        memcpy( (BYTE *)(*ppwNew+ichNewCur),
                (BYTE *)(pwOld+ichBeginCopy),
                (pTokArray[m_cMaxToken-1].token.ibTokMac-ichBeginCopy)*sizeof(WCHAR));
        ichNewCur += (pTokArray[m_cMaxToken-1].token.ibTokMac-ichBeginCopy);
        *pcchNew = ichNewCur;
    }
    else
    {
        // this means that we calculated one of m_c's incorrectly. We need to fix that
        // case in M4
        goto LIncorrectcItems;

LCopyAndRet:
        memcpy( (BYTE *)*ppwNew,
                (BYTE *)pwOld,
                (pTokArray[m_cMaxToken-1].token.ibTokMac)*sizeof(WCHAR));
        *pcchNew = pTokArray[m_cMaxToken-1].token.ibTokMac;
    }

} /* CTriEditParse::FilterHtml() */

int
CTriEditParse::ValidateTag(LPWSTR pszText)
{
    int len = 0;

    if (pszText == NULL)
        return(0);
    // check for the first non Alpha in the pszText and return it. Add '\0' at the end
    while (    (*(pszText+len) >= _T('A') && *(pszText+len) <= _T('Z'))
            || (*(pszText+len) >= _T('a') && *(pszText+len) <= _T('z'))
            || (*(pszText+len) >= _T('0') && *(pszText+len) <= _T('9'))
            )
    {
        len++;
    }

    return(len);
}

INT
CTriEditParse::GetTagID(LPWSTR pszText, TXTB token)
{
    WCHAR szTag[MAX_TOKIDLEN+1];
    int len;
    int tagID;

    len = ValidateTag(pszText+token.ibTokMin);
    if (len == 0 || len != (int)(token.ibTokMac-token.ibTokMin))
        tagID = -1;
    else
    {
		if (token.tok == 0 && token.tokClass == tokIDENTIFIER)
			tagID = -1;
		else
		{
			memcpy((BYTE *)szTag, (BYTE *)(pszText+token.ibTokMin), (min(len, MAX_TOKIDLEN))*sizeof(WCHAR));
			szTag[min(len, MAX_TOKIDLEN)] = '\0';
			tagID = IndexFromElementName((LPCTSTR) szTag);
		}
    }
    return(tagID);
}
void
CTriEditParse::PreProcessToken(TOKSTRUCT *pTokArray, INT *pitokCur, LPWSTR /*pszText*/, 
                               UINT /*cbCur*/, TXTB token, DWORD lxs, INT tagID, FilterMode mode)
{
    TOKSTRUCT *pTokT = pTokArray + *pitokCur;

    if (*pitokCur == -1) // the buffer reallocation must have failed
        goto LSkipArrayOp;

    // if (lxs & inTag) then we can ASSERT(token.tok == TokTag_START)
    //put the new token into pTokArray at *pitokCur position
    pTokT->token = token;
    pTokT->fStart = (lxs & inEndTag)?FALSE:TRUE;
    pTokT->ichStart = token.ibTokMin;
    pTokT->iNextprev = 0xFFFFFFFF; // init value
    pTokT->iNextPrevAlternate = 0xFFFFFFFF; // init value
    pTokT->tagID = tagID;

    if (mode == modeInput)
    {
        if (   pTokT->token.tok == TokTag_SSSOPEN
            && pTokT->token.tokClass == tokSSS
            && ((lxs & inSCRIPT) || (lxs & inAttribute))
            )
        {
            pTokT->token.tok = TokTag_SSSOPEN_TRIEDIT;
        }
        if (   pTokT->token.tok == TokTag_SSSCLOSE
            && pTokT->token.tokClass == tokSSS
            && ((lxs & inSCRIPT) || (lxs & inAttribute))
            )
        {
            pTokT->token.tok = TokTag_SSSCLOSE_TRIEDIT;
        }
    }

    *pitokCur += 1;

LSkipArrayOp:
    return;

} /* CTriEditParse::PreProcessToken() */


// Handle special cases of replacing things and saving the replaced contents
void
CTriEditParse::PostProcessToken(OLECHAR* /*pwOld*/, OLECHAR* /*pwNew*/, UINT* /*pcbNew*/, 
                                UINT /*cbCur*/, UINT /*cbCurSav*/, TXTB token, 
                                FilterMode mode, DWORD lxs, DWORD dwFlags)
{
    // handle special cases of replacing the DTCs, ServerSideScripts etc.
    // save the contents into a buffer if (mode == modeInput)
    // put the contents back into buffer if (mode == modeOutput)

    if (mode == modeInput)
    {
        if (   token.tok == TokAttrib_ENDSPAN
            && token.tokClass == tokAttr
            && (dwFlags & (dwFilterDTCs | dwFilterDTCsWithoutMetaTags))
            )
        {
            m_cDTC++;
        }
        if (   token.tok == TokTag_SSSCLOSE
            && token.tokClass == tokSSS
            && !(lxs & inAttribute) // !(lxs & inValue && lxs & inTag)
            && !(lxs & inSCRIPT)
            && (dwFlags & dwFilterServerSideScripts)
            )
        {
            m_cSSSIn++;
        }
        if (   token.tokClass == tokEntity
            && dwFlags != dwFilterNone
            )
        {
            m_cNbsp++;
        }
        if (   (token.tok == TokElem_OBJECT)
            && (token.tokClass == tokElem)
            && (lxs & inEndTag)
            && (dwFlags != dwFilterNone)
            )
        {
            m_cObjIn++;
        }
        if (   token.tok == TokElem_APPLET
            && token.tokClass == tokElem
            && (lxs & inEndTag)
            && (dwFlags != dwFilterNone)
            )
        {
            m_cAppletIn++;
        }
    }
    else if (mode == modeOutput)
    {
        if (   token.tok == TokElem_OBJECT
            && token.tokClass == tokElem
            && (lxs & inTag && !(lxs & inEndTag))
            && (dwFlags & (dwFilterDTCs | dwFilterDTCsWithoutMetaTags))
            )
        {
            m_cObj++;
        }
        if (   token.tok == TokElem_SCRIPT
            && token.tokClass == tokElem
            && (lxs & inEndTag)
            && (dwFlags & dwFilterServerSideScripts)
            )
        {
            m_cSSSOut++;
        }
        if (   token.tok == TokTag_BANG
            && token.tokClass == tokTag
            )
        {
            m_cComment++;
        }
        if (   token.tok == TokElem_APPLET
            && token.tokClass == tokElem
            && (lxs & inEndTag)
            && (dwFlags != dwFilterNone)
            )
        {
            m_cAppletOut++;
        }
    }

} /* CTriEditParse::PostProcessToken() */

HRESULT 
CTriEditParse::ProcessToken(DWORD &lxs, TXTB &tok, LPWSTR pszText, 
                            UINT /*cbCur*/, TOKSTACK *pTokStack, INT *pitokTop, 
                            TOKSTRUCT *pTokArray, INT iArrayPos, INT tagID)
{
    TXTB token = tok;

    if (*pitokTop == -1) // the buffer reallocation must have failed
        goto LSkipStackOp;

    if (lxs & inEndTag) // end tag begins, set m_fEndTagFound
        m_fEndTagFound = TRUE;

    if (tagID == -1) // we need to put only the IDENTIFIERS on the stack
    {
        // special cases (1)<%, (2)%>, (3)startspan, (4)endspan
        if (token.tok == TokTag_SSSOPEN && token.tokClass == tokSSS /*&& !(lxs & inAttribute)*/) // <%
        {
            token.tok = TokTag_SSSCLOSE; // fake it so that we can use the same code for matching %>
            goto LSpecialCase;
        }
        else if (token.tok == TokTag_SSSCLOSE && token.tokClass == tokSSS /*&& !(lxs & inAttribute)*/) // %>
        {
            m_fEndTagFound = TRUE; // lxs is not inEndTag when we get TokTag_SSSCLOSE
            goto LSpecialCase;
        }
        else if (token.tok == TokAttrib_STARTSPAN && token.tokClass == tokAttr) // startspan
        {
            token.tok = TokAttrib_ENDSPAN; // fake it so that we can use the same code for matching endspan
            goto LSpecialCase;
        }
        else if (token.tok == TokAttrib_ENDSPAN && token.tokClass == tokAttr) // endspan
        {
            LPCWSTR szDesignerControl[] =
            {
                L"\"DesignerControl\"",
                L"DesignerControl",
            };
            
            // HACK to fix FrontPage BUG - DaVinci puts a dummy endspan & startspan between
            // the "DESIGNERCONTROL" startspan-endspan pair. We want to make sure that
            // our pTokArray has correct matching iNextprev for the TokAttrib_STARTSPAN
            // Refer VID bug 3991
            if (       (iArrayPos-3 >= 0) /* validation */
                    && (   0 == _wcsnicmp(szDesignerControl[0], &pszText[pTokArray[iArrayPos-3].token.ibTokMin], wcslen(szDesignerControl[0]))
                        || 0 == _wcsnicmp(szDesignerControl[1], &pszText[pTokArray[iArrayPos-3].token.ibTokMin], wcslen(szDesignerControl[1]))
                        )
                    )
            {
                m_fEndTagFound = TRUE; // lxs is not inEndTag when we get TokAttrib_ENDSPAN
                goto LSpecialCase;
            }
            else
                goto LSkipStackOp;
        }
        else
        {
            if (m_fEndTagFound)
                m_fEndTagFound = FALSE;
            goto LSkipStackOp;
        }
    }

LSpecialCase:   
    if (m_fEndTagFound) // end tag was found previously, means pop from the stack
    {
        TOKSTACK *pTokT;

        if (*pitokTop == 0) // we don't have anything on stack, we can't delete it
            goto LSkipStackOp;

        pTokT = pTokStack + *pitokTop - 1;
        m_fEndTagFound = FALSE; // reset

        // if we get an end tag, in ideal case, the top of the stack should
        // match with what we got
        if (tagID == pTokT->tagID)
        {
            if (tagID == -1) // special case, match token.tok & token.tokClass
            {
                if (   (pTokT->token.tok == TokTag_SSSCLOSE) /* faked token for <% */
                    && (pTokT->token.tokClass == tokSSS)
                    )
                {
                    ASSERT(token.tok == TokTag_SSSCLOSE);
                    goto LMatch;
                }
                else if (   (pTokT->token.tok == TokAttrib_ENDSPAN) /* faked token for startspan */
                    && (pTokT->token.tokClass == tokAttr)
                    )
                {
                    ASSERT(token.tok == TokAttrib_ENDSPAN);
                    goto LMatch;
                }
                else // we may have found another special case
                {
                    goto LNoMatch;
                }
            }
LMatch:
            ASSERT(iArrayPos - 1 >= 0);
            // put iNextPrev or INextPrevAlternate for the matching start token in pTokArray
            pTokArray[pTokT->iMatch].iNextprev = iArrayPos - 1;
            ASSERT(pTokArray[pTokT->iMatch].fStart == TRUE);
            ASSERT(pTokT->ichStart == pTokArray[pTokT->iMatch].token.ibTokMin);
            pTokArray[iArrayPos-1].iNextprev = pTokT->iMatch;
            
            ASSERT(*pitokTop >= 0);
            *pitokTop -= 1; // pop the stack
        }
        else
        {
LNoMatch:
            int index;

            // look for the first entry down the array that matches
            index = *pitokTop - 1;
            while (index >= 0)
            {
                if (tagID == (pTokStack+index)->tagID)
                {
                    if (tagID == -1) // special case
                    {
                        if (       (   ((pTokStack+index)->token.tok == TokTag_SSSCLOSE) /* faked token for <% */
                                    && ((pTokStack+index)->token.tokClass == tokSSS)
                                    && (token.tok == TokTag_SSSCLOSE)
                                    && (token.tokClass == tokSSS)
                                    )
                                || (   ((pTokStack+index)->token.tok == TokAttrib_ENDSPAN) /* faked token for startspan */
                                    && ((pTokStack+index)->token.tokClass == tokAttr)
                                    && (token.tok == TokAttrib_ENDSPAN)
                                    && (token.tokClass == tokAttr)
                                    )
                                )
                            break;
                        //else actually, this means error case.
                    }
                    else
                        break;
                }
                index--;
            }

            if (index != -1) // match was found at index'th position on the stack
            {
                int i;
                TOKSTACK *pTokIndex = pTokStack + index;

                ASSERT(index >= 0);
                ASSERT(iArrayPos - 1 >= 0);
                
                if (tagID == -1) // special case, match token.tok & token.tokClass
                {
                    ASSERT(    (   (pTokIndex->token.tok == TokTag_SSSCLOSE) /* faked token for <% */
                                && (pTokIndex->token.tokClass == tokSSS)
                                && (token.tok == TokTag_SSSCLOSE)
                                && (token.tokClass == tokSSS)
                                )
                            || (   ((pTokStack+index)->token.tok == TokAttrib_ENDSPAN) /* faked token for startspan */
                                && ((pTokStack+index)->token.tokClass == tokAttr)
                                && (token.tok == TokAttrib_ENDSPAN)
                                && (token.tokClass == tokAttr)
                                )
                            );
                }
                // first of all fill in appropriate iNextprev
                pTokArray[pTokIndex->iMatch].iNextprev = iArrayPos - 1;
                ASSERT(pTokArray[pTokIndex->iMatch].fStart == TRUE);
                pTokArray[iArrayPos-1].iNextprev = pTokIndex->iMatch;

                // now fill in iNextPrevAlternate for all elements from index to *pitokTop - 1
                for (i = index+1; i <= *pitokTop - 1; i++)
                {
                    TOKSTACK *pTokSkip = pTokStack + i;

                    pTokArray[pTokSkip->iMatch].iNextPrevAlternate = iArrayPos - 1;
                    ASSERT(pTokArray[pTokSkip->iMatch].fStart == TRUE);
                    ASSERT(pTokArray[pTokSkip->iMatch].iNextprev == -1);
                } // for ()
                // decrement the stack appropriately
                *pitokTop = index;
            } // else

        } // of if (tagID == pTokT->tagID)
    } // end of if (lxs & inEndTag)
    else // push the token info on the stack
    {
        TOKSTACK *pTokT = pTokStack + *pitokTop;

        ASSERT(iArrayPos - 1 >= 0);
        //push the new token into pTokArray at *pitokCur position
        pTokT->iMatch = iArrayPos - 1;
        pTokT->tagID = tagID;
        pTokT->ichStart = token.ibTokMin;
        pTokT->token = token; // note that this isused ONLY in special cases where tagID is -1

        *pitokTop += 1;
    } //end of else case of if (lxs & inEndTag)

LSkipStackOp:

    return NOERROR;
}



// This function does following
//      (a) reads the stream 
//      (b) generates tokens
//      (c) allocates a buffer that holds replaced elements like DTCs
//      (d) does the parsing of the tokens to build a not-so-tree tree of tokens
//      (e) returns the not-so-tree tree of tokens
// VK 5/19/99: Replaced dwReserved with dwSpecialize.
// This can currently take PARSE_SPECIAL_HEAD_ONLY to terminate parsing at the <BODY>
HRESULT CTriEditParse::hrTokenizeAndParse(HGLOBAL hOld, HGLOBAL *phNew, IStream *pStmNew,
                        DWORD dwFlags, FilterMode mode, 
                        int cbSizeIn, UINT *pcbSizeOut, IUnknown *pUnkTrident, 
                        HGLOBAL *phgTokArray, UINT *pcMaxToken,
                        HGLOBAL *phgDocRestore, BSTR bstrBaseURL, DWORD dwSpecialize)
{
    // FilterRule structure initilization - move this at apporpriate place
    LPSTR pOld, pNew;
    UINT cbOld = 0;
    UINT cbwOld, cchwOld; // number of bytes & chars in the converted unicode string
    UINT cchNew = 0; // number of unicode chars in the new (after filtering) buffer
    HRESULT hrRet = S_OK;
    HGLOBAL hgNew, hgOld, hgTokStack;
    WCHAR *pwOld, *pwNew;
    UINT cbCur = 0; // This is actually the current character position
    TOKSTRUCT *pTokArray;
    TOKSTACK *pTokStack;
    INT itokTop = 0;
    INT itokCur = 0;
    TXTB token;
    INT cStackMax, cArrayMax;
    DWORD lxs = 0; 
    INT tagID;
    BOOL fAllocDocRestore = FALSE; // did we allocate *phgDocRestore locally? (Y/N)
    BOOL fUsePstmNew = (dwFlags & dwFilterUsePstmNew);
    HGLOBAL hgPstm = NULL;
    ULARGE_INTEGER li;
    UINT cbT = 0;
    BOOL fBeginTokSelect; // used by special case code that detects server side scripts inside a SELECT block
    BOOL fBeginTokTextarea; // used by special case code that detects server side scripts inside a TEXTAREA block
    BOOL fBeginTokLabel; // used by special case code that detects server side scripts inside a LABEL block
    BOOL fBeginTokListing; // used by special case code that detects server side scripts inside a LISTING block
    BOOL fInDTCOutput, fInDTC;

#ifdef DEBUG
    DWORD dwErr;
#endif // DEBUG

    ASSERT((PARSE_SPECIAL_NONE == dwSpecialize) || (PARSE_SPECIAL_HEAD_ONLY == dwSpecialize));

	if ( PARSE_SPECIAL_HEAD_ONLY & dwSpecialize )
		ASSERT ( dwFlags == dwFilterNone );

    // NOTE
    // this could be done another way. We can make m_pUnkTrident public member and set its value
    // at the point where the CTriEditParse object is created. But this looks fine too.
    m_pUnkTrident = pUnkTrident; // we cache this for our use.
    m_fUnicodeFile = FALSE;
    m_bstrBaseURL = bstrBaseURL;
    li.LowPart = li.HighPart = 0;
    // Initialize PTDTC related members
    if (mode == modeInput)
    {
        m_fInHdrIn = TRUE;
    }

    if (fUsePstmNew)
        li.LowPart = li.HighPart = 0;

    // initialize <TBODY> related members
    m_hgTBodyStack = NULL;
    m_pTBodyStack = NULL;
    m_iMaxTBody = m_iTBodyMax = 0;

    // initilize members used by PageTransitionDTC
    if (mode == modeInput)
    {
        m_ichPTDTC = m_cchPTDTCObj = m_cchPTDTC = 0;
        m_indexBeginBody = m_indexEndBody = 0;
        m_hgPTDTC = m_pPTDTC = NULL;
    }
    else
    {
        ASSERT(m_hgPTDTC == NULL); // make sure that it was freed (if we allocated it in modeInput case)
    }

    if (mode == modeInput)
    {
        m_fHasTitleIn = FALSE;
        m_indexTitleIn = -1;
        m_ichTitleIn = -1;
        m_cchTitleIn = -1;
        m_ichBeginBodyTagIn = -1;
        m_ichBeginHeadTagIn = -1;
        m_indexHttpEquivIn = -1;
    }
    //initilize fBeginTokSelect (used by special case code that 
    // detects server side scripts inside a SELECT block)
    fBeginTokSelect = fBeginTokTextarea = fBeginTokLabel = fBeginTokListing = FALSE;
    fInDTCOutput = fInDTC = FALSE;

    pOld = (LPSTR) GlobalLock(hOld);
    if (cbSizeIn == -1)
        cbOld = SAFE_INT64_TO_DWORD(GlobalSize(hOld));
    else
        cbOld = cbSizeIn;
    if (cbOld == 0) // zero sized file
    {
        if (pcbSizeOut)
            *pcbSizeOut = 0;
        hrRet = E_OUTOFMEMORY;
        *pcMaxToken = 0;
        if (fUsePstmNew)
            pStmNew->SetSize(li);
        else
            *phNew = NULL;
        *phgTokArray = NULL;
        goto LRetOnly;
    }
    hgNew = hgOld = hgTokStack = NULL;
    if (*((BYTE *)pOld) == 0xff && *((BYTE *)pOld+1) == 0xfe)
    {
        m_fUnicodeFile = TRUE;
        if (dwFlags & dwFilterMultiByteStream)
            dwFlags &= ~dwFilterMultiByteStream;
    }

    // allocate a buffer that will hold token structs. This is returned
    *phgTokArray = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, MIN_TOK*sizeof(TOKSTRUCT)); // stack
    if (*phgTokArray == NULL)
    {
        hrRet = E_OUTOFMEMORY;
        goto LOOM;
    }
    pTokArray = (TOKSTRUCT *) GlobalLock(*phgTokArray);
    ASSERT(pTokArray != NULL);
    cArrayMax = MIN_TOK;

    // allocate temporary buffers that for the current & filtered html documents
    hgTokStack = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, MIN_TOK*sizeof(TOKSTRUCT)); // stack
    if (hgTokStack == NULL)
    {
        hrRet = E_OUTOFMEMORY;
        goto LOOM;
    }
    pTokStack = (TOKSTACK *) GlobalLock(hgTokStack);
    ASSERT(pTokStack != NULL);
    cStackMax = MIN_TOK;

    // In most cases for NON-UNICODE streams, 
    // (cbOld+1/*for NULL*/)*sizeof(WCHAR)  will endup being lot more than what we need
    hgOld = GlobalAlloc(GMEM_ZEROINIT, (dwFlags & dwFilterMultiByteStream) 
                                        ? (cbOld+1/*for NULL*/)*sizeof(WCHAR) 
                                        : (cbOld+2/*for NULL*/));
    if (hgOld == NULL)
    {
        hrRet = E_OUTOFMEMORY;
        goto LOOM;
    }
    pwOld = (WCHAR *) GlobalLock(hgOld);
    ASSERT(pwOld != NULL);

    // we could just allocate cbOld bytes in modeInput and modeOutput. 
    // But reallocs are expensive and in both cases, we will grow by some bytes
    // if we have DTCs and/or SSSs.
    if (dwFlags & dwFilterNone) // the caller has called this function only for tokenizing
    {
        if (dwFlags & dwFilterMultiByteStream)
            cbT = (cbOld+1/*for NULL*/)*sizeof(WCHAR); // this will be bigger than what we need.
        else
            cbT = cbOld + sizeof(WCHAR); // for NULL
    }
    else
    {
        if (dwFlags & dwFilterMultiByteStream)
            cbT = (cbOld+1)*sizeof(WCHAR) + cbBufPadding;
        else
            cbT = cbOld + cbBufPadding; // no need to add +2
    }
    hgNew = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbT);
    if (hgNew == NULL)
    {
        hrRet = E_OUTOFMEMORY;
        goto LOOM;
    }
    pwNew = (WCHAR *) GlobalLock(hgNew);
    ASSERT(pwNew != NULL);

    // buffer to save all contents before/after <BODY> tag
    m_hgDocRestore = phgDocRestore ? *phgDocRestore : NULL;
    if (m_hgDocRestore == NULL)
    {
        fAllocDocRestore = TRUE;
        m_hgDocRestore = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbHeader);
        if (m_hgDocRestore == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            goto LOOM;
        }
    }
    // at this point we know that m_hgDocRestore is not going to be null, but lets be cautious
    // we call FilterIn only once when we load the document. (bug 15393)
    if (m_hgDocRestore != NULL && mode == modeInput)
    {
        WCHAR *pwDocRestore;
        DWORD cbDocRestore;

        // lock
        pwDocRestore = (WCHAR *) GlobalLock(m_hgDocRestore);
        // fill with zeros
        cbDocRestore = SAFE_INT64_TO_DWORD(GlobalSize(m_hgDocRestore));
        memset((BYTE *)pwDocRestore, 0, cbDocRestore);
        // unlock
        GlobalUnlock(m_hgDocRestore);
    }

    m_fEndTagFound = FALSE; // initialize

    m_cMaxToken = m_cDTC = m_cObj = m_cSSSIn = m_cSSSOut = m_cNbsp = m_iControl = m_cComment = m_cObjIn = 0;
    m_cAppletIn = m_cAppletOut = 0;
    m_fSpecialSSS = FALSE;
    m_cHtml = (mode == modeInput)? 0 : 0; // assume that we atleast have one <HTML> tag in modeInput case
    m_cHdr = m_cFtr = m_cAImgLink = 1;
    m_pspInfoCur = m_pspInfo = m_pspInfoOut = m_pspInfoOutStart = NULL;
    m_hgspInfo = NULL;
    m_ichStartSP = 0;
    if (dwFlags & dwPreserveSourceCode)
    {
        m_ispInfoIn = (mode == modeInput)? 1 : 0;
        m_ispInfoOut = (mode == modeOutput)? 1 : 0;
        if (mode == modeInput)
        {
            srand((unsigned)time(NULL));
            m_ispInfoBase = rand();
            if (0x0fffffff-m_ispInfoBase < 0x000fffff)
                m_ispInfoBase  = 0;
        }
    }
    else
    {
        m_ispInfoIn = 0;
        m_ispInfoOut = 0;
    }

    m_iArrayspLast = 0;
    m_ispInfoBlock = 0; // index of the block. stored as value of DESIGNTIMESPx tag
    m_cchspInfoTotal = 0;
    m_fDontDeccItem = FALSE; // we can do this differently next time

    // if we have multiple of these tags, we need to warn the user before going to design view
    // and not let the user switch views (bug 18474)
    m_cBodyTags = m_cHtmlTags = m_cTitleTags = m_cHeadTags = 0;

    if (dwFlags & dwFilterMultiByteStream)
    {
        // note that cbOld is actually number of characters in single byte world
        cchwOld = MultiByteToWideChar(CP_ACP, 0, pOld, (cbSizeIn==-1)?-1:cbOld, NULL, 0);
        MultiByteToWideChar(CP_ACP, 0, pOld, (cbSizeIn==-1)?-1:cbOld, pwOld, cchwOld);
    }
    else
    {
        memcpy((BYTE *)pwOld, (BYTE *)pOld, cbOld); // we are already UNICODE
        // Assume that in UNICODE world we can simply divide cbOld by sizeof(WCHAR)
        cchwOld = cbOld/sizeof(WCHAR);
    }
    *(pwOld+cchwOld) = '\0';

    // get the token & save it into a buffer
    cbwOld = cchwOld * sizeof(WCHAR);
    while (cbCur < cchwOld)
    {
        UINT cbCurSav = cbCur;

        NextToken(pwOld, cchwOld, &cbCur, &lxs, &token);
        tagID = GetTagID(pwOld, token); // only if inAttribute & inTag ????

        // if we have more of any of these tags, Trident removes them, so lets warn the user and
        // not the user go to design view (bug 18474)
        if (   (mode == modeInput)
            && (token.tokClass == tokElem)
            && (lxs & inTag)
            && !(lxs & inEndTag) /* this may be redundant, but having it does no harm */
            )
        {
            switch (token.tok)
            {
            case TokElem_BODY:
                m_cBodyTags++;
                break;
            case TokElem_HTML:
                m_cHtmlTags++;
                break;
            case TokElem_TITLE:
                m_cTitleTags++;
                break;
            case TokElem_HEAD:
                m_cHeadTags++;
                break;
            };
            if (m_cBodyTags > 1 || m_cHtmlTags > 1 || m_cTitleTags > 1 || m_cHeadTags > 1)
            {
                // skip tokenizing. we can't let this go to Trident
                memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
                cchNew = cchwOld;
                hrRet = E_FILTER_MULTIPLETAGS;
                goto LSkipTokFilter;
            }
        }

        if (   (token.tokClass == tokElem)
            && (   (token.tok == TokElem_FRAME)
                || (token.tok == TokElem_FRAMESET)
                )
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_FRAMESET;
            goto LSkipTokFilter;
        }
        if (   (token.tok == TokTag_SSSOPEN)
            && (token.tokClass == tokSSS)
            && (lxs & inAttribute)
            && !(lxs & inString)
            && !(lxs & inStringA)
            && !(fInDTCOutput)
            && (mode == modeInput)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SERVERSCRIPT;
            goto LSkipTokFilter;
        }
        if (   (token.tok == 0)
            && (token.tokClass == tokSSS)
            && (lxs & inTag)
            && (lxs & inHTXTag)
            && (lxs & inAttribute)
            && (lxs & inString || lxs & inStringA)
            && (lxs & inNestedQuoteinSSS)
            && !(fInDTCOutput)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SERVERSCRIPT;
            goto LSkipTokFilter;
        }

        // REVIEW TODO LATER - For all following special cases, we need to add !fInDTCOutput
        if (   (fBeginTokSelect)
            && (token.tok == TokTag_SSSOPEN || token.tok == TokElem_SCRIPT)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SCRIPTSELECT;
            goto LSkipTokFilter;
        }

        if (   (fBeginTokTextarea)
            && (token.tok == TokTag_SSSOPEN && token.tokClass == tokSSS)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SCRIPTTEXTAREA;
            goto LSkipTokFilter;
        }
        if (   (fBeginTokLabel)
            && (token.tok == TokTag_SSSOPEN && token.tokClass == tokSSS)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SCRIPTLABEL;
            goto LSkipTokFilter;
        }
        if (   (fBeginTokListing)
            && (token.tok == TokTag_SSSOPEN && token.tokClass == tokSSS)
            )
        {
            // skip tokenizing. we can't let this go to Trident
            memcpy((BYTE *)pwNew, (BYTE *)pwOld, cchwOld*sizeof(WCHAR));
            cchNew = cchwOld;
            hrRet = E_FILTER_SCRIPTLISTING;
            goto LSkipTokFilter;
        }

        // Special cases Begin

        // special case - check if the document has <!DOCTYPE before going to Design view.
        // If it does, set m_fHasDocType flag. Trident always inserts this flag and we
        // want to remove it on the way out from Design view.
        if (   (token.tok == TokElem_TITLE)
            && (token.tokClass == tokElem)
            )
        {
            if (mode == modeInput)
            {
                m_fHasTitleIn = TRUE;
                if (m_indexTitleIn == -1)
                    m_indexTitleIn = itokCur;
            }
        }

        if (   (token.tok == TokElem_BODY)
            && (token.tokClass == tokElem)
            && (m_ichBeginBodyTagIn == -1)
            )
		{
			if ( PARSE_SPECIAL_HEAD_ONLY & dwSpecialize )
				break;
			if (mode == modeInput)
				m_ichBeginBodyTagIn = token.ibTokMin;
		}

        if (   (token.tok == TokAttrib_HTTPEQUIV || token.tok == TokAttrib_HTTP_EQUIV)
            && (token.tokClass == tokAttr)
            && (mode == modeInput)
            )
        {
            if (m_indexHttpEquivIn == -1)
                m_indexHttpEquivIn = itokCur;
        }
        if (   (token.tok == TokElem_HEAD)
            && (token.tokClass == tokElem)
            && (m_ichBeginHeadTagIn == -1)
            && (mode == modeInput)
            )
        {
            m_ichBeginHeadTagIn = token.ibTokMin;
        }
        if (   (token.tok == TokElem_SELECT)
            && (token.tokClass == tokElem)
            && (mode == modeInput)
            && !(lxs & inSCRIPT)
            )
        {
            if (   (pTokArray[itokCur-1].token.tok == TokTag_START)
                && (pTokArray[itokCur-1].token.tokClass == tokTag)
                )
                fBeginTokSelect = TRUE;
            else if (      (pTokArray[itokCur-1].token.tok == TokTag_END)
                        && (pTokArray[itokCur-1].token.tokClass == tokTag)
                        )
                fBeginTokSelect = FALSE;
        }
        if (   (token.tok == TokElem_TEXTAREA)
            && (token.tokClass == tokElem)
            && (mode == modeInput)
            )
        {
            if (   (pTokArray[itokCur-1].token.tok == TokTag_START)
                && (pTokArray[itokCur-1].token.tokClass == tokTag)
                )
                fBeginTokTextarea = TRUE;
            else if (      (pTokArray[itokCur-1].token.tok == TokTag_END)
                        && (pTokArray[itokCur-1].token.tokClass == tokTag)
                        )
                fBeginTokTextarea = FALSE;
        }
        if (   (token.tok == TokElem_LABEL)
            && (token.tokClass == tokElem)
            && (mode == modeInput)
            )
        {
            if (   (pTokArray[itokCur-1].token.tok == TokTag_START)
                && (pTokArray[itokCur-1].token.tokClass == tokTag)
                )
                fBeginTokLabel = TRUE;
            else if (      (pTokArray[itokCur-1].token.tok == TokTag_END)
                        && (pTokArray[itokCur-1].token.tokClass == tokTag)
                        )
                fBeginTokLabel = FALSE;
        }
        if (   (token.tok == TokElem_LISTING)
            && (token.tokClass == tokElem)
            && (mode == modeInput)
            )
        {
            if (   (pTokArray[itokCur-1].token.tok == TokTag_START)
                && (pTokArray[itokCur-1].token.tokClass == tokTag)
                )
                fBeginTokListing = TRUE;
            else if (      (pTokArray[itokCur-1].token.tok == TokTag_END)
                        && (pTokArray[itokCur-1].token.tokClass == tokTag)
                        )
                fBeginTokListing = FALSE;
        }

        if (   (token.tok == TokAttrib_STARTSPAN)
            && (token.tokClass == tokAttr)
            && (mode == modeInput)
            )
            fInDTC = TRUE;
        if (   (token.tok == TokElem_OBJECT)
            && (token.tokClass == tokElem)
            && (lxs & inEndTag)
            && (fInDTC)
            && (mode == modeInput)
            )
            fInDTCOutput = TRUE;
        if (   (token.tok == TokAttrib_ENDSPAN)
            && (token.tokClass == tokAttr)
            && (mode == modeInput)
            )
        {
            fInDTCOutput = FALSE;
            fInDTC = FALSE;
        }
        // Special cases End


        if (itokCur == cArrayMax - 1) //allocate more memory for the array
        {
            HGLOBAL hgTokArray;
            GlobalUnlock(*phgTokArray);
            hgTokArray = *phgTokArray;
#pragma prefast(suppress:308, "noise")
            *phgTokArray = GlobalReAlloc(*phgTokArray, (cArrayMax+MIN_TOK)*sizeof(TOKSTRUCT), GMEM_MOVEABLE|GMEM_ZEROINIT);
            // if this alloc failed, we may still want to continue
            if (*phgTokArray == NULL)
            {
                GlobalFree(hgTokArray);
                hrRet = E_OUTOFMEMORY;
                *pcMaxToken = itokCur;
                if (fUsePstmNew)
                    pStmNew->SetSize(li);
                else
                    *phNew = NULL;
                goto LOOM;
            }
            else
            {
                pTokArray = (TOKSTRUCT *)GlobalLock(*phgTokArray); // do we need to unlock this first?
                ASSERT(pTokArray != NULL);
                cArrayMax += MIN_TOK;
            }
        }
        ASSERT(itokCur < cArrayMax);
        PreProcessToken(pTokArray, &itokCur, pwOld, cbCur, token, lxs, tagID, mode); //saves the token into the buffer


        if (itokTop == cStackMax - 1) //allocate more memory for the stack
        {
            HGLOBAL hg;
            GlobalUnlock(hgTokStack);
            hg = hgTokStack;
#pragma prefast(suppress: 308, "noise")
            hgTokStack = GlobalReAlloc(hgTokStack, (cStackMax+MIN_TOK)*sizeof(TOKSTACK), GMEM_MOVEABLE|GMEM_ZEROINIT);
            // if this alloc failed, we may still want to continue
            if (hgTokStack == NULL)
            {
                GlobalFree(hg);
                hrRet = E_OUTOFMEMORY;
                *pcMaxToken = itokCur;
                if (fUsePstmNew)
                    pStmNew->SetSize(li);
                else
                    *phNew = NULL;
                goto LOOM;
            }
            else
            {
                pTokStack = (TOKSTACK *)GlobalLock(hgTokStack); // do we need to unlock this first?
                ASSERT(pTokStack != NULL);
                cStackMax += MIN_TOK;
            }
        }
        ASSERT(itokTop < cStackMax);
        ProcessToken(lxs, token, pwOld, cbCur, pTokStack, &itokTop, pTokArray, itokCur, tagID); //push/pop stack, determine error states

        PostProcessToken(pwOld, pwNew, &cchNew, cbCur, cbCurSav, token, mode, lxs, dwFlags); // handle special cases of replacement 
    } // while (cbCur < cchwOld)
    *pcMaxToken = m_cMaxToken = itokCur;
    ASSERT(cchNew < GlobalSize(hgNew)); // or compare the cached value

    ASSERT(dwFlags != dwFilterDefaults);
    if (       dwFlags & dwFilterDTCs
            || dwFlags & dwFilterDTCsWithoutMetaTags
            || dwFlags & dwFilterServerSideScripts
            || dwFlags & dwPreserveSourceCode
            )
    {
        ASSERT(!(dwFlags & dwFilterNone));


        
        // check dwSpacing flag here
        if ((mode == modeOutput) && (dwFlags & dwPreserveSourceCode))
        {
            INT cchBeforeBody = 0;
            INT cchAfterBody = 0;
            INT cchPreEndBody = 0;

            ASSERT(m_pspInfoOut == NULL);
            ASSERT(m_hgDocRestore != NULL);
            m_pspInfoOut = (WORD *)GlobalLock(m_hgDocRestore);
            cchBeforeBody = (int)*m_pspInfoOut; // we are assuming that cchBeforeBody exists in this block
            m_pspInfoOut += cchBeforeBody + (sizeof(INT))/sizeof(WCHAR); // for cchBeforeBody
            cchAfterBody = (int)*m_pspInfoOut;
            m_pspInfoOut += cchAfterBody + (sizeof(INT))/sizeof(WCHAR); // for cchAfterBody
            cchPreEndBody = (int)*m_pspInfoOut;
            m_pspInfoOut += cchPreEndBody + (sizeof(INT))/sizeof(WCHAR); // for cchPreEndBody
            m_cchspInfoTotal = (int)*m_pspInfoOut;
            m_pspInfoOut += sizeof(INT)/sizeof(WCHAR);
            m_pspInfoOutStart = m_pspInfoOut;
        }

        
        ASSERT(pTokArray != NULL);
        FilterHtml( pwOld, &pwNew, &cchNew, &hgNew, pTokArray, 
                    mode, dwFlags);
        
        // check dwSpacing flag here
        if ((mode == modeOutput) && (dwFlags & dwPreserveSourceCode))
        {
            if (m_pspInfoOut != NULL)
            {
                ASSERT(m_hgDocRestore != NULL);
                GlobalUnlock(m_hgDocRestore);
            }
        }

    }

LSkipTokFilter:

    if (fUsePstmNew)
    {
        if (dwFlags & dwFilterMultiByteStream)
            li.LowPart = WideCharToMultiByte(CP_ACP, 0, pwNew, -1, NULL, 0, NULL, NULL) - 1; // to compensate for NULL character at end
        else
            li.LowPart = (cchNew)*sizeof(WCHAR);
        li.HighPart = 0;
        if (S_OK != pStmNew->SetSize(li))
        {
            hrRet = E_OUTOFMEMORY;
            goto LOOM;
        }
        if (S_OK != GetHGlobalFromStream(pStmNew, &hgPstm))
        {
            hrRet = E_INVALIDARG;
            goto LOOM;
        }
        pNew = (LPSTR) GlobalLock(hgPstm);
    }
    else
    {
        // cchNew is # of unicode characters in pwNew
        // If we want to convert this UNICODE string into MultiByte string, 
        // we will need anywhere between cchNew bytes & cchNew*sizeof(WCHAR) bytes.
        // and we don't know it at this point, so lets leave the max size for allocation.
        *phNew = GlobalAlloc(GMEM_ZEROINIT, (cchNew+1)*sizeof(WCHAR));
        if (*phNew == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            goto LOOM;
        }
        pNew = (LPSTR) GlobalLock(*phNew);
    }

    if (dwFlags & dwFilterMultiByteStream)
    {
        INT cbSize;

        cbSize = WideCharToMultiByte(CP_ACP, 0, pwNew, -1, NULL, 0, NULL, NULL) - 1; // to compensate for NULL character at end
        if (pcbSizeOut)
            *pcbSizeOut = cbSize;
        // we assume that number of characters will be the same in UNICODE or MBCS world
        // what changes is the number of bytes they need.
        WideCharToMultiByte(CP_ACP, 0, pwNew, -1, pNew, cbSize, NULL, NULL);
    }
    else
    {
        // NOTE - that we always set *pcbSizeOut to the number of BYTES in the new buffer
        if (pcbSizeOut)
            *pcbSizeOut = cchNew*sizeof(WCHAR);
        memcpy((BYTE *)pNew, (BYTE *)pwNew, cchNew*sizeof(WCHAR)); // we want to remain UNICODE
    }

#ifdef DEBUG
    dwErr = GetLastError();
#endif // DEBUG
    
    if (fUsePstmNew)
        GlobalUnlock(hgPstm);
    else
        GlobalUnlock(*phNew);

LOOM:
    // assume that the caller will free *phgTokArray
    if (*phgTokArray != NULL)
        GlobalUnlock(*phgTokArray); // do we need to check if this was already Unlocked?
    
    // assume that the caller will free *phgDocRestore if the caller allocated it
    if (fAllocDocRestore && m_hgDocRestore != NULL) // we allocated it here, so the caller doesn't need it
        GlobalUnlockFreeNull(&m_hgDocRestore);

    if (phgDocRestore)
        *phgDocRestore = m_hgDocRestore; // in case of a realloc, this may have changed.

    if (hgTokStack != NULL)
        GlobalUnlockFreeNull(&hgTokStack);
    if (hgNew != NULL)
        GlobalUnlockFreeNull(&hgNew);
    if (hgOld != NULL)
        GlobalUnlockFreeNull(&hgOld);
    if (m_hgTBodyStack != NULL)
        GlobalUnlockFreeNull(&m_hgTBodyStack);

    // check dwSpacing flag here
    if ((m_hgspInfo != NULL) && (dwFlags & dwPreserveSourceCode))
    {
        if (mode == modeInput && phgDocRestore)
        {
            WCHAR *pHdr, *pHdrSav;
            INT cchBeforeBody, cchAfterBody, cchPreEndBody;

            pHdr = (WCHAR *)GlobalLock(*phgDocRestore);
            ASSERT(pHdr != NULL);
            pHdrSav = pHdr;
            memcpy((BYTE *)&cchBeforeBody, (BYTE *)pHdr, sizeof(INT));
            pHdr += cchBeforeBody + sizeof(INT)/sizeof(WCHAR);

            memcpy((BYTE *)&cchAfterBody, (BYTE *)pHdr, sizeof(INT));
            pHdr += cchAfterBody + sizeof(INT)/sizeof(WCHAR);

            memcpy((BYTE *)&cchPreEndBody, (BYTE *)pHdr, sizeof(INT));
            pHdr += cchPreEndBody + sizeof(INT)/sizeof(WCHAR);


            if (GlobalSize(*phgDocRestore) < SAFE_PTR_DIFF_TO_INT(pHdr - pHdrSav)*sizeof(WCHAR) + SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo)*sizeof(WORD)+sizeof(int))
            {
                INT cdwSize = SAFE_PTR_DIFF_TO_INT(pHdr - pHdrSav);

                ASSERT(cdwSize >= 0); // validation
                hrRet = ReallocBuffer(  phgDocRestore,
                                        SAFE_INT64_TO_DWORD(pHdr - pHdrSav)*sizeof(WCHAR) + SAFE_INT64_TO_DWORD(m_pspInfoCur-m_pspInfo)*sizeof(WORD)+sizeof(int),
                                        GMEM_MOVEABLE|GMEM_ZEROINIT);
                if (hrRet == E_OUTOFMEMORY)
                    goto LRet;
                ASSERT(*phgDocRestore != NULL);
                pHdr = (WORD *)GlobalLock(*phgDocRestore);
                pHdr += cdwSize;
            }
            
            *(int*)pHdr = SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo);
            pHdr += sizeof(INT)/sizeof(WCHAR);

            memcpy( (BYTE *)pHdr,
                    (BYTE *)m_pspInfo,
                    SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo)*sizeof(WORD));
LRet:
            GlobalUnlock(*phgDocRestore);
        }
        GlobalUnlockFreeNull(&m_hgspInfo);
    }


    GlobalUnlock(hOld);
LRetOnly:
    return(hrRet);

}

void 
CTriEditParse::SetSPInfoState(WORD inState, WORD *pdwState, WORD *pdwStatePrev, BOOL *pfSave)
{
    *pfSave = TRUE;
    *pdwStatePrev = *pdwState;
    *pdwState = inState;
}

HRESULT
CTriEditParse::hrMarkOrdering(WCHAR *pwOld, TOKSTRUCT *pTokArray, INT iArrayStart, int iArrayEnd, 
                              UINT cbCur, INT *pichStartOR)
{

    HRESULT hr = S_OK;
    WORD *pspInfoSize;
    WORD cAttr = 0;

    ASSERT(m_pspInfo != NULL);
    if (m_pspInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto LRetOnly;
    }

    pspInfoSize = m_pspInfoCur; // placeholder to save run size in BYTEs, size includes this DWORD
    *m_pspInfoCur++ = 0xFFFF; // placeholder to save run size in BYTEs, size includes this WORD
    *m_pspInfoCur++ = 0xFFFF; // placeholder to save number of Attr

    // handle the simplest case where we know that there is nothing to save
    if (cbCur == (UINT)*pichStartOR)
        goto LRet;
    // find out the number ot attributes insize this tag
    while (iArrayStart < iArrayEnd)
    {
        if (pTokArray[iArrayStart].token.tokClass == tokAttr)
        {
            INT ichStart, ichEnd;
            INT iArrayQuote = iArrayStart+1;
            INT iArrayEq = -1;

            cAttr++;
            ichStart = pTokArray[iArrayStart].token.ibTokMin;
            ichEnd = pTokArray[iArrayStart].token.ibTokMac;
            ASSERT(ichEnd > ichStart);
            
            while (iArrayQuote < iArrayEnd) // handle the case of white space before the quotes
            {
                if (pTokArray[iArrayQuote].token.tokClass == tokAttr) // gone too far, found next attr
                    break;
                if (   (   pTokArray[iArrayQuote].token.tokClass == tokValue
                        || pTokArray[iArrayQuote].token.tokClass == tokString
                        )
                    && (   pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '"'
                        || pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '\''
                        )
                    )
                    break;
                if (pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '=')
                    iArrayEq = iArrayQuote;
                iArrayQuote++;
            }

            if (   iArrayEq != -1
                && pTokArray[iArrayEq].token.tokClass == tokOp
                && pwOld[pTokArray[iArrayEq].token.ibTokMin] == '='
                && (   pTokArray[iArrayQuote].token.tokClass == tokValue
                    || pTokArray[iArrayQuote].token.tokClass == tokString
                    )
                && pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '"'
                )
            {
                *m_pspInfoCur++ = 1;
            }
            else if (   iArrayEq != -1
                && pTokArray[iArrayEq].token.tokClass == tokOp
                && pwOld[pTokArray[iArrayEq].token.ibTokMin] == '='
                && (   pTokArray[iArrayQuote].token.tokClass == tokValue
                    || pTokArray[iArrayQuote].token.tokClass == tokString
                    )
                && pwOld[pTokArray[iArrayQuote].token.ibTokMin] == '\''
                )
            {
                *m_pspInfoCur++ = 2;
            }
            else
            {
                *m_pspInfoCur++ = 0;
            }
            *m_pspInfoCur++ = (WORD)(ichEnd-ichStart);
            memcpy((BYTE *)m_pspInfoCur, (BYTE *)&(pwOld[ichStart]), (ichEnd-ichStart)*sizeof(WCHAR));
            m_pspInfoCur += (ichEnd-ichStart);
        }
        iArrayStart++;
    }

LRet:
    *pspInfoSize++ = SAFE_PTR_DIFF_TO_WORD(m_pspInfoCur - pspInfoSize);
    *pspInfoSize = cAttr;

    *pichStartOR = cbCur; // set for next run
LRetOnly:
    return(hr);

} /* hrMarkOrdering() */

BOOL
CTriEditParse::FRestoreOrder(WCHAR *pwNew, WCHAR *pwOld, WORD *pspInfoOrder, UINT *pichNewCur, 
                             INT /*cwOrderInfo*/, TOKSTRUCT *pTokArray, INT iArrayStart, INT iArrayEnd, 
                             INT iArrayDSPStart, INT iArrayDSPEnd, INT cchNewCopy, HGLOBAL *phgNew)
{
    // iArrayStart points to '<' & iArrayEnd points to '>'. (These refer to pwOld)
    // look at the attributes between iArrayStart & iArrayEnd and compare them with the attributes
    // saved in pspInfoOrder (which already points to the data saved, i.e. past cwOrderInfo)
    // If we find a matching attribute, move it to appropriate position.
    // DON'T touch extra attributes and IGNORE missing attributes because those represent user action

    HGLOBAL hgNewAttr = NULL;
    HGLOBAL hgTokList = NULL;
    BOOL *pTokList, *pTokListSav;
    WCHAR *pNewAttr, *pNewAttrSav;
    INT i, ichStart, ichEnd, iStart, iEnd, cAttr, cchTag, iStartSav, cchNew;
    BOOL fRet = TRUE;
    LPCWSTR rgSpaceTags[] =
    {
        L"DESIGNTIMESP",
    };
    UINT cbNeed;
    
    ASSERT(pspInfoOrder != NULL);
    cAttr = *(WORD *)pspInfoOrder++;
    ASSERT(cAttr >= 0); // make sure that it was filled in
    if (cAttr == 0)/* || cAttr == 1)*/
        goto LRet;

    hgTokList = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, (iArrayEnd-iArrayStart+1)*(sizeof(BOOL)));
    if (hgTokList == NULL) // don't reorder the attributes
    {
        fRet = FALSE;
        goto LRet;
    }
    pTokList = (BOOL *) GlobalLock(hgTokList);
    pTokListSav = pTokList;

    ichStart = pTokArray[iArrayStart].token.ibTokMin;
    ichEnd = pTokArray[iArrayEnd].token.ibTokMac;
    // cAttr*2 becase we may need to add quotes around each attr value
    hgNewAttr = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, (ichEnd-ichStart+cAttr*2)*(sizeof(WCHAR)));
    if (hgNewAttr == NULL) // don't reorder the attributes
    {
        fRet = FALSE;
        goto LRet;
    }
    pNewAttr = (WCHAR *) GlobalLock(hgNewAttr);
    pNewAttrSav = pNewAttr;

    for (i = iArrayStart; i <= iArrayEnd; i++)
        *pTokList++ = FALSE;

    ASSERT(iArrayDSPEnd > iArrayDSPStart);
    for (i = iArrayDSPStart; i <= iArrayDSPEnd; i++)
    {
        ASSERT(*(pTokListSav+i-iArrayStart) == FALSE);
        *(pTokListSav+i-iArrayStart) = TRUE;
    }
    if (pwOld[pTokArray[iArrayDSPEnd+1].token.ibTokMin] == ' ')
    {
        ASSERT(*(pTokListSav+iArrayDSPEnd+1-iArrayStart) == FALSE);
        *(pTokListSav+iArrayDSPEnd+1-iArrayStart) = TRUE;
    }
    // copy contents from pwOld into pNewAttr till we find the first tokAttr/tokSpace
    iStart = iEnd = iArrayStart;
    cchTag = wcslen(rgSpaceTags[0]);
    while (iEnd < iArrayEnd)
    {
        if (   (pTokArray[iEnd].token.tokClass == tokAttr)
            /*|| (   (pTokArray[iEnd].token.tokClass == tokSpace)
                && (0 != _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[iEnd].token.ibTokMin], cchTag))
                )*/
            )
        {
            break;
        }
        iEnd++;
    }
    if (iEnd >= iArrayEnd) // error
    {
        fRet = FALSE;
        goto LRet;
    }

    for (i = iStart; i < iEnd; i++)
    {
        if (*(pTokListSav+i-iArrayStart) != TRUE) // if not already copied
        {
            if (       (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin == 3)
                    && pwOld[pTokArray[i].token.ibTokMin] == ' '
                    && pwOld[pTokArray[i].token.ibTokMin+1] == '\r'
                    && pwOld[pTokArray[i].token.ibTokMin+2] == '\n'
                    )
            {
                memcpy( (BYTE *)pNewAttr,
                        (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                        (1)*sizeof(WCHAR));
                pNewAttr++;
            }
            else
            {
                if (pTokArray[i].token.tokClass == tokElem)
                {
                    memcpy( (BYTE *)pNewAttr,
                            (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    // BUG 15389 - restore proper case here
                    if (iswupper(pwOld[pTokArray[iArrayDSPStart].token.ibTokMin]) != 0) // DESIGNTIMESP is upper case
                    {
                        _wcsupr(pNewAttr);
                    }
                    else
                    {
                        _wcslwr(pNewAttr);
                    }
                    pNewAttr += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                else
                {
                    memcpy( (BYTE *)pNewAttr,
                            (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                            (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    pNewAttr += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
            }
            *(pTokListSav+i-iArrayStart) = TRUE;
        }
    }

    iStartSav = iStart = iEnd;
    while (cAttr > 0)
    {
        INT cchAttr;
        BOOL fAddSpace;
        WORD isQuote;

        isQuote = *(WORD *)pspInfoOrder++;
        cchAttr = *(WORD *)pspInfoOrder++;
        ASSERT(cchAttr > 0); // make sure that it was filled in
        
        while (iStart <= iArrayEnd) //for (i = iStart; i <= iArrayEnd; i++)
        {
            if (   (pTokArray[iStart].token.tokClass == tokAttr)
                && (pTokArray[iStart].token.ibTokMac-pTokArray[iStart].token.ibTokMin == (UINT)cchAttr)
                && (0 == _wcsnicmp(pspInfoOrder, &pwOld[pTokArray[iStart].token.ibTokMin], cchAttr))
                )
            {
                break; // found the match, so copy from ith token to the next tokAttr
            }
            iStart++;
        } // while ()
        if (iStart >= iArrayEnd) // we know that iArrayEnd is actually '>'
            goto LNoMatch;

        // now from iStart go forward till we get the next tokAttr or '>'
        iEnd = iStart+1;
        fAddSpace = FALSE;
        while (iEnd < iArrayEnd)
        {
            if (       (pTokArray[iEnd].token.tokClass == tokAttr)
                    || (       (pTokArray[iEnd].token.tokClass == tokSpace)
                            && (0 == _wcsnicmp(rgSpaceTags[0], &pwOld[pTokArray[iEnd].token.ibTokMin], cchTag))
                            )
                    )
                break; // found the next attribute
            iEnd++;
        }
        if (iEnd == iArrayEnd)
            fAddSpace = TRUE;
        iEnd--; // iEnd will be pointing to '>' or the next Attribute, so decrement it

        for (i = iStart; i <= iEnd; i++)
        {
            if (*(pTokListSav+i-iArrayStart) != TRUE) // we didn't copy this token
            {
                if (       (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin == 3)
                        && pwOld[pTokArray[i].token.ibTokMin] == ' '
                        && pwOld[pTokArray[i].token.ibTokMin+1] == '\r'
                        && pwOld[pTokArray[i].token.ibTokMin+2] == '\n'
                        )
                {
                    memcpy( (BYTE *)pNewAttr,
                            (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                            (1)*sizeof(WCHAR));
                    pNewAttr++;
                }
                else
                {
                    if (pTokArray[i].token.tokClass == tokAttr)
                    {
                        ASSERT(i == iStart);
                        ASSERT((INT)(pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin) == cchAttr);
                        ASSERT(0 == _wcsnicmp(pspInfoOrder, &pwOld[pTokArray[i].token.ibTokMin], cchAttr));
                        memcpy( (BYTE *)pNewAttr,
                                (BYTE *)pspInfoOrder,
                                (cchAttr)*sizeof(WCHAR));
                    }
                    else if (      (isQuote == 1)
                                && (   pTokArray[i].token.tokClass == tokValue
                                    || pTokArray[i].token.tokClass == tokString
                                    )
								&& (pwOld[pTokArray[i-1].token.ibTokMin] != '@') /*hack alert - VID BUG 23597*/
                                )
                    {
                        isQuote = 0; // the quote restoring has been taken care of for this attribute's value
                        if (pwOld[pTokArray[i].token.ibTokMin] != '"')
                            *pNewAttr++ = '"';
                        memcpy( (BYTE *)pNewAttr,
                                (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        if (pwOld[pTokArray[i].token.ibTokMin] != '"')
                        {
                            *(pNewAttr+pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin) = '"';
                            pNewAttr++;
                        }
                    }
                    else if (      (isQuote == 2)
                                && (   pTokArray[i].token.tokClass == tokValue
                                    || pTokArray[i].token.tokClass == tokString
                                    )
								&& (pwOld[pTokArray[i-1].token.ibTokMin] != '@') /*hack alert - VID BUG 23597*/
                                )
                    {
                        isQuote = 0; // the quote restoring has been taken care of for this attribute's value
                        // if we already have double quote, don't insert another single quote.
                        // ideally, we want to replace the double quote, but lets not do it now, because
                        // we believe that trident would have inserted double quotes to make it valid html!
                        if (pwOld[pTokArray[i].token.ibTokMin] != '\'' && pwOld[pTokArray[i].token.ibTokMin] != '"')
                            *pNewAttr++ = '\'';
                        memcpy( (BYTE *)pNewAttr,
                                (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                        if (pwOld[pTokArray[i].token.ibTokMin] != '\'' && pwOld[pTokArray[i].token.ibTokMin] != '"')
                        {
                            *(pNewAttr+pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin) = '\'';
                            pNewAttr++;
                        }
                    }
                    else
                    {
                        memcpy( (BYTE *)pNewAttr,
                                (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                                (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                    }
                    pNewAttr += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
                }
                *(pTokListSav+i-iArrayStart) = TRUE;
            }
        }
        if (fAddSpace)
            *pNewAttr++ = ' ';

LNoMatch:
        iStart = iStartSav;
        pspInfoOrder += cchAttr;
        cAttr--;
    } // while (cAttr > 0)

    // do we want to insert an extra space into pNewAttr here?

    // all the saved attributes are accounted for, lets copy remaining stuff
    for (i = iStartSav; i <= iArrayEnd; i++)
    {
        if (*(pTokListSav+i-iArrayStart) != TRUE) // we didn't copy this token
        {
            if (       (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin == 3)
                    && pwOld[pTokArray[i].token.ibTokMin] == ' '
                    && pwOld[pTokArray[i].token.ibTokMin+1] == '\r'
                    && pwOld[pTokArray[i].token.ibTokMin+2] == '\n'
                    )
            {
                memcpy( (BYTE *)pNewAttr,
                        (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                        (1)*sizeof(WCHAR));
                pNewAttr++;
            }
            else
            {
                memcpy( (BYTE *)pNewAttr,
                        (BYTE *)(pwOld+pTokArray[i].token.ibTokMin),
                        (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin)*sizeof(WCHAR));
                pNewAttr += (pTokArray[i].token.ibTokMac-pTokArray[i].token.ibTokMin);
            }
            *(pTokListSav+i-iArrayStart) = TRUE;
        }
    } // for ()
    cchNew = SAFE_PTR_DIFF_TO_INT(pNewAttr - pNewAttrSav);

    cbNeed = *pichNewCur+cchNew-cchNewCopy;
    ASSERT(cbNeed*sizeof(WCHAR) <= GlobalSize(*phgNew));
    if (S_OK != ReallocIfNeeded(phgNew, &pwNew, cbNeed, GMEM_MOVEABLE|GMEM_ZEROINIT))
    {
        fRet = FALSE;
        goto LRet;
    }

    memcpy( (BYTE *)(pwNew+*pichNewCur-cchNewCopy),
            (BYTE *)(pNewAttrSav),
            cchNew*sizeof(WCHAR));
    *pichNewCur += (cchNew-cchNewCopy);

    // NOTE - Find a better way to account for the extra space added when we moved
    // the attributes. We can't avoid adding space because when we move the last attribute, 
    // there may not be a space between that and the '>'. 
    if (       /*(cchNew > cchNewCopy)
            &&*/ (pwNew[*pichNewCur-1] == '>' && pwNew[*pichNewCur-2] == ' ')
            )
    {
        pwNew[*pichNewCur-2] = pwNew[*pichNewCur-1];
        pwNew[*pichNewCur-1] = '\0';
        *pichNewCur -= 1;
    }

LRet:
    if (hgNewAttr != NULL)
        GlobalUnlockFreeNull(&hgNewAttr);
    if (hgTokList != NULL)
        GlobalUnlockFreeNull(&hgTokList);

    return(fRet);

} /* FRestoreOrder() */

HRESULT
CTriEditParse::hrMarkSpacing(WCHAR *pwOld, UINT cbCur, INT *pichStartSP)
{

    HRESULT hrRet = S_OK;
    UINT i;
    WORD cSpace, cEOL, cTab, cChar, cTagOpen, cTagClose, cTagEq;
    WORD dwState = initState;
    WORD dwStatePrev = initState;
    BOOL fSave = FALSE;
    WORD *pspInfoSize;
    
    if (m_pspInfo == NULL) // allocate it
    {
        m_hgspInfo = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, cbHeader*sizeof(WORD));
        if (m_hgspInfo == NULL)
        {
            hrRet = E_OUTOFMEMORY;
            goto LRet;
        }
        m_pspInfo = (WORD *) GlobalLock(m_hgspInfo);
        ASSERT(m_pspInfo != NULL);
        m_pspInfoCur = m_pspInfo;
        //ASSERT(m_ispInfoIn == 0);
    }
    else // reallocate if needed
    {
        // assumption here is that we can't have more runs than the number of characters we have to scan
        // we use *2 to reduce future reallocations
        if (GlobalSize(m_hgspInfo) < SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo)*sizeof(WORD) + (cbCur-*pichStartSP)*2*sizeof(WORD) + cbBufPadding)
        {
            int cdwSize = SAFE_PTR_DIFF_TO_INT(m_pspInfoCur-m_pspInfo); // size in DWORDs

            hrRet = ReallocBuffer(  &m_hgspInfo,
                                    SAFE_INT64_TO_DWORD(m_pspInfoCur-m_pspInfo)*sizeof(WORD) + (cbCur-*pichStartSP)*2*sizeof(WORD) + cbBufPadding,
                                    GMEM_MOVEABLE|GMEM_ZEROINIT);
            if (hrRet == E_OUTOFMEMORY)
                goto LRet;
            ASSERT(m_hgspInfo != NULL);
            m_pspInfo = (WORD *)GlobalLock(m_hgspInfo);
            m_pspInfoCur = m_pspInfo + cdwSize;
        }
    }

    //m_ispInfoIn++;
    pspInfoSize = m_pspInfoCur; // placeholder to save run size in BYTEs, size includes this DWORD
    *m_pspInfoCur++ = 0xFFFF; // placeholder to save run size in BYTEs, size includes this WORD
    *m_pspInfoCur++ = SAFE_INT_DIFF_TO_WORD(cbCur-*pichStartSP);
    cSpace = cEOL = cTab = cChar = cTagOpen = cTagClose = cTagEq = 0;
    
    //scan from ichStartSP till cbCur for space, tab, eol
    // NOTE - Optimization note
    // part of this info is already in pTokArray. We should use it
    // to reduce the time in this function
    for (i = *pichStartSP; i < cbCur; i++)
    {
        switch (pwOld[i])
        {
        case ' ':
            if (dwState != inSpace)
            {
                SetSPInfoState(inSpace, &dwState, &dwStatePrev, &fSave);
                ASSERT(cSpace == 0);
            }
            cSpace++;
            break;
        case '\r':
        case '\n':
            if (dwState != inEOL)
            {
                SetSPInfoState(inEOL, &dwState, &dwStatePrev, &fSave);
                ASSERT(cEOL == 0);
            }
            if (pwOld[i] == '\n')
                cEOL++;
            break;
        case '\t':
            if (dwState != inTab)
            {
                SetSPInfoState(inTab, &dwState, &dwStatePrev, &fSave);
                ASSERT(cTab == 0);
            }
            cTab++;
            break;
        case '<':
            if (dwState != inTagOpen)
            {
                SetSPInfoState(inTagOpen, &dwState, &dwStatePrev, &fSave);
                ASSERT(cTagOpen == 0);
            }
            cTagOpen++;
            break;
        case '>':
            if (dwState != inTagClose)
            {
                SetSPInfoState(inTagClose, &dwState, &dwStatePrev, &fSave);
                ASSERT(cTagClose == 0);
            }
            cTagClose++;
            break;
        case '=':
            if (dwState != inTagEq)
            {
                SetSPInfoState(inTagEq, &dwState, &dwStatePrev, &fSave);
                ASSERT(cTagEq == 0);
            }
            cTagEq++;
            break;
        default:
            if (dwState != inChar)
            {
                SetSPInfoState(inChar, &dwState, &dwStatePrev, &fSave);
                ASSERT(cChar == 0);
            }
            cChar++;
            break;
        } /* switch */

        if (fSave) // save previous run
        {
            if (dwStatePrev != initState)
            {
                switch (dwStatePrev)
                {
                case inSpace:
                    *m_pspInfoCur++ = inSpace;
                    *m_pspInfoCur++ = cSpace;
                    cSpace = 0;
                    break;
                case inEOL:
                    *m_pspInfoCur++ = inEOL;
                    *m_pspInfoCur++ = cEOL;
                    cEOL = 0;
                    break;
                case inTab:
                    *m_pspInfoCur++ = inTab;
                    *m_pspInfoCur++ = cTab;
                    cTab = 0;
                    break;
                case inTagOpen:
                    *m_pspInfoCur++ = inTagOpen;
                    *m_pspInfoCur++ = cTagOpen;
                    cTagOpen = 0;
                    break;
                case inTagClose:
                    *m_pspInfoCur++ = inTagClose;
                    *m_pspInfoCur++ = cTagClose;
                    cTagClose = 0;
                    break;
                case inTagEq:
                    *m_pspInfoCur++ = inTagEq;
                    *m_pspInfoCur++ = cTagEq;
                    cTagEq = 0;
                    break;
                case inChar:
                    *m_pspInfoCur++ = inChar;
                    *m_pspInfoCur++ = cChar;
                    cChar = 0;
                    break;
                }
            }
            fSave = FALSE;

        } // if (fSave)

    } // for ()
    
    *pichStartSP = cbCur; // set for next run

    //if (pwOld[i] == '\0') // end of file and we wouldn't have saved the last run
    //{
        if (cSpace > 0)
            dwStatePrev = inSpace;
        else if (cEOL > 0)
            dwStatePrev = inEOL;
        else if (cTab > 0)
            dwStatePrev = inTab;
        else if (cTagOpen > 0)
            dwStatePrev = inTagOpen;
        else if (cTagClose > 0)
            dwStatePrev = inTagClose;
        else if (cTagEq > 0)
            dwStatePrev = inTagEq;
        else if (cChar > 0)
            dwStatePrev = inChar;
        else
            dwStatePrev = initState; // handle error case

        switch (dwStatePrev) // repeat of above, make this into a function
        {
        case inSpace:
            *m_pspInfoCur++ = inSpace;
            *m_pspInfoCur++ = cSpace;
            cSpace = 0;
            break;
        case inEOL:
            *m_pspInfoCur++ = inEOL;
            *m_pspInfoCur++ = cEOL;
            cEOL = 0;
            break;
        case inTab:
            *m_pspInfoCur++ = inTab;
            *m_pspInfoCur++ = cTab;
            cTab = 0;
            break;
        case inTagOpen:
            *m_pspInfoCur++ = inTagOpen;
            *m_pspInfoCur++ = cTagOpen;
            cTagOpen = 0;
            break;
        case inTagClose:
            *m_pspInfoCur++ = inTagClose;
            *m_pspInfoCur++ = cTagClose;
            cTagClose = 0;
            break;
        case inTagEq:
            *m_pspInfoCur++ = inTagEq;
            *m_pspInfoCur++ = cTagEq;
            cTagEq = 0;
            break;
        case inChar:
            *m_pspInfoCur++ = inChar;
            *m_pspInfoCur++ = cChar;
            cChar = 0;
            break;
        } // switch()
    //} // if ()

    *pspInfoSize = SAFE_PTR_DIFF_TO_WORD(m_pspInfoCur - pspInfoSize);

LRet:
    return(hrRet);

} /* hrMarkSpacing() */


BOOL
CTriEditParse::FRestoreSpacing(LPWSTR pwNew, LPWSTR /*pwOld*/, UINT *pichNewCur, INT *pcchwspInfo,
                               INT cchRange, INT ichtoktagStart, BOOL fLookback, INT index)
{
    BOOL fRet = TRUE;
    INT ichNewCur = (INT)*pichNewCur;
    INT cchwspInfo = *pcchwspInfo;
    WORD *pspInfoCur;
    INT cchwspInfoSav, cspInfopair, cchIncDec;
    BOOL fInValue = FALSE;

    cchwspInfo -= 2; // skip the cch & cchRange
    cchwspInfoSav = cchwspInfo;
    if (fLookback)
        pspInfoCur = m_pspInfoOut + cchwspInfo-1; // cch is actual number of char, so its 1 based
    else
        pspInfoCur = m_pspInfoOut;
    cspInfopair = cchwspInfo / 2; // we assume that cchwspInfo will be even number
    ASSERT(cchwspInfo % 2 == 0);
    cchIncDec = (fLookback)? -1 : 1;

    while (cspInfopair > 0)//(pspInfoCur >= m_pspInfoOut)
    {
        WORD dwState, count;

        cspInfopair--; // ready to get next cch & its type
        if (fLookback)
        {
            count = *(WORD *)pspInfoCur--;
            dwState = *(WORD *)pspInfoCur--;
        }
        else
        {
            dwState = *(WORD *)pspInfoCur++;
            count = *(WORD *)pspInfoCur++;
        }
        cchwspInfo -= 2; // previous pair of cch and its type

        switch (dwState)
        {
        case inChar:
            ASSERT(index == 1 || index == 0 || index == 3);
            if (index == 0 || index == 3)
            {
                int countws = 0; // count of white space chars

                while (    pwNew[ichtoktagStart-countws] == ' '
                        || pwNew[ichtoktagStart-countws] == '\t'
                        || pwNew[ichtoktagStart-countws] == '\r'
                        || pwNew[ichtoktagStart-countws] == '\n'
                        )
                {
                    // skip these white space chars. They shouldn't be here
                    countws++;
                    if (ichtoktagStart-countws <= 0)
                        break;
                }
                if (countws > 0)
                {
                    if (ichtoktagStart-countws >= 0)
                    {
                        memcpy((BYTE*)&pwNew[ichtoktagStart-countws+1], (BYTE *)&pwNew[ichtoktagStart+1], (ichNewCur-ichtoktagStart-1)*sizeof(WCHAR));
                        ichNewCur -= countws;
                        ichtoktagStart -= countws;
                    }
                }
            } // if (index == 0 || index == 3)

            while (    pwNew[ichtoktagStart] != ' '
                    && pwNew[ichtoktagStart] != '\t'
                    && pwNew[ichtoktagStart] != '\n'
                    && pwNew[ichtoktagStart] != '\r'
                    && pwNew[ichtoktagStart] != '<'
                    && pwNew[ichtoktagStart] != '>'
                    && pwNew[ichtoktagStart] != '='
                    && (ichNewCur > ichtoktagStart)
                    && count > 0
                    )
            {
                count--;
                ichtoktagStart += cchIncDec;
                cchRange--;
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }
            }
            if (count == 0) // we match the exact chars, we may have more contiguous chars in pwNew
            {
                while (    pwNew[ichtoktagStart] != ' '
                        && pwNew[ichtoktagStart] != '\t'
                        && pwNew[ichtoktagStart] != '\n'
                        && pwNew[ichtoktagStart] != '\r'
                        && pwNew[ichtoktagStart] != '<'
                        && pwNew[ichtoktagStart] != '>'
                        && (pwNew[ichtoktagStart] != '=' || (fInValue /*&& index == 1*/))
                        && (ichNewCur > ichtoktagStart)
                        )
                {
                    ichtoktagStart += cchIncDec;
                    cchRange--;
                    if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                    {
                        fRet = FALSE;
                        goto LRet;
                    }
                }
            }
            break;
        case inTagOpen:
        case inTagClose:
        case inTagEq:
            // make sure that we have atleast count number of spaces at 
            // pwNew[ichtoktagStart-count]
            if (pwNew[ichtoktagStart] == '=' /* && index == 1*/)
                fInValue = TRUE;
            else
                fInValue = FALSE;
            while (    (pwNew[ichtoktagStart] == '<' || pwNew[ichtoktagStart] == '>' || pwNew[ichtoktagStart] == '=')
                    && count > 0
                    )
            {
                count--;
                ichtoktagStart += cchIncDec;
                cchRange--;
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }
            }
            break;

        case inSpace:
            // make sure that we have atleast count number of spaces at 
            // pwNew[ichtoktagStart-count]
            fInValue = FALSE;
            while (pwNew[ichtoktagStart] == ' ' && count > 0)
            {
                count--;
                ichtoktagStart += cchIncDec;
                cchRange--;
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }
            }
            if (count == 0) // we matched exact spaces, we may have more spaces in pwNew
            {
                if (fLookback)
                {
                    INT countT = 0;
                    //INT ichtoktagStartSav = ichtoktagStart;

                    if (cspInfopair == 0)
                        break;

                    ASSERT(index == 0 || index == 3);
                    // REMOVE EXTRA SPACES here.
                    while (pwNew[ichtoktagStart-countT] == ' ')
                        countT++;
                    if (countT > 0)
                    {
                        if (ichNewCur-(ichtoktagStart) > 0)
                        {
                            memmove((BYTE *)(pwNew+ichtoktagStart-countT+1),
                                    (BYTE *)(pwNew+ichtoktagStart),
                                    (ichNewCur-(ichtoktagStart))*sizeof(WCHAR));
                            ichNewCur -= (countT-1);
                            ichtoktagStart -= (countT-1);
                            while (countT > 1)
                            {
                                pwNew[ichNewCur+countT-2] = '\0';
                                countT--;
                            }
                        }
                    }
                }
                else if (!fLookback)
                {
                    INT countT = -1;

                    ASSERT(index == 1 || index == 2);
                    // look ahead into pspInfoCur to see what the next parameters should be
                    if ((index == 1) && (*(WORD *)pspInfoCur == inChar))
                    {
                        while (    pwNew[ichtoktagStart] == ' '
                                || pwNew[ichtoktagStart] == '\r'
                                || pwNew[ichtoktagStart] == '\n'
                                || pwNew[ichtoktagStart] == '\t'
                                )
                        {
                            countT++;
                            ichtoktagStart += cchIncDec;
                        }
                    }
                    else
                    {
                        while (pwNew[ichtoktagStart] == ' ')
                        {
                            countT++;
                            ichtoktagStart += cchIncDec;
                        }
                    }
                    if (countT > 0)
                    {
                        if (ichNewCur-(ichtoktagStart+1) > 0)
                        {
                            memmove((BYTE *)(pwNew+ichtoktagStart-countT-1),
                                    (BYTE *)(pwNew+ichtoktagStart),
                                    (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                            ichNewCur -= (countT+1);
                            ichtoktagStart -= (countT+1);
                            while (countT >= 0)
                            {
                                pwNew[ichNewCur+countT] = '\0';
                                countT--;
                            }
                        }
                    }
                }
            }
            else
            {
                if (fLookback)
                {
                    ASSERT(index == 0 || index == 3);
                    if ((int)(ichNewCur-ichtoktagStart-1) >= 0)
                    {
                        // insert spaces after ichtoktagStart
                        memmove((BYTE *)&pwNew[ichtoktagStart+1+count],
                                (BYTE *)&pwNew[ichtoktagStart+1],
                                (ichNewCur-ichtoktagStart-1)*sizeof(WCHAR));
                        ichNewCur += count;
                        //ichtoktagStart++;
                        while (count > 0)
                        {
                            pwNew[ichtoktagStart+count] = ' ';
                            count--;
                        }
                        //ichtoktagStart--; // compensate
                    }
                }
                else 
                {
                    ASSERT(index == 1 || index == 2);
                    if ((int)(ichNewCur-ichtoktagStart) >= 0)
                    {
                        int countT = count;

                        // insert spaces at ichtoktagStart and set ichtoktagStart after last space
                        memmove((BYTE *)&pwNew[ichtoktagStart+count],
                                (BYTE *)&pwNew[ichtoktagStart],
                                (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                        ichNewCur += count;
                        while (count > 0)
                        {
                            ASSERT((INT)(ichtoktagStart+count-1) >= 0);
                            pwNew[ichtoktagStart+count-1] = ' ';
                            count--;
                        }
                        ichtoktagStart += countT;
                    }
                }
            }
            break;
        case inEOL:
            // make sure that we have atleast count number of EOLs at 
            // pwNew[ichtoktagStart-count]
            // if fLookback, then we get '\n', else we get '\r'
            fInValue = FALSE;
            while ((pwNew[ichtoktagStart] == '\n' || pwNew[ichtoktagStart] == '\r') && count > 0)
            {
                count--;
                cchRange -= 2;
                ichtoktagStart += cchIncDec; // assume '\r' or '\n'
                ichtoktagStart += cchIncDec; // assume '\r' or '\n'
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }

            }
            if (count == 0) // we matched exact EOLs, we may have more EOLs in pwNew
            {
                if (fLookback)
                {
                    INT countT = 0;

                    ASSERT(index == 0 || index == 3);
                    // REMOVE EXTRA EOLs here.
                    while (    pwNew[ichtoktagStart-countT] == '\r'
                            || pwNew[ichtoktagStart-countT] == '\n'
                            )
                        countT++;
                    if (countT > 0)
                    {
                        if (ichNewCur-(ichtoktagStart) > 0)
                        {
                            memmove((BYTE *)(pwNew+ichtoktagStart-countT+1),
                                    (BYTE *)(pwNew+ichtoktagStart),
                                    (ichNewCur-(ichtoktagStart))*sizeof(WCHAR));
                            ichNewCur -= (countT-1);
                            ichtoktagStart -= (countT-1);
                            while (countT > 1)
                            {
                                pwNew[ichNewCur+countT-2] = '\0';
                                countT--;
                            }
                        }
                    }
                }
                else if (!fLookback)
                {
                    INT countT = 0;

                    ASSERT(index == 1 || index == 2);
                    // REMOVE EXTRA EOLS here.

                    // look ahead into pspInfoCur to see what the next parameters should be
                    if ((index == 1) && (*(WORD *)pspInfoCur == inChar))
                    {
                        while (    pwNew[ichtoktagStart] == ' '
                                || pwNew[ichtoktagStart] == '\r'
                                || pwNew[ichtoktagStart] == '\n'
                                || pwNew[ichtoktagStart] == '\t'
                                )
                        {
                            countT++;
                            ichtoktagStart += cchIncDec;
                        }
                    }
                    else
                    {
                        while (    pwNew[ichtoktagStart] == '\r'
                                || pwNew[ichtoktagStart] == '\n'
                                )
                        {
                            countT++;
                            ichtoktagStart += cchIncDec;
                        }
                    }
                    
                    //ASSERT(countT % 2 == 0); // assert that countT is an even number, because we should find \r & \n always in pair
                    if (countT > 0)
                    {
                        if (ichNewCur-(ichtoktagStart+1) > 0)
                        {
                            memmove((BYTE *)(pwNew+ichtoktagStart-countT),
                                    (BYTE *)(pwNew+ichtoktagStart),
                                    (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                            ichNewCur -= (countT);
                            ichtoktagStart -= (countT);
                            while (countT >= 0)
                            {
                                pwNew[ichNewCur+countT] = '\0';
                                countT--;
                            }
                        }
                    }
                }
            }
            else
            {
                if (fLookback)
                {
                    INT i;

                    ASSERT(index == 0 || index == 3);
                    if ((int)(ichNewCur-ichtoktagStart-1) >= 0)
                    {
                        // insert EOLs after ichtoktagStart
                        memmove((BYTE *)&pwNew[ichtoktagStart+1+count*2],
                                (BYTE *)&pwNew[ichtoktagStart+1],
                                (ichNewCur-ichtoktagStart-1)*sizeof(WCHAR));
                        ichNewCur += count*2;
                        count *= 2;
                        ichtoktagStart++;
                        for (i = 0; i < count; i+=2)
                        {
                            pwNew[ichtoktagStart+i] = '\r';
                            pwNew[ichtoktagStart+i+1] = '\n';
                        }
                        ichtoktagStart--; // compensate for prior increment
                    }
                }
                else 
                {
                    INT i;

                    ASSERT(index == 1 || index == 2);
                    // insert spaces at ichtoktagStart and set ichtoktagStart after last space
                    if ((int)(ichNewCur-ichtoktagStart) >= 0)
                    {
                        memmove((BYTE *)&pwNew[ichtoktagStart+count*2],
                                (BYTE *)&pwNew[ichtoktagStart],
                                (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                        ichNewCur += count*2;
                        count *= 2;
                        for (i=0; i < count; i+=2)
                        {
                            pwNew[ichtoktagStart+i] = '\r';
                            pwNew[ichtoktagStart+i+1] = '\n';
                        }
                        ichtoktagStart += count;
                    }
                }
            }

            break;
        case inTab:
            // make sure that we have atleast count number of spaces at 
            // pwNew[ichtoktagStart-count]
            fInValue = FALSE;
            while (pwNew[ichtoktagStart] == '\t' && count > 0)
            {
                count--;
                ichtoktagStart += cchIncDec;
                cchRange--;
                if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                {
                    fRet = FALSE;
                    goto LRet;
                }
            }
            if (count == 0) // we matched exact spaces, we may have more tabs in pwNew
            {
                // skip extra spaces in pwNew, if we had more spaces in pwNew than count
                while (pwNew[ichtoktagStart] == '\t')
                {
                    ichtoktagStart += cchIncDec;
                    cchRange--;
                    if (ichtoktagStart < 0 || cchRange < 0) // boundary condition
                    {
                        fRet = FALSE;
                        goto LRet;
                    }
                }

            }
            else
            {
                INT ichSav = ichtoktagStart;
                INT i;

                ASSERT(count > 0);
                // insert these many extra tabs at pwNew[ichtoktagStart] and increment ichNewCur
                if (fLookback)
                    ichtoktagStart++;
                if (ichNewCur-ichtoktagStart > 0)
                {
                    memmove((BYTE *)(pwNew+ichtoktagStart+count), 
                            (BYTE *)(pwNew+ichtoktagStart),
                            (ichNewCur-ichtoktagStart)*sizeof(WCHAR));
                }
                for (i = 0; i < count; i++)
                    pwNew[ichtoktagStart+i] = '\t';

                ichNewCur += count;
                if (fLookback)
                    ichtoktagStart = ichSav;
                else
                    ichtoktagStart += count;
            }
            break;
        } // switch (dwState)

    } // while ()
    if (   cspInfopair == 0
        && pwNew[ichNewCur-1] == '>'
        && ichNewCur > ichtoktagStart
        && !fLookback
        && index == 1)
    {
        INT countT = 0;

        ASSERT(cchIncDec == 1);
        // This means that we may have extra spaces & EOLs from ichtoktagStart to '>'
        // REMOVE EXTRA SPACES EOLS here.
        while (    pwNew[ichtoktagStart+countT] == ' '
                || pwNew[ichtoktagStart+countT] == '\r'
                || pwNew[ichtoktagStart+countT] == '\n'
                || pwNew[ichtoktagStart+countT] == '\t'
                )
        {
            countT++;
        }
        if (countT > 0 && pwNew[ichtoktagStart+countT] == '>')
        {
            if (ichNewCur-(ichtoktagStart+1) > 0)
            {
                memmove((BYTE *)(pwNew+ichtoktagStart),
                        (BYTE *)(pwNew+ichtoktagStart+countT),
                        (ichNewCur-(ichtoktagStart+countT))*sizeof(WCHAR));
                ichNewCur -= (countT);
                ichtoktagStart -= (countT);
                while (countT > 0)
                {
                    pwNew[ichNewCur+countT-1] = '\0';
                    countT--;
                }
            }
        }

        // Next time around - we can do the following...
        // look back from ichtoktagStart and check if we have any spaces/eols.
        // if we do, there is a likelihood that these shouldn't have been there.
        // Here is how they get there - If we had spaces between the parameter and
        // the '=' and its value, those spacves are removed by Trident. We then go
        // in and add those spaces at the end rather than at proper place because 
        // we don't break up the text. e.g. "width = 23" --> "width=23". 
        // Now, because we don't break that text, we end up inserting these spaces
        // at the end. Lets remove them.
    }
    else if (      cspInfopair == 0
                && fLookback
                && (index == 0 || index == 3)) /* VID6 - bug 18207 */
    {
        INT countT = 0;

        ASSERT(cchIncDec == -1);
        // This means that we may have extra spaces & EOLs before ichtoktagStart to '>'
        // REMOVE EXTRA SPACES EOLS here.
        while (    pwNew[ichtoktagStart-countT] == ' '
                || pwNew[ichtoktagStart-countT] == '\r'
                || pwNew[ichtoktagStart-countT] == '\n'
                || pwNew[ichtoktagStart-countT] == '\t'
                )
        {
            countT++;
        }
        if (countT > 0 && pwNew[ichtoktagStart-countT] == '>')
        {
            if (ichNewCur-(ichtoktagStart+1) > 0)
            {
                memmove((BYTE *)(pwNew+ichtoktagStart-countT+1),
                        (BYTE *)(pwNew+ichtoktagStart+1),
                        (ichNewCur-(ichtoktagStart+1))*sizeof(WCHAR));
                ichNewCur -= countT;
                ichtoktagStart -= (countT); // this doesn't matter because we will exit after this
                while (countT > 0)
                {
                    pwNew[ichNewCur+countT-1] = '\0';
                    countT--;
                }
            }
        }
    }
LRet:
    m_pspInfoOut = m_pspInfoOut + cchwspInfoSav;
    *pcchwspInfo = cchwspInfo;
    *pichNewCur = ichNewCur;
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\htmparse.h ===
// HtmParse.h : Declaration of the CHtmParse
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __HTMPARSE_H_
#define __HTMPARSE_H_

#include "resource.h"       // main symbols
#include "guids.h"
#include "lexhtml.h"
#include "token.h"

#define tokClsIgnore tokclsError // if you don't want to use the token class info in the rule, use this.

#define cbBufPadding 0x800 // we allocate this much extra memory so that subsequent reallocs are saved
#define MIN_TOK 100 // init size for token stack to keep track of nested blocks. e.g. <table>...<table>...</table>...</table>

// init value for number of <TBODY> tags
#define cTBodyInit 20 // init size of nested TBODY's. we start with the assumption that we won't have more than these many nested TBODYs and reallocate if needed.

#define cchspBlockMax 20 // size of spacing block index. we can't have more than 20 digit number
// state flags for space preservation
#define initState   0x0000
#define inChar      0x0001
#define inSpace     0x0002
#define inEOL       0x0003
#define inTab       0x0004
#define inTagOpen   0x0005
#define inTagClose  0x0006
#define inTagEq     0x0007

// used by space preservation in comments
#define chCommentSp '2'
#define chCommentEOL '3'
#define chCommentTab '4'

// Specializations for hrTokenizeAndParse
#define PARSE_SPECIAL_NONE		0x00000000
#define PARSE_SPECIAL_HEAD_ONLY	0x00000001

/////////////////////////////////////////////////////////////////////////////
// CTriEditParse
class ATL_NO_VTABLE CTriEditParse : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTriEditParse, &CLSID_TriEditParse>,
    public ITokenGen
{
public:
    CTriEditParse();
    ~CTriEditParse();

DECLARE_REGISTRY_RESOURCEID(IDR_TRIEDITPARSE)

BEGIN_COM_MAP(CTriEditParse)
    COM_INTERFACE_ENTRY_IID(IID_ITokenGen, ITokenGen)
END_COM_MAP()



// ITokenGen // copied from CColorHtml
public:
    STDMETHOD(NextToken)(LPCWSTR pszText, UINT cbText, UINT* pcbCur, DWORD * pLXS, TXTB* pToken);
    STDMETHOD(hrTokenizeAndParse)(HGLOBAL hOld, HGLOBAL *phNew, IStream *pStmNew, DWORD dwFlags, FilterMode mode, int cbSizeIn, UINT* pcbSizeOut, IUnknown* pUnkTrident, HGLOBAL *phgTokArray, UINT *pcMaxToken, HGLOBAL *phgDocRestore, BSTR bstrBaseURL, DWORD dwReserved);

private:
    static long m_bInit;
    PSUBLANG    m_rgSublang;

    IUnknown *m_pUnkTrident; // we cache it in hrTokenizeAndParse()
    HGLOBAL m_hgDocRestore; // we cache it in hrTokenizeAndParse()
    LPWSTR m_bstrBaseURL;

    // flag used to remember if we have a unicode file that has 0xff,0xfe at the begining
    BOOL m_fUnicodeFile;

    // following m_c's keep track of number of respective tags found
    // during parsing. e.g. m_cHtml will keep track of count of 
    // <html> tags
    INT m_cHtml;
    INT m_cDTC;
    INT m_cObj;
    INT m_cSSSIn;
    INT m_cSSSOut;
    INT m_cNbsp;
    INT m_cHdr;
    INT m_cFtr;
    INT m_cObjIn;
    INT m_cComment;
    INT m_cAImgLink;

    UINT m_cMaxToken;       // Max of token array (pTokArray)
    BOOL m_fEndTagFound;    // end tag found
    INT  m_iControl;        // index in applet collection
    BOOL m_fSpecialSSS;     // found special SSS <%@....%>

    // used to save space preservation info
    HGLOBAL m_hgspInfo;
    WORD *m_pspInfo;
    WORD *m_pspInfoOut;
    WORD *m_pspInfoOutStart;
    WORD *m_pspInfoCur;
    UINT m_ichStartSP;          // save all prev spacing info at this ich
    INT m_ispInfoBase;
    INT m_ispInfoIn;
    INT m_ispInfoOut;
    INT m_iArrayspLast;
    INT m_ispInfoBlock;
    INT m_cchspInfoTotal;
    BOOL m_fDontDeccItem;       // we don't have counters for items that we don't process, so we use this to preserve the total count
    
    // used by <TBODY> code.
    // Trident puts in extra <tbody></tbody> tags inside table
    // and filtering tries to remove them.
    HGLOBAL m_hgTBodyStack;
    UINT *m_pTBodyStack;
    INT m_iMaxTBody;
    INT m_iTBodyMax;

    // used by Page Transition DTC code
    // page transition dtc is a special case in filtering because 
    // we have to maintain its location inside the head section.
    BOOL m_fInHdrIn;
    INT m_cchPTDTCObj;
    INT m_ichPTDTC;
    INT m_cchPTDTC;
    INT m_indexBeginBody;
    INT m_indexEndBody;
    WCHAR *m_pPTDTC;
    HGLOBAL m_hgPTDTC;

    // used by the code that recreates our own pre-Body part of the document
    BOOL m_fHasTitleIn;
    INT m_indexTitleIn;
    INT m_ichTitleIn;
    INT m_cchTitleIn;
    INT m_ichBeginBodyTagIn;
    INT m_indexHttpEquivIn;
    INT m_ichBeginHeadTagIn;

    // used by APPLET pretty-printing code
    int m_cAppletIn;
    int m_cAppletOut;

    // used to keep track of multiple occurances of BODY, HTML, TITLE & HEAD tags
    int m_cBodyTags;
    int m_cHtmlTags;
    int m_cTitleTags;
    int m_cHeadTags;

    void SetTable(DWORD lxs);
    void InitSublanguages();
    void PreProcessToken(TOKSTRUCT *pTokArray, INT *pitokCur, LPWSTR pszText, UINT cbCur, TXTB token, DWORD lxs, INT tagID, FilterMode mode);
    void PostProcessToken(OLECHAR *pwOld, OLECHAR *pwNew, UINT *pcbNew, UINT cbCur, UINT cbCurSav, TXTB token, FilterMode mode, DWORD lxs, DWORD dwFlags);
    int ValidateTag(LPWSTR pszText);
    int GetTagID(LPWSTR pszText, TXTB token);
    HRESULT hrMarkSpacing(WCHAR *pwOld, UINT cbCur, INT *pchStartSP);
    void SetSPInfoState(WORD inState, WORD *pdwState, WORD *pdwStatePrev, BOOL *pfSave);
    BOOL FRestoreSpacing(LPWSTR pwNew, LPWSTR pwOld, UINT *pichNewCur, INT *pcchwspInfo, INT cchRange, INT ichtoktagStart, BOOL fLookback, INT index);
    HRESULT hrMarkOrdering(WCHAR *pwOld, TOKSTRUCT *pTokArray, INT iArrayStart, INT iArrayEnd, UINT cbCur, INT *pichStartOR);
    BOOL FRestoreOrder(WCHAR *pwNew, WCHAR *pwOld, WORD *pspInfoOrder, UINT *pichNewCur, INT cwOrderInfo, TOKSTRUCT *pTokArray, INT iArrayStart, INT iArrayEnd, INT iArrayDSPStart, INT iArrayDSPEnd, INT cchNewCopy, HGLOBAL *phgNew);
    void SaveSpacingSpecial(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR *ppwNew, HGLOBAL *phgNew, TOKSTRUCT *pTokArray, INT iArray, UINT *pichNewCur);
    void RestoreSpacingSpecial(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR *ppwNew, HGLOBAL *phgNew, TOKSTRUCT *pTokArray, UINT iArray, UINT *pichNewCur);

    HRESULT ProcessToken(DWORD &lxs, TXTB &tok, LPWSTR pszText, UINT cbCur, TOKSTACK *pTokStack, INT *pitokTop, TOKSTRUCT *pTokArray, INT iArrayPos, INT tagID);
    void FilterHtml(LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, TOKSTRUCT *pTokArray, FilterMode mode, DWORD dwFlags);


    struct FilterTok
    {
        TOKEN tokBegin;
        TOKEN tokBegin2; // supporting token
        TOKEN tokClsBegin;
        TOKEN tokEnd;
        TOKEN tokEnd2; // supporting token
        TOKEN tokClsEnd;
    };

    typedef  void (_stdcall* PFNACTION)(CTriEditParse *, LPWSTR, LPWSTR *, UINT *, HGLOBAL *, TOKSTRUCT *, UINT*, FilterTok, INT*, UINT*, UINT*, DWORD);
    struct FilterRule
    {
        FilterTok ft;
        PFNACTION pfn;
    };

    // Following are static functions. We could make them members, but it wasn't felt necessary then.
    void static fnRestoreDTC(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveDTC(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);

    void static fnRestoreSSS(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveSSS(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);

    void static fnRestoreHtmlTag(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveHtmlTag(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveNBSP(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnRestoreNBSP(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnSaveHdr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnRestoreHdr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnSaveFtr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnRestoreFtr(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy,
              DWORD dwFlags);
    void static fnRestoreSpace(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveSpace(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreSpaceEnd(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreObject(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveObject(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreTbody(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveTbody(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveApplet(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreApplet(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveAImgLink(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreAImgLink(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveComment(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreComment(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnSaveTextArea(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);
    void static fnRestoreTextArea(CTriEditParse *ptep, LPWSTR pwOld, LPWSTR* ppwNew, UINT *pcchNew, HGLOBAL *phgNew, 
              TOKSTRUCT *pTokArray, UINT *piArrayStart, FilterTok ft,
              INT *pcHtml, UINT *pichNewCur, UINT *pichBeginCopy, DWORD dwFlags);

    #define cRuleMax 26 /* max number of filtering rules. if you add a new rule above, change this too */
    FilterRule m_FilterRule[cRuleMax];

};


#endif //__HTMPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\lex.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __LEX__
#define __LEX__

#include <tchar.h>

#include "fmtinfo.h"
#include "token.h"

#define P_IN(x)     const x &
#define P_OUT(x)    x &
#define P_IO(x)     x &
#define PURE        = 0

// Lex state, kept at the beginning of every line (lxsBOL) from
// previous line's state at its end (lxsEOL). Must fit all bits
// necessary to restart lexing on a line by line basis.

typedef DWORD   LXS;
typedef LXS *   PLXS;

// Lexer and language Metrics
const unsigned ctchUserTokenPhrase = 100;
struct USERTOKENS
{
    INT         token;      // preassigned in the user range
    TCHAR       szToken[ctchUserTokenPhrase+1]; // token class name exposed to user
    COLORREF    RGBText;
    COLORREF    RGBBackground;
    AUTO_COLOR  autocolorFore;
    AUTO_COLOR  autocolorBack;
};
typedef USERTOKENS *        PUSERTOKENS;
typedef const USERTOKENS *  PCUSERTOKENS;


// Alternate way of looking at a token, editor will only look at tokUser.
// Other clients of the lexer (like the parser or the EE) may want to look
// at the actual token in tokAct.  If any of tokAct is set, then it is expected
// that the actual token is different than the meta token it passed back.
// The status bits are only used by the lexer for whatever it wants.

union TOK_ALT  {
    TOKEN   tok;
    struct {
        unsigned        tokUser : 12;
        unsigned        tokUserStatus : 4;
        unsigned        tokAct : 12;
        unsigned        tokActStatus : 4;
    };
};


// A SUBLANG structure was originally used for identifying different
// dialects of the same language (like fortran fixed and fortran free)
// that use the same lexer, can be treated as two languages in the editor,
// and share all the same color/font info in the format dialog.
//
// We've extended it to be a general descriptor for a type of text file.
//
struct SUBLANG
{
    LPCTSTR szSubLang;
    LXS     lxsInitial;
    UINT    nIdTemplate; // Icon and MFC doc template string resource id
    CLSID   clsidTemplate;
};
typedef SUBLANG * PSUBLANG;
typedef const SUBLANG * PCSUBLANG;

#define MAX_LANGNAMELEN (50)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\ioleobj.cpp ===
//------------------------------------------------------------------------------
// ioleobj.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     bash
//
// History
//      6-27-97      created     (bash)
//
// Implementation of IOleObject.
//
// We mostly just delegate to Trident's IOleObject, except
// for GetUserClassID and GetUserType.  We also cache the
// host's clientsite and uihandler interfaces in SetClientSite.
//------------------------------------------------------------------------------

#include "stdafx.h"

#include "triedit.h"
#include "document.h"

STDMETHODIMP CTriEditDocument::SetClientSite(IOleClientSite *pClientSite)
{
    ATLTRACE(_T("IOleObjectImpl::SetClientSite\n"));

    HRESULT hr;
    ICustomDoc *pCustomDoc = NULL;

    _ASSERTE(m_pOleObjTrident);
    
    SAFERELEASE(m_pClientSiteHost);
    SAFERELEASE(m_pUIHandlerHost);
    SAFERELEASE(m_pDragDropHandlerHost);

    m_pClientSiteHost = pClientSite;
    if (NULL != m_pClientSiteHost)
    {
        m_pClientSiteHost->AddRef(); 
        m_pClientSiteHost->QueryInterface(IID_IDocHostUIHandler, (void **) &m_pUIHandlerHost);
        m_pClientSiteHost->QueryInterface(IID_IDocHostDragDropHandler, (void **) &m_pDragDropHandlerHost);
    }

    hr = m_pOleObjTrident->SetClientSite(pClientSite);

    if (!m_fUIHandlerSet)
    {
        // Give Trident the pointer to our IDocHostUIHandler
        // This has to be done after the SetClientSite call due to a Trident bug

        hr = m_pUnkTrident->QueryInterface(IID_ICustomDoc, (void **) &pCustomDoc);
        if (SUCCEEDED(hr) && m_pUIHandler)
        {
            hr = pCustomDoc->SetUIHandler(static_cast<IDocHostUIHandler*>(m_pUIHandler));

            pCustomDoc->Release();
        }

    m_fUIHandlerSet = TRUE;

    // We can only call this after SetClientSite or else Trident will crash
    SetUpDefaults();
    }

#ifdef IE5_SPACING
    // instantiate the sink
    if (NULL != m_pClientSiteHost)
    {
        CComPtr<IHTMLDocument2> pHTMLDocument2;

        m_pTridentEventSink = NULL;
        hr = m_pUnkTrident->QueryInterface(IID_IHTMLDocument2, (void**)&pHTMLDocument2);
        if (hr == S_OK && pHTMLDocument2 != NULL)
        {
            m_pTridentEventSink = new CComObject<CTridentEventSink>;
            if (m_pTridentEventSink != NULL)
            {
                m_pTridentEventSink->m_pHTMLDocument2 = pHTMLDocument2;
                m_pTridentEventSink->m_pTriEditDocument = this;
                hr = m_pTridentEventSink->AddRef();
                hr = m_pTridentEventSink->Advise(m_pTridentEventSink->m_pHTMLDocument2, DIID_HTMLDocumentEvents);
            }
        }
    }
    else
    {
        if (m_pTridentEventSink)
        {
            m_pTridentEventSink->Unadvise();
            hr = m_pTridentEventSink->Release();
        }
    }
#endif //IE5_SPACING

    return hr;
}

STDMETHODIMP CTriEditDocument::GetClientSite(IOleClientSite **ppClientSite)
{
    ATLTRACE(_T("IOleObjectImpl::GetClientSite\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetClientSite(ppClientSite);
}

STDMETHODIMP CTriEditDocument::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    ATLTRACE(_T("IOleObjectImpl::SetHostNames\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->SetHostNames(szContainerApp, szContainerObj);
}

STDMETHODIMP CTriEditDocument::Close(DWORD dwSaveOption)
{
    ATLTRACE(_T("IOleObjectImpl::Close\n"));

    _ASSERTE(m_pOleObjTrident);

    ReleaseElement();

    return m_pOleObjTrident->Close(dwSaveOption);
}

STDMETHODIMP CTriEditDocument::SetMoniker(DWORD dwWhichMoniker, IMoniker* pmk)
{
    ATLTRACE(_T("IOleObjectImpl::SetMoniker\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->SetMoniker(dwWhichMoniker, pmk);
}

STDMETHODIMP CTriEditDocument::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk )
{
    ATLTRACE(_T("IOleObjectImpl::GetMoniker\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetMoniker(dwAssign, dwWhichMoniker, ppmk);
}

STDMETHODIMP CTriEditDocument::InitFromData(IDataObject*  pDataObject, BOOL fCreation, DWORD dwReserved)
{
    ATLTRACE(_T("IOleObjectImpl::InitFromData\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->InitFromData(pDataObject,  fCreation,  dwReserved );
}

STDMETHODIMP CTriEditDocument::GetClipboardData(DWORD dwReserved, IDataObject** ppDataObject)
{
    ATLTRACE(_T("IOleObjectImpl::GetClipboardData\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetClipboardData(dwReserved, ppDataObject);
}


STDMETHODIMP CTriEditDocument::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite , LONG lindex ,
                                 HWND hwndParent, LPCRECT lprcPosRect)
{
    ATLTRACE(_T("IOleObjectImpl::DoVerb\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->DoVerb(iVerb, lpmsg, pActiveSite, lindex, hwndParent, lprcPosRect);
}

STDMETHODIMP CTriEditDocument::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    ATLTRACE(_T("IOleObjectImpl::EnumVerbs\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->EnumVerbs(ppEnumOleVerb);
}

STDMETHODIMP CTriEditDocument::Update(void)
{
    ATLTRACE(_T("IOleObjectImpl::Update\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->Update();
}

STDMETHODIMP CTriEditDocument::IsUpToDate(void)
{
    ATLTRACE(_T("IOleObjectImpl::IsUpToDate\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->IsUpToDate();
}

STDMETHODIMP CTriEditDocument::GetUserClassID(CLSID *pClsid)
{
    ATLTRACE(_T("IOleObjectImpl::GetUserClassID\n"));

    _ASSERTE(m_pOleObjTrident);

    *pClsid = GetObjectCLSID();

    return S_OK;
}

STDMETHODIMP CTriEditDocument::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    ATLTRACE(_T("IOleObjectImpl::GetUserType\n"));

    _ASSERTE(m_pOleObjTrident);

    return OleRegGetUserType(GetObjectCLSID(), dwFormOfType, pszUserType);
}

STDMETHODIMP CTriEditDocument::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    ATLTRACE(_T("IOleObjectImpl::SetExtent\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->SetExtent(dwDrawAspect, psizel);
}

STDMETHODIMP CTriEditDocument::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    ATLTRACE(_T("IOleObjectImpl::GetExtent\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetExtent(dwDrawAspect, psizel);
}

STDMETHODIMP CTriEditDocument::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    ATLTRACE(_T("IOleObjectImpl::Advise\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->Advise(pAdvSink, pdwConnection);
}

STDMETHODIMP CTriEditDocument::Unadvise(DWORD dwConnection)
{
    ATLTRACE(_T("IOleObjectImpl::Unadvise\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->Unadvise(dwConnection);
}

STDMETHODIMP CTriEditDocument::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    ATLTRACE(_T("IOleObjectImpl::EnumAdvise\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->EnumAdvise(ppenumAdvise);
}

STDMETHODIMP CTriEditDocument::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    ATLTRACE(_T("IOleObjectImpl::GetMiscStatus\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->GetMiscStatus(dwAspect, pdwStatus);
}

STDMETHODIMP CTriEditDocument::SetColorScheme(LOGPALETTE* pLogpal)
{
    ATLTRACE(_T("IOleObjectImpl::SetColorScheme\n"));

    _ASSERTE(m_pOleObjTrident);

    return m_pOleObjTrident->SetColorScheme(pLogpal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\lexer.cpp ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
/* copied from ..\htmed\lexer.cpp */

/*++

  Copyright (c) 1995 Microsoft Corporation

  File: lexer.cpp

  Abstract:
        Nitty Gritty Lexer stuff

  Contents:
      SetValueSeen()
      IsSingleOp()
      IsWhiteSpace()
      MapToken()
      FindEndTag()
      MakeSublang()
      SetLanguage()
      FindTable()
      FindTable()
      RemoveTable()
      MakeTableSet()
      GetToken()
      IfHackComment()
      FindServerScript()
      FindEndComment()
      FindEndEntity()
      FindEntityRef()
      FindValue()
      FindEndString()
      FindTagOpen()
      FindText()
      FindNextToken()
      GetTextHint()
      GetHint()
      GetTokenLength()
      GetValueTokenLength()
      IsElementName()
      IsAttributeName()
      IsIdentifier()
      IsUnknownID()
      IsNumber()
      CColorHtml::SetTable()
      CColorHtml::InitSublanguages()

  History:
      2/14/97   cgomes:   Created


--*/

#include "stdafx.h"

#include "resource.h"
#include "guids.h"
#include "token.h"
#include "table.h"
#include "lexer.h"

UINT FindClientScriptEnd(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);

#undef ASSERT
#define ASSERT(b) _ASSERTE(b)
// HACK: we keep a copy of a ptr to the ASP table and sublang
// so we can do special behavior for ASP files
CTableSet* g_ptabASP = 0;
PSUBLANG g_psublangASP = 0;

PTABLESET g_arpTables[CV_MAX+1];

// NOTE: added to handle value tokens properly.
UINT GetValueTokenLength(LPCTSTR pchLine, UINT cbLen, UINT cbCur);

// mark state transition from value -> next attribute
inline int SetValueSeen(DWORD *plxs)
{
    if (*plxs & inValue)
    {
        *plxs &= ~inValue;
        *plxs |= inAttribute;
        return TRUE;
    }
    else
        return FALSE;
}

// REVIEW (walts) - need better way
inline void SetScriptLanguage(LPCTSTR pchLine, DWORD *plxs)
{
    LPCTSTR strJavaScript       = _T("javascript");
    LPCTSTR strVBScript         = _T("vbscript");
    // triedit's special language. Its set when we convert server-side scripts into
    // client-side scripts. Its a dummy language. if we find that as language, we
    // set in ServerASP. It is reset(removed) in FindNextToken().
    LPCTSTR strServerAsp        = _T("serverasp");

    // language attribute may have quotes around it.
    // if it does then advance past the first quote.
    //      ex. <SCRIPT LANGUAGE="VBScript">
    if(*pchLine == L'\"')
        pchLine++;

    if (_tcsnicmp(pchLine, strJavaScript, lstrlen(strJavaScript)) == 0)
    {
        *plxs &= ~inVBScript;
        *plxs &= ~inServerASP;
        *plxs |= inJavaScript;
    }
    else if (_tcsnicmp(pchLine, strVBScript, lstrlen(strVBScript)) == 0)
    {
        *plxs &= ~inJavaScript;
        *plxs &= ~inServerASP;
        *plxs |= inVBScript;
    }
    else if (_tcsnicmp(pchLine, strServerAsp, lstrlen(strServerAsp)) == 0)
    {
        *plxs &= ~inJavaScript;
        *plxs &= ~inVBScript;
        *plxs |= inServerASP;
    }
}

inline BOOL IsSingleOp(HINT hint)
{
    return ((hint >= tokOP_SINGLE) && (hint < tokOP_MAX));
};

inline BOOL IsWhiteSpace(TCHAR c)
{
    return _istspace(c);
};


// NOTE: Added to handle value tokens properly
inline IsValueChar(TCHAR ch)
{
    // REVIEW(cgomes): specify all the invalid value characters
    return ch != _T('<') && ch != _T('>');
};

////////////////////////////////////////////////////////////////////////////
//
// map parsed token to returned token

// left column must be in ascending order
static TOKEN _rgTokenMap[] =
{
    tokName,     tokSpace,
    tokNum,      tokSpace,
    tokParEnt,   tokSpace,
    tokResName,  tokSpace,
    0,           0
};

static TOKEN MapToken(TOKEN tokClass, DWORD lxs)
{
    if (IsSingleOp((HINT)tokClass))
        return tokOp;
    else if ((tokClass == tokTag) && (lxs & inHTXTag))
        return tokSSS;
    for (int i = 0; (_rgTokenMap[i] != 0) && (_rgTokenMap[i] >= tokClass); i += 2)
    {
        if (_rgTokenMap[i] == tokClass)
            return _rgTokenMap[i + 1];
    }
    return tokClass;
}

////////////////////////////////////////////////////////////////////////////

UINT FindEndTag(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD *plxs, TXTB & token)
{
    ASSERT(pchLine);
    TCHAR szEnd[16];
    ELLEX * pellex = pellexFromTextState(*plxs);
    ASSERT(0 != pellex); // shouldn't be called with something other than special text state
    UINT cbCmp = 3 + pellex->cb; // length of end tag
    ASSERT(cbCmp < sizeof szEnd);
    _tcscpy(szEnd, _T("</"));
    _tcscat(szEnd, pellex->sz);
    _tcscat(szEnd, _T(">"));

    while (cbCur < cbLen)
    {
        if (_T('<') == pchLine[cbCur])
        {
            if ((cbLen - cbCur >= cbCmp) && (0 == _tcsnicmp(szEnd, &pchLine[cbCur], cbCmp)))
            {
                *plxs &= ~TEXTMASK; // special text modes are exclusive
                token.ibTokMac = cbCur;
                return cbCur;
            }
            else if ((cbCur + 1 < cbLen) && (_T('%') == pchLine[cbCur+1]))
            {
                *plxs |= inHTXTag;
                token.ibTokMac = cbCur;
                break;
            }
            else
                cbCur++;
        }
        else
            cbCur += _tclen(&pchLine[cbCur]);
    }
    token.ibTokMac = cbCur;
    return cbCur;
}

////////////////////////////////////////////////////////////////////////////

BOOL MakeSublang(PSUBLANG ps, UINT id, const TCHAR *strName, UINT nIdTemplate, CLSID clsid)
{
    int len;

    ASSERT( NULL != ps );

    ps->szSubLang = NULL;
    ps->lxsInitial = LxsFromSubLangIndex(id);
    ps->nIdTemplate = nIdTemplate;
    ps->clsidTemplate = clsid;

    if ((len = lstrlen(strName)) != 0)
    {
        LPTSTR szNew = new TCHAR [len+1];
        if (NULL != szNew)
        {
            _tcscpy(szNew,strName);
            ps->szSubLang = szNew;
            return TRUE;
        }
    }
    return FALSE;
}

// Set sublang and tableset array members,
// putting the default one in 0th position.
//
void SetLanguage(TCHAR * strDefault, PSUBLANG rgSublang,
                 PTABLESET pTab, UINT & index, UINT nIdTemplate, CLSID clsid)
{
    if (pTab != NULL)
    {
        int i;
        if (lstrcmp(strDefault, pTab->Name()) == 0)
            i = 0;
        else
            i = index;
        if (MakeSublang(rgSublang+i, i, pTab->Name(), nIdTemplate, clsid))
        {
            g_arpTables[i] = pTab;
            if (i)
                index++;
            else
                g_pTable = pTab;
        }
        else
            delete pTab;
    }
}

CTableSet * FindTable(CTableSet ** rgpts, TCHAR *strName)
{
    for (int n = 0; rgpts[n]; n++)
    {
        if (rgpts[n]->Name() == strName)
        //if (strcmp(rgpts[n]->Name(), strName) == 0)
            return rgpts[n];
    }
    return NULL;
}

CTableSet * FindTable(CTableSet ** rgpts, CTableSet * pts)
{
    for (int n = 0; rgpts[n]; n++)
    {
        if (rgpts[n] == pts)
            return rgpts[n];
    }
    return NULL;
}

void RemoveTable(CTableSet ** rgpts, CTableSet *pts)
{
    int n;
    for (n = 0; rgpts[n]; n++)
    {
        if (rgpts[n] == pts)
        {
            for(; rgpts[n]; n++)
                rgpts[n] = rgpts[n+1];
            return;
        }
    }
}

CTableSet * MakeTableSet(CTableSet ** /*rgpts*/, RWATT_T att, UINT nIdName)
{
    return new CStaticTableSet(att, nIdName);
}

////////////////////////////////////////////////////////////////////////
// GetToken()
//
UINT GetToken(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    ASSERT (cbCur < cbLen);
    if(cbCur > cbLen)
        return cbCur;

    UINT cbCount = 0;

    // init token
    token.tok = 0;

    // initialize location where token starts
    token.ibTokMin = cbCur;

    if (*plxs & inHTXTag)
        cbCount = FindServerScript(pchLine, cbLen, cbCur, plxs, token);
    else if (*plxs & inSCRIPT && !(*plxs & inTag) && !(*plxs & inServerASP))
    {
        // NOTE that we want to skip tokenizing scripts that are special to triedit
        // when we wrap server-side scripts in client-side scripts, we set a dummy
        // language as 'serverasp'. inServerASP is set in that case.
        cbCount = FindClientScriptEnd(pchLine, cbLen, cbCur, plxs, token);
    }
    else if (*plxs & inComment)  // in a comment
    {
        if (*plxs & inSCRIPT)
            *plxs |= inScriptText;
        COMMENTTYPE ct = IfHackComment(pchLine, cbLen, cbCur, plxs, token);
        if (ct == CT_METADATA)
        {
            // Treat as an element
            cbCount = FindNextToken(pchLine, cbLen, cbCur, plxs, token);
            // Remove inBangTag
            *plxs &= ~inBangTag;
        }
        else if (ct == CT_IECOMMENT)
            cbCount = token.ibTokMac;
        else
            cbCount = FindEndComment(pchLine, cbLen, cbCur, plxs, token);
    }
    else if (*plxs & INSTRING)  // in a string
        cbCount = FindEndString(pchLine, cbLen, cbCur, plxs, token);
    else
        cbCount = FindNextToken(pchLine, cbLen, cbCur, plxs, token);

    token.tokClass = MapToken(token.tokClass, *plxs);
    return cbCount;
}

///////////////////////////////////////////////////////////////////////////////////
// IfHackComment
//
// Probe ahead in the current line to see if we have what IE recognizes
// as the end of a comment ("->"). This does not conform to RFC 1866 or SGML,
// but suppports browser behavior. This lets us tolerate comments of the
// form: "<!--- whatever ->"
// (note how it ends)
//
// Returns a COMMENTTYPE enum.
//  0 if norma comment
//  1 if IE comment
//  -1 if METADATA comment
//
// Proper comments are scanned using FindEndComment().
//
COMMENTTYPE IfHackComment(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    token.tokClass = tokComment;
    while (cbCur+1 < cbLen)
    {
        if(_tcsnicmp(&pchLine[cbCur], _T("METADATA"), lstrlen(_T("METADATA"))) == 0)
        {
            token.ibTokMac = cbCur + 1; // include second dash??
            *plxs &= ~inComment;
            // Remove inBangTag
            *plxs &= ~inBangTag;
            *plxs |= inTag;
            return CT_METADATA; // METADATA
        }
        else if (pchLine[cbCur] == '-' && pchLine[cbCur + 1] == '>')
        {
            token.ibTokMac = cbCur + 1;
            *plxs &= ~inComment;
            *plxs &= ~inScriptText;
            return CT_IECOMMENT;
        }
        else
        {
            cbCur += _tclen(&pchLine[cbCur]);
        }
    }
    return CT_NORMAL;
}


UINT FindServerScript(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int cb;

    // parse HTX start tag
    if (*pCurrent == _T('<') && (cbCur+1 < cbLen) && *(pCurrent+1) == '%')
    {
        token.tokClass = tokTag;
        token.tok = TokTag_SSSOPEN;
        token.ibTokMac = cbCur + 2;
        *plxs |= inHTXTag;
        return token.ibTokMac;
    }

    ASSERT(*plxs & inHTXTag); // should be in HTXTag state here

    if (*pCurrent == _T('%') && (cbCur+1 < cbLen) && *(pCurrent+1) == '>')
    {
        token.tok = TokTag_SSSCLOSE;
        token.tokClass = tokSSS; //tokTag;
        token.ibTokMac = cbCur + 2;
        *plxs &= ~inHTXTag;
        if (*plxs & inNestedQuoteinSSS)
            *plxs &= ~inNestedQuoteinSSS;
        return token.ibTokMac;
    }

    token.tokClass = tokSSS;

    while (cbCur < cbLen)
    {
        if (*pCurrent == _T('%') && (cbCur+1 < cbLen) && (*(pCurrent+1) == _T('>')))
            break;
        if (   *pCurrent == _T('"') 
            && *plxs&inTag
            && *plxs&inHTXTag
            && *plxs&inAttribute
            && *plxs&inString
            )
            *plxs |= inNestedQuoteinSSS;

        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }

    token.ibTokMac = cbCur;
    return cbCur;
}

///////////////////////////////////////////////////////////////////////////////////
// FindClientScriptEnd()
//
// HTMED CHANGE: Find the end of client script block
//
UINT FindClientScriptEnd(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int cb;

    TCHAR rgEndScript[] = _T("</SCRIPT");
    int cchEndScript = (wcslen(rgEndScript) - 1);

    if( cbCur + cchEndScript < cbLen &&
        0 == _tcsnicmp(pCurrent, rgEndScript, cchEndScript))
    {
        token.tokClass = tokTag;
        token.tok = TokTag_END;
        *plxs &= ~inSCRIPT;
        *plxs |= inEndTag;
        token.ibTokMac = cbCur + 2;
        return token.ibTokMac;
    }

    token.tokClass = tokSpace;

    while (cbCur < cbLen)
    {
        if (*pCurrent == _T('<') && (cbCur+1 < cbLen) && (*(pCurrent+1) == _T('/')))
        {
            // Check if found end </SCRIPT
            if( cbCur + cchEndScript < cbLen &&
                0 == _tcsnicmp(pCurrent, rgEndScript, cchEndScript))
            {
                // Check if found end </SCRIPT
                break;
            }
        }
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }

    token.ibTokMac = cbCur;
    return cbCur;
}

///////////////////////////////////////////////////////////////////////////////////
// FindEndComment()
//
// Find the end of comment ("--").
//
UINT FindEndComment(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    BOOL bEndComment = FALSE;
    int cb;

    ASSERT(*plxs & inComment); // must be in a comment now

    token.tokClass = tokComment;

    while (!bEndComment && cbCur < cbLen)
    {
        if (*pCurrent == _T('-'))  // check the character to see if it's the first "-" in "--"
        {
            pCurrent++;
            cbCur++;
            if ((cbCur < cbLen) &&
                (*pCurrent == _T('-'))) // we're possibly at the end, so search for the final "--" pair
            {
                bEndComment = TRUE;
            }
        }
        else
        {
            cb = _tclen(pCurrent);
            cbCur += cb;
            pCurrent += cb;
        }
    }
    if (cbCur < cbLen)
    {
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }

    token.ibTokMac = cbCur;

    // reset state if we reach end of comment
    if (bEndComment)
        *plxs &= ~inComment;

    return cbCur;
}

/////////////////////////////////////////////////////////////
// FindEndEntity()
//
// Find the end of the special character sequence (ends with ; or whitespace).
//
UINT FindEndEntity(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * /*plxs*/, TXTB & token)
{
    token.tokClass = tokEntity;
    int cb = GetTokenLength(pchLine, cbLen, cbCur);
    if (pchLine[cbCur + cb] == ';')
        cb++;
    token.ibTokMac = cbCur + cb;
    return token.ibTokMac;
}

/////////////////////////////////////////////////////////////
// Find an entity reference or non-entity ref, literal "&..."
//
UINT FindEntityRef(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * /*plxs*/, TXTB & token)
{
    ASSERT(cbCur < cbLen);
    ASSERT(pchLine[cbCur] == '&'); // must be on ERO

    cbCur++;
    if (cbCur == cbLen)
    {
NotEntity:
        token.tokClass = tokIDENTIFIER; // plain text
        token.ibTokMac = cbCur;
        return cbCur;
    }

    if (pchLine[cbCur] == '#')
    {
        // parse and check valid number
        if (!IsNumber(pchLine, cbLen, cbCur + 1, token))
            goto NotEntity;

        // must be <= 3 digits
        if (token.ibTokMac - (cbCur + 1) > 3)
            goto NotEntity;

        // validate range
        TCHAR szNum[4];
        _tcsncpy(szNum, &pchLine[cbCur + 1], 3);
        if (_tcstoul(szNum, 0, 10) > 255)
            goto NotEntity;

        // we now have a valid numeric entity ref

        token.tokClass = tokEntity;
        cbCur = token.ibTokMac;

        // scan for end of entity ref

        // scan rest of alphanumeric token
        // REVIEW: Is this correct? IE 4.40.308 behaves this way
        while ((cbCur < cbLen) && IsCharAlphaNumeric(pchLine[cbCur]))
            cbCur++;

        // scan delimiter
        if (cbCur < cbLen)
            cbCur++;
        token.ibTokMac = cbCur;
        return cbCur;
    }
    else if (!IsCharAlpha(pchLine[cbCur]))
    {
        goto NotEntity;
    }
    else
    {
        // parse and check entity name
        UINT nLen = GetTokenLength(pchLine, cbLen, cbCur);
        if (!g_pTable->FindEntity(&pchLine[cbCur], nLen))
            goto NotEntity;

        cbCur += nLen;
        // eat delimiter if necessary
        if ((cbCur < cbLen) &&
            (pchLine[cbCur] == ';' || IsWhiteSpace(pchLine[cbCur])))
            cbCur++;
        token.tokClass = tokEntity;
        token.ibTokMac = cbCur;
        return cbCur;
    }
}


/////////////////////////////////////////////////////////////
// FindEndValue
// Find the end of an unquoted value.
//
// Scan for whitespace or end if tag
//
UINT FindValue(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    ASSERT(cbCur < cbLen);

    do
    {
        cbCur++;
    } while ( cbCur < cbLen &&
        !IsWhiteSpace(pchLine[cbCur]) &&
        pchLine[cbCur] != '>' );

    token.tokClass = tokValue;
    token.ibTokMac = cbCur;

    // switch from value to attribute
    *plxs &= ~inValue;
    *plxs |= inAttribute;

    return cbCur;
}

/////////////////////////////////////////////////////////////
// FindEndString()
// Find the end of the string.
// Should only be called when we are in the string mode already.
//
UINT FindEndString (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int cb;
    BOOL bInString = TRUE;
    TCHAR chDelim;

    ASSERT (*plxs & INSTRING); // must be in a string now

    token.tokClass = tokString;
    chDelim = (*plxs & inStringA) ? _T('\'') : _T('"');

    while (bInString && cbCur < cbLen)
    {
        if (*pCurrent == chDelim)
        {
            *plxs &= ~INSTRING;
            bInString = FALSE;
            SetValueSeen(plxs);
        }
        else if (*pCurrent == _T('<') &&
            cbCur+1 < cbLen &&
            *(pCurrent+1) == _T('%'))
        {
            *plxs |= inHTXTag;
            break;
        }
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }
    token.ibTokMac = cbCur;
    return cbCur;
}

//////////////////////////////////////////////////////////////////
//
UINT FindTagOpen(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    ASSERT(pchLine[cbCur] == '<');
    token.tokClass = tokTag;
    *plxs &= ~inScriptText;     // turn off script coloring when inside tags
    cbCur++;

    if (cbCur == cbLen)
    {
        *plxs |= inTag;
    }
    else
    {
#ifdef NEEDED // copied from htmed\lexer.cpp
        //
        // HTMED CHANGE:
        // REVIEW(cgomes): Figure out if I should turn off inSCRIPT in any of the
        // following cases.  Right now I only do it for the </ case.
        //
#endif //NEEDED         
        switch (pchLine[cbCur])
        {
        case '!': // MDO - Markup Declaration Open
            cbCur++;
            *plxs |= inBangTag;
            token.tok = TokTag_BANG;
            break;

        case '/': // End tag
            cbCur++;
            *plxs |= inEndTag;
            token.tok = TokTag_END;
#ifdef NEEDED // copied from htmed\lexer.cpp
            // HTMED CHANGE:
            // REVIEW(cgomes): Colorizer bug: it never removes the inSCRIPT state
            //  This removes the inSCRIPT in the case <SCRIPT <BODY>
            //  in this case <BODY is in error.
            //
            *plxs &= ~inSCRIPT;
#endif //NEEDED         
            break;

        // REVIEW: PI is SGML -- not in HTML, but might be added
        case '?': // PI - Processing Instruction
            cbCur++;
            *plxs |= inPITag;
            token.tok = TokTag_PI;
            break;

        case '%': // HTX -- ODBC server HTML extension
            cbCur++;
            *plxs |= inHTXTag;
            token.tok = TokTag_SSSOPEN;
            break;

        default: // Tag
            if (IsCharAlpha(pchLine[cbCur]))
            {
                *plxs |= inTag;
                token.tok = TokTag_START;
            }
            else
                token.tokClass = tokIDENTIFIER; // NOT a TAG
            break;
        }
    }
    token.ibTokMac = cbCur;
    return cbCur;
}

//////////////////////////////////////////////////////////////////
//  FindText
//  Scan a token of text
//      NOTE DO NOT MODIFY this function, mainly b/c the side effects
//              will be hard to find, and will break the way
//              that everything works.
//
UINT FindText(LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token)
{
    //BOOL fExtraSpace = FALSE;
    //int cSpace = 0;

    ASSERT (cbCur < cbLen);

    token.tokClass = tokIDENTIFIER;

    //if (pchLine[cbCur] == ' ' && !fExtraSpace)
    //  fExtraSpace = TRUE;
    cbCur += _tclen(&pchLine[cbCur]);
    while (cbCur < cbLen)
    {
        switch (pchLine[cbCur])
        {
        case _T('\0'):
        case _T('\n'):
        case _T('<'):
        case _T('&'):
            //if (cSpace > 0) // found extra spaces so remember them somewhere
            goto ret;
            break;
        //case _T(' '):
        //  if (!fExtraSpace)
        //      fExtraSpace = TRUE;
        //  else
        //      cSpace++;
        //  break;
        default:
            //if (cSpace > 0) // found extra spaces so remember them somewhere
            //cSpace = 0;
            //fExtraSpace = FALSE;
            break;
        }
        cbCur += _tclen(&pchLine[cbCur]);
    }

ret:
    token.ibTokMac = cbCur;
    return cbCur;
}

//////////////////////////////////////////////////////////////////
// FindNextToken()
//  Find the next token in the line
//
UINT FindNextToken(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    ASSERT (cbCur < cbLen);
    HINT hint;

    if (!(*plxs & INTAG)) // scanning text
    {
        if (*plxs & TEXTMASK)
        {
            if (*plxs & inCOMMENT)
                token.tokClass = tokComment;
            else
                token.tokClass = tokIDENTIFIER;
            // probe for end tag </comment>
            UINT cbEnd = FindEndTag(pchLine, cbLen, cbCur, plxs, token);
            if (cbEnd > cbCur) // parsed a nonzero-length token
            {
                return cbEnd;
            }
            //else fall through to normal processing
        }
        hint = GetTextHint(pchLine, cbLen, cbCur, plxs, token);
        switch (hint)
        {
        case HTA:
            // begin a tag
            return FindTagOpen(pchLine, cbLen, cbCur, plxs, token);

        case HEN:
            // scan an entity reference
            token.ibTokMac = FindEntityRef(pchLine, cbLen, cbCur, plxs, token);
            return token.ibTokMac;

        case EOS:
        case ONL:
            return token.ibTokMac;

        case ERR:
        default:
            // scan text as a single token
            // If the editor uses token info for more than coloring
            //   (e.g. extended selections), then this will need to
            //   return smaller chunks.
            if (*plxs & inSCRIPT)
                *plxs |= inScriptText;
            return FindText(pchLine, cbLen, cbCur, token);
            break;
        }

        return cbCur;
    }

    ASSERT(*plxs & INTAG); // must be in a tag here

    BOOL bError = FALSE;
    hint = GetHint(pchLine, cbLen, cbCur, plxs, token);
    switch (hint)
    {
    case HTE:
        // Tag end: remove all tag state bits
        *plxs &= ~TAGMASK;
        cbCur++;
        token.tokClass = tokTag;
        token.tok = TokTag_CLOSE;
        token.ibTokMac = cbCur;
        break;

    case HNU:
#if 0  // lexing HTML instance, not a DTD!
        if (!IsNumber(pchLine, cbLen, cbCur, token))
            bError = TRUE;
        if (SetValueSeen(plxs))
            token.tokClass = tokValue;
        break;
#else
        // fall through
#endif

    case HRN: // reserved name start: #
#if 1  // lexing HTML instance, not a DTD!
        // simple nonwhitespace stream
        if (!(*plxs & inValue))
            bError = TRUE;
        FindValue(pchLine, cbLen, cbCur, plxs, token);
        if (bError)
        {
            token.tokClass = tokSpace;
            bError = FALSE; //"corrected" the error
        }
#else
        cbCur++;
        if (cbCur == cbLen)
            token.tokClass = tokOp;
        else
        {
            if (IsIdChar(pchLine[cbCur]))
            {
                cbCur++;
                while (cbCur < cbLen && IsIdChar(pchLine[cbCur]))
                    cbCur++;
                token.tokClass = tokResName;
            }
            else
                token.tokClass = tokOp;
        }
        token.ibTokMac = cbCur;
        if (SetValueSeen(plxs))
            token.tokClass = tokValue;
#endif
        break;

    case HEP: // parameter entity: %
#if 1  // lexing HTML instance, not a DTD!
        goto BadChar;
#else
        cbCur++;
        if (cbCur == cbLen)
        {
            token.tokClass = tokOp;
            token.ibTokMac = cbCur;
        }
        else
        {
            if (IsIdChar(pchLine[cbCur]))
            {
                token.ibTokMac = FindEndEntity(pchLine, cbLen, cbCur, plxs, token);
                token.tokClass = tokParEnt;
            }
            else
            {
                token.ibTokMac = cbCur;
                token.tokClass = tokOp;
            }
        }
        if (SetValueSeen(plxs))
            token.tokClass = tokValue;
#endif
        break;

    // ported HTMED change (walts) -- handle some chars as valid start char for attribute values.
    case HAV:
        {
        if (!(*plxs & inTag) || !SetValueSeen(plxs))
            goto BadChar;   // not in tag or attribute value.

        int iTokenLength = GetValueTokenLength(pchLine, cbLen, cbCur);
        token.ibTokMac = token.ibTokMin + iTokenLength;
        token.tokClass = tokValue;
        break;
        }
    // ported HTMED change (walts) -- handle some chars as valid start char for attribute values.

    case HKW:  // identifier
        {
            int iTokenLength = GetTokenLength(pchLine, cbLen, cbCur);
            token.ibTokMac = token.ibTokMin + iTokenLength;
            token.tokClass = tokName;
            //FUTURE: Don't scan attributes in an end tag
            if (*plxs & (inTag|inEndTag))
            {
                if (*plxs & inAttribute)
                {
                    IsAttributeName(pchLine, cbCur, iTokenLength, token);
                    // don't change attribute/value state here
                    // we only look for values after we've seen "=" in case OEQ below

                    // REVIEW(cgomes): what if more attributes follow
                    // the SPAN??
                    // if found STARTSPAN then pretend I am not in a tag
                    if(token.tok == TokAttrib_STARTSPAN)
                        *plxs &= ~(inTag | inAttribute);
                    // if found ENDSPAN then goback to comment state
                    else if(token.tok == TokAttrib_ENDSPAN)
                    {
                        *plxs &= ~(inTag | inAttribute);
                        *plxs |= inBangTag | inComment;
                    }
                }
                else if (SetValueSeen(plxs))
                {
                    // REVIEW (walts)
                    // Handle the client side script language detection here for the
                    // following case (language attribute value is NOT wrapped by quotes.)
                    // <SCRIPT LANGUAGE=VBScript>
                    if (*plxs & inSCRIPT)
                    {
                        SetScriptLanguage(&pchLine[cbCur], plxs);
                    }

                    //
                    // REVIEW(cgomes): It seems that any non-white space character
                    //      is valid for non-quoted attribute values.
                    //      Problem is that GetTokenLength is used to determine
                    //      the token length, which works great non-values,
                    //      but pulls egss for values.
                    //      I use GetValueTokenLength here to get the length
                    //      of value token.  GetValueTokenLength will not
                    //      stop till it hits a white space character.
                    //

                    iTokenLength = GetValueTokenLength(pchLine, cbLen, cbCur);
                    token.ibTokMac = token.ibTokMin + iTokenLength;
                    token.tokClass = tokName;

                    token.tokClass = tokValue;
                }
                else
                {
                    IsElementName(pchLine, cbCur, iTokenLength, token);
                    // look for attributes
                    *plxs |= inAttribute;
                    // set content state
                    if (*plxs & inTag)
                        *plxs |= TextStateFromElement(&pchLine[token.ibTokMin], iTokenLength);
                    else if ((*plxs & inEndTag) && (*plxs & TEXTMASK))
                        *plxs &= ~TextStateFromElement(&pchLine[token.ibTokMin], iTokenLength);
                    else if ((*plxs & inEndTag) && (*plxs & inSCRIPT))
                        *plxs &= ~(inSCRIPT | inScriptText | inServerASP/* | inVBScript | inJavaScript*/);
                }
            }
            else if (*plxs & inBangTag)
            {
                // FUTURE: other <!...> items like "HTML", "PUBLIC"? -- nice for DTDs
                //   Use a RW table for it if we do

                // recognize <!DOCTYPE ...>  as 'element'
                if ((iTokenLength == 7) &&
                    (0 == _tcsnicmp(&pchLine[cbCur], _T("doctype"), 7)))
                    token.tokClass = tokElem;
            }
            break;
        }

    case HST:  // string "..."
        *plxs |= inString;
        goto String;

    case HSL:  // string alternate '...'
        *plxs |= inStringA;
String:
        cbCur++;
        token.ibTokMac = FindEndString(pchLine, cbLen, cbCur, plxs, token);
        SetValueSeen(plxs);
        // Handle the client side script language detection here for the
        // following case (language attribute value is wrapped by quotes.)
        // <SCRIPT LANGUAGE="VBScript">
        if((*plxs & inSCRIPT) && (*plxs & inAttribute))
        {
            SetScriptLanguage(&pchLine[cbCur], plxs);
        }
        break;

    case HWS: // tag whitespace
        do
        {
            cbCur++;
        } while (cbCur < cbLen && IsWhiteSpace(pchLine[cbCur]));
        token.tokClass = tokSpace;
        token.ibTokMac = cbCur;
        break;

    case OEQ:
        // GetHint has set token info
        if (*plxs & inAttribute)
        {
            // start looking for values
            *plxs &= ~inAttribute;
            *plxs |= inValue;
        }
        else
            goto BadChar;
        break;

    case HTA:
        if (cbCur+1 < cbLen && '%' == pchLine[cbCur+1])
        {
            SetValueSeen(plxs);
            return FindTagOpen(pchLine, cbLen, cbCur, plxs, token);
        }
        // else fall through
    case ERR:
    case HEN:
BadChar:
        token.tokClass = tokSpace;

        // DS96# 10116 [CFlaat]: we can be in DBCS here, and so we need
        //     to make sure that our increment is double-byte aware
        cbCur += _tcsnbcnt(pchLine + cbCur, 1); // byte count for current char
        ASSERT(cbCur <= cbLen);
        token.ibTokMac = cbCur;
        break;

    // ported HTMED CHANGE (walts) - added this case to handle dbcs attribute values.
    case HDB:
        {
        // DBCS char.  Handle for attribute values within tag.
        if (!SetValueSeen(plxs))
            goto BadChar;

        int iTokenLength = GetValueTokenLength(pchLine, cbLen, cbCur);
        token.ibTokMac = token.ibTokMin + iTokenLength;
        token.tokClass = tokValue;
        }
        break;
    // ported HTMED CHANGE END

    default:
        // GetHint has set token info
        if (token.tokClass != tokComment && (*plxs & inValue))
            FindValue(pchLine, cbLen, cbCur, plxs, token);
        break;
    }
    if (bError)
        IsUnknownID(pchLine, cbLen, cbCur, token);
    return token.ibTokMac;
}

////////////////////////////////////////////////////////////////////
// GetTextHint()
// Like GetHint when scanning text -- look only for tags and entities
//
HINT GetTextHint(LPCTSTR pchLine, UINT /*cbLen*/, UINT cbCur, DWORD * /*plxs*/, TXTB & token)
{
    // if the character is bigger than 128 (dbcs) then return error
    if (pchLine[cbCur] & ~0x7F)
        return HDB;

    HINT hint = g_hintTable[pchLine[cbCur]];

    if (IsSingleOp(hint))
    {
        hint = ERR;
    }
    else if (hint == ONL || hint == EOS)
    {
        token.tokClass = tokOp;
        token.ibTokMac = cbCur + 1;
    }
    return hint;
}

////////////////////////////////////////////////////////////////////
// GetHint()
//      Use hint table to guess what the next token going to be
//      If it is a single operator, it will fill in the token info
//      as well
//
HINT GetHint(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token)
{
    // if the character is bigger than 128 (dbcs) then return error
    if (pchLine[cbCur] & ~0x7F)
        return HDB;

    HINT hint = g_hintTable[pchLine[cbCur]];

    // check if it is a single op, new line or end of stream
    if (IsSingleOp(hint) || hint == ONL || hint == EOS)
    {
        token.tokClass = hint;
        token.ibTokMac = cbCur + 1;
    }
    else if (hint == ODA)
    {
        if ((cbCur + 1 < cbLen) &&
            (g_hintTable[pchLine[cbCur + 1]] == ODA) &&
            (*plxs & inBangTag))
        {
            cbCur += 2;
            *plxs |= inComment;
            COMMENTTYPE ct = IfHackComment(pchLine, cbLen, cbCur, plxs, token);
            if (ct == 0)
            {
                token.tokClass = tokComment;
                token.ibTokMac = cbCur;
            }
            else if(ct == CT_METADATA)
                hint = HTA; // tag open
        }
        else
        {
            // single -
            token.tokClass = tokOp;
            token.ibTokMac = cbCur + 1;
        }
    }
    return hint;
}

///////////////////////////////////////////////////////////////////
// GetTokenLength ()
//  return the length of a token identifier/keyword
//
UINT GetTokenLength(LPCTSTR pchLine, UINT cbLen, UINT cbCur)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    UINT cb;
    UINT cbOld = cbCur;

    if (IsCharAlphaNumeric(*pCurrent))
    {
        while (cbCur < cbLen && IsIdChar(*pCurrent))
        {
            cb = _tclen(pCurrent);
            cbCur += cb;
            pCurrent += cb;
        }
    }
    return (int) max((cbCur - cbOld), 1);
}

/*

    UINT GetValueTokenLength

    Description:
        Gets the length of the token.
        This version will accept any non whitespace character
        in the token.

*/
UINT GetValueTokenLength(LPCTSTR pchLine, UINT cbLen, UINT cbCur)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    UINT cb;
    UINT cbOld = cbCur;

    while (cbCur < cbLen && !_istspace(*pCurrent) && IsValueChar(*pCurrent))
    {
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }
    return (int) max((cbCur - cbOld), 1);
}


////////////////////////////////////////////////////////////////
// IsElementName ()
//  lookup the keyword table to determine if it is a keyword or not
//
BOOL IsElementName(LPCTSTR pchLine, UINT cbCur, int iTokenLength, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int iFound = NOT_FOUND;

    if (NOT_FOUND != (iFound = g_pTable->FindElement(pCurrent, iTokenLength)))
    {
        token.tokClass = tokElem;
        token.ibTokMac = cbCur + iTokenLength;
        token.tok = iFound; // set token
    }
    return (iFound != NOT_FOUND);
}

int IndexFromElementName(LPCTSTR pszName)
{
    return g_pTable->FindElement(pszName, lstrlen(pszName));
}

////////////////////////////////////////////////////////////////
// IsAttributeName ()
// lookup the keyword table to determine if it is a keyword or not
//
BOOL IsAttributeName(LPCTSTR pchLine, UINT cbCur, int iTokenLength, TXTB & token)
{
    LPCTSTR pCurrent = &pchLine[cbCur];
    int iFound = NOT_FOUND;

    if (NOT_FOUND != (iFound = g_pTable->FindAttribute(pCurrent, iTokenLength)))
    {
        token.tokClass = tokAttr;
        // ENDSPAN__ is needed b/c the lexer does not recognize the
        // endspan-- as 2 seperate tokens.
        if(iFound == TokAttrib_ENDSPAN__)
        {
            // endspan-- found.  return TokAttrib_ENDSPAN
            // set ibTokMac to not include --.
            token.tok = TokAttrib_ENDSPAN;
            token.ibTokMac = cbCur + iTokenLength - 2;
        }
        else
        {
            token.ibTokMac = cbCur + iTokenLength;
            token.tok =  iFound; // set token
        }
    }
    return (iFound != NOT_FOUND);
}

//////////////////////////////////////////////////////////////////////////
// IsIdentifier()
// check if it is an identifier
//
BOOL IsIdentifier (int iTokenLength, TXTB & token)
{
    if (iTokenLength > 0)
    {
        token.tokClass = tokName;
        token.ibTokMac = token.ibTokMin + iTokenLength;
        return TRUE;
    }
    else
        return FALSE;
}

////////////////////////////////////////////////////////////////////
// IsUnknownID ()
//  Mark the next token as an ID
//
BOOL IsUnknownID (LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token)
{
    ASSERT(cbCur < cbLen);
    UINT cb;
    LPCTSTR pCurrent = &pchLine[cbCur];

    cb = _tclen(pCurrent);
    cbCur += cb;
    pCurrent += cb;

    while ((cbCur < cbLen) && IsIdChar(*pCurrent))
    {
        cb = _tclen(pCurrent);
        cbCur += cb;
        pCurrent += cb;
    }

    token.tokClass = tokSpace;
    token.ibTokMac = cbCur;
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// IsNumber()
//  Check whether the next token is an SGML NUMTOKEN
//
BOOL IsNumber(LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token)
{
    if (cbCur >= cbLen)
        return FALSE;

    if (!_istdigit(pchLine[cbCur]))
        return FALSE;

    token.tokClass = tokNum;

    // assume all digits are one byte
    ASSERT(1 == _tclen(&pchLine[cbCur]));
    cbCur++;

    while (cbCur < cbLen && _istdigit(pchLine[cbCur]))
    {
        // assume all digits are one byte
        ASSERT(1 == _tclen(&pchLine[cbCur]));
        cbCur++;
    }

    token.ibTokMac = cbCur;
    return TRUE;
}



/* end of file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\lexhtml.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __LEXHTML__
#define __LEXHTML__

#include "lex.h"
#include "tokhtml.h"

#define DS_HTML_IE3         _T("HTML - IE 3.0")
#define DS_HTML_RFC1866     _T("HTML 2.0 (RFC 1866)")


// token hints
#define BASED_HINT  0x9000
#define ERR         BASED_HINT +  0  // error
#define HWS         BASED_HINT +  1  // white space
#define HST         BASED_HINT +  2  // string "..."
#define HSL         BASED_HINT +  3  // string alternate '...'
#define HNU         BASED_HINT +  5  // number
#define HKW         BASED_HINT +  6  // keyword
#define HEN         BASED_HINT +  7  // entity &...;
#define HRN         BASED_HINT +  8  // reserved name #...
#define HEP         BASED_HINT +  9  // parameter entity %...;
#define HTA         BASED_HINT + 10  // tag open <
#define HTE         BASED_HINT + 11  // tag end >
#define HDB         BASED_HINT + 12  // dbcs (> 128).   HTMED CHANGE (walts)
#define HAV         BASED_HINT + 13  // valid attr value start char     HTMED CHANGE (walts)

// strictly single ops
#define ODA tokOpDash
#define OCO tokOpComma
#define OPI tokOpPipe
#define OPL tokOpPlus
#define OEQ tokOpEqual
#define OST tokOpStar
#define OLP tokOpLP
#define ORP tokOpRP
#define OLB tokOpLB
#define ORB tokOpRB
#define OQU tokOpQuestion
#define OLC tokDELI_LCBKT   
#define ORC tokDELI_RCBKT   
#define ONL tokNEWLINE
#define EOS tokEOF

typedef unsigned short HINT;

typedef BYTE RWATT_T;
//
// Reserved Word Attributes - HTML variant
//
enum RWATT
{
    HTML2 = 0x01,  // RFC 1866
//  IEXP2 = 0x02,  // Internet Explorer 2.0
    IEXP3 = 0x04,  // Internet Explorer 3.0
    ALL   = 0xff,  // all browsers
};
#define IEXPn (IEXP3)
#define IE40  (ALL)

typedef struct ReservedWord
{
    TCHAR *     psz;        // pointer to reserved word string 
    BYTE        cb;         // length of reserved word
    RWATT_T     att;        // attributes
} ReservedWord;

#endif // __LEXHTML__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\lexer.h ===
/* copied from ..\htmed\lexer.cpp */
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

/*++

  Copyright (c) 1995 Microsoft Corporation

  File: lexer.h

  Abstract:
        Nitty gritty lexer stuff

  Contents:

  History:
      2/14/97   cgomes:   Created


--*/
#if !defined __INC_LEXER_H__
#define __INC_LEXER_H__

#include "token.h"

extern CTableSet*   g_ptabASP;
extern PSUBLANG     g_psublangASP;
extern PTABLESET    g_arpTables[CV_MAX+1];

typedef enum tag_COMMENTTYPE
{
    CT_NORMAL       = 0,
    CT_METADATA     = -1,
    CT_IECOMMENT    = 1
} COMMENTTYPE;

HINT GetHint         (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
HINT GetTextHint     (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT GetToken        (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT GetTokenLength  (LPCTSTR pchLine, UINT cbLen, UINT cbCur);
UINT FindEndEntity   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
COMMENTTYPE IfHackComment   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindEntityRef   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindEndComment  (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindServerScript(LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindValue       (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindEndString   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindNextToken   (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindTagOpen     (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindEndTag      (LPCTSTR pchLine, UINT cbLen, UINT cbCur, DWORD * plxs, TXTB & token);
UINT FindText        (LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token);
BOOL IsUnknownID     (LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token);
BOOL IsNumber        (LPCTSTR pchLine, UINT cbLen, UINT cbCur, TXTB & token);
BOOL IsElementName   (LPCTSTR pchLine, UINT cbCur, int cbTokLen, TXTB & token);
BOOL IsAttributeName (LPCTSTR pchLine, UINT cbCur, int cbTokLen, TXTB & token);
BOOL IsIdentifier(int iTokenLength, TXTB & token);
int  IndexFromElementName(LPCTSTR pszName);


CTableSet * MakeTableSet(CTableSet ** rgpts, RWATT_T att, UINT nIdName);
void SetLanguage(TCHAR * /*const CString & */strDefault, PSUBLANG rgSublang,
                 PTABLESET pTab, UINT & index, UINT nIdTemplate, CLSID clsid);
CTableSet * FindTable(CTableSet ** rgpts, /*const CString & */TCHAR *strName);
CTableSet * FindTable(CTableSet ** rgpts, CTableSet * pts);


#endif /* __INC_LEXER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\privcid.h ===
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __privcid_h__
#define __privcid_h__


#include <mshtmcid.h>

//----------------------------------------------------------------------------
//
// Private Command IDs.
//
//----------------------------------------------------------------------------

#define IDM_TABKEY                  6000
#define IDM_SHTABKEY                6001
#define IDM_RETURNKEY               6002
#define IDM_ESCKEY                  6003

#if DBG == 1
#define IDM_DEBUG_TRACETAGS         6004
#define IDM_DEBUG_RESFAIL           6005
#define IDM_DEBUG_DUMPOTRACK        6006
#define IDM_DEBUG_BREAK             6007
#define IDM_DEBUG_VIEW              6008
#define IDM_DEBUG_DUMPTREE          6009
#define IDM_DEBUG_DUMPLINES         6010
#define IDM_DEBUG_LOADHTML          6011
#define IDM_DEBUG_SAVEHTML          6012
#define IDM_DEBUG_MEMMON            6013
#endif

// IE4 Shdocvw Messages

#define IDM_SHDV_FINALTITLEAVAIL         6020
#define IDM_SHDV_MIMECSETMENUOPEN        6021
#define IDM_SHDV_PRINTFRAME              6022
#define IDM_SHDV_PUTOFFLINE              6022
#define IDM_SHDV_GOBACK                  6024   // different from IDM_GOBACK
#define IDM_SHDV_GOFORWARD               6025   // different from ISM_GOFORWARD
#define IDM_SHDV_CANGOBACK               6026
#define IDM_SHDV_CANGOFORWARD            6027
#define IDM_SHDV_CANSUPPORTPICS          6028
#define IDM_SHDV_CANDEACTIVATENOW        6029
#define IDM_SHDV_DEACTIVATEMENOW         6030
#define IDM_SHDV_NODEACTIVATENOW         6031
#define IDM_SHDV_SETPENDINGURL           6032
#define IDM_SHDV_ISDRAGSOURCE            6033
#define IDM_SHDV_DOCFAMILYCHARSET        6034
#define IDM_SHDV_DOCCHARSET              6035
#define IDM_SHDV_GETMIMECSETMENU         6036
#define IDM_SHDV_GETFRAMEZONE            6037

// Flavors of refresh

#define IDM_REFRESH_TOP                  6041   // Normal refresh, topmost doc
#define IDM_REFRESH_THIS                 6042   // Normal refresh, nearest doc
#define IDM_REFRESH_TOP_FULL             6043   // Full refresh, topmost doc
#define IDM_REFRESH_THIS_FULL            6044   // Full refresh, nearest doc

#define IDM_DEFAULTBLOCK                 6046

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
// Used by triedit.rc
//
#define IDS_PROJNAME                    100
#define IDR_TRIEDITDOCUMENT             101
#define IDR_FEEDBACKRECTBMP             102
#define IDS_HTML                        101
#define IDS_IEXP3                       103
#define IDR_HTML                        104
#define IDS_RFC1866                     105
#define IDR_ASP                         106
#define IDR_HTMPARSE                    107
#define IDR_TRIEDITPARSE                107

#define IDS_GLYPHTABLE1                 201
#define IDS_GLYPHTABLE2                 202
#define IDS_GLYPHTABLE3                 203
#define IDS_GLYPHTABLE4                 204
#define IDS_GLYPHTABLE5                 205
#define IDS_GLYPHTABLE6                 206
#define IDS_GLYPHTABLE7                 207
#define IDS_GLYPHTABLE8                 208
#define IDS_GLYPHTABLE9                 209
#define IDS_GLYPHTABLE10                210
#define IDS_GLYPHTABLE11                211
#define IDS_GLYPHTABLE12                212
#define IDS_GLYPHTABLE13                213
#define IDS_GLYPHTABLE14                214
#define IDS_GLYPHTABLE15                215
#define IDS_GLYPHTABLE16                216
#define IDS_GLYPHTABLE17                217
#define IDS_GLYPHTABLE18                218
#define IDS_GLYPHTABLE19                219
#define IDS_GLYPHTABLE20                220
#define IDS_GLYPHTABLE21                221
#define IDS_GLYPHTABLE22                222
#define IDS_GLYPHTABLE23                223
#define IDS_GLYPHTABLE24                224

#define IDS_GLYPHTABLESTART             IDS_GLYPHTABLE1
#define IDS_GLYPHTABLEFORMEND           IDS_GLYPHTABLE2
#define IDS_GLYPHTABLEEND               IDS_GLYPHTABLE24

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           150
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#if !defined(AFX_STDAFX_H__438DA5D5_F171_11D0_984E_0000F80270F8__INCLUDED_)
#define AFX_STDAFX_H__438DA5D5_F171_11D0_984E_0000F80270F8__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_STATIC_REGISTRY

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#pragma warning(disable: 4505)	// unreferenced local function has been removed

#include <windows.h>

// Note that this include MUST be at this location (after the above include)
#include "win95wrp.h"

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#pragma warning(disable: 4100 4189 4244)	// Necessary for ia64 build
#include <atlcom.h>
#include <atlwin.h>
#pragma warning(default: 4100 4189 4244)	// Necessary for ia64 build

#include <mshtml.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__438DA5D5_F171_11D0_984E_0000F80270F8__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\table.cpp ===
// table.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
// HTML keyword tables
// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.


#include "stdafx.h"

#include "resource.h"
#include "guids.h"
#include "table.h"

#undef ASSERT
#define ASSERT(b) _ASSERTE(b)

// qsort/bsearch helper
int CmpFunc(const void *a, const void *b);

static const TCHAR szFileSig[] = _T("@HLX@");
static const TCHAR szElTag[]   = _T("[Elements]");
static const TCHAR szAttTag[]  = _T("[Attributes]");
static const TCHAR szEntTag[]  = _T("[Entities]");

////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
//
// table verification routines
//
int CheckWordTable(ReservedWord *arw, int cel, LPCTSTR szName /*= NULL*/)
{
	int cerr = 0;
	int cch;
	for (int i = 0; i < cel; i++)
	{
		// table must be sorted in ascending alpha order
		//
		if (i > 1)
		{
			if (!(_tcscmp(arw[i-1].psz, arw[i].psz) < 0))
			{
				ATLTRACE(_T("lexer:entries in %s out of order at %d: %s - %s\n"),
					szName?szName:_T("?"), i-1, arw[i-1].psz, arw[i].psz);
				cerr++;
			}
		}

		// length must match
		//
		cch = _tcslen(arw[i].psz);
		if (cch != arw[i].cb)
		{
			ATLTRACE(_T("lexer:Incorrect entry in %s: %s,%d should be %d\n"),
				szName?szName:_T("?"), arw[i].psz, arw[i].cb, cch);
			cerr++;
		}
	}
	return cerr;
}

int CheckWordTableIndex(ReservedWord *arw, int cel, int *ai, BOOL bCase /*= FALSE*/, LPCTSTR szName /* = NULL*/)
{
	int cerr = 0;
	int index;
	int max = bCase ? 52 : 26;

	_ASSERTE(NULL != arw);
	_ASSERTE(NULL != ai);

	int aik[] =
	{
		//A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
		  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
		//a b c d e f g h i j k l m n o p q r s t u v w x y z
		  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	};

	// Build correct index array on static aik
	cerr += MakeIndexHere( arw, cel, aik, bCase );

	// Compare with declared arrray
	//
	if (0 != memcmp(aik, ai, max))
		cerr++;

	// If errors, dump correct array
	if (cerr)
	{
		ATLTRACE(_T("lexer: Correct index array for %s: \n{\n\t"), szName ? szName : _T("?"));
		for (index = 0; index < max - 1; index++)
		{
			ATLTRACE(_T("%3d,"), aik[index]);
			if (index % 13 == 12)
				ATLTRACE(_T("\n\t"));
		}
		ATLTRACE(_T("%3d\n};\n"), aik[index]);
	}
	return cerr;
}
#endif

int MakeIndexHere(ReservedWord *arw, int cel, int *ab, BOOL bCase /*= FALSE*/, LPCTSTR szName /*= NULL*/)
{
	int cerr = 0;
	int index;

	ASSERT(ab != NULL);
	ASSERT(arw != NULL);

	for (int irw = cel - 1; irw > 0; irw--)
	{
		index = PeekIndex(*arw[irw].psz, bCase);
		if (-1 != index)
			ab[index] = irw;
		else
		{
			ATLTRACE(_T("lexer:error in %s: non-alpha token %s\n"), szName?szName:_T("?"), arw[irw].psz);
			cerr++;
		}
	}
	return cerr;
}

int MakeIndex(ReservedWord *arw, int cel, int **pab, BOOL bCase /*= FALSE*/, LPCTSTR szName /*= NULL*/)
{
	ASSERT(NULL != arw);
	ASSERT(NULL != pab);
	*pab = new int[ bCase ? 52 : 26 ];
	if (NULL == *pab)
		return -1;
	return MakeIndexHere(arw, cel, *pab, bCase, szName);
}

#define RW_Entry(string, attribute) \
	_T( #string ), sizeof( #string ) - 1, attribute

////////////////////////////////////////////////////////////////////////////
// reserved word table
// Two tables:
//   reserved[] = sorted table of reserved words
//   index[initial(token)] = (index of first reserved word with that initial)
// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
//
// NOTE: the "HPn" elements are considered obsolete
//
static ReservedWord _rgElementNames[] =
{// psz             cb      att
	_T(""),	0, 0,
	RW_Entry(A 				,ALL	),
	RW_Entry(ADDRESS 		,ALL	),
	RW_Entry(APPLET 		,IEXPn	), // ???
	RW_Entry(AREA 			,IEXPn	),
	RW_Entry(B 				,ALL	),
	RW_Entry(BASE 			,ALL	),
	RW_Entry(BASEFONT 		,IEXPn	),
	RW_Entry(BGSOUND 		,IEXPn	), // IExplore
  	RW_Entry(BIG 			,IEXP3	),
	RW_Entry(BLINK 			,IEXPn	), // Netscape
	RW_Entry(BLOCKQUOTE 	,ALL	),
	RW_Entry(BODY 			,ALL	),
	RW_Entry(BR 			,ALL	),
	RW_Entry(BUTTON 		,IE40	),
	RW_Entry(CAPTION 		,IEXPn	), // tables
	RW_Entry(CENTER 		,IEXPn	),
	RW_Entry(CITE 			,ALL	),
	RW_Entry(CODE 			,ALL	),
	RW_Entry(COL 			,IEXP3	),
	RW_Entry(COLGROUP 		,IEXP3	), // HTML 3 tables?
	RW_Entry(COMMENT 		,ALL	), // considered obsolete
	RW_Entry(DD 			,ALL	),
	RW_Entry(DFN 			,ALL	), // RFC1866: not in the RFC, but deployed. ital or bold ital
	RW_Entry(DIR 			,ALL	),
	RW_Entry(DIV 			,IEXP3	),     // HTML 3
	RW_Entry(DL 			,ALL	),
	RW_Entry(DT 			,ALL	),
	RW_Entry(EM 			,ALL	),
	RW_Entry(EMBED 			,IEXP3	), // netscape -- IEXP3
	RW_Entry(FIELDSET 		,IE40	),
	RW_Entry(FONT 			,IEXPn	),
	RW_Entry(FORM 			,ALL	),   // forms
	RW_Entry(FRAME 			,IEXP3	), // framesets
	RW_Entry(FRAMESET 		,IEXP3	), // framesets
	RW_Entry(H1 			,ALL	), // heading 1
	RW_Entry(H2 			,ALL	), // heading 2
	RW_Entry(H3 			,ALL	), // heading 3
	RW_Entry(H4 			,ALL	), // heading 4
	RW_Entry(H5 			,ALL	), // heading 5
	RW_Entry(H6 			,ALL	), // heading 6
	RW_Entry(HEAD 			,ALL	), // document head
	RW_Entry(HR 			,ALL	),
	RW_Entry(HTML 			,ALL	),
	RW_Entry(I 				,ALL	),
	RW_Entry(IFRAME 		,IEXP3	),	// inline frames
	RW_Entry(IMG 			,ALL	),
	RW_Entry(INPUT 			,ALL	), // forms
	RW_Entry(ISINDEX 		,ALL	),
	RW_Entry(KBD 			,ALL	),
	RW_Entry(LABEL 			,IE40	),
	RW_Entry(LEGEND 		,IE40	),
	RW_Entry(LI 			,ALL	),
	RW_Entry(LINK 			,ALL	),
	RW_Entry(LISTING 		,ALL	), // RFC 1866: obsolete
	RW_Entry(MAP 			,IEXPn	),
	RW_Entry(MARQUEE 		,IEXPn	), // IExplore
	RW_Entry(MENU 			,ALL	),
	RW_Entry(META 			,ALL	),
	RW_Entry(METADATA 		,ALL	),
	RW_Entry(NOBR 			,IEXPn	),
	RW_Entry(NOFRAMES 		,IEXP3	), // framesets
	RW_Entry(NOSCRIPT 		,IE40	), // IE4 only
	RW_Entry(OBJECT 		,IEXP3	), // ActiveX
	RW_Entry(OL 			,ALL	),
	RW_Entry(OPTION 		,ALL	),   // forms
	RW_Entry(P 				,ALL	),
	RW_Entry(PARAM 			,IEXP3	), // ActiveX
	RW_Entry(PLAINTEXT 		,ALL	),   // RFC 1866: deprecated, noted as obsolete
	RW_Entry(PRE 			,ALL	),
	RW_Entry(S 				,IEXPn	), // (apparently) synonym for strike
	RW_Entry(SAMP 			,ALL	),
	RW_Entry(SCRIPT 		,IEXP3	), // ActiveX
	RW_Entry(SELECT 		,ALL	),
	RW_Entry(SMALL 			,IEXP3	),
	RW_Entry(SPAN 			,IEXP3	), // tables
	RW_Entry(STRIKE 		,IEXPn	), // not in RFC 1866 DTD, but noted as deployed
	RW_Entry(STRONG 		,ALL	),
    RW_Entry(STYLE 			,IEXP3	), // HTML 3 stylesheets
	RW_Entry(SUB 			,IEXP3	), // HTML3 ???
	RW_Entry(SUP 			,IEXP3	), // HTML3 ???
	RW_Entry(TABLE 			,IEXPn	), // tables
	RW_Entry(TBODY 			,IEXP3	), // HTML 3 tables
	RW_Entry(TD 			,IEXPn	), // tables
	RW_Entry(TEXTAREA 		,ALL	),   // forms
	RW_Entry(TFOOT 			,IEXP3	), // HTML 3 tables
	RW_Entry(TH 			,IEXPn	), // tables
	RW_Entry(THEAD 			,IEXP3	), // HTML 3 tables
	RW_Entry(TITLE 			,ALL	),
	RW_Entry(TR 			,IEXPn	), // tables
	RW_Entry(TT 			,ALL	),
	RW_Entry(U 				,ALL	),   // not in RFC 1866 DTD, but noted as deployed
	RW_Entry(UL 			,ALL	),
	RW_Entry(VAR 			,ALL	),
	RW_Entry(WBR 			,IEXPn	),
	RW_Entry(XMP 			,ALL	),   // deprecated by RFC 1866
};

// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
// The following array is a mapping of each letter to a position in the
// table where tokens starting with that letter begin.
//
static int _rgIndexElementNames[] = // [Elements]
{
	/* A */ TokElem_A			,
	/* B */ TokElem_B			,
	/* C */	TokElem_CAPTION		,
	/* D */	TokElem_DD			,
	/* E */	TokElem_EM			,
	/* F */	TokElem_FIELDSET	,
	/* G */	0					,
	/* H */	TokElem_H1			,
	/* I */	TokElem_I			,
	/* J */	0					,
	/* K */	TokElem_KBD			,
	/* L */	TokElem_LABEL		,
	/* M */	TokElem_MAP			,
	/* N */	TokElem_NOBR		,
	/* O */	TokElem_OBJECT		,
	/* P */	TokElem_P			,
	/* Q */	0					,
	/* R */	0					,
	/* S */	TokElem_S			,
	/* T */	TokElem_TABLE		,
	/* U */	TokElem_U			,
	/* V */	TokElem_VAR			,
	/* W */	TokElem_WBR			,
	/* X */	TokElem_XMP			,
	/* Y */	0					,
	/* Z */	0
};

// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.

//
// attribute name table
//
static ReservedWord _rgAttributeNames[] =
{// psz                 cb   att
	_T(""), 0, 0,
	RW_Entry(ACCESSKEY					,IEXP3	),
	RW_Entry(ACTION						,ALL	),
	RW_Entry(ALIGN						,ALL	),
	RW_Entry(ALINK						,IEXPn	),
	RW_Entry(ALT						,ALL	),
	RW_Entry(APPNAME					,IE40	),
	RW_Entry(APPVERSION					,IE40	),
	RW_Entry(BACKGROUND					,IEXPn	),
	RW_Entry(BACKGROUNDATTACHMENT		,IE40	),
	RW_Entry(BACKGROUNDCOLOR			,IE40	),
	RW_Entry(BACKGROUNDIMAGE			,IE40	),
	RW_Entry(BACKGROUNDPOSITION			,IE40	),
	RW_Entry(BACKGROUNDPOSITIONX		,IE40	),
	RW_Entry(BACKGROUNDPOSITIONY		,IE40	),
	RW_Entry(BACKGROUNDREPEAT			,IE40	),
	RW_Entry(BALANCE					,IE40	),
	RW_Entry(BEHAVIOR					,IEXPn	), // MARQUEE
	RW_Entry(BGCOLOR					,IEXPn	),
	RW_Entry(BGPROPERTIES				,IEXPn	),
	RW_Entry(BORDER						,IEXPn	),
	RW_Entry(BORDERBOTTOM				,IE40	),
	RW_Entry(BORDERBOTTOMCOLOR			,IE40	),
	RW_Entry(BORDERBOTTOMSTYLE			,IE40	),
	RW_Entry(BORDERBOTTOMWIDTH			,IE40	),
	RW_Entry(BORDERCOLOR				,IEXPn	), // tables
	RW_Entry(BORDERCOLORDARK			,IEXPn	), // tables
	RW_Entry(BORDERCOLORLIGHT			,IEXPn	), // tables
	RW_Entry(BORDERLEFT					,IE40	),
	RW_Entry(BORDERLEFTCOLOR			,IE40	),
	RW_Entry(BORDERLEFTSTYLE			,IE40	),
	RW_Entry(BORDERLEFTWIDTH			,IE40	),
	RW_Entry(BORDERRIGHT				,IE40	),
	RW_Entry(BORDERRIGHTCOLOR			,IE40	),
	RW_Entry(BORDERRIGHTSTYLE			,IE40	),
	RW_Entry(BORDERRIGHTWIDTH			,IE40	),
	RW_Entry(BORDERSTYLE				,IE40	),
	RW_Entry(BORDERTOP					,IE40	),
	RW_Entry(BORDERTOPCOLOR				,IE40	),
	RW_Entry(BORDERTOPSTYLE				,IE40	),
	RW_Entry(BORDERTOPWIDTH				,IE40	),
	RW_Entry(BORDERWIDTH				,IE40	),
	RW_Entry(BOTTOMMARGIN				,IEXPn	),
	RW_Entry(BREAKPOINT					,IEXPn	), // (walts) hidden META tag attribute for brkpt mapping.
	RW_Entry(BUFFERDEPTH				,IE40	),
	RW_Entry(BUTTON						,IE40	),
	RW_Entry(CANCELBUBBLE				,IE40	),
	RW_Entry(CELLPADDING				,IEXPn	), // tables
	RW_Entry(CELLSPACING				,IEXPn	), // tables
	RW_Entry(CENTER						,IEXPn	),
	RW_Entry(CHARSET					,IE40	),
	RW_Entry(CHECKED					,ALL	),
	RW_Entry(CLASS						,IEXPn	),
	RW_Entry(CLASSID					,IEXP3	), //objects
	RW_Entry(CLASSNAME					,IE40	),
	RW_Entry(CLEAR						,IEXP3	),
	RW_Entry(CLIP						,IE40	),
	RW_Entry(CODE						,IEXPn	),
	RW_Entry(CODEBASE					,IEXP3	), //objects
	RW_Entry(CODETYPE					,IE40	),
	RW_Entry(COLOR						,IEXPn	), // font
	RW_Entry(COLORDEPTH					,IE40	),
	RW_Entry(COLS						,ALL	),
	RW_Entry(COLSPAN					,IEXPn	), // tables
	RW_Entry(COMPACT					,ALL	),
	RW_Entry(COMPLETE					,IE40	),
	RW_Entry(CONTENT					,ALL	),
	RW_Entry(CONTROLS					,IEXPn	),
	RW_Entry(COOKIE						,IE40	),
	RW_Entry(COOKIEENABLED				,IE40	),
	RW_Entry(COORDS						,IEXPn	),
	RW_Entry(CSSTEXT					,IE40	),
	RW_Entry(CTRLKEY					,IE40	),
	RW_Entry(CURSOR						,IE40	),
	RW_Entry(DATA						,IEXP3	), //objects
	RW_Entry(DATAFLD					,IE40	),
	RW_Entry(DATAFORMATAS				,IE40	),
	RW_Entry(DATAPAGESIZE				,IE40	),
	RW_Entry(DATASRC					,IE40	),
	RW_Entry(DECLARE					,IEXP3	), //objects
	RW_Entry(DEFAULTCHECKED				,IE40	),
	RW_Entry(DEFAULTSELECTED			,IE40	),
	RW_Entry(DEFAULTSTATUS				,IE40	),
	RW_Entry(DEFAULTVALUE				,IE40	),
	RW_Entry(DIALOGARGUMENTS			,IE40	),
	RW_Entry(DIALOGHEIGHT				,IE40	),
	RW_Entry(DIALOGLEFT					,IE40	),
	RW_Entry(DIALOGTOP					,IE40	),
	RW_Entry(DIALOGWIDTH				,IE40	),
	RW_Entry(DIR						,IEXP3	), // HTML 3 ???
	RW_Entry(DIRECTION					,IEXPn	), // MARQUEE
	RW_Entry(DISABLED					,IE40	),
	RW_Entry(DISPLAY					,IE40	),
	RW_Entry(DOMAIN						,IE40	),
	RW_Entry(DYNSRC						,IEXPn	),
	RW_Entry(ENCODING					,IE40	),
	RW_Entry(ENCTYPE					,ALL	),
	RW_Entry(ENDSPAN					,IE40	),	// Designer control tags
	RW_Entry(ENDSPAN--					,IE40	),	// Designer control tags HACK to handle nonspace
	RW_Entry(EVENT						,IEXP3	), // ActiveX <SCRIPT>
	RW_Entry(FACE						,IEXPn	), // font
	RW_Entry(FGCOLOR					,IE40	),
	RW_Entry(FILTER						,IE40	),
	RW_Entry(FONT						,IE40	),
	RW_Entry(FONTFAMILY					,IE40	),
	RW_Entry(FONTSIZE					,IE40	),
	RW_Entry(FONTSTYLE					,IE40	),
	RW_Entry(FONTVARIANT				,IE40	),
	RW_Entry(FONTWEIGHT					,IE40	),
	RW_Entry(FOR						,IEXP3	), // ActiveX <SCRIPT>
	RW_Entry(FORM						,IE40	),
	RW_Entry(FRAME						,IE40	),
	RW_Entry(FRAMEBORDER				,IEXP3	),
	RW_Entry(FRAMESPACING				,IEXP3	),
	RW_Entry(FROMELEMENT				,IE40	),
	RW_Entry(HASH						,IE40	),
	RW_Entry(HEIGHT						,IEXPn	),
	RW_Entry(HIDDEN						,IE40	),
	RW_Entry(HOST						,IE40	),
	RW_Entry(HOSTNAME					,IE40	),
	RW_Entry(HREF						,ALL	),
	RW_Entry(HSPACE						,IEXPn	),
	RW_Entry(HTMLFOR					,IE40	),
	RW_Entry(HTMLTEXT					,IE40	),
	RW_Entry(HTTP-EQUIV					,ALL	),
	RW_Entry(HTTPEQUIV					,IE40	),
	RW_Entry(ID							,IEXPn	),
	RW_Entry(IN							,IEXP3	), // ActiveX <SCRIPT>
	RW_Entry(INDETERMINATE				,IE40	),
	RW_Entry(INDEX						,IE40	),
	RW_Entry(ISMAP						,ALL	),
	RW_Entry(LANG						,IEXPn	),
	RW_Entry(LANGUAGE					,IEXP3	),
	RW_Entry(LEFTMARGIN					,IEXPn	),
	RW_Entry(LENGTH						,IE40	),
	RW_Entry(LETTERSPACING				,IE40	),
	RW_Entry(LINEHEIGHT					,IE40	),
	RW_Entry(LINK						,IEXPn	),
	RW_Entry(LINKCOLOR					,IE40	),
	RW_Entry(LISTSTYLE					,IE40	),
	RW_Entry(LISTSTYLEIMAGE				,IE40	),
	RW_Entry(LISTSTYLEPOSITION			,IE40	),
	RW_Entry(LISTSTYLETYPE				,IE40	),
	RW_Entry(LOCATION					,IE40	),
	RW_Entry(LOOP						,IEXPn	),
	RW_Entry(LOWSRC						,IE40	),
	RW_Entry(MAP						,IE40	),
	RW_Entry(MARGIN						,IE40	),
	RW_Entry(MARGINBOTTOM				,IE40	),
	RW_Entry(MARGINHEIGHT				,IEXP3	),
	RW_Entry(MARGINLEFT					,IE40	),
	RW_Entry(MARGINRIGHT				,IE40	),
	RW_Entry(MARGINTOP					,IE40	),
	RW_Entry(MARGINWIDTH				,IEXP3	),
	RW_Entry(MAXLENGTH					,ALL	),
	RW_Entry(METHOD						,ALL	),
	RW_Entry(METHODS					,ALL	),
	RW_Entry(MIMETYPES					,IE40	),
	RW_Entry(MULTIPLE					,ALL	),
	RW_Entry(NAME						,ALL	),
	RW_Entry(NOHREF						,IEXPn	),
	RW_Entry(NORESIZE					,IEXP3	),
	RW_Entry(NOSHADE					,IEXP3	), // not implemented by IExplore 2
	RW_Entry(NOWRAP						,IEXPn	),
	RW_Entry(OBJECT						,IEXP3	), // <PARAM>
	RW_Entry(OFFSCREENBUFFERING			,IE40	),
	RW_Entry(OFFSETHEIGHT				,IE40	),
	RW_Entry(OFFSETLEFT					,IE40	),
	RW_Entry(OFFSETPARENT				,IE40	),
	RW_Entry(OFFSETTOP					,IE40	),
	RW_Entry(OFFSETWIDTH				,IE40	),
	RW_Entry(OFFSETX					,IE40	),
	RW_Entry(OFFSETY					,IE40	),
	RW_Entry(ONABORT					,IE40	),
	RW_Entry(ONAFTERUPDATE				,IE40	),
	RW_Entry(ONBEFOREUNLOAD				,IE40	),
	RW_Entry(ONBEFOREUPDATE				,IE40	),
	RW_Entry(ONBLUR						,IEXP3	), // SELECT, INPUT, TEXTAREA
	RW_Entry(ONBOUNCE					,IE40	),
	RW_Entry(ONCHANGE					,IEXP3	), // SELECT, INPUT, TEXTAREA
	RW_Entry(ONCLICK					,IEXP3	), // INPUT, A, <more>
	RW_Entry(ONDATAAVAILABLE			,IE40	),
	RW_Entry(ONDATASETCHANGED			,IE40	),
	RW_Entry(ONDATASETCOMPLETE			,IE40	),
	RW_Entry(ONDBLCLICK					,IE40	),
	RW_Entry(ONDRAGSTART				,IE40	),
	RW_Entry(ONERROR					,IE40	),
	RW_Entry(ONERRORUPDATE				,IE40	),
	RW_Entry(ONFILTERCHANGE				,IE40	),
	RW_Entry(ONFINISH					,IE40	),
	RW_Entry(ONFOCUS					,IEXP3	), // SELECT, INPUT, TEXTAREA
	RW_Entry(ONHELP						,IE40	),
	RW_Entry(ONKEYDOWN					,IE40	),
	RW_Entry(ONKEYPRESS					,IE40	),
	RW_Entry(ONKEYUP					,IE40	),
	RW_Entry(ONLOAD						,IEXP3	), // FRAMESET, BODY
	RW_Entry(ONMOUSEOUT					,IEXP3	), // A, AREA, <more>
	RW_Entry(ONMOUSEOVER				,IEXP3	), // A, AREA, <more>
	RW_Entry(ONMOUSEUP					,IE40	),
	RW_Entry(ONREADYSTATECHANGE			,IE40	),
	RW_Entry(ONRESET					,IE40	),
	RW_Entry(ONRESIZE					,IE40	),
	RW_Entry(ONROWENTER					,IE40	),
	RW_Entry(ONROWEXIT					,IE40	),
	RW_Entry(ONSCROLL					,IE40	),
	RW_Entry(ONSELECT					,IEXP3	), // INPUT, TEXTAREA
	RW_Entry(ONSELECTSTART				,IE40	),
	RW_Entry(ONSUBMIT					,IEXP3	), // FORM
	RW_Entry(ONUNLOAD					,IEXP3	), // FRAMESET, BODY
	RW_Entry(OPENER						,IE40	),
	RW_Entry(OUTERHTML					,IE40	),
	RW_Entry(OUTERTEXT					,IE40	),
	RW_Entry(OUTLINE					,IEXP3	),
	RW_Entry(OVERFLOW					,IE40	),
	RW_Entry(OWNINGELEMENT				,IE40	),
	RW_Entry(PADDING					,IE40	),
	RW_Entry(PADDINGBOTTOM				,IE40	),
	RW_Entry(PADDINGLEFT				,IE40	),
	RW_Entry(PADDINGRIGHT				,IE40	),
	RW_Entry(PADDINGTOP					,IE40	),
	RW_Entry(PAGEBREAKAFTER				,IE40	),
	RW_Entry(PAGEBREAKBEFORE			,IE40	),
	RW_Entry(PALETTE					,IE40	),
	RW_Entry(PARENT						,IE40	),
	RW_Entry(PARENTELEMENT				,IE40	),
	RW_Entry(PARENTSTYLESHEET			,IE40	),
	RW_Entry(PARENTTEXTEDIT				,IE40	),
	RW_Entry(PARENTWINDOW				,IE40	),
	RW_Entry(PATHNAME					,IE40	),
	RW_Entry(PIXELHEIGHT				,IE40	),
	RW_Entry(PIXELLEFT					,IE40	),
	RW_Entry(PIXELTOP					,IE40	),
	RW_Entry(PIXELWIDTH					,IE40	),
	RW_Entry(PLUGINS					,IE40	),
	RW_Entry(PLUGINSPAGE				,IE40	),
	RW_Entry(PORT						,IE40	),
	RW_Entry(POSHEIGHT					,IE40	),
	RW_Entry(POSITION					,IE40	),
	RW_Entry(POSLEFT					,IE40	),
	RW_Entry(POSTOP						,IE40	),
	RW_Entry(POSWIDTH					,IE40	),
	RW_Entry(PROMPT						,IEXPn	),
	RW_Entry(PROTOCOL					,IE40	),
	RW_Entry(READONLY					,IE40	),
	RW_Entry(READYSTATE					,IE40	),
	RW_Entry(REASON						,IE40	),
	RW_Entry(RECORDNUMBER				,IE40	),
	RW_Entry(RECORDSET					,IE40	),
	RW_Entry(REF						,IEXP3	),
	RW_Entry(REFERRER					,IE40	),
	RW_Entry(REL						,ALL	),
	RW_Entry(RETURNVALUE				,IE40	),
	RW_Entry(REV						,ALL	),
	RW_Entry(RIGHTMARGIN				,IEXPn	),
	RW_Entry(ROWS						,ALL	),
	RW_Entry(ROWSPAN					,IEXPn	), // tables
	RW_Entry(RULES						,IEXP3	),
	RW_Entry(RUNAT						,IEXP3	), // SCRIPT
	RW_Entry(SCREENX					,IE40	),
	RW_Entry(SCREENY					,IE40	),
	RW_Entry(SCRIPTENGINE				,IEXP3	),
	RW_Entry(SCROLL						,IE40	),
	RW_Entry(SCROLLAMOUNT				,IEXPn	), // MARQUEE
	RW_Entry(SCROLLDELAY				,IEXPn	), // MARQUEE
	RW_Entry(SCROLLHEIGHT				,IE40	),
	RW_Entry(SCROLLING					,IEXP3	), // frameset
	RW_Entry(SCROLLLEFT					,IE40	),
	RW_Entry(SCROLLTOP					,IE40	),
	RW_Entry(SCROLLWIDTH				,IE40	),
	RW_Entry(SEARCH						,IE40	),
	RW_Entry(SELECTED					,ALL	),
	RW_Entry(SELECTEDINDEX				,IE40	),
	RW_Entry(SELF						,IE40	),
	RW_Entry(SHAPE						,IEXPn	),
	RW_Entry(SHAPES						,IEXP3	), //objects
	RW_Entry(SHIFTKEY					,IE40	),
	RW_Entry(SIZE						,ALL	),
	RW_Entry(SOURCEINDEX				,IE40	),
	RW_Entry(SPAN						,IEXP3	),
	RW_Entry(SRC						,ALL	),
	RW_Entry(SRCELEMENT					,IE40	),
	RW_Entry(SRCFILTER					,IE40	),
	RW_Entry(STANDBY					,IEXP3	), //objects
	RW_Entry(START						,IEXPn	),
	RW_Entry(STARTSPAN					,ALL	),	// Designer control tags
	RW_Entry(STATUS						,IE40	),
	RW_Entry(STYLE						,IEXP3	),
	RW_Entry(STYLEFLOAT					,IE40	),
	RW_Entry(TABINDEX					,IEXP3	),
	RW_Entry(TAGNAME					,IE40	),
	RW_Entry(TARGET						,IEXP3	),
	RW_Entry(TEXT						,IEXPn	),
	RW_Entry(TEXTALIGN					,IE40	),
	RW_Entry(TEXTDECORATION				,IE40	),
	RW_Entry(TEXTDECORATIONBLINK		,IE40	),
	RW_Entry(TEXTDECORATIONLINETHROUGH	,IE40	),
	RW_Entry(TEXTDECORATIONNONE			,IE40	),
	RW_Entry(TEXTDECORATIONOVERLINE		,IE40	),
	RW_Entry(TEXTDECORATIONUNDERLINE	,IE40	),
	RW_Entry(TEXTINDENT					,IE40	),
	RW_Entry(TEXTTRANSFORM				,IE40	),
	RW_Entry(TITLE						,ALL	),
	RW_Entry(TOELEMENT					,IE40	),
	RW_Entry(TOP						,IE40	),
	RW_Entry(TOPMARGIN					,IEXPn	),
	RW_Entry(TRUESPEED					,IE40	),
	RW_Entry(TYPE						,IEXPn	),
	RW_Entry(UPDATEINTERVAL				,IE40	),
	RW_Entry(URL						,IEXP3	),
	RW_Entry(URN						,ALL	),
	RW_Entry(USEMAP						,IEXPn	),
	RW_Entry(USERAGENT					,IE40	),
	RW_Entry(VALIGN						,IEXPn	),
	RW_Entry(VALUE						,ALL	),
	RW_Entry(VERSION					,IEXP3	),	// HTML
	RW_Entry(VERTICALALIGN				,IE40	),
	RW_Entry(VIEWASTEXT					,ALL	),	// ViewAsText for AspView only
	RW_Entry(VISIBILITY					,IE40	),
	RW_Entry(VLINK						,IEXPn	),
	RW_Entry(VLINKCOLOR					,IE40	),
	RW_Entry(VOLUME						,IE40	),
	RW_Entry(VRML						,IEXPn	),
	RW_Entry(VSPACE						,IEXPn	),
	RW_Entry(WIDTH						,ALL	),
	RW_Entry(WRAP						,IEXP3	),
	RW_Entry(X							,IE40	),
	RW_Entry(Y							,IE40	),
	RW_Entry(ZINDEX						,IE40	),
};

// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
static int _rgIndexAttributeNames[] = // [Attributes]
{
	/* A */	TokAttrib_ACCESSKEY			,
	/* B */	TokAttrib_BACKGROUND		,
	/* C */	TokAttrib_CANCELBUBBLE		,
	/* D */	TokAttrib_DATA				,
	/* E */	TokAttrib_ENCODING			,
	/* F */	TokAttrib_FACE				,
	/* G */	0							,
	/* H */	TokAttrib_HASH				,
	/* I */	TokAttrib_ID				,
	/* J */	0							,
	/* K */	0							,
	/* L */	TokAttrib_LANG				,
	/* M */	TokAttrib_MAP				,
	/* N */	TokAttrib_NAME				,
	/* O */	TokAttrib_OBJECT			,
	/* P */	TokAttrib_PADDING			,
	/* Q */	0							,
	/* R */	TokAttrib_READONLY			,
	/* S */	TokAttrib_SCREENX			,
	/* T */	TokAttrib_TABINDEX			,
	/* U */	TokAttrib_UPDATEINTERVAL	,
	/* V */	TokAttrib_VALIGN			,
	/* W */	TokAttrib_WIDTH				,
	/* X */	TokAttrib_X					,
	/* Y */	TokAttrib_Y					,
	/* Z */	TokAttrib_ZINDEX
};

//
// Entities
//
// ALL   - Basic             - RFC 1866, 9.7.1. Numeric and Special Graphic Entity Set
// ALL   - ISO Latin 1       - RFC 1866, 9.7.2. ISO Latin 1 Character Entity Set
// IEXPn - ISO Latin 1 Added - RFC 1866, 14.    Proposed Entities
//
// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
static ReservedWord _rgEntity[] =
{
    _T(""),       0,      0,
    _T("AElig"),  5,      ALL,    // <!ENTITY AElig  CDATA "&#198;") -- capital AE diphthong (ligature) -->
    _T("Aacute"), 6,      ALL,    // <!ENTITY Aacute CDATA "&#193;") -- capital A, acute accent -->
    _T("Acirc"),  5,      ALL,    // <!ENTITY Acirc  CDATA "&#194;") -- capital A, circumflex accent -->
    _T("Agrave"), 6,      ALL,    // <!ENTITY Agrave CDATA "&#192;") -- capital A, grave accent -->
    _T("Aring"),  5,      ALL,    // <!ENTITY Aring  CDATA "&#197;") -- capital A, ring -->
    _T("Atilde"), 6,      ALL,    // <!ENTITY Atilde CDATA "&#195;") -- capital A, tilde -->
    _T("Auml"),   4,      ALL,    // <!ENTITY Auml   CDATA "&#196;") -- capital A, dieresis or umlaut mark -->
    _T("Ccedil"), 6,      ALL,    // <!ENTITY Ccedil CDATA "&#199;") -- capital C, cedilla -->
    _T("ETH"),    3,      ALL,    // <!ENTITY ETH    CDATA "&#208;") -- capital Eth, Icelandic -->
    _T("Eacute"), 6,      ALL,    // <!ENTITY Eacute CDATA "&#201;") -- capital E, acute accent -->
    _T("Ecirc"),  5,      ALL,    // <!ENTITY Ecirc  CDATA "&#202;") -- capital E, circumflex accent -->
    _T("Egrave"), 6,      ALL,    // <!ENTITY Egrave CDATA "&#200;") -- capital E, grave accent -->
    _T("Euml"),   4,      ALL,    // <!ENTITY Euml   CDATA "&#203;") -- capital E, dieresis or umlaut mark -->
    _T("Iacute"), 6,      ALL,    // <!ENTITY Iacute CDATA "&#205;") -- capital I, acute accent -->
    _T("Icirc"),  5,      ALL,    // <!ENTITY Icirc  CDATA "&#206;") -- capital I, circumflex accent -->
    _T("Igrave"), 6,      ALL,    // <!ENTITY Igrave CDATA "&#204;") -- capital I, grave accent -->
    _T("Iuml"),   4,      ALL,    // <!ENTITY Iuml   CDATA "&#207;") -- capital I, dieresis or umlaut mark -->
    _T("Ntilde"), 6,      ALL,    // <!ENTITY Ntilde CDATA "&#209;") -- capital N, tilde -->
    _T("Oacute"), 6,      ALL,    // <!ENTITY Oacute CDATA "&#211;") -- capital O, acute accent -->
    _T("Ocirc"),  5,      ALL,    // <!ENTITY Ocirc  CDATA "&#212;") -- capital O, circumflex accent -->
    _T("Ograve"), 6,      ALL,    // <!ENTITY Ograve CDATA "&#210;") -- capital O, grave accent -->
    _T("Oslash"), 6,      ALL,    // <!ENTITY Oslash CDATA "&#216;") -- capital O, slash -->
    _T("Otilde"), 6,      ALL,    // <!ENTITY Otilde CDATA "&#213;") -- capital O, tilde -->
    _T("Ouml"),   4,      ALL,    // <!ENTITY Ouml   CDATA "&#214;") -- capital O, dieresis or umlaut mark -->
    _T("THORN"),  5,      ALL,    // <!ENTITY THORN  CDATA "&#222;") -- capital THORN, Icelandic -->
    _T("Uacute"), 6,      ALL,    // <!ENTITY Uacute CDATA "&#218;") -- capital U, acute accent -->
    _T("Ucirc"),  5,      ALL,    // <!ENTITY Ucirc  CDATA "&#219;") -- capital U, circumflex accent -->
    _T("Ugrave"), 6,      ALL,    // <!ENTITY Ugrave CDATA "&#217;") -- capital U, grave accent -->
    _T("Uuml"),   4,      ALL,    // <!ENTITY Uuml   CDATA "&#220;") -- capital U, dieresis or umlaut mark -->
    _T("Yacute"), 6,      ALL,    // <!ENTITY Yacute CDATA "&#221;") -- capital Y, acute accent -->
    _T("aacute"), 6,      ALL,    // <!ENTITY aacute CDATA "&#225;") -- small a, acute accent -->
    _T("acirc"),  5,      ALL,    // <!ENTITY acirc  CDATA "&#226;") -- small a, circumflex accent -->
	_T("acute"),  5,      IEXPn,  // <!ENTITY acute  CDATA "&#180;") -- acute accent -->
    _T("aelig"),  5,      ALL,    // <!ENTITY aelig  CDATA "&#230;") -- small ae diphthong (ligature) -->
    _T("agrave"), 6,      ALL,    // <!ENTITY agrave CDATA "&#224;") -- small a, grave accent -->
	_T("amp"),    3,      ALL,
    _T("aring"),  5,      ALL,    // <!ENTITY aring  CDATA "&#229;") -- small a, ring -->
    _T("atilde"), 6,      ALL,    // <!ENTITY atilde CDATA "&#227;") -- small a, tilde -->
    _T("auml"),   4,      ALL,    // <!ENTITY auml   CDATA "&#228;") -- small a, dieresis or umlaut mark -->
	_T("brvbar"), 6,      IEXPn,  // <!ENTITY brvbar CDATA "&#166;") -- broken (vertical) bar -->
    _T("ccedil"), 6,      ALL,    // <!ENTITY ccedil CDATA "&#231;") -- small c, cedilla -->
	_T("cedil"),  5,      IEXPn,  // <!ENTITY cedil  CDATA "&#184;") -- cedilla -->
	_T("cent"),   4,      IEXPn,  // <!ENTITY cent   CDATA "&#162;") -- cent sign -->
	_T("copy"),   4,      IEXPn,  // <!ENTITY copy   CDATA "&#169;") -- copyright sign -->
	_T("curren"), 6,      IEXPn,  // <!ENTITY curren CDATA "&#164;") -- general currency sign -->
	_T("deg"),    3,      IEXPn,  // <!ENTITY deg    CDATA "&#176;") -- degree sign -->
	_T("divide"), 6,      IEXPn,  // <!ENTITY divide CDATA "&#247;") -- divide sign -->
    _T("eacute"), 6,      ALL,    // <!ENTITY eacute CDATA "&#233;") -- small e, acute accent -->
    _T("ecirc"),  5,      ALL,    // <!ENTITY ecirc  CDATA "&#234;") -- small e, circumflex accent -->
    _T("egrave"), 6,      ALL,    // <!ENTITY egrave CDATA "&#232;") -- small e, grave accent -->
    _T("eth"),    3,      ALL,    // <!ENTITY eth    CDATA "&#240;") -- small eth, Icelandic -->
    _T("euml"),   4,      ALL,    // <!ENTITY euml   CDATA "&#235;") -- small e, dieresis or umlaut mark -->
	_T("frac12"), 6,      IEXPn,  // <!ENTITY frac12 CDATA "&#189;") -- fraction one-half -->
	_T("frac14"), 6,      IEXPn,  // <!ENTITY frac14 CDATA "&#188;") -- fraction one-quarter -->
	_T("frac34"), 6,      IEXPn,  // <!ENTITY frac34 CDATA "&#190;") -- fraction three-quarters -->
	_T("gt"),     2,      ALL,
    _T("iacute"), 6,      ALL,    // <!ENTITY iacute CDATA "&#237;") -- small i, acute accent -->
    _T("icirc"),  5,      ALL,    // <!ENTITY icirc  CDATA "&#238;") -- small i, circumflex accent -->
	_T("iexcl"),  5,      IEXPn,  // <!ENTITY iexcl  CDATA "&#161;") -- inverted exclamation mark -->
    _T("igrave"), 6,      ALL,    // <!ENTITY igrave CDATA "&#236;") -- small i, grave accent -->
	_T("iquest"), 6,      IEXPn,  // <!ENTITY iquest CDATA "&#191;") -- inverted question mark -->
    _T("iuml"),   4,      ALL,    // <!ENTITY iuml   CDATA "&#239;") -- small i, dieresis or umlaut mark -->
	_T("laquo"),  5,      IEXPn,  // <!ENTITY laquo  CDATA "&#171;") -- angle quotation mark, left -->
	_T("lt"),     2,      ALL,
	_T("macr"),   4,      IEXPn,  // <!ENTITY macr   CDATA "&#175;") -- macron -->
	_T("micro"),  5,      IEXPn,  // <!ENTITY micro  CDATA "&#181;") -- micro sign -->
	_T("middot"), 6,      IEXPn,  // <!ENTITY middot CDATA "&#183;") -- middle dot -->
	_T("nbsp"),   4,      IEXPn,  // <!ENTITY nbsp   CDATA "&#160;") -- no-break space -->
	_T("not"),    3,      IEXPn,  // <!ENTITY not    CDATA "&#172;") -- not sign -->
    _T("ntilde"), 6,      ALL,    // <!ENTITY ntilde CDATA "&#241;") -- small n, tilde -->
    _T("oacute"), 6,      ALL,    // <!ENTITY oacute CDATA "&#243;") -- small o, acute accent -->
    _T("ocirc"),  5,      ALL,    // <!ENTITY ocirc  CDATA "&#244;") -- small o, circumflex accent -->
    _T("ograve"), 6,      ALL,    // <!ENTITY ograve CDATA "&#242;") -- small o, grave accent -->
	_T("ordf"),   4,      IEXPn,  // <!ENTITY ordf   CDATA "&#170;") -- ordinal indicator, feminine -->
	_T("ordm"),   4,      IEXPn,  // <!ENTITY ordm   CDATA "&#186;") -- ordinal indicator, masculine -->
    _T("oslash"), 6,      ALL,    // <!ENTITY oslash CDATA "&#248;") -- small o, slash -->
    _T("otilde"), 6,      ALL,    // <!ENTITY otilde CDATA "&#245;") -- small o, tilde -->
    _T("ouml"),   4,      ALL,    // <!ENTITY ouml   CDATA "&#246;") -- small o, dieresis or umlaut mark -->
	_T("para"),   4,      IEXPn,  // <!ENTITY para   CDATA "&#182;") -- pilcrow (paragraph sign) -->
	_T("plusmn"), 6,      IEXPn,  // <!ENTITY plusmn CDATA "&#177;") -- plus-or-minus sign -->
	_T("pound"),  5,      IEXPn,  // <!ENTITY pound  CDATA "&#163;") -- pound sterling sign -->
	_T("quot"),   4,      ALL,
	_T("raquo"),  5,      IEXPn,  // <!ENTITY raquo  CDATA "&#187;") -- angle quotation mark, right -->
	_T("reg"),    3,      IEXPn,  // <!ENTITY reg    CDATA "&#174;") -- registered sign -->
	_T("sect"),   4,      IEXPn,  // <!ENTITY sect   CDATA "&#167;") -- section sign -->
	_T("shy"),    3,      IEXPn,  // <!ENTITY shy    CDATA "&#173;") -- soft hyphen -->
	_T("sup1"),   4,      IEXPn,  // <!ENTITY sup1   CDATA "&#185;") -- superscript one -->
	_T("sup2"),   4,      IEXPn,  // <!ENTITY sup2   CDATA "&#178;") -- superscript two -->
	_T("sup3"),   4,      IEXPn,  // <!ENTITY sup3   CDATA "&#179;") -- superscript three -->
    _T("szlig"),  5,      ALL,    // <!ENTITY szlig  CDATA "&#223;") -- small sharp s, German (sz ligature)->
    _T("thorn"),  5,      ALL,    // <!ENTITY thorn  CDATA "&#254;") -- small thorn, Icelandic -->
	_T("times"),  5,      IEXPn,  // <!ENTITY times  CDATA "&#215;") -- multiply sign -->
    _T("uacute"), 6,      ALL,    // <!ENTITY uacute CDATA "&#250;") -- small u, acute accent -->
    _T("ucirc"),  5,      ALL,    // <!ENTITY ucirc  CDATA "&#251;") -- small u, circumflex accent -->
    _T("ugrave"), 6,      ALL,    // <!ENTITY ugrave CDATA "&#249;") -- small u, grave accent -->
	_T("uml"),    3,      IEXPn,  // <!ENTITY uml    CDATA "&#168;") -- umlaut (dieresis) -->
    _T("uuml"),   4,      ALL,    // <!ENTITY uuml   CDATA "&#252;") -- small u, dieresis or umlaut mark -->
    _T("yacute"), 6,      ALL,    // <!ENTITY yacute CDATA "&#253;") -- small y, acute accent -->
	_T("yen"),    3,      IEXPn,  // <!ENTITY yen    CDATA "&#165;") -- yen sign -->
    _T("yuml"),   4,      ALL,    // <!ENTITY yuml   CDATA "&#255;") -- small y, dieresis or umlaut mark -->

};

// If you modify the element, attribute, or entity tables, then you MUST 
// update Token.h.
static int _rgIndexEntity[] =
{
//  A   B   C   D   E   F   G   H   I   J   K   L   M
	1,  0,  8,  0,  9,  0,  0,  0, 14,  0,  0,  0,  0,
//  N   O   P   Q   R   S   T   U   V   W   X   Y   Z
   18, 19,  0,  0,  0,  0, 25, 26,  0,  0,  0, 30,  0,
//  a   b   c   d   e   f   g   h   i   j   k   l   m
   31, 40, 41, 46, 48, 53, 56,  0, 57,  0,  0, 63, 65,
//  n   o   p   q   r   s   t   u   v   w   x   y   z
   68, 71, 79, 82, 83, 85, 91, 93,  0,  0,  0, 98,  0
};

////////////////////////////////////////////////////////////////////////////


//
//
//	int LookupLinearKeyword
//
//	Description:
//		Does the lookup in the given table.
//		Returns index into table if found, NOT_FOUND otw.
//
int LookupLinearKeyword
(
	ReservedWord 	*rwTable,
	int 			cel,
	RWATT_T 		att,
	LPCTSTR 		pchLine,
	int 			cbLen,
	BOOL 			bCase /* = NOCASE */
)
{
	int iTable = 0;
	ASSERT(cel > 0);

	PFNNCMP pfnNCmp = bCase ? (_tcsncmp) : (_tcsnicmp);

	do
	{
		int Cmp;
		if (0 == (Cmp = pfnNCmp(pchLine, rwTable[iTable].psz, cbLen)) &&
			 (cbLen == rwTable[iTable].cb))
			return (0 != (rwTable[iTable].att & att)) ? iTable : NOT_FOUND;
		else if (Cmp < 0)
			return NOT_FOUND;
		else
			iTable++;
	} while (iTable < cel);
	return NOT_FOUND;
}

////////////////////////////////////////////////////////////////////////////
//  LookupIndexedKeyword()
//
int LookupIndexedKeyword
(
	ReservedWord 	*rwTable,
	int 			cel,
	int * 			indexTable,
	RWATT_T 		att,
	LPCTSTR 		pchLine,
	int 			cbLen,
	BOOL 			bCase 	/* = NOCASE */
)
{
	// lookup table:
	int iTable;
	int index = PeekIndex(*pchLine, bCase);
	if (index < 0)
		return NOT_FOUND;
	else
		iTable = indexTable[index];
	if (0 == iTable)
		return NOT_FOUND;
	int iFound = LookupLinearKeyword(&rwTable[iTable], cel - iTable,
		att, pchLine, cbLen, bCase);

	return (iFound == NOT_FOUND) ? NOT_FOUND : iTable + iFound;
}

////////////////////////////////////////////////////////////////////////////
// hinting table - character classification

// HOP
// () ? , | + [] * =
//   in tag, op
//
// HDA
// - op
// -- comment
//
// HEN
// & in text, entity ref
//   in tag, op
//
// HEP
// % in tag, parameter entity ref (%name) or op (%WS)
//
// HRN
// # reserved name
//
// HTA
// <    tag open
// </   tag end
// <!   MDO Markup delimiter open
// <?   processing instruction - what's the syntax for a complete PI tag?

// Hint table:
HINT g_hintTable[128] =
{
//    0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f
    EOS, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, HWS, ONL, ERR, ERR, ERR, ERR, ERR,
//   10   11   12   13   14   15   16   17   18   19   1a   1b   1c   1d   1e   1f
    ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR, ERR,
//  spc   !    "    #    $    %    &    '    (    )    *    +    ,    -    .    /
    HWS, ERR, HST, HRN, ERR, HEP, HEN, HSL, OLP, ORP, OST, OPL, OCO, ODA, HKW, HAV,
//   0    1    2    3    4    5    6    7    8    9    :    ;    <    =    >    ?
    HNU, HNU, HNU, HNU, HNU, HNU, HNU, HNU, HNU, HNU, ERR, ERR, HTA, OEQ, HTE, OQU,
//   @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O
    ERR, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW,
//   P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _
    HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, OLB, HAV, ORB, ERR, HAV,
//   `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o
    ERR, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW,
//   p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~   DEL
    HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, HKW, ERR, OPI, ERR, ERR, ERR
};

////////////////////////////////////////////////////////////////////////////
// content model
//
// Map between element / lex state
//

// 0-terminated list
// if we get more, consider putting text state in element table
static ELLEX _ElTextStateTable[] =
{
	_T("COMMENT"),   7, inCOMMENT,
	_T("LISTING"),   7, inLISTING,
	_T("PLAINTEXT"), 9, inPLAINTEXT,
	_T("SCRIPT"),	 6, inSCRIPT,
	_T("XMP"),       3, inXMP,
	0, 0, 0
};

DWORD TextStateFromElement(LPCTSTR szEl, int cb)
{
	int cmp;
	for (ELLEX *pel = _ElTextStateTable; pel->sz != 0; pel++)
	{
		if (0 == (cmp = _tcsnicmp(pel->sz, szEl, cb)))
		{
			if (cb == pel->cb)
				return pel->lxs;
		}
		else if (cmp > 0)
			return 0;
	}
	return 0;
}

ELLEX * pellexFromTextState(DWORD state)
{
	DWORD t = (state & TEXTMASK); // only want text state bits
	for (ELLEX *pellex = _ElTextStateTable; pellex->lxs != 0; pellex++)
	{
		if (t == pellex->lxs)
			return pellex;
	}
	return 0;
}


////////////////////////////////////////////////////////////////////////////
// CStaticTable
CStaticTable::CStaticTable(RWATT_T att,
						   ReservedWord *prgrw,
						   UINT cel,
						   int *prgi /*= NULL*/,
						   BOOL bCase /*= FALSE*/,
						   LPCTSTR szName /*= NULL*/)
: m_att(att), m_prgrw(prgrw), m_cel(cel), m_prgi(prgi), m_bCase(bCase)
{
	ASSERT(NULL != m_prgrw);
	ASSERT(m_cel > 0);
	ASSERT(0 == CheckWordTable(m_prgrw, cel, szName));
	if (NULL == m_prgi)
	{
		MakeIndex(m_prgrw, m_cel, &m_prgi, m_bCase, szName);
	}
	else
		ASSERT(0 == CheckWordTableIndex(m_prgrw, cel, prgi, m_bCase, szName));
}

int CStaticTable::Find(LPCTSTR pch, int cb)
{
	return LookupIndexedKeyword(m_prgrw, m_cel, m_prgi, m_att, pch, cb, m_bCase);
}

////////////////////////////////////////////////////////////////////////////
CStaticTableSet::CStaticTableSet(RWATT_T att, UINT nIdName)
:	m_Elements  ( att, _rgElementNames, CELEM_ARRAY(_rgElementNames),
				 _rgIndexElementNames, NOCASE, szElTag ),
	m_Attributes( att, _rgAttributeNames, CELEM_ARRAY(_rgAttributeNames),
				 _rgIndexAttributeNames, NOCASE, szAttTag ),
	m_Entities  ( att, _rgEntity, CELEM_ARRAY(_rgEntity),
				 _rgIndexEntity, CASE, szEntTag )
{
	::LoadString(	_Module.GetModuleInstance(),
					nIdName,
					m_strName,
					sizeof(m_strName)
					);
}

int CStaticTableSet::FindElement(LPCTSTR pch, int cb)
{
	return m_Elements.Find(pch, cb);
}

int CStaticTableSet::FindAttribute(LPCTSTR pch, int cb)
{
	return m_Attributes.Find(pch, cb);
}

int CStaticTableSet::FindEntity(LPCTSTR pch, int cb)
{
	return m_Entities.Find(pch, cb);
}

CStaticTableSet * g_pTabDefault;
PTABLESET g_pTable = 0;

////////////////////////////////////////////////////////////////////////////
//
// Custom HTML tables
//
/*

@HLX@ "Internet Explorer 3.0"
;Custom HTML tagset file must begin with the "@HLX@"
;signature and the name of the HTML variant in quotes.

[Elements]
; element set

[Attributes]
; attribute set

[Entities]
; entity set

*/

// qsort/bsearch helper
int CmpFunc(const void *a, const void *b)
{
	CLStr *A = (CLStr*)a;
	CLStr *B = (CLStr*)b;
	int r = memcmp(A->m_rgb, B->m_rgb, __min(A->m_cb, B->m_cb));
	return (0 == r) ? (A->m_cb - B->m_cb) : r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\table.h ===
// HTML lexer tables
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __HLTABLE_H__
#define __HLTABLE_H__

#include "lexhtml.h"

#ifndef PURE
#define PURE =0
#endif

// These values must match the number of built-in tables (CV_FIXED), 
// and the capacity of the inVariant bits of the lex state (CV_MAX).
const UINT CV_FIXED =  4; // Count Variants in Fixed tables
const UINT CV_MAX   = 16; // Count variants maximum total

// Macro for determining number of elements in an array
#define CELEM_ARRAY(a)  (sizeof(a) / sizeof(a[0]))

// length-limited string compare function pointer (e.g. strncmp/strnicmp)

typedef  int (_cdecl* PFNNCMP)(LPCTSTR, LPCTSTR, size_t);

#define CASE (TRUE)
#define NOCASE (FALSE)

#define NOT_FOUND (-1)

////////////////////////////////////////////////////////////////////////////

// return A-Z[a-z] index if alpha, else -1
inline int PeekIndex(TCHAR c, BOOL bCase /*= NOCASE*/)
{
	if ((c >= _T('A')) && (c <= _T('Z')))
		return c - _T('A');
	else if ((c >= _T('a')) && (c <= _T('z')))
		return c - _T('a') + (bCase ? 26 : 0);
	else
		return -1;
}

// static table lookups
int LookupLinearKeyword(ReservedWord *rwTable, int cel, RWATT_T att, LPCTSTR pchLine, int cbLen, BOOL bCase = NOCASE);
int LookupIndexedKeyword(ReservedWord *rwTable, int cel, int * indexTable, RWATT_T att, LPCTSTR pchLine, int cbLen, BOOL bCase = NOCASE);

// content model
// Map between element / lex state
//
struct ELLEX {
	LPCTSTR sz;
	int     cb;
	DWORD   lxs;
};

DWORD TextStateFromElement(LPCTSTR szEl, int cb);
ELLEX * pellexFromTextState(DWORD state);
inline LPCTSTR ElementFromTextState(DWORD state)
{
	ELLEX *pellex = pellexFromTextState(state);
	return pellex ? pellex->sz : 0;
}

#ifdef _DEBUG
int CheckWordTable(ReservedWord *arw, int cel, LPCTSTR szName = NULL);
int CheckWordTableIndex(ReservedWord *arw, int cel, int *ai, BOOL bCase = FALSE, LPCTSTR szName = NULL);
int MakeIndexHere(ReservedWord *arw, int cel, int *ab, BOOL bCase = FALSE, LPCTSTR szName = NULL);
#endif

int MakeIndex(ReservedWord *arw, int cel, int **pab, BOOL bCase = FALSE, LPCTSTR szName = NULL);

////////////////////////////////////////////////////////////////////////////

// test for SGML identifier character:
// alphanumeric or '-' or '.'
inline BOOL IsIdChar(TCHAR ch)
{
	return IsCharAlphaNumeric(ch) || ch == _T('-') || ch == _T('.') || ch == _T(':');
}

////////////////////////////////////////////////////////////////////////////
// Abstract Base Classes
//
class CTable
{
public:
	virtual ~CTable() {}
	virtual int Find(LPCTSTR pch, int cb) PURE;
};

class CTableSet
{
public:
	virtual ~CTableSet() {}
	virtual int FindElement(LPCTSTR pch, int cb) PURE;
	virtual int FindAttribute(LPCTSTR pch, int cb) PURE;
	virtual int FindEntity(LPCTSTR pch, int cb) PURE;
	const TCHAR* Name() const { return m_strName; }

protected:
	TCHAR m_strName[1024];

};

typedef CTable *PTABLE;
typedef CTableSet * PTABLESET;
typedef const CTableSet * PCTABLESET;

// static, built-in table
class CStaticTable : public CTable
{
public:
	CStaticTable(
		RWATT_T att,
		ReservedWord *prgrw, UINT cel, 
		int *prgi = NULL, 
		BOOL bCase = FALSE,
		LPCTSTR szName = NULL);
	virtual ~CStaticTable() {} // nothing to delete
	BOOL Find(LPCTSTR pch, int cb);
private:
	ReservedWord *m_prgrw; // reserved word table
	UINT m_cel;            // element count (size)
	int *m_prgi;           // index table
	BOOL m_bCase;          // case sensitive?
	RWATT_T m_att;         // attribute mask for table lookup
};

class CStaticTableSet : public CTableSet
{
public:
	CStaticTableSet(RWATT_T att, UINT nIdName);
	virtual ~CStaticTableSet() {}
	int FindElement(LPCTSTR pch, int cb);
	int FindAttribute(LPCTSTR pch, int cb);
	int FindEntity(LPCTSTR pch, int cb);
private:
	CStaticTable m_Elements;
	CStaticTable m_Attributes;
	CStaticTable m_Entities;
};

////////////////////////////////////////////////////////////////////////////
// CLStr
// A very simple length-and-buffer string representation
// with just enough functionality for our purpose.
class CLStr
{
public:
	CLStr() : m_cb(0), m_rgb(0) {}
	CLStr(const BYTE * rgb, DWORD cb) : m_rgb(rgb), m_cb(cb) {}
	BOOL Compare(const BYTE * rgb, DWORD cb, BOOL bCase)
	{
		int r;
		if (bCase)
			r = memcmp(rgb, m_rgb, __min(m_cb, cb));
		else
			r = _memicmp(rgb, m_rgb, __min(m_cb, cb));
		return (0 == r) ? (cb - m_cb) : r;
	}
	// data
	DWORD m_cb;
	const BYTE * m_rgb;
};
typedef CLStr * PLSTR;
typedef const CLStr * PCLSTR;
typedef const CLStr & RCLSTR;

extern CStaticTableSet * g_pTabDefault;
extern PTABLESET g_pTable;
extern HINT g_hintTable[];

#endif // __HLTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\trace.cpp ===
/****************************************************************************
*
* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
*
*
*
*
*
*
*
****************************************************************************/

#include "stdafx.h"

#include "trace.h"

#ifdef _DEBUG

void __cdecl Trace(LPSTR lprgchFormat, ...)
{
    char rgch[128], rgchOutput[256];
    wsprintfA(rgch, "%s\n", lprgchFormat);
#if defined(_M_IX86)
    wvsprintfA(rgchOutput, rgch, (LPSTR)(((LPSTR)&lprgchFormat) + sizeof(LPSTR)));
#else
    {
    va_list lpArgs;
    va_start(lpArgs, lprgchFormat);
    wvsprintfA(rgchOutput, rgch, lpArgs);
    va_end(lpArgs);
    }
#endif
    OutputDebugStringA(rgchOutput);
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\token.h ===
/* Copied from ..\htmed\itoken.h and changed name from ITokenizer to ITokGen 
and itoken.h to token.h just to avoid name confusion in future. */

/*

    File: Token.h

    Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.

    Abstract:
		ITokenizer interface and its types

*/
#if !defined __INC_TOKEN_H__
#define __INC_TOKEN_H__

typedef int TOKEN;
// A text token block indicates the token, and its starting and ending
// indexes in the line of source just lexed.
// Note that for any N > 0, rgtxtb[N].ibTokMin >= rgtxtb[N-1].ibTokMac.
// if it is such that rgtxtb[N].ibTokMin > rgtxtb[N-1].ibTokMac, then
// the intervening unclassified characters are treated as white space tokens.

typedef struct _tagTXTB { // Text token class block
	TOKEN   tok;
	TOKEN   tokClass;
	UINT    ibTokMin;               // token length given by ibTokMac - ibTokMin
	UINT    ibTokMac;               // given in bytes
} TXTB;

// ********* defines specific to TRIEDIT begin here


enum ObjectTypes
    {	
    OT_NONE	= 0,
	OT_ACTIVEXCONTROL	= 0x1,
	OT_DESIGNTIMECONTROL	= 0x2,
	OT_INPUT	= 0x4,
	OT_TABLE	= 0x8,
	OT_APPLET	= 0x10,
	OT_INVISIBLE	= 0x8000,
	OT_VISIBLEITEMS	= 0x4fff,
	OT_ALLITEMS	= 0xffff
    };

enum ParserStates
{
	PS_HTML,
	PS_SIMPLETAG,		// simple tag that cannot have </ nested within it
	PS_OBJECT,
	PS_METADATASTART,
	PS_METADATABODY,
	PS_METADATAEND

};

enum ObjectParserStates
{
	OPS_NONE,
	OPS_CLASSID
};

enum TagStates
{
	TS_NONE,	  	// in tag, looking for the end tag
	TS_FOUNDTAGCLOSE, // found > closing the start element
	TS_FOUNDTAGEND	// found </ next token should be end tag token
};

enum DesignControlStates
{
	DTCS_NONE, 		// just found METADATA
	DTCS_TYPE,		// found TYPE attribute
	DTCS_DTCTYPE,	// found DesignerControl attribute value
	DTCS_ENDSPAN 	// found endspan
};
enum FilterMode
{ modeNone, modeInput, modeOutput };

#define cbHeader 0x8000	// initial buffer size to save all contents before/after <BODY> tag
#define MAX_BLOCKS 20 // max # of blocks that hold the replaced data 
#define MAX_TOKIDLEN 32 // max length of a token identifier


struct TOKSTRUCT // holds elements of token array generated  from the document
{
	TXTB token;
	BOOL fStart;
	UINT ichStart;
	UINT iNextprev;
	UINT iNextPrevAlternate;
	INT tagID;
};

struct TOKSTACK
{
	UINT iMatch;
	INT tagID;
	UINT ichStart; // start char position of this token in the input buffer
	TXTB token; // used in special cases (<%, %>) where tagID is -1
};


// ********* defines specific to TRIEDIT end here
interface ITokenGen : public IUnknown
{
public:
	// Gets then next token given the text
	//	pszText:	stream of text - UNICODE only!!!!
	//	cbText:		count of bytes in pszText
	//	pcbCur:		current byte position in pszText.
	//				set to 0 for start of pszText
	//	pLXS:		should be 0, on initial call
	//	pToken:		TXTB structure which contains the token info
	//	returns:
	//			NOERROR if found the next token
	//			S_FALSE if no more tokens
	//			error if there was an error
	//
	virtual HRESULT STDMETHODCALLTYPE NextToken(
		/*	[in]	  */ LPCWSTR pszText,
		/*	[in]	  */ UINT	 cbText,
		/*	[in, out] */ UINT	*pcbCur,
		/*	[in, out] */ DWORD *pLXS,
		/*	[out]	  */ TXTB	*pToken) = 0;


	// Tokenizes & Parses the input buffer
	//	hOld:	source buffer
	//	phNew or pStmNew: filtered buffer (based on dwFlagsUsePstmNew)
	//	pStmNew
	//	dwFlags:filter flags
	//	mode:	input/output mode.
	//	cbSizeIn: size of input buffer in bytes (if -1, assume NULL terminated buffer)
	//	*pcbSizeOut:size of output buffer in bytes
	//	pUnkTrident:trident's IUnknown
	//	phgTokArray:Token Array (freed by the caller)
	//	pcMaxToken:number of tokens in phgTokArray
	//	phgDocRestore:stores document contents which are used for filtering
	//	bstrBaseURL:used to convert URLs on a page into Relative URL (can be NULL)
	//	dwReserved - must be 0 (added for future use)
	//	returns:
	//		S_OK if no errors
	//		E_OUTOFMEMORY if any allocation failed
	//		E_FILTERFRAMESET or E_FILTERSERVERSCRIPT for html files that cannot be filtered

	virtual HRESULT STDMETHODCALLTYPE hrTokenizeAndParse(
		/*	[in]	*/ HGLOBAL hOld,
		/*	[out]	*/ HGLOBAL *phNew,
		/*	[in/out]*/ IStream *pStmNew,
		/*	[in]	*/ DWORD dwFlags,
		/*	[in]	*/ FilterMode mode,
		/*	[in]	*/ int cbSizeIn,
		/*	[out]	*/ UINT* pcbSizeOut,
		/*	[in]	*/ IUnknown *pUnkTrident,
		/*	[out]	*/ HGLOBAL *phgTokArray,
		/*	[out]	*/ UINT *pcMaxToken,
		/*	[in/out]*/ HGLOBAL *phgDocRestore,
		/*  [in]    */ BSTR bstrBaseURL,
		/*	[in]	*/ DWORD dwReserved) = 0;

};

enum TOKCLS { // token classes
	tokclsError = 0,

	// all standard language keywords
	tokclsKeyWordMin = 1,

	// for block start/end that are keywords instead of operators...like
	// Pascal or BASIC for instance.
	tokclsKeyWordOpenBlock = 0xfe,
	tokclsKeyWordCloseBlock = 0xff,

	tokclsKeyWordMax = 0x100,

	// all language operators
	tokclsOpMin = 0x100,
	tokclsOpSpecOpenBlock = 0x1fe,
	tokclsOpSpecCloseBlock = 0x1ff,
	tokclsOpMax = 0x200,

	// special, hard coded operators that editor keys off of
	tokclsOpSpecMin = 0x200,
	tokclsOpSpecEOL = 0x200,
	tokclsOpSpecLineCmt = 0x201, // automatic skip to eol on this one
	tokclsOpSpecEOS = 0x202,
	tokclsOpSpecMax = 0x210,

	// all identifiers, give ~500 possibilities
	tokclsIdentMin = 0x210,
	tokclsIdentUser = 0x211,        // special idents (user keywords)
	tokclsIdentMax = 0x400,

	// all constants (numeric and string)
	tokclsConstMin = 0x400,
	tokclsConstInteger = 0x400,
	tokclsConstReal = 0x401,
	tokclsConstString = 0x402,
	tokclsStringPart = 0x402,               // partial string ("....)
	tokclsConstMax = 0x410,

	// comments
	tokclsCommentMin = 0x500,
	tokclsCommentPart = 0x500,      // partial comment (/* ...)
	tokclsCommentMax = 0x510,

	// language dependent token class(es) start at 0x800 to 0xfff
	tokclsUserMin = 0x800,
	tokclsUserLast = 0xfff,
	tokclsUserMax = 0x1000,

	// mask to ignore all the bits in a token[class] that the lexer can use
	// for private status.  they will be masked off and ignored by clients
	// of the lexer.  A good use of this feature is to encode the real token
	// type in the lexer private portion (area is ~tokclsMask) when including
	// meta-token types (such as MFC/Wizard user token types) so that other
	// clients of the lexer can keep that information.
	tokclsUserMask = ~(tokclsUserMin - 1),
	tokclsMask = tokclsUserLast,

};


// NOTE:
// ========================================================================
// PLEASE LET sridharc KNOW IF YOU PLAN TO ADD/REMOVE A TOKEN FROM
// THE BELOW ENUM, SINCE HE IS DEPENDING UPON THIS ORDER FOR HIS TAG PROPERTY
// EDITING.  THANKS.
// ========================================================================
typedef enum tagElementTokens
{
	TokElem_Empty            = 0  	,  /* Empty    		*/
	TokElem_A				 = 1	,  /* A				*/
	TokElem_ADDRESS			 = 2	,  /* ADDRESS		*/
	TokElem_APPLET			 = 3	,  /* APPLET		*/
	TokElem_AREA			 = 4	,  /* AREA			*/
	TokElem_B				 = 5	,  /* B				*/
	TokElem_BASE			 = 6	,  /* BASE			*/
	TokElem_BASEFONT		 = 7	,  /* BASEFONT		*/
	TokElem_BGSOUND			 = 8	,  /* BGSOUND		*/
	TokElem_BIG				 = 9	,  /* BIG			*/
	TokElem_BLINK			 = 10	,  /* BLINK			*/
	TokElem_BLOCKQUOTE		 = 11	,  /* BLOCKQUOTE	*/
	TokElem_BODY			 = 12	,  /* BODY			*/
	TokElem_BR				 = 13	,  /* BR			*/
	TokElem_BUTTON			 = 14	,  /* BUTTON		*/
	TokElem_CAPTION			 = 15	,  /* CAPTION		*/
	TokElem_CENTER			 = 16	,  /* CENTER		*/
	TokElem_CITE			 = 17	,  /* CITE			*/
	TokElem_CODE			 = 18	,  /* CODE			*/
	TokElem_COL				 = 19	,  /* COL			*/
	TokElem_COLGROUP		 = 20	,  /* COLGROUP		*/
	TokElem_COMMENT			 = 21	,  /* COMMENT		*/
	TokElem_DD				 = 22	,  /* DD			*/
	TokElem_DFN				 = 23	,  /* DFN			*/
	TokElem_DIR				 = 24	,  /* DIR			*/
	TokElem_DIV				 = 25	,  /* DIV			*/
	TokElem_DL				 = 26	,  /* DL			*/
	TokElem_DT				 = 27	,  /* DT			*/
	TokElem_EM				 = 28	,  /* EM			*/
	TokElem_EMBED			 = 29	,  /* EMBED			*/
	TokElem_FIELDSET		 = 30	,  /* FIELDSET		*/
	TokElem_FONT			 = 31	,  /* FONT			*/
	TokElem_FORM			 = 32	,  /* FORM			*/
	TokElem_FRAME			 = 33	,  /* FRAME			*/
	TokElem_FRAMESET		 = 34	,  /* FRAMESET		*/
	TokElem_H1				 = 35	,  /* H1			*/
	TokElem_H2				 = 36	,  /* H2			*/
	TokElem_H3				 = 37	,  /* H3			*/
	TokElem_H4				 = 38	,  /* H4			*/
	TokElem_H5				 = 39	,  /* H5			*/
	TokElem_H6				 = 40	,  /* H6			*/
	TokElem_HEAD			 = 41	,  /* HEAD			*/
	TokElem_HR				 = 42	,  /* HR			*/
	TokElem_HTML			 = 43	,  /* HTML			*/
	TokElem_I				 = 44	,  /* I				*/
	TokElem_IFRAME			 = 45	,  /* IFRAME		*/
	TokElem_IMG				 = 46	,  /* IMG			*/
	TokElem_INPUT			 = 47	,  /* INPUT			*/
	TokElem_ISINDEX			 = 48	,  /* ISINDEX		*/
	TokElem_KBD				 = 49	,  /* KBD			*/
	TokElem_LABEL			 = 50	,  /* LABEL			*/
	TokElem_LEGEND			 = 51	,  /* LEGEND		*/
	TokElem_LI				 = 52	,  /* LI			*/
	TokElem_LINK			 = 53	,  /* LINK			*/
	TokElem_LISTING			 = 54	,  /* LISTING		*/
	TokElem_MAP				 = 55	,  /* MAP			*/
	TokElem_MARQUEE			 = 56	,  /* MARQUEE		*/
	TokElem_MENU			 = 57	,  /* MENU			*/
	TokElem_META			 = 58	,  /* META			*/
	TokElem_METADATA		 = 59	,  /* METADATA		*/
	TokElem_NOBR			 = 60	,  /* NOBR			*/
	TokElem_NOFRAMES		 = 61	,  /* NOFRAMES		*/
	TokElem_NOSCRIPT		 = 62	,  /* NOSCRIPT		*/
	TokElem_OBJECT			 = 63	,  /* OBJECT		*/
	TokElem_OL				 = 64	,  /* OL			*/
	TokElem_OPTION			 = 65	,  /* OPTION		*/
	TokElem_P				 = 66	,  /* P				*/
	TokElem_PARAM			 = 67	,  /* PARAM			*/
	TokElem_PLAINTEXT		 = 68	,  /* PLAINTEXT		*/
	TokElem_PRE				 = 69	,  /* PRE			*/
	TokElem_S				 = 70	,  /* S				*/
	TokElem_SAMP			 = 71	,  /* SAMP			*/
	TokElem_SCRIPT			 = 72	,  /* SCRIPT		*/
	TokElem_SELECT			 = 73	,  /* SELECT		*/
	TokElem_SMALL			 = 74	,  /* SMALL			*/
	TokElem_SPAN			 = 75	,  /* SPAN			*/
	TokElem_STRIKE			 = 76	,  /* STRIKE		*/
	TokElem_STRONG			 = 77	,  /* STRONG		*/
	TokElem_STYLE			 = 78	,  /* STYLE			*/
	TokElem_SUB				 = 79	,  /* SUB			*/
	TokElem_SUP				 = 80	,  /* SUP			*/
	TokElem_TABLE			 = 81	,  /* TABLE			*/
	TokElem_TBODY			 = 82	,  /* TBODY			*/
	TokElem_TD				 = 83	,  /* TD			*/
	TokElem_TEXTAREA		 = 84	,  /* TEXTAREA		*/
	TokElem_TFOOT			 = 85	,  /* TFOOT			*/
	TokElem_TH				 = 86	,  /* TH			*/
	TokElem_THEAD			 = 87	,  /* THEAD			*/
	TokElem_TITLE			 = 88	,  /* TITLE			*/
	TokElem_TR				 = 89	,  /* TR			*/
	TokElem_TT				 = 90	,  /* TT			*/
	TokElem_U				 = 91	,  /* U				*/
	TokElem_UL				 = 92	,  /* UL			*/
	TokElem_VAR				 = 93	,  /* VAR			*/
	TokElem_WBR				 = 94	,  /* WBR			*/
	TokElem_XMP				 = 95	  /* XMP			*/
} ElementTokens;
// NOTE:
// ========================================================================
// PLEASE LET sridharc KNOW IF YOU PLAN TO ADD/REMOVE A TOKEN FROM
// THE ABOVE ENUM, SINCE HE IS DEPENDING UPON THIS ORDER FOR HIS TAG PROPERTY
// ========================================================================

typedef enum tagAttributeTokens
{
	TokAttrib_Empty                         =0  ,   /*                      */
	TokAttrib_ACCESSKEY						=1    	,// ACCESSKEY
	TokAttrib_ACTION						=2    	,// ACTION
	TokAttrib_ALIGN							=3    	,// ALIGN
	TokAttrib_ALINK							=4    	,// ALINK
	TokAttrib_ALT							=5    	,// ALT
	TokAttrib_APPNAME						=6    	,// APPNAME
	TokAttrib_APPVERSION					=7    	,// APPVERSION
	TokAttrib_BACKGROUND					=8    	,// BACKGROUND
	TokAttrib_BACKGROUNDATTACHMENT			=9    	,// BACKGROUNDATTACHMENT
	TokAttrib_BACKGROUNDCOLOR				=10   	,// BACKGROUNDCOLOR
	TokAttrib_BACKGROUNDIMAGE				=11   	,// BACKGROUNDIMAGE
	TokAttrib_BACKGROUNDPOSITION			=12   	,// BACKGROUNDPOSITION
	TokAttrib_BACKGROUNDPOSITIONX			=13   	,// BACKGROUNDPOSITIONX
	TokAttrib_BACKGROUNDPOSITIONY			=14   	,// BACKGROUNDPOSITIONY
	TokAttrib_BACKGROUNDREPEAT				=15   	,// BACKGROUNDREPEAT
	TokAttrib_BALANCE						=16   	,// BALANCE
	TokAttrib_BEHAVIOR						=17   	,// BEHAVIOR
	TokAttrib_BGCOLOR						=18   	,// BGCOLOR
	TokAttrib_BGPROPERTIES					=19   	,// BGPROPERTIES
	TokAttrib_BORDER						=20   	,// BORDER
	TokAttrib_BORDERBOTTOM					=21   	,// BORDERBOTTOM
	TokAttrib_BORDERBOTTOMCOLOR				=22   	,// BORDERBOTTOMCOLOR
	TokAttrib_BORDERBOTTOMSTYLE				=23   	,// BORDERBOTTOMSTYLE
	TokAttrib_BORDERBOTTOMWIDTH				=24   	,// BORDERBOTTOMWIDTH
	TokAttrib_BORDERCOLOR					=25   	,// BORDERCOLOR
	TokAttrib_BORDERCOLORDARK				=26   	,// BORDERCOLORDARK
	TokAttrib_BORDERCOLORLIGHT				=27   	,// BORDERCOLORLIGHT
	TokAttrib_BORDERLEFT					=28   	,// BORDERLEFT
	TokAttrib_BORDERLEFTCOLOR				=29   	,// BORDERLEFTCOLOR
	TokAttrib_BORDERLEFTSTYLE				=30   	,// BORDERLEFTSTYLE
	TokAttrib_BORDERLEFTWIDTH				=31   	,// BORDERLEFTWIDTH
	TokAttrib_BORDERRIGHT					=32   	,// BORDERRIGHT
	TokAttrib_BORDERRIGHTCOLOR				=33   	,// BORDERRIGHTCOLOR
	TokAttrib_BORDERRIGHTSTYLE				=34   	,// BORDERRIGHTSTYLE
	TokAttrib_BORDERRIGHTWIDTH				=35   	,// BORDERRIGHTWIDTH
	TokAttrib_BORDERSTYLE					=36   	,// BORDERSTYLE
	TokAttrib_BORDERTOP						=37   	,// BORDERTOP
	TokAttrib_BORDERTOPCOLOR				=38   	,// BORDERTOPCOLOR
	TokAttrib_BORDERTOPSTYLE				=39   	,// BORDERTOPSTYLE
	TokAttrib_BORDERTOPWIDTH				=40   	,// BORDERTOPWIDTH
	TokAttrib_BORDERWIDTH					=41   	,// BORDERWIDTH
	TokAttrib_BOTTOMMARGIN					=42   	,// BOTTOMMARGIN
	TokAttrib_BREAKPOINT					=43   	,// BREAKPOINT
	TokAttrib_BUFFERDEPTH					=44   	,// BUFFERDEPTH
	TokAttrib_BUTTON						=45   	,// BUTTON
	TokAttrib_CANCELBUBBLE					=46   	,// CANCELBUBBLE
	TokAttrib_CELLPADDING					=47   	,// CELLPADDING
	TokAttrib_CELLSPACING					=48   	,// CELLSPACING
	TokAttrib_CENTER						=49   	,// CENTER
	TokAttrib_CHARSET						=50   	,// CHARSET
	TokAttrib_CHECKED						=51   	,// CHECKED
	TokAttrib_CLASS							=52   	,// CLASS
	TokAttrib_CLASSID						=53   	,// CLASSID
	TokAttrib_CLASSNAME						=54   	,// CLASSNAME
	TokAttrib_CLEAR							=55   	,// CLEAR
	TokAttrib_CLIP							=56   	,// CLIP
	TokAttrib_CODE							=57   	,// CODE
	TokAttrib_CODEBASE						=58   	,// CODEBASE
	TokAttrib_CODETYPE						=59   	,// CODETYPE
	TokAttrib_COLOR							=60   	,// COLOR
	TokAttrib_COLORDEPTH					=61   	,// COLORDEPTH
	TokAttrib_COLS							=62   	,// COLS
	TokAttrib_COLSPAN						=63   	,// COLSPAN
	TokAttrib_COMPACT						=64   	,// COMPACT
	TokAttrib_COMPLETE						=65   	,// COMPLETE
	TokAttrib_CONTENT						=66   	,// CONTENT
	TokAttrib_CONTROLS						=67   	,// CONTROLS
	TokAttrib_COOKIE						=68   	,// COOKIE
	TokAttrib_COOKIEENABLED					=69   	,// COOKIEENABLED
	TokAttrib_COORDS						=70   	,// COORDS
	TokAttrib_CSSTEXT						=71   	,// CSSTEXT
	TokAttrib_CTRLKEY						=72   	,// CTRLKEY
	TokAttrib_CURSOR						=73   	,// CURSOR
	TokAttrib_DATA							=74   	,// DATA
	TokAttrib_DECLARE						=75   	,// DECLARE
	TokAttrib_DATAFLD						=76   	,// DATAFLD
	TokAttrib_DATAFORMATAS					=77   	,// DATAFORMATAS
	TokAttrib_DATAPAGESIZE					=78   	,// DATAPAGESIZE
	TokAttrib_DATASRC						=79   	,// DATASRC
	TokAttrib_DEFAULTCHECKED				=80   	,// DEFAULTCHECKED
	TokAttrib_DEFAULTSELECTED				=81   	,// DEFAULTSELECTED
	TokAttrib_DEFAULTSTATUS					=82   	,// DEFAULTSTATUS
	TokAttrib_DEFAULTVALUE					=83   	,// DEFAULTVALUE
	TokAttrib_DIALOGARGUMENTS				=84   	,// DIALOGARGUMENTS
	TokAttrib_DIALOGHEIGHT					=85   	,// DIALOGHEIGHT
	TokAttrib_DIALOGLEFT					=86   	,// DIALOGLEFT
	TokAttrib_DIALOGTOP						=87   	,// DIALOGTOP
	TokAttrib_DIALOGWIDTH					=88   	,// DIALOGWIDTH
	TokAttrib_DIR							=89   	,// DIR
	TokAttrib_DIRECTION						=90   	,// DIRECTION
	TokAttrib_DISABLED						=91   	,// DISABLED
	TokAttrib_DISPLAY						=92   	,// DISPLAY
	TokAttrib_DOMAIN						=93   	,// DOMAIN
	TokAttrib_DYNSRC						=94   	,// DYNSRC
	TokAttrib_ENCODING						=95   	,// ENCODING
	TokAttrib_ENCTYPE						=96   	,// ENCTYPE
	TokAttrib_ENDSPAN						=97   	,// ENDSPAN
	TokAttrib_ENDSPAN__						=98   	,// ENDSPAN--
	TokAttrib_EVENT							=99   	,// EVENT
	TokAttrib_FACE							=100  	,// FACE
	TokAttrib_FGCOLOR						=101  	,// FGCOLOR
	TokAttrib_FILTER						=102  	,// FILTER
	TokAttrib_FONT							=103  	,// FONT
	TokAttrib_FONTFAMILY					=104  	,// FONTFAMILY
	TokAttrib_FONTSIZE						=105  	,// FONTSIZE
	TokAttrib_FONTSTYLE						=106  	,// FONTSTYLE
	TokAttrib_FONTVARIANT					=107  	,// FONTVARIANT
	TokAttrib_FONTWEIGHT					=108  	,// FONTWEIGHT
	TokAttrib_FOR							=109  	,// FOR
	TokAttrib_FORM							=110  	,// FORM
	TokAttrib_FRAME							=111  	,// FRAME
	TokAttrib_FRAMEBORDER					=112  	,// FRAMEBORDER
	TokAttrib_FRAMESPACING					=113  	,// FRAMESPACING
	TokAttrib_FROMELEMENT					=114  	,// FROMELEMENT
	TokAttrib_HASH							=115  	,// HASH
	TokAttrib_HEIGHT						=116  	,// HEIGHT
	TokAttrib_HIDDEN						=117  	,// HIDDEN
	TokAttrib_HOST							=118  	,// HOST
	TokAttrib_HOSTNAME						=119  	,// HOSTNAME
	TokAttrib_HREF							=120  	,// HREF
	TokAttrib_HSPACE						=121  	,// HSPACE
	TokAttrib_HTMLFOR						=122  	,// HTMLFOR
	TokAttrib_HTMLTEXT						=123  	,// HTMLTEXT
	TokAttrib_HTTPEQUIV						=124  	,// HTTPEQUIV
	TokAttrib_HTTP_EQUIV					=125  	,// HTTP-EQUIV
	TokAttrib_ID							=126  	,// ID
	TokAttrib_IN							=127  	,// IN
	TokAttrib_INDETERMINATE					=128  	,// INDETERMINATE
	TokAttrib_INDEX							=129  	,// INDEX
	TokAttrib_ISMAP							=130  	,// ISMAP
	TokAttrib_LANG							=131  	,// LANG
	TokAttrib_LANGUAGE						=132  	,// LANGUAGE
	TokAttrib_LEFTMARGIN					=133  	,// LEFTMARGIN
	TokAttrib_LENGTH						=134  	,// LENGTH
	TokAttrib_LETTERSPACING					=135  	,// LETTERSPACING
	TokAttrib_LINEHEIGHT					=136  	,// LINEHEIGHT
	TokAttrib_LINK							=137  	,// LINK
	TokAttrib_LINKCOLOR						=138  	,// LINKCOLOR
	TokAttrib_LISTSTYLE						=139  	,// LISTSTYLE
	TokAttrib_LISTSTYLEIMAGE				=140  	,// LISTSTYLEIMAGE
	TokAttrib_LISTSTYLEPOSITION				=141  	,// LISTSTYLEPOSITION
	TokAttrib_LISTSTYLETYPE					=142  	,// LISTSTYLETYPE
	TokAttrib_LOCATION						=143  	,// LOCATION
	TokAttrib_LOOP							=144  	,// LOOP
	TokAttrib_LOWSRC						=145  	,// LOWSRC
	TokAttrib_MAP							=146  	,// MAP
	TokAttrib_MARGIN						=147  	,// MARGIN
	TokAttrib_MARGINBOTTOM					=148  	,// MARGINBOTTOM
	TokAttrib_MARGINHEIGHT					=149  	,// MARGINHEIGHT
	TokAttrib_MARGINLEFT					=150  	,// MARGINLEFT
	TokAttrib_MARGINRIGHT					=151  	,// MARGINRIGHT
	TokAttrib_MARGINTOP						=152  	,// MARGINTOP
	TokAttrib_MARGINWIDTH					=153  	,// MARGINWIDTH
	TokAttrib_MAXLENGTH						=154  	,// MAXLENGTH
	TokAttrib_METHOD						=155  	,// METHOD
	TokAttrib_METHODS						=156  	,// METHODS
	TokAttrib_MIMETYPES						=157  	,// MIMETYPES
	TokAttrib_MULTIPLE						=158  	,// MULTIPLE
	TokAttrib_NAME							=159  	,// NAME
	TokAttrib_NOHREF						=160  	,// NOHREF
	TokAttrib_NORESIZE						=161  	,// NORESIZE
	TokAttrib_NOSHADE						=162  	,// NOSHADE
	TokAttrib_NOWRAP						=163  	,// NOWRAP
	TokAttrib_OBJECT						=164  	,// OBJECT
	TokAttrib_OFFSCREENBUFFERING			=165  	,// OFFSCREENBUFFERING
	TokAttrib_OFFSETHEIGHT					=166  	,// OFFSETHEIGHT
	TokAttrib_OFFSETLEFT					=167  	,// OFFSETLEFT
	TokAttrib_OFFSETPARENT					=168  	,// OFFSETPARENT
	TokAttrib_OFFSETTOP						=169  	,// OFFSETTOP
	TokAttrib_OFFSETWIDTH					=170  	,// OFFSETWIDTH
	TokAttrib_OFFSETX						=171  	,// OFFSETX
	TokAttrib_OFFSETY						=172  	,// OFFSETY
	TokAttrib_ONABORT						=173  	,// ONABORT
	TokAttrib_ONAFTERUPDATE					=174  	,// ONAFTERUPDATE
	TokAttrib_ONBEFOREUNLOAD				=175  	,// ONBEFOREUNLOAD
	TokAttrib_ONBEFOREUPDATE				=176  	,// ONBEFOREUPDATE
	TokAttrib_ONBLUR						=177  	,// ONBLUR
	TokAttrib_ONBOUNCE						=178  	,// ONBOUNCE
	TokAttrib_ONCHANGE						=179  	,// ONCHANGE
	TokAttrib_ONCLICK						=180  	,// ONCLICK
	TokAttrib_ONDATAAVAILABLE				=181  	,// ONDATAAVAILABLE
	TokAttrib_ONDATASETCHANGED				=182  	,// ONDATASETCHANGED
	TokAttrib_ONDATASETCOMPLETE				=183  	,// ONDATASETCOMPLETE
	TokAttrib_ONDBLCLICK					=184  	,// ONDBLCLICK
	TokAttrib_ONDRAGSTART					=185  	,// ONDRAGSTART
	TokAttrib_ONERROR						=186  	,// ONERROR
	TokAttrib_ONERRORUPDATE					=187  	,// ONERRORUPDATE
	TokAttrib_ONFILTERCHANGE				=188  	,// ONFILTERCHANGE
	TokAttrib_ONFINISH						=189  	,// ONFINISH
	TokAttrib_ONFOCUS						=190  	,// ONFOCUS
	TokAttrib_ONHELP						=191  	,// ONHELP
	TokAttrib_ONKEYDOWN						=192  	,// ONKEYDOWN
	TokAttrib_ONKEYPRESS					=193  	,// ONKEYPRESS
	TokAttrib_ONKEYUP						=194  	,// ONKEYUP
	TokAttrib_ONLOAD						=195  	,// ONLOAD
	TokAttrib_ONMOUSEOUT					=196  	,// ONMOUSEOUT
	TokAttrib_ONMOUSEOVER					=197  	,// ONMOUSEOVER
	TokAttrib_ONMOUSEUP						=198  	,// ONMOUSEUP
	TokAttrib_ONREADYSTATECHANGE			=199  	,// ONREADYSTATECHANGE
	TokAttrib_ONRESET						=200  	,// ONRESET
	TokAttrib_ONRESIZE						=201  	,// ONRESIZE
	TokAttrib_ONROWENTER					=202  	,// ONROWENTER
	TokAttrib_ONROWEXIT						=203  	,// ONROWEXIT
	TokAttrib_ONSCROLL						=204  	,// ONSCROLL
	TokAttrib_ONSELECT						=205  	,// ONSELECT
	TokAttrib_ONSELECTSTART					=206  	,// ONSELECTSTART
	TokAttrib_ONSUBMIT						=207  	,// ONSUBMIT
	TokAttrib_ONUNLOAD						=208  	,// ONUNLOAD
	TokAttrib_OPENER						=209  	,// OPENER
	TokAttrib_OUTERHTML						=210  	,// OUTERHTML
	TokAttrib_OUTERTEXT						=211  	,// OUTERTEXT
	TokAttrib_OUTLINE						=212  	,// OUTLINE
	TokAttrib_OVERFLOW						=213  	,// OVERFLOW
	TokAttrib_OWNINGELEMENT					=214  	,// OWNINGELEMENT
	TokAttrib_PADDING						=215  	,// PADDING
	TokAttrib_PADDINGBOTTOM					=216  	,// PADDINGBOTTOM
	TokAttrib_PADDINGLEFT					=217  	,// PADDINGLEFT
	TokAttrib_PADDINGRIGHT					=218  	,// PADDINGRIGHT
	TokAttrib_PADDINGTOP					=219  	,// PADDINGTOP
	TokAttrib_PAGEBREAKAFTER				=220  	,// PAGEBREAKAFTER
	TokAttrib_PAGEBREAKBEFORE				=221  	,// PAGEBREAKBEFORE
	TokAttrib_PALETTE						=222  	,// PALETTE
	TokAttrib_PARENT						=223  	,// PARENT
	TokAttrib_PARENTELEMENT					=224  	,// PARENTELEMENT
	TokAttrib_PARENTSTYLESHEET				=225  	,// PARENTSTYLESHEET
	TokAttrib_PARENTTEXTEDIT				=226  	,// PARENTTEXTEDIT
	TokAttrib_PARENTWINDOW					=227  	,// PARENTWINDOW
	TokAttrib_PATHNAME						=228  	,// PATHNAME
	TokAttrib_PIXELHEIGHT					=229  	,// PIXELHEIGHT
	TokAttrib_PIXELLEFT						=230  	,// PIXELLEFT
	TokAttrib_PIXELTOP						=231  	,// PIXELTOP
	TokAttrib_PIXELWIDTH					=232  	,// PIXELWIDTH
	TokAttrib_PLUGINS						=233  	,// PLUGINS
	TokAttrib_PLUGINSPAGE					=234  	,// PLUGINSPAGE
	TokAttrib_PORT							=235  	,// PORT
	TokAttrib_POSHEIGHT						=236  	,// POSHEIGHT
	TokAttrib_POSITION						=237  	,// POSITION
	TokAttrib_POSLEFT						=238  	,// POSLEFT
	TokAttrib_POSTOP						=239  	,// POSTOP
	TokAttrib_POSWIDTH						=240  	,// POSWIDTH
	TokAttrib_PROMPT						=241  	,// PROMPT
	TokAttrib_PROTOCOL						=242  	,// PROTOCOL
	TokAttrib_READONLY						=243  	,// READONLY
	TokAttrib_READYSTATE					=244  	,// READYSTATE
	TokAttrib_REASON						=245  	,// REASON
	TokAttrib_RECORDNUMBER					=246  	,// RECORDNUMBER
	TokAttrib_RECORDSET						=247  	,// RECORDSET
	TokAttrib_REF							=248  	,// REF
	TokAttrib_REFERRER						=249  	,// REFERRER
	TokAttrib_REL							=250  	,// REL
	TokAttrib_RETURNVALUE					=251  	,// RETURNVALUE
	TokAttrib_REV							=252  	,// REV
	TokAttrib_RIGHTMARGIN					=253  	,// RIGHTMARGIN
	TokAttrib_ROWS							=254  	,// ROWS
	TokAttrib_ROWSPAN						=255  	,// ROWSPAN
	TokAttrib_RULES							=256  	,// RULES
	TokAttrib_RUNAT							=257  	,// RUNAT
	TokAttrib_SCREENX						=258  	,// SCREENX
	TokAttrib_SCREENY						=259  	,// SCREENY
	TokAttrib_SCRIPTENGINE					=260  	,// SCRIPTENGINE
	TokAttrib_SCROLL						=261  	,// SCROLL
	TokAttrib_SCROLLAMOUNT					=262  	,// SCROLLAMOUNT
	TokAttrib_SCROLLDELAY					=263  	,// SCROLLDELAY
	TokAttrib_SCROLLHEIGHT					=264  	,// SCROLLHEIGHT
	TokAttrib_SCROLLING						=265  	,// SCROLLING
	TokAttrib_SCROLLLEFT					=266  	,// SCROLLLEFT
	TokAttrib_SCROLLTOP						=267  	,// SCROLLTOP
	TokAttrib_SCROLLWIDTH					=268  	,// SCROLLWIDTH
	TokAttrib_SEARCH						=269  	,// SEARCH
	TokAttrib_SELECTED						=270  	,// SELECTED
	TokAttrib_SELECTEDINDEX					=271  	,// SELECTEDINDEX
	TokAttrib_SELF							=272  	,// SELF
	TokAttrib_SHAPE							=273  	,// SHAPE
	TokAttrib_SHAPES						=274  	,// SHAPES
	TokAttrib_SHIFTKEY						=275  	,// SHIFTKEY
	TokAttrib_SIZE							=276  	,// SIZE
	TokAttrib_SPAN							=277  	,// SPAN
	TokAttrib_SOURCEINDEX					=278  	,// SOURCEINDEX
	TokAttrib_SRC							=279  	,// SRC
	TokAttrib_SRCELEMENT					=280  	,// SRCELEMENT
	TokAttrib_SRCFILTER						=281  	,// SRCFILTER
	TokAttrib_STANDBY						=282  	,// STANDBY
	TokAttrib_START							=283  	,// START
	TokAttrib_STARTSPAN						=284  	,// STARTSPAN
	TokAttrib_STATUS						=285  	,// STATUS
	TokAttrib_STYLE							=286  	,// STYLE
	TokAttrib_STYLEFLOAT					=287  	,// STYLEFLOAT
	TokAttrib_TABINDEX						=288  	,// TABINDEX
	TokAttrib_TAGNAME						=289  	,// TAGNAME
	TokAttrib_TARGET						=290  	,// TARGET
	TokAttrib_TEXT							=291  	,// TEXT
	TokAttrib_TEXTALIGN						=292  	,// TEXTALIGN
	TokAttrib_TEXTDECORATION				=293  	,// TEXTDECORATION
	TokAttrib_TEXTDECORATIONBLINK			=294  	,// TEXTDECORATIONBLINK
	TokAttrib_TEXTDECORATIONLINETHROUGH		=295  	,// TEXTDECORATIONLINETHROUGH
	TokAttrib_TEXTDECORATIONNONE			=296  	,// TEXTDECORATIONNONE
	TokAttrib_TEXTDECORATIONOVERLINE		=297  	,// TEXTDECORATIONOVERLINE
	TokAttrib_TEXTDECORATIONUNDERLINE		=298  	,// TEXTDECORATIONUNDERLINE
	TokAttrib_TEXTINDENT					=299  	,// TEXTINDENT
	TokAttrib_TEXTTRANSFORM					=300  	,// TEXTTRANSFORM
	TokAttrib_TITLE							=301  	,// TITLE
	TokAttrib_TOELEMENT						=302  	,// TOELEMENT
	TokAttrib_TOP							=303  	,// TOP
	TokAttrib_TOPMARGIN						=304  	,// TOPMARGIN
	TokAttrib_TRUESPEED						=305  	,// TRUESPEED
	TokAttrib_TYPE							=306  	,// TYPE
	TokAttrib_UPDATEINTERVAL				=307  	,// UPDATEINTERVAL
	TokAttrib_URL							=308  	,// URL
	TokAttrib_URN							=309  	,// URN
	TokAttrib_USEMAP						=310  	,// USEMAP
	TokAttrib_USERAGENT						=311  	,// USERAGENT
	TokAttrib_VALIGN						=312  	,// VALIGN
	TokAttrib_VALUE							=313  	,// VALUE
	TokAttrib_VERSION						=314  	,// VERSION
	TokAttrib_VERTICALALIGN					=315  	,// VERTICALALIGN
	TokAttrib_VIEWASTEXT					=316  	,// VIEWASTEXT
	TokAttrib_VISIBILITY					=317  	,// VISIBILITY
	TokAttrib_VLINK							=318  	,// VLINK
	TokAttrib_VLINKCOLOR					=319  	,// VLINKCOLOR
	TokAttrib_VOLUME						=320  	,// VOLUME
	TokAttrib_VRML							=321  	,// VRML
	TokAttrib_VSPACE						=322  	,// VSPACE
	TokAttrib_WIDTH							=323  	,// WIDTH
	TokAttrib_WRAP							=324  	,// WRAP
	TokAttrib_X								=325  	,// X
	TokAttrib_Y								=326  	,// Y
	TokAttrib_ZINDEX						=327  	// ZINDEX

} AttributeTokens;

typedef enum tagTagTokens
{
	TokTag_START 	=	1,	/* <  	*/
	TokTag_END 		=	2,	/* </ 	*/
	TokTag_CLOSE 	=	3,	/* >  	*/
	TokTag_BANG		=	4,	/* <! 	*/
	TokTag_PI 		=	5,	/* <? 	*/
	TokTag_SSSOPEN	=	6, 	/* <% 	*/
	TokTag_SSSCLOSE	=	7, 	/* %> 	*/
	TokTag_SSSOPEN_TRIEDIT	=	8, 	/* <% 	inside <script block>*/
	TokTag_SSSCLOSE_TRIEDIT	=	9 	/* %> 	inside <script block>*/
} TagTokens;

enum HtmlToken
{
    tokUNKNOWN = tokclsError,
    tokIDENTIFIER = tokclsIdentMin,     // identifier/plain text
    tokNEWLINE = tokclsUserMin,
	//
	// colored HTML items
	//
    tokElem,     // element name
    tokAttr,     // attribute name
	tokValue,    // attribute value
	tokComment,  // comment
    tokEntity,   // entity reference: e.g. "&nbsp;"
	tokTag,      // tag delimiter
	tokString,   // string
	tokSpace,    // whitespace and unrecognized text in a tag
	tokOp,       // operator
	tokSSS,      // server-side script <%...%>
	//
	// parsed HTML and SGML items - tokens folded with items above
	//
	tokName,     // NAMETOKEN
	tokNum,      // NUMTOKEN
	tokParEnt,   // parameter entity: e.g. "%name;"
	tokResName,  // reserved name
	//
	// operators - colors folded with tokOp above
	//
	tokOP_MIN,
	tokOpDash = tokOP_MIN,         // -
	tokOP_SINGLE,
	tokOpQuestion = tokOP_SINGLE,  // ?
	tokOpComma,                    // ,
	tokOpPipe,                     // |
	tokOpPlus,                     // +
	tokOpEqual,                    // =
	tokOpStar,                     // *
	tokOpAmp,                      // &
	tokOpCent,                     // %
	tokOpLP,                       // (
	tokOpRP,                       // )
	tokOpLB,                       // [
	tokOpRB,                       // ]
    tokOP_MAX,                     // token op MAX

    tokEOF
};

// the state of lexical analyser
//
// We're generally in one of two states:
// 1.  scanning text
// 2.  scanning tag info
//
// Within these states, the lexer can be in several substates.
//
// Text substates:
//
//      inText       HTML text content -- process markup
//      inPLAINTEXT  after a <PLAINTEXT> tag - remainder of file is not HTML
//      inCOMMENT    COMMENT content -- suppress all markup but </COMMENT>
//               color text as comment
//      inXMP        XMP content -- suppress all markup but </XMP>
//      inLISTING    LISTING content -- suppress all markup but </LISTING>
//		inSCRIPT	 SCRIPT content -- colorize with script engine
//
// Tag substates:
//
// inTag       inside a tag < ... >
// inBangTag   inside an SGML MDO tag <! ... >
// inPITag     inside an SGML Prcessing Instruction tag <? ... >
// inHTXTag    inside an ODBC HTML Extension template tag <% ... %>
// inEndTag    inside an end tag </name>
// inAttribute expecting an attribute
// inValue     expecting an attribute value (right of =)
// inComment   inside a comment
// inString        inside a " string, terminated by "
// inStringA   inside a ' (Alternate) string, terminated by '
//
enum HtmlLexState
{
	// tag types
	inTag        = 0x00000001, // <  ... >
	inBangTag    = 0x00000002, // <! ... >
	inPITag      = 0x00000004, // <? ... >
	inHTXTag     = 0x00000008, // <% ... %>
	inEndTag         = 0x00000010, // </ ... >

	// tag scanning states
	inAttribute  = 0x00000020,
	inValue      = 0x00000040,

	inComment    = 0x00000080,
	inString     = 0x00000100,
	inStringA    = 0x00000200,
	inScriptText = 0x00000400,
	inNestedQuoteinSSS= 0x00000800, // e.g. attr="<%if something Response.Write("X")%>"

	// text content model states
	inPLAINTEXT  = 0x00001000,
	inCOMMENT    = 0x00002000,
	inXMP        = 0x00004000,
	inLISTING    = 0x00008000,
	inSCRIPT	 = 0x00010000,

	// sublanguages
	inVariant    = 0x00F00000, // mask for sublang index
	inHTML2      = 0x00000000,
	inIExplore2  = 0x00100000,
	inIExplore3  = 0x00200000,

	//  script languages
	inJavaScript = 0x01000000,
	inVBScript   = 0x02000000,
	inServerASP  = 0x04000000, // in triedit's special script (serverside->clientside conversion)

};

// masks for subsets of the state
// These masks will not show up in the generated file
// Just copy paste these into your file.
#define INTAG (inTag|inBangTag|inPITag|inHTXTag|inEndTag)
#define INSTRING (inString|inStringA)
#define TAGMASK (INTAG|inAttribute|inValue|inComment|INSTRING)
#define TEXTMASK (inPLAINTEXT|inCOMMENT|inXMP|inLISTING)
#define STATEMASK (TAGMASK|TEXTMASK)

#endif __INC_TOKEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\tokhtml.h ===
// tokhtml.h - Tokens and lex state for HTML
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Include lex.h before including this file.
//

#ifndef __TOKHTML_H__
#define __TOKHTML_H__

#if 0
// Moved to the IDL
enum HtmlToken
{
    tokUNKNOWN = tokclsError,
    tokIDENTIFIER = tokclsIdentMin,     // identifier/plain text
    tokNEWLINE = tokclsUserMin,
	//
	// colored HTML items
	//
    tokElem,     // element name
    tokAttr,     // attribute name
	tokValue,    // attribute value
	tokComment,  // comment
    tokEntity,   // entity reference: e.g. "&nbsp;"
	tokTag,      // tag delimiter
	tokString,   // string
	tokSpace,    // whitespace and unrecognized text in a tag
	tokOp,       // operator
	tokSSS,      // server-side script <%...%>
	//
	// parsed HTML and SGML items - tokens folded with items above
	//
	tokName,     // NAMETOKEN
	tokNum,      // NUMTOKEN
	tokParEnt,   // parameter entity: e.g. "%name;"
	tokResName,  // reserved name
	//
	// operators - colors folded with tokOp above
	//
	tokOP_MIN,
	tokOpDash = tokOP_MIN,         // -
	tokOP_SINGLE,
	tokOpQuestion = tokOP_SINGLE,  // ?
	tokOpComma,                    // ,
	tokOpPipe,                     // |
	tokOpPlus,                     // +
	tokOpEqual,                    // =
	tokOpStar,                     // *
	tokOpAmp,                      // &
	tokOpCent,                     // %
	tokOpLP,                       // (
	tokOpRP,                       // )
	tokOpLB,                       // [
	tokOpRB,                       // ]
    tokOP_MAX,                     // token op MAX

    tokEOF
};

// the state of lexical analyser
//
// We're generally in one of two states:
// 1.  scanning text
// 2.  scanning tag info
//
// Within these states, the lexer can be in several substates.
//
// Text substates:
//
// 	inText       HTML text content -- process markup
//	inPLAINTEXT  after a <PLAINTEXT> tag - remainder of file is not HTML
//	inCOMMENT    COMMENT content -- suppress all markup but </COMMENT>
//               color text as comment
//	inXMP        XMP content -- suppress all markup but </XMP>
//	inLISTING    LISTING content -- suppress all markup but </LISTING>
//	inSCRIPT	 SCRIPT content -- color using script engine.
//
// Tag substates:
//
// inTag       inside a tag < ... >
// inBangTag   inside an SGML MDO tag <! ... >
// inPITag     inside an SGML Prcessing Instruction tag <? ... >
// inHTXTag    inside an ODBC HTML Extension template tag <% ... %>
// inEndTag    inside an end tag </name>
// inAttribute expecting an attribute
// inValue     expecting an attribute value (right of =)
// inComment   inside a comment
// inString	   inside a " string, terminated by "
// inStringA   inside a ' (Alternate) string, terminated by '
//
enum HtmlLexState
{
	// tag types
	inTag        = 0x00000001, // <  ... >
	inBangTag    = 0x00000002, // <! ... >
	inPITag      = 0x00000004, // <? ... >
	inHTXTag     = 0x00000008, // <% ... %>
	inEndTag	 = 0x00000010, // </ ... >

	// tag scanning states
	inAttribute  = 0x00000020,
	inValue      = 0x00000040,

	inComment    = 0x00000080,
	inString     = 0x00000100,
	inStringA    = 0x00000200,

	// text content model states
	inPLAINTEXT  = 0x00001000,
	inCOMMENT    = 0x00002000,
	inXMP        = 0x00004000,
	inLISTING    = 0x00008000,
	inSCRIPT     = 0x00010000,

	// sublanguages
	inVariant    = 0x00F00000, // mask for sublang index
	inHTML2      = 0x00000000,
	inIExplore2  = 0x00100000,
	inIExplore3  = 0x00200000,

	//  script languages
	inJavaScript = 0x01000000,
	inVBScript   = 0x02000000,

};

// masks for subsets of the state
#define INTAG (inTag|inBangTag|inPITag|inHTXTag|inEndTag)
#define INSTRING (inString|inStringA)
#define TAGMASK (INTAG|inAttribute|inValue|inComment|INSTRING)
#define TEXTMASK (inPLAINTEXT|inCOMMENT|inXMP|inLISTING|inSCRIPT)
#define STATEMASK (TAGMASK|TEXTMASK)

#endif


// convert state <-> sublang index
inline DWORD SubLangIndexFromLxs(DWORD lxs) { return (lxs & inVariant) >> 20UL; }
inline DWORD LxsFromSubLangIndex(DWORD isl) { return (isl << 20UL) & inVariant; }

#endif // __TOKHTML_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\trace.h ===
/****************************************************************************
*
* Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
*
*
*
*
*
*
*
****************************************************************************/

#ifndef __TRACE_H__
#define __TRACE_H__

#ifdef _DEBUG
    void __cdecl Trace(LPSTR lprgchFormat, ...);
#else
    inline void __cdecl Trace(LPSTR /*lprgchFormat*/, ...) {}
#endif //_DEBUG

#endif //__TRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\triedcid.h ===
// triedcid.h : Command IDs for TriEdit's IOleCommandTarget
// Copyright 1998-1999 Microsoft Corporation.  All rights reserved.

#ifndef __TRIEDCID_H__
#define __TRIEDCID_H__

// GUID_TriEditCommandGroup {2582F1C0-084E-11d1-9A0E-006097C9B344}

#define IDM_TRIED_NUDGE_ELEMENT             2   //[in,VT_BYREF VARIANT.byref=LPPOINT]
#define IDM_TRIED_SET_ALIGNMENT             3   //[in,VT_BYREF VARIANT.byref=LPPOINT]
#define IDM_TRIED_MAKE_ABSOLUTE             4
#define IDM_TRIED_LOCK_ELEMENT              5
#define IDM_TRIED_SEND_TO_BACK              6
#define IDM_TRIED_BRING_TO_FRONT            7
#define IDM_TRIED_SEND_BACKWARD             8
#define IDM_TRIED_BRING_FORWARD             9
#define IDM_TRIED_SEND_BELOW_TEXT          10 
#define IDM_TRIED_BRING_ABOVE_TEXT         11
#define IDM_TRIED_CONSTRAIN                12   //[in,VT_BOOL]
#define IDM_TRIED_ABSOLUTE_DROP_MODE       13   //[in,VT_BOOL]
#define IDM_TRIED_INSERTROW                14
#define IDM_TRIED_INSERTCOL                15
#define IDM_TRIED_DELETEROWS               16
#define IDM_TRIED_DELETECOLS               17
#define IDM_TRIED_MERGECELLS               18
#define IDM_TRIED_SPLITCELL                19
#define IDM_TRIED_INSERTCELL               20
#define IDM_TRIED_DELETECELLS              21
#define IDM_TRIED_INSERTTABLE              22   //[in, VT_ARRAY]
#define IDM_TRIED_ACTIVATEACTIVEXCONTROLS  23
#define IDM_TRIED_ACTIVATEAPPLETS          24
#define IDM_TRIED_ACTIVATEDTCS             25
#define IDM_TRIED_BACKCOLOR                26
#define IDM_TRIED_BLOCKFMT                 27
#define IDM_TRIED_BOLD                     28
#define IDM_TRIED_BROWSEMODE               29
#define IDM_TRIED_COPY                     30
#define IDM_TRIED_CUT                      31
#define IDM_TRIED_DELETE                   32
#define IDM_TRIED_EDITMODE                 33
#define IDM_TRIED_FIND                     34
#define IDM_TRIED_FONT                     35
#define IDM_TRIED_FONTNAME                 36
#define IDM_TRIED_FONTSIZE                 37
#define IDM_TRIED_FORECOLOR                38
#define IDM_TRIED_GETBLOCKFMTS             39
#define IDM_TRIED_HYPERLINK                40
#define IDM_TRIED_IMAGE                    41
#define IDM_TRIED_INDENT                   42
#define IDM_TRIED_ITALIC                   43
#define IDM_TRIED_JUSTIFYCENTER            44
#define IDM_TRIED_JUSTIFYLEFT              45
#define IDM_TRIED_JUSTIFYRIGHT             46
#define IDM_TRIED_ORDERLIST                47
#define IDM_TRIED_OUTDENT                  48
#define IDM_TRIED_PASTE                    50
#define IDM_TRIED_PRINT                    51
#define IDM_TRIED_REDO                     52
#define IDM_TRIED_REMOVEFORMAT             53
#define IDM_TRIED_SELECTALL                54
#define IDM_TRIED_SHOWBORDERS              55
#define IDM_TRIED_SHOWDETAILS              56
#define IDM_TRIED_UNDERLINE                57
#define IDM_TRIED_UNDO                     58
#define IDM_TRIED_UNLINK                   59
#define IDM_TRIED_UNORDERLIST              60
#define IDM_TRIED_DOVERB                   61

//WARNING WARNING WARNING!!! Don't forget to modify IDM_TRIED_LAST_CID
//when you add new Command IDs

#define IDM_TRIED_LAST_CID             IDM_TRIED_DOVERB

//These are old command IDs that are here for backward compatibility
//We don't recommend using these any more
#define IDM_TRIED_IS_1D_ELEMENT         0   //[out,VT_BOOL]
#define IDM_TRIED_IS_2D_ELEMENT         1   //[out,VT_BOOL]
#define IDM_TRIED_SEND_TO_FRONT         IDM_TRIED_BRING_TO_FRONT
#define IDM_TRIED_SEND_FORWARD          IDM_TRIED_BRING_FORWARD
#define IDM_TRIED_SEND_BEHIND_1D        IDM_TRIED_SEND_BELOW_TEXT
#define IDM_TRIED_SEND_FRONT_1D         IDM_TRIED_BRING_ABOVE_TEXT
#define IDM_TRIED_SET_2D_DROP_MODE      IDM_TRIED_ABSOLUTE_DROP_MODE

#endif //__TRIEDCID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\undo.h ===
// undo.h
// Undo manager functions
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved

#ifndef __UNDO_H__
#define __UNDO_H__

// {6501DC80-12A6-11d1-9A15-006097C9B344}
DEFINE_GUID(UID_TRIEDIT_UNDO, 
0x6501dc80, 0x12a6, 0x11d1, 0x9a, 0x15, 0x0, 0x60, 0x97, 0xc9, 0xb3, 0x44);

#define cUndoPackMax		1024

//Add a constant when creating new undoable objects
#define TRIEDIT_UNDO_DRAG	0
#define TRIEDIT_UNDO_PACK	1

//Use this method to add undoable objects to Trident's stack
HRESULT AddUndoUnit(IUnknown* punkTrident, IOleUndoUnit* pioleUndoUnit);


class CUndo : public IOleUndoUnit
{
protected:
    ULONG m_cRef;
    BOOL m_fUndo;

public:
    CUndo();
    virtual ~CUndo();

    //IUnknown
    STDMETHOD (QueryInterface)(REFIID riid, LPVOID* ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //IOleUndoUnit
    STDMETHOD (Do)(IOleUndoManager *pUndoManager) PURE;
    STDMETHOD (GetDescription)(BSTR *pBstr) PURE;
    STDMETHOD (GetUnitType)(CLSID *pClsid, LONG *plID) PURE;
    STDMETHOD (OnNextAdd)(void) PURE;
};

class CUndoDrag : public CUndo
{
protected:
    IHTMLStyle* m_pihtmlStyle;
    POINT m_ptOrig;
    POINT m_ptMove;

public:
    CUndoDrag(IHTMLStyle* pihtmlStyle, POINT m_ptOrig, POINT m_ptMove);
    virtual ~CUndoDrag();

    //IOleUndoUnit
    STDMETHOD (Do)(IOleUndoManager *pUndoManager);
    STDMETHOD (GetDescription)(BSTR *pBstr);
    STDMETHOD (GetUnitType)(CLSID *pClsid, LONG *plID);
    STDMETHOD (OnNextAdd)(void);
};

class CUndoPackUnit : public CUndo
{
protected:
    ULONG m_cRef;
    CComPtr<IOleUndoUnit> m_rgUndo[cUndoPackMax]; 
    
public:
    CUndoPackUnit() {};
    virtual ~CUndoPackUnit(){};

    //IOleUndoUnit
    STDMETHOD (Do)(IOleUndoManager *pUndoManager);
    STDMETHOD (GetDescription)(BSTR *pBstr);
    STDMETHOD (GetUnitType)(CLSID *pClsid, LONG *plID);
    STDMETHOD (OnNextAdd)(void);

    HRESULT PackUndo(ULONG indexStartPacking, IUnknown *pUnkTrident);
};

class CUndoPackManager
{
protected:
    CComPtr<IUnknown> m_srpUnkTrident;
    ULONG m_indexStartPacking;
    BOOL m_fPacking;
    
public:
    CUndoPackManager(IUnknown* pUnkTrident)
            { m_srpUnkTrident=pUnkTrident; 
              m_indexStartPacking=0;
              m_fPacking=FALSE;
             };
             
    virtual ~CUndoPackManager();

    HRESULT Start(void);
    HRESULT End(void);
};
#endif //__UNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\util.h ===
// util.h : Utility inlines/functions
// Copyright (c)1999 Microsoft Corporation, All Rights Reserved
// added during 64 bit port of triedit.

// All throughout the triedit code, we assume that 
// the size of the document is not going to exceed
// 2GB. We assert the fact when we open the document
// in filter.cpp as well. If at later point, we do exceed 
// the document size of 2GB, we need to change this too.

// Safe conversion of pointer differences.

#ifndef __UTIL_H_
#define __UTIL_H_

inline WORD SAFE_PTR_DIFF_TO_WORD(SIZE_T lptrDiff)
{
    _ASSERTE(lptrDiff <= USHRT_MAX);
    return((WORD)lptrDiff);
};
inline WORD SAFE_INT_DIFF_TO_WORD(int iDiff)
{
    _ASSERTE(iDiff <= USHRT_MAX);
    return((WORD)iDiff);
};
inline int SAFE_PTR_DIFF_TO_INT(SIZE_T lptrDiff)
{
    _ASSERTE(lptrDiff <= UINT_MAX);
    return((int)lptrDiff);
};
inline DWORD SAFE_INT64_TO_DWORD(SIZE_T iValue)
{
    _ASSERTE(iValue <= UINT_MAX);
    return((DWORD)iValue);
};
#endif __UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\triedit.cpp ===
// triedit.cpp : Implementation of DLL Exports.
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f trieditps.mk in the project directory.

#include "stdafx.h"

#include <initguid.h>

#include "resource.h"
#include "triedit.h"
#include "triedcid.h"       //IOleCommandTarget CIDs for TriEdit
#include "htmparse.h"
#include "Document.h"
#include "undo.h"
#include "triedit_i.c"

CComModule _Module;

static void SpikeSharedFileCount ();

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_TriEditDocument, CTriEditDocument)
	OBJECT_ENTRY(CLSID_TriEditParse, CTriEditParse)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	SpikeSharedFileCount ();

	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;
    ITypeLib *  pTypeLib;
    TLIBATTR *  pTypeLibAttr;

	_Module.UnregisterServer();

	// Ideally, we want to fix this using ::GetModuleFileName()
	// but at this point, we want to keep changes to minimal. (1/14/99)
#ifdef _DEBUG
    hr = LoadTypeLib(L"triedit.dll", &pTypeLib);
#else
    hr = LoadTypeLib(L"triedit.dll", &pTypeLib);
#endif

    _ASSERTE(hr == S_OK);
    
    if (hr == S_OK)
    {
        if (pTypeLib->GetLibAttr(&pTypeLibAttr) == S_OK)
        {
            hr = UnRegisterTypeLib(pTypeLibAttr->guid, pTypeLibAttr->wMajorVerNum,
                    pTypeLibAttr->wMinorVerNum, pTypeLibAttr->lcid,
                    pTypeLibAttr->syskind);
            _ASSERTE(hr == S_OK);
    
            pTypeLib->ReleaseTLibAttr(pTypeLibAttr);
        }
        pTypeLib->Release();
    }

    return S_OK;
}

//	Because we've changed from a shared component to a system component, and we're now
//	installed by IE using RollBack rather than reference counting, a serious bug
//	occurs if we're installed once under IE4, IE5 is installed, and the original
//	product is uninstalled.  (We're deleted.  Bug 23681.)
//	This crude but effective routine spikes our reference count to 10000.
//	It doesn't matter so much where we're installed NOW, it matters where the shared
//	component was, or might be, installed.  Even if it's a different copy, the
//	DLL will be unregistered when its reference count is decremented to zero.
//
static void SpikeSharedFileCount ()
{
	CRegKey	keyShared;
	CRegKey	keyCurVer;
	HRESULT	hr = S_OK;

	hr = keyCurVer.Open ( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion" ) );
	_ASSERTE ( SUCCEEDED ( hr ) );

	if ( FAILED ( hr ) )
	{
		return;	// There's nothing we can do.
	}

	hr = keyShared.Open ( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls") );
	
	// We expect there to be a SharedDLLs key, but it's possible that there is none.
	if ( FAILED ( hr ) )
	{
		hr = keyShared.Create ( keyCurVer, TEXT("SharedDlls") );
	}

	_ASSERT ( SUCCEEDED ( hr ) );
	if ( SUCCEEDED ( hr ) )
	{
		TCHAR	tszPath[_MAX_PATH];
		TCHAR	tszMod[_MAX_PATH];
		DWORD	cchPath	= _MAX_PATH;
		
		// set tszPath to be an empty string in case the QueryValue fails
		tszPath[0]=0;

		// Build the string X:\Program Files\Common Files\Microsoft Shared\Triedit\dhtmled.ocx
		hr = keyCurVer.QueryValue ( tszPath, TEXT("CommonFilesDir"), &cchPath );
		if ( SUCCEEDED ( hr ) )
		{
			_tcscat ( tszPath, TEXT("\\Microsoft Shared\\Triedit\\") );
			
			// This routine gets the full path name of this DLL.  It SHOULD be the same
			// as the path we're constructing, but that could change in the future, so
			// truncate all but the bare file name.
			if ( 0 != GetModuleFileName ( _Module.GetModuleInstance(), tszMod, _MAX_PATH ) )
			{
				_tcsrev ( tszMod );				// Reverse the string
				_tcstok ( tszMod, TEXT("\\") );	// This replaces the first backslash with a \0.
				_tcsrev ( tszMod );
				_tcscat ( tszPath, tszMod );

				hr = keyShared.SetValue ( 10000, tszPath );
			}
		}
		hr = keyShared.Close ();
	}
	keyCurVer.Close ();
}


#ifdef _ATL_STATIC_REGISTRY
#pragma warning(disable: 4100 4189)	// Necessary for ia64 build
#include <statreg.h>
#include <statreg.cpp>
#pragma warning(default: 4100 4189)	// Necessary for ia64 build
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\undo.cpp ===
//------------------------------------------------------------------------------
// undo.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Undo support routines for TriEdit
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include <ocidl.h>

#include "undo.h"
#include "triedit.h"
#include "document.h"

///////////////////////////////////////////////////////////////////////////////
//
// AddUndoUnit
//
// Add the given undo unit to the given Trident instance. Return S_OK
// or a Trident error code.
//

HRESULT AddUndoUnit(IUnknown* punkTrident, IOleUndoUnit* pioleUndoUnit)
{
    HRESULT hr = E_FAIL;
    IServiceProvider* piservProv;
    IOleUndoManager* pioleUndoManager;
    
    if (punkTrident && pioleUndoUnit)
    {
        hr = punkTrident->QueryInterface(IID_IServiceProvider, (LPVOID*)&piservProv);

        if (SUCCEEDED(hr))
        {
            _ASSERTE(piservProv);
            hr = piservProv->QueryService(IID_IOleUndoManager,
                    IID_IOleUndoManager, (LPVOID*)&pioleUndoManager);

            if (SUCCEEDED(hr))
            {
                _ASSERTE(pioleUndoManager);
                hr = pioleUndoManager->Add(pioleUndoUnit);
                _ASSERTE(SUCCEEDED(hr));
                pioleUndoManager->Release();
            }
            piservProv->Release();
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// EmptyUndoRedoStack
//
// If fUndo is TRUE, discard all undo items from the given undo manager.
// If fUndo is FALSE, discard all redo items from the given undo manager
// Return S_OK if all goes well, or a Trident error code otherwise.
//

HRESULT EmptyUndoRedoStack(BOOL fUndo, IOleUndoManager *pUndoManager)
{
	CComPtr<IEnumOleUndoUnits> srpEnum;
    CComPtr<IOleUndoUnit> srpcd;
    ULONG cFetched=0, cTotal=0;
	HRESULT hr = E_FAIL;
	
    if (fUndo)
    {
		if (FAILED(hr = pUndoManager->EnumUndoable(&srpEnum)))
			goto Fail;
	}
	else
	{
		if (FAILED(hr = pUndoManager->EnumRedoable(&srpEnum)))
			goto Fail;
	}
	

    while (SUCCEEDED(srpEnum->Next(1, &srpcd, &cFetched))) 
    {
        _ASSERTE(cFetched <=1);
        if (srpcd == NULL)
            break;
            
        cTotal++;
        srpcd.Release();
    }

	// get the one on top of the stack and discard from that
    if (cTotal > 0)
    {
    	if (FAILED(hr = srpEnum->Reset()))
        	goto Fail; 
    	if (FAILED(hr = srpEnum->Skip(cTotal-1)))
        	goto Fail;

    	srpcd.Release();
    	if (FAILED(hr = srpEnum->Next(1, &srpcd, &cFetched)))
        	goto Fail;

		_ASSERTE(cFetched ==1);
		
    	if (FAILED(hr = pUndoManager->DiscardFrom(srpcd)))
        	goto Fail;
	}

Fail:
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// GetUndoManager
//
// Obtain and return (under *ppOleUndoManager) the IOleUndoManager
// associated with the given Trident instance. Return S_OK if a 
// manager was returned; E_FAIL otherwise.
//

HRESULT GetUndoManager(IUnknown* punkTrident, IOleUndoManager **ppOleUndoManager)
{
   HRESULT hr = E_FAIL;
   CComPtr<IServiceProvider> srpiservProv;
   CComPtr<IOleUndoManager> srpioleUndoManager;

   _ASSERTE(ppOleUndoManager != NULL);
   _ASSERTE(punkTrident != NULL);
   if (punkTrident)
    {
        hr = punkTrident->QueryInterface(IID_IServiceProvider, (LPVOID*)&srpiservProv);

        if (SUCCEEDED(hr))
        {
            _ASSERTE(srpiservProv);
            if (SUCCEEDED(hr = srpiservProv->QueryService(IID_IOleUndoManager,
                    IID_IOleUndoManager, (LPVOID*)&srpioleUndoManager)))
            {
                *ppOleUndoManager = srpioleUndoManager;
                (*ppOleUndoManager)->AddRef();
            }
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndo::CUndo
// CUndo::~Undo
//
// Simple constructor and destructor for the CUndo class. 
//

CUndo::CUndo()
{
    m_cRef = 1;
    m_fUndo = TRUE;

}

CUndo::~CUndo()
{
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndo::QueryInterface (IUnknown method)
// CUndo::AddRef (IUnknown method)
// CUndo::Release (IUnknown method)
//
// Implementations of the three IUnknown methods.
//

STDMETHODIMP CUndo::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    if (!ppvObject) 
        return E_POINTER;
    if (IsEqualGUID(riid, IID_IUnknown))
        *ppvObject = (IUnknown*)this;
    else
    if (IsEqualGUID(riid, IID_IOleUndoUnit))
        *ppvObject = (IOleUndoUnit*)this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CUndo::AddRef(void)
{
    return InterlockedIncrement((LONG*)&m_cRef);
}

STDMETHODIMP_(ULONG) CUndo::Release(void)
{
    ULONG cRef = InterlockedDecrement((LONG*)&m_cRef);
    if (!cRef)
        delete this;
    return cRef;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::CUndoDrag
// CUndoDrag::~CUndoDrag
//
// Constructor for an object which can undo the drag of an HTML element.
//

CUndoDrag::CUndoDrag(IHTMLStyle* pihtmlStyle, POINT ptOrig, POINT ptMove)
{
    m_pihtmlStyle = pihtmlStyle;
    if (m_pihtmlStyle)
        m_pihtmlStyle->AddRef();
    m_ptOrig = ptOrig;
    m_ptMove = ptMove;
}

CUndoDrag::~CUndoDrag()
{
    SAFERELEASE(m_pihtmlStyle);
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::Do (IOleUndoUnit method)
//
// Do or undo dragging of an HTML element from place to place. Set or
// restore the item's position. Return S_OK.
//

STDMETHODIMP CUndoDrag::Do(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;
    if (pUndoManager)
    {
        hr = pUndoManager->Add(this);        
    }
    if (m_pihtmlStyle)
    {
        // We do a put_pixelLeft(-1) and put_pixelTop(-1) below in order
        // to work around a Trident problem.  Sometimes they don't think
        // that anything has changed - these calls below fool them into
        // thinking that the values have changed.
        if (m_fUndo)
        {
            m_pihtmlStyle->put_pixelLeft(-1);
            m_pihtmlStyle->put_pixelLeft(m_ptOrig.x);
            m_pihtmlStyle->put_pixelTop(-1);
            m_pihtmlStyle->put_pixelTop(m_ptOrig.y);
        }
        else
        {
            m_pihtmlStyle->put_pixelLeft(-1);
            m_pihtmlStyle->put_pixelLeft(m_ptMove.x);
            m_pihtmlStyle->put_pixelTop(-1);
            m_pihtmlStyle->put_pixelTop(m_ptMove.y);
        }
        m_fUndo = !m_fUndo;
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::GetDescription (IOleUndoUnit method)
//
// Return the description of the undo item. Note that this function
// returns an empty string since this is the only would-be localizable
// content in TriEdit.
//

STDMETHODIMP CUndoDrag::GetDescription(BSTR *pBstr)
{
    if (pBstr)
    {
        *pBstr = SysAllocString(_T(" "));
        return S_OK;
    }
    return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::GetUnitType (IOleUndoUnit method)
//
// Return the CLSID and an identifier for the undo item.
//

STDMETHODIMP CUndoDrag::GetUnitType(CLSID *pClsid, LONG *plID)
{
    if (pClsid)
        *pClsid = UID_TRIEDIT_UNDO;
    if (plID)
        *plID = TRIEDIT_UNDO_DRAG;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoDrag::OnNextAdd (IOleUndoUnit method)
//
// Do nothing, but do it extremely well.
//

STDMETHODIMP CUndoDrag::OnNextAdd(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackManager::~CUndoPackManager
//
// Destructor for a CUndoPackManager object. If currently packing undo
// items, end the packing before destroying the object. 
//

CUndoPackManager::~CUndoPackManager(void)
{
    if (m_fPacking)
        End();
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackManager::Start
// 
// Called to tell the pack manager to begin accumulating subsequent
// undo units into a unit that can be undone in one fell swoop. Turn
// on the packing flag. Return S_OK if all goes well or E_FAIL if
// something goes wrong.
//

HRESULT CUndoPackManager::Start(void)
{
    HRESULT hr = E_FAIL;
    CComPtr<IOleUndoManager> srpioleUndoManager;
    CComPtr<IEnumOleUndoUnits> srpEnum;
    CComPtr<IOleUndoUnit> srpcd;
    ULONG cFetched=0;

    _ASSERTE(m_indexStartPacking==0);
    
    if (FAILED(hr = GetUndoManager(m_srpUnkTrident, &srpioleUndoManager)))
        goto Fail;

    if (FAILED(hr = srpioleUndoManager->EnumUndoable(&srpEnum)))
        goto Fail;

    while(SUCCEEDED(srpEnum->Next(1, &srpcd, &cFetched))) 
    {
        _ASSERTE(cFetched <=1);
        if (srpcd == NULL)
            break;
            
        m_indexStartPacking++;
        srpcd.Release();
    }

    m_fPacking = TRUE;

 Fail:
    if (!m_fPacking)
        m_indexStartPacking=0;
        
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackManager::End
//
// Called to tell the pack manager to stop accumulating undo units. Pack
// the accumulated undo units in to the parent undo unit and turn off
// the packing flag. Return S_OK if all goes well or E_FAIL if something
// goes wrong.
//

HRESULT CUndoPackManager::End(void)
{
    HRESULT hr = E_FAIL;
    CUndoPackUnit *pUndoParentUnit;
    
    _ASSERTE(m_srpUnkTrident != NULL);
    pUndoParentUnit = new CUndoPackUnit();
    _ASSERTE(pUndoParentUnit  != NULL);
    
    if (FAILED(hr = pUndoParentUnit->PackUndo(m_indexStartPacking, m_srpUnkTrident)))
        goto Fail;

    m_fPacking = FALSE;
Fail:
    pUndoParentUnit->Release();
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::Do (IOleUndoUnit method)
//
// Invoke the Do method of each undo unit referenced by the object. Return
// S_OK.
//

STDMETHODIMP CUndoPackUnit::Do(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK; 

    for (INT i=sizeof(m_rgUndo)/sizeof(IOleUndoUnit*)-1; i >= 0; i--)
    {
        if (m_rgUndo[i] == NULL)
            continue;
        
        if (FAILED(hr = m_rgUndo[i]->Do(pUndoManager)))
            goto Fail;
    }

	::EmptyUndoRedoStack(FALSE, pUndoManager);
	
Fail:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::GetDescription (IOleUndoUnit method)
//
// Return the description of the undo item. Note that this function
// returns an empty string since this string would be one of only
// two localizable strings in TriEdit.
//

STDMETHODIMP CUndoPackUnit::GetDescription(BSTR *pBstr)
{
    if (pBstr)
    {
        // In order to save localization work for the two TriEdit strings, 
        // it was decided that we would return a blank string here
        *pBstr = SysAllocString(_T(" "));
        return S_OK;
    }
    return E_FAIL;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::GetUnitType (IOleUndoUnit method)
//
// Return the CLSID and an identifier for the undo item.
//

STDMETHODIMP CUndoPackUnit::GetUnitType(CLSID *pClsid, LONG *plID)
{
    if (pClsid)
        *pClsid = UID_TRIEDIT_UNDO;
    if (plID)
        *plID = TRIEDIT_UNDO_PACK;
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::OnNextAdd (IOleUndoUnit method)
//
// Do nothing, but do it extremely well.
//

STDMETHODIMP CUndoPackUnit::OnNextAdd(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// CUndoPackUnit::PackUndo
//
// Pack all of the undo units starting at the given index in to
// the parent undo manager. Return S_OK if all goes well, or
// E_FAIL if something goes wrong.
//

HRESULT CUndoPackUnit::PackUndo(ULONG indexStartPacking, IUnknown *pUnkTrident)
{
    HRESULT hr = E_FAIL;
    CComPtr<IOleUndoManager> srpioleUndoManager;
    CComPtr<IEnumOleUndoUnits> srpEnumUndo;
    CComPtr<IOleUndoUnit> rgUndo[cUndoPackMax]; // CONSIDER: allocate dynamically
    CComPtr<IOleUndoUnit> srpcd;
    ULONG cFetched=0, cUndo=0, i=0;
    
    if (FAILED(hr = GetUndoManager(pUnkTrident, &srpioleUndoManager)))
        goto Fail;

    if (FAILED(hr = srpioleUndoManager->EnumUndoable(&srpEnumUndo)))
        goto Fail;
        
    _ASSERTE(srpEnumUndo != NULL);
    while(SUCCEEDED(srpEnumUndo->Next(1, &srpcd, &cFetched))) 
    {
        _ASSERTE(cFetched <= 1);
        if (srpcd == NULL)
            break;
            
        cUndo++;
        srpcd.Release();
    }

    // if there's nothing to pack
    if ((cUndo-indexStartPacking) == 0)
        return S_OK;
        
    if ((cUndo-indexStartPacking) > cUndoPackMax)
        return E_OUTOFMEMORY;
        
    // get the undo units that we want to pack
    if (FAILED(hr = srpEnumUndo->Reset()))
        goto Fail; 
    if (FAILED(hr =srpEnumUndo->Skip(indexStartPacking)))
        goto Fail;
    if (FAILED(hr = srpEnumUndo->Next(cUndo-indexStartPacking, (IOleUndoUnit **) &m_rgUndo, &cFetched)))
        goto Fail;
    _ASSERTE(cFetched == (cUndo-indexStartPacking));
    
    // now clear the undo/redo stack and then adds back the undo unit except that one that we just packed
    if (FAILED(hr = srpEnumUndo->Reset()))
        goto Fail;

    if (FAILED(hr = srpEnumUndo->Next(cUndo, (IOleUndoUnit **) &rgUndo, &cFetched)))
        goto Fail;
        
    _ASSERTE(cFetched == cUndo);

    if (FAILED(hr = srpioleUndoManager->DiscardFrom(NULL)))
        goto Fail;

    for (i=0; i < indexStartPacking; i++)
    {
        if (FAILED(hr = srpioleUndoManager->Add(rgUndo[i])))
            goto Fail;
    }

    if (FAILED(hr = ::AddUndoUnit(pUnkTrident, this)))
        goto Fail;
Fail:   
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\win95wrp.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       win95wrp.h
//
//  This file was taken from the Davinci sources and adapted for TriEdit
//  on 3/11/98 in order to get rid of the external dependency for the TriEdit SDK
//  The adaptation process included getting rid of several APIs that were not being
//  supported and moving some APIs from the supported to unsupported group
//
//  Contents:   Unicode wrapper API, used only on Win95
//
//  Functions:  About 125 Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//              All memory allocation is done on the stack.
//
//----------------------------------------------------------------------------

#ifndef __WIN95WRP_CPP__

#ifndef __WIN95WRP_H__
#define __WIN95WRP_H__

extern "C"{

BOOL WINAPI OAppendMenuW(HMENU hMenu, UINT uFlags, UINT uIDnewItem, LPCWSTR lpnewItem);
LRESULT WINAPI OCallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
DWORD WINAPI OCharLowerBuffW(LPWSTR lpsz, DWORD cchLength);
LPWSTR WINAPI OCharLowerW(LPWSTR lpsz);
LPWSTR WINAPI OCharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);
BOOL WINAPI OCharToOemW(LPCWSTR lpszSrc, LPSTR lpszDst);
LPWSTR WINAPI OCharUpperW(LPWSTR lpsz);
BOOL WINAPI OCopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
BOOL WINAPI OCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
BOOL WINAPI OCreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
HDC WINAPI OCreateEnhMetaFileW(HDC hdc, LPCWSTR lpFileName, CONST RECT *lpRect, LPCWSTR lpDescription);
HANDLE WINAPI OCreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);
HANDLE WINAPI OCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
HFONT WINAPI OCreateFontIndirectW(CONST LOGFONTW * plfw);
HFONT OCreateFontW(int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline, DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision, DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCWSTR lpszFace);
HWND WINAPI OCreateMDIWindowW(LPWSTR lpClassName, LPWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);
HDC WINAPI OCreateMetaFileW(LPCWSTR lpstr);
HANDLE WINAPI OCreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
HWND WINAPI OCreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam);
HSZ WINAPI ODdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);
UINT WINAPI ODdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes);
LRESULT WINAPI ODefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ODefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI ODefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI ODeleteFileW(LPCWSTR pwsz);
LRESULT WINAPI ODialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
LRESULT WINAPI ODialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
LRESULT WINAPI ODispatchMessageW(CONST MSG *lpMsg);
int WINAPI ODrawTextW(HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat);
int WINAPI ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);
DWORD WINAPI OExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);
VOID WINAPI OFatalAppExitW(UINT uAction, LPCWSTR lpMessageText);
HANDLE WINAPI OFindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);
HANDLE WINAPI OFindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
BOOL WINAPI OFindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
HRSRC WINAPI OFindResourceW(HINSTANCE hModule, LPCWSTR lpName, LPCWSTR lpType);
HWND WINAPI OFindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);
DWORD WINAPI OFormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments);
BOOL APIENTRY OGetCharABCWidthsFloatW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPABCFLOAT lpABC);
BOOL APIENTRY OGetCharABCWidthsW(HDC hdc, UINT uFirstChar, UINT uLastChar, LPABC lpABC);
BOOL APIENTRY OGetCharWidthFloatW(HDC hdc, UINT iFirstChar, UINT iLastChar, PFLOAT pBuffer);
BOOL WINAPI OGetCharWidthW(HDC hdc, UINT iFirstChar, UINT iLastChar, LPINT lpBuffer);
BOOL WINAPI OGetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass);
BOOL WINAPI OGetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSEXW lpWndClass);
DWORD WINAPI OGetClassLongW(HWND hWnd, int nIndex);
DWORD WINAPI OSetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong);
int WINAPI OGetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);
DWORD WINAPI OGetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);
UINT WINAPI OGetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int nMaxCount);
DWORD WINAPI OGetFileAttributesW(LPCWSTR lpFileName);
DWORD WINAPI OGetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart);
DWORD WINAPI OGetGlyphOutlineW(HDC hdc, UINT uChar, UINT uFormat, LPGLYPHMETRICS lpgm, DWORD cbBuffer, LPVOID lpvBuffer, CONST MAT2 *lpmat2);
DWORD WINAPI OGetKerningPairsW(HDC hdc, DWORD nNumPairs, LPKERNINGPAIR lpkrnpair);
BOOL WINAPI OGetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
DWORD WINAPI OGetModuleFileNameW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize);
HMODULE WINAPI OGetModuleHandleW(LPCWSTR lpModuleName);
UINT APIENTRY OGetOutlineTextMetricsW(HDC hdc, UINT cbData, LPOUTLINETEXTMETRICW lpOTM);
UINT WINAPI OGetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
DWORD WINAPI OGetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
int WINAPI OGetObjectW(HGDIOBJ hgdiobj, int cbBuffer, LPVOID lpvObject);
UINT WINAPI OGetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);
HANDLE WINAPI OGetPropW(HWND hWnd, LPCWSTR lpString);
DWORD WINAPI OGetTabbedTextExtentW(HDC hDC, LPCWSTR lpString, int nCount, int nTabPositions, LPINT lpnTabStopPositions);
UINT WINAPI OGetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);
DWORD WINAPI OGetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);
BOOL APIENTRY OGetTextExtentPoint32W(HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize);
BOOL APIENTRY OGetTextExtentPointW(HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize);
BOOL APIENTRY OGetTextExtentExPointW(HDC hdc, LPCWSTR lpszStr, int cchString, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE pSize);
LONG WINAPI OGetWindowLongW(HWND hWnd, int nIndex);
BOOL WINAPI OGetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);
BOOL WINAPI OGetUserNameW(LPWSTR lpBuffer, LPDWORD nSize);
BOOL WINAPI OGetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize);
int WINAPI OGetWindowTextLengthW(HWND hWnd);
int WINAPI OGetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);
ATOM WINAPI OGlobalAddAtomW(LPCWSTR lpString);
UINT WINAPI OGlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);
BOOL WINAPI OGrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
BOOL WINAPI OInsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem);
BOOL WINAPI OIsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);
BOOL WINAPI OIsCharAlphaNumericW(WCHAR wch);
BOOL WINAPI OIsCharAlphaW(WCHAR wch);
BOOL WINAPI OIsDialogMessageW(HWND hDlg, LPMSG lpMsg);
int WINAPI OLCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
HACCEL WINAPI OLoadAcceleratorsW(HINSTANCE hInst, LPCWSTR lpTableName);
HBITMAP WINAPI OLoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);
HCURSOR WINAPI OLoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);
HICON WINAPI OLoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);
HINSTANCE WINAPI OLoadLibraryW(LPCWSTR pwszFileName);
HMODULE WINAPI OLoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);
HMENU WINAPI OLoadMenuIndirectW(CONST MENUTEMPLATEW *lpMenuTemplate);
HMENU WINAPI OLoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);
int WINAPI OLoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax);
LPWSTR WINAPI OlstrcatW(LPWSTR lpString1, LPCWSTR lpString2);
int WINAPI OlstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);
int WINAPI OlstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR WINAPI OlstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
LPWSTR WINAPI OlstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);
int WINAPI OlstrlenW(LPCWSTR lpString);
UINT WINAPI OMapVirtualKeyW(UINT uCode, UINT uMapType);
int WINAPI OMessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);
int WINAPI OMessageBoxIndirectW(LPMSGBOXPARAMSW lpmbp);
BOOL WINAPI OModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem);
BOOL WINAPI OMoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
BOOL WINAPI OMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
HANDLE WINAPI OLoadImageW(HINSTANCE hinst, LPCWSTR lpszName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad);
BOOL WINAPI OOemToCharW(LPCSTR lpszSrc, LPWSTR lpszDst);
VOID WINAPI OOutputDebugStringW(LPCWSTR lpOutputString);
BOOL WINAPI OPeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
BOOL WINAPI OPostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OPostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);
LONG APIENTRY ORegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
LONG APIENTRY ORegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
LONG APIENTRY ORegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
LONG APIENTRY ORegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult);
LONG APIENTRY ORegDeleteKeyW(HKEY hKey, LPCWSTR pwszSubKey);
LONG APIENTRY ORegDeleteValueW(HKEY hKey, LPWSTR lpValueName);
ATOM WINAPI ORegisterClassW(CONST WNDCLASSW *lpWndClass);
ATOM WINAPI ORegisterClassExW(CONST WNDCLASSEXW * lpWndClass);
BOOL WINAPI OUnregisterClassW(LPCTSTR  lpClassName, HINSTANCE  hInstance);
UINT WINAPI ORegisterClipboardFormatW(LPCWSTR lpszFormat);
UINT WINAPI ORegisterWindowMessageW(LPCWSTR lpString);
LONG APIENTRY ORegOpenKeyExW(HKEY hKey, LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
LONG APIENTRY ORegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime);
LONG APIENTRY ORegQueryValueW(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue, PLONG lpcbValue);
LONG APIENTRY ORegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE* lpData, DWORD cbData);
LONG APIENTRY ORegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
LONG APIENTRY ORegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
HANDLE WINAPI ORemovePropW(HWND hWnd, LPCWSTR lpString);
LRESULT WINAPI OSendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI OSendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OSendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI OSetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);
BOOL WINAPI OSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
BOOL WINAPI OSetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);
BOOL WINAPI OSetMenuItemInfoW(HMENU hMenu, UINT uItem, BOOL fByPosition, LPCMENUITEMINFOW lpcmii);
LONG WINAPI OSetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong); 
HHOOK WINAPI OSetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);
BOOL WINAPI OSetWindowTextW(HWND hWnd, LPCWSTR lpString);
LONG WINAPI OTabbedTextOutW(HDC hDC, int X, int Y, LPCWSTR lpString, int nCount, int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
int WINAPI OTranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
SHORT WINAPI OVkKeyScanW(WCHAR ch);
BOOL WINAPI OWinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, DWORD dwData);
BOOL WINAPI OWritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
int WINAPIV OwsprintfW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...);
BOOL WINAPI OGetVersionExW(LPOSVERSIONINFOW lpVersionInformation);
LONG APIENTRY ORegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
HANDLE WINAPI OCreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName);
LRESULT WINAPI ODefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI OGetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);
BOOL WINAPI OSetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData);
HRESULT WINAPI OStgCreateDocfile(const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, IStorage ** ppstgOpen);
int WINAPI OStartDocW(HDC hDC, CONST DOCINFOW * pdiDocW);
BOOL WINAPI OSystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
LPWSTR WINAPI OCharNextW(LPCWSTR lpsz);

#ifdef DEBUG
int WINAPI ODlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType);
int WINAPI ODlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype);
BOOL WINAPI ODlgDirSelectComboBoxExW(HWND hDlg, LPWSTR lpString, int nCount, int nIDComboBox);
BOOL WINAPI ODlgDirSelectExW(HWND hDlg, LPWSTR lpString, int nCount, int nIDListBox);
#endif

} // extern "C"

#define AppendMenuW OAppendMenuW
#define CallWindowProcW OCallWindowProcW
#define CharLowerBuffW OCharLowerBuffW
#define CharLowerW OCharLowerW
#define CharNextW OCharNextW
#define CharPrevW OCharPrevW
#define CharToOemW OCharToOemW
#define CharUpperW OCharUpperW
#define CopyFileW OCopyFileW
#define CreateDirectoryExW OCreateDirectoryExW
#define CreateDirectoryW OCreateDirectoryW
#define CreateEnhMetaFileW OCreateEnhMetaFileW
#define CreateEventW OCreateEventW
#define CreateFileMappingW OCreateFileMappingW
#define CreateFileW OCreateFileW
#define CreateFontIndirectW OCreateFontIndirectW
#define CreateFontW OCreateFontW
#define CreateMDIWindowW OCreateMDIWindowW
#define CreateMetaFileW OCreateMetaFileW
#define CreateSemaphoreW OCreateSemaphoreW
#define CreateWindowExW OCreateWindowExW
#define DdeCreateStringHandleW ODdeCreateStringHandleW
#define DdeInitializeW ODdeInitializeW
#define DefFrameProcW ODefFrameProcW
#define DefMDIChildProcW ODefMDIChildProcW
#define DefWindowProcW ODefWindowProcW
#define DeleteFileW ODeleteFileW
#define DialogBoxIndirectParamW ODialogBoxIndirectParamW
#define DialogBoxParamW ODialogBoxParamW
#define DispatchMessageW ODispatchMessageW
#define DrawTextExW ODrawTextExW
#define DrawTextW ODrawTextW
#define ExpandEnvironmentStringsW OExpandEnvironmentStringsW
#define FatalAppExitW OFatalAppExitW
#define FindFirstChangeNotificationW OFindFirstChangeNotificationW
#define FindFirstFileW OFindFirstFileW
#define FindNextFileW OFindNextFileW
#define FindResourceW OFindResourceW
#define FindWindowW OFindWindowW
#define FormatMessageW OFormatMessageW
#define GetCharABCWidthsFloatW OGetCharABCWidthsFloatW
#define GetCharABCWidthsW OGetCharABCWidthsW
#define GetCharWidthFloatW OGetCharWidthFloatW
#define GetCharWidthW OGetCharWidthW
#define GetClassInfoW OGetClassInfoW
#define GetClassInfoExW OGetClassInfoExW
#define GetClassLongW OGetClassLongW
#define GetClassNameW OGetClassNameW
#define GetCurrentDirectoryW OGetCurrentDirectoryW
#define GetDlgItemTextW OGetDlgItemTextW
#define GetFileAttributesW OGetFileAttributesW
#define GetFullPathNameW OGetFullPathNameW
#define GetGlyphOutlineW OGetGlyphOutlineW
#define GetKerningPairsW OGetKerningPairsW
#define GetLocaleInfoW OGetLocaleInfoW
#define GetMessageW OGetMessageW
#define GetModuleFileNameW OGetModuleFileNameW
#define GetModuleHandleW OGetModuleHandleW
#define GetObjectW OGetObjectW
#define GetOutlineTextMetricsW OGetOutlineTextMetricsW
#define GetPrivateProfileIntW OGetPrivateProfileIntW
#define GetPrivateProfileStringW OGetPrivateProfileStringW
#define GetProfileIntW OGetProfileIntW
#define GetPropW OGetPropW
#define GetTabbedTextExtentW OGetTabbedTextExtentW
#define GetTempFileNameW OGetTempFileNameW
#define GetTempPathW OGetTempPathW
#define GetTextExtentPoint32W OGetTextExtentPoint32W
#define GetTextExtentPointW OGetTextExtentPointW
#define GetTextExtentExPointW OGetTextExtentExPointW
#define GetTextMetricsW OGetTextMetricsW
#define GetUserNameW OGetUserNameW
#define GetVersionExW OGetVersionExW
#define GetVolumeInformationW OGetVolumeInformationW
#define GetWindowLongW OGetWindowLongW
#define GetWindowTextLengthW OGetWindowTextLengthW
#define GetWindowTextW OGetWindowTextW
#define GlobalAddAtomW OGlobalAddAtomW
#define GlobalGetAtomNameW OGlobalGetAtomNameW
#define GrayStringW OGrayStringW
#define InsertMenuW OInsertMenuW
#define IsBadStringPtrW OIsBadStringPtrW
#define IsCharAlphaNumericW OIsCharAlphaNumericW
#define IsCharAlphaW OIsCharAlphaW
#define IsDialogMessageW OIsDialogMessageW
#define LCMapStringW OLCMapStringW
#define LoadAcceleratorsW OLoadAcceleratorsW
#define LoadBitmapW OLoadBitmapW
#define LoadCursorW OLoadCursorW
#define LoadIconW OLoadIconW
#define LoadImageW OLoadImageW
#define LoadLibraryExW OLoadLibraryExW
#define LoadLibraryW OLoadLibraryW
#define LoadMenuIndirectW OLoadMenuIndirectW
#define LoadMenuW OLoadMenuW
#define LoadStringW OLoadStringW
#define lstrcatW OlstrcatW
#define lstrcmpiW OlstrcmpiW
#define lstrcmpW OlstrcmpW
#define lstrcpynW OlstrcpynW
#define lstrcpyW OlstrcpyW
#define lstrlenW OlstrlenW
#define MapVirtualKeyW OMapVirtualKeyW
#define MessageBoxW OMessageBoxW
#define MessageBoxIndirectW OMessageBoxIndirectW
#define ModifyMenuW OModifyMenuW
#define MoveFileExW OMoveFileExW
#define MoveFileW OMoveFileW
#define OemToCharW OOemToCharW
#define OutputDebugStringW OOutputDebugStringW
#define PeekMessageW OPeekMessageW
#define PostMessageW OPostMessageW
#define PostThreadMessageW OPostThreadMessageW
#define RegCreateKeyExW ORegCreateKeyExW
#define RegCreateKeyW ORegCreateKeyW
#define RegDeleteKeyW ORegDeleteKeyW
#define RegDeleteValueW ORegDeleteValueW
#define RegEnumKeyW ORegEnumKeyW
#define RegEnumValueW ORegEnumValueW
#define RegEnumKeyExW ORegEnumKeyExW
#define RegisterClassW ORegisterClassW
#define RegisterClassExW ORegisterClassExW
#define RegisterClipboardFormatW ORegisterClipboardFormatW
#define RegisterWindowMessageW ORegisterWindowMessageW
#define RegOpenKeyExW ORegOpenKeyExW
#define RegOpenKeyW ORegOpenKeyW
#define RegQueryInfoKeyW ORegQueryInfoKeyW
#define RegQueryValueExW ORegQueryValueExW
#define RegQueryValueW ORegQueryValueW
#define RegSetValueExW ORegSetValueExW
#define RegSetValueW ORegSetValueW
#define RemovePropW ORemovePropW
#define SendDlgItemMessageW OSendDlgItemMessageW
#define SendMessageW OSendMessageW
#define SendNotifyMessageW OSendNotifyMessageW
#define SetDlgItemTextW OSetDlgItemTextW
#define SetFileAttributesW OSetFileAttributesW
#define SetLocaleInfoW OSetLocaleInfoW
#define SetMenuItemInfoW OSetMenuItemInfoW
#define SetPropW OSetPropW
#define SetWindowLongW OSetWindowLongW
#define SetWindowsHookExW OSetWindowsHookExW
#define SetWindowTextW OSetWindowTextW
#define StartDocW OStartDocW
#define StgCreateDocfile OStgCreateDocfile
#define SystemParametersInfoW OSystemParametersInfoW
#define TabbedTextOutW OTabbedTextOutW
#define TranslateAcceleratorW OTranslateAcceleratorW
#define UnregisterClassW OUnregisterClassW
#define VkKeyScanW OVkKeyScanW
#define WinHelpW OWinHelpW
#define WritePrivateProfileStringW OWritePrivateProfileStringW
#define wsprintfW OwsprintfW
 
// These are the currently unsupported APIs
// These will assert in the debug version and map directly 
// to Windows in the retail version
#ifdef DEBUG
#define AbortSystemShutdownW OAbortSystemShutdownW
#define AccessCheckAndAuditAlarmW OAccessCheckAndAuditAlarmW
#define AddFontResourceW OAddFontResourceW
#define AddFormW OAddFormW
#define AddJobW OAddJobW
#define AddMonitorW OAddMonitorW
#define AddPortW OAddPortW
#define AddPrinterConnectionW OAddPrinterConnectionW
#define AddPrinterDriverW OAddPrinterDriverW
#define AddPrinterW OAddPrinterW
#define AddPrintProcessorW OAddPrintProcessorW
#define AddPrintProvidorW OAddPrintProvidorW
#define AdvancedDocumentPropertiesW OAdvancedDocumentPropertiesW
#define auxGetDevCapsW OauxGetDevCapsW
#define BackupEventLogW OBackupEventLogW
#define BeginUpdateResourceW OBeginUpdateResourceW
#define BuildCommDCBAndTimeoutsW OBuildCommDCBAndTimeoutsW
#define BuildCommDCBW OBuildCommDCBW
#define CallMsgFilterW OCallMsgFilterW
#define CallNamedPipeW OCallNamedPipeW
#define ChangeDisplaySettingsW OChangeDisplaySettingsW
#define ChangeMenuW OChangeMenuW
#define CharToOemBuffW OCharToOemBuffW
#define CharUpperBuffW OCharUpperBuffW
#define ChooseColorW OChooseColorW
#define ChooseFontW OChooseFontW
#define ClearEventLogW OClearEventLogW
#define CommConfigDialogW OCommConfigDialogW
#define CompareStringW OCompareStringW
#define ConfigurePortW OConfigurePortW
#define CopyAcceleratorTableW OCopyAcceleratorTableW
#define CopyEnhMetaFileW OCopyEnhMetaFileW
#define CopyMetaFileW OCopyMetaFileW
#define CreateAcceleratorTableW OCreateAcceleratorTableW
#define CreateColorSpaceW OCreateColorSpaceW
#define CreateDCW OCreateDCW
#define CreateDesktopW OCreateDesktopW
#define CreateDialogIndirectParamW OCreateDialogIndirectParamW
#define CreateDialogParamW OCreateDialogParamW
#define CreateICW OCreateICW
#define CreateMailslotW OCreateMailslotW
#define CreateMutexW OCreateMutexW
#define CreateNamedPipeW OCreateNamedPipeW
#define CreateProcessW OCreateProcessW
#define CreateProcessAsUserW OCreateProcessAsUserW
#define CreatePropertySheetPageW OCreatePropertySheetPageW
#define CreateScalableFontResourceW OCreateScalableFontResourceW
#define CreateStatusWindowW OCreateStatusWindowW
#define CreateWindowStationW OCreateWindowStationW
#define DceErrorInqTextW ODceErrorInqTextW
#define DdeQueryStringW   ODdeQueryStringW
#define DefDlgProcW ODefDlgProcW
#define DefineDosDeviceW ODefineDosDeviceW
#define DeleteFormW ODeleteFormW
#define DeleteMonitorW ODeleteMonitorW
#define DeletePortW ODeletePortW
#define DeletePrinterConnectionW ODeletePrinterConnectionW
#define DeletePrinterDriverW ODeletePrinterDriverW
#define DeletePrintProcessorW ODeletePrintProcessorW
#define DeletePrintProvidorW ODeletePrintProvidorW
#define DeviceCapabilitiesW ODeviceCapabilitiesW
#define DlgDirListComboBoxW ODlgDirListComboBoxW
#define DlgDirListW ODlgDirListW
#define DlgDirSelectComboBoxExW ODlgDirSelectComboBoxExW
#define DlgDirSelectExW ODlgDirSelectExW
#define DocumentPropertiesW ODocumentPropertiesW
#define DoEnvironmentSubstW ODoEnvironmentSubstW
#define DragQueryFileW ODragQueryFileW
#define DrawStateW ODrawStateW
#define EndUpdateResourceW OEndUpdateResourceW
#define EnumCalendarInfoW OEnumCalendarInfoW
#define EnumDateFormatsW OEnumDateFormatsW
#define EnumDesktopsW OEnumDesktopsW
#define EnumDisplaySettingsW OEnumDisplaySettingsW
#define EnumFontFamiliesExW OEnumFontFamiliesExW
#define EnumFontFamiliesW OEnumFontFamiliesW
#define EnumFontsW OEnumFontsW
#define EnumFormsW OEnumFormsW
#define EnumICMProfilesW OEnumICMProfilesW
#define EnumJobsW OEnumJobsW
#define EnumMonitorsW OEnumMonitorsW
#define EnumPortsW OEnumPortsW
#define EnumPrinterDriversW OEnumPrinterDriversW
#define EnumPrintersW OEnumPrintersW
#define EnumPrintProcessorDatatypesW OEnumPrintProcessorDatatypesW
#define EnumPrintProcessorsW OEnumPrintProcessorsW
#define EnumPropsExW OEnumPropsExW
#define EnumPropsW OEnumPropsW
#define EnumProtocolsW OEnumProtocolsW
#define EnumResourceLanguagesW OEnumResourceLanguagesW
#define EnumResourceNamesW OEnumResourceNamesW
#define EnumResourceTypesW OEnumResourceTypesW
#define EnumSystemCodePagesW OEnumSystemCodePagesW
#define EnumSystemLocalesW OEnumSystemLocalesW
#define EnumTimeFormatsW OEnumTimeFormatsW
#define EnumWindowStationsW OEnumWindowStationsW
#define ExtractAssociatedIconW OExtractAssociatedIconW
#define ExtractIconW OExtractIconW
#define ExtractIconExW OExtractIconExW
#define FillConsoleOutputCharacterW OFillConsoleOutputCharacterW
#define FindEnvironmentStringW OFindEnvironmentStringW
#define FindExecutableW OFindExecutableW
#define FindResourceExW OFindResourceExW
#define FindTextW OFindTextW
#define FindWindowExW OFindWindowExW
#define FoldStringW OFoldStringW
#define GetBinaryTypeW OGetBinaryTypeW
#define GetCharacterPlacementW OGetCharacterPlacementW
#define GetCharWidth32W OGetCharWidth32W
#define GetCommandLineW OGetCommandLineW
#define GetClipboardFormatNameW OGetClipboardFormatNameW
#define GetCompressedFileSizeW OGetCompressedFileSizeW
#define GetComputerNameW OGetComputerNameW
#define GetConsoleTitleW OGetConsoleTitleW
#define GetCurrencyFormatW OGetCurrencyFormatW
#define GetDateFormatW OGetDateFormatW
#define GetDefaultCommConfigW OGetDefaultCommConfigW
#define GetDiskFreeSpaceW OGetDiskFreeSpaceW
#define GetDriveTypeW OGetDriveTypeW
#define GetEnhMetaFileDescriptionW OGetEnhMetaFileDescriptionW
#define GetEnhMetaFileW OGetEnhMetaFileW
#define GetEnvironmentVariableW OGetEnvironmentVariableW
#define GetExpandedNameW OGetExpandedNameW
#define GetFileSecurityW OGetFileSecurityW
#define GetFileTitleW OGetFileTitleW
#define GetFileVersionInfoW OGetFileVersionInfoW
#define GetFileVersionInfoSizeW OGetFileVersionInfoSizeW
#define GetFormW OGetFormW
#define GetICMProfileW OGetICMProfileW
#define GetJobW OGetJobW
#define GetKeyboardLayoutNameW OGetKeyboardLayoutNameW
#define GetKeyNameTextW OGetKeyNameTextW
#define GetLogColorSpaceW OGetLogColorSpaceW
#define GetLogicalDriveStringsW OGetLogicalDriveStringsW
#define GetMenuItemInfoW OGetMenuItemInfoW
#define GetMenuStringW OGetMenuStringW
#define GetMetaFileW OGetMetaFileW
#define GetNameByTypeW OGetNameByTypeW
#define GetNamedPipeHandleStateW OGetNamedPipeHandleStateW
#define GetNumberFormatW OGetNumberFormatW
#define GetOpenFileNameW OGetOpenFileNameW
#define GetPrinterW OGetPrinterW
#define GetPrinterDataW OGetPrinterDataW
#define GetPrinterDriverDirectoryW OGetPrinterDriverDirectoryW
#define GetPrinterDriverW OGetPrinterDriverW
#define GetPrintProcessorDirectoryW OGetPrintProcessorDirectoryW
#define GetPrivateProfileSectionNamesW OGetPrivateProfileSectionNamesW
#define GetPrivateProfileSectionW OGetPrivateProfileSectionW
#define GetPrivateProfileStructW OGetPrivateProfileStructW
#define GetProfileSectionW OGetProfileSectionW
#define GetProfileStringW OGetProfileStringW
#define GetSaveFileNameW OGetSaveFileNameW
#define GetShortPathNameW OGetShortPathNameW
#define GetStartupInfoW OGetStartupInfoW
#define GetStringTypeExW OGetStringTypeExW
#define GetSystemDirectoryW OGetSystemDirectoryW
#define GetTextFaceW OGetTextFaceW
#define GetTimeFormatW OGetTimeFormatW
#define GetTypeByNameW OGetTypeByNameW
#define GetUserObjectInformationW OGetUserObjectInformationW
#define GetWindowsDirectoryW OGetWindowsDirectoryW
#define GlobalFindAtomW OGlobalFindAtomW
#define ImageList_LoadImageW OImageList_LoadImageW
#define ImmConfigureIMEW OImmConfigureIMEW
#define ImmEnumRegisterWordW OImmEnumRegisterWordW
#define ImmEscapeW OImmEscapeW
#define ImmGetCandidateListCountW OImmGetCandidateListCountW
#define ImmGetCandidateListW OImmGetCandidateListW
#define ImmGetCompositionFontW OImmGetCompositionFontW
#define ImmGetCompositionStringW OImmGetCompositionStringW
#define ImmGetConversionListW OImmGetConversionListW
#define ImmGetDescriptionW OImmGetDescriptionW
#define ImmGetGuideLineW OImmGetGuideLineW
#define ImmGetIMEFileNameW OImmGetIMEFileNameW
#define ImmGetRegisterWordStyleW OImmGetRegisterWordStyleW
#define ImmInstallIMEW OImmInstallIMEW
#define ImmIsUIMessageW OImmIsUIMessageW
#define ImmRegisterWordW OImmRegisterWordW
#define ImmSetCompositionFontW OImmSetCompositionFontW
#define ImmSetCompositionStringW OImmSetCompositionStringW
#define ImmUnregisterWordW OImmUnregisterWordW
#define InitiateSystemShutdownW OInitiateSystemShutdownW
#define InsertMenuItemW OInsertMenuItemW
#define IsCharLowerW OIsCharLowerW
#define IsCharUpperW OIsCharUpperW
#define I_RpcServerUnregisterEndpointW OI_RpcServerUnregisterEndpointW
#define joyGetDevCapsW OjoyGetDevCapsW
#define LoadCursorFromFileW OLoadCursorFromFileW
#define LoadKeyboardLayoutW OLoadKeyboardLayoutW
#define LogonUserW OLogonUserW
#define LZOpenFileW OLZOpenFileW
#define MapVirtualKeyExW OMapVirtualKeyExW
#define MIMEAssociationDialogW OMIMEAssociationDialogW
#define MultinetGetConnectionPerformanceW OMultinetGetConnectionPerformanceW
#define ObjectCloseAuditAlarmW OObjectCloseAuditAlarmW
#define ObjectOpenAuditAlarmW OObjectOpenAuditAlarmW
#define ObjectPrivilegeAuditAlarmW OObjectPrivilegeAuditAlarmW
#define OemToCharBuffW OOemToCharBuffW
#define OpenBackupEventLogW OOpenBackupEventLogW
#define OpenDesktopW OOpenDesktopW
#define OpenEventLogW OOpenEventLogW
#define OpenEventW OOpenEventW
#define OpenFileMappingW OOpenFileMappingW
#define OpenMutexW OOpenMutexW
#define OpenPrinterW OOpenPrinterW
#define OpenSemaphoreW OOpenSemaphoreW
#define OpenWindowStationW OOpenWindowStationW
#define PageSetupDlgW OPageSetupDlgW
#define PeekConsoleInputW OPeekConsoleInputW
#define PolyTextOutW OPolyTextOutW
#define PrintDlgW OPrintDlgW
#define PrinterMessageBoxW OPrinterMessageBoxW
#define PrivilegedServiceAuditAlarmW OPrivilegedServiceAuditAlarmW
#define PropertySheetW OPropertySheetW
#define QueryDosDeviceW OQueryDosDeviceW
#define ReadConsoleInputW OReadConsoleInputW
#define ReadConsoleOutputCharacterW OReadConsoleOutputCharacterW
#define ReadConsoleOutputW OReadConsoleOutputW
#define ReadConsoleW OReadConsoleW
#define ReadEventLogW OReadEventLogW
#define RegConnectRegistryW ORegConnectRegistryW
#define RegisterEventSourceW ORegisterEventSourceW
#define RegLoadKeyW ORegLoadKeyW
#define RegQueryMultipleValuesW ORegQueryMultipleValuesW
#define RegReplaceKeyW ORegReplaceKeyW
#define RegRestoreKeyW ORegRestoreKeyW
#define RegSaveKeyW ORegSaveKeyW
#define RegUnLoadKeyW ORegUnLoadKeyW
#define RemoveDirectoryW ORemoveDirectoryW
#define RemoveFontResourceW ORemoveFontResourceW
#define ReplaceTextW OReplaceTextW
#define ReportEventW OReportEventW
#define ResetDCW OResetDCW
#define ResetPrinterW OResetPrinterW
#define RpcBindingFromStringBindingW ORpcBindingFromStringBindingW
#define RpcBindingInqAuthClientW ORpcBindingInqAuthClientW
#define RpcBindingToStringBindingW ORpcBindingToStringBindingW
#define RpcEpRegisterNoReplaceW ORpcEpRegisterNoReplaceW
#define RpcMgmtEpEltInqNextW ORpcMgmtEpEltInqNextW
#define RpcMgmtInqServerPrincNameW ORpcMgmtInqServerPrincNameW
#define RpcNetworkInqProtseqsW ORpcNetworkInqProtseqsW
#define RpcNetworkIsProtseqValidW ORpcNetworkIsProtseqValidW
#define RpcNsBindingInqEntryNameW ORpcNsBindingInqEntryNameW
#define RpcProtseqVectorFreeW ORpcProtseqVectorFreeW
#define RpcServerInqDefaultPrincNameW ORpcServerInqDefaultPrincNameW
#define RpcServerUseProtseqEpW ORpcServerUseProtseqEpW
#define RpcServerUseProtseqIfW ORpcServerUseProtseqIfW
#define RpcServerUseProtseqW ORpcServerUseProtseqW
#define RpcStringBindingComposeW ORpcStringBindingComposeW
#define RpcStringBindingParseW ORpcStringBindingParseW
#define RpcStringFreeW ORpcStringFreeW
#define ScrollConsoleScreenBufferW OScrollConsoleScreenBufferW
#define SearchPathW OSearchPathW
#define SendMessageCallbackW OSendMessageCallbackW
#define SendMessageTimeoutW OSendMessageTimeoutW
#define SetClassLongW OSetClassLongW
#define SetComputerNameW OSetComputerNameW
#define SetConsoleTitleW OSetConsoleTitleW
#define SetCurrentDirectoryW OSetCurrentDirectoryW
#define SetDefaultCommConfigW OSetDefaultCommConfigW
#define SetEnvironmentVariableW OSetEnvironmentVariableW
#define SetFileSecurityW OSetFileSecurityW
#define SetFormW OSetFormW
#define SetICMProfileW OSetICMProfileW
#define SetJobW OSetJobW
#define SetPrinterDataW OSetPrinterDataW
#define SetPrinterW OSetPrinterW
#define SetUserObjectInformationW OSetUserObjectInformationW
#define SetVolumeLabelW OSetVolumeLabelW
#define SetWindowsHookW OSetWindowsHookW
#define SHBrowseForFolderW OSHBrowseForFolderW
#define Shell_NotifyIconW OShell_NotifyIconW
#define ShellAboutW OShellAboutW
#define ShellExecuteW OShellExecuteW
#define ShellExecuteExW OShellExecuteExW
#define SHFileOperationW OSHFileOperationW
#define SHGetFileInfoW OSHGetFileInfoW
#define SHGetNewLinkInfoW OSHGetNewLinkInfoW
#define SHGetPathFromIDListW OSHGetPathFromIDListW
#define sndPlaySoundW OsndPlaySoundW
#define StartDocPrinterW OStartDocPrinterW
#define StgCreateDocfile OStgCreateDocfile
#define TranslateURLW OTranslateURLW
#define UpdateICMRegKeyW OUpdateICMRegKeyW
#define URLAssociationDialogW OURLAssociationDialogW
#define UuidFromStringW OUuidFromStringW
#define VerFindFileW OVerFindFileW
#define VerInstallFileW OVerInstallFileW
#define VerLanguageNameW OVerLanguageNameW
#define VerQueryValueW OVerQueryValueW
#define VkKeyScanExW OVkKeyScanExW
#define WaitNamedPipeW OWaitNamedPipeW
#define waveInGetDevCapsW OwaveInGetDevCapsW
#define waveInGetErrorTextW OwaveInGetErrorTextW
#define waveOutGetDevCapsW OwaveOutGetDevCapsW
#define waveOutGetErrorTextW OwaveOutGetErrorTextW
#define wglUseFontBitmapsW OwglUseFontBitmapsW
#define wglUseFontOutlinesW OwglUseFontOutlinesW
#define WinExecErrorW OWinExecErrorW
#define WNetAddConnection2W OWNetAddConnection2W
#define WNetAddConnection3W OWNetAddConnection3W
#define WNetAddConnectionW OWNetAddConnectionW
#define WNetCancelConnection2W OWNetCancelConnection2W
#define WNetCancelConnectionW OWNetCancelConnectionW
#define WNetConnectionDialog1W OWNetConnectionDialog1W
#define WNetDisconnectDialog1W OWNetDisconnectDialog1W
#define WNetEnumResourceW OWNetEnumResourceW
#define WNetGetConnectionW OWNetGetConnectionW
#define WNetGetLastErrorW OWNetGetLastErrorW
#define WNetGetNetworkInformationW OWNetGetNetworkInformationW
#define WNetGetProviderNameW OWNetGetProviderNameW
#define WNetGetUniversalNameW OWNetGetUniversalNameW
#define WNetGetUserW OWNetGetUserW
#define WNetOpenEnumW OWNetOpenEnumW
#define WNetSetConnectionW OWNetSetConnectionW
#define WNetUseConnectionW OWNetUseConnectionW
#define WriteConsoleInputW OWriteConsoleInputW
#define WriteConsoleOutputCharacterW OWriteConsoleOutputCharacterW
#define WriteConsoleOutputW OWriteConsoleOutputW
#define WriteConsoleW OWriteConsoleW
#define WritePrivateProfileSectionW OWritePrivateProfileSectionW
#define WritePrivateProfileStructW OWritePrivateProfileStructW
#define WriteProfileSectionW OWriteProfileSectionW
#define WriteProfileStringW OWriteProfileStringW
#define wvsprintfW OwvsprintfW
#endif // DEBUG

#endif // __WIN95WRP_H__

#else // __WIN95WRP_CPP__

#undef AppendMenuW
#undef CallWindowProcW
#undef CharLowerBuffW
#undef CharLowerW
#undef CharNextW
#undef CharPrevW
#undef CharToOemW
#undef CharUpperW
#undef CopyFileW
#undef CreateDirectoryExW
#undef CreateDirectoryW
#undef CreateEnhMetaFileW
#undef CreateEventW
#undef CreateFileMappingW
#undef CreateFileW
#undef CreateFontIndirectW
#undef CreateFontW
#undef CreateMDIWindowW
#undef CreateMetaFileW
#undef CreateSemaphoreW
#undef CreateWindowExW
#undef DdeCreateStringHandleW
#undef DdeInitializeW
#undef DefFrameProcW
#undef DefMDIChildProcW
#undef DefWindowProcW
#undef DeleteFileW
#undef DialogBoxIndirectParamW
#undef DialogBoxParamW
#undef DispatchMessageW
#undef DrawTextExW
#undef DrawTextW
#undef ExpandEnvironmentStringsW
#undef FatalAppExitW
#undef FindFirstChangeNotificationW
#undef FindFirstFileW
#undef FindNextFileW
#undef FindResourceW
#undef FindWindowW
#undef FormatMessageW
#undef GetCharABCWidthsFloatW
#undef GetCharABCWidthsW
#undef GetCharWidthFloatW
#undef GetCharWidthW
#undef GetClassInfoW
#undef GetClassInfoExW
#undef GetClassLongW
#undef GetClassNameW
#undef GetCurrentDirectoryW
#undef GetDlgItemTextW
#undef GetFileAttributesW
#undef GetFullPathNameW
#undef GetGlyphOutlineW
#undef GetKerningPairsW
#undef GetLocaleInfoW
#undef GetMessageW
#undef GetModuleFileNameW
#undef GetModuleHandleW
#undef GetObjectW
#undef GetOutlineTextMetricsW
#undef GetPrivateProfileIntW
#undef GetPrivateProfileStringW
#undef GetProfileIntW
#undef GetPropW
#undef GetTabbedTextExtentW
#undef GetTempFileNameW
#undef GetTempPathW
#undef GetTextExtentPoint32W
#undef GetTextExtentPointW
#undef GetTextExtentExPointW
#undef GetTextMetricsW
#undef GetUserNameW
#undef GetVersionExW
#undef GetVolumeInformationW
#undef GetWindowLongW
#undef GetWindowTextLengthW
#undef GetWindowTextW
#undef GlobalAddAtomW
#undef GlobalGetAtomNameW
#undef GrayStringW
#undef InsertMenuW
#undef IsBadStringPtrW
#undef IsCharAlphaNumericW
#undef IsCharAlphaW
#undef IsDialogMessageW
#undef LCMapStringW
#undef LoadAcceleratorsW
#undef LoadBitmapW
#undef LoadCursorW
#undef LoadIconW
#undef LoadImageW
#undef LoadLibraryExW
#undef LoadLibraryW
#undef LoadMenuIndirectW
#undef LoadMenuW
#undef LoadStringW
#undef lstrcatW
#undef lstrcmpiW
#undef lstrcmpW
#undef lstrcpynW
#undef lstrcpyW
#undef lstrlenW
#undef MapVirtualKeyW
#undef MessageBoxW
#undef MessageBoxIndirectW
#undef ModifyMenuW
#undef MoveFileExW
#undef MoveFileW
#undef OemToCharW
#undef OutputDebugStringW
#undef PeekMessageW
#undef PostMessageW
#undef PostThreadMessageW
#undef RegCreateKeyExW
#undef RegCreateKeyW
#undef RegDeleteKeyW
#undef RegDeleteValueW
#undef RegEnumKeyW
#undef RegEnumValueW
#undef RegEnumKeyExW
#undef RegisterClassW
#undef RegisterClassExW
#undef RegisterClipboardFormatW
#undef RegisterWindowMessageW
#undef RegOpenKeyExW
#undef RegOpenKeyW
#undef RegQueryInfoKeyW
#undef RegQueryValueExW
#undef RegQueryValueW
#undef RegSetValueExW
#undef RegSetValueW
#undef RemovePropW
#undef SendDlgItemMessageW
#undef SendMessageW
#undef SendNotifyMessageW
#undef SetDlgItemTextW
#undef SetFileAttributesW
#undef SetLocaleInfoW
#undef SetMenuItemInfoW
#undef SetPropW
#undef SetWindowLongW
#undef SetWindowsHookExW
#undef SetWindowTextW
#undef StartDocW
#undef StgCreateDocfileW
#undef SystemParametersInfoW
#undef TabbedTextOutW
#undef TranslateAcceleratorW
#undef UnregisterClassW
#undef VkKeyScanW
#undef WinHelpW
#undef WritePrivateProfileStringW
#undef wsprintfW
 
// These are the currently unsupported APIs
// These will assert in the debug version and map directly 
// to Windows in the retail version
#ifdef DEBUG
#undef AbortSystemShutdownW
#undef AccessCheckAndAuditAlarmW
#undef AddFontResourceW
#undef AddFormW
#undef AddJobW
#undef AddMonitorW
#undef AddPortW
#undef AddPrinterConnectionW
#undef AddPrinterDriverW
#undef AddPrinterW
#undef AddPrintProcessorW
#undef AddPrintProvidorW
#undef AdvancedDocumentPropertiesW
#undef auxGetDevCapsW
#undef BackupEventLogW
#undef BeginUpdateResourceW
#undef BuildCommDCBAndTimeoutsW
#undef BuildCommDCBW
#undef CallMsgFilterW
#undef CallNamedPipeW
#undef ChangeDisplaySettingsW
#undef ChangeMenuW
#undef CharToOemBuffW
#undef CharUpperBuffW
#undef ChooseColorW
#undef ChooseFontW
#undef ClearEventLogW
#undef CommConfigDialogW
#undef CompareStringW
#undef ConfigurePortW
#undef CopyAcceleratorTableW
#undef CopyEnhMetaFileW
#undef CopyMetaFileW
#undef CreateAcceleratorTableW
#undef CreateColorSpaceW
#undef CreateDCW
#undef CreateDesktopW
#undef CreateDialogIndirectParamW
#undef CreateDialogParamW
#undef CreateICW
#undef CreateMailslotW
#undef CreateMutexW
#undef CreateNamedPipeW
#undef CreateProcessW
#undef CreateProcessAsUserW
#undef CreatePropertySheetPageW
#undef CreateScalableFontResourceW
#undef CreateStatusWindowW
#undef CreateWindowStationW
#undef DceErrorInqTextW
#undef DdeQueryStringW
#undef DefDlgProcW
#undef undefDosDeviceW
#undef DeleteFormW
#undef DeleteMonitorW
#undef DeletePortW
#undef DeletePrinterConnectionW
#undef DeletePrinterDriverW
#undef DeletePrintProcessorW
#undef DeletePrintProvidorW
#undef DeviceCapabilitiesW
#undef DlgDirListComboBoxW
#undef DlgDirListW
#undef DlgDirSelectComboBoxExW
#undef DlgDirSelectExW
#undef DocumentPropertiesW
#undef DoEnvironmentSubstW
#undef DragQueryFileW
#undef DrawStateW
#undef EndUpdateResourceW
#undef EnumCalendarInfoW
#undef EnumDateFormatsW
#undef EnumDesktopsW
#undef EnumDisplaySettingsW
#undef EnumFontFamiliesExW
#undef EnumFontFamiliesW
#undef EnumFontsW
#undef EnumFormsW
#undef EnumICMProfilesW
#undef EnumJobsW
#undef EnumMonitorsW
#undef EnumPortsW
#undef EnumPrinterDriversW
#undef EnumPrintersW
#undef EnumPrintProcessorDatatypesW
#undef EnumPrintProcessorsW
#undef EnumPropsExW
#undef EnumPropsW
#undef EnumProtocolsW
#undef EnumResourceLanguagesW
#undef EnumResourceNamesW
#undef EnumResourceTypesW
#undef EnumSystemCodePagesW
#undef EnumSystemLocalesW
#undef EnumTimeFormatsW
#undef EnumWindowStationsW
#undef ExtractAssociatedIconW
#undef ExtractIconW
#undef ExtractIconExW
#undef FillConsoleOutputCharacterW
#undef FindEnvironmentStringW
#undef FindExecutableW
#undef FindResourceExW
#undef FindTextW
#undef FindWindowExW
#undef FoldStringW
#undef GetBinaryTypeW
#undef GetCharacterPlacementW
#undef GetCharWidth32W
#undef GetCommandLineW
#undef GetClipboardFormatNameW
#undef GetCompressedFileSizeW
#undef GetComputerNameW
#undef GetConsoleTitleW
#undef GetCurrencyFormatW
#undef GetDateFormatW
#undef GetDefaultCommConfigW
#undef GetDiskFreeSpaceW
#undef GetDriveTypeW
#undef GetEnhMetaFileDescriptionW
#undef GetEnhMetaFileW
#undef GetEnvironmentVariableW
#undef GetExpandedNameW
#undef GetFileSecurityW
#undef GetFileTitleW
#undef GetFileVersionInfoW
#undef GetFileVersionInfoSizeW
#undef GetFormW
#undef GetICMProfileW
#undef GetJobW
#undef GetKeyboardLayoutNameW
#undef GetKeyNameTextW
#undef GetLogColorSpaceW
#undef GetLogicalDriveStringsW
#undef GetMenuItemInfoW
#undef GetMenuStringW
#undef GetMetaFileW
#undef GetNameByTypeW
#undef GetNamedPipeHandleStateW
#undef GetNumberFormatW
#undef GetOpenFileNameW
#undef GetPrinterW
#undef GetPrinterDataW
#undef GetPrinterDriverDirectoryW
#undef GetPrinterDriverW
#undef GetPrintProcessorDirectoryW
#undef GetPrivateProfileSectionNamesW
#undef GetPrivateProfileSectionW
#undef GetPrivateProfileStructW
#undef GetProfileSectionW
#undef GetProfileStringW
#undef GetSaveFileNameW
#undef GetShortPathNameW
#undef GetStartupInfoW
#undef GetStringTypeExW
#undef GetSystemDirectoryW
#undef GetTextFaceW
#undef GetTimeFormatW
#undef GetTypeByNameW
#undef GetUserObjectInformationW
#undef GetWindowsDirectoryW
#undef GlobalFindAtomW
#undef ImageList_LoadImageW
#undef ImmConfigureIMEW
#undef ImmEnumRegisterWordW
#undef ImmEscapeW
#undef ImmGetCandidateListCountW
#undef ImmGetCandidateListW
#undef ImmGetCompositionFontW
#undef ImmGetCompositionStringW
#undef ImmGetConversionListW
#undef ImmGetDescriptionW
#undef ImmGetGuideLineW
#undef ImmGetIMEFileNameW
#undef ImmGetRegisterWordStyleW
#undef ImmInstallIMEW
#undef ImmIsUIMessageW
#undef ImmRegisterWordW
#undef ImmSetCompositionFontW
#undef ImmSetCompositionStringW
#undef ImmUnregisterWordW
#undef InitiateSystemShutdownW
#undef InsertMenuItemW
#undef IsCharLowerW
#undef IsCharUpperW
#undef I_RpcServerUnregisterEndpointW
#undef joyGetDevCapsW
#undef LoadCursorFromFileW
#undef LoadKeyboardLayoutW
#undef LogonUserW
#undef LZOpenFileW
#undef MapVirtualKeyExW
#undef MIMEAssociationDialogW
#undef MultinetGetConnectionPerformanceW
#undef ObjectCloseAuditAlarmW
#undef ObjectOpenAuditAlarmW
#undef ObjectPrivilegeAuditAlarmW
#undef OemToCharBuffW
#undef OpenBackupEventLogW
#undef OpenDesktopW
#undef OpenEventLogW
#undef OpenEventW
#undef OpenFileMappingW
#undef OpenMutexW
#undef OpenPrinterW
#undef OpenSemaphoreW
#undef OpenWindowStationW
#undef PageSetupDlgW
#undef PeekConsoleInputW
#undef PolyTextOutW
#undef PrintDlgW
#undef PrinterMessageBoxW
#undef PrivilegedServiceAuditAlarmW
#undef PropertySheetW
#undef QueryDosDeviceW
#undef ReadConsoleInputW
#undef ReadConsoleOutputCharacterW
#undef ReadConsoleOutputW
#undef ReadConsoleW
#undef ReadEventLogW
#undef RegConnectRegistryW
#undef RegisterEventSourceW
#undef RegLoadKeyW
#undef RegQueryMultipleValuesW
#undef RegReplaceKeyW
#undef RegRestoreKeyW
#undef RegSaveKeyW
#undef RegUnLoadKeyW
#undef RemoveDirectoryW
#undef RemoveFontResourceW
#undef ReplaceTextW
#undef ReportEventW
#undef ResetDCW
#undef ResetPrinterW
#undef RpcBindingFromStringBindingW
#undef RpcBindingInqAuthClientW
#undef RpcBindingToStringBindingW
#undef RpcEpRegisterNoReplaceW
#undef RpcMgmtEpEltInqNextW
#undef RpcMgmtInqServerPrincNameW
#undef RpcNetworkInqProtseqsW
#undef RpcNetworkIsProtseqValidW
#undef RpcNsBindingInqEntryNameW
#undef RpcProtseqVectorFreeW
#undef RpcServerInqDefaultPrincNameW
#undef RpcServerUseProtseqEpW
#undef RpcServerUseProtseqIfW
#undef RpcServerUseProtseqW
#undef RpcStringBindingComposeW
#undef RpcStringBindingParseW
#undef RpcStringFreeW
#undef ScrollConsoleScreenBufferW
#undef SearchPathW
#undef SendMessageCallbackW
#undef SendMessageTimeoutW
#undef SetClassLongW
#undef SetComputerNameW
#undef SetConsoleTitleW
#undef SetCurrentDirectoryW
#undef SetDefaultCommConfigW
#undef SetEnvironmentVariableW
#undef SetFileSecurityW
#undef SetFormW
#undef SetICMProfileW
#undef SetJobW
#undef SetPrinterDataW
#undef SetPrinterW
#undef SetUserObjectInformationW
#undef SetVolumeLabelW
#undef SetWindowsHookW
#undef SHBrowseForFolderW
#undef Shell_NotifyIconW
#undef ShellAboutW
#undef ShellExecuteW
#undef ShellExecuteExW
#undef SHFileOperationW
#undef SHGetFileInfoW
#undef SHGetNewLinkInfoW
#undef SHGetPathFromIDListW
#undef sndPlaySoundW
#undef StartDocPrinterW
#undef StgCreateDocfileW
#undef TranslateURLW
#undef UpdateICMRegKeyW
#undef URLAssociationDialogW
#undef UuidFromStringW
#undef VerFindFileW
#undef VerInstallFileW
#undef VerLanguageNameW
#undef VerQueryValueW
#undef VkKeyScanExW
#undef WaitNamedPipeW
#undef waveInGetDevCapsW
#undef waveInGetErrorTextW
#undef waveOutGetDevCapsW
#undef waveOutGetErrorTextW
#undef wglUseFontBitmapsW
#undef wglUseFontOutlinesW
#undef WinExecErrorW
#undef WNetAddConnection2W
#undef WNetAddConnection3W
#undef WNetAddConnectionW
#undef WNetCancelConnection2W
#undef WNetCancelConnectionW
#undef WNetConnectionDialog1W
#undef WNetDisconnectDialog1W
#undef WNetEnumResourceW
#undef WNetGetConnectionW
#undef WNetGetLastErrorW
#undef WNetGetNetworkInformationW
#undef WNetGetProviderNameW
#undef WNetGetUniversalNameW
#undef WNetGetUserW
#undef WNetOpenEnumW
#undef WNetSetConnectionW
#undef WNetUseConnectionW
#undef WriteConsoleInputW
#undef WriteConsoleOutputCharacterW
#undef WriteConsoleOutputW
#undef WriteConsoleW
#undef WritePrivateProfileSectionW
#undef WritePrivateProfileStructW
#undef WriteProfileSectionW
#undef WriteProfileStringW
#undef wvsprintfW
#endif // DEBUG

#endif // __WIN95WRP_CPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\win95wrp.cpp ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       win95wrp.cpp
//
//  This file was taken from the Davinci sources and adapted for TriEdit
//  on 3/11/98 in order to get rid of the external dependency for the TriEdit SDK
//  The adaptation process included getting rid of several APIs that were not being
//  supported and moving some APIs from the supported to unsupported group
//
//  Contents:   Unicode wrapper API, used only on Win95
//
//  Functions:  About 125 Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//              All memory allocation is done on the stack.
//
//----------------------------------------------------------------------------

// Includes ------------------------------------------------------------------
#include "stdafx.h"

// The following two lines will ensure that no mapping from Foo to OFoo will take place
// and the real windows APIs will get called from this file
#define __WIN95WRP_CPP__
#include "win95wrp.h"

#include <mbstring.h>
#include <commctrl.h>
#include <shlobj.h>

// Function prototypes
inline LONG UnicodeToAnsi(LPSTR szOut, LPCWSTR pwszIn, LONG cbOut, LONG cbIn = -1) throw();
inline LONG AnsiToUnicode(LPWSTR pwszOut, LPCSTR szIn, LONG cbOut, LONG cbIn = -1) throw();

BOOL g_fWin95;
BOOL g_fOSInit = FALSE;

// Debug ----------------------------------------------------------------------
#ifdef _DEBUG
#define Assert(f)   ((f) ? 0 : AssertFail(#f))
#define Verify(f)   Assert(f)
#define Debug(f)    (f)
#else
#define Assert(f)   (0)
#define Verify(f)   (f)
#define Debug(f)    (0)
#endif

#ifdef DEBUG
int AssertFail(const CHAR *pszMsg) throw()
{
	int wRet = MessageBoxA(NULL, pszMsg, "Assert Failed in Win95 layer",
						   MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 |
						   MB_SYSTEMMODAL | MB_ICONHAND );

	switch (wRet)
		{
		case IDABORT:
			FatalAppExit(0, L"BOO HOO");
			break;

		case IDRETRY:
			DebugBreak();
			// deliberately fall through to IDIGNORE in order to continue

		case IDIGNORE:

			// go aways
			break;
		}
	return 0;
}
#else
#define AssertFail(s) (0)
#endif  // ! DEBUG

// This macro determines whether a LPTSTR is an atom or string pointer
#define FATOM(x)    (!(HIWORD((x))))

// OffsetOf       - Return the byte offset into s of m
#define	OffsetOf(s,m)	(size_t)(((unsigned char*)&(((s*)0)->m))-((unsigned char*)0))

inline LONG UnicodeToAnsi(LPSTR szDestString, LPCWSTR pwszSrcString,
						  LONG  cbDestString, LONG    cbSrcString ) throw()
{

	Assert(-1 != cbDestString && (!cbDestString || szDestString));
	return WideCharToMultiByte(CP_ACP, 0, pwszSrcString, cbSrcString,
							   szDestString, cbDestString, NULL, NULL);

}

inline LONG AnsiToUnicode(LPWSTR pwszDestString, LPCSTR szSrcString,
						  LONG   cbDestString,   LONG   cbSrcString ) throw()
{

	Assert(-1 != cbDestString && (!cbDestString || pwszDestString));
	return MultiByteToWideChar(CP_ACP, 0, szSrcString, cbSrcString,
							   pwszDestString, cbDestString );
}

inline bool FWide() throw()
{
	if (!g_fOSInit)
	{
		OSVERSIONINFOA osvi;
		osvi.dwOSVersionInfoSize = sizeof(osvi);

		GetVersionExA(&osvi);
		g_fWin95 = (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId);
		g_fOSInit = TRUE;
	}

	Assert(g_fOSInit);
	return !g_fWin95;
}

//  The implementation of the Unicode to ANSI (MBCS) convertion macros use the
//  _alloca() function to allocate memory from the stack instead of the heap.
//  Allocating memory from the stack is much faster than allocating memory on
//  the heap, and the memory is automatically freed when the function is exited.
//  In addition, these macros avoid calling WideCharToMultiByte more than one
//  time.  This is done by allocating a little bit more memory than is
//  necessary.  We know that an MBC will convert into at most one WCHAR and
//  that for each WCHAR we will have a maximum of two MBC bytes.  By allocating
//  a little more than necessary, but always enough to handle the conversion
//  the second call to the conversion function is avoided.  The call to the
//  helper function UnicodeToAnsi reduces the number of argument pushes that
//  must be done in order to perform the conversion (this results in smaller
//  code, than if it called WideCharToMultiByte directly).
//
//  In order for the macros to store the temporary length and the pointer to
//  the resultant string, it is necessary to declare some local variables
//  called _len and _sz in each function that uses these conversion macros.
//  This is done by invoking the PreConvert macro in each function before any
//  uses of Convert or ConverWithLen.  (PreConvert just need to be invoked once
//  per function.)

#define PreConvert() \
	LONG   _len;     \
	LPSTR  _sz;      \
	LONG   _lJunk;   \
	_lJunk; // Unused sometimes

// stack-allocates a char buffer of size cch
#define SzAlloc(cch)  ((LPSTR)_alloca(cch))

// stack-allocates a wchar buffer of size cch
#define SzWAlloc(cch) ((LPWSTR)_alloca(cch * sizeof(WCHAR)))

// Returns a properly converted string,
//   or NULL string on failure or szFrom == NULL
// On return the variable passed via pnTo will have the output byte count
//   (including the trailing '\0' iff the nFrom is -1)
#define ConvertWithLen(szFrom, nFrom, pnTo) \
			(!szFrom ? NULL : \
				(_len = (-1 == nFrom ? (wcslen(szFrom) + 1) : nFrom) * \
						sizeof(WCHAR), \
				 _sz = SzAlloc(_len + sizeof(WCHAR)), \
				 Debug(_sz[_len] = '\0'), \
				 (((*pnTo) = UnicodeToAnsi(_sz, szFrom, _len, nFrom)) < 0 ? \
				  (AssertFail("Convert failed in Unicode wrapper"), NULL) : \
				  (Assert('\0' == _sz[_len]), _sz) ) ) )
#define Convert(szFrom) ConvertWithLen(szFrom, -1, &_lJunk)

// There are strings which are blocks of strings end to end with a trailing '\0'
// to indicate the true end.  These strings are used with the REG_MULTI_SZ
// option of the Reg... routines and the lpstrFilter field of the OPENFILENAME
// structure used in the GetOpenFileName and GetSaveFileName routines.  To help
// in converting these strings here are two routines which calculate the length
// of the Unicode and ASNI versions (including all '\0's!):

size_t
cUnicodeMultiSzLen
(
LPCWSTR lpsz
) throw()
{
	size_t cRet = 0;
	while (*lpsz)
		{
		size_t c = wcslen(lpsz) + 1;
		cRet += c;
		lpsz += c;
		}
	return cRet + 1;
}

size_t
cAnsiMultiSzLen
(
LPCSTR lpsz
) throw()
{
	size_t cRet = 0;
	while (*lpsz)
		{
		size_t c = _mbslen((const unsigned char*)lpsz) + 1;
		cRet += c;
		lpsz += c;
		}
	return cRet + 1;
}

extern "C"{

BOOL
WINAPI
OAppendMenuW(
	HMENU hMenu,
	UINT uFlags,
	UINT uIDnewItem,
	LPCWSTR lpnewItem
	)
{
	if(FWide())
		return AppendMenuW(hMenu, uFlags, uIDnewItem, lpnewItem);

	if(MF_STRING != uFlags)
		return AppendMenuA(hMenu, uFlags, uIDnewItem, (LPSTR)lpnewItem);

	PreConvert();
	LPSTR sz = Convert(lpnewItem);
	if (sz == NULL)
		return(0);
	return AppendMenuA(hMenu, uFlags, uIDnewItem, sz);
}

LRESULT
WINAPI
OCallWindowProcW(
	WNDPROC lpPrevWndFunc,
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return CallWindowProcW(lpPrevWndFunc, hWnd, Msg, wParam, lParam);

	return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);  //$ CONSIDER - Not really wrapped
}

DWORD
WINAPI
OCharLowerBuffW(
	LPWSTR lpsz,
	DWORD cchLength)
{
	if(!lpsz)
		return 0;

	if(FWide())
		return CharLowerBuffW(lpsz, cchLength);

	DWORD i = 0;
	while(i++ < cchLength)
		{
		*lpsz = towlower(*lpsz);
		lpsz++;
		}
	return i;
}

LPWSTR
WINAPI
OCharLowerW(
	LPWSTR lpsz)
{
	if(!lpsz)
		return NULL;

	if(FWide())
		return CharLowerW(lpsz);

	// Checking if it's a single byte character.
	if(FATOM(lpsz))
		{
		return (LPWSTR)towlower((WCHAR)LOWORD(lpsz));
		}

	LPWSTR lp = lpsz;

	while(*lp)
		{
		*lp = towlower(*lp);
		lp++;
		}
	return lpsz;
}

// From: Mark Ashton on 5/29/97
LPWSTR
WINAPI
OCharPrevW(
	LPCWSTR lpszStart,
	LPCWSTR lpszCurrent)
{
	return (LPWSTR)((lpszStart != lpszCurrent) ? lpszCurrent - 1 : lpszCurrent);
}

BOOL
WINAPI
OCharToOemW(
	LPCWSTR lpszSrc,
	LPSTR lpszDst)
{
	if(FWide())
		{
		Assert((LPSTR) lpszSrc != lpszDst);
		return CharToOemW(lpszSrc, lpszDst);
		}

	PreConvert();
	LPSTR sz = Convert(lpszSrc);

	return CharToOemA(sz, lpszDst);
}

LPWSTR
WINAPI
OCharUpperW(
	LPWSTR lpsz)
{
	if(!lpsz)
		return NULL;

	if(FWide())
		return CharUpperW(lpsz);

	// Checking if it's a single byte character.
	if(FATOM(lpsz))
		{
		return (LPWSTR)towupper((WCHAR)LOWORD(lpsz));
		}

	LPWSTR lp = lpsz;

	while(*lp)
		{
		*lp = towupper(*lp);
		lp++;
		}
	return lpsz;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OCopyFileW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName,
	BOOL bFailIfExists
	)
{
	if (FWide())
		return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);

	char szExisting[_MAX_PATH], szNew[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szExisting, lpExistingFileName, _MAX_PATH));
	Verify(0 <= UnicodeToAnsi(szNew, lpNewFileName, _MAX_PATH));
	return CopyFileA(szExisting, szNew, bFailIfExists);
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OCreateDirectoryW(
	LPCWSTR lpPathName,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	if (FWide())
		return CreateDirectoryW(lpPathName, lpSecurityAttributes);

	PreConvert();
	LPSTR sz = Convert(lpPathName);
	if (sz == NULL)
		return(0);
	return CreateDirectoryA(sz, NULL);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith: simpified on 6/25
// Smoke tested by Mark Ashton on 6/25
BOOL
WINAPI
OCreateDirectoryExW(
	LPCWSTR lpTemplateDirectory,
	LPCWSTR lpNewDirectory,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	if (FWide())
		return CreateDirectoryExW(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);

	PreConvert();
	LPSTR szTemplateDirectory = Convert(lpTemplateDirectory);
	LPSTR szNewDirectory      = Convert(lpNewDirectory);
	return CreateDirectoryExA(szTemplateDirectory, szNewDirectory, NULL);
}

HDC
WINAPI
OCreateEnhMetaFileW(
	HDC hdc,
	LPCWSTR lpFileName,
	CONST RECT *lpRect,
	LPCWSTR lpDescription)
{
	if(FWide())
		return CreateEnhMetaFileW(hdc, lpFileName, lpRect, lpDescription);

	PreConvert();
	LPSTR szN = Convert(lpFileName);
	LPSTR szD = ConvertWithLen(lpDescription, cUnicodeMultiSzLen(lpDescription), &_lJunk);
	return  CreateEnhMetaFileA(hdc, szN, lpRect, szD);
}

HANDLE
WINAPI
OCreateEventW(
	LPSECURITY_ATTRIBUTES lpEventAttributes,
	BOOL bManualReset,
	BOOL bInitialState,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateEventA(lpEventAttributes, bManualReset, bInitialState, sz);
}

HANDLE
WINAPI
OCreateFileW(
	LPCWSTR lpFileName,
	DWORD dwDesiredAccess,
	DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes,
	HANDLE hTemplateFile
	)
{
	// Don't even attempt this on Win95!
	Assert(0 != wcsncmp(lpFileName, L"\\\\?\\", 4));

	if(FWide())
		return CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
			dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	return CreateFileA(sz, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
		dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
}

HFONT
WINAPI
OCreateFontIndirectW(CONST LOGFONTW * plfw)
{
	Assert(plfw);

	if(FWide())
		return CreateFontIndirectW(plfw);

	LOGFONTA  lfa;
	//HFONT     hFont = NULL;

	// It's assumed here that sizeof(LOGFONTA) <= sizeof (LOGFONTW);
	memcpy(&lfa, plfw, sizeof(LOGFONTA));

	Verify(0 <= UnicodeToAnsi(lfa.lfFaceName, plfw->lfFaceName, LF_FACESIZE));
	return CreateFontIndirectA(&lfa);
}

// From: Mark Ashton on 5/29/97
HFONT
OCreateFontW(
	int nHeight, // logical height of font
	int nWidth, // logical average character width
	int nEscapement, // angle of escapement
	int nOrientation, // base-line orientation angle
	int fnWeight, // font weight
	DWORD fdwItalic, // italic attribute flag
	DWORD fdwUnderline, // underline attribute flag
	DWORD fdwStrikeOut, // strikeout attribute flag
	DWORD fdwCharSet, // character set identifier
	DWORD fdwOutputPrecision, // output precision
	DWORD fdwClipPrecision, // clipping precision
	DWORD fdwQuality, // output quality
	DWORD fdwPitchAndFamily, // pitch and family
	LPCWSTR lpszFace) // pointer to typeface name string
{
	if (FWide())
		return CreateFontW(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, lpszFace);
	PreConvert();
	LPSTR sz = Convert(lpszFace);
	return CreateFontA(nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, sz);
}

HWND
WINAPI
OCreateMDIWindowW(
	LPWSTR lpClassName,
	LPWSTR lpWindowName,
	DWORD dwStyle,
	int X,
	int Y,
	int nWidth,
	int nHeight,
	HWND hWndParent,
	HINSTANCE hInstance,
	LPARAM lParam
	)
{
	if(FWide())
		return CreateMDIWindowW(lpClassName, lpWindowName, dwStyle,
			X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);

	PreConvert();
	LPSTR szClass = Convert(lpClassName);
	LPSTR szWin   = Convert(lpWindowName);

	return CreateMDIWindowA(szClass, szWin, dwStyle,
			X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
}

HDC
WINAPI
OCreateMetaFileW(LPCWSTR lpstr)
{
	if(FWide())
		return CreateMetaFileW(lpstr);

	PreConvert();
	LPSTR sz = Convert(lpstr);
	return CreateMetaFileA(sz);
}

HANDLE
WINAPI
OCreateSemaphoreW(
	LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
	LONG lInitialCount,
	LONG lMaximumCount,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateSemaphoreW(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateSemaphoreA(lpSemaphoreAttributes, lInitialCount, lMaximumCount, sz);
}

HWND
WINAPI
OCreateWindowExW( DWORD dwExStyle,
			  LPCWSTR lpClassName,
				LPCWSTR lpWindowName,
				DWORD dwStyle,
				int X,
				int Y,
				int nWidth,
				int nHeight,
				HWND hWndParent ,
				HMENU hMenu,
				HINSTANCE hInstance,
				LPVOID lpParam )
{
	if(FWide())
		return CreateWindowExW(dwExStyle,
				lpClassName,
				lpWindowName,
				dwStyle,
				X,
				Y,
				nWidth,
				nHeight,
				hWndParent ,
				hMenu,
				hInstance,
				lpParam );

	PreConvert();

	LPSTR szClass;
	if (FATOM(lpClassName))
		{
		// is it an atom?
		szClass = (LPSTR) lpClassName;
		}
	else
		{
		// otherwise convert the string
		szClass = Convert(lpClassName);
		}
	LPSTR szWindow = Convert(lpWindowName);

	return CreateWindowExA (dwExStyle, szClass, szWindow, dwStyle, X, Y,
						 nWidth, nHeight, hWndParent, hMenu, hInstance,
						 lpParam);

}

HSZ
WINAPI
ODdeCreateStringHandleW(
	DWORD idInst,
	LPCWSTR psz,
	int iCodePage)
{
	if(FWide())
		{
		Assert(CP_WINUNICODE == iCodePage);
		return DdeCreateStringHandleW(idInst, psz, iCodePage);
		}
	PreConvert();
	LPSTR sz = Convert(psz);
	return DdeCreateStringHandleA(idInst, sz, CP_WINANSI);
}

UINT
WINAPI
ODdeInitializeW(
	LPDWORD pidInst,
	PFNCALLBACK pfnCallback,
	DWORD afCmd,
	DWORD ulRes)
{
	if(FWide())
		return DdeInitializeW(pidInst, pfnCallback, afCmd, ulRes);
	return DdeInitializeA(pidInst, pfnCallback, afCmd, ulRes);
}

LRESULT
WINAPI
ODefFrameProcW(
	HWND hWnd,
	HWND hWndMDIClient ,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefFrameProcW(hWnd, hWndMDIClient , uMsg, wParam, lParam);

	return DefFrameProcA(hWnd, hWndMDIClient , uMsg, wParam, lParam);
}

LRESULT
WINAPI
ODefMDIChildProcW(
	HWND hWnd,
	UINT uMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefMDIChildProcW(hWnd, uMsg, wParam, lParam);

	return DefMDIChildProcA(hWnd, uMsg, wParam, lParam);
}

LRESULT
WINAPI
ODefWindowProcW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return DefWindowProcW( hWnd, Msg,wParam, lParam);

	return DefWindowProcA( hWnd, Msg,wParam, lParam);
}

BOOL
WINAPI
ODeleteFileW(
	LPCWSTR pwsz)
{
	if(FWide())
		return DeleteFileW(pwsz);

	PreConvert();
	LPSTR sz = Convert(pwsz);
	return DeleteFileA(sz);
}

LRESULT
WINAPI
ODialogBoxIndirectParamW(
	HINSTANCE hInstance,
	LPCDLGTEMPLATEW hDialogTemplate,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	if(FWide())
		return DialogBoxIndirectParamW(hInstance, hDialogTemplate, hWndParent ,
			lpDialogFunc, dwInitParam);

	return DialogBoxIndirectParamA(hInstance, hDialogTemplate, hWndParent ,
			lpDialogFunc, dwInitParam);
}

LRESULT
WINAPI
ODialogBoxParamW(
	HINSTANCE hInstance,
	LPCWSTR lpTemplateName,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	if(FWide())
		return DialogBoxParamW(hInstance, lpTemplateName, hWndParent , lpDialogFunc, dwInitParam);

	if(FATOM(lpTemplateName))
		return DialogBoxParamA(hInstance, (LPSTR)lpTemplateName, hWndParent , lpDialogFunc, dwInitParam);

	PreConvert();
	LPSTR sz = Convert(lpTemplateName);
	return DialogBoxParamA(hInstance, sz, hWndParent , lpDialogFunc, dwInitParam);
}

LRESULT
WINAPI
ODispatchMessageW(
	CONST MSG *lpMsg)
{
	if(FWide())
		return DispatchMessageW(lpMsg);

	return DispatchMessageA(lpMsg);
}

int
WINAPI
ODrawTextW(
	HDC hDC,
	LPCWSTR lpString,
	int nCount,
	LPRECT lpRect,
	UINT uFormat)
{
	// NOTE OS may write 3 characters beyond end of lpString so make room!


	if(FWide())
		return DrawTextW(hDC, lpString, nCount, lpRect, uFormat);

	bool fModifyString = (uFormat & DT_MODIFYSTRING) &&
						 (uFormat & (DT_END_ELLIPSIS | DT_PATH_ELLIPSIS));

	const int nBuff = WideCharToMultiByte(CP_ACP, 0, lpString, nCount,
										  NULL, 0, NULL, NULL );
	Assert(0 <= nBuff);

	// OS may write beyond end of buffer so make room!
	const LPSTR sz = SzAlloc(nBuff + 4);

	Verify(nBuff == WideCharToMultiByte(CP_ACP, 0, lpString, nCount,
										sz, nBuff, NULL, NULL ));

	if (fModifyString)
		{
		// DrawTextA doesn't nessacerily '\0' terminate the output,
		// so have termiators ready
		memcpy(sz + nBuff, "\0\0\0\0", 4);
		}

	const int iDrawTextReturn = DrawTextA(hDC, sz, nBuff - 1, lpRect, uFormat);

	// With certain flags, DrawText modifies the string, truncating it with
	// an ellipsis.  We need to convert back and update the string passed to
	// the wrapper before we return.
	if (fModifyString && 0 <= iDrawTextReturn)
		{
		Assert('\0' == sz[nBuff + 3]); // Verify not too many were overwritten

		// The windows function prototype has lpString as constant even
		//    though the string gets modified!
		const int nStringLen = -1 != nCount ? nCount : wcslen(lpString);
		Verify(0 <= AnsiToUnicode(const_cast<LPWSTR>(lpString), sz,
								 nStringLen + 4 ));
		}
	return iDrawTextReturn;
}

// Written by Bill Hiebert on 9/4/97
// Smoke tested by Bill Hiebert 9/4/97
int
WINAPI
ODrawTextExW(HDC hdc, LPWSTR pwsz, int cb, LPRECT lprect, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams)
{
	Assert(-1 != cb);
	Assert(!(DT_MODIFYSTRING & dwDTFormat));

	if(FWide())
		return DrawTextExW(hdc, pwsz, cb, lprect, dwDTFormat, lpDTParams);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);

	if (sz == NULL)
		return(0);

	return DrawTextExA(hdc, sz, n, lprect, dwDTFormat, lpDTParams);
}


// Written for Carlos Gomes on 6/26/97 by Ted Smith
// Smoke tested by Carlos Gomes on 6/26
DWORD
WINAPI
OExpandEnvironmentStringsW(
	LPCWSTR lpSrc,
	LPWSTR lpDst,
	DWORD nSize
	)
{
	if (FWide())
		return ExpandEnvironmentStringsW(lpSrc, lpDst, nSize);

	PreConvert();
	LPSTR szSrc = Convert(lpSrc);
	LPSTR szDst = SzAlloc(sizeof(WCHAR) * nSize);

	if (szSrc == NULL)
		return(0);

	DWORD dwRet = ExpandEnvironmentStringsA(szSrc, szDst, sizeof(WCHAR) * nSize);

	if (dwRet)
		{
		LONG lRet = AnsiToUnicode(lpDst, szDst, nSize, min(dwRet, sizeof(WCHAR) * nSize));
		if (dwRet < (DWORD) lRet)
			{
			dwRet = lRet;
			}
		}
	else if (lpDst && 0 < nSize)
		{
		*lpDst = L'\0';
		}

	return dwRet;
}

VOID
WINAPI
OFatalAppExitW(
	UINT uAction,
	LPCWSTR lpMessageText
	)
{
	if(FWide())
		FatalAppExitW(uAction, lpMessageText);

	PreConvert();
	LPSTR sz = Convert(lpMessageText);
	FatalAppExitA(uAction, sz);
}

// From: Mark Ashton on 5/8/97
HANDLE
WINAPI
OFindFirstChangeNotificationW(
	LPCWSTR lpPathName,
	BOOL bWatchSubtree,
	DWORD dwNotifyFilter
	)
{
	if (FWide())
		return FindFirstChangeNotificationW(lpPathName, bWatchSubtree, dwNotifyFilter);

	PreConvert();
	LPSTR sz = Convert(lpPathName);
	if (sz == NULL)
		return(INVALID_HANDLE_VALUE);

	return FindFirstChangeNotificationA(sz, bWatchSubtree, dwNotifyFilter);
}

// From: Mark Ashton on 5/8/97
HANDLE
WINAPI
OFindFirstFileW(
	LPCWSTR lpFileName,
	LPWIN32_FIND_DATAW lpFindFileData
	)
{
	if (FWide())
		return FindFirstFileW(lpFileName, lpFindFileData);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	if (sz == NULL)
		return(INVALID_HANDLE_VALUE);

	WIN32_FIND_DATAA findFileData;
	HANDLE h = FindFirstFileA(sz, &findFileData);
	if (INVALID_HANDLE_VALUE != h)
		{
		lpFindFileData->dwFileAttributes    = findFileData.dwFileAttributes;
		lpFindFileData->ftCreationTime      = findFileData.ftCreationTime;
		lpFindFileData->ftLastAccessTime    = findFileData.ftLastAccessTime;
		lpFindFileData->ftLastWriteTime     = findFileData.ftLastWriteTime;
		lpFindFileData->nFileSizeHigh       = findFileData.nFileSizeHigh;
		lpFindFileData->nFileSizeLow        = findFileData.nFileSizeLow;
		lpFindFileData->dwReserved0         = findFileData.dwReserved0;
		lpFindFileData->dwReserved1         = findFileData.dwReserved1;
		Verify(0 <= AnsiToUnicode(lpFindFileData->cFileName, findFileData.cFileName, _MAX_PATH));
		Verify(0 <= AnsiToUnicode(lpFindFileData->cAlternateFileName, findFileData.cAlternateFileName, 14));
		}
	return h;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OFindNextFileW(
	HANDLE hFindFile,
	LPWIN32_FIND_DATAW lpFindFileData
	)
{
	if (FWide())
		return FindNextFileW(hFindFile, lpFindFileData);

	WIN32_FIND_DATAA findFileData;
	BOOL fFlag = FindNextFileA(hFindFile, &findFileData);
	if (fFlag)
		{
		lpFindFileData->dwFileAttributes    = findFileData.dwFileAttributes;
		lpFindFileData->ftCreationTime      = findFileData.ftCreationTime;
		lpFindFileData->ftLastAccessTime    = findFileData.ftLastAccessTime;
		lpFindFileData->ftLastWriteTime     = findFileData.ftLastWriteTime;
		lpFindFileData->nFileSizeHigh       = findFileData.nFileSizeHigh;
		lpFindFileData->nFileSizeLow        = findFileData.nFileSizeLow;
		lpFindFileData->dwReserved0         = findFileData.dwReserved0;
		lpFindFileData->dwReserved1         = findFileData.dwReserved1;
		Verify(0 <= AnsiToUnicode(lpFindFileData->cFileName, findFileData.cFileName, _MAX_PATH));
		Verify(0 <= AnsiToUnicode(lpFindFileData->cAlternateFileName, findFileData.cAlternateFileName, 14));
		}
	return fFlag;
}

HRSRC
WINAPI
OFindResourceW(
	HINSTANCE hModule,
	LPCWSTR lpName,
	LPCWSTR lpType
	)
{
	if(FWide())
		return FindResourceW(hModule, lpName, lpType);

	LPCSTR szName = (LPCSTR)lpName;
	LPCSTR szType = (LPCSTR)lpType;

	PreConvert();
	if(!FATOM(lpName))
		szName = Convert(lpName);
	if(!FATOM(lpType))
		szType = Convert(lpType);

	return FindResourceA(hModule, szName, szType);
}

HWND
WINAPI
OFindWindowW(
	LPCWSTR lpClassName ,
	LPCWSTR lpWindowName)
{
	if(FWide())
		return FindWindowW(lpClassName , lpWindowName);

	PreConvert();
	LPSTR szClass = Convert(lpClassName);
	LPSTR szWnd   = Convert(lpWindowName);

	return FindWindowA(szClass, szWnd);
}

// Bill Hiebert of IStudio on 6/13/97 added support for the
//   FORMAT_MESSAGE_ALLOCATE_BUFFER flag
// Bill donated a bugfix for 1819 on 8/1/97

DWORD
WINAPI
OFormatMessageW(
	DWORD dwFlags,
	LPCVOID lpSource,
	DWORD dwMessageId,
	DWORD dwLanguageId,
	LPWSTR lpBuffer,
	DWORD nSize,
	va_list *Arguments)
{

	if (FWide())
		return FormatMessageW(dwFlags, lpSource, dwMessageId, dwLanguageId,
							  lpBuffer, nSize, Arguments );

	DWORD dwRet;

	LPSTR szBuffer = NULL;

	if (!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER))
		{
		Assert(!IsBadWritePtr(lpBuffer, nSize * sizeof(WCHAR)));
		szBuffer = SzAlloc(sizeof(WCHAR) * nSize);
		}

	if (dwFlags & FORMAT_MESSAGE_FROM_STRING)
		{
		PreConvert();
		LPSTR szSource = Convert((LPWSTR)lpSource);

		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{   // Must pass address of szBuffer
			dwRet = FormatMessageA(dwFlags, szSource, dwMessageId, dwLanguageId,
				(char*)&szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		else
			{
			dwRet = FormatMessageA(dwFlags, szSource, dwMessageId, dwLanguageId,
				szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		}
	else
		{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{   // Must pass address of szBuffer
			dwRet = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId,
					(char*)&szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		else
			{
			dwRet = FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId,
					szBuffer, sizeof(WCHAR) * nSize, Arguments);
			}
		}

	if (dwRet)
		{
		if (dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER)
			{ // szBuffer contains LocalAlloc ptr to new string. lpBuffer is a
			  // WCHAR** when FORMAT_MESSAGE_ALLOCATE_BUFFER is defined.
			WCHAR* pTemp = (WCHAR*)LocalAlloc(NONZEROLPTR, (dwRet + 1) * sizeof(WCHAR) );
			dwRet = pTemp == NULL? 0 : AnsiToUnicode(pTemp, szBuffer, dwRet + 1);
			LocalFree(szBuffer);
			if (dwRet)
				{
				*(WCHAR**)lpBuffer = pTemp;
				}
			return dwRet;
			}
		else
			{ // Just convert
			return AnsiToUnicode(lpBuffer, szBuffer, nSize);
			}
		}
	else if (lpBuffer && 0 < nSize)
		{
		*lpBuffer = L'\0';
		}

	return dwRet;
}

BOOL
APIENTRY
OGetCharABCWidthsFloatW(
	HDC     hdc,
	UINT    uFirstChar,
	UINT    uLastChar,
	LPABCFLOAT      lpABC)
{
	if(FWide())
		return GetCharABCWidthsFloatW(hdc, uFirstChar, uLastChar, lpABC);

	return GetCharABCWidthsFloatA(hdc, uFirstChar, uLastChar, lpABC);
}

BOOL
APIENTRY
OGetCharABCWidthsW(
	HDC hdc,
	UINT uFirstChar,
	UINT uLastChar,
	LPABC lpABC)
{
	if(FWide())
		return GetCharABCWidthsW(hdc, uFirstChar, uLastChar, lpABC);

	return GetCharABCWidthsA(hdc, uFirstChar, uLastChar, lpABC);
}

BOOL
APIENTRY
OGetCharWidthFloatW(
	HDC     hdc,
	UINT    iFirstChar,
	UINT    iLastChar,
	PFLOAT  pBuffer)
{
	if(FWide())
		return GetCharWidthFloatW(hdc, iFirstChar, iLastChar, pBuffer);

	return GetCharWidthFloatA(hdc, iFirstChar, iLastChar, pBuffer);
}


BOOL
WINAPI
OGetCharWidthW(
	HDC hdc,
	UINT iFirstChar,
	UINT iLastChar,
	LPINT lpBuffer)
{
	if(FWide())
		return GetCharWidth32W(hdc, iFirstChar, iLastChar, lpBuffer);

	return GetCharWidth32A(hdc, iFirstChar, iLastChar, lpBuffer);
}

// Static buffers for GetClassInfo[Ex] to return the classname
// and menuname in Unicode, when running on an Ansi system.
// The contract of GetClassInfo is that it returns const ptrs
// back to the class name and menu name.  Unfortuntely, this
// prevents us from translating these back from Ansi to Unicode,
// without having some static buffers to use.  Since we strongly
// believe that the only people calling this are doing it just to
// see if it succeeds or not, so they know whether the class is
// already registered, we've willing to just have one set of
// static buffers to use.
// CAUTION: this will work as long as two threads don't call
// GetClassInfo[Ex] at the same time!
static WCHAR g_szClassName[256];
static WCHAR g_szMenuName[256];

#ifdef DEBUG
static DWORD g_dwCallingThread = 0;    // debug global for ensuring one thread.
#endif // DEBUG

BOOL
WINAPI
OGetClassInfoW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSW lpWndClass
)
{
	if (FWide())
		return GetClassInfoW(hInstance, lpClassName, lpWndClass);

	PreConvert();
	LPSTR szClassName = Convert(lpClassName);
	BOOL fRet = GetClassInfoA(hInstance, szClassName, (LPWNDCLASSA)lpWndClass);
	if (!fRet)
		{
		return false;
		}

	// if ClassName or MenuName aren't atom's, we need to
	// translate them back to Unicode.  We use our static
	// buffers above.  See note about why and the CAUTION!
#ifdef DEBUG
	if (!g_dwCallingThread)
		g_dwCallingThread = GetCurrentThreadId();
	Assert(GetCurrentThreadId() == g_dwCallingThread);
#endif // DEBUG

	if (!FATOM(lpWndClass->lpszMenuName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszMenuName) <
				(sizeof(g_szMenuName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szMenuName, (LPCSTR)lpWndClass->lpszMenuName,
				strlen((LPCSTR)lpWndClass->lpszMenuName)+1))
			{
			return false;
			}
		lpWndClass->lpszMenuName = g_szMenuName;
		}

	if (!FATOM(lpWndClass->lpszClassName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszClassName) <
				(sizeof(g_szClassName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szClassName, (LPCSTR)lpWndClass->lpszClassName,
				strlen((LPCSTR)lpWndClass->lpszClassName)+1))
			{
			return false;
			}
		lpWndClass->lpszClassName = g_szClassName;
		}

	return fRet;
}

BOOL
WINAPI
OGetClassInfoExW
(
HINSTANCE hInstance,
LPCWSTR lpClassName,
LPWNDCLASSEXW lpWndClass
)
{
	if (FWide())
		return GetClassInfoExW(hInstance, lpClassName, lpWndClass);

	PreConvert();
	LPSTR szClassName = Convert(lpClassName);
	BOOL fRet = GetClassInfoExA(hInstance, szClassName, (LPWNDCLASSEXA)lpWndClass);
	if (!fRet)
		{
		return false;
		}

	// if ClassName or MenuName aren't atom's, we need to
	// translate them back to Unicode.  We use our static
	// buffers above.  See note about why and the CAUTION!
#ifdef DEBUG
	if (!g_dwCallingThread)
		g_dwCallingThread = GetCurrentThreadId();
	Assert(GetCurrentThreadId() == g_dwCallingThread);
#endif // DEBUG

	if (!FATOM(lpWndClass->lpszMenuName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszMenuName) <
				(sizeof(g_szMenuName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szMenuName, (LPCSTR)lpWndClass->lpszMenuName,
				strlen((LPCSTR)lpWndClass->lpszMenuName)+1))
			{
			return false;
			}
		lpWndClass->lpszMenuName = g_szMenuName;
		}

	if (!FATOM(lpWndClass->lpszClassName))
		{
		Assert(strlen((LPCSTR)lpWndClass->lpszClassName) <
				(sizeof(g_szClassName)/sizeof(WCHAR)));
		if (!AnsiToUnicode(g_szClassName, (LPCSTR)lpWndClass->lpszClassName,
				strlen((LPCSTR)lpWndClass->lpszClassName)+1))
			{
			return false;
			}
		lpWndClass->lpszClassName = g_szClassName;
		}

	return fRet;
}

DWORD
WINAPI
OGetClassLongW(
	HWND hWnd,
	int nIndex)
{
	if(FWide())
		return GetClassLongW(hWnd, nIndex);
	return GetClassLongA(hWnd, nIndex);  //$UNDONE_POST_98 Watch out for GCL_MENUNAME, etc!
}

DWORD
WINAPI
OSetClassLongW(
	HWND hWnd,
	int nIndex,
	LONG dwNewLong)
{
	if (FWide())
		return SetClassLongW(hWnd, nIndex, dwNewLong);

	return SetClassLongA(hWnd, nIndex, dwNewLong);  //$UNDONE_POST_98 Watch out for GCL_MENUNAME, etc!

}

int
WINAPI
OGetClassNameW(
	HWND hWnd,
	LPWSTR lpClassName,
	int nMaxCount)
{
	if(FWide())
		return GetClassNameW(hWnd, lpClassName, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount + 2);
	int nRet = GetClassNameA(hWnd, sz, sizeof(WCHAR) * nMaxCount);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (nRet)
		{
		// force null-termination
		sz[sizeof(WCHAR) * nMaxCount] = '\0';
		sz[sizeof(WCHAR) * nMaxCount + 1] = '\0';

		// need a temporary wide string
		LPWSTR wsz = SzWAlloc(2 * nMaxCount + 1);

		nRet = min(AnsiToUnicode(wsz, sz, 2 * nMaxCount + 1), nMaxCount);

		// copy the requested number of characters
		if (lpClassName)
			{
			memcpy(lpClassName, wsz, nRet * sizeof(WCHAR));
			}

		return nRet;
		}

	else if (lpClassName && 0 < nMaxCount)
		{
		*lpClassName = L'\0';
		}

	return nRet;
}

DWORD
WINAPI
OGetCurrentDirectoryW(
	DWORD nBufferLength,
	LPWSTR lpBuffer)
{
	if (FWide())
		return GetCurrentDirectoryW(nBufferLength, lpBuffer);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nBufferLength);
	DWORD dwRet = GetCurrentDirectoryA(sizeof(WCHAR) * nBufferLength, sz);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (dwRet)
		{
		return AnsiToUnicode(lpBuffer, sz, nBufferLength);
		}
	else if (lpBuffer && 0 < nBufferLength)
		{
		*lpBuffer = L'\0';
		}

	return dwRet;
}

UINT
WINAPI
OGetDlgItemTextW(
	HWND hDlg,
	int nIDDlgItem,
	LPWSTR lpString,
	int nMaxCount)
{
	if(FWide())
		return GetDlgItemTextW(hDlg, nIDDlgItem, lpString, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount);
	UINT uRet = GetDlgItemTextA(hDlg, nIDDlgItem, sz, sizeof(WCHAR) * nMaxCount);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(uRet)
		{
		return AnsiToUnicode(lpString, sz, nMaxCount);
		}
	else if (lpString && 0 < nMaxCount)
		{
		*lpString = L'\0';
		}

	return uRet;
}

DWORD
WINAPI
OGetFileAttributesW(
	LPCWSTR lpFileName
	)
{
	if(FWide())
		return GetFileAttributesW(lpFileName);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	if (sz == NULL)
		return(DWORD)(-1);

	return GetFileAttributesA(sz);
}

DWORD
WINAPI
OGetFullPathNameW(
	LPCWSTR lpFileName,
	DWORD nBufferLength,
	LPWSTR lpBuffer,
	LPWSTR *lpFilePart
	)
{
	if(FWide())
		return GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);

	PreConvert();
	LPSTR szFile = Convert(lpFileName);
	if (szFile == NULL)
		return(0); // dwRet

	LPSTR szBuffer = SzAlloc(sizeof(WCHAR) * nBufferLength);
	LPSTR pszFile;

	DWORD dwRet = GetFullPathNameA(szFile ,sizeof(WCHAR) * nBufferLength, szBuffer , &pszFile);

	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(dwRet)
		{
		DWORD dwNoOfChar = AnsiToUnicode(lpBuffer, szBuffer , nBufferLength);
		*pszFile = '\0';
		*lpFilePart = lpBuffer + AnsiToUnicode(NULL, szBuffer, 0);
		return dwNoOfChar;
		}

	return dwRet;
}

DWORD
WINAPI
OGetGlyphOutlineW(
	HDC     hdc,
	UINT    uChar,
	UINT    uFormat,
	LPGLYPHMETRICS      lpgm,
	DWORD       cbBuffer,
	LPVOID      lpvBuffer,
	CONST MAT2 *    lpmat2)
{
	if (FWide())
		return GetGlyphOutlineW(hdc, uChar, uFormat, lpgm, cbBuffer, lpvBuffer, lpmat2);

	return GetGlyphOutlineA(hdc, uChar, uFormat, lpgm, cbBuffer, lpvBuffer, lpmat2);
}

DWORD
WINAPI
OGetKerningPairsW(
	HDC         hdc,
	DWORD       nNumPairs,
	LPKERNINGPAIR       lpkrnpair)
{
	if(FWide())
		return GetKerningPairsW(hdc, nNumPairs, lpkrnpair);

	return GetKerningPairsA(hdc, nNumPairs, lpkrnpair);
}

BOOL
WINAPI
OGetMessageW(
	LPMSG lpMsg,
	HWND hWnd ,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax)
{
	if(FWide())
		return GetMessageW(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax);

	return GetMessageA(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax);
}

DWORD
WINAPI
OGetModuleFileNameW(
	HINSTANCE hModule,
	LPWSTR pwszFilename,
	DWORD nSize
	)
{
	if(FWide())
		return GetModuleFileNameW(
			hModule,
			pwszFilename,
			nSize
			);

	LPSTR sz    = SzAlloc(sizeof(WCHAR) * nSize);
	DWORD dwRet = GetModuleFileNameA(hModule, sz, sizeof(WCHAR) * nSize);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if (dwRet)
		{
		return AnsiToUnicode(pwszFilename, sz, nSize, dwRet + 1);
		}
	else if (pwszFilename && 0 < nSize)
		{
		*pwszFilename = L'\0';
		}

	return dwRet;
}

HMODULE
WINAPI
OGetModuleHandleW(
	LPCWSTR lpModuleName
	)
{
	if(FWide())
		return GetModuleHandleW(lpModuleName);

	PreConvert();
	LPSTR sz = Convert(lpModuleName);

	return GetModuleHandleA(sz);
}

UINT
APIENTRY
OGetOutlineTextMetricsW(
	HDC hdc,
	UINT cbData,
	LPOUTLINETEXTMETRICW lpOTM)
{
	// *** TextMetrics defines BYTE elements in the structure for the
	// value of first first/last character defined in the font.
	// Problem for DBCS.

	if(FWide())
		return GetOutlineTextMetricsW(hdc, cbData, lpOTM);

	return GetOutlineTextMetricsA(hdc, cbData, (LPOUTLINETEXTMETRICA)lpOTM); //$ UNDONE_POST_98 - This doesn't convert the embedded Names...
}

UINT
WINAPI
OGetPrivateProfileIntW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	INT nDefault,
	LPCWSTR lpFileName)
{
	if(FWide())
		return GetPrivateProfileIntW(lpAppName, lpKeyName, nDefault, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szFileName = Convert(lpFileName);

	return GetPrivateProfileIntA(szAppName, szKeyName, nDefault, szFileName);
}

DWORD
WINAPI
OGetPrivateProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpDefault,
	LPWSTR lpReturnedString,
	DWORD nSize,
	LPCWSTR lpFileName)
{
	if(FWide())
		return GetPrivateProfileStringW(lpAppName, lpKeyName, lpDefault, lpReturnedString,
		  nSize, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szDefault  = Convert(lpDefault);
	LPSTR szFileName = Convert(lpFileName);

	LPSTR szReturnedString = SzAlloc(sizeof(WCHAR) * nSize);

	DWORD dwRet = GetPrivateProfileStringA(szAppName, szKeyName, szDefault, szReturnedString,
	  sizeof(WCHAR) * nSize, szFileName);

	// I hope this doesn't fail because there's no clear failure value in the docs

	DWORD dwNoOfChar = AnsiToUnicode(lpReturnedString, szReturnedString, nSize);

	if (dwNoOfChar)
		return dwRet;
	else
		{
		LPWSTR lpTempString = SzWAlloc(sizeof(WCHAR) * nSize);
		if (AnsiToUnicode(lpTempString, szReturnedString, sizeof(WCHAR) * nSize))
			{
			if (lpAppName && lpKeyName)
				{
				lpTempString[nSize - 1] = L'\0';
				wcsncpy(lpReturnedString, lpTempString, nSize);
				return nSize - 1;
				}
			else
				{
				lpTempString[nSize - 1] = L'\0';
				lpTempString[nSize - 2] = L'\0';
				wcsncpy(lpReturnedString, lpTempString, nSize);
				return nSize - 2;
				}
			}
		}

	return dwRet;
}


int
WINAPI
OGetObjectW(
	HGDIOBJ hgdiobj,
	int cbBuffer,
	LPVOID lpvObject)
{
	if(FWide())
		return GetObjectW(hgdiobj, cbBuffer, lpvObject);

	DWORD dwObj = GetObjectType(hgdiobj);
	if (OBJ_FONT == dwObj)
		{
		//$CONSIDER: This effects all getobject call, performance?
		Assert(cbBuffer == sizeof(LOGFONTW));
		LOGFONTA  lfa;
		LOGFONTW *plfw = (LOGFONTW *)lpvObject;

		int nRet = GetObjectA(hgdiobj, sizeof(lfa), &lfa);

		if(nRet)
			{
			memcpy(plfw, &lfa, sizeof(LOGFONTA));
			Verify(0 <= AnsiToUnicode(plfw->lfFaceName, lfa.lfFaceName, LF_FACESIZE));
			}

		return nRet;
		}
	else
		{
		return GetObjectA(hgdiobj, cbBuffer, lpvObject);
		}
}

UINT
WINAPI
OGetProfileIntW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	INT nDefault
	)
{
	if(FWide())
		return GetProfileIntW(lpAppName, lpKeyName, nDefault);

	PreConvert();
	LPSTR szApp = Convert(lpAppName);
	LPSTR szKey = Convert(lpKeyName);

	return GetProfileIntA(szApp, szKey, nDefault);
}

HANDLE
WINAPI
OGetPropW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return GetPropW(hWnd, lpString);

	if(FATOM(lpString))
		return GetPropA(hWnd, (LPSTR)lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return GetPropA(hWnd, sz);
}

DWORD
WINAPI
OGetTabbedTextExtentW(
	HDC hDC,
	LPCWSTR lpString,
	int nCount,
	int nTabPositions,
	LPINT lpnTabStopPositions)
{
	Assert(-1 != nCount);

	if(FWide())
		return GetTabbedTextExtentW(hDC, lpString, nCount, nTabPositions, lpnTabStopPositions);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpString, nCount, &n);

	if (sz == NULL)
		return(0);

	return GetTabbedTextExtentA(hDC, sz, n, nTabPositions, lpnTabStopPositions);
}

// From: Mark Ashton on 5/8/97
UINT
WINAPI
OGetTempFileNameW(
	LPCWSTR lpPathName,
	LPCWSTR lpPrefixString,
	UINT uUnique,
	LPWSTR lpTempFileName
	)
{
	if (FWide())
		return GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

	char szPathName[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szPathName, lpPathName, _MAX_PATH));

	char szPrefixString[_MAX_PATH];
	Verify(0 <= UnicodeToAnsi(szPrefixString, lpPrefixString, _MAX_PATH));

	char szTempFilename[_MAX_PATH];
	UINT dwRet = GetTempFileNameA(szPathName, szPrefixString, uUnique, szTempFilename);
	if (dwRet)
		{
		Verify(0 <= AnsiToUnicode(lpTempFileName, szTempFilename, _MAX_PATH));
		}
	return dwRet;
}

// From: Mark Ashton on 5/8/97
DWORD
WINAPI
OGetTempPathW(
	DWORD nBufferLength,
	LPWSTR lpBuffer
	)
{
	if (FWide())
		return GetTempPathW(nBufferLength, lpBuffer);

	char szPath[_MAX_PATH];
	DWORD dwRet = GetTempPathA(_MAX_PATH, szPath);
	if (dwRet)
		{
		Verify(0 <= AnsiToUnicode(lpBuffer, szPath, nBufferLength));
		}
	return dwRet;
}

BOOL
APIENTRY
OGetTextExtentPoint32W(
					HDC hdc,
					LPCWSTR pwsz,
					int cb,
					LPSIZE pSize
					)
{
	Assert(-1 != cb);

	if(FWide())
		return GetTextExtentPoint32W(hdc, pwsz, cb, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);
	if (sz == NULL)
		return(0);

	return GetTextExtentPoint32A(hdc, sz, n, pSize);
}

BOOL
APIENTRY
OGetTextExtentPointW(
					HDC hdc,
					LPCWSTR pwsz,
					int cb,
					LPSIZE pSize
					)
{
	Assert(-1 != cb);

	if(FWide())
		return GetTextExtentPointW(hdc, pwsz, cb, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(pwsz, cb, &n);
	return GetTextExtentPointA(hdc, sz, n, pSize);
}

BOOL
APIENTRY OGetTextExtentExPointW(
					HDC hdc,
					LPCWSTR lpszStr,
					int cchString,
					int nMaxExtent,
					LPINT lpnFit,
					LPINT alpDx,
					LPSIZE pSize
					)
{
	Assert(-1 != cchString);

	if(FWide())
		return GetTextExtentExPointW(hdc, lpszStr, cchString,
									 nMaxExtent, lpnFit, alpDx, pSize);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpszStr, cchString, &n);
	if (sz == NULL)
		return(0);

	return GetTextExtentExPointA(hdc, sz, n, nMaxExtent, lpnFit, alpDx, pSize);

}

LONG
WINAPI
OGetWindowLongW(
	HWND hWnd,
	int nIndex)
{
	if(FWide())
		return GetWindowLongW(hWnd, nIndex);

	return GetWindowLongA(hWnd, nIndex);
}

BOOL
WINAPI
OGetTextMetricsW(
	HDC hdc,
	LPTEXTMETRICW lptm)
{
	if(FWide())
		return GetTextMetricsW(hdc, lptm);

	TEXTMETRICA tma;

	memcpy(&tma, lptm, OffsetOf(TEXTMETRIC, tmFirstChar));

	// tmFirstChar is defined as BYTE.
	// $CONSIDER : will fail for DBCS !!

	wctomb((LPSTR)&tma.tmFirstChar, lptm->tmFirstChar);
	wctomb((LPSTR)&tma.tmLastChar, lptm->tmLastChar);
	wctomb((LPSTR)&tma.tmDefaultChar, lptm->tmDefaultChar);
	wctomb((LPSTR)&tma.tmBreakChar, lptm->tmBreakChar);

	memcpy(&tma.tmItalic, &lptm->tmItalic, sizeof(TEXTMETRIC) - OffsetOf(TEXTMETRIC, tmItalic));

	BOOL fRet = GetTextMetricsA(hdc, &tma);

	if(fRet)
		{
		memcpy(&lptm->tmItalic, &tma.tmItalic, sizeof(TEXTMETRIC) - OffsetOf(TEXTMETRIC, tmItalic));

		// Convert tma.tmFirstChar (1 byte char) to lptm->tmFirstChar
		mbtowc(&lptm->tmFirstChar, (LPSTR)&tma.tmFirstChar, 1);
		mbtowc(&lptm->tmLastChar, (LPSTR)&tma.tmLastChar, 1);
		mbtowc(&lptm->tmDefaultChar, (LPSTR)&tma.tmDefaultChar, 1);
		mbtowc(&lptm->tmBreakChar, (LPSTR)&tma.tmBreakChar, 1);

		memcpy(lptm, &tma, OffsetOf(TEXTMETRIC, tmFirstChar));
		}

	return fRet;
}

// From: Mark Ashton on 5/8/97
BOOL
WINAPI
OGetUserNameW (
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	if (FWide())
		return GetUserNameW(lpBuffer, nSize);

	DWORD dwLen = *nSize;
	LPSTR sz = SzAlloc(dwLen);

	BOOL fFlag = GetUserNameA(sz, nSize);
	if (fFlag)
		{
		*nSize = AnsiToUnicode(lpBuffer, sz, dwLen);
		}
	return fFlag;
}

BOOL
WINAPI
OGetVolumeInformationW(
	LPCWSTR lpRootPathName,
	LPWSTR lpVolumeNameBuffer,
	DWORD nVolumeNameSize,
	LPDWORD lpVolumeSerialNumber,
	LPDWORD lpMaximumComponentLength,
	LPDWORD lpFileSystemFlags,
	LPWSTR lpFileSystemNameBuffer,
	DWORD nFileSystemNameSize
	)
{
	if(FWide())
		return GetVolumeInformationW(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber,
			lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);

	PreConvert();
	LPSTR szRoot = Convert(lpRootPathName);
	LPSTR szName = SzAlloc(sizeof(WCHAR) * nVolumeNameSize);
	LPSTR szSysName = SzAlloc(sizeof(WCHAR) * nFileSystemNameSize);

	BOOL fRet = GetVolumeInformationA(szRoot, szName, sizeof(WCHAR) * nVolumeNameSize, lpVolumeSerialNumber,
			lpMaximumComponentLength, lpFileSystemFlags, szSysName, sizeof(WCHAR) * nFileSystemNameSize);

	if(fRet)
		{
		if (!AnsiToUnicode(lpVolumeNameBuffer, szName, nVolumeNameSize) ||
			!AnsiToUnicode(lpFileSystemNameBuffer, szSysName, nFileSystemNameSize))
			{
			fRet = false;
			}
		}
	if (!fRet)
		{
		if (lpVolumeNameBuffer && 0 < nVolumeNameSize)
			{
			*lpVolumeNameBuffer = L'\0';
			}

		if (lpFileSystemNameBuffer && 0 < nFileSystemNameSize)
			{
			*lpFileSystemNameBuffer = L'\0';
			}
		}

	return fRet;
}

int
WINAPI
OGetWindowTextLengthW(
	HWND hWnd)
{
	if(FWide())
		return GetWindowTextLengthW(hWnd);

	return GetWindowTextLengthA(hWnd);
}

int
WINAPI
OGetWindowTextW(
	HWND hWnd,
	LPWSTR lpString,
	int nMaxCount)
{

	/*******  Blackbox Testing results for GetWindowText Win32 API ******

	TestCase    lpString    nMaxCount   Return Value    *lpString modified
	======================================================================
	Testing GetWindowTextW on WinNT :-
		A       not NULL        0           0               No
		B           NULL        0           0               No
		C           NULL    not 0           0               No
		D       not NULL    not 0       # of chars w/o      Yes
										\0 terminator

	Testing GetWindowTextA on Win95 :-
		A       not NULL        0           0               Yes
		B           NULL        0               GPF!!
		C           NULL    not 0               GPF!!
		D       not NULL    not 0       # of chars w/o      Yes
										\0 terminator
	*********************************************************************/

	if(FWide())
		return GetWindowTextW(hWnd, lpString, nMaxCount);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nMaxCount);
	int nRet = GetWindowTextA(hWnd, sz, sizeof(WCHAR) * nMaxCount);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(nRet)
		{
		return AnsiToUnicode(lpString, sz, nMaxCount);
		}
	else
		{
		// GetWindowText() returns 0 when you call it on a window which
		// has no text (e.g. edit control without any text). It also initializes
		// the buffer passed in to receive the text to "\0". So we should initialize
		// the buffer passed in before returning.
		if (lpString && 0 < nMaxCount)
			{
			*lpString = L'\0';
			}
		}

	return nRet;
}

ATOM
WINAPI
OGlobalAddAtomW(
	LPCWSTR lpString
	)
{
	if(FWide())
		return GlobalAddAtomW(lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	if (sz == NULL)
		return(0);

	return GlobalAddAtomA(sz);
}

// From: Josh Kaplan on 8/12/97
UINT
WINAPI
OGlobalGetAtomNameW(
	ATOM nAtom,
	LPWSTR lpBuffer,
	int nSize
	)
{
	if(FWide())
		return GlobalGetAtomNameW(nAtom, lpBuffer, nSize);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nSize);
	if (GlobalGetAtomNameA(nAtom, sz, sizeof(WCHAR) * nSize))
		{
		// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
		return AnsiToUnicode(lpBuffer, sz, nSize) - 1;
		}

	if (lpBuffer && 0 < nSize)
		{
		*lpBuffer = L'\0';
		}
	return 0;
}

BOOL
WINAPI
OGrayStringW(
	HDC hDC,
	HBRUSH hBrush,
	GRAYSTRINGPROC lpOutputFunc,
	LPARAM lpData,
	int nCount,
	int X,
	int Y,
	int nWidth,
	int nHeight)
{
	if(FWide())
		return GrayStringW(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);

	if (!lpOutputFunc)
		{
		PreConvert();
		LPSTR szData = Convert((LPCWSTR) lpData);
		if (szData == NULL)
			return(0);

		return GrayStringA(hDC, hBrush, lpOutputFunc, (LPARAM) szData, nCount, X, Y, nWidth, nHeight);
		}

	return GrayStringA(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
}

BOOL
WINAPI
OInsertMenuW(
	HMENU hMenu,
	UINT uPosition,
	UINT uFlags,
	UINT uIDNewItem,
	LPCWSTR lpNewItem
	)
{
	if(FWide())
		return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);

	if(uFlags & (MF_BITMAP | MF_OWNERDRAW))
		return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, (LPSTR)lpNewItem);

	PreConvert();
	LPSTR sz = Convert(lpNewItem);
	return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, sz);
}

BOOL
WINAPI
OIsBadStringPtrW(
	LPCWSTR lpsz,
	UINT ucchMax
	)
{
	if(FWide())
		return IsBadStringPtrW(lpsz, ucchMax);

	return IsBadStringPtrA((LPSTR) lpsz, ucchMax * sizeof(WCHAR));  //$UNDONE_POST_98 - We should use IsBadReadPtr(strlen)!
}


BOOL
WINAPI
OIsCharAlphaNumericW(
	WCHAR wch)
{
	if(FWide())
		return IsCharAlphaNumericW(wch);

	//$CONSIDER: we really want to use MB_CUR_MAX, but that is
	// not a defined constant
	CHAR psz[4];

	int cch = WideCharToMultiByte(CP_ACP, 0, &wch, 1, (CHAR *) psz, 4, NULL, NULL);
	if (1 == cch)
		{
		return IsCharAlphaNumericA(*psz);
		}
	else if (1 < cch)
		{
		// It's a multi-byte character, so treat it as alpha
		// Note: we are not sure that this is entirely correct
		return true;
		}
	else
		{
		return false;
		}
}

BOOL
WINAPI
OIsCharAlphaW(
	WCHAR wch)
{
	if(FWide())
		return IsCharAlphaW(wch);

	//$CONSIDER: we really want to use MB_CUR_MAX, but that is
	// not a defined constant
	CHAR psz[4];

	int cch = WideCharToMultiByte(CP_ACP, 0, &wch, 1, (CHAR *) psz, 4, NULL, NULL);
	if(1 == cch)
		{
		return IsCharAlphaA(*psz);
		}
	else if (1 < cch)
		{
		// It's a multi-byte character, so treat it as alpha
		// Note: we are not sure that this is entirely correct
		return true;
		}
	else
		{
		return false;
		}
}

BOOL
WINAPI
OIsDialogMessageW(
	HWND hDlg,
	LPMSG lpMsg)
{
	// WARNING!!!
	// Bug #6488. We have run into problems due to using IsDialogMessageW on
	// WinNT Japanese. The fix for the bug was calling ANSI version of
	// IsDialogMessage irrespective of whether we are running on NT or Win95.
	// The shell is compiled MBCS (not UNICODE) and they are always using the
	// ANSI versions of the routines. lpMsg passed by shell contains MBCS
	// characters & not UNICODE. So in cases where you get the message
	// structure from the Shell, you will have to call the IsDialogMessageA
	// directly and not use this wrapper.

	if(FWide())
		return IsDialogMessageW(hDlg, lpMsg);

	return IsDialogMessageA(hDlg, lpMsg);
}

// From: Mark Ashton on 5/8/97
//		 Bill Hieber - 2/5/98 fixed buffer size problem.
int
WINAPI
OLCMapStringW(
	LCID     Locale,
	DWORD    dwMapFlags,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWSTR  lpDestStr,
	int      cchDest)
{
	if (FWide())
		return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);

	// lpSrcStr is not required to be '\0' terminated. Note that we don't support -1!
	Assert(cchSrc != -1);
	LPSTR sz = SzAlloc(cchSrc * 2);
	int dw = WideCharToMultiByte(CP_ACP, 0, lpSrcStr, cchSrc, sz, cchSrc * 2, NULL, NULL);

	LPSTR dst = cchDest ? SzAlloc(cchDest*2) : NULL;
	int dwRet = LCMapStringA(Locale, dwMapFlags, sz, dw, dst, cchDest*2);
	if (dwRet && cchDest)
		{
		dwRet = MultiByteToWideChar(CP_ACP, 0, dst, dwRet, lpDestStr, cchDest);
		}
	return dwRet;
}

HACCEL
WINAPI
OLoadAcceleratorsW(
	HINSTANCE hInst,
	LPCWSTR   lpTableName)
{
	if(FWide())
		return LoadAcceleratorsW(hInst, lpTableName);

	if(FATOM(lpTableName))
		return LoadAcceleratorsA(hInst, (LPSTR)lpTableName);

	PreConvert();
	LPSTR sz = Convert(lpTableName);
	return LoadAcceleratorsA(hInst, sz);
}

HBITMAP
WINAPI
OLoadBitmapW(
	HINSTANCE hInstance,
	LPCWSTR lpBitmapName)
{
	if(FWide())
		return LoadBitmapW(hInstance, lpBitmapName);

	if(FATOM(lpBitmapName))
		return LoadBitmapA(hInstance, (LPSTR)lpBitmapName);

	PreConvert();
	LPSTR sz = Convert(lpBitmapName);
	return LoadBitmapA(hInstance, sz);
}

HCURSOR
WINAPI
OLoadCursorW(
	HINSTANCE hInstance,
	LPCWSTR lpCursorName)
{
	if(FWide())
		return LoadCursorW(
			hInstance,
			lpCursorName);

	if (FATOM(lpCursorName))
		return LoadCursorA(hInstance, (LPSTR) lpCursorName);

	PreConvert();
	LPSTR sz = Convert(lpCursorName);
	return LoadCursorA(hInstance, sz);
}

HICON
WINAPI
OLoadIconW(
	HINSTANCE hInstance,
	LPCWSTR lpIconName)
{
	if(FWide())
		return LoadIconW(hInstance, lpIconName);

	if(FATOM(lpIconName))
		return LoadIconA(hInstance, (LPSTR)lpIconName);

	PreConvert();
	LPSTR sz = Convert(lpIconName);
	return LoadIconA(hInstance, sz);
}

HINSTANCE
WINAPI
OLoadLibraryW(
	LPCWSTR pwszFileName
	)
{
	if(FWide())
		return LoadLibraryW(pwszFileName);

	PreConvert();
	LPSTR sz = Convert(pwszFileName);
	return LoadLibraryA(sz);
}

HMODULE
WINAPI
OLoadLibraryExW(
	LPCWSTR lpLibFileName,
	HANDLE hFile,
	DWORD dwFlags
	)
{
	if(FWide())
		return LoadLibraryExW(lpLibFileName, hFile, dwFlags);

	PreConvert();
	LPSTR sz = Convert(lpLibFileName);
	return LoadLibraryExA(sz, hFile, dwFlags);
}

HMENU
WINAPI
OLoadMenuIndirectW(
	CONST MENUTEMPLATEW *lpMenuTemplate)
{
	if(FWide())
		return LoadMenuIndirectW(lpMenuTemplate);

	//$NOTE: For both the ANSI and the Unicode version of this function,
	//the strings in the MENUITEMTEMPLATE structure must be Unicode strings

	return LoadMenuIndirectA(lpMenuTemplate);
}

HMENU
WINAPI
OLoadMenuW(
	HINSTANCE hInstance,
	LPCWSTR lpMenuName)
{
	if(FWide())
		return LoadMenuW(hInstance, lpMenuName);

	if(FATOM(lpMenuName))
		return LoadMenuA(hInstance, (LPCSTR)lpMenuName);

	PreConvert();
	LPSTR sz = Convert(lpMenuName);
	return LoadMenuA(hInstance, sz);
}

int
WINAPI
OLoadStringW(
	HINSTANCE hInstance,
	UINT uID,
	LPWSTR lpBuffer,
	int nBufferMax)
{
	if(FWide())
		return LoadStringW(hInstance, uID,  lpBuffer, nBufferMax);

	LPSTR sz = SzAlloc(sizeof(WCHAR) * nBufferMax);
	int nRet = LoadStringA(hInstance, uID, sz, sizeof(WCHAR) * nBufferMax);

	if (!nRet)
		{
		if (lpBuffer && 0 < nBufferMax)
			{
			*lpBuffer = L'\0';
			}
		return 0;
		}

	LONG lRet = AnsiToUnicode(lpBuffer, sz, nBufferMax, nRet + 1); // '\0'
	if (lRet)
		{
		return lRet - 1;
		}

	LPWSTR szBuff = SzWAlloc(nRet + 1);
	lRet = AnsiToUnicode(szBuff, sz, nRet + 1, nRet + 1);
	Assert(lRet);
	memcpy(lpBuffer, szBuff, sizeof(WCHAR) * nBufferMax);
	lpBuffer[nBufferMax - 1] = L'\0';
	return nBufferMax - 1;
}

LPWSTR
WINAPI
OlstrcatW(
	LPWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if (!lpString1 || !lpString2)
		return lpString1;

	return wcscat(lpString1, lpString2);
}

int
WINAPI
OlstrcmpiW(
	LPCWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if(FWide())
		return lstrcmpiW(lpString1, lpString2);

	PreConvert();
	LPSTR psz1 = lpString1 ? Convert(lpString1) : NULL;
	LPSTR psz2 = lpString2 ? Convert(lpString2) : NULL;

	return lstrcmpiA(psz1, psz2);
}

int
WINAPI
OlstrcmpW(
	LPCWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if(FWide())
		return lstrcmpW(lpString1, lpString2);

	PreConvert();
	LPSTR psz1 = lpString1 ? Convert(lpString1) : NULL;
	LPSTR psz2 = lpString2 ? Convert(lpString2) : NULL;

	return lstrcmpA(psz1, psz2);
}

LPWSTR
WINAPI
OlstrcpyW(
	LPWSTR lpString1,
	LPCWSTR lpString2
	)
{
	if (!lpString1)
		return lpString1;

	if (!lpString2)
		lpString2 = L"";

	return wcscpy(lpString1, lpString2);
}

// From: Mark Ashton on 5/8/97
//       Ted Smith added null string pointer handling
LPWSTR
WINAPI
OlstrcpynW(
	LPWSTR lpString1,
	LPCWSTR lpString2,
	int iMaxLength
	)
{
	if (!lpString1)
		{
		return lpString1;
		}

	if (!lpString2)
		{
		lpString2 = L"";
		}

	if(FWide())
		return lstrcpynW(lpString1, lpString2, iMaxLength);

	lpString1[--iMaxLength] = L'\0';
	return wcsncpy(lpString1, lpString2, iMaxLength);
}

int
WINAPI
OlstrlenW(
	LPCWSTR lpString
	)
{
	return lpString ? wcslen(lpString) : 0;
}

UINT
WINAPI
OMapVirtualKeyW(
	UINT uCode,
	UINT uMapType)
{
	// The only person using this so far is using uMapType == 0
	Assert(2 != uMapType);
	if (FWide())
		return MapVirtualKeyW(uCode, uMapType);
	return MapVirtualKeyA(uCode, uMapType);
}

int
WINAPI
OMessageBoxW(
	HWND hWnd ,
	LPCWSTR lpText,
	LPCWSTR lpCaption,
	UINT uType)
{
	if(FWide())
		return MessageBoxW(hWnd, lpText, lpCaption, uType);

	PreConvert();
	LPSTR szText = Convert(lpText);
	LPSTR szCap  = Convert(lpCaption);

	return MessageBoxA(hWnd, szText, szCap, uType);
}

int
WINAPI
OMessageBoxIndirectW(
	LPMSGBOXPARAMSW lpmbp)
{
	Assert(!IsBadWritePtr((void*)lpmbp, sizeof MSGBOXPARAMSW));
	Assert(sizeof MSGBOXPARAMSW == lpmbp->cbSize);
	Assert(sizeof MSGBOXPARAMSW == sizeof MSGBOXPARAMSA);

	if(FWide())
		return MessageBoxIndirectW(lpmbp);

	PreConvert();

	MSGBOXPARAMSA mbpa;
	memcpy(&mbpa, lpmbp, sizeof MSGBOXPARAMSA);

	if (!FATOM(lpmbp->lpszText))
		{
		mbpa.lpszText = Convert(lpmbp->lpszText);
		}
	if (!FATOM(lpmbp->lpszCaption))
		{
		mbpa.lpszCaption = Convert(lpmbp->lpszCaption);
		}
	if ((lpmbp->dwStyle & MB_USERICON) && !FATOM(lpmbp->lpszIcon))
		{
		mbpa.lpszIcon = Convert(lpmbp->lpszIcon);
		}

	return MessageBoxIndirectA(&mbpa);
}

BOOL
WINAPI
OModifyMenuW(
	HMENU hMnu,
	UINT uPosition,
	UINT uFlags,
	UINT uIDNewItem,
	LPCWSTR lpNewItem
	)
{
	if(FWide())
		return ModifyMenuW(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);

	if (MF_STRING == uFlags)
		{
		PreConvert();
		LPSTR sz = Convert(lpNewItem);
		return ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, sz);
		}
	else
		return ModifyMenuA(hMnu, uPosition, uFlags, uIDNewItem, (LPSTR) lpNewItem);

}


// From: Mark Ashton on 5/29/97
BOOL
WINAPI
OMoveFileExW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName,
	DWORD dwFlags
	)
{
	if (FWide())
		return MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags);

	PreConvert();
	LPSTR szOld = Convert(lpExistingFileName);
	LPSTR szNew = Convert(lpNewFileName);

	return MoveFileExA(szOld, szNew, dwFlags);
}

BOOL
WINAPI
OMoveFileW(
	LPCWSTR lpExistingFileName,
	LPCWSTR lpNewFileName)
{
	if(FWide())
		return MoveFileW(lpExistingFileName, lpNewFileName);

	PreConvert();
	LPSTR szOld = Convert(lpExistingFileName);
	LPSTR szNew = Convert(lpNewFileName);

	return MoveFileA(szOld, szNew);
}

HANDLE
WINAPI
OLoadImageW(
	HINSTANCE hinst,
	LPCWSTR lpszName,
	UINT uType,
	int cxDesired,
	int cyDesired,
	UINT fuLoad)
{
	if (FWide())
		{
		Assert(!(LR_LOADFROMFILE & fuLoad));
		return LoadImageW(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);
		}

	if (!FATOM(lpszName))
		{
		PreConvert();
		LPSTR pszName = Convert(lpszName);
		return LoadImageA(hinst, pszName, uType, cxDesired, cyDesired, fuLoad);
		}
	 else
		return LoadImageA(hinst, (LPSTR) lpszName, uType, cxDesired, cyDesired, fuLoad);
}

BOOL
WINAPI
OOemToCharW(
	LPCSTR lpszSrc,
	LPWSTR lpszDst)
{
	if(FWide())
		{
		Assert(lpszSrc != (LPCSTR) lpszDst);
#pragma prefast(suppress:56, "do not know the size of the destination buffer")
		return OemToCharW(lpszSrc, lpszDst);
		}

	DWORD cb = _mbslen((const unsigned char *)lpszSrc);
	LPSTR szDst = SzAlloc(cb);
#pragma prefast(suppress:56, "noise")
	BOOL fRet = OemToCharA(lpszSrc, szDst);
	if(fRet)
		{
		Verify(0 <= AnsiToUnicode(lpszDst, szDst, cb));
		}
	return fRet;
}

VOID
WINAPI
OOutputDebugStringW(
	LPCWSTR lpOutputString
	)
{
	if(FWide())
		{
		OutputDebugStringW(lpOutputString);
		return;
		}

	PreConvert();
	LPSTR sz = Convert(lpOutputString);

	if (NULL == sz)
	    return;

	OutputDebugStringA(sz);
}

BOOL
WINAPI
OPeekMessageW(
	LPMSG lpMsg,
	HWND hWnd ,
	UINT wMsgFilterMin,
	UINT wMsgFilterMax,
	UINT wRemoveMsg)
{
	if(FWide())
		return PeekMessageW(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax, wRemoveMsg);

	return PeekMessageA(lpMsg, hWnd , wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

BOOL
WINAPI
OPostMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return PostMessageW(hWnd, Msg, wParam, lParam);

	return PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OPostThreadMessageW(
	DWORD idThread,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
 {
	if (FWide())
		return PostThreadMessageW(idThread, Msg, wParam, lParam);

	return PostThreadMessageA(idThread, Msg, wParam, lParam);
 }


// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegCreateKeyExW(
	HKEY hKey,
	LPCWSTR lpSubKey,
	DWORD Reserved,
	LPWSTR lpClass,
	DWORD dwOptions,
	REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult,
	LPDWORD lpdwDisposition
	)
{
	Assert(lpSubKey);
	if(FWide())
		return RegCreateKeyExW(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired,
			lpSecurityAttributes, phkResult, lpdwDisposition);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);
	LPSTR sz2 = Convert(lpClass);
	return RegCreateKeyExA(hKey, sz, Reserved, sz2, dwOptions, samDesired,
			lpSecurityAttributes, phkResult, lpdwDisposition);
}

// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegCreateKeyW (
	HKEY hKey,
	LPCWSTR lpSubKey,
	PHKEY phkResult
	)
{
	if (FWide())
		return RegCreateKeyW(hKey, lpSubKey, phkResult);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);
	return RegCreateKeyA(hKey, sz, phkResult);
}

// From: Mark Ashton on 5/8/97
LONG
APIENTRY
ORegEnumKeyW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpName,
	DWORD cbName
	)
{
	if (FWide())
		return RegEnumKeyW(hKey, dwIndex, lpName, cbName);

	LPSTR sz = SzAlloc(cbName);
	LONG dwRet = RegEnumKeyA(hKey, dwIndex, sz, cbName);
	Verify(0 <= AnsiToUnicode(lpName, sz, cbName));
	return dwRet;
}

//  Van Kichline
//  IHammer group
//  Not supported: REG_MULTI_SZ
//
LONG
APIENTRY
ORegEnumValueW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpValueName,
	LPDWORD lpcbValueName,  // Documentation indicates this is a count of characters, despite the Hungarian.
	LPDWORD lpReserved,
	LPDWORD lpType,         // May be NULL, but we need to know it on return if lpData is not NULL.
	LPBYTE lpData,          // May be NULL
	LPDWORD lpcbData        // May be NULL is lpData is NULL
	)
{
	if (FWide())
		return RegEnumValueW(hKey, dwIndex, lpValueName, lpcbValueName, lpReserved, lpType, lpData, lpcbData);

	// Required pointers:
	if (!lpValueName || !lpcbValueName || !lpcbData && lpData)
		{
		Assert(lpValueName);
		Assert(lpcbValueName);
		Assert(!lpcbData && lpData);
		return E_POINTER;
		}

	// If NULL was specified for lpType, we need to supply our own so we can check for string results.
	DWORD dwPrivateType = 0;
	if (!lpType)
		{
		lpType = &dwPrivateType;
		}

	DWORD cbValueName  = *lpcbValueName;
	DWORD dwOrigCbData = lpcbData ? *lpcbData : 0;
	LPSTR pchValueName = SzAlloc(*lpcbValueName);

	LONG lResult = RegEnumValueA(hKey, dwIndex, pchValueName, &cbValueName, lpReserved, lpType, lpData, lpcbData);

	if (ERROR_SUCCESS == lResult)
		{
		*lpcbValueName = AnsiToUnicode(lpValueName, pchValueName, min(*lpcbValueName, cbValueName + 1)) - 1; // Returned value does NOT include terminating NULL

		if (lpData)
			{
			// If the resulting data was a string, convert it in place.
			switch (*lpType)
				{
				case REG_MULTI_SZ:
					// Not supported
					Assert(0 && REG_MULTI_SZ);
					lResult = E_FAIL;
					break;
				case REG_EXPAND_SZ:
				case REG_SZ:
					{
					Assert(lpcbData);
					LPSTR pszTemp = SzAlloc(*lpcbData); // is the number of bytes!
					memcpy(pszTemp, lpData, *lpcbData);
					*lpcbData = AnsiToUnicode((LPWSTR)lpData, pszTemp, dwOrigCbData/sizeof(WCHAR), *lpcbData) * sizeof(WCHAR);

					//	It's possible to encounter a second stage overflow, if lpData >= sizeof(Unicode)/2
					if ( 0 == *lpcbData )
						{
						lResult = ERROR_MORE_DATA;
						}
					}
					break;
				}
			}
		}

	return lResult;
}

LONG
APIENTRY ORegOpenKeyW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
	if(FWide())
		return RegOpenKeyW(hKey, pwszSubKey, phkResult);

	PreConvert();
	LPSTR sz = Convert(pwszSubKey);

	return RegOpenKeyA(hKey, sz, phkResult);
}

LONG
APIENTRY
ORegDeleteKeyW(
	HKEY hKey,
	LPCWSTR pwszSubKey
	)
{
	Assert(pwszSubKey);
	if(FWide())
		return RegDeleteKeyW(hKey, pwszSubKey);

	PreConvert();
	LPSTR sz = Convert(pwszSubKey);
	return RegDeleteKeyA(hKey, sz);
}

LONG
APIENTRY
ORegDeleteValueW(
	HKEY hKey,
	LPWSTR lpValueName
	)
{
	if(FWide())
		return RegDeleteValueW (hKey, lpValueName);

	PreConvert();
	LPSTR sz = Convert(lpValueName);
	return RegDeleteValueA(hKey, sz);
}

ATOM
WINAPI
ORegisterClassW(
	CONST WNDCLASSW *lpWndClass)
{
	if(FWide())
		return RegisterClassW(lpWndClass);

	WNDCLASSA wc;
	memcpy(&wc, lpWndClass, sizeof(wc));

	PreConvert();

	if (!(IsBadReadPtr(wc.lpszMenuName, sizeof(* wc.lpszMenuName)) ||
		  IsBadReadPtr(lpWndClass->lpszMenuName, sizeof (*(lpWndClass->lpszMenuName)))))
		{
		wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
		}

	wc.lpszClassName = Convert(lpWndClass->lpszClassName);

	return RegisterClassA(&wc);
}

ATOM
WINAPI
ORegisterClassExW(CONST WNDCLASSEXW * lpWndClass)
{
	if (FWide())
		return RegisterClassExW(lpWndClass);

	WNDCLASSEXA wc;
	memcpy(&wc, lpWndClass, sizeof(wc));

	PreConvert();

	if (!FATOM(wc.lpszMenuName))
		{
		wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
		}

	if (!FATOM(wc.lpszClassName))
		wc.lpszClassName = Convert(lpWndClass->lpszClassName);

	return RegisterClassExA(&wc);
}

BOOL
WINAPI
OUnregisterClassW
(
LPCTSTR  lpClassName,   // address of class name string
HINSTANCE  hInstance    // handle of application instance
)
{
	if(FWide())
		return UnregisterClassW(lpClassName, hInstance);

	if (FATOM(lpClassName))
		return UnregisterClassW(lpClassName, hInstance);

	PreConvert();
	LPSTR sz = Convert(lpClassName);

	return UnregisterClassA(sz, hInstance);
}

UINT
WINAPI
ORegisterClipboardFormatW(
	LPCWSTR lpszFormat)
{
	if(FWide())
		return RegisterClipboardFormatW(lpszFormat);

	PreConvert();
	LPSTR sz = Convert(lpszFormat);
	if (sz == NULL)
		return(0);

	return RegisterClipboardFormatA(sz);
}

UINT
WINAPI
ORegisterWindowMessageW(LPCWSTR lpString)
{
	if(FWide())
		return RegisterWindowMessageW(lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	if (sz == NULL)
		return(0);

	return  RegisterWindowMessageA(sz);
}

LONG
APIENTRY
ORegOpenKeyExW (
	HKEY hKey,
	LPCTSTR lpSubKey,
	DWORD ulOptions,
	REGSAM samDesired,
	PHKEY phkResult
	)
{
	if(FWide())
		return RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);

	PreConvert();
	LPSTR sz = Convert(lpSubKey);

	return RegOpenKeyExA(hKey, sz, ulOptions, samDesired, phkResult);
}

LONG
APIENTRY
ORegQueryInfoKeyW (
	HKEY hKey,
	LPWSTR lpClass,
	LPDWORD lpcbClass,
	LPDWORD lpReserved,
	LPDWORD lpcSubKeys,
	LPDWORD lpcbMaxSubKeyLen,
	LPDWORD lpcbMaxClassLen,
	LPDWORD lpcValues,
	LPDWORD lpcbMaxValueNameLen,
	LPDWORD lpcbMaxValueLen,
	LPDWORD lpcbSecurityDescriptor,
	PFILETIME lpftLastWriteTime
	)
{
	Assert(!lpClass && !lpcbClass); //$ UNDONE_POST_98 - Not wrapped yet!
	if(FWide())
		return RegQueryInfoKeyW(hKey, lpClass, lpcbClass, lpReserved,
								lpcSubKeys, lpcbMaxSubKeyLen,
								lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
								lpcbMaxValueLen, lpcbSecurityDescriptor,
								lpftLastWriteTime );

	if (lpClass && (!lpcbClass || IsBadWritePtr(lpcbClass, sizeof(lpcbClass))))
		{
		// lpcbClass must be valid if lpClass is non-NULL
		return ERROR_INVALID_PARAMETER;
		}

	return RegQueryInfoKeyA(hKey, NULL, NULL, lpReserved,
							lpcSubKeys, lpcbMaxSubKeyLen,
							lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen,
							lpcbMaxValueLen, lpcbSecurityDescriptor,
							lpftLastWriteTime );
}

LONG
APIENTRY ORegQueryValueW(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue,
	PLONG   lpcbValue)
{
	if(FWide())
		return RegQueryValueW(hKey, pwszSubKey, pwszValue, lpcbValue);

	LONG  cb;
	LONG  lRet    = 0;
	LPSTR szValue = NULL;
	PreConvert();
	LPSTR sz = Convert(pwszSubKey);

	lRet = RegQueryValueA(hKey, sz, NULL, &cb);

	if(ERROR_SUCCESS != lRet)
		{
		return lRet;
		}
	// If the caller was just asking for the size of the value, jump out
	//  now, without actually retrieving and converting the value.

	if (!pwszValue)
		{
		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		goto Exit;
		}


	// If the caller was asking for the value, but allocated too small
	// of a buffer, set the buffer size and jump out.

	if (*lpcbValue < (LONG) (cb * sizeof(WCHAR)))
		{
		//$UNDONE_POST_98: We should actually use the nubmer of bytes required, not some
		// wild guess as we are here

		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		lRet = ERROR_MORE_DATA;
		goto Exit;
		}

	// Otherwise, retrieve and convert the value.

	szValue = SzAlloc(cb);

	lRet = RegQueryValueA(hKey, sz, szValue, &cb);

	if (ERROR_SUCCESS == lRet)
		{
		Verify(0 <= AnsiToUnicode(pwszValue, szValue, cb));

		//$UNDONE_POST_98: We should actually use the nubmer of bytes required, not some
		// wild guess as we are here

		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbValue = cb * sizeof(WCHAR);
		}
	else if (pwszValue && 0 < cb)
		{
		*pwszValue = L'\0';
		}

Exit:

	return lRet;
}

LONG
APIENTRY
ORegSetValueExW(
	HKEY hKey,
	LPCWSTR lpValueName,
	DWORD Reserved,
	DWORD dwType,
	CONST BYTE* lpData,
	DWORD cbData
	)
{
	if(FWide())
		return RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);

	PreConvert();
	LPSTR sz = Convert(lpValueName);

	LONG lRet;

	// NOTE: when calling RegSetValueExA, if the data type is
	// REG_SZ, REG_EXPAND_SZ, or REG_MULTI_SZ, then the API expects the strings
	// to be ansi also.
	if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
		{
		LONG lData = 0;
		LPSTR szData = ConvertWithLen((LPTSTR)lpData, -1, &lData);
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, (CONST BYTE *)szData, lData);
		}
	else if (REG_MULTI_SZ == dwType)
		{
		LONG lData = 0;
		LPSTR szData = ConvertWithLen((LPWSTR)lpData,
									  cUnicodeMultiSzLen((LPWSTR)lpData),
									  &lData );
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, (CONST BYTE *)szData, lData);
		}
	else
		{
		lRet = RegSetValueExA(hKey, sz, Reserved, dwType, lpData, cbData);
		}

	return lRet;
}

LONG
APIENTRY ORegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType,
	LPCWSTR lpData, DWORD cbData)
{
	Assert(REG_SZ == dwType);

	if(FWide())
		return RegSetValueW(hKey, lpSubKey, dwType,
			lpData, cbData);

	PreConvert();
	LPSTR szKey   = Convert(lpSubKey);
	LPSTR szValue = Convert(lpData);

	return RegSetValueA(hKey, szKey, dwType, szValue, cbData);
}

LONG
APIENTRY
ORegQueryValueExW (
	HKEY hKey,
	LPCWSTR lpValueName,
	LPDWORD lpReserved,
	LPDWORD lpType,
	LPBYTE lpData,
	LPDWORD lpcbData
	)
{
	Assert(lpcbData || !lpData); // lpcbData can be NULL only if lpData is NULL
	if(FWide())
		return RegQueryValueExW (
			hKey,
			lpValueName,
			lpReserved,
			lpType,
			lpData,
			lpcbData
			);

	LPBYTE lpTempBuffer;
	DWORD dwTempType;
	DWORD cb, cbRequired;
	LONG  lRet;
	PreConvert();
	LPSTR sz = Convert(lpValueName);

	lRet = RegQueryValueExA(hKey, sz, lpReserved, &dwTempType, NULL, &cb);

	if(ERROR_SUCCESS != lRet)
		{
		return lRet;
		}

	// If the caller was just asking for the size of the value, jump out
	//  now, without actually retrieving and converting the value.

	if (!lpData)
		{
		switch (dwTempType)
			{
			case REG_EXPAND_SZ:
			case REG_MULTI_SZ:
			case REG_SZ:
				// Adjust size of buffer to report, to account for CHAR -> WCHAR

				*lpcbData = cb * sizeof(WCHAR);
				break;

			default:
				*lpcbData = cb;
				break;
			}

		// Set the type, if required.
		if (lpType)
			{
			*lpType = dwTempType;
			}

		goto Exit;
		}


	//
	// Determine the size of buffer needed
	//

	switch (dwTempType)
		{
		case REG_EXPAND_SZ:
		case REG_MULTI_SZ:
		case REG_SZ:
			cbRequired = cb * sizeof(WCHAR);
			break;

		default:
			cbRequired = cb;
			break;
		}

	// If the caller was asking for the value, but allocated too small
	// of a buffer, set the buffer size and jump out.

	if (*lpcbData < cbRequired)
		{
		// Adjust size of buffer to report, to account for CHAR -> WCHAR
		*lpcbData = cbRequired;

		// Set the type, if required.
		if (lpType)
			{
			*lpType = dwTempType;
			}

		lRet = ERROR_MORE_DATA;
		goto Exit;
		}

	// Otherwise, retrieve and convert the value.

	switch (dwTempType)
		{
		case REG_EXPAND_SZ:
		case REG_MULTI_SZ:
		case REG_SZ:

			lpTempBuffer = (LPBYTE)SzAlloc(cbRequired);

			lRet = RegQueryValueExA(hKey,
									sz,
									lpReserved,
									&dwTempType,
									lpTempBuffer,
									&cb);

			if (ERROR_SUCCESS == lRet)
				{
				switch (dwTempType)
					{
					case REG_EXPAND_SZ:
					case REG_MULTI_SZ:
					case REG_SZ:

						*lpcbData = AnsiToUnicode((LPWSTR)lpData, (LPSTR)lpTempBuffer, *lpcbData, cb);
						*lpcbData = cb * sizeof(WCHAR); // Result it in BYTES!

						// Set the type, if required.
						if (lpType)
							{
							*lpType = dwTempType;
							}
						break;
					}
				}

			goto Exit;

		default:

			//
			// No conversion of out parameters needed.  Just call narrow
			// version with args passed in, and return directly.
			//

			lRet = RegQueryValueExA(hKey,
									sz,
									lpReserved,
									lpType,
									lpData,
									lpcbData);

		}

Exit:

	return lRet;
}

HANDLE
WINAPI
ORemovePropW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return RemovePropW(hWnd, lpString);

	if(FATOM(lpString))
		return RemovePropA(hWnd, (LPSTR)lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return RemovePropA(hWnd, sz);
}

LRESULT
WINAPI
OSendDlgItemMessageW(
	HWND hDlg,
	int nIDDlgItem,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);

	PreConvert();
	switch (Msg)
		{
		case LB_ADDSTRING:
		case LB_INSERTSTRING:
		case LB_SELECTSTRING:
		case LB_FINDSTRING:
		case LB_FINDSTRINGEXACT:
		case CB_ADDSTRING:
		case CB_INSERTSTRING:
		case CB_SELECTSTRING:
		case CB_FINDSTRING:
		case CB_FINDSTRINGEXACT:
			{
			lParam = (LPARAM)Convert((LPWSTR)lParam);
			break;
			}
		}

	return SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam);
}

LRESULT
WINAPI
OSendMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	// incase TCHAR strings are being passed in lParam the caller
	// will have to do the proper conversions PlatformToInternal or
	// InternalToPlatform

	if(FWide())
		return SendMessageW(hWnd, Msg, wParam, lParam);

	return SendMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OSendNotifyMessageW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	if(FWide())
		return SendNotifyMessageW(hWnd, Msg, wParam, lParam);

	return SendNotifyMessageA(hWnd, Msg, wParam, lParam);
}

BOOL
WINAPI
OSetDlgItemTextW(
	HWND hDlg,
	int nIDDlgItem,
	LPCWSTR lpString)
{
	if(FWide())
		return SetDlgItemTextW(hDlg, nIDDlgItem, lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetDlgItemTextA(hDlg, nIDDlgItem, sz);
}

BOOL
WINAPI
OSetFileAttributesW(
	LPCWSTR lpFileName,
	DWORD dwFileAttributes
	)
{
	if (FWide())
		return SetFileAttributesW(lpFileName, dwFileAttributes);

	PreConvert();
	LPSTR sz = Convert(lpFileName);
	if (sz == NULL)
		return(0);

	return SetFileAttributesA(sz, dwFileAttributes);
}

BOOL
WINAPI
OSetPropW(
	HWND hWnd,
	LPCWSTR lpString,
	HANDLE hData)
{
	if(FWide())
		return SetPropW(hWnd, lpString, hData);

	if(FATOM(lpString))
		return SetPropA(hWnd, (LPSTR)lpString, hData);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetPropA(hWnd, sz, hData);
}

BOOL
WINAPI
OSetMenuItemInfoW(
	HMENU hMenu,
	UINT uItem,
	BOOL fByPosition,
	LPCMENUITEMINFOW lpcmii
	)
{
	Assert(!IsBadWritePtr((void*)lpcmii, sizeof MENUITEMINFOW));
	Assert(sizeof MENUITEMINFOW == lpcmii->cbSize);
	Assert(sizeof MENUITEMINFOW == sizeof MENUITEMINFOA);

	if (FWide())
		return SetMenuItemInfoW(hMenu, uItem, fByPosition, lpcmii);

	MENUITEMINFOA mii;
	memcpy(&mii, lpcmii, sizeof MENUITEMINFOA);

	if (!(lpcmii->fMask & MIIM_TYPE) ||
		MFT_STRING != (lpcmii->fType &
				  (MFT_BITMAP | MFT_SEPARATOR | MFT_OWNERDRAW | MFT_STRING) ) )
		{
		return SetMenuItemInfoA(hMenu, uItem, fByPosition, &mii);
		}

	PreConvert();
	mii.dwTypeData = Convert(lpcmii->dwTypeData);
	return SetMenuItemInfoA(hMenu, uItem, fByPosition, &mii);
}

LONG
WINAPI
OSetWindowLongW(
	HWND hWnd,
	int nIndex,
	LONG dwNewLong)
{
	if(FWide())
		return SetWindowLongW(hWnd, nIndex, dwNewLong);

	return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

HHOOK
WINAPI
OSetWindowsHookExW(
	int idHook,
	HOOKPROC lpfn,
	HINSTANCE hmod,
	DWORD dwThreadId)
{
	if(FWide())
		return SetWindowsHookExW(idHook, lpfn, hmod, dwThreadId);

	return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);  //$ CONSIDER - Not really wrapped
}

BOOL
WINAPI
OSetWindowTextW(
	HWND hWnd,
	LPCWSTR lpString)
{
	if(FWide())
		return SetWindowTextW(hWnd, lpString);

	PreConvert();
	LPSTR sz = Convert(lpString);
	return SetWindowTextA(hWnd, sz);
}

LONG
WINAPI
OTabbedTextOutW(
	HDC hDC,
	int X,
	int Y,
	LPCWSTR lpString,
	int nCount,
	int nTabPositions,
	LPINT lpnTabStopPositions,
	int nTabOrigin)
{
	Assert(-1 != nCount);

	if(FWide())
		return TabbedTextOutW(hDC, X, Y, lpString, nCount, nTabPositions,
			lpnTabStopPositions, nTabOrigin);

	PreConvert();
	LONG  n = 0;
	LPSTR sz = ConvertWithLen(lpString, nCount, &n);
	if (sz == NULL)
		return(0);

	return TabbedTextOutA(hDC, X, Y, sz, n, nTabPositions,
						  lpnTabStopPositions, nTabOrigin );
}

int
WINAPI
OTranslateAcceleratorW(
	HWND hWnd,
	HACCEL hAccTable,
	LPMSG lpMsg)
{
	if(FWide())
		return TranslateAcceleratorW(hWnd, hAccTable, lpMsg);

	return TranslateAcceleratorA(hWnd, hAccTable, lpMsg);
}

SHORT
WINAPI
OVkKeyScanW(
	WCHAR ch)
{
	if (FWide())
		return VkKeyScanW(ch);
	TCHAR szW[2];
	char szA[2];
	szW[0] = ch;
	szW[1] = L'\0';
	Verify(0 <= UnicodeToAnsi(szA, szW, 2));
	return VkKeyScanA(szA[0]);
}

BOOL
WINAPI
OWinHelpW(
	HWND hWndMain,
	LPCWSTR lpszHelp,
	UINT uCommand,
	DWORD dwData
	)
{
	if(FWide())
		return WinHelpW(hWndMain, lpszHelp, uCommand,dwData);

	PreConvert();
	LPSTR sz = Convert(lpszHelp);
	return WinHelpA(hWndMain, sz, uCommand, dwData);
}

BOOL
WINAPI
OWritePrivateProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpString,
	LPCWSTR lpFileName)
{
	if(FWide())
		return WritePrivateProfileStringW(lpAppName, lpKeyName, lpString, lpFileName);

	PreConvert();
	LPSTR szAppName  = Convert(lpAppName);
	LPSTR szKeyName  = Convert(lpKeyName);
	LPSTR szString   = Convert(lpString);
	LPSTR szFileName = Convert(lpFileName);

	return WritePrivateProfileStringA(szAppName, szKeyName, szString, szFileName);
}

int
WINAPIV
OwsprintfW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
	va_list vaArgs;
	va_start(vaArgs, pwszFormat);
	int retval;

	if(FWide())
		retval = wvsprintfW(pwszOut, pwszFormat, vaArgs);
	else
		retval = _vstprintf(pwszOut, pwszFormat, vaArgs); //$CONSIDER Why isn't this vswprint?

	va_end(vaArgs);
	return retval;
}

BOOL
WINAPI
OGetVersionExW(
	LPOSVERSIONINFOW lpVersionInformation
	)
{
	if(FWide())
		return GetVersionExW(lpVersionInformation);

	if (lpVersionInformation->dwOSVersionInfoSize < sizeof(OSVERSIONINFOW))
		return false;

	OSVERSIONINFOA  osviVersionInfo;
	osviVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	int fRetval = GetVersionExA(&osviVersionInfo);

	if (fRetval)
		{
		memcpy(lpVersionInformation, &osviVersionInfo, sizeof(OSVERSIONINFOA));

		Verify(0 <= AnsiToUnicode(lpVersionInformation->szCSDVersion,
								 osviVersionInfo.szCSDVersion,
								 sizeof(lpVersionInformation->szCSDVersion)
								 /sizeof(lpVersionInformation->szCSDVersion[0])));
		}

	return fRetval;
}

LONG
APIENTRY
ORegEnumKeyExW (
	HKEY hKey,
	DWORD dwIndex,
	LPWSTR lpName,
	LPDWORD lpcbName,
	LPDWORD lpReserved,
	LPWSTR lpClass,
	LPDWORD lpcbClass,
	PFILETIME lpftLastWriteTime
	)
{
	if(FWide())
		return RegEnumKeyExW (
			hKey,
			dwIndex,
			lpName,
			lpcbName,
			lpReserved,
			lpClass,
			lpcbClass,
			lpftLastWriteTime
			);

	LPSTR szName, szClass;
	DWORD cbName, cbClass;

	if (lpcbName)
		{
		cbName = sizeof(WCHAR) * *lpcbName;
		szName = lpName ? SzAlloc(cbName) : NULL;
		}
	else
		{
		szName = NULL;
		cbName = 0;
		}

	if (lpcbClass)
		{
		cbClass = sizeof(WCHAR) * (*lpcbClass);
		szClass = lpClass ? SzAlloc(cbClass) : NULL;
		}
	else
		{
		szClass = NULL;
		cbClass = 0;
		}

	if (szName == NULL)
		return(ERROR_BUFFER_OVERFLOW);

	LONG lRet = RegEnumKeyExA(hKey, dwIndex, szName, &cbName, lpReserved,
							  szClass, &cbClass, lpftLastWriteTime );

	if (ERROR_SUCCESS != lRet)
		{
		return lRet;
		}

	// Get the number of characters instead of number of bytes.
	if (lpcbName)
		{
		DWORD dwNoOfChar = AnsiToUnicode((LPWSTR) lpName, (LPSTR) szName, *lpcbName);
		if (cbName && !dwNoOfChar)
			{
			return ERROR_BUFFER_OVERFLOW;
			}

		*lpcbName = dwNoOfChar;
		}

	if (lpcbClass && lpClass)
		{
		DWORD dwNoOfChar = AnsiToUnicode((LPWSTR) lpClass, (LPSTR) szClass, *lpcbClass);

		if (cbClass && !dwNoOfChar)
			{
			return ERROR_BUFFER_OVERFLOW;
			}

		*lpcbClass = dwNoOfChar;
		}

	return lRet;

}

HANDLE
WINAPI
OCreateFileMappingW(
	HANDLE hFile,
	LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
	DWORD flProtect,
	DWORD dwMaximumSizeHigh,
	DWORD dwMaximumSizeLow,
	LPCWSTR lpName
	)
{
	if(FWide())
		return CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);

	PreConvert();
	LPSTR sz = Convert(lpName);
	return CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, sz);
}

LRESULT
WINAPI
ODefDlgProcW(
	HWND hDlg,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam)
{
	// incase TCHAR strings are being passed in lParam the caller
	// will have to do the proper conversions PlatformToInternal or
	// InternalToPlatform

	if(FWide())
		return DefDlgProcW(hDlg, Msg, wParam, lParam);

	return DefDlgProcA(hDlg, Msg, wParam, lParam);
}

int
WINAPI
OGetLocaleInfoW(
	LCID     Locale,
	LCTYPE   LCType,
	LPWSTR  lpLCData,
	int      cchData)
{
	DWORD dwRet;

	if (FWide())
		return GetLocaleInfoW(Locale, LCType, lpLCData, cchData);

	if (!cchData || !lpLCData)
		return GetLocaleInfoA(Locale, LCType, NULL, cchData);

	int cchDataAnsi = sizeof(WCHAR) * cchData;
	LPSTR szBuffer = SzAlloc(cchDataAnsi);

	dwRet = GetLocaleInfoA(Locale, LCType, szBuffer, cchDataAnsi);
	// $UNDONE_POST_98: This is bogus, we should do this like OLoadStringW
	if(dwRet)
		{
		return AnsiToUnicode(lpLCData, szBuffer, cchData, dwRet);
		}
	else if (lpLCData && 0 < cchData)
		{
		*lpLCData = L'\0';
		}

	return dwRet;
}

BOOL
WINAPI
OSetLocaleInfoW(
	LCID     Locale,
	LCTYPE   LCType,
	LPCWSTR lpLCData)
{
	if (FWide())
		return SetLocaleInfoW(Locale, LCType, lpLCData);
	PreConvert();
	LPSTR sz = Convert(lpLCData);
	if (sz == NULL)
		return(0);

	return SetLocaleInfoA(Locale, LCType, sz);
}

// $UNDONE_POST_98$ Workaround because StgCreateDocfile is not reentrant.
//          We were getting ACCESS DENIED errors when multiple threads opened
//             temp files simultaneously.

//-----------------------------------------------------------------------------
// Name: StgCreateDocfileCriticalSection
//
// Description:
// Used solely by OStgCreateDocfile in order to protect its call to
// StgCreateDocfile from simultaneously entry by multiple threads.
//
//-----------------------------------------------------------------------------
class StgCreateDocfileCriticalSection
{
public:
	StgCreateDocfileCriticalSection() {InitializeCriticalSection(&m_critsec);}
	~StgCreateDocfileCriticalSection() {DeleteCriticalSection(&m_critsec);}
	VOID VEnter() {EnterCriticalSection(&m_critsec);}
	VOID VLeave() {LeaveCriticalSection(&m_critsec);}
private:
	CRITICAL_SECTION m_critsec;
};

#pragma warning(disable: 4717) // IA64 build fix
//-----------------------------------------------------------------------------
// Name: OStgCreateDocfile
//
// Description:
// Wrapper for StgCreateDocfile to protect against reentrancy bug in OLE.
//
// Thread-Safety: Bullet-proof
//
// Return Values: same HRESULT as StgCreateDocfile
//-----------------------------------------------------------------------------
HRESULT
WINAPI
OStgCreateDocfile
(
const WCHAR * pwcsName,
DWORD grfMode,
DWORD reserved,
IStorage ** ppstgOpen
)
{
	static StgCreateDocfileCriticalSection Crit;
	Crit.VEnter();
	HRESULT hrReturn = StgCreateDocfile(pwcsName, grfMode, reserved, ppstgOpen);
	Crit.VLeave();
	return hrReturn;
}
#pragma warning(default: 4717) // IA64 build fix

int
WINAPI
OStartDocW
(
HDC hDC,
CONST DOCINFOW * pdiDocW
)
{
	if (FWide())
		return StartDocW(hDC, pdiDocW);

	DOCINFOA diDocA;

	PreConvert();

	diDocA.lpszDocName  = Convert(pdiDocW->lpszDocName);
	diDocA.lpszOutput   = Convert(pdiDocW->lpszOutput);
	diDocA.lpszDatatype = Convert(pdiDocW->lpszDatatype);
	diDocA.cbSize       = sizeof(DOCINFOA);
	diDocA.fwType       = pdiDocW->fwType;

	return StartDocA(hDC, &diDocA);

}

BOOL
WINAPI
OSystemParametersInfoW(
	UINT uiAction,
	UINT uiParam,
	PVOID pvParam,
	UINT fWinIni)
{
	if (FWide())
		return SystemParametersInfoW(uiAction, uiParam, pvParam, fWinIni);

	switch (uiAction)
		{   // unsupported actions
		case SPI_GETHIGHCONTRAST:
		case SPI_GETICONMETRICS:
		case SPI_GETICONTITLELOGFONT:
		case SPI_GETNONCLIENTMETRICS:
		case SPI_GETSERIALKEYS:
		case SPI_GETSOUNDSENTRY:

		case SPI_SETDESKWALLPAPER:
		case SPI_SETHIGHCONTRAST:
		case SPI_SETICONMETRICS:
		case SPI_SETICONTITLELOGFONT:
		case SPI_SETNONCLIENTMETRICS:
		case SPI_SETSERIALKEYS:
		case SPI_SETSOUNDSENTRY:
			AssertFail("No Unicode Wrapper Available for Win32 API - SystemParametersInfoW");
			return 0;
		};
	return SystemParametersInfoA(uiAction, uiParam, pvParam, fWinIni);
}

LPWSTR
WINAPI
OCharNextW(
LPCWSTR lpsz)
{
	if ( FWide() )
		return CharNextW( lpsz );

	if (*lpsz == L'\0')
		{
		return const_cast<LPWSTR>(lpsz);
		}

	return const_cast<LPWSTR>(lpsz + 1);
}


#ifdef DEBUG
BOOL
APIENTRY
OAbortSystemShutdownW(
	LPWSTR lpMachineName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AbortSystemShutdownW");
	return 0;
}

BOOL
WINAPI
OAccessCheckAndAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	LPWSTR ObjectTypeName,
	LPWSTR ObjectName,
	PSECURITY_DESCRIPTOR SecurityDescriptor,
	DWORD DesiredAccess,
	PGENERIC_MAPPING GenericMapping,
	BOOL ObjectCreation,
	LPDWORD GrantedAccess,
	LPBOOL AccessStatus,
	LPBOOL pfGenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AccessCheckAndAuditAlarmW");
	return 0;
}

int
WINAPI OAddFontResourceW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddFontResourceW");
	return 0;
}

BOOL
WINAPI
OAddFormW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pForm
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddFormW");
	return 0;
}

BOOL
WINAPI
OAddJobW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pData,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddJobW");
	return 0;
}

BOOL
WINAPI
OAddMonitorW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pMonitors
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddMonitorW");
	return 0;
}

BOOL
WINAPI
OAddPortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pMonitorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPortW");
	return 0;
}

HANDLE
WINAPI
OAddPrinterW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pPrinter
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterW");
	return 0;
}

BOOL
WINAPI
OAddPrinterConnectionW(
	LPWSTR   pName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterConnectionW");
	return 0;
}

BOOL
WINAPI
OAddPrinterDriverW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pDriverInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrinterDriverW");
	return 0;
}

BOOL
WINAPI
OAddPrintProcessorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPathName,
	LPWSTR   pPrintProcessorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrintProcessorW");
	return 0;
}

BOOL
WINAPI
OAddPrintProvidorW(
	LPWSTR  pName,
	DWORD    level,
	LPBYTE   pProvidorInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AddPrintProvidorW");
	return 0;
}

LONG
WINAPI
OAdvancedDocumentPropertiesW(
	HWND    hWnd,
	HANDLE  hPrinter,
	LPWSTR   pDeviceName,
	PDEVMODEW pDevModeOutput,
	PDEVMODEW pDevModeInput
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - AdvancedDocumentPropertiesW");
	return 0;
}

MMRESULT WINAPI OauxGetDevCapsW(UINT uDeviceID, LPAUXCAPSW pac, UINT cbac)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - auxGetDevCapsW");
	return 0;
}

BOOL
WINAPI
OBackupEventLogW (
	HANDLE hEventLog,
	LPCWSTR lpBackupFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BackupEventLogW");
	return 0;
}

HANDLE
WINAPI
OBeginUpdateResourceW(
	LPCWSTR pFileName,
	BOOL bDeleteExistingResources
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BeginUpdateResourceW");
	return 0;
}

BOOL
WINAPI
OBuildCommDCBW(
	LPCWSTR lpDef,
	LPDCB lpDCB
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BuildCommDCBW");
	return 0;
}

BOOL
WINAPI
OBuildCommDCBAndTimeoutsW(
	LPCWSTR lpDef,
	LPDCB lpDCB,
	LPCOMMTIMEOUTS lpCommTimeouts
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - BuildCommDCBAndTimeoutsW");
	return 0;
}

BOOL
WINAPI
OCallMsgFilterW(
	LPMSG lpMsg,
	int nCode)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CallMsgFilterW");
	return 0;
}

BOOL
WINAPI
OCallNamedPipeW(
	LPCWSTR lpNamedPipeName,
	LPVOID lpInBuffer,
	DWORD nInBufferSize,
	LPVOID lpOutBuffer,
	DWORD nOutBufferSize,
	LPDWORD lpBytesRead,
	DWORD nTimeOut
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CallNamedPipeW");
	return 0;
}

LONG
WINAPI
OChangeDisplaySettingsW(
	LPDEVMODEW lpDevMode,
	DWORD dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeDisplaySettingsW");
	return 0;
}

BOOL
WINAPI
OChangeMenuW(
	HMENU hMenu,
	UINT cmd,
	LPCWSTR lpszNewItem,
	UINT cmdInsert,
	UINT flags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeMenuW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OChangeServiceConfigW(
	SC_HANDLE    hService,
	DWORD        dwServiceType,
	DWORD        dwStartType,
	DWORD        dwErrorControl,
	LPCWSTR     lpBinaryPathName,
	LPCWSTR     lpLoadOrderGroup,
	LPDWORD      lpdwTagId,
	LPCWSTR     lpDependencies,
	LPCWSTR     lpServiceStartName,
	LPCWSTR     lpPassword,
	LPCWSTR     lpDisplayName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChangeServiceConfigW");
	return 0;
}
#endif

BOOL
WINAPI
OCharToOemBuffW(
	LPCWSTR lpszSrc,
	LPSTR lpszDst,
	DWORD cchDstLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CharToOemBuffW");
	return 0;
}

DWORD
WINAPI
OCharUpperBuffW(
	LPWSTR lpsz,
	DWORD cchLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CharUpperBuffW");
	return 0;
}

BOOL
WINAPI
OChooseColorW(
	LPCHOOSECOLORW lpcc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChooseColorW");
	return 0;
}

BOOL
APIENTRY OChooseFontW(LPCHOOSEFONTW pchfw)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ChooseFontW");
	return 0;
}

BOOL
WINAPI
OClearEventLogW (
	HANDLE hEventLog,
	LPCWSTR lpBackupFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ClearEventLogW");
	return 0;
}

BOOL
WINAPI
OCommConfigDialogW(
	LPCWSTR lpszName,
	HWND hWnd,
	LPCOMMCONFIG lpCC
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CommConfigDialogW");
	return 0;
}

int
WINAPI
OCompareStringW(
	LCID     Locale,
	DWORD    dwCmpFlags,
	LPCWSTR lpString1,
	int      cchCount1,
	LPCWSTR lpString2,
	int      cchCount2)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CompareStringW");
	return 0;
}

BOOL
WINAPI
OConfigurePortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pPortName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ConfigurePortW");
	return 0;
}

int
WINAPI
OCopyAcceleratorTableW(
	HACCEL hAccelSrc,
	LPACCEL lpAccelDst,
	int cAccelEntries)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyAcceleratorTableW");
	return 0;
}

HENHMETAFILE
WINAPI
OCopyEnhMetaFileW(HENHMETAFILE, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyEnhMetaFileW");
	return 0;
}

HMETAFILE
WINAPI
OCopyMetaFileW(HMETAFILE, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CopyMetaFileW");
	return 0;
}

HACCEL
WINAPI
OCreateAcceleratorTableW(
	LPACCEL, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateAcceleratorTableW");
	return 0;
}

WINAPI
OCreateColorSpaceW(LPLOGCOLORSPACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateColorSpaceW");
	return 0;
}

HDC
WINAPI
OCreateDCW(
	LPCWSTR lpszDriver,
	LPCWSTR lpszDevice,
	LPCWSTR lpszOutput,
	CONST DEVMODEW *lpInitData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDCW");
	return 0;
}

HDESK
WINAPI
OCreateDesktopW(
	LPWSTR lpszDesktop,
	LPWSTR lpszDevice,
	LPDEVMODEW pDevmode,
	DWORD dwFlags,
	DWORD dwDesiredAccess,
	LPSECURITY_ATTRIBUTES lpsa)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDesktopW");
	return 0;
}

HWND
WINAPI
OCreateDialogIndirectParamW(
	HINSTANCE hInstance,
	LPCDLGTEMPLATEW lpTemplate,
	HWND hWndParent,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDialogIndirectParamW");
	return 0;
}

HWND
WINAPI
OCreateDialogParamW(
	HINSTANCE hInstance,
	LPCWSTR lpTemplateName,
	HWND hWndParent ,
	DLGPROC lpDialogFunc,
	LPARAM dwInitParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateDialogParamW");
	return 0;
}

HDC
WINAPI
OCreateICW(
	LPCWSTR lpszDriver,
	LPCWSTR lpszDevice,
	LPCWSTR lpszOutput,
	CONST DEVMODEW *lpdvmInit)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateICW");
	return 0;
}

HANDLE
WINAPI
OCreateMailslotW(
	LPCWSTR lpName,
	DWORD nMaxMessageSize,
	DWORD lReadTimeout,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateMailslotW");
	return 0;
}

HANDLE
WINAPI
OCreateMutexW(
	LPSECURITY_ATTRIBUTES lpMutexAttributes,
	BOOL bInitialOwner,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateMutexW");
	return 0;
}

HANDLE
WINAPI
OCreateNamedPipeW(
	LPCWSTR lpName,
	DWORD dwOpenMode,
	DWORD dwPipeMode,
	DWORD nMaxInstances,
	DWORD nOutBufferSize,
	DWORD nInBufferSize,
	DWORD nDefaultTimeOut,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateNamedPipeW");
	return 0;
}

BOOL
WINAPI
OCreateProcessW(
	LPCWSTR lpApplicationName,
	LPWSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory,
	LPSTARTUPINFOW lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateProcessW");
	return 0;
}

BOOL
WINAPI
OCreateProcessAsUserW (
	HANDLE hToken,
	LPCWSTR lpApplicationName,
	LPWSTR lpCommandLine,
	LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes,
	BOOL bInheritHandles,
	DWORD dwCreationFlags,
	LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory,
	LPSTARTUPINFOW lpStartupInfo,
	LPPROCESS_INFORMATION lpProcessInformation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateProcessAsUserW");
	return 0;
}

HPROPSHEETPAGE
WINAPI
OCreatePropertySheetPageW(
	LPCPROPSHEETPAGEW lpcpsp
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreatePropertySheetPageW");
	return 0;
}

BOOL
WINAPI
OCreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateScalableFontResourceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OCreateServiceW(
	SC_HANDLE    hSCManager,
	LPCWSTR     lpServiceName,
	LPCWSTR     lpDisplayName,
	DWORD        dwDesiredAccess,
	DWORD        dwServiceType,
	DWORD        dwStartType,
	DWORD        dwErrorControl,
	LPCWSTR     lpBinaryPathName,
	LPCWSTR     lpLoadOrderGroup,
	LPDWORD      lpdwTagId,
	LPCWSTR     lpDependencies,
	LPCWSTR     lpServiceStartName,
	LPCWSTR     lpPassword
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateServiceW");
	return 0;
}
#endif

HWND WINAPI OCreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateStatusWindowW");
	return 0;
}

HWINSTA
WINAPI
OCreateWindowStationW(
	LPWSTR lpwinsta,
	DWORD dwReserved,
	DWORD dwDesiredAccess,
	LPSECURITY_ATTRIBUTES lpsa)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - CreateWindowStationW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ODceErrorInqTextW (
	IN RPC_STATUS RpcStatus,
	OUT unsigned short __RPC_FAR * ErrorText
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DceErrorInqTextW");
	return 0;
}

BOOL
WINAPI
ODefineDosDeviceW(
	DWORD dwFlags,
	LPCWSTR lpDeviceName,
	LPCWSTR lpTargetPath
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DefineDosDeviceW");
	return 0;
}

BOOL
WINAPI
ODeleteFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeleteFormW");
	return 0;
}

BOOL
WINAPI
ODeleteMonitorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pMonitorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeleteMonitorW");
	return 0;
}

BOOL
WINAPI
ODeletePortW(
	LPWSTR   pName,
	HWND    hWnd,
	LPWSTR   pPortName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePortW");
	return 0;
}

BOOL
WINAPI
ODeletePrinterConnectionW(
	LPWSTR   pName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrinterConnectionW");
	return 0;
}

BOOL
WINAPI
ODeletePrinterDriverW(
   LPWSTR    pName,
   LPWSTR    pEnvironment,
   LPWSTR    pDriverName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrinterDriverW");
	return 0;
}

BOOL
WINAPI
ODeletePrintProcessorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPrintProcessorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrintProcessorW");
	return 0;
}

BOOL
WINAPI
ODeletePrintProvidorW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	LPWSTR   pPrintProvidorName
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeletePrintProvidorW");
	return 0;
}

int
WINAPI
ODeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,
								LPWSTR, CONST DEVMODEW *)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DeviceCapabilitiesW");
	return 0;
}

int
WINAPI
ODlgDirListW(
	HWND hDlg,
	LPWSTR lpPathSpec,
	int nIDListBox,
	int nIDStaticPath,
	UINT uFileType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirListW");
	return 0;
}

int
WINAPI
ODlgDirListComboBoxW(
	HWND hDlg,
	LPWSTR lpPathSpec,
	int nIDComboBox,
	int nIDStaticPath,
	UINT uFiletype)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirListComboBoxW");
	return 0;
}

BOOL
WINAPI
ODlgDirSelectComboBoxExW(
	HWND hDlg,
	LPWSTR lpString,
	int nCount,
	int nIDComboBox)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirSelectComboBoxExW");
	return 0;
}

BOOL
WINAPI
ODlgDirSelectExW(
	HWND hDlg,
	LPWSTR lpString,
	int nCount,
	int nIDListBox)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DlgDirSelectExW");
	return 0;
}

DWORD
WINAPI
ODocumentPropertiesW(
	HWND      hWnd,
	HANDLE    hPrinter,
	LPWSTR   pDeviceName,
	PDEVMODEW pDevModeOutput,
	PDEVMODEW pDevModeInput,
	DWORD     fMode
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DocumentPropertiesW");
	return 0;
}

DWORD
APIENTRY
ODoEnvironmentSubstW(LPWSTR szString, UINT cbString)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DoEnvironmentSubstW");
	return 0;
}

UINT
APIENTRY
ODragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DragQueryFileW");
	return 0;
}

BOOL
WINAPI
ODrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DrawStateW");
	return 0;
}

BOOL
WINAPI
OEndUpdateResourceW(
	HANDLE      hUpdate,
	BOOL        fDiscard
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EndUpdateResourceW");
	return 0;
}

BOOL
WINAPI
OEnumCalendarInfoW(
	CALINFO_ENUMPROCW lpCalInfoEnumProc,
	LCID              Locale,
	CALID             Calendar,
	CALTYPE           CalType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumCalendarInfoW");
	return 0;
}

BOOL
WINAPI
OEnumDateFormatsW(
	DATEFMT_ENUMPROCW lpDateFmtEnumProc,
	LCID              Locale,
	DWORD             dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDateFormatsW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OEnumDependentServicesW(
	SC_HANDLE               hService,
	DWORD                   dwServiceState,
	LPENUM_SERVICE_STATUSW  lpServices,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded,
	LPDWORD                 lpServicesReturned
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDependentServicesW");
	return 0;
}
#endif

BOOL
WINAPI
OEnumDesktopsW(
	HWINSTA hwinsta,
	DESKTOPENUMPROCW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDesktopsW");
	return 0;
}

BOOL
WINAPI
OEnumDisplaySettingsW(
	LPCWSTR lpszDeviceName,
	DWORD iModeNum,
	LPDEVMODEW lpDevMode)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumDisplaySettingsW");
	return 0;
}

int
WINAPI
OEnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontFamiliesW");
	return 0;
}

int
WINAPI
OEnumFontFamiliesExW(HDC, LPLOGFONTW,FONTENUMPROCW, LPARAM,DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontFamiliesExW");
	return 0;
}

int
WINAPI
OEnumFontsW(HDC, LPCWSTR,  FONTENUMPROCW, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFontsW");
	return 0;
}

BOOL
WINAPI
OEnumFormsW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pForm,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumFormsW");
	return 0;
}

WINAPI
OEnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumICMProfilesW");
	return 0;
}

BOOL
WINAPI
OEnumJobsW(
	HANDLE  hPrinter,
	DWORD   FirstJob,
	DWORD   NoJobs,
	DWORD   Level,
	LPBYTE  pJob,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumJobsW");
	return 0;
}

BOOL
WINAPI
OEnumMonitorsW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pMonitors,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumMonitorsW");
	return 0;
}

BOOL
WINAPI
OEnumPortsW(
	LPWSTR   pName,
	DWORD   Level,
	LPBYTE  pPorts,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPortsW");
	return 0;
}

BOOL
WINAPI
OEnumPrinterDriversW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrinterDriversW");
	return 0;
}

BOOL
WINAPI
OEnumPrintersW(
	DWORD   Flags,
	LPWSTR   Name,
	DWORD   Level,
	LPBYTE  pPrinterEnum,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintersW");
	return 0;
}

BOOL
WINAPI
OEnumPrintProcessorDatatypesW(
	LPWSTR   pName,
	LPWSTR   pPrintProcessorName,
	DWORD   Level,
	LPBYTE  pDatatypes,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintProcessorDatatypesW");
	return 0;
}

BOOL
WINAPI
OEnumPrintProcessorsW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pPrintProcessorInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded,
	LPDWORD pcReturned
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPrintProcessorsW");
	return 0;
}

int
WINAPI
OEnumPropsW(
	HWND hWnd,
	PROPENUMPROCW lpEnumFunc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPropsW");
	return 0;
}

int
WINAPI
OEnumPropsExW(
	HWND hWnd,
	PROPENUMPROCEXW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumPropsExW");
	return 0;
}

INT
APIENTRY
OEnumProtocolsW (
	IN     LPINT           lpiProtocols,
	IN OUT LPVOID          lpProtocolBuffer,
	IN OUT LPDWORD         lpdwBufferLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumProtocolsW");
	return 0;
}

BOOL
WINAPI
OEnumResourceLanguagesW(
	HMODULE hModule,
	LPCWSTR lpType,
	LPCWSTR lpName,
	ENUMRESLANGPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceLanguagesW");
	return 0;
}

BOOL
WINAPI
OEnumResourceNamesW(
	HMODULE hModule,
	LPCWSTR lpType,
	ENUMRESNAMEPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceNamesW");
	return 0;
}

BOOL
WINAPI
OEnumResourceTypesW(
	HMODULE hModule,
	ENUMRESTYPEPROC lpEnumFunc,
	LONG lParam
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumResourceTypesW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OEnumServicesStatusW(
	SC_HANDLE               hSCManager,
	DWORD                   dwServiceType,
	DWORD                   dwServiceState,
	LPENUM_SERVICE_STATUSW  lpServices,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded,
	LPDWORD                 lpServicesReturned,
	LPDWORD                 lpResumeHandle
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumServicesStatusW");
	return 0;
}
#endif

BOOL
WINAPI
OEnumSystemCodePagesW(
	CODEPAGE_ENUMPROCW lpCodePageEnumProc,
	DWORD              dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumSystemCodePagesW");
	return 0;
}

BOOL
WINAPI
OEnumSystemLocalesW(
	LOCALE_ENUMPROCW lpLocaleEnumProc,
	DWORD            dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumSystemLocalesW");
	return 0;
}

BOOL
WINAPI
OEnumTimeFormatsW(
	TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
	LCID              Locale,
	DWORD             dwFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumTimeFormatsW");
	return 0;
}

BOOL
WINAPI
OEnumWindowStationsW(
	WINSTAENUMPROCW lpEnumFunc,
	LPARAM lParam)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - EnumWindowStationsW");
	return 0;
}

HICON
APIENTRY
OExtractAssociatedIconW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIcon)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractAssociatedIconW");
	return 0;
}

HICON
APIENTRY
OExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractIconW");
	return 0;
}


UINT
WINAPI
OExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON FAR *phiconLarge, HICON FAR *phiconSmall, UINT nIcons)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtractIconExW");
	return 0;
}

// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*
BOOL
WINAPI
OExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ExtTextOutW");
	return 0;
}
*/

BOOL
WINAPI
OFillConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	WCHAR  cCharacter,
	DWORD  nLength,
	COORD  dwWriteCoord,
	LPDWORD lpNumberOfCharsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FillConsoleOutputCharacterW");
	return 0;
}

LPWSTR
APIENTRY
OFindEnvironmentStringW(LPWSTR szEnvVar)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindEnvironmentStringW");
	return 0;
}

HINSTANCE
APIENTRY
OFindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindExecutableW");
	return 0;
}

HRSRC
WINAPI
OFindResourceExW(
	HMODULE hModule,
	LPCWSTR lpType,
	LPCWSTR lpName,
	WORD    wLanguage
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindResourceExW");
	return 0;
}

APIENTRY
OFindTextW(LPFINDREPLACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindTextW");
	return 0;
}

HWND
WINAPI
OFindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FindWindowExW");
	return 0;
}

int
WINAPI
OFoldStringW(
	DWORD    dwMapFlags,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWSTR  lpDestStr,
	int      cchDest)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - FoldStringW");
	return 0;
}

BOOL
WINAPI
OGetBinaryTypeW(
	LPCWSTR lpApplicationName,
	LPDWORD lpBinaryType
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetBinaryTypeW");
	return 0;
}

DWORD
WINAPI
OGetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCharacterPlacementW");
	return 0;
}

BOOL
WINAPI
OGetCharWidth32W(HDC, UINT, UINT, LPINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCharWidth32W");
	return 0;
}

LPWSTR
WINAPI
OGetCommandLineW(
	VOID
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCommandLineW");
	return 0;
}

DWORD
WINAPI
OGetCompressedFileSizeW(
	LPCWSTR lpFileName,
	LPDWORD lpFileSizeHigh
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCompressedFileSizeW");
	return 0;
}

BOOL
WINAPI
OGetComputerNameW (
	LPWSTR lpBuffer,
	LPDWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetComputerNameW");
	return 0;
}

DWORD
WINAPI
OGetConsoleTitleW(
	LPWSTR lpConsoleTitle,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetConsoleTitleW");
	return 0;
}

int
WINAPI
OGetCurrencyFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	LPCWSTR lpValue,
	CONST CURRENCYFMTW *lpFormat,
	LPWSTR  lpCurrencyStr,
	int      cchCurrency)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetCurrencyFormatW");
	return 0;
}

int
WINAPI
OGetDateFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	CONST SYSTEMTIME *lpDate,
	LPCWSTR lpFormat,
	LPWSTR  lpDateStr,
	int      cchDate)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDateFormatW");
	return 0;
}

BOOL
WINAPI
OGetDefaultCommConfigW(
	LPCWSTR lpszName,
	LPCOMMCONFIG lpCC,
	LPDWORD lpdwSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDefaultCommConfigW");
	return 0;
}

BOOL
WINAPI
OGetDiskFreeSpaceW(
	LPCWSTR lpRootPathName,
	LPDWORD lpSectorsPerCluster,
	LPDWORD lpBytesPerSector,
	LPDWORD lpNumberOfFreeClusters,
	LPDWORD lpTotalNumberOfClusters
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDiskFreeSpaceW");
	return 0;
}

UINT
WINAPI
OGetDriveTypeW(
	LPCWSTR lpRootPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetDriveTypeW");
	return 0;
}

HENHMETAFILE
WINAPI
OGetEnhMetaFileW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnhMetaFileW");
	return 0;
}

UINT
WINAPI
OGetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnhMetaFileDescriptionW");
	return 0;
}

DWORD
WINAPI
OGetEnvironmentVariableW(
	LPCWSTR lpName,
	LPWSTR lpBuffer,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetEnvironmentVariableW");
	return 0;
}

INT
APIENTRY
OGetExpandedNameW(
	LPWSTR,
	LPWSTR
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetExpandedNameW");
	return 0;
}

BOOL
WINAPI
OGetFileSecurityW (
	LPCWSTR lpFileName,
	SECURITY_INFORMATION RequestedInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	DWORD nLength,
	LPDWORD lpnLengthNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileSecurityW");
	return 0;
}

short
WINAPI
OGetFileTitleW
(
LPCWSTR pwszFile,
LPWSTR pwszOut,
WORD w
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileTitleW");
	return 0;
}

BOOL
WINAPI
OGetFileVersionInfoW(
	LPWSTR lpszFile,
	DWORD dwHandle,
	DWORD cbBuf,
	LPVOID lpvData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileVersionInfoW");
	return 0;
}

DWORD
WINAPI
OGetFileVersionInfoSizeW(
	LPWSTR lpszFile,
	LPDWORD lpdwHandle)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFileVersionInfoSizeW");
	return 0;
}

BOOL
WINAPI
OGetFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName,
	DWORD   Level,
	LPBYTE  pForm,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetFormW");
	return 0;
}

WINAPI OGetICMProfileW(HDC,LPDWORD,LPWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetICMProfileW");
	return 0;
}

BOOL
WINAPI
OGetJobW(
   HANDLE   hPrinter,
   DWORD    JobId,
   DWORD    Level,
   LPBYTE   pJob,
   DWORD    cbBuf,
   LPDWORD  pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetJobW");
	return 0;
}

BOOL
WINAPI
OGetKeyboardLayoutNameW(
	LPWSTR pwszKLID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetKeyboardLayoutNameW");
	return 0;
}

WINAPI OGetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetLogColorSpaceW");
	return 0;
}

DWORD
WINAPI
OGetLogicalDriveStringsW(
	DWORD nBufferLength,
	LPWSTR lpBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetLogicalDriveStringsW");
	return 0;
}

BOOL
WINAPI
OGetMenuItemInfoW(
	HMENU,
	UINT,
	BOOL,
	LPMENUITEMINFOW
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuItemInfoW");
	return 0;
}

HMETAFILE   WINAPI OGetMetaFileW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMetaFileW");
	return 0;
}

INT
APIENTRY
OGetNameByTypeW (
	IN     LPGUID          lpServiceType,
	IN OUT LPWSTR         lpServiceName,
	IN     DWORD           dwNameLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNameByTypeW");
	return 0;
}

BOOL
WINAPI
OGetNamedPipeHandleStateW(
	HANDLE hNamedPipe,
	LPDWORD lpState,
	LPDWORD lpCurInstances,
	LPDWORD lpMaxCollectionCount,
	LPDWORD lpCollectDataTimeout,
	LPWSTR lpUserName,
	DWORD nMaxUserNameSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNamedPipeHandleStateW");
	return 0;
}

int
WINAPI
OGetNumberFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	LPCWSTR lpValue,
	CONST NUMBERFMTW *lpFormat,
	LPWSTR  lpNumberStr,
	int      cchNumber)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetNumberFormatW");
	return 0;
}

APIENTRY
OGetOpenFileNameW(
LPOPENFILENAMEW lpofn
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetOpenFileNameW");
	return 0;
}

BOOL
WINAPI
OGetPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pPrinter,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterW");
	return 0;
}

DWORD
WINAPI
OGetPrinterDataW(
	HANDLE   hPrinter,
	LPWSTR    pValueName,
	LPDWORD  pType,
	LPBYTE   pData,
	DWORD    nSize,
	LPDWORD  pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDataW");
	return 0;
}

BOOL
WINAPI
OGetPrinterDriverW(
	HANDLE  hPrinter,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDriverW");
	return 0;
}

BOOL
WINAPI
OGetPrinterDriverDirectoryW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pDriverDirectory,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrinterDriverDirectoryW");
	return 0;
}

BOOL
WINAPI
OGetPrintProcessorDirectoryW(
	LPWSTR   pName,
	LPWSTR   pEnvironment,
	DWORD   Level,
	LPBYTE  pPrintProcessorInfo,
	DWORD   cbBuf,
	LPDWORD pcbNeeded
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrintProcessorDirectoryW");
	return 0;
}

DWORD
WINAPI
OGetPrivateProfileSectionW(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileSectionW");
	return 0;
}

DWORD
WINAPI
OGetPrivateProfileSectionNamesW(
	LPWSTR lpszReturnBuffer,
	DWORD nSize,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileSectionNamesW");
	return 0;
}

BOOL
WINAPI
OGetPrivateProfileStructW(
	LPCWSTR lpszSection,
	LPCWSTR lpszKey,
	LPVOID   lpStruct,
	UINT     uSizeStruct,
	LPCWSTR szFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetPrivateProfileStructW");
	return 0;
}

DWORD
WINAPI
OGetProfileSectionW(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetProfileSectionW");
	return 0;
}

DWORD
WINAPI
OGetProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpDefault,
	LPWSTR lpReturnedString,
	DWORD nSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetProfileStringW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OGetServiceDisplayNameW(
	SC_HANDLE               hSCManager,
	LPCWSTR                lpServiceName,
	LPWSTR                 lpDisplayName,
	LPDWORD                 lpcchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetServiceDisplayNameW");
	return 0;
}

BOOL
WINAPI
OGetServiceKeyNameW(
	SC_HANDLE               hSCManager,
	LPCWSTR                lpDisplayName,
	LPWSTR                 lpServiceName,
	LPDWORD                 lpcchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetServiceKeyNameW");
	return 0;
}
#endif

APIENTRY
OGetSaveFileNameW(LPOPENFILENAMEW lpofn)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetSaveFileNameW");
	return 0;
}

DWORD
WINAPI
OGetShortPathNameW(
	LPCWSTR lpszLongPath,
	LPWSTR  lpszShortPath,
	DWORD    cchBuffer
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetShortPathNameW");
	return 0;
}

VOID
WINAPI
OGetStartupInfoW(
	LPSTARTUPINFOW lpStartupInfo
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetStartupInfoW");
	return;
}

BOOL
WINAPI
OGetStringTypeExW(
	LCID     Locale,
	DWORD    dwInfoType,
	LPCWSTR lpSrcStr,
	int      cchSrc,
	LPWORD   lpCharType)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetStringTypeExW");
	return 0;
}

UINT
WINAPI
OGetSystemDirectoryW(
	LPWSTR lpBuffer,
	UINT uSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetSystemDirectoryW");
	return 0;
}

int
WINAPI
OGetTimeFormatW(
	LCID     Locale,
	DWORD    dwFlags,
	CONST SYSTEMTIME *lpTime,
	LPCWSTR lpFormat,
	LPWSTR  lpTimeStr,
	int      cchTime)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetTimeFormatW");
	return 0;
}

INT
APIENTRY
OGetTypeByNameW (
	IN     LPWSTR         lpServiceName,
	IN OUT LPGUID          lpServiceType
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetTypeByNameW");
	return 0;
}

BOOL
WINAPI
OGetUserObjectInformationW(
	HANDLE hObj,
	int nIndex,
	PVOID pvInfo,
	DWORD nLength,
	LPDWORD lpnLengthNeeded)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetUserObjectInformationW");
	return 0;
}

UINT
WINAPI
OGetWindowsDirectoryW(
	LPWSTR lpBuffer,
	UINT uSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetWindowsDirectoryW");
	return 0;
}

ATOM
WINAPI
OGlobalFindAtomW(
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GlobalFindAtomW");
	return 0;
}

RPC_STATUS RPC_ENTRY
OI_RpcServerUnregisterEndpointW (
	IN unsigned short * Protseq,
	IN unsigned short * Endpoint
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - I_RpcServerUnregisterEndpointW");
	return 0;
}

HIMAGELIST
WINAPI
OImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImageList_LoadImageW");
	return 0;
}

WINAPI
OImmConfigureIMEW(HKL, HWND, DWORD, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmConfigureIMEW");
	return 0;
}

WINAPI
OImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmEnumRegisterWordW");
	return 0;
}

WINAPI
OImmEscapeW(HKL, HIMC, UINT, LPVOID)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmEscapeW");
	return 0;
}

WINAPI
OImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST, DWORD dwBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCandidateListW");
	return 0;
}

WINAPI
OImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCandidateListCountW");
	return 0;
}

WINAPI
OImmGetCompositionFontW(HIMC, LPLOGFONTW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCompositionFontW");
	return 0;
}

WINAPI
OImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetCompositionStringW");
	return 0;
}

WINAPI
OImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD dwBufLen, UINT uFlag)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetConversionListW");
	return 0;
}

WINAPI
OImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetDescriptionW");
	return 0;
}

WINAPI
OImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR, DWORD dwBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetGuideLineW");
	return 0;
}

WINAPI
OImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetIMEFileNameW");
	return 0;
}

WINAPI
OImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmGetRegisterWordStyleW");
	return 0;
}

WINAPI
OImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmInstallIMEW");
	return 0;
}

WINAPI
OImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmIsUIMessageW");
	return 0;
}

WINAPI
OImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmRegisterWordW");
	return 0;
}

WINAPI
OImmSetCompositionFontW(HIMC, LPLOGFONTW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmSetCompositionFontW");
	return 0;
}

WINAPI
OImmSetCompositionStringW(HIMC, DWORD dwIndex, LPCVOID lpComp, DWORD, LPCVOID lpRead, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmSetCompositionStringW");
	return 0;
}

WINAPI
OImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ImmUnregisterWordW");
	return 0;
}

BOOL
APIENTRY
OInitiateSystemShutdownW(
	LPWSTR lpMachineName,
	LPWSTR lpMessage,
	DWORD dwTimeout,
	BOOL bForceAppsClosed,
	BOOL bRebootAfterShutdown
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - InitiateSystemShutdownW");
	return 0;
}

BOOL
WINAPI
OInsertMenuItemW(
	HMENU,
	UINT,
	BOOL,
	LPCMENUITEMINFOW
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - InsertMenuItemW");
	return 0;
}

BOOL
WINAPI
OIsCharLowerW(
	WCHAR ch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - IsCharLowerW");
	return 0;
}

BOOL
WINAPI
OIsCharUpperW(
	WCHAR ch)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - IsCharUpperW");
	return 0;
}

MMRESULT
WINAPI
OjoyGetDevCapsW(UINT uJoyID, LPJOYCAPSW pjc, UINT cbjc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - joyGetDevCapsW");
	return 0;
}

HCURSOR
WINAPI
OLoadCursorFromFileW(
	LPCWSTR    lpFileName)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LoadCursorFromFileW");
	return 0;
}

HKL
WINAPI
OLoadKeyboardLayoutW(
	LPCWSTR pwszKLID,
	UINT Flags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LoadKeyboardLayoutW");
	return 0;
}

BOOL
WINAPI
OLogonUserW (
	LPWSTR lpszUsername,
	LPWSTR lpszDomain,
	LPWSTR lpszPassword,
	DWORD dwLogonType,
	DWORD dwLogonProvider,
	PHANDLE phToken
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LogonUserW");
	return 0;
}

INT
APIENTRY
OLZOpenFileW(
	LPWSTR,
	LPOFSTRUCT,
	WORD
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - LZOpenFileW");
	return 0;
}

UINT
WINAPI
OMapVirtualKeyExW(
	UINT uCode,
	UINT uMapType,
	HKL dwhkl)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MapVirtualKeyExW");
	return 0;
}

HRESULT
WINAPI
OMIMEAssociationDialogW(HWND hwndParent,
									   DWORD dwInFlags,
									   PCWSTR pcszFile,
									   PCWSTR pcszMIMEContentType,
									   PWSTR pszAppBuf,
									   UINT ucAppBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MIMEAssociationDialogW");
	return 0;
}

DWORD
APIENTRY
OMultinetGetConnectionPerformanceW(
		LPNETRESOURCEW lpNetResource,
		LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - MultinetGetConnectionPerformanceW");
	return 0;
}

BOOL
WINAPI
OObjectCloseAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	BOOL GenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectCloseAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OObjectOpenAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	LPWSTR ObjectTypeName,
	LPWSTR ObjectName,
	PSECURITY_DESCRIPTOR pSecurityDescriptor,
	HANDLE ClientToken,
	DWORD DesiredAccess,
	DWORD GrantedAccess,
	PPRIVILEGE_SET Privileges,
	BOOL ObjectCreation,
	BOOL AccessGranted,
	LPBOOL GenerateOnClose
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectOpenAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OObjectPrivilegeAuditAlarmW (
	LPCWSTR SubsystemName,
	LPVOID HandleId,
	HANDLE ClientToken,
	DWORD DesiredAccess,
	PPRIVILEGE_SET Privileges,
	BOOL AccessGranted
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ObjectPrivilegeAuditAlarmW");
	return 0;
}

BOOL
WINAPI
OOemToCharBuffW(
	LPCSTR lpszSrc,
	LPWSTR lpszDst,
	DWORD cchDstLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OemToCharBuffW");
	return 0;
}

HANDLE
WINAPI
OOpenBackupEventLogW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenBackupEventLogW");
	return 0;
}

HDESK
WINAPI
OOpenDesktopW(
	LPWSTR lpszDesktop,
	DWORD dwFlags,
	BOOL fInherit,
	DWORD dwDesiredAccess)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenDesktopW");
	return 0;
}

HANDLE
WINAPI
OOpenEventW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenEventW");
	return 0;
}

HANDLE
WINAPI
OOpenEventLogW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpSourceName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenEventLogW");
	return 0;
}

HANDLE
WINAPI
OOpenFileMappingW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenFileMappingW");
	return 0;
}

HANDLE
WINAPI
OOpenMutexW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenMutexW");
	return 0;
}

BOOL
WINAPI
OOpenPrinterW(
	LPWSTR    pPrinterName,
	LPHANDLE phPrinter,
	LPPRINTER_DEFAULTSW pDefault
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenPrinterW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OOpenSCManagerW(
	LPCWSTR lpMachineName,
	LPCWSTR lpDatabaseName,
	DWORD   dwDesiredAccess
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenSCManagerW");
	return 0;
}
#endif

HANDLE
WINAPI
OOpenSemaphoreW(
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	LPCWSTR lpName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenSemaphoreW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SC_HANDLE
WINAPI
OOpenServiceW(
	SC_HANDLE   hSCManager,
	LPCWSTR    lpServiceName,
	DWORD       dwDesiredAccess
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenServiceW");
	return 0;
}
#endif

HWINSTA
WINAPI
OOpenWindowStationW(
	LPWSTR lpszWinSta,
	BOOL fInherit,
	DWORD dwDesiredAccess)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - OpenWindowStationW");
	return 0;
}

APIENTRY OPageSetupDlgW( LPPAGESETUPDLGW )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PageSetupDlgW");
	return 0;
}

BOOL
WINAPI
OPeekConsoleInputW(
	HANDLE hConsoleInput,
	PINPUT_RECORD lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PeekConsoleInputW");
	return 0;
}

BOOL
WINAPI
OPolyTextOutW(HDC, CONST POLYTEXTW *, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PolyTextOutW");
	return 0;
}

APIENTRY
OPrintDlgW(LPPRINTDLGW lppd)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrintDlgW");
	return 0;
}

DWORD
WINAPI
OPrinterMessageBoxW(
	HANDLE  hPrinter,
	DWORD   Error,
	HWND    hWnd,
	LPWSTR   pText,
	LPWSTR   pCaption,
	DWORD   dwType
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrinterMessageBoxW");
	return 0;
}

BOOL
WINAPI
OPrivilegedServiceAuditAlarmW (
	LPCWSTR SubsystemName,
	LPCWSTR ServiceName,
	HANDLE ClientToken,
	PPRIVILEGE_SET Privileges,
	BOOL AccessGranted
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PrivilegedServiceAuditAlarmW");
	return 0;
}

int
WINAPI
OPropertySheetW(
	LPCPROPSHEETHEADERW lpcpsh
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - PropertySheetW");
	return 0;
}

DWORD
WINAPI
OQueryDosDeviceW(
	LPCWSTR lpDeviceName,
	LPWSTR lpTargetPath,
	DWORD ucchMax
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryDosDeviceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OQueryServiceConfigW(
	SC_HANDLE               hService,
	LPQUERY_SERVICE_CONFIGW lpServiceConfig,
	DWORD                   cbBufSize,
	LPDWORD                 pcbBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryServiceConfigW");
	return 0;
}

BOOL
WINAPI
OQueryServiceLockStatusW(
	SC_HANDLE                       hSCManager,
	LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
	DWORD                           cbBufSize,
	LPDWORD                         pcbBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - QueryServiceLockStatusW");
	return 0;
}
#endif

BOOL
WINAPI
OReadConsoleW(
	HANDLE hConsoleInput,
	LPVOID lpBuffer,
	DWORD nNumberOfCharsToRead,
	LPDWORD lpNumberOfCharsRead,
	LPVOID lpReserved
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleW");
	return 0;
}

BOOL
WINAPI
OReadConsoleInputW(
	HANDLE hConsoleInput,
	PINPUT_RECORD lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleInputW");
	return 0;
}

BOOL
WINAPI
OReadConsoleOutputW(
	HANDLE hConsoleOutput,
	PCHAR_INFO lpBuffer,
	COORD dwBufferSize,
	COORD dwBufferCoord,
	PSMALL_RECT lpReadRegion
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleOutputW");
	return 0;
}

BOOL
WINAPI
OReadConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	LPWSTR lpCharacter,
	DWORD nLength,
	COORD dwReadCoord,
	LPDWORD lpNumberOfCharsRead
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadConsoleOutputCharacterW");
	return 0;
}

BOOL
WINAPI
OReadEventLogW (
	 HANDLE     hEventLog,
	 DWORD      dwReadFlags,
	 DWORD      dwRecordOffset,
	 LPVOID     lpBuffer,
	 DWORD      nNumberOfBytesToRead,
	 DWORD      *pnBytesRead,
	 DWORD      *pnMinNumberOfBytesNeeded
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReadEventLogW");
	return 0;
}

LONG
APIENTRY
ORegConnectRegistryW (
	LPWSTR lpMachineName,
	HKEY hKey,
	PHKEY phkResult
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegConnectRegistryW");
	return 0;
}

HANDLE
WINAPI
ORegisterEventSourceW (
	LPCWSTR lpUNCServerName,
	LPCWSTR lpSourceName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegisterEventSourceW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
SERVICE_STATUS_HANDLE
WINAPI
ORegisterServiceCtrlHandlerW(
	LPCWSTR             lpServiceName,
	LPHANDLER_FUNCTION   lpHandlerProc
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegisterServiceCtrlHandlerW");
	return 0;
}
#endif

LONG
APIENTRY
ORegLoadKeyW (
	HKEY    hKey,
	LPCWSTR  lpSubKey,
	LPCWSTR  lpFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegLoadKeyW");
	return 0;
}

LONG
APIENTRY
ORegQueryMultipleValuesW (
	HKEY hKey,
	PVALENTW val_list,
	DWORD num_vals,
	LPWSTR lpValueBuf,
	LPDWORD ldwTotsize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegQueryMultipleValuesW");
	return 0;
}

LONG
APIENTRY
ORegReplaceKeyW (
	HKEY     hKey,
	LPCWSTR  lpSubKey,
	LPCWSTR  lpNewFile,
	LPCWSTR  lpOldFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegReplaceKeyW");
	return 0;
}

LONG
APIENTRY
ORegRestoreKeyW (
	HKEY hKey,
	LPCWSTR lpFile,
	DWORD   dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegRestoreKeyW");
	return 0;
}

LONG
APIENTRY
ORegSaveKeyW (
	HKEY hKey,
	LPCWSTR lpFile,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegSaveKeyW");
	return 0;
}

LONG
APIENTRY
ORegUnLoadKeyW (
	HKEY    hKey,
	LPCWSTR lpSubKey
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RegUnLoadKeyW");
	return 0;
}

BOOL
WINAPI
ORemoveDirectoryW(
	LPCWSTR lpPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RemoveDirectoryW");
	return 0;
}

BOOL
WINAPI
ORemoveFontResourceW(LPCWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RemoveFontResourceW");
	return 0;
}

APIENTRY
OReplaceTextW(LPFINDREPLACEW)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReplaceTextW");
	return 0;
}

BOOL
WINAPI
OReportEventW (
	 HANDLE     hEventLog,
	 WORD       wType,
	 WORD       wCategory,
	 DWORD      dwEventID,
	 PSID       lpUserSid,
	 WORD       wNumStrings,
	 DWORD      dwDataSize,
	 LPCWSTR   *lpStrings,
	 LPVOID     lpRawData
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ReportEventW");
	return 0;
}

HDC
WINAPI
OResetDCW(
	HDC hdc,
	CONST DEVMODEW *lpInitData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ResetDCW");
	return 0;
}

BOOL
WINAPI
OResetPrinterW(
   HANDLE   hPrinter,
   LPPRINTER_DEFAULTSW pDefault
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ResetPrinterW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingFromStringBindingW (
	IN unsigned short __RPC_FAR * StringBinding,
	OUT RPC_BINDING_HANDLE __RPC_FAR * Binding
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingFromStringBindingW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingInqAuthClientW (
	IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
	OUT RPC_AUTHZ_HANDLE __RPC_FAR * Privs,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthnLevel, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthnSvc, OPTIONAL
	OUT unsigned long __RPC_FAR * AuthzSvc OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingInqAuthClientW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcBindingToStringBindingW (
	IN RPC_BINDING_HANDLE Binding,
	OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcBindingToStringBindingW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcEpRegisterNoReplaceW (
	IN RPC_IF_HANDLE IfSpec,
	IN RPC_BINDING_VECTOR * BindingVector,
	IN UUID_VECTOR * UuidVector OPTIONAL,
	IN unsigned short  * Annotation
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcEpRegisterNoReplaceW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcMgmtEpEltInqNextW (
	IN RPC_EP_INQ_HANDLE InquiryContext,
	OUT RPC_IF_ID __RPC_FAR * IfId,
	OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
	OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcMgmtEpEltInqNextW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcMgmtInqServerPrincNameW (
	IN RPC_BINDING_HANDLE Binding,
	IN unsigned long AuthnSvc,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcMgmtInqServerPrincNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNetworkInqProtseqsW (
	OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNetworkInqProtseqsW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNetworkIsProtseqValidW (
	IN unsigned short __RPC_FAR * Protseq
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNetworkIsProtseqValidW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcNsBindingInqEntryNameW (
	IN RPC_BINDING_HANDLE Binding,
	IN unsigned long EntryNameSyntax,
	OUT unsigned short __RPC_FAR * __RPC_FAR * EntryName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcNsBindingInqEntryNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcProtseqVectorFreeW (
	IN OUT RPC_PROTSEQ_VECTORW __RPC_FAR * __RPC_FAR * ProtseqVector
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcProtseqVectorFreeW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerInqDefaultPrincNameW (
	IN unsigned long AuthnSvc,
	OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerInqDefaultPrincNameW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqEpW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN unsigned short __RPC_FAR * Endpoint,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqEpW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcServerUseProtseqIfW (
	IN unsigned short __RPC_FAR * Protseq,
	IN unsigned int MaxCalls,
	IN RPC_IF_HANDLE IfSpec,
	IN void __RPC_FAR * SecurityDescriptor OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcServerUseProtseqIfW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringBindingComposeW (
	IN unsigned short __RPC_FAR * ObjUuid OPTIONAL,
	IN unsigned short __RPC_FAR * Protseq OPTIONAL,
	IN unsigned short __RPC_FAR * NetworkAddr OPTIONAL,
	IN unsigned short __RPC_FAR * Endpoint OPTIONAL,
	IN unsigned short __RPC_FAR * Options OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * StringBinding OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringBindingComposeW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringBindingParseW (
	IN unsigned short __RPC_FAR * StringBinding,
	OUT unsigned short __RPC_FAR * __RPC_FAR * ObjUuid OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Protseq OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkAddr OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * Endpoint OPTIONAL,
	OUT unsigned short __RPC_FAR * __RPC_FAR * NetworkOptions OPTIONAL
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringBindingParseW");
	return 0;
}

RPC_STATUS RPC_ENTRY
ORpcStringFreeW (
	IN OUT unsigned short __RPC_FAR * __RPC_FAR * String
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - RpcStringFreeW");
	return 0;
}

BOOL
WINAPI
OScrollConsoleScreenBufferW(
	HANDLE hConsoleOutput,
	CONST SMALL_RECT *lpScrollRectangle,
	CONST SMALL_RECT *lpClipRectangle,
	COORD dwDestinationOrigin,
	CONST CHAR_INFO *lpFill
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ScrollConsoleScreenBufferW");
	return 0;
}

DWORD
WINAPI
OSearchPathW(
	LPCWSTR lpPath,
	LPCWSTR lpFileName,
	LPCWSTR lpExtension,
	DWORD nBufferLength,
	LPWSTR lpBuffer,
	LPWSTR *lpFilePart
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SearchPathW");
	return 0;
}

BOOL
WINAPI
OSendMessageCallbackW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam,
	SENDASYNCPROC lpResultCallBack,
	DWORD dwData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SendMessageCallbackW");
	return 0;
}

LRESULT
WINAPI
OSendMessageTimeoutW(
	HWND hWnd,
	UINT Msg,
	WPARAM wParam,
	LPARAM lParam,
	UINT fuFlags,
	UINT uTimeout,
	LPDWORD lpdwResult)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SendMessageTimeoutW");
	return 0;
}

BOOL
WINAPI
OSetComputerNameW (
	LPCWSTR lpComputerName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetComputerNameW");
	return 0;
}

BOOL
WINAPI
OSetConsoleTitleW(
	LPCWSTR lpConsoleTitle
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetConsoleTitleW");
	return 0;
}

BOOL
WINAPI
OSetCurrentDirectoryW(
	LPCWSTR lpPathName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetCurrentDirectoryW");
	return 0;
}

BOOL
WINAPI
OSetDefaultCommConfigW(
	LPCWSTR lpszName,
	LPCOMMCONFIG lpCC,
	DWORD dwSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetDefaultCommConfigW");
	return 0;
}

BOOL
WINAPI
OSetEnvironmentVariableW(
	LPCWSTR lpName,
	LPCWSTR lpValue
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetEnvironmentVariableW");
	return 0;
}

BOOL
WINAPI
OSetFileSecurityW (
	LPCWSTR lpFileName,
	SECURITY_INFORMATION SecurityInformation,
	PSECURITY_DESCRIPTOR pSecurityDescriptor
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetFileSecurityW");
	return 0;
}

BOOL
WINAPI
OSetFormW(
	HANDLE  hPrinter,
	LPWSTR   pFormName,
	DWORD   Level,
	LPBYTE  pForm
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetFormW");
	return 0;
}

WINAPI
OSetICMProfileW(HDC,LPWSTR)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetICMProfileW");
	return 0;
}

BOOL
WINAPI
OSetJobW(
	HANDLE  hPrinter,
	DWORD   JobId,
	DWORD   Level,
	LPBYTE  pJob,
	DWORD   Command
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetJobW");
	return 0;
}

BOOL
WINAPI
OSetPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pPrinter,
	DWORD   Command
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetPrinterW");
	return 0;
}

DWORD
WINAPI
OSetPrinterDataW(
	HANDLE  hPrinter,
	LPWSTR   pValueName,
	DWORD   Type,
	LPBYTE  pData,
	DWORD   cbData
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetPrinterDataW");
	return 0;
}

BOOL
WINAPI
OSetUserObjectInformationW(
	HANDLE hObj,
	int nIndex,
	PVOID pvInfo,
	DWORD nLength)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetUserObjectInformationW");
	return 0;
}

BOOL
WINAPI
OSetVolumeLabelW(
	LPCWSTR lpRootPathName,
	LPCWSTR lpVolumeName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetVolumeLabelW");
	return 0;
}

HHOOK
WINAPI
OSetWindowsHookW(
	int nFilterType,
	HOOKPROC pfnFilterProc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SetWindowsHookW");
	return 0;
}

LPITEMIDLIST
WINAPI
OSHBrowseForFolderW(
	LPBROWSEINFO lpbi)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHBrowseForFolderW");
	return 0;
}

BOOL
WINAPI
OShell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - Shell_NotifyIconW");
	return 0;
}

INT
APIENTRY
OShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellAboutW");
	return 0;
}

HINSTANCE
APIENTRY
OShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellExecuteW");
	return 0;
}

BOOL
WINAPI
OShellExecuteExW(
	LPSHELLEXECUTEINFOW lpExecInfo)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - ShellExecuteExW");
	return 0;
}


int
WINAPI
OSHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHFileOperationW");
	return 0;
}

DWORD
WINAPI
OSHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW FAR *psfi, UINT cbFileInfo, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetFileInfoW");
	return 0;
}

BOOL
WINAPI
OSHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName,
							 BOOL FAR * pfMustCopy, UINT uFlags)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetNewLinkInfoW");
	return 0;
}

BOOL
WINAPI
OSHGetPathFromIDListW(
	LPCITEMIDLIST pidl,
	LPTSTR pszPath)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - SHGetPathFromIDListW");
	return 0;
}

BOOL
WINAPI
OsndPlaySoundW(LPCWSTR pszSound, UINT fuSound)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - sndPlaySoundW");
	return 0;
}

DWORD
WINAPI
OStartDocPrinterW(
	HANDLE  hPrinter,
	DWORD   Level,
	LPBYTE  pDocInfo
)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartDocPrinterW");
	return 0;
}

#if 0 //$UNDONE_POST_98 - We should wrap these as being NT only...
BOOL
WINAPI
OStartServiceW(
	SC_HANDLE            hService,
	DWORD                dwNumServiceArgs,
	LPCWSTR             *lpServiceArgVectors
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartServiceW");
	return 0;
}

BOOL
WINAPI
OStartServiceCtrlDispatcherW(
	LPSERVICE_TABLE_ENTRYW    lpServiceStartTable
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - StartServiceCtrlDispatcherW");
	return 0;
}
#endif

// Commented since gdi32.dll on Win95 provides the wrapper for this function.
/*
BOOL
WINAPI
OTextOutW(HDC, int, int, LPCWSTR, int)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - TextOutW");
	return 0;
}
*/

HRESULT
WINAPI
OTranslateURLW(PCWSTR pcszURL,
										 DWORD dwInFlags,
										 PWSTR *ppszTranslatedURL)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - TranslateURLW");
	return 0;
}

WINAPI
OUpdateICMRegKeyW(DWORD, DWORD, LPWSTR, UINT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - UpdateICMRegKeyW");
	return 0;
}

HRESULT
WINAPI
OURLAssociationDialogW(HWND hwndParent,
												 DWORD dwInFlags,
												 PCWSTR pcszFile,
												 PCWSTR pcszURL,
												 PWSTR pszAppBuf,
												 UINT ucAppBufLen)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - URLAssociationDialogW");
	return 0;
}

/* client/server */
RPC_STATUS RPC_ENTRY
OUuidFromStringW (
	IN unsigned short __RPC_FAR * StringUuid,
	OUT UUID __RPC_FAR * Uuid
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - UuidFromStringW");
	return 0;
}

DWORD
APIENTRY
OVerFindFileW(
		DWORD uFlags,
		LPWSTR szFileName,
		LPWSTR szWinDir,
		LPWSTR szAppDir,
		LPWSTR szCurDir,
		PUINT lpuCurDirLen,
		LPWSTR szDestDir,
		PUINT lpuDestDirLen
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerFindFileW");
	return 0;
}

DWORD
APIENTRY
OVerInstallFileW(
		DWORD uFlags,
		LPWSTR szSrcFileName,
		LPWSTR szDestFileName,
		LPWSTR szSrcDir,
		LPWSTR szDestDir,
		LPWSTR szCurDir,
		LPWSTR szTmpFile,
		PUINT lpuTmpFileLen
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerInstallFileW");
	return 0;
}

DWORD
APIENTRY
OVerLanguageNameW(
		DWORD wLang,
		LPWSTR szLang,
		DWORD nSize
		)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerLanguageNameW");
	return 0;
}

BOOL
WINAPI
OVerQueryValueW(
	const LPVOID pBlock,
	LPWSTR lpSubBlock,
	LPVOID *lplpBuffer,
	PUINT puLerr)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VerQueryValueW");
	return 0;
}

WINAPI
OVkKeyScanExW(
	WCHAR  ch,
	HKL   dwhkl)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - VkKeyScanExW");
	return 0;
}

BOOL
WINAPI
OWaitNamedPipeW(
	LPCWSTR lpNamedPipeName,
	DWORD nTimeOut
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WaitNamedPipeW");
	return 0;
}

MMRESULT
WINAPI
OwaveInGetDevCapsW(UINT uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveInGetDevCapsW");
	return 0;
}

MMRESULT
WINAPI
OwaveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveInGetErrorTextW");
	return 0;
}

MMRESULT
WINAPI
OwaveOutGetDevCapsW(UINT uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveOutGetDevCapsW");
	return 0;
}

MMRESULT
WINAPI
OwaveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - waveOutGetErrorTextW");
	return 0;
}

BOOL
WINAPI
OwglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wglUseFontBitmapsW");
	return 0;
}

BOOL
WINAPI
OwglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
										   FLOAT, int, LPGLYPHMETRICSFLOAT)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wglUseFontOutlinesW");
	return 0;
}

void
WINAPI
OWinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WinExecErrorW");
	return;
}

DWORD
APIENTRY
OWNetAddConnectionW(
	 LPCWSTR   lpRemoteName,
	 LPCWSTR   lpPassword,
	 LPCWSTR   lpLocalName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetAddConnection2W(
	 LPNETRESOURCEW lpNetResource,
	 LPCWSTR       lpPassword,
	 LPCWSTR       lpUserName,
	 DWORD          dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnection2W");
	return 0;
}

DWORD
APIENTRY
OWNetAddConnection3W(
	 HWND           hwndOwner,
	 LPNETRESOURCEW lpNetResource,
	 LPCWSTR       lpPassword,
	 LPCWSTR       lpUserName,
	 DWORD          dwFlags
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetAddConnection3W");
	return 0;
}

DWORD
APIENTRY
OWNetCancelConnectionW(
	 LPCWSTR lpName,
	 BOOL     fForce
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetCancelConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetCancelConnection2W(
	 LPCWSTR lpName,
	 DWORD    dwFlags,
	 BOOL     fForce
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetCancelConnection2W");
	return 0;
}

DWORD
APIENTRY
OWNetConnectionDialog1W(
	LPCONNECTDLGSTRUCTW lpConnDlgStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetConnectionDialog1W");
	return 0;
}

DWORD
APIENTRY
OWNetDisconnectDialog1W(
	LPDISCDLGSTRUCTW lpConnDlgStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetDisconnectDialog1W");
	return 0;
}

DWORD
APIENTRY
OWNetEnumResourceW(
	 HANDLE  hEnum,
	 LPDWORD lpcCount,
	 LPVOID  lpBuffer,
	 LPDWORD lpBufferSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetEnumResourceW");
	return 0;
}

DWORD
APIENTRY
OWNetGetConnectionW(
	 LPCWSTR lpLocalName,
	 LPWSTR  lpRemoteName,
	 LPDWORD  lpnLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetGetLastErrorW(
	 LPDWORD    lpError,
	 LPWSTR    lpErrorBuf,
	 DWORD      nErrorBufSize,
	 LPWSTR    lpNameBuf,
	 DWORD      nNameBufSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetLastErrorW");
	return 0;
}

DWORD
APIENTRY
OWNetGetNetworkInformationW(
	LPCWSTR          lpProvider,
	LPNETINFOSTRUCT   lpNetInfoStruct
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetNetworkInformationW");
	return 0;
}

DWORD
APIENTRY
OWNetGetProviderNameW(
	DWORD   dwNetType,
	LPWSTR lpProviderName,
	LPDWORD lpBufferSize
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetProviderNameW");
	return 0;
}

DWORD
APIENTRY
OWNetGetUniversalNameW(
	 LPCWSTR lpLocalPath,
	 DWORD    dwInfoLevel,
	 LPVOID   lpBuffer,
	 LPDWORD  lpBufferSize
	 )
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetUniversalNameW");
	return 0;
}

DWORD
APIENTRY
OWNetGetUserW(
	 LPCWSTR  lpName,
	 LPWSTR   lpUserName,
	 LPDWORD   lpnLength
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetGetUserW");
	return 0;
}

DWORD
APIENTRY
OWNetOpenEnumW(
	 DWORD          dwScope,
	 DWORD          dwType,
	 DWORD          dwUsage,
	 LPNETRESOURCEW lpNetResource,
	 LPHANDLE       lphEnum
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetOpenEnumW");
	return 0;
}

DWORD
APIENTRY
OWNetSetConnectionW(
	LPCWSTR    lpName,
	DWORD       dwProperties,
	LPVOID      pvValues
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetSetConnectionW");
	return 0;
}

DWORD
APIENTRY
OWNetUseConnectionW(
	HWND            hwndOwner,
	LPNETRESOURCEW  lpNetResource,
	LPCWSTR        lpUserID,
	LPCWSTR        lpPassword,
	DWORD           dwFlags,
	LPWSTR         lpAccessName,
	LPDWORD         lpBufferSize,
	LPDWORD         lpResult
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WNetUseConnectionW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleW(
	HANDLE hConsoleOutput,
	CONST VOID *lpBuffer,
	DWORD nNumberOfCharsToWrite,
	LPDWORD lpNumberOfCharsWritten,
	LPVOID lpReserved
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleInputW(
	HANDLE hConsoleInput,
	CONST INPUT_RECORD *lpBuffer,
	DWORD nLength,
	LPDWORD lpNumberOfEventsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleInputW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleOutputW(
	HANDLE hConsoleOutput,
	CONST CHAR_INFO *lpBuffer,
	COORD dwBufferSize,
	COORD dwBufferCoord,
	PSMALL_RECT lpWriteRegion
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleOutputW");
	return 0;
}

BOOL
WINAPI
OWriteConsoleOutputCharacterW(
	HANDLE hConsoleOutput,
	LPCWSTR lpCharacter,
	DWORD nLength,
	COORD dwWriteCoord,
	LPDWORD lpNumberOfCharsWritten
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteConsoleOutputCharacterW");
	return 0;
}

BOOL
WINAPI
OWritePrivateProfileSectionW(
	LPCWSTR lpAppName,
	LPCWSTR lpString,
	LPCWSTR lpFileName
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WritePrivateProfileSectionW");
	return 0;
}

BOOL
WINAPI
OWritePrivateProfileStructW(
	LPCWSTR lpszSection,
	LPCWSTR lpszKey,
	LPVOID   lpStruct,
	UINT     uSizeStruct,
	LPCWSTR szFile
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WritePrivateProfileStructW");
	return 0;
}

BOOL
WINAPI
OWriteProfileSectionW(
	LPCWSTR lpAppName,
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteProfileSectionW");
	return 0;
}

BOOL
WINAPI
OWriteProfileStringW(
	LPCWSTR lpAppName,
	LPCWSTR lpKeyName,
	LPCWSTR lpString
	)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - WriteProfileStringW");
	return 0;
}

int
WINAPI
OwvsprintfW(
	LPWSTR,
	LPCWSTR,
	va_list arglist)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - wvsprintfW");
	return 0;
}

DWORD
WINAPI
ODdeQueryStringW(
	DWORD idInst,
	HSZ hsz,
	LPWSTR psz,
	DWORD cchMax,
	int iCodePage)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - DdeQueryStringW");
	return 0;
}

int WINAPI
OGetClipboardFormatNameW(
	UINT format,
	LPWSTR pwsz,
	int cchMaxCount)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetClipboardFormatNameW");
	return 0;
}

int
WINAPI
OGetKeyNameTextW(
	LONG lParam,
	LPWSTR lpString,
	int nSize)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetKeyNameTextW");
	return 0;
}

int
WINAPI
OGetMenuStringW(
	HMENU hMenu,
	UINT uIDItem,
	LPWSTR lpString,
	int nMaxCount,
	UINT uFlag)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuStringW");
	return 0;
}

int
WINAPI
OGetTextFaceW(
	HDC    hdc,
	int    cch,
	LPWSTR lpFaceName)
{
	AssertFail("No Unicode Wrapper Available for Win32 API - GetMenuStringW");
	return 0;
}

#endif    //ifdef DEBUG

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\zorder.cpp ===
//------------------------------------------------------------------------------
// zorder.cpp
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     V-BMohan
//
// History
//      8-15-97     created     (ThomasOl)
//     10-31-97     rewritten   (V-BMohan)
//
//
//------------------------------------------------------------------------------

#include "stdafx.h"

#include <stdlib.h>

//#include "mfcincl.h"
#include "triedit.h"
#include "document.h"
#include "zorder.h"
#include "dispatch.h"

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::CompareProc
//
// Compare the Z-order of the two items (which must be CZOrder pointers)
// and return:
//
//      -1 if the Z-order of item 1 preceeds that of item 2
//       1 if the Z-order of item 1 succeeds or is the same as that of item 2
//

int CTriEditDocument::CompareProc(const void *arg1, const void *arg2)
{
    CZOrder* pcz1 = (CZOrder*)arg1;
    CZOrder* pcz2 = (CZOrder*)arg2;

    _ASSERTE(pcz1 != NULL);
    _ASSERTE(pcz2 != NULL);
    if (pcz1->m_zOrder < pcz2->m_zOrder)
        return -1;
    else
    if (pcz1->m_zOrder > pcz2->m_zOrder)
        return 1;

    // if arg1's Z-order is qual to arg2's zorder then return a one 
    // instead of a zero  so that the qsort function treats it as 
    // arg1's Z-Order > arg2's Z-order and keeps arg1 in top of the
    // sort order. 
    // 
    // This actually helps us to sort elements in such a  way that among
    // the elements having the same Z-order the recently created one will be
    // in top of the order. This way we make sure that when propagating
    // Z-order it doesn't affect the existing Z-order appearance of the
    // elements.
    return 1; 
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::IsEqualZIndex
//
// Given a sorted array of CZorder objects and the number of elements
// in the array, return TRUE if any two consecutive objects have the
// same Z-order. Return FALSE if this is not the case.
//

BOOL CTriEditDocument::IsEqualZIndex(CZOrder* pczOrder, LONG lIndex)
{
    for (LONG lLoop = 0; lLoop < (lIndex - 1); ++lLoop)
    {
        if (pczOrder[lLoop].m_zOrder == pczOrder[lLoop+1].m_zOrder)
            return TRUE;
    }
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::GetZIndex
//
// Fetch the Z-order value from the given HTML element and return
// it under *plZindex. Return S_OK or a Trident error.
//

HRESULT CTriEditDocument::GetZIndex(IHTMLElement* pihtmlElement, LONG* plZindex)
{
    HRESULT hr;
    IHTMLStyle* pihtmlStyle=NULL;
    VARIANT var;

    _ASSERTE(pihtmlElement);
    _ASSERTE(plZindex);
    hr = pihtmlElement->get_style(&pihtmlStyle);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pihtmlStyle);

    if (SUCCEEDED(hr) && pihtmlStyle)
    {
        VariantInit(&var);
        hr = pihtmlStyle->get_zIndex(&var);
        hr = VariantChangeType(&var, &var, 0, VT_I4);

        if (SUCCEEDED(hr))
        {
            *plZindex = var.lVal;
        }
    }

    SAFERELEASE(pihtmlStyle);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::SetZIndex
//
// Set the Z-order of the given HTML element as indicated. Return S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::SetZIndex(IHTMLElement* pihtmlElement, LONG lZindex)
{
    HRESULT hr;
    IHTMLStyle* pihtmlStyle=NULL;
    VARIANT var;

    _ASSERTE(pihtmlElement);
    
    hr = pihtmlElement->get_style(&pihtmlStyle);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pihtmlStyle);

    if (SUCCEEDED(hr) && pihtmlStyle)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = lZindex;
        hr = pihtmlStyle->put_zIndex(var);
        _ASSERTE(SUCCEEDED(hr));
    }

    SAFERELEASE(pihtmlStyle);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::AssignZIndex
//
// Set the Z-order of the given HTML element according to the index mode:
//
//      SEND_BACKWARD
//      SEND_FORWARD
//      SEND_TO_BACK
//      SEND_TO_FRONT
//      SEND_BEHIND_1D
//      SEND_FRONT_1D
//      MADE_ABSOLUTE
//
// The Z-order of the element's sibling will be adjusted as necessary
// in order to keep them unique. Returns S_OK or a Trident error.
//

HRESULT CTriEditDocument::AssignZIndex(IHTMLElement* pihtmlElement, int nZIndexMode)
{
    HRESULT hr = E_FAIL;
    IHTMLElementCollection* pihtmlCollection = NULL;
    IHTMLElement* pihtmlElementTemp = NULL;
    IHTMLElement* pihtmlElementParent = NULL;
    LONG iIndex, lLoop;
	LONG lZindex = 0;
    LONG lSourceIndexTemp, lSourceIndexElement, lSourceIndexParent;
    LONG cElements = 0;
    BOOL f2d = FALSE;
    BOOL f2dCapable = FALSE;
    BOOL fZeroIndex = FALSE;
    BOOL fSorted = FALSE;
    BOOL fZIndexNegative = FALSE; // FALSE means we need to deal with
			    	  // elements having +ve Z-INDEX and
                                  // vice versa.
    CZOrder* pczOrder=NULL;
    
    _ASSERTE(pihtmlElement);

    if ( !pihtmlElement)
    {
        return E_FAIL;
    }

    hr = pihtmlElement->get_offsetParent(&pihtmlElementParent);

    if (FAILED(hr) || !pihtmlElementParent)
    {
        return E_FAIL;
    }

    // we get the source index of the passed element's parent to
    // be used in the following for loop to identify the elements
    // belonging to this parent.
    
    hr = pihtmlElementParent->get_sourceIndex(&lSourceIndexParent);
    SAFERELEASE(pihtmlElementParent);
    _ASSERTE(SUCCEEDED(hr) && (lSourceIndexParent != -1));
    if (FAILED(hr) || (lSourceIndexParent == -1))
    {
        return E_FAIL;
    }

    // we get the source index of the element to be used in the
    // following for loop to identify the current element in
    // the collection.

    hr = pihtmlElement->get_sourceIndex(&lSourceIndexElement);

    _ASSERTE(SUCCEEDED(hr) && (lSourceIndexElement != -1));
    if (FAILED(hr) || (lSourceIndexElement == -1))
    {
        return E_FAIL;
    }

    hr = GetZIndex(pihtmlElement, &lZindex);
    _ASSERTE(SUCCEEDED(hr));

    if (FAILED(hr))
    {
        return E_FAIL;
    }

    if (lZindex < 0) 
    {
        if (nZIndexMode == SEND_BEHIND_1D)    // If Z-order is negative then
                                              // its already behind 1D.
        {                                     // hence return. 
            return S_OK;
        }
        else if(nZIndexMode != SEND_FRONT_1D) 
        {
            fZIndexNegative = TRUE; // If the passed element has negative
                                    // Z-order and if mode is anything
        }                           // other than send front then we
                                    // need to deal only with negative
                                    // elements.
    }
    else
    {
        if (nZIndexMode == SEND_FRONT_1D)     // If Z-order is positive then
                                              // its already in front of 1D
        {                                     // hence return.
            if (lZindex > 0)
                return S_OK;
        }
        else if(nZIndexMode == SEND_BEHIND_1D)
        {
            fZIndexNegative = TRUE; // If the passed element has positive
                                    // Z-order and if mode is send behind
        }                           // then we need to deal only with
                                    // negative elements.
    }

    hr = GetAllCollection(&pihtmlCollection);
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(pihtmlCollection);

    if (FAILED(hr) || !pihtmlCollection)    // If we dont have a collection
                                            // then exit
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pihtmlCollection->get_length(&cElements);  // Get number of elements
                                                    // in the collection
    _ASSERTE(SUCCEEDED(hr));
    _ASSERTE(cElements > 0);

    if ( FAILED(hr) || cElements <= 0 )     
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pczOrder = new CZOrder[cElements];      // Allocate an array of CZOrder
                                            // big enough for all

    if (!pczOrder)                          
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Now we collect all elements which are children of the parent of
    // the element passed to this function, including the passed element
    // itself.

    for (lLoop=0, iIndex=0; lLoop < cElements; lLoop++)
    {
        hr = GetCollectionElement(pihtmlCollection, lLoop, &pihtmlElementTemp); 
        _ASSERTE(SUCCEEDED(hr));
        _ASSERTE(pihtmlElementTemp);

        if (FAILED(hr) || !pihtmlElementTemp)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = Is2DCapable(pihtmlElementTemp, &f2dCapable);

        if (FAILED(hr))
            goto Cleanup;

        if (f2dCapable) 
        {
            hr = Is2DElement(pihtmlElementTemp, &f2d);

            if (FAILED(hr))
                goto Cleanup;

            if (f2d) // If the element is a 2D element
            {   
                hr = pihtmlElementTemp->get_offsetParent(&pihtmlElementParent);
                _ASSERTE(SUCCEEDED(hr));
                _ASSERTE(pihtmlElementParent);

                if (FAILED(hr) || !pihtmlElementParent)
                    goto Cleanup;

                hr = pihtmlElementParent->get_sourceIndex(&lSourceIndexTemp);
                SAFERELEASE(pihtmlElementParent);
                _ASSERTE(SUCCEEDED(hr) && lSourceIndexElement != -1);

                if (FAILED(hr) || (lSourceIndexTemp == -1))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                // Is it a child of the same parent as that of the
                // parent of the element passed to this function?

                if (lSourceIndexTemp == lSourceIndexParent) 
                {
                     hr = GetZIndex(pihtmlElementTemp, &lZindex);
                    _ASSERTE(SUCCEEDED(hr));

                    if (FAILED(hr))
                        goto Cleanup;

                    if (lZindex == 0)
                    {
                        hr = pihtmlElementTemp->get_sourceIndex(&lSourceIndexTemp);
    
                        if (FAILED(hr) || (lSourceIndexTemp == -1))
                        {
                            hr = E_FAIL;
                            goto Cleanup;
                        }

                        // General scenario is that we set fZeroIndex to
                        // TRUE when we encounter a child with no Z-order
                        // index.
                        // 
                        // So that after we have collected all the children
                        // we could assign Z-order to all the children.
                        //
                        // However, when this function is called after
                        // making a 2D element we need to ensure that we
                        // don't set fZeroIndex to TRUE when the current
                        // child is the one which is made absolute, hence
                        // the following check.
                
                        if (!((lSourceIndexTemp == lSourceIndexElement) &&
                              (nZIndexMode == MADE_ABSOLUTE)))
                            fZeroIndex = TRUE;
                    }
                                 
                    if (fZIndexNegative)
                    {
                        if (lZindex < 0) // Collect only children with
                                         // negative Z-order index.
                        {
                            CZOrder z(pihtmlElementTemp, lZindex);
                            pczOrder[iIndex++] = z;
                        }
                    }
                    else
                    {
                        if (lZindex >= 0) // collect only children with
                                          // positive or no Z-order index.
                        {
                            CZOrder z(pihtmlElementTemp, lZindex);
                            pczOrder[iIndex++] = z;
                        }
                    }

                }
                
            }

        }
        
        SAFERELEASE(pihtmlElementTemp);
    }

    // If we have at least one child with no Z-order index and if we are
    // dealing with an element with a positive Z-order index, then we
    // assign new Z-order indexes to all the children collected above.

    if (fZeroIndex && !fZIndexNegative)
    {
        LONG lZOrder = ZINDEX_BASE;

        for ( lLoop = 0; lLoop < iIndex; lLoop++, lZOrder++)
        {
            if (pczOrder[lLoop].m_zOrder != 0)
            {
                // Maintain the existing Z-order index
                pczOrder[lLoop].m_zOrder += (iIndex+ZINDEX_BASE); 
            }
            else
            {
               pczOrder[lLoop].m_zOrder += lZOrder;
            }
            
        }
        
        if (iIndex > 1) 
        {
            // Wwe have at least two children; sort by Zorder index,
            // and propagate starting from ZINDEX_BASE.
            qsort( (LPVOID)pczOrder, iIndex, sizeof(CZOrder), CompareProc);
            hr = PropagateZIndex(pczOrder, iIndex);
            _ASSERTE(SUCCEEDED(hr));

            if (FAILED(hr))
                goto Cleanup;
            fSorted = TRUE;
        }

        
    }

    // If we have at least two children and not already sorted then sort
    // by Z-order index.
    if ((iIndex > 1) && !fSorted) 
        qsort( (LPVOID)pczOrder, iIndex, sizeof(CZOrder), CompareProc);

    if (IsEqualZIndex(pczOrder, iIndex))
    {
        hr = PropagateZIndex(pczOrder, iIndex);
        if (FAILED(hr))
            goto Cleanup;
    }

    if ((nZIndexMode == MADE_ABSOLUTE) ||
        (nZIndexMode == SEND_TO_FRONT) ||
        (nZIndexMode == SEND_BEHIND_1D))
    {
        LONG lZIndex;
        LONG lmaxZIndex = pczOrder[iIndex - 1].m_zOrder;

        if (fZIndexNegative)
        {
            if (iIndex == 0) // If we have no children with negative
                             // Z-order index.
            {
                hr = SetZIndex(pihtmlElement, -ZINDEX_BASE);
                goto Cleanup;
            }
            else 
            {
                // when we are dealing with elements with negative Z-order
                // we need to ensure that the maximum Z-order index (to be
                // assigned to the current element) can never become
                // greater than or equal to 0. If so then propagate
                // the Z-order index starting from ZINDEX_BASE.

                if ((lmaxZIndex + 1) >=0) 
                {
                    hr = PropagateZIndex(pczOrder, iIndex, fZIndexNegative);

                    if (FAILED(hr))
                        goto Cleanup;
                }
    
                lmaxZIndex = pczOrder[iIndex - 1].m_zOrder;
            }
        }

        if(SUCCEEDED(hr = GetZIndex(pihtmlElement, &lZIndex)))
        {
            if(lZIndex != lmaxZIndex) 
            {
                // The current element is not the top most element
                hr = SetZIndex(pihtmlElement, lmaxZIndex+1);
                _ASSERTE(SUCCEEDED(hr));
            }
            else if(lmaxZIndex == 0) 
            {
                // if the current element has no Z-order index
                hr = SetZIndex(pihtmlElement, ZINDEX_BASE);
                _ASSERTE(SUCCEEDED(hr));
            }
        }
    }
    else if ((nZIndexMode == SEND_BACKWARD) || (nZIndexMode == SEND_FORWARD))
    {
        LONG lPrevOrNextZIndex;
        LONG lIndexBuf = iIndex;

        hr = GetZIndex(pihtmlElement, &lPrevOrNextZIndex);
        
        if (FAILED(hr))
            goto Cleanup;

        if (iIndex == 1)
            goto Cleanup;
        
        while(--iIndex>=0)
        {
            if  (pczOrder[iIndex].m_zOrder == lPrevOrNextZIndex)
            {
        
                if (nZIndexMode == SEND_BACKWARD)
                {
                    if ( (iIndex - 1) < 0)
                        // The element already has the lowest Z-order index
                        // so exit.
                        goto Cleanup;
                    else
                        iIndex--;  
                }
                else
                {
                    if ((iIndex + 1) == lIndexBuf)
                        // The element already has the highest Z-order index
                        // so exit.
                        goto Cleanup;
                    else
                        iIndex++;
                }

                hr = SetZIndex(pihtmlElement, pczOrder[iIndex].m_zOrder);
                _ASSERTE(SUCCEEDED(hr));
                    
                if (FAILED(hr))
                    goto Cleanup;
                    
                hr = SetZIndex(pczOrder[iIndex].m_pihtmlElement, lPrevOrNextZIndex);
                _ASSERTE(SUCCEEDED(hr));
                    
                if (FAILED(hr))
                    goto Cleanup;

                break;
            }

        }

    }
    else if((nZIndexMode == SEND_TO_BACK) || (nZIndexMode == SEND_FRONT_1D)) 
    {
        LONG lZIndex;
        LONG lminZIndex = pczOrder[0].m_zOrder;

        if (iIndex == 0) 
        {
            // We have no children with a positive Z-order index
            hr = SetZIndex(pihtmlElement, ZINDEX_BASE);
            goto Cleanup;
        }

        if (!fZIndexNegative)
        {
            // When we are dealing with elements with positive Z-order
            // index, we need to ensure that the minimum Z-order index
            // (to be assigned to the current element) should never become
            // less than or equal to 0. If so then propagate the
            // Z-order index starting from ZINDEX_BASE.

            if ((lminZIndex - 1) <= 0) 
            {
                hr = PropagateZIndex(pczOrder, iIndex);
    
                if (FAILED(hr))
                    goto Cleanup;
            }

            lminZIndex = pczOrder[0].m_zOrder;
        }

        if(SUCCEEDED(hr = GetZIndex(pihtmlElement, &lZIndex)))
        {
            if(lZIndex != lminZIndex)
            {
                // The current element is not the bottom most element
                hr = SetZIndex(pihtmlElement, lminZIndex - 1);
                _ASSERTE(SUCCEEDED(hr));
            }
        }
    }
       
    if (SUCCEEDED(hr))
    {
        RECT rcElement;

        if (SUCCEEDED(GetElementPosition(pihtmlElement, &rcElement)))
        {
             InflateRect(&rcElement, ELEMENT_GRAB_SIZE, ELEMENT_GRAB_SIZE);
             if( SUCCEEDED(GetTridentWindow()))
             {
                 _ASSERTE(m_hwndTrident);
                 InvalidateRect(m_hwndTrident,&rcElement, FALSE);
             }
        }
    }
       
Cleanup:

    if (pczOrder)
        delete [] pczOrder;
    SAFERELEASE(pihtmlElementTemp);
    SAFERELEASE(pihtmlElementParent);
    SAFERELEASE(pihtmlCollection);

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//
// CTriEditDocument::PropagateZIndex
//
// Set the Z-order index for each element in the given array. Return S_OK
// or a Trident error.
//

HRESULT CTriEditDocument::PropagateZIndex(CZOrder* pczOrder, LONG lZIndex, BOOL fZIndexNegative)
{
    HRESULT hr = S_OK; // init
    LONG lLoop;
    LONG lZOrder;

    // if fZIndexNegative is true means that we have a collection of
    // negative ZOrder elements and hence the initial ZOrder needs to
    // be ZINDEX_BASE + number of elments in the array.

    lZOrder = fZIndexNegative ? -(ZINDEX_BASE+lZIndex) : ZINDEX_BASE;

    for ( lLoop = 0; lLoop < lZIndex; lLoop++, lZOrder+=1)
    {
        hr = SetZIndex(pczOrder[lLoop].m_pihtmlElement, lZOrder);
        _ASSERTE(SUCCEEDED(hr));
    
        if (FAILED(hr))
            return hr;

        pczOrder[lLoop].m_zOrder = lZOrder;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\types\stub.cxx ===
#define _KERNEL32_
#include <w4warn.h>
#include <windows.h>
#include <w4warn.h>

// Hack to ensure pdlparse will build on pass0 of the NT build.
// Basically, no library can be referenced except msvcrt.lib because
// on a true clean build of NT, there are no libraries except the
// CRT's until after pass 1 is finished.

extern "C" void __stdcall Sleep(unsigned long) {}
extern "C" DWORD __stdcall GetVersion(void) { return 0; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\athena.inc ===
#  ATHENA.INC
#
#  -- root include file for the athena project.  should be !included
#     before any macros are set, etc, with the exception of ATHROOT,
#     which is required here
#
#  History:
#     12-Oct-96  Created by Erik Neuenschwander (t-erikne)

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
!if $(WIN64)
WINVER_VERSION=0x0500
!else
WINVER_VERSION=0x0400
!endif

_WIN32_IE=0x560

LINK_LIB_IGNORE=4049,4217

#ALT_PROJECT_TARGET=athena
!if "$(BUILD_PRODUCT)" == "NT"
BINPLACE_PLACEFILE=$(ATHROOT)\ntplace.txt
!endif

# Root dir for WAB include paths
WABROOT=$(ATHROOT)\wabw

# Target platform for BBT'd binaries
BBT_TARGET=win95

# $(SHELL_INC_PATH) is needed for shlguidp.h
INCLUDES=$(ATHROOT)\public\inc;$(ATHROOT)\public\inc\$(O);$(ATHROOT)\external\inc;$(ATHROOT)\inc;$(ATHROOT)\inc\$(O);$(BASEDIR)\private\inc;$(SHELL_INC_PATH)

# treat warnings as errors
MSC_WARNING_LEVEL=/W3 /WX

# NOTE: the NT_BUILD below is a temp hack to allow old headers
# to function correctly with split windows headers

C_DEFINES=$(C_DEFINES) -DSTRICT -DNT_BUILD -DNASHVILLE -DUSE_MIRRORING

# Note this is only here so we can do OE5 Beta 2 coding  using the 
# iedev IE5 Beta 1 tree.  It will be removed after IE5 forks for Beta 1
# Disable Shell Debug macros as our names collide
C_DEFINES=$(C_DEFINES) -DOE5_BETA2 -DDONT_WANT_SHELLDEBUG -DHM_GROUP_SYNCING

# !if "$(SMIME)" == "V3"
# SMIME build is default build now
C_DEFINES=$(C_DEFINES) -DSMIME_V3 -DCMS_PKCS7 -DCMSG_ENVELOPED_ENCODE_INFO_HAS_CMS_FIELDS
SMIMEV3=1
# !endif

!ifdef ATHBROWSE
BROWSER_INFO=1
BSCMAKE_FLAGS=/n /nologo
!endif

!if !$(FREEBUILD)
LINKER_NOICF=1
C_DEFINES=$(C_DEFINES) -DDEBUG
!endif

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)

# Needed to prevent spurious BUILD warnings about missing include files
CONDITIONAL_INCLUDES=\
    winwlm.h    \
    macwin32.h  \
    macpub.h    \
    macapi.h    \
    macname1.h  \
    macname2.h  \
    macocidl.h  \
    rpcerr.h    \
    rpcmac.h    \
    events.h    \
    types.h     \
    macos\resource.h    \
    macos\dialogs.h     \
    macos\events.h      \
    macos\types.h       \
    fragload.h  \
    files.h     \
    osutils.h   \
    gestaltequ.h\
    errors.h    \
    aliases.h   \
    lowmem.h    \
    mimetype.h  \
    ver.h       \
    comctlie.h  \
    regmsg16.h  \
    win16x.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\tried\triedit\zorder.h ===
//------------------------------------------------------------------------------
// zorder.h
// Copyright (c)1997-1999 Microsoft Corporation, All Rights Reserved
//
// Author
//     ThomasOl
//
// History
//      8-15-97     created     (ThomasOl)
//
//
//------------------------------------------------------------------------------

#ifndef __ZORDER_H__
#define __ZORDER_H__

enum ZIndexMode
{
    SEND_BACKWARD,
    SEND_FORWARD,
    SEND_TO_BACK,
    SEND_TO_FRONT,
    SEND_BEHIND_1D,
    SEND_FRONT_1D,
    MADE_ABSOLUTE   // we pass this mode when calling AssignZIndex during the process of making
};                  // 2D elements.

#define ZINDEX_BASE 100

class CZOrder
{
public:
    IHTMLElement* m_pihtmlElement;
    LONG          m_zOrder;

    CZOrder() : m_pihtmlElement(0), m_zOrder(0)
      {}
    CZOrder(IHTMLElement* pihtmlElement, LONG zOrder)
    {
        m_pihtmlElement = pihtmlElement;
        _ASSERTE(m_pihtmlElement);
        if (m_pihtmlElement)
            m_pihtmlElement->AddRef();
        m_zOrder = zOrder;
    }
    virtual ~CZOrder()
    {
        SAFERELEASE(m_pihtmlElement);
    }
    int operator==(const CZOrder& node) const
    {
        return (m_zOrder == node.m_zOrder);
    }
    int operator<(const CZOrder& node) const
    {
        return (m_zOrder < node.m_zOrder);
    }
    int operator>(const CZOrder& node) const
    {
        return (m_zOrder > node.m_zOrder);
    }
    int operator>=(const CZOrder& node) const
    {
        return (m_zOrder >= node.m_zOrder);
    }
    int operator<=(const CZOrder& node) const
    {
        return (m_zOrder <= node.m_zOrder);
    }
    CZOrder& operator=(const CZOrder& node)
    {
        m_pihtmlElement = node.m_pihtmlElement;
        _ASSERTE(m_pihtmlElement);
        if (m_pihtmlElement)
            m_pihtmlElement->AddRef();
        m_zOrder = node.m_zOrder;
        return *this;
    }
};

#endif //__ZORDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\types\makefile.inc ===
.SUFFIXES: .pdl .hdl .asc .nf

PERFFLAGS=

TOOLS_PLATFORM=

!if "$(PROCESSOR_ARCHITECTURE)" == "IA64"
TOOLS_PLATFORM=ia64
!else if "$(PROCESSOR_ARCHITECTURE)" == "AMD64"
TOOLS_PLATFORM=amd64
!else
TOOLS_PLATFORM=i386
!endif

!if $(IA64)
PDL_ARCH=win64
!else
PDL_ARCH=i386
!endif

PDLPARSE=$(ROOT)\btools\bin\$(TOOLS_PLATFORM)\pdlparse.exe
ASCPARSE=$(ROOT)\btools\bin\$(TOOLS_PLATFORM)\ascparse.exe
NFPARSE=$(ROOT)\btools\bin\$(TOOLS_PLATFORM)\nfparse.exe
TLDIFF=$(ROOT)\btools\bin\i386\tldiff.bat
TLVIEWER=$(ROOT)\btools\bin\i386\tlviewer.exe

{$(ROOT)\src\site\types}.pdl{$O}.pdl:
    copy $< $@

{$(ROOT)\src\other\htmldlg}.pdl{$O}.pdl:
    copy $< $@

{$(ROOT)\src\core\types}.pdl{$O}.pdl:
    copy $< $@

.pdl.hdl:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<< /Tc $< | $(PDLPARSE) <<
$(CPPXX: =
)
<<NOKEEP
- $(MAKEDIR)\$O\$(@B) $(@B).pdl $(MAKEDIR)\$O
<<NOKEEP
    -del $(MAKEDIR)\$(O)LOG

# Headers we need.

$O\versstr.h: $(ROOT)\src\f3\include\versstr.h
    copy $** $@

$O\f3ctx.h: $(ROOT)\external\inc\f3ctx.h
    copy $** $@

$O\coredisp.h: $(ROOT)\src\core\include\coredisp.h
    copy $** $@

$O\mshtmdid.h : $(DISPID_FILES)
    echo. >$O\mshtmdid.h
    !type $** >>$O\mshtmdid.h

$O\funcsig.cxx : $O\funcsig.dat
    echo Processing funcsig.dat...
    $(PDLPARSE) /G $(PDL_ARCH) $(O)

$O\mshtmtmp.idl : mshtmpre.idl $(IDL_FILES) mshtmpst.idl
    echo. >$O\mshtmtmp.idl
    !type $** >>$O\mshtmtmp.idl
    echo. >>$O\mshtmtmp.idl

$O\mshtml.idl : $O\mshtmtmp.idl $O\behavior.idl
    echo. >$O\mshtml.idl
    !type $** >>$O\mshtml.idl
    echo  } >>$O\mshtml.idl
    echo. >>$O\mshtml.idl

$(_NTBINDIR)\inetcore\published\inc\mshtml.idl : $O\mshtml.idl
!ifndef NOPASS0
    call comphtml $O\mshtml.idl $(_NTBINDIR)\inetcore\published\inc\mshtml.idl $O\mshtml_i.c $(_NTBINDIR)\inetcore\published\inc\$O\mshtml_i.c
!else
    @echo.
!endif

$O\mshtml.out: $O\mshtml.tlb
   $(TLVIEWER) $O\mshtml.tlb $O\mshtml.out
   -del /q tlviewer.o

$O\errors.out: $O\mshtml.out mshtml.ref
    !set CURFILE=$O\mshtml.out
    !set REFFILE=mshtml.ref
    !set OBJ_DIR=$(_OBJ_DIR)\$(TOOLS_PLATFORM)
    !set TLBNAME=mshtml.tlb
    !set BADTLBNAME=mshtml.bad
    !set BTOOLSBIN=$(ROOT)\btools\bin\i386
    $(TLDIFF)

$O\interned.idl : interpre.idl $O\internal.idl interpst.idl
    echo. >$O\interned.idl
    !type $** >>$O\interned.idl
    echo. >>$O\interned.idl

$(_NTBINDIR)\inetcore\published\inc\interned.idl : $O\interned.idl
!ifndef NOPASS0
    call comphtml $O\interned.idl $(_NTBINDIR)\inetcore\published\inc\interned.idl
!else
    @echo.
!endif

$(_NTBINDIR)\inetcore\published\inc\mshtmdid.h : $O\mshtmdid.h
!ifndef NOPASS0
    call comphtml $O\mshtmdid.h $(_NTBINDIR)\inetcore\published\inc\mshtmdid.h
!else
    @echo.
!endif

$O\mshtml.tlb : $O\mshtml.idl
    $(MIDL) \
    -Zp8 \
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\mshtml_p.c \
    -iid $O\mshtml_i.c \
    -dlldata $O\dlldata.c \
    -cpp_cmd $(TARGET_CPP) \
    -header $O\mshtml.h \
    -tlb $(O)\mshtml.tlb \
    $(C_DEFINES) \
    $(MIDL_OPTIMIZATION) \
    $O\mshtml.idl

!if [@mkdir $(_OBJ_DIR)]
!endif

!if [@mkdir $(O)]
!endif

$(HDL_FILES) : $(PDLPARSE)

{$(ROOT)\src\site\types}.asc{$O}.asc:
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP $< > $@

.asc.h:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    $(ASCPARSE) $< $@

$(HSC_FILES) : $(ASCPARSE)

{$(ROOT)\src\site\types}.nf{$O}.nf:
    $(C_PREPROCESSOR_NAME) $(C_DEFINES) /EP $< > $@

.nf.h:
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /EP $<
<<NOKEEP
    $(NFPARSE) $< $@

$(HNF_FILES) : $(NFPARSE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctreg\acctreg.h ===
#ifndef __ACCTREG_H
#define __ACCTREG_H

class CAcctReg :
    public IDispatch
{
public:
    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    CAcctReg();
    ~CAcctReg();

private:
    ULONG       m_cRef;
};


#endif //__ACCTREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctreg\acctreg.cpp ===
#include <windows.h>
#include <wininet.h>
#include <shlwapi.h>
#include <icwacct.h>
#include "dllmain.h"
#include "acctreg.h"

#define ARRAYSIZE(_exp_) (sizeof(_exp_) / sizeof(_exp_[0]))

CAcctReg::CAcctReg()
{
    m_cRef = 1;
    DllAddRef();
}


CAcctReg::~CAcctReg()
{
    DllRelease();
}

ULONG CAcctReg::AddRef(void)
{
    return ++m_cRef; 
}

ULONG CAcctReg::Release(void)
{ 
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CAcctReg::QueryInterface(REFIID riid, void **ppvObject)
{
    if(!ppvObject)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IDispatch))
        *ppvObject = (IDispatch *)this;
    else if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CAcctReg::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

HRESULT CAcctReg::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

HRESULT CAcctReg::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    if (cNames == 1 && lstrcmpW(rgszNames[0], L"register") == 0)
        {
        rgdispid[0] = 666;  
        return S_OK;
        }

    return E_NOTIMPL;
}

HRESULT RegisterAccounts(LPSTR pszFile)
    {
    HRESULT hr;
    HINSTANCE hinst;
    HKEY hkey;
    char szDll[MAX_PATH], szExpand[MAX_PATH];
    LPSTR psz;
    DWORD cb, type;
    PFNCREATEACCOUNTSFROMFILE pfn;

    hr = E_FAIL;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Internet Account Manager", 0, KEY_QUERY_VALUE, &hkey))
        {
        cb = sizeof(szDll);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, "DllPath", NULL, &type, (LPBYTE)szDll, &cb))
            {
            if (type == REG_EXPAND_SZ)
                {
                ExpandEnvironmentStrings(szDll, szExpand, ARRAYSIZE(szExpand));
                psz = szExpand;
                }
            else
                {
                psz = szDll;
                }

            hinst = LoadLibrary(psz);
            if (hinst != NULL)
                {
                pfn = (PFNCREATEACCOUNTSFROMFILE)GetProcAddress(hinst, "CreateAccountsFromFile");
                if (pfn != NULL)
                    {
                    hr = pfn(pszFile, 0);
                    }

                FreeLibrary(hinst);
                }
            }

        RegCloseKey(hkey);
        }

    return(hr);
    }

#define CBBUFFER 1024

BOOL CreateLocalFile(HINTERNET hfile, LPCSTR pszFile)
    {
    BOOL fRet;
    HANDLE hfileLocal;
    LPBYTE pb;
    DWORD dw, dwT;

    fRet = FALSE;

    pb = (LPBYTE)malloc(CBBUFFER);
    if (pb != NULL)
        {
        hfileLocal = CreateFile(pszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
        if (hfileLocal != INVALID_HANDLE_VALUE)
            {
            while (InternetReadFile(hfile, pb, CBBUFFER, &dw))
                {
                if (dw == 0)
                    {
                    fRet = TRUE;
                    break;
                    }

                if (!WriteFile(hfileLocal, pb, dw, &dwT, NULL))
                    break;
                }

            CloseHandle(hfileLocal);

            if (!fRet)
                DeleteFile(pszFile);
            }

        free(pb);
        }

    return(fRet);
    }

HRESULT CAcctReg::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr;
    HINTERNET hnet, hfile;
    LPSTR pszSrc, pszFile;
    char szPath[MAX_PATH], szDest[MAX_PATH];
    int cch;
    DWORD dw;

    if (dispidMember == 666 &&
        pdispparams->cArgs == 1 &&
        pdispparams->rgvarg[0].vt == VT_BSTR &&
        pdispparams->rgvarg[0].bstrVal)
        {
        hr = E_FAIL;

        cch = WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[0].bstrVal, -1, NULL, 0, NULL, NULL);
        cch++;
        pszSrc = (LPSTR)malloc(cch);
        if (pszSrc != NULL)
            {
            WideCharToMultiByte(CP_ACP, 0, pdispparams->rgvarg[0].bstrVal, -1, pszSrc, cch, NULL, NULL);

            if (GetTempPath(sizeof(szPath), szPath) &&
                GetTempFileName(szPath, "ins", 0, szDest) != 0)
                {
                hnet = InternetOpen("Outlook Express", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
                if (hnet != NULL)
                    {
                    hfile = InternetOpenUrl(hnet, pszSrc, NULL, 0, INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE, 0);
                    if (hfile != NULL)
                        {
                        if (CreateLocalFile(hfile, szDest))
                            {
                            hr = RegisterAccounts(szDest);
                            DeleteFile(szDest);
                            }

                        InternetCloseHandle(hfile);
                        }

                    InternetCloseHandle(hnet);
                    }
                }

            free(pszSrc);
            }

        return(S_OK);
        }

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctreg\dllmain.h ===
#ifndef __DLLMAIN_H
#define __DLLMAIN_H

extern ULONG       g_cRefDll;
extern HINSTANCE   g_hInst;

ULONG DllAddRef(void);
ULONG DllRelease(void);

#endif //__DLLMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctreg\guids.h ===
#ifndef __GUIDS_H
#define __GUIDS_H

// {FBABBCE1-DEFB-11d1-AAA0-006097D474C4}
DEFINE_GUID(CLSID_AcctReg, 0xfbabbce1, 0xdefb, 0x11d1, 0xaa, 0xa0, 0x0, 0x60, 0x97, 0xd4, 0x74, 0xc4);

#endif //__GUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctreg\dllmain.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <advpub.h>
#include "dllmain.h"
#include "acctreg.h"

CRITICAL_SECTION    g_csDllMain={0};

ULONG               g_cRefDll=0;
HINSTANCE           g_hInst=NULL;


void InitGlobalVars(void)
{
    InitializeCriticalSection(&g_csDllMain);
}

void FreeGlobalVars(void)
{
    DeleteCriticalSection(&g_csDllMain);
}

 
// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Handle Attach - detach reason
    switch (dwReason)                 
    {
    case DLL_PROCESS_ATTACH:
	    // Set global instance handle
	    g_hInst = hInst;

		// Initialize Global Variables
		InitGlobalVars();

        // we don't care about thread-attach notifications, so
        // diable them, This is mondo-more efficient for creating
        // threads
        DisableThreadLibraryCalls(hInst);
        break;

    case DLL_PROCESS_DETACH:
		FreeGlobalVars();
	    break;
    }
    return TRUE;
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    return (ULONG)InterlockedIncrement((LPLONG)&g_cRefDll);
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    return (ULONG)InterlockedDecrement((LPLONG)&g_cRefDll);
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// 
// Ole will hit this now and again to see if it can free up our library
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;
    
    EnterCriticalSection(&g_csDllMain);
    hr = g_cRefDll ? S_FALSE : S_OK;
    LeaveCriticalSection(&g_csDllMain);
    return hr;
}

// --------------------------------------------------------------------------------
// Override new operator
// --------------------------------------------------------------------------------
void * __cdecl operator new(UINT cb)
{
    LPVOID  lpv;

    lpv = malloc(cb);

    return lpv;
}

// --------------------------------------------------------------------------------
// Override delete operator
// --------------------------------------------------------------------------------
void __cdecl operator delete(LPVOID pv)
{
    free(pv);
}

HRESULT CallRegInstall(HINSTANCE hInst, LPCSTR pszSection)
{    
    HRESULT     hr = E_FAIL;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    char        szDll[MAX_PATH];
    int         cch;
    STRENTRY    seReg[2];
    STRTABLE    stReg;
    OSVERSIONINFO verinfo;        // Version Check

    hAdvPack = LoadLibraryA("advpack.dll");
    if (NULL == hAdvPack)
        return(E_FAIL);

    // Get our location
    GetModuleFileName(hInst, szDll, sizeof(szDll));

    // Get Proc Address for registration util
    pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
    if (NULL == pfnri)
        goto exit;

    // Setup special registration stuff
    // Do this instead of relying on _SYS_MOD_PATH which loses spaces under '95
    stReg.cEntries = 0;
    seReg[stReg.cEntries].pszName = "SYS_MOD_PATH";
    seReg[stReg.cEntries].pszValue = szDll;
    stReg.cEntries++;    
    stReg.pse = seReg;

    // Call the self-reg routine
    hr = pfnri(hInst, pszSection, &stReg);

exit:
    // Cleanup
    FreeLibrary(hAdvPack);

    return(hr);
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    // Register my self
    hr = CallRegInstall(g_hInst, "Reg");

    return(hr);
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(g_hInst, "UnReg");

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctreg\factory.cpp ===
// --------------------------------------------------------------------------------
// Factory.cpp
// --------------------------------------------------------------------------------
#include <windows.h>
#include <ole2.h>
#include "dllmain.h"
#include "acctreg.h"
#include "guids.h"

////////////////////////////////////////////////////////////////////////
//
//  IClassFactory implementation
//
////////////////////////////////////////////////////////////////////////
class CClassFactory : public IClassFactory
{
public:
    CClassFactory(REFCLSID clsid) : m_cRef(1), m_clsid(clsid) { DllAddRef(); }
    ~CClassFactory() { DllRelease(); }

    // IUnknown
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
    ULONG   STDMETHODCALLTYPE AddRef(void);
    ULONG   STDMETHODCALLTYPE Release(void);

    // IClassFactory
    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *punkOuter, REFIID riid, LPVOID *ppv);
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);

private:
    UINT    m_cRef;
    CLSID   m_clsid;
};


HRESULT STDMETHODCALLTYPE CClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
    if (!ppvObject)
        return E_INVALIDARG;

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
        {
        *ppvObject = (IClassFactory *)this;
        }
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE CClassFactory::AddRef(void)
{
    return ++m_cRef;
}

ULONG STDMETHODCALLTYPE CClassFactory::Release(void)
{
    if (--m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT STDMETHODCALLTYPE CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, LPVOID *ppv)
{
    HRESULT     hr;

    if (!ppv)
        return E_INVALIDARG;

    *ppv = NULL;  // assume error

    if (punkOuter)
        return CLASS_E_NOAGGREGATION;       // don't support aggregation


    if (IsEqualCLSID(m_clsid, CLSID_AcctReg))
        {
        // make sure we're the IMsgBox class factory
        CAcctReg *pAcctReg;

        if (pAcctReg = new CAcctReg())
            {
            hr = pAcctReg->QueryInterface(riid, ppv);
            // Note that the Release member will free the object, if QueryInterface
            // failed.
            pAcctReg->Release();
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }
    else
        {
        hr = E_NOINTERFACE;
        }

    return hr;
}

HRESULT STDMETHODCALLTYPE CClassFactory::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}




// --------------------------------------------------------------------------------
// DllGetClassObject
// --------------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    HRESULT     hr;

    if (ppv == NULL)
        return E_INVALIDARG;

    if (IsEqualCLSID(rclsid, CLSID_AcctReg))
        {
        // caller want the class factory that can handout msgbox
        // objects...
        CClassFactory *pcf = new CClassFactory(rclsid);
        
        if (pcf)
            {
            hr = pcf->QueryInterface(riid, ppv);
            pcf->Release();
            }
        else
            hr = E_OUTOFMEMORY;    
        }
    else
        hr = CLASS_E_CLASSNOTAVAILABLE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctreg\initguid.cpp ===
#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#include "guids.h"

// we need to get the variables for the CLSID_ and IID_ compiled into our datasegment.
// we include initguid.h which defines a preprocessor variable which when it loads imsgbox.h
// will unwrap the DEFINE_GUID macro such that the variables are declared.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctres\makefile.inc ===
ATHENA_RC_DEPENDS = server.dlg	    \
		    wizard.dlg	    \
		    folders.bmp     \
		    globe.bmp	    \
		    icw.bmp	    \
		    wizard.bmp	    \
		    ldap2.ico	    \
		    mailsvr.ico     \
		    ..\msoeacct\resource.h

$O\msoeres.res : $(ATHENA_RC_DEPENDS)

.SUFFIXES: .htx

frntpage.htm : dlg.sed
        -del *.htm
        sed -f dlg.sed $(@:.htm=.htx) >$@

.htx.htm:
        sed -f dlg.sed $** >$@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\acctres\res.inc ===
ATHROOT=..
R=$(ATHROOT)\mailnews
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

USE_LIBCMT=1
NO_NTDLL=1

UMTYPE=windows

C_DEFINES=$(C_DEFINES) -DDOCOBJ -DDBCS_DIVIDE -DBCC -D_MSOEAPI_ -D_WINDLL
WIN32_IE_VERSION=0x0500

INCLUDES=\
    $(BASEDIR)\private\windows\inc; \
    $(ATHROOT)\msoeres; \
    $(R)\inc; \
    $(R)\common; \
    $(R)\shell; \
    $(R)\objectdb; \
    $(R)\mail; \
    $(R)\news; \
    $(R)\rules; \
    $(R)\store; \
    $(R)\spooler; \
    $(R)\view; \
    $(R)\imap; \
    $(R)\bactrl; \
    $(R)\extinc; \
    $(ATHROOT)\inetcomm\mimeole; \
    $(ATHROOT)\common; \
    $(BASEDIR)\public\sdk\inc\atl21; \
    $(INCLUDES)

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN=1

# NOTE: star below is replaced with platform by platform-specific .inc
# file in %_NTROOT%\public\oak\bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\acemail.cpp ===
/*****************************************************************************\
    FILE: ACEmail.cpp

    DESCRIPTION:
        This file implements AutoComplete for Email Addresses.

    BryanSt 3/1/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#include "MailBox.h"

#define MAX_EMAIL_MRU_SIZE          100



class CACLEmail
                : public IEnumString
                , public IACList
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt) {return E_NOTIMPL;}
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum) {return E_NOTIMPL;}

    // *** IACList ***
    virtual STDMETHODIMP Expand(LPCOLESTR pszExpand) {return E_NOTIMPL;}

private:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLEmail(LPCTSTR pszMRURegKey);
    ~CACLEmail(void);

    HRESULT AddEmail(IN LPCWSTR pszEmailAddress);

    // Instance creator
    friend HRESULT CACLEmail_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj);
    friend HRESULT AddEmailToAutoComplete(IN LPCWSTR pszEmailAddress);

    // Private variables
    DWORD           m_cRef;      // COM reference count
    DWORD           m_nMRUIndex; // Current Index into MRU

    DWORD           m_dwRunMRUIndex; // Index into the Run MRU.
    DWORD           m_dwRunMRUSize;
    HANDLE          m_hMRURun;
};




//===========================
// *** IEnumString Interface ***
//===========================
HRESULT CACLEmail::Reset(void)
{
    HRESULT hr = S_OK;
    m_nMRUIndex = 0;
    m_dwRunMRUIndex = 0;

    return hr;
}


HRESULT CACLEmail::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    TCHAR szMRUEntry[MAX_URL_STRING+1];
    LPWSTR pwzMRUEntry = NULL;

    *pceltFetched = 0;
    if (!celt)
        return S_OK;

    if (!rgelt)
        return S_FALSE;

    *rgelt = 0;
    if (m_dwRunMRUIndex >= m_dwRunMRUSize)
        hr = S_FALSE;  // No more.
    else
    {
        if (m_hMRURun && EnumMRUList(m_hMRURun, m_dwRunMRUIndex++, szMRUEntry, ARRAYSIZE(szMRUEntry)) > 0)
        {
            hr = S_OK;
        }
        else
            hr = S_FALSE;
    }

    if (S_OK == hr)
    {
        DWORD cchSize = lstrlen(szMRUEntry)+1;
        //
        // Allocate a return buffer (caller will free it).
        //
        pwzMRUEntry = (LPOLESTR)CoTaskMemAlloc(cchSize * sizeof(pwzMRUEntry[0]));
        if (pwzMRUEntry)
        {
            //
            // Convert the display name into an OLESTR.
            //
#ifdef UNICODE
            StrCpyN(pwzMRUEntry, szMRUEntry, cchSize);
#else   // ANSI
            MultiByteToWideChar(CP_ACP, 0, szMRUEntry, -1, pwzMRUEntry, cchSize);
#endif  // ANSI
            rgelt[0] = pwzMRUEntry;
            *pceltFetched = 1;
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
STDMETHODIMP CACLEmail::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CACLEmail, IEnumString),
        QITABENT(CACLEmail, IACList),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}                                             


ULONG CACLEmail::AddRef(void)
{
    m_cRef++;
    return m_cRef;
}


ULONG CACLEmail::Release(void)
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef > 0)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}



//===========================
// *** Class Methods ***
//===========================
HRESULT CACLEmail::AddEmail(IN LPCWSTR pszEmailAddress)
{
    HRESULT hr = S_OK;

    if (-1 == AddMRUStringW(m_hMRURun, pszEmailAddress))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


CACLEmail::CACLEmail(LPCTSTR pszMRURegKey)
{
    DllAddRef();

    // Require object to be in heap and Zero-Inited
    ASSERT(!m_nMRUIndex);
    ASSERT(!m_dwRunMRUIndex);
    ASSERT(!m_hMRURun);

    MRUINFO mi =  {
        sizeof(MRUINFO),
        MAX_EMAIL_MRU_SIZE,
        MRU_CACHEWRITE,
        HKEY_CURRENT_USER,
        SZ_REGKEY_EMAIL_MRU,
        NULL        // NOTE: use default string compare
                    // since this is a GLOBAL MRU
    };

    m_hMRURun = CreateMRUList(&mi);
    if (m_hMRURun)
        m_dwRunMRUSize = EnumMRUList(m_hMRURun, -1, NULL, 0);

    m_cRef = 1;
}


CACLEmail::~CACLEmail()
{
    if (m_hMRURun)
        FreeMRUList(m_hMRURun);

    DllRelease();
}





/****************************************************\
    DESCRIPTION:
        This function create an instance of the AutoComplete
    List "MRU".  This will point to either the MRU for
    a browser or for a non-browser (Start->Run or
    the AddressBar in the Taskbar or floating) depending
    on the pszMRU parameter.
\****************************************************/
HRESULT CACLEmail_CreateInstance(IN IUnknown * punkOuter, IN REFIID riid, OUT void ** ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    CACLEmail *paclSF = new CACLEmail(NULL);
    if (paclSF)
    {
        hr = paclSF->QueryInterface(riid, ppvObj);
        paclSF->Release();
    }
    else
    {
        *ppvObj = NULL;
    }

    return hr;
}


HRESULT AddEmailToAutoComplete(IN LPCWSTR pszEmailAddress)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    CACLEmail *paclSF = new CACLEmail(NULL);
    if (paclSF)
    {
        hr = paclSF->AddEmail(pszEmailAddress);
        paclSF->Release();
    }

    return hr;
}



#define SZ_REGKEY_AUTOCOMPLETE_TAB          TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\AutoComplete")
#define SZ_REGVALUE_AUTOCOMPLETE_TAB        TEXT("Always Use Tab")
#define BOOL_NOT_SET                        0x00000005
DWORD _UpdateAutoCompleteFlags(void)
{
    DWORD dwACOptions = 0;

    if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
    {
        dwACOptions |= ACO_AUTOAPPEND;
    }

    if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
    {
        dwACOptions |= ACO_AUTOSUGGEST;
    }

    // Windows uses the TAB key to move between controls in a dialog.  UNIX and other
    // operating systems that use AutoComplete have traditionally used the TAB key to
    // iterate thru the AutoComplete possibilities.  We need to default to disable the
    // TAB key (ACO_USETAB) unless the caller specifically wants it.  We will also
    // turn it on 
    static BOOL s_fAlwaysUseTab = BOOL_NOT_SET;
    if (BOOL_NOT_SET == s_fAlwaysUseTab)
        s_fAlwaysUseTab = SHRegGetBoolUSValue(SZ_REGKEY_AUTOCOMPLETE_TAB, SZ_REGVALUE_AUTOCOMPLETE_TAB, FALSE, FALSE);
        
    if (s_fAlwaysUseTab)
        dwACOptions |= ACO_USETAB;

    return dwACOptions;
}


// TODO: Move this functionality to SHAutoComplete when it's ready.
STDAPI AddEmailAutoComplete(HWND hwndEdit)
{
    IUnknown * punkACL = NULL;
    DWORD dwACOptions = _UpdateAutoCompleteFlags();
    HRESULT hr = CACLEmail_CreateInstance(NULL, IID_PPV_ARG(IUnknown, &punkACL));

    if (punkACL)    // May fail on low memory.
    {
        IAutoComplete2 * pac;

        // Create the AutoComplete Object
        hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IAutoComplete2, &pac));
        if (SUCCEEDED(hr))   // May fail because of out of memory
        {
            if (SHPinDllOfCLSID(&CLSID_ACListISF) &&
                SHPinDllOfCLSID(&CLSID_AutoComplete))
            {
                hr = pac->Init(hwndEdit, punkACL, NULL, NULL);
                pac->SetOptions(dwACOptions);
            }
            else
            {
                hr = E_FAIL;
            }
            pac->Release();
        }

        punkACL->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\autodiscover.cpp ===
/*****************************************************************************\
    FILE: AutoDiscover.cpp

    DESCRIPTION:
        This is the Autmation Object to AutoDiscover account information.

    BryanSt 10/3/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "AutoDiscover.h"



class CAccountDiscovery : public CImpIDispatch
                        , public CAccountDiscoveryBase
                        , public IAccountDiscovery
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CAccountDiscoveryBase::AddRef();}
    virtual STDMETHODIMP_(ULONG) Release(void) {return CAccountDiscoveryBase::Release();}

    // *** IAccountDiscovery ***
    virtual STDMETHODIMP DiscoverNow(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse);
    virtual STDMETHODIMP WorkAsync(IN HWND hwnd, IN UINT wMsg) {return _WorkAsync(hwnd, wMsg);}

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

protected:
    CAccountDiscovery();
    virtual ~CAccountDiscovery(void);

    // Friend Functions
    friend HRESULT CAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
};



//===========================
// *** IAccountDiscovery Interface ***
//===========================
HRESULT CAccountDiscovery::DiscoverNow(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse)
{
    return CAccountDiscoveryBase::_InternalDiscoverNow(bstrEmailAddress, dwFlags, bstrXMLRequest, ppXMLResponse);
}



HRESULT CAccountDiscovery::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAccountDiscovery, IAccountDiscovery),
        QITABENT(CAccountDiscovery, IDispatch),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
    {
        hr = CAccountDiscoveryBase::QueryInterface(riid, ppvObj);
    }

    return hr;
}


CAccountDiscovery::CAccountDiscovery() : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IAccountDiscovery)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
}


CAccountDiscovery::~CAccountDiscovery()
{
    DllRelease();
}


HRESULT CAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;
    if (NULL == punkOuter)
    {
        CAccountDiscovery * pmf = new CAccountDiscovery();
        if (pmf)
        {
            hr = pmf->QueryInterface(riid, ppvObj);
            pmf->Release();
        }
        else
        {
            *ppvObj = NULL;
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\autodiscbase.cpp ===
/*****************************************************************************\
    FILE: AutoDiscBase.cpp

    DESCRIPTION:
        This is the Autmation Object to AutoDiscover account information.

    BryanSt 10/3/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include <crypto\md5.h>

#include "AutoDiscover.h"
#include "INStoXML.h"


//#define SZ_WININET_AGENT_AUTO_DISCOVER      TEXT("Microsoft(r) Windows(tm) Account AutoDiscovery Agent")
#define SZ_WININET_AGENT_AUTO_DISCOVER      TEXT("Mozilla/4.0 (compatible; MSIE.5.01; Windows.NT.5.0)")

// BUGBUG: Ditch default.asp
#define SZ_ADSERVER_XMLFILE                    "/AutoDiscover/default.xml"

#define SZ_PATH_AUTODISCOVERY       L"AutoDiscovery"
#define SZ_FILEEXTENSION            L".xml"
#define SZ_TEMPEXTENSION            L".tmp"


// this is how long we wait for the UI thread to create the progress hwnd before giving up
#define WAIT_AUTODISCOVERY_STARTUP_HWND 10*1000 // ten seconds

// The FILETIME structure is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601
#define SECONDS_IN_ONE_DAY         (60/*seconds*/ * 60/*minutes*/ * 24/*hrs*/)                                    

//===========================
// *** Class Internals & Helpers ***
//===========================

HRESULT GetTempPathHr(IN DWORD cchSize, IN LPTSTR pszPath)
{
    HRESULT hr = S_OK;
    DWORD cchSizeNeeded = GetTempPath(cchSize, pszPath);

    if ((0 == cchSizeNeeded) || (cchSizeNeeded > cchSize))
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT GetTempFileNameHr(IN LPCTSTR lpPathName, IN LPCTSTR lpPrefixString, IN UINT uUnique, IN LPTSTR lpTempFileName)
{
    if (0 == GetTempFileName(lpPathName, lpPrefixString, uUnique, lpTempFileName))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}


HRESULT CreateXMLTempFile(IN BSTR bstrXML, IN LPTSTR pszPath, IN DWORD cchSize)
{
    TCHAR szTemp[MAX_PATH];
    HRESULT hr = GetTempPathHr(ARRAYSIZE(szTemp), szTemp);

    AssertMsg((MAX_PATH <= cchSize), "You need to be at least MAX_PATH.  Required by GetTempFileName()");
    if (SUCCEEDED(hr))
    {
        hr = GetTempFileNameHr(szTemp, TEXT("AD_"), 0, pszPath);
        if (SUCCEEDED(hr))
        {
            HANDLE hFile;

            hr = CreateFileHrWrap(pszPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &hFile);
            if (SUCCEEDED(hr))
            {
                LPSTR pszAnsiXML = AllocStringFromBStr(bstrXML);
                if (pszAnsiXML)
                {
                    DWORD cchWritten;

                    hr = WriteFileWrap(hFile, pszAnsiXML, (lstrlenA(pszAnsiXML) + 1), &cchWritten, NULL);
                    LocalFree(pszAnsiXML);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                CloseHandle(hFile);
            }

            if (FAILED(hr))
            {
                DeleteFile(pszPath);
            }
        }
    }

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:
        This function will see if pbstrXML is valid AutoDiscovery XML or is 
    in the .INS/.ISP format that can be converted to valid XML.  It will then look
    for a redirect URL and return on if one exists.
\*****************************************************************************/
HRESULT CAccountDiscoveryBase::_VerifyValidXMLResponse(IN BSTR * pbstrXML, IN LPWSTR pszRedirURL, IN DWORD cchSize)
{
    IXMLDOMDocument * pXMLDOMDoc;
    bool fConverted = false;
    HRESULT hr = XMLDOMFromBStr(*pbstrXML, &pXMLDOMDoc);
    TCHAR szPath[MAX_PATH];

    pszRedirURL[0] = 0;
    if (FAILED(hr))
    {
        // It may have failed if it was an .INS or .ISP formatted
        // file.  Since we need to be compatible with these
        // file formats, check for it and convert it if it
        // is in that format.
        hr = CreateXMLTempFile(*pbstrXML, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            fConverted = true;
            if (IsINSFile(szPath))
            {
                hr = ConvertINSToXML(szPath);
                if (SUCCEEDED(hr))
                {
                    hr = XMLDOMFromFile(szPath, &pXMLDOMDoc);
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        IXMLDOMElement * pXMLElementMessage = NULL;

        hr = pXMLDOMDoc->get_documentElement(&pXMLElementMessage);
        if (S_FALSE == hr)
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        else if (SUCCEEDED(hr))
        {
            // This is only valid XML if the root tag is "AUTODISCOVERY".
            // The case is not important.
            hr = XMLElem_VerifyTagName(pXMLElementMessage, SZ_XMLELEMENT_AUTODISCOVERY);
            if (SUCCEEDED(hr))
            {
                // Now we are in search for a redirect URL.
                IXMLDOMNode * pXMLReponse;

                // Enter the <RESPONSE> tag.
                if (SUCCEEDED(XMLNode_GetChildTag(pXMLElementMessage, SZ_XMLELEMENT_RESPONSE, &pXMLReponse)))
                {
                    IXMLDOMElement * pXMLElementMessage;

                    if (SUCCEEDED(pXMLReponse->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElementMessage))))
                    {
                        IXMLDOMNodeList * pNodeListAccounts;

                        // Iterate thru the list of <ACCOUNT> tags...
                        if (SUCCEEDED(XMLElem_GetElementsByTagName(pXMLElementMessage, SZ_XMLELEMENT_ACCOUNT, &pNodeListAccounts)))
                        {
                            DWORD dwIndex = 0;
                            IXMLDOMNode * pXMLNodeAccount = NULL;

                            // We are going to look thru each one for one of them with <TYPE>email</TYPE>
                            while (S_OK == XMLNodeList_GetChild(pNodeListAccounts, dwIndex, &pXMLNodeAccount))
                            {
                                // FUTURE: We could support redirects or error messages here depending on
                                //       <ACTION> redirect | message </ACTION>
                                if (XML_IsChildTagTextEqual(pXMLNodeAccount, SZ_XMLELEMENT_TYPE, SZ_XMLTEXT_EMAIL) &&
                                    XML_IsChildTagTextEqual(pXMLNodeAccount, SZ_XMLELEMENT_ACTION, SZ_XMLTEXT_REDIRECT))
                                {
                                    CComBSTR bstrRedirURL;

                                    // This file may or may not settings to contact the server.  However in either case
                                    // it may contain an INFOURL tag.  If it does, then the URL in side will point to a 
                                    // web page.
                                    // <INFOURL> xxx </INFOURL>
                                    if (SUCCEEDED(XMLNode_GetChildTagTextValue(pXMLNodeAccount, SZ_XMLELEMENT_REDIRURL, &bstrRedirURL)))
                                    {
                                        StrCpyNW(pszRedirURL, bstrRedirURL, cchSize);
                                        break;
                                    }
                                }

                                // No, so keep looking.
                                ATOMICRELEASE(pXMLNodeAccount);
                                dwIndex++;
                            }

                            ATOMICRELEASE(pXMLNodeAccount);
                            pNodeListAccounts->Release();
                        }

                        pXMLElementMessage->Release();
                    }

                    pXMLReponse->Release();
                }
            }

            pXMLElementMessage->Release();
        }

        if (true == fConverted)
        {
            if (SUCCEEDED(hr))
            {
                // It only succeeded after the conversion, so we need to move the
                // XML from the temp file to pbstrXML.
                SysFreeString(*pbstrXML);
                *pbstrXML = NULL;

                hr = XMLBStrFromDOM(pXMLDOMDoc, pbstrXML);
            }
        }

        pXMLDOMDoc->Release();
    }

    if (true == fConverted)
    {
        DeleteFile(szPath);
    }

    return hr;
}


typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
static const char c_szShlwapiDll[] = "shlwapi.dll";
static const char c_szDllGetVersion[] = "DllGetVersion";

HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT)
{
    char szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibraryA(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, MAKEINTRESOURCEA(377));
                    if (pfn != NULL)
                        hInst = pfn(szDllName, hInstCaller, (ML_NO_CROSSCODEPAGE));
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if ((NULL == hInst) && (GetModuleFileNameA(hInstCaller, szPath, ARRAYSIZE(szPath))))
    {
        PathRemoveFileSpecA(szPath);
        iEnd = lstrlenA(szPath);
        szPath[iEnd++] = '\\';
        StrCpyNA(&szPath[iEnd], szDllName, ARRAYSIZE(szPath)-iEnd);
        hInst = LoadLibraryA(szPath);
    }

    return hInst;
}


#define SZ_DLL_OE_ACCTRES_DLL           "acctres.dll"
HRESULT CAccountDiscoveryBase::_SendStatusMessage(UINT nStringID, LPCWSTR pwzArg)
{
    HRESULT hr = S_OK;

    if (m_hwndAsync && IsWindow(m_hwndAsync))
    {
        WCHAR szMessage[MAX_URL_STRING*3];
        WCHAR szTemplate[MAX_URL_STRING*3];

        // Our DLL has these message.
        LoadString(HINST_THISDLL, nStringID, szTemplate, ARRAYSIZE(szTemplate));

        HINSTANCE hInstOE = LoadLangDll(GetModuleHandleA(NULL), SZ_DLL_OE_ACCTRES_DLL, IsOSNT());
        if (hInstOE)
        {
            // We prefer to get the string from OE because it will be localized based on the installed
            // language.
            LoadString(hInstOE, nStringID, szTemplate, ARRAYSIZE(szTemplate));
            FreeLibrary(hInstOE);
        }

        if (pwzArg)
        {
            wnsprintfW(szMessage, ARRAYSIZE(szMessage), szTemplate, pwzArg);
        }
        else
        {
            StrCpyN(szMessage, szTemplate, ARRAYSIZE(szMessage));
        }

        LPWSTR pszString = (LPWSTR) LocalAlloc(LPTR, (lstrlenW(szMessage) + 1) * sizeof(szMessage[0]));
        if (pszString)
        {
            StrCpy(pszString, szMessage);
            PostMessage(m_hwndAsync, (m_wMsgAsync + 1), (WPARAM)pszString, (LPARAM)0);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_UrlToComponents(IN LPCWSTR pszURL, IN BOOL * pfHTTPS, IN LPWSTR pszDomain, IN DWORD cchSize, IN LPSTR pszURLPath, IN DWORD cchSizeURLPath)
{
    HRESULT hr = S_OK;
    WCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    WCHAR szURLPath[INTERNET_MAX_PATH_LENGTH];
    URL_COMPONENTS urlComponents = {0};

    urlComponents.dwStructSize = sizeof(urlComponents);
    urlComponents.lpszScheme = szScheme;
    urlComponents.dwSchemeLength = ARRAYSIZE(szScheme);
    urlComponents.lpszHostName = pszDomain;
    urlComponents.dwHostNameLength = cchSize;
    urlComponents.lpszUrlPath = szURLPath;
    urlComponents.dwUrlPathLength = ARRAYSIZE(szURLPath);

    *pfHTTPS = ((INTERNET_SCHEME_HTTPS == urlComponents.nScheme) ? TRUE : FALSE);
    if (!InternetCrackUrlW(pszURL, 0, 0, &urlComponents))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        SHUnicodeToAnsi(szURLPath, pszURLPath, cchSizeURLPath);
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_GetInfoFromDomain(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BOOL fHTTPS, IN BOOL fPost, IN LPCSTR pszURLPath, OUT BSTR * pbstrXML)
{
    HRESULT hr = E_OUTOFMEMORY;
    DWORD cbToSend = (lstrlenW(bstrXMLRequest));
    LPSTR pszPostData = (LPSTR) LocalAlloc(LPTR, (cbToSend + 1) * sizeof(bstrXMLRequest[0]));
    TCHAR szRedirectURL[MAX_URL_STRING];

    szRedirectURL[0] = 0;
    if (pszPostData)
    {
        HINTERNET hInternetHTTPConnect = NULL;

        SHUnicodeToAnsi(bstrXMLRequest, pszPostData, (cbToSend + 1));
        _SendStatusMessage(IDS_STATUS_CONNECTING_TO, pwzDomain);

        // We may want to use INTERNET_FLAG_KEEP_CONNECTION.
        hr = InternetConnectWrap(m_hInternetSession, FALSE, pwzDomain, (fHTTPS ? INTERNET_DEFAULT_HTTPS_PORT : INTERNET_DEFAULT_HTTP_PORT),
                            NULL, NULL, INTERNET_SERVICE_HTTP, 0, NULL, &hInternetHTTPConnect);
        if (SUCCEEDED(hr))
        {
            HINTERNET hInternetHTTPRequest = NULL;
            DWORD cbBytesRead;

            // NOTE: The web server may want to redirect to an https URL for additional security.
            //       We need to pass the INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS to HttpOpenRequest
            //       or HttpSendRequest() will fail with ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR

            // NOTE: We may need to split the URL into lpszReferer + lpszObjectName.
            hr = HttpOpenRequestWrap(hInternetHTTPConnect, (fPost ? SZ_HTTP_VERB_POST : NULL), pszURLPath, HTTP_VERSIONA, 
                        /*pszReferer*/ NULL, NULL, INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS, NULL, &cbBytesRead, &hInternetHTTPRequest);
            if (SUCCEEDED(hr))
            {
                hr = HttpSendRequestWrap(hInternetHTTPRequest, NULL,  0, (fPost ? pszPostData : NULL), (fPost ? cbToSend : 0));
                if (SUCCEEDED(hr))
                {
                    _SendStatusMessage(IDS_STATUS_DOWNLOADING, pwzDomain);
                    hr = InternetReadIntoBSTR(hInternetHTTPRequest, pbstrXML);
                    if (SUCCEEDED(hr))
                    {
                        hr = _VerifyValidXMLResponse(pbstrXML, szRedirectURL, ARRAYSIZE(szRedirectURL));
                        if (FAILED(hr))
                        {
                            SysFreeString(*pbstrXML);
                            *pbstrXML = NULL;
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = InternetCloseHandleWrap(hInternetHTTPRequest);
                    }
                    else
                    {
                        InternetCloseHandleWrap(hInternetHTTPRequest);
                    }
                }

                InternetCloseHandleWrap(hInternetHTTPRequest);
            }

            InternetCloseHandleWrap(hInternetHTTPConnect);
        }

        LocalFree(pszPostData);
    }

    // Did the caller want to redirect to another server?
    if (szRedirectURL[0])
    {
        // Yes, so do that now via recursion.
        WCHAR szDomain[INTERNET_MAX_HOST_NAME_LENGTH];
        CHAR szURLPath[INTERNET_MAX_PATH_LENGTH];

        SysFreeString(*pbstrXML);
        *pbstrXML = NULL;

        hr = _UrlToComponents(szRedirectURL, &fHTTPS, szDomain, ARRAYSIZE(szDomain), szURLPath, ARRAYSIZE(szURLPath));
        if (SUCCEEDED(hr))
        {
            hr = _GetInfoFromDomain(bstrXMLRequest, bstrEmail, szDomain, fHTTPS, TRUE, szURLPath, pbstrXML);
        }
    }

    return hr;
}


#define SZ_XML_NOTFOUNDRESULTS              L"<?xml version=\"1.0\"?><AUTODISCOVERY><NOFOUND /></AUTODISCOVERY>"

HRESULT CAccountDiscoveryBase::_GetInfoFromDomainWithSubdirAndCacheCheck(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags, IN LPCSTR pszURLPath)
{
    HRESULT hr;
    WCHAR wzCacheURL[INTERNET_MAX_HOST_NAME_LENGTH];

    if (dwFlags & ADDN_SKIP_CACHEDRESULTS)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = _CheckInCacheAndAddHash(pwzDomain, bstrEmail, pszURLPath, wzCacheURL, ARRAYSIZE(wzCacheURL), bstrXMLRequest, pbstrXML);
    }

    if (FAILED(hr))
    {
        hr = _GetInfoFromDomain(bstrXMLRequest, bstrEmail, pwzDomain, FALSE, FALSE, pszURLPath, pbstrXML);
        if (SUCCEEDED(hr))
        {
            // Put the data into the cache for the next time.
            _CacheResults(wzCacheURL, *pbstrXML);
        }
        else
        {
            // We want to make a blank entry so we don't keep hitting the server
            _CacheResults(wzCacheURL, SZ_XML_NOTFOUNDRESULTS);
        }
    }

    // Did we find a blank entry?
    if (SUCCEEDED(hr) && pbstrXML && *pbstrXML && !StrCmpIW(*pbstrXML, SZ_XML_NOTFOUNDRESULTS))
    {
        // Yes, so we didn't get a successful results, so fail.
        // This way we will try other sources.
        hr = E_FAIL;
        SysFreeString(*pbstrXML);
        *pbstrXML = NULL;
    }

    return hr;
}


BOOL IsExpired(FILETIME ftExpireTime)
{
    BOOL fIsExpired = TRUE;
    SYSTEMTIME stCurrentTime;
    FILETIME ftCurrentTime;

    GetSystemTime(&stCurrentTime);
    SystemTimeToFileTime(&stCurrentTime, &ftCurrentTime);

    // It is not expired if the current time is before the expired time.
    if (-1 == CompareFileTime(&ftCurrentTime, &ftExpireTime))
    {
        fIsExpired = FALSE;
    }

    return fIsExpired;
}


#define SZ_HASHSTR_HEADER               L"MD5"
HRESULT GenerateHashStr(IN LPCWSTR pwzHashData, IN LPWSTR pwzHashStr, IN DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    MD5_CTX md5;
    DWORD * pdwHashChunk = (DWORD *)&md5.digest;

    MD5Init(&md5);
    MD5Update(&md5, (const unsigned char *) pwzHashData, (lstrlenW(pwzHashData) * sizeof(OLECHAR)));
    MD5Final(&md5);

    StrCpyNW(pwzHashStr, SZ_HASHSTR_HEADER, cchSize);

    // Break the hash into 64 bit chunks and turn them into strings.
    // pwzHashStr will then contain the header and each chunk concatinated.
    for (int nIndex = 0; nIndex < (sizeof(md5.digest) / sizeof(*pdwHashChunk)); nIndex++)
    {
        WCHAR szNumber[MAX_PATH];
        
        wnsprintfW(szNumber, ARRAYSIZE(szNumber), L"%08lX", pdwHashChunk[nIndex]);
        StrCatBuffW(pwzHashStr, szNumber, cchSize);
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_CheckInCacheAndAddHash(IN LPCWSTR pwzDomain, IN BSTR bstrEmail, IN LPCSTR pszSubdir, IN LPWSTR pwzCacheURL, IN DWORD cchSize, IN BSTR bstrXMLRequest, OUT BSTR * pbstrXML)
{
    WCHAR szHash[MAX_PATH];

    // We add the MD5 of the XML request to the URL so that the different XML requests to the
    // same server are cached separately
    GenerateHashStr(bstrXMLRequest, szHash, ARRAYSIZE(szHash));
    wnsprintfW(pwzCacheURL, cchSize, L"http://%ls.%ls%hs/%ls.xml", szHash, pwzDomain, pszSubdir, bstrEmail);

    return _CheckInCache(pwzCacheURL, pbstrXML);
}


HRESULT CAccountDiscoveryBase::_CheckInCache(IN LPWSTR pwzCacheURL, OUT BSTR * pbstrXML)
{
    HINTERNET hOpenUrlSession;
    DWORD cbSize = (sizeof(INTERNET_CACHE_ENTRY_INFO) + 4048);
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, cbSize);
    HRESULT hr = E_FAIL;

    if (lpCacheEntryInfo)
    {
        // HACKHACK: I wish InternetOpenUrlWrap() would respect the INTERNET_FLAG_FROM_CACHE flag but
        //   it doesn't.  Therefore I call GetUrlCacheEntryInfo() to check and check the expired
        //   myself.
        lpCacheEntryInfo->dwStructSize = cbSize;
        if (GetUrlCacheEntryInfo(pwzCacheURL, lpCacheEntryInfo, &cbSize))
        {
            if (!IsExpired(lpCacheEntryInfo->ExpireTime))
            {
                hr = InternetOpenUrlWrap(m_hInternetSession, pwzCacheURL, NULL, 0, INTERNET_FLAG_FROM_CACHE, NULL, &hOpenUrlSession);
                if (SUCCEEDED(hr))
                {
                    hr = InternetReadIntoBSTR(hOpenUrlSession, pbstrXML);
                    InternetCloseHandleWrap(hOpenUrlSession);
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        LocalFree(lpCacheEntryInfo);
    }

    return hr;
}


#define AUTODISC_EXPIRE_TIME        7 /*days*/

HRESULT GetModifiedAndExpiredDates(IN FILETIME * pftExpireTime, IN FILETIME * pftLastModifiedTime)
{
    SYSTEMTIME stCurrentUTC;
    ULARGE_INTEGER uliTimeMath;
    ULARGE_INTEGER uliExpireTime;

    GetSystemTime(&stCurrentUTC);
    SystemTimeToFileTime(&stCurrentUTC, pftLastModifiedTime);

    *pftExpireTime = *pftLastModifiedTime;
    uliTimeMath.HighPart = pftExpireTime->dwHighDateTime;
    uliTimeMath.LowPart = pftExpireTime->dwLowDateTime;

    uliExpireTime.QuadPart = 1000000; // One Second; 
    uliExpireTime.QuadPart *= (SECONDS_IN_ONE_DAY * AUTODISC_EXPIRE_TIME);

    uliTimeMath.QuadPart += uliExpireTime.QuadPart;
    pftExpireTime->dwHighDateTime = uliTimeMath.HighPart;
    pftExpireTime->dwLowDateTime = uliTimeMath.LowPart;

    return S_OK;
}


HRESULT CAccountDiscoveryBase::_CacheResults(IN LPCWSTR pwzCacheURL, IN BSTR bstrXML)
{
    HRESULT hr = S_OK;
    WCHAR wzPath[MAX_PATH];

    hr = CreateUrlCacheEntryWrap(pwzCacheURL, (lstrlenW(bstrXML) + 1), L"xml", wzPath, 0);
    if (SUCCEEDED(hr))
    {
        HANDLE hFile;

        hr = CreateFileHrWrap(wzPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &hFile);
        if (SUCCEEDED(hr))
        {
            LPSTR pszAnsiXML = AllocStringFromBStr(bstrXML);
            if (pszAnsiXML)
            {
                DWORD cchWritten;

                hr = WriteFileWrap(hFile, pszAnsiXML, (lstrlenA(pszAnsiXML) + 1), &cchWritten, NULL);
                LocalFree(pszAnsiXML);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            CloseHandle(hFile);
            if (SUCCEEDED(hr))
            {
                FILETIME ftExpireTime;
                FILETIME ftLastModifiedTime;

                GetModifiedAndExpiredDates(&ftExpireTime, &ftLastModifiedTime);
                hr = CommitUrlCacheEntryWrap(pwzCacheURL, wzPath, ftExpireTime, ftLastModifiedTime, NORMAL_CACHE_ENTRY, NULL, 0, NULL, pwzCacheURL);
            }
        }
    }

    return hr;
}


LPCWSTR _GetNextDomain(IN LPCWSTR pwszDomain)
{
    LPCWSTR pwzNext = NULL;
    
    pwszDomain = StrChrW(pwszDomain, CH_EMAIL_DOMAIN_SEPARATOR);
    if (pwszDomain) // We did find the next one.
    {
        pwszDomain = CharNext(pwszDomain);  // Skip past '.'

        if (StrChrW(pwszDomain, CH_EMAIL_DOMAIN_SEPARATOR)) // is this the primary domain "com"?
        {
            // No, so that's good. Because we can't search for JoeUser@com.
            pwzNext = pwszDomain;
        }
    }

    return pwzNext;
}


#define SZ_EMAIL_TAG            L"Email=\""

HRESULT _FilterEmailName(IN BSTR bstrXMLRequest, OUT BSTR * pbstrXMLRequest)
{
    HRESULT hr = S_OK;

    *pbstrXMLRequest = SysAllocString(bstrXMLRequest);
    LPWSTR pwzEmailTag = StrStrIW(*pbstrXMLRequest, SZ_EMAIL_TAG);
    LPWSTR pwzEmailTagSource = StrStrIW(bstrXMLRequest, SZ_EMAIL_TAG);

    if (pwzEmailTag)
    {
        pwzEmailTagSource += (ARRAYSIZE(SZ_EMAIL_TAG) - 1);
        pwzEmailTag += (ARRAYSIZE(SZ_EMAIL_TAG) - 1);

        LPCWSTR pwzEndOfUserName = StrChrW(pwzEmailTagSource, CH_EMAIL_AT);

        StrCpyW(pwzEmailTag, pwzEndOfUserName);
    }

    return hr;
}


#define SZ_HTTP_SCHEME              L"http://"
HRESULT GetDomainFromURL(IN LPCWSTR pwzURL, IN LPWSTR pwzDomain, IN int cchSize)
{
    StrCpyNW(pwzDomain, pwzURL, cchSize);

    if (!StrCmpNIW(SZ_HTTP_SCHEME, pwzDomain, (ARRAYSIZE(SZ_HTTP_SCHEME) - 1)))
    {
        StrCpyNW(pwzDomain, &pwzURL[(ARRAYSIZE(SZ_HTTP_SCHEME) - 1)], cchSize);

        LPWSTR pszRemovePath = StrChrW(pwzDomain, L'/');
        if (pszRemovePath)
        {
            pszRemovePath[0] = 0;
        }
    }

    return S_OK;
}


HRESULT CAccountDiscoveryBase::_UseOptimizedService(IN LPCWSTR pwzServiceURL, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags)
{
    WCHAR szURL[MAX_URL_STRING];
    HINTERNET hOpenUrlSession;

    wnsprintfW(szURL, ARRAYSIZE(szURL), L"%lsDomain=%ls", pwzServiceURL, pwzDomain);

    HRESULT hr = _CheckInCache(szURL, pbstrXML);
    if (FAILED(hr))
    {
        WCHAR szDomain[MAX_PATH];

        if (SUCCEEDED(GetDomainFromURL(szURL, szDomain, ARRAYSIZE(szDomain))))
        {
            _SendStatusMessage(IDS_STATUS_CONNECTING_TO, szDomain);
        }

        // NOTE: The web server may want to redirect to an https URL for additional security.
        //       We need to pass the INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS to HttpOpenRequest
        //       or HttpSendRequest() will fail with ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR

        // INTERNET_FLAG_IGNORE_CERT_CN_INVALID is another option we may want to use.
        hr = InternetOpenUrlWrap(m_hInternetSession, szURL, NULL, 0, INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS, NULL, &hOpenUrlSession);
        if (SUCCEEDED(hr))
        {
            hr = InternetReadIntoBSTR(hOpenUrlSession, pbstrXML);
            if (SUCCEEDED(hr))
            {
                DWORD cbSize = (sizeof(INTERNET_CACHE_ENTRY_INFO) + 4048);
                LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO) LocalAlloc(LPTR, cbSize);
                HRESULT hr = E_FAIL;

                if (lpCacheEntryInfo)
                {
                    lpCacheEntryInfo->dwStructSize = cbSize;
                    if (GetUrlCacheEntryInfo(szURL, lpCacheEntryInfo, &cbSize))
                    {
                        lpCacheEntryInfo->CacheEntryType |= CACHE_ENTRY_EXPTIME_FC;
                        GetModifiedAndExpiredDates(&(lpCacheEntryInfo->ExpireTime), &(lpCacheEntryInfo->LastModifiedTime));
                        SetUrlCacheEntryInfo(szURL, lpCacheEntryInfo, (CACHE_ENTRY_EXPTIME_FC | CACHE_ENTRY_MODTIME_FC));
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }

                    LocalFree(lpCacheEntryInfo);
                }
            }
            InternetCloseHandleWrap(hOpenUrlSession);
        }
    }

    return hr;
}


// We turn this off because JoshCo said that it would make
// it hard to turn it into an international standard.
// There are cases where user@organization.co.uk may trust
// organization.co.uk but not co.uk.
//#define FEATURE_WALK_UP_DOMAIN

HRESULT CAccountDiscoveryBase::_GetInfo(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN BSTR * pbstrXML, IN DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;
    LPCWSTR pwszDomain = StrChrW(bstrEmail, CH_EMAIL_AT);

    if (pwszDomain)
    {
        pwszDomain = CharNext(pwszDomain);  // Skip past the '@'
        IAutoDiscoveryProvider * pProviders;

        hr = _getPrimaryProviders(bstrEmail, &pProviders);
        if (SUCCEEDED(hr))
        {
            long nTotal = 0;
            VARIANT varIndex;
        
            varIndex.vt = VT_I4;

            hr = pProviders->get_length(&nTotal);
            hr = E_FAIL;
            for (varIndex.lVal = 0; FAILED(hr) && (varIndex.lVal < nTotal); varIndex.lVal++)
            {
                CComBSTR bstrDomain;

                hr = pProviders->get_item(varIndex, &bstrDomain);
                if (SUCCEEDED(hr))
                {
                    hr = _GetInfoFromDomainWithSubdirAndCacheCheck(bstrXMLRequest, bstrEmail, bstrDomain, pbstrXML, dwFlags, SZ_ADSERVER_XMLFILE);
                }
            }

            pProviders->Release();
        }

        // Do we still need to find the settings and should we fall back
        // to trying public internet servers that can try to find the email mappings?
        // We also only want to try one of the public servers if the domain is not an internet
        // domain because we don't want to send intranet email server names outside of
        // the corp-net to public servers.  We detect intranet type servers by the lack
        // of a 'period' in the name.  For Example: JustUser@internetemailserver vs
        // JoeUser@theISP.com.
        if (FAILED(hr) && (ADDN_CONFIGURE_EMAIL_FALLBACK & dwFlags) &&
            (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_TEST_INTRANETS, FALSE, /*default:*/FALSE) ||
                StrChrW(pwszDomain, CH_EMAIL_DOMAIN_SEPARATOR)))
        {
            hr = _getSecondaryProviders(bstrEmail, &pProviders, dwFlags);
            if (SUCCEEDED(hr))
            {
                long nTotal = 0;
                VARIANT varIndex;
        
                varIndex.vt = VT_I4;

                hr = pProviders->get_length(&nTotal);
                hr = E_FAIL;
                for (varIndex.lVal = 0; FAILED(hr) && (varIndex.lVal < nTotal); varIndex.lVal++)
                {
                    CComBSTR bstrURL;

                    hr = pProviders->get_item(varIndex, &bstrURL);
                    if (SUCCEEDED(hr))
                    {
                        hr = _UseOptimizedService(bstrURL, pwszDomain, pbstrXML, dwFlags);
                    }
                }

                pProviders->Release();
            }
        }
    }

    return hr;
}


// We turn this off because JoshCo said that it would make
// it hard to turn it into an international standard.
// There are cases where user@organization.co.uk may trust
// organization.co.uk but not co.uk.
//#define FEATURE_WALK_UP_DOMAIN

HRESULT CAccountDiscoveryBase::_getPrimaryProviders(IN LPCWSTR pwzEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders)
{
    HRESULT hr = E_INVALIDARG;

    if (ppProviders)
    {
        *ppProviders = NULL;
        if (!m_hdpaPrimary && pwzEmailAddress)
        {
            LPCWSTR pwszDomain = StrChrW(pwzEmailAddress, CH_EMAIL_AT);
            if (pwszDomain)
            {
                pwszDomain = CharNext(pwszDomain);  // Skip past the "@"
                if (pwszDomain[0])
                {
                    // While we still have a domain and it's at least a second level domain...
                    if (pwszDomain)
                    {
                        WCHAR wzDomain[INTERNET_MAX_HOST_NAME_LENGTH];

                        // First we try "AutoDiscovery.<domainname>".  That way, if admins receive a large amount
                        // of traffic, they can change their DNS to have a "AutoDiscovery" alias that points to
                        // a web server of their choosing to handle this traffic.
                        wnsprintfW(wzDomain, ARRAYSIZE(wzDomain), L"autodiscover.%ls", pwszDomain);
                        if (SUCCEEDED(AddHDPA_StrDup(wzDomain, &m_hdpaPrimary)))
                        {
                            // Add ballback server here.  If the administrators don't want to do all the work
                            // of having another machine or creating a DNS alias, we will try the main server.
                            AddHDPA_StrDup(pwszDomain, &m_hdpaPrimary);
                        }
                    }
                }
            }
        }

        if (m_hdpaPrimary)
        {
            hr = CADProviders_CreateInstance(m_hdpaPrimary, SAFECAST(this, IObjectWithSite *), ppProviders);
        }
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_getSecondaryProviders(IN LPCWSTR pwzEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders, IN DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if (ppProviders)
    {
        *ppProviders = NULL;
        if (!m_hdpaSecondary && pwzEmailAddress)
        {
            LPCWSTR pwszDomain = StrChrW(pwzEmailAddress, CH_EMAIL_AT);
            if (pwszDomain)
            {
                pwszDomain = CharNext(pwszDomain);  // Skip past the "@"
                if (pwszDomain[0])
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);

                    BOOL fUseGlobalService = SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_SERVICES_POLICY, FALSE, /*default:*/TRUE);
                    if (fUseGlobalService)
                    {
                        // If this policy is set, then we only want to use the Global Service for certain (i.e. Microsoft Owned)
                        // domains.  If people don't feel confortable with us providing settings for non-Microsoft
                        // email providers, then we can turn this on and only provide them for Microsoft providers.
                        if (SHRegGetBoolUSValue(SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_MS_ONLY_ADDRESSES, FALSE, /*default:*/FALSE))
                        {
                            fUseGlobalService = SHRegGetBoolUSValue(SZ_REGKEY_SERVICESALLOWLIST, pwszDomain, FALSE, /*default:*/FALSE);
                        }
                    }

                    if (fUseGlobalService)
                    {
                        HKEY hKey;
                        DWORD dwError = RegOpenKeyExW(HKEY_LOCAL_MACHINE, SZ_REGKEY_GLOBALSERVICES, 0, KEY_READ, &hKey);

                        if (ERROR_SUCCESS == dwError)
                        {
                            WCHAR szServiceURL[MAX_PATH];
                            int nIndex = 0;

                            do
                            {
                                WCHAR szValue[MAX_PATH];
                                DWORD cchValueSize = ARRAYSIZE(szValue);
                                DWORD dwType = REG_SZ;
                                DWORD cbDataSize = sizeof(szServiceURL);

                                dwError = RegEnumValueW(hKey, nIndex, szValue, &cchValueSize, NULL, &dwType, (unsigned char *)szServiceURL, &cbDataSize);
                                if (ERROR_SUCCESS == dwError)
                                {
                                    // FEATURE_OPTIMIZED_SERVICE: We can either pass the entire XML request or just put the domain name
                                    //    in the QueryString.  The QueryString is faster for the server and they can optimize by using it.
                                    AddHDPA_StrDup(szServiceURL, &m_hdpaSecondary);
                                }
                                else
                                {
                                    break;
                                }

                                nIndex++;
                            }
                            while (1);

                            RegCloseKey(hKey);
                        }
                    }
                }
            }
        }

        if (m_hdpaSecondary)
        {
            hr = CADProviders_CreateInstance(m_hdpaSecondary, SAFECAST(this, IObjectWithSite *), ppProviders);
        }
    }


    return hr;
}


HRESULT CAccountDiscoveryBase::_PerformAutoDiscovery(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse)
{
    HRESULT hr = E_INVALIDARG;

    *ppXMLResponse = NULL;
    if (bstrEmailAddress)
    {
        hr = InternetOpenWrap(SZ_WININET_AGENT_AUTO_DISCOVER, PRE_CONFIG_INTERNET_ACCESS, NULL, NULL, 0, &m_hInternetSession);
        if (SUCCEEDED(hr))
        {
            BSTR bstrXML;

            hr = _GetInfo(bstrXMLRequest, bstrEmailAddress, &bstrXML, dwFlags);
            if (SUCCEEDED(hr))
            {
                hr = XMLDOMFromBStr(bstrXML, ppXMLResponse);
                SysFreeString(bstrXML);
            }

            InternetCloseHandleWrap(m_hInternetSession);
            m_hInternetSession = NULL;
        }
    }

    return hr;
}


HRESULT CAccountDiscoveryBase::_InternalDiscoverNow(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse)
{
    HRESULT hr = E_INVALIDARG;

    *ppXMLResponse = NULL;
    if (bstrEmailAddress)
    {
        // Does the caller want this done async?
        if (m_hwndAsync)
        {
            // No, so cache the params so we can use them when async.
            SysFreeString(m_bstrEmailAsync);
            hr = HrSysAllocString(bstrEmailAddress, &m_bstrEmailAsync);
            if (SUCCEEDED(hr))
            {
                SysFreeString(m_bstrXMLRequest);
                hr = HrSysAllocString(bstrXMLRequest, &m_bstrXMLRequest);
                if (SUCCEEDED(hr))
                {
                    DWORD idThread;

                    m_dwFlagsAsync = dwFlags;

                    AddRef();
                    HANDLE hThread = CreateThread(NULL, 0, CAccountDiscoveryBase::AutoDiscoveryUIThreadProc, this, 0, &idThread);
                    if (hThread)
                    {
                        // We wait WAIT_AUTODISCOVERY_STARTUP_HWND for the new thread to create the COM object
                        if (m_hCreatedBackgroundTask)
                        {
                            DWORD dwRet = WaitForSingleObject(m_hCreatedBackgroundTask, WAIT_AUTODISCOVERY_STARTUP_HWND);
                            ASSERT(dwRet != WAIT_TIMEOUT);
                        }

                        hr = m_hrSuccess;
                        CloseHandle(hThread);
                    }
                    else
                    {
                        Release();
                    }
                }
            }
        }
        else
        {
            // Yes.
            hr = _PerformAutoDiscovery(bstrEmailAddress, dwFlags, bstrXMLRequest, ppXMLResponse);
        }
    }

    return hr;
}


DWORD CAccountDiscoveryBase::_AutoDiscoveryUIThreadProc(void)
{
    m_hrSuccess = CoInitialize(NULL);

    // We need to make sure that the API is installed and
    // accessible before we can continue.
    if (SUCCEEDED(m_hrSuccess))
    {
        IXMLDOMDocument * pXMLResponse;
        BSTR bstrXMLResponse = NULL;

        // Signal the main thread that we have successfully started
        if (m_hCreatedBackgroundTask)
            SetEvent(m_hCreatedBackgroundTask);

        // we give up the remainder of our timeslice here so that our parent thread has time to run
        // and will notice that we have signaled the m_hCreatedBackgroundTask event and can therefore return
        Sleep(0);

        m_hrSuccess = _PerformAutoDiscovery(m_bstrEmailAsync, m_dwFlagsAsync, m_bstrXMLRequest, &pXMLResponse);
        if (SUCCEEDED(m_hrSuccess))
        {
            m_hrSuccess = XMLBStrFromDOM(pXMLResponse, &bstrXMLResponse);
            pXMLResponse->Release();
        }

        _AsyncParseResponse(bstrXMLResponse);
        
        // Whether we succeeded or failed, inform the caller of our results.
        if (IsWindow(m_hwndAsync))
        {
            PostMessage(m_hwndAsync, m_wMsgAsync, m_hrSuccess, (LPARAM)bstrXMLResponse);
        }
        else
        {
            SysFreeString(bstrXMLResponse);
        }

        CoUninitialize();
    }
    else
    {
        // Signal the main thread that they can wake up to find that we
        // failed to start the async operation.
        if (m_hCreatedBackgroundTask)
            SetEvent(m_hCreatedBackgroundTask);
    }

    Release();
    return 0;
}


HRESULT CAccountDiscoveryBase::_WorkAsync(IN HWND hwnd, IN UINT wMsg)
{
    m_hwndAsync = hwnd;
    m_wMsgAsync = wMsg;

    return S_OK;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CAccountDiscoveryBase::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CAccountDiscoveryBase::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CAccountDiscoveryBase::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAccountDiscoveryBase, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CAccountDiscoveryBase::CAccountDiscoveryBase() : m_cRef(1)
{
    // DllAddRef();  // Done by our inheriting class

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hInternetSession);
    ASSERT(!m_hwndAsync);
    ASSERT(!m_wMsgAsync);
    ASSERT(!m_dwFlagsAsync);
    ASSERT(!m_bstrEmailAsync);
    ASSERT(!m_bstrXMLRequest);
    ASSERT(S_OK == m_hrSuccess);
    ASSERT(!m_hdpaPrimary);
    ASSERT(!m_hdpaSecondary);

    // We use this event to signal the primary thread that the hwnd was created on the UI thread.
    m_hCreatedBackgroundTask = CreateEvent(NULL, FALSE, FALSE, NULL); 
}


CAccountDiscoveryBase::~CAccountDiscoveryBase()
{
    SysFreeString(m_bstrEmailAsync);
    SysFreeString(m_bstrXMLRequest);

    if (m_hCreatedBackgroundTask)
        CloseHandle(m_hCreatedBackgroundTask);

    if (m_hdpaPrimary)
    {
        DPA_DestroyCallback(m_hdpaPrimary, DPALocalFree_Callback, NULL);
    }

    if (m_hdpaSecondary)
    {
        DPA_DestroyCallback(m_hdpaSecondary, DPALocalFree_Callback, NULL);
    }

    //DllRelease();  // Done by our inheriting class
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\autodiscmail.cpp ===
/*****************************************************************************\
    FILE: AutoDiscMail.cpp

    DESCRIPTION:
        This is the Autmation Object to AutoDiscovered account information.

    BryanSt 10/3/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "AutoDiscover.h"
#include "MailProtocol.h"


// TODO: Add " xmlns="http://bryanst2-email/dtd/AutoDiscovery" to XML"
#define XML_POST_REQUEST                    L"<?xml version=\"1.0\"?>\r\n" \
                                             L"<" SZ_XMLELEMENT_AUTODISCOVERY L">\r\n" \
                                               L"<" SZ_XMLELEMENT_REQUEST L">\r\n" \
                                                 L"<" SZ_XMLELEMENT_ACCOUNT L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_TYPE L">" SZ_XMLTEXT_EMAIL L"</" SZ_XMLELEMENT_TYPE L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_VERSION L">0.1</" SZ_XMLELEMENT_VERSION L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_RESPONSEVER L">0.1</" SZ_XMLELEMENT_RESPONSEVER L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_LANG L">en</" SZ_XMLELEMENT_LANG L">\r\n" \
                                                   L"<" SZ_XMLELEMENT_EMAIL L">%ls</" SZ_XMLELEMENT_EMAIL L">\r\n" \
                                                 L"</" SZ_XMLELEMENT_ACCOUNT L">\r\n" \
                                               L"</" SZ_XMLELEMENT_REQUEST L">\r\n" \
                                             L"</" SZ_XMLELEMENT_AUTODISCOVERY L">\r\n"

#define STR_AT_EMAIL                        TEXT("Email")


typedef struct tagPROTOCOL_ENTRY
{
    BSTR bstrProtocolName;
    IMailProtocolADEntry * pMailProtocol;
} PROTOCOL_ENTRY;


class CMailAccountDiscovery     : public CAccountDiscoveryBase
                                , public CImpIDispatch
                                , public IMailAutoDiscovery
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) {return CAccountDiscoveryBase::AddRef();}
    virtual STDMETHODIMP_(ULONG) Release(void) {return CAccountDiscoveryBase::Release();}

    // *** IMailAutoDiscovery ***
    virtual STDMETHODIMP get_DisplayName(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_InfoURL(OUT BSTR * pbstrURL);
    virtual STDMETHODIMP get_PreferedProtocolType(OUT BSTR * pbstrProtocolType);
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT IMailProtocolADEntry ** ppMailProtocol);
    virtual STDMETHODIMP get_XML(OUT IXMLDOMDocument ** ppXMLDoc);
    virtual STDMETHODIMP put_XML(IN IXMLDOMDocument * pXMLDoc);

    virtual STDMETHODIMP getPrimaryProviders(IN BSTR bstrEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders);
    virtual STDMETHODIMP getSecondaryProviders(IN BSTR bstrEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders);
    virtual STDMETHODIMP DiscoverMail(IN BSTR bstrEmailAddress);
    virtual STDMETHODIMP PurgeCache(void);
    virtual STDMETHODIMP WorkAsync(IN HWND hwnd, IN UINT wMsg) {return _WorkAsync(hwnd, wMsg);}

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CMailAccountDiscovery();
    virtual ~CMailAccountDiscovery(void);

    HRESULT _GetUsersDisplayName(IN IXMLDOMElement * pXMLElementMessage);
    HRESULT _GetInfoURL(IN IXMLDOMNode * pXMLAccountNode);
    HRESULT _Initialize(IN IXMLDOMElement * pXMLElementMessage);
    HRESULT _FreeProtocolList(void);
    HRESULT _CreateProtocolEntry(IN IXMLDOMNode * pXMLNodeProtocol);

    HRESULT _GenerateXMLRequest(IN BSTR bstrEmailAddress, OUT BSTR * pbstrXMLRequest);
    HRESULT _ParseResponse(void);
    STDMETHODIMP _AsyncParseResponse(BSTR bstrEmail);   // Override base class implementation
    HRESULT _AsyncPrep(void);

    // Private Member Variables
    int                     m_cRef;

    bool                    m_fDiscovered;
    BSTR                    m_bstrUserDisplayName;  // OPTIONAL: User's Display Name from server.
    BSTR                    m_bstrInfoURL;          // OPTIONAL: An URL pointing to a web page describing information about the e-mail server or accessing e-mail.
    IXMLDOMNode *           m_pXMLNodeAccount;      // Node to section of XML with <ACCOUT> <TYPE>email</TYPE> ... </ACCOUNT>
    IXMLDOMDocument *       m_pXMLDocResponse;      // The XML document
    BSTR                    m_bstrResponse;         // Cached XML response until the main thread can parse in the async case.
    HDSA                    m_hdsaProtocols;        // PROTOCOL_ENTRY structs, containing IMailAutoDiscoveryProtocol *.

    // Friend Functions
    friend HRESULT CMailAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
};



#define SZ_FILEEXTENSION            L".xml"

//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CMailAccountDiscovery::_GetUsersDisplayName(IN IXMLDOMElement * pXMLElementMessage)
{
    IXMLDOMNode * pNodeUser;
    HRESULT hr = XMLNode_GetChildTag(pXMLElementMessage, SZ_XMLELEMENT_USER, &pNodeUser);

    if (m_bstrUserDisplayName)
    {
        SysFreeString(m_bstrUserDisplayName);
        m_bstrUserDisplayName = NULL;
    }

    if (SUCCEEDED(hr))
    {
        hr = XMLNode_GetChildTagTextValue(pNodeUser, SZ_XMLELEMENT_DISPLAYNAME, &m_bstrUserDisplayName);
        pNodeUser->Release();
    }

    return hr;
}


HRESULT CMailAccountDiscovery::_GetInfoURL(IN IXMLDOMNode * pXMLAccountNode)
{
    if (m_bstrInfoURL)
    {
        SysFreeString(m_bstrInfoURL);
        m_bstrInfoURL = NULL;
    }

    return XMLNode_GetChildTagTextValue(pXMLAccountNode, SZ_XMLELEMENT_INFOURL, &m_bstrInfoURL);
}


HRESULT CMailAccountDiscovery::_Initialize(IN IXMLDOMElement * pXMLElementMessage)
{
    // This is only valid XML if the root tag is "AUTODISCOVERY".
    // The case is not important.
    // If it isn't we need to reject this return value.
    // This happens most often when the URL fails to load
    // because the server doesn't exist and the Web Proxy
    // returns the error value wrapped in a web page.
    HRESULT hr = XMLElem_VerifyTagName(pXMLElementMessage, SZ_XMLELEMENT_AUTODISCOVERY);
    if (SUCCEEDED(hr))
    {
        IXMLDOMNode * pXMLReponse;

        // We don't care if this is failes because the server isn't obligated to 
        // provide:
        // <USER> <DISPLAYNAME> xxx </DISPLAYNAME> </USER>
        _GetUsersDisplayName(pXMLElementMessage);

        // Enter the <RESPONSE> tag.
        hr = XMLNode_GetChildTag(pXMLElementMessage, SZ_XMLELEMENT_RESPONSE, &pXMLReponse);
        if (SUCCEEDED(hr))
        {
            IXMLDOMElement * pXMLElementMessage;

            hr = pXMLReponse->QueryInterface(IID_PPV_ARG(IXMLDOMElement, &pXMLElementMessage));
            if (SUCCEEDED(hr))
            {
                IXMLDOMNodeList * pNodeListAccounts;

                // Iterate thru the list of <ACCOUNT> tags...
                hr = XMLElem_GetElementsByTagName(pXMLElementMessage, SZ_XMLELEMENT_ACCOUNT, &pNodeListAccounts);
                if (SUCCEEDED(hr))
                {
                    DWORD dwIndex = 0;

                    // We are going to look thru each one for one of them with <TYPE>email</TYPE>
                    while (S_OK == (hr = XMLNodeList_GetChild(pNodeListAccounts, dwIndex, &m_pXMLNodeAccount)))
                    {
                        // FUTURE: We could support redirects or error messages here depending on
                        //       <ACTION> redirect | message </ACTION>
                        if (XML_IsChildTagTextEqual(m_pXMLNodeAccount, SZ_XMLELEMENT_TYPE, SZ_XMLTEXT_EMAIL))
                        {
                            // This file may or may not settings to contact the server.  However in either case
                            // it may contain an INFOURL tag.  If it does, then the URL in side will point to a 
                            // web page.
                            // <INFOURL> xxx </INFOURL>
                            _GetInfoURL(m_pXMLNodeAccount);

                            if (XML_IsChildTagTextEqual(m_pXMLNodeAccount, SZ_XMLELEMENT_ACTION, SZ_XMLTEXT_SETTINGS))
                            {
                                break;
                            }
                        }

                        // No, so keep looking.
                        ATOMICRELEASE(m_pXMLNodeAccount);
                        dwIndex++;
                    }

                    pNodeListAccounts->Release();
                }

                pXMLElementMessage->Release();
            }

            pXMLReponse->Release();
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::_GenerateXMLRequest(IN BSTR bstrEmailAddress, OUT BSTR * pbstrXMLRequest)
{
    HRESULT hr;
    WCHAR wzXML[4096];

    wnsprintfW(wzXML, ARRAYSIZE(wzXML), XML_POST_REQUEST, bstrEmailAddress);
    hr = HrSysAllocStringW(wzXML, pbstrXMLRequest);

    return hr;
}


HRESULT CMailAccountDiscovery::_CreateProtocolEntry(IN IXMLDOMNode * pXMLNodeProtocol)
{
    BSTR bstrProtocolType;
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_TYPE, &bstrProtocolType);

    if (SUCCEEDED(hr))
    {
        IMailProtocolADEntry * pMailProtocol;

        hr = CMailProtocol_CreateInstance(pXMLNodeProtocol, &pMailProtocol);
        if (SUCCEEDED(hr))
        {
            PROTOCOL_ENTRY protocolEntry;

            protocolEntry.bstrProtocolName = bstrProtocolType;
            protocolEntry.pMailProtocol = pMailProtocol;
        
            if (-1 != DSA_InsertItem(m_hdsaProtocols, DA_LAST, &protocolEntry))
            {
                // We succeeded, so transfer owner ship of the items to the structure.
                bstrProtocolType = NULL;
                pMailProtocol = NULL;
            }
            else
            {
                hr = E_FAIL;
            }

            ATOMICRELEASE(pMailProtocol);
        }

        SysFreeString(bstrProtocolType);
    }

    return hr;
}

HRESULT CMailAccountDiscovery::_ParseResponse(void)
{
    HRESULT hr = E_UNEXPECTED;

    if (m_pXMLDocResponse)
    {
        IXMLDOMElement * pXMLElementMessage = NULL;
        hr = m_pXMLDocResponse->get_documentElement(&pXMLElementMessage);

        if (S_FALSE == hr)
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        else if (SUCCEEDED(hr))
        {
            hr = _Initialize(pXMLElementMessage);
            if (SUCCEEDED(hr))
            {
                IXMLDOMNodeList * pNodeListProtocols;

                // Iterate thru the list of <ACCOUNT> tags...
                hr = XMLElem_GetElementsByTagName(pXMLElementMessage, SZ_XMLELEMENT_PROTOCOL, &pNodeListProtocols);
                if (SUCCEEDED(hr))
                {
                    IXMLDOMNode * pXMLNodeProtocol;
                    DWORD dwIndex;

                    for (dwIndex = 0; (S_OK == (hr = XMLNodeList_GetChild(pNodeListProtocols, dwIndex, &pXMLNodeProtocol))); dwIndex++)
                    {
                        hr = _CreateProtocolEntry(pXMLNodeProtocol);
                        pXMLNodeProtocol->Release();
                    }

                    long nCount;

                    if (SUCCEEDED(get_length(&nCount)) && (nCount > 0))
                    {
                        hr = S_OK;
                    }

                    pNodeListProtocols->Release();
                }
            }

            pXMLElementMessage->Release();
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::_FreeProtocolList(void)
{
    if (m_hdsaProtocols)
    {
        for (int nIndex = 0; nIndex < DSA_GetItemCount(m_hdsaProtocols); nIndex++)
        {
            PROTOCOL_ENTRY * pProtocolStruct = (PROTOCOL_ENTRY *) DSA_GetItemPtr(m_hdsaProtocols, nIndex);

            if (pProtocolStruct)
            {
                SysFreeString(pProtocolStruct->bstrProtocolName);
                ATOMICRELEASE(pProtocolStruct->pMailProtocol);
            }
        }
        
        DSA_DeleteAllItems(m_hdsaProtocols);
    }

    return S_OK;
}


//===========================
// *** IMailAutoDiscovery Interface ***
//===========================
HRESULT CMailAccountDiscovery::get_DisplayName(OUT BSTR * pbstr)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstr)
    {
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            if (m_bstrUserDisplayName)
            {
                hr = HrSysAllocString(m_bstrUserDisplayName, pbstr);
            }
            else
            {
                *pbstr = NULL;
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_InfoURL(OUT BSTR * pbstrURL)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstrURL)
    {
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            if (m_bstrInfoURL)
            {
                hr = HrSysAllocString(m_bstrInfoURL, pbstrURL);
            }
            else
            {
                *pbstrURL = NULL;
                hr = E_FAIL;
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_PreferedProtocolType(OUT BSTR * pbstrProtocolType)
{
    HRESULT hr = E_INVALIDARG;
    
    if (pbstrProtocolType)
    {
        *pbstrProtocolType = NULL;
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
            if (m_hdsaProtocols && (0 < DSA_GetItemCount(m_hdsaProtocols)))
            {
                PROTOCOL_ENTRY * pProtocolEntry = (PROTOCOL_ENTRY *) DSA_GetItemPtr(m_hdsaProtocols, 0);

                if (pProtocolEntry && pProtocolEntry->bstrProtocolName)
                {
                    hr = HrSysAllocString(pProtocolEntry->bstrProtocolName, pbstrProtocolType);
                }
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;

    if (pnLength)
    {
        *pnLength = 0;
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            *pnLength = (long) DSA_GetItemCount(m_hdsaProtocols);
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_item(IN VARIANT varIndex, OUT IMailProtocolADEntry ** ppMailProtocol)
{
    HRESULT hr = E_INVALIDARG;

    if (ppMailProtocol)
    {
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            long nCount = 0;

            get_length(&nCount);
            *ppMailProtocol = NULL;
            hr = E_FAIL;

            // This is sortof gross, but if we are passed a pointer to another variant, simply
            // update our copy here...
            if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
                varIndex = *(varIndex.pvarVal);

            switch (varIndex.vt)
            {
            case VT_I2:
                varIndex.lVal = (long)varIndex.iVal;
                // And fall through...

            case VT_I4:
                if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount) && (0 < DSA_GetItemCount(m_hdsaProtocols)))
                {
                    PROTOCOL_ENTRY * pProtocolEntry = (PROTOCOL_ENTRY *) DSA_GetItemPtr(m_hdsaProtocols, varIndex.lVal);

                    if (pProtocolEntry && pProtocolEntry->pMailProtocol)
                    {
                        hr = pProtocolEntry->pMailProtocol->QueryInterface(IID_PPV_ARG(IMailProtocolADEntry, ppMailProtocol));
                    }
                }
            break;
            case VT_BSTR:
            {
                long nIndex;

                for (nIndex = 0; nIndex < nCount; nIndex++)
                {
                    PROTOCOL_ENTRY * pProtocolEntry = (PROTOCOL_ENTRY *) DSA_GetItemPtr(m_hdsaProtocols, nIndex);

                    if (pProtocolEntry && pProtocolEntry->pMailProtocol && pProtocolEntry->bstrProtocolName &&
                        !StrCmpIW(pProtocolEntry->bstrProtocolName, varIndex.bstrVal))
                    {
                        hr = pProtocolEntry->pMailProtocol->QueryInterface(IID_PPV_ARG(IMailProtocolADEntry, ppMailProtocol));
                        break;
                    }
                }
            }
            break;

            default:
                hr = E_NOTIMPL;
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::get_XML(OUT IXMLDOMDocument ** ppXMLDoc)
{
    HRESULT hr = E_INVALIDARG;

    if (ppXMLDoc && m_pXMLDocResponse)
    {
        *ppXMLDoc = NULL;
        hr = _AsyncPrep();
        if (SUCCEEDED(hr))
        {
            hr = m_pXMLDocResponse->QueryInterface(IID_PPV_ARG(IXMLDOMDocument, ppXMLDoc));
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::put_XML(IN IXMLDOMDocument * pXMLDoc)
{
    HRESULT hr = E_INVALIDARG;

    return hr;
}


HRESULT _IsValidEmailAddress(IN BSTR bstrEmailAddress)
{
    HRESULT hr = E_INVALIDARG;

    if (bstrEmailAddress && bstrEmailAddress[0])
    {
        if (NULL != StrChrW(bstrEmailAddress, CH_EMAIL_AT))
        {
            // Ok, we found a '@' so it's valid.
            hr = S_OK;
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::getPrimaryProviders(IN BSTR bstrEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders)
{
    return _getPrimaryProviders(bstrEmailAddress, ppProviders);
}


HRESULT CMailAccountDiscovery::getSecondaryProviders(IN BSTR bstrEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders)
{
    return _getSecondaryProviders(bstrEmailAddress, ppProviders, (ADDN_DEFAULT | ADDN_CONFIGURE_EMAIL_FALLBACK | ADDN_FILTER_EMAIL));
}


HRESULT CMailAccountDiscovery::DiscoverMail(IN BSTR bstrEmailAddress)
{
    HRESULT hr = _IsValidEmailAddress(bstrEmailAddress);

    if (SUCCEEDED(hr))
    {
        BSTR bstrXMLRequest;

        hr = _GenerateXMLRequest(bstrEmailAddress, &bstrXMLRequest);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(m_pXMLDocResponse);
            ATOMICRELEASE(m_pXMLNodeAccount);
            SysFreeString(m_bstrResponse);
            m_bstrResponse = NULL;

            _FreeProtocolList();
            hr = _InternalDiscoverNow(bstrEmailAddress, (ADDN_DEFAULT | ADDN_CONFIGURE_EMAIL_FALLBACK | ADDN_FILTER_EMAIL), bstrXMLRequest, &m_pXMLDocResponse);
            if (SUCCEEDED(hr) && !m_hwndAsync)  // If we aren't async, parse now.
            {
                hr = _ParseResponse();
                if (SUCCEEDED(hr))
                {
                    m_fDiscovered = true;
                }
            }

            SysFreeString(bstrXMLRequest);
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::_AsyncParseResponse(BSTR bstrEmail)
{
    return HrSysAllocString(bstrEmail, &m_bstrResponse);
}


HRESULT CMailAccountDiscovery::_AsyncPrep(void)
{
    HRESULT hr = S_OK;

    // Now that we are back on the main thread.  See if we
    // need to turn the XML response back into a real COM object
    // for the user to read.
    if (m_hwndAsync && !m_pXMLDocResponse)    // Are we async?  And have we not yet parsed the response
    {
        hr = XMLDOMFromBStr(m_bstrResponse, &m_pXMLDocResponse);
        if (SUCCEEDED(hr))
        {
            hr = _ParseResponse();
            if (SUCCEEDED(hr))
            {
                m_fDiscovered = true;
            }
        }
    }

    return hr;
}


HRESULT CMailAccountDiscovery::PurgeCache(void)
{
    HRESULT hr = E_INVALIDARG;

    // TODO:
    _FreeProtocolList();
    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================


//===========================
// *** Class Methods ***
//===========================
HRESULT CMailAccountDiscovery::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CMailAccountDiscovery, IMailAutoDiscovery),
        QITABENT(CMailAccountDiscovery, IDispatch),
        { 0 },
    };

    hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
    {
        hr = CAccountDiscoveryBase::QueryInterface(riid, ppvObj);
    }

    return hr;
}


CMailAccountDiscovery::CMailAccountDiscovery() : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IMailAutoDiscovery)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_pXMLDocResponse);
    ASSERT(!m_pXMLNodeAccount);
    ASSERT(!m_bstrUserDisplayName);
    ASSERT(!m_bstrInfoURL);
    ASSERT(!m_bstrResponse);

    m_hdsaProtocols = DSA_Create(sizeof(PROTOCOL_ENTRY), 1);
    m_fDiscovered = false;
}


CMailAccountDiscovery::~CMailAccountDiscovery()
{
    ATOMICRELEASE(m_pXMLNodeAccount);
    ATOMICRELEASE(m_pXMLDocResponse);
    SysFreeString(m_bstrUserDisplayName);
    SysFreeString(m_bstrInfoURL);
    SysFreeString(m_bstrResponse);

    _FreeProtocolList();
    DSA_DeleteAllItems(m_hdsaProtocols);
    m_hdsaProtocols = NULL;

    DllRelease();
}


HRESULT CMailAccountDiscovery_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;
    if (NULL == punkOuter)
    {
        if (ppvObj)
        {
            CMailAccountDiscovery * pThis = new CMailAccountDiscovery();
            if (pThis)
            {
                hr = pThis->QueryInterface(riid, ppvObj);
                pThis->Release();
            }
            else
            {
                *ppvObj = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

    }
    return hr;
}

















//===========================
// *** IAutoDiscoveryProvider Interface ***
//===========================
HRESULT CADProviders::get_length(OUT long * pnLength)
{
    HRESULT hr = E_INVALIDARG;

    if (pnLength && m_hdpa)
    {
        *pnLength = (long) DSA_GetItemCount(m_hdpa);
        hr = S_OK;
    }

    return hr;
}


HRESULT CADProviders::get_item(IN VARIANT varIndex, OUT BSTR * pbstr)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstr)
    {
        long nCount = 0;

        get_length(&nCount);
        *pbstr = NULL;

        hr = E_FAIL;

        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        if (varIndex.vt == (VT_BYREF | VT_VARIANT) && varIndex.pvarVal)
            varIndex = *(varIndex.pvarVal);

        switch (varIndex.vt)
        {
        case VT_I2:
            varIndex.lVal = (long)varIndex.iVal;
            // And fall through...

        case VT_I4:
            if ((varIndex.lVal >= 0) && (varIndex.lVal < nCount) && (0 < DSA_GetItemCount(m_hdpa)))
            {
                if (m_hdpa)
                {
                    LPCWSTR pszFilename = (LPWSTR) DPA_GetPtr(m_hdpa, varIndex.lVal);

                    if (pszFilename)
                    {
                        hr = HrSysAllocString(pszFilename, pbstr);
                    }
                }
            }
        break;
        case VT_BSTR:
            hr = E_NOTIMPL;
        break;

        default:
            hr = E_NOTIMPL;
        }
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
ULONG CADProviders::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CADProviders::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


HRESULT CADProviders::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CADProviders, IAutoDiscoveryProvider),
        QITABENT(CADProviders, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


//===========================
// *** Class Methods ***
//===========================
CADProviders::CADProviders(IN HDPA hdpa, IN IUnknown * punkParent) : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IAutoDiscoveryProvider), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_hdpa);
    ASSERT(!m_punkParent);

    m_hdpa = hdpa;
    IUnknown_Set((IUnknown **)&m_punkParent, punkParent);
}


CADProviders::~CADProviders()
{
    IUnknown_Set((IUnknown **)&m_punkParent, NULL);

    DllRelease();
}


HRESULT CADProviders_CreateInstance(IN HDPA hdpa, IN IUnknown * punkParent, OUT IAutoDiscoveryProvider ** ppProvider)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;

    if (ppProvider)
    {
        CADProviders * pThis = new CADProviders(hdpa, punkParent);
        if (pThis)
        {
            hr = pThis->QueryInterface(IID_PPV_ARG(IAutoDiscoveryProvider, ppProvider));
            pThis->Release();
        }
        else
        {
            *ppProvider = NULL;
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\classfactory.cpp ===
/*****************************************************************************\
    FILE: classfactory.cpp

    DESCRIPTION:
       This file will be the Class Factory.

    BryanSt 8/12/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "autodiscovery.h"
#include "objcache.h"
#include "mailbox.h"


/*****************************************************************************
 *
 *  CClassFactory
 *
 *
 *****************************************************************************/

class CClassFactory       : public IClassFactory
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CClassFactory(REFCLSID rclsid);
    ~CClassFactory(void);

    // Friend Functions
    friend HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int                     m_cRef;
    CLSID                   m_rclsid;
};



/*****************************************************************************
 *  IClassFactory::CreateInstance
 *****************************************************************************/

HRESULT CClassFactory::CreateInstance(IUnknown * punkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hr = E_INVALIDARG;

    if (NULL != ppvObj)
    {
        if (!punkOuter)
        {
            if (IsEqualCLSID(m_rclsid,CLSID_AccountDiscovery))
            {
                hr = CAccountDiscovery_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_MailAutoDiscovery))
            {
                hr = CMailAccountDiscovery_CreateInstance(punkOuter, riid, ppvObj);
            }
            else if (IsEqualCLSID(m_rclsid, CLSID_ACLEmailAddresses))
            {
                hr = CACLEmail_CreateInstance(punkOuter, riid, ppvObj);
            }
#ifdef FEATURE_EMAILASSOCIATIONS
            else if (IsEqualCLSID(m_rclsid, CLSID_EmailAssociations))
            {
                hr = CEmailAssociations_CreateInstance(punkOuter, riid, ppvObj);
            }
#endif // FEATURE_EMAILASSOCIATIONS
#ifdef FEATURE_MAILBOX
            else if (IsEqualCLSID(m_rclsid, CLSID_MailBoxDeskBar))
            {
                hr = CMailBoxDeskBand_CreateInstance(punkOuter, riid, ppvObj);
            }
#endif // FEATURE_MAILBOX
            else
            {
                TCHAR szGuid[GUIDSTR_MAX];

                SHStringFromGUID(m_rclsid, szGuid, ARRAYSIZE(szGuid));
                AssertMsg(0, "CClassFactory::CreateInstance(%s) failed because we don't support that CLSID.  This is because someone made a registration bug.", szGuid);  // What are you looking for?
                hr = E_NOINTERFACE;
            }
        }
        else
        {   // Does anybody support aggregation any more?
            hr = ResultFromScode(CLASS_E_NOAGGREGATION);
        }
    }

    return hr;
}

/*****************************************************************************
 *
 *  IClassFactory::LockServer
 *
 *  Locking the server is identical to
 *  creating an object and not releasing it until you want to unlock
 *  the server.
 *
 *****************************************************************************/

HRESULT CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return S_OK;
}

/*****************************************************************************
 *
 *  CClassFactory_Create
 *
 *****************************************************************************/

/****************************************************\
    Constructor
\****************************************************/
CClassFactory::CClassFactory(REFCLSID rclsid) : m_cRef(1)
{
    m_rclsid = rclsid;
    DllAddRef();
}


/****************************************************\
    Destructor
\****************************************************/
CClassFactory::~CClassFactory()
{
    DllRelease();
}


//===========================
// *** IUnknown Interface ***
//===========================

ULONG CClassFactory::AddRef()
{
    m_cRef++;
    return m_cRef;
}

ULONG CClassFactory::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

HRESULT CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualCLSID(riid, IID_IUnknown) || IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory *);
    }
    else
    {
        TraceMsg(TF_WMOTHER, "CClassFactory::QueryInterface() failed.");
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}



HRESULT CClassFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    if (IsEqualCLSID(riid, IID_IClassFactory))
    {
        *ppvObj = (LPVOID) new CClassFactory(rclsid);
        hres = (*ppvObj) ? S_OK : E_OUTOFMEMORY;
    }
    else
        hres = ResultFromScode(E_NOINTERFACE);

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\autodiscover.h ===
/*****************************************************************************\
    FILE: AutoDiscover.h

    DESCRIPTION:
        This is the Autmation Object to AutoDiscover account information.

    BryanSt 10/3/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_AUTODISCOVER
#define _FILE_H_AUTODISCOVER

#include <cowsite.h>
#include <atlbase.h>

class CAccountDiscoveryBase : public CObjectWithSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    virtual STDMETHODIMP _InternalDiscoverNow(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse);
    virtual STDMETHODIMP _WorkAsync(IN HWND hwnd, IN UINT wMsg);

protected:
    CAccountDiscoveryBase();
    virtual ~CAccountDiscoveryBase(void);

    HRESULT _GetInfo(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN BSTR * pbstrXML, IN DWORD dwFlags);
    HRESULT _GetInfoFromDomain(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BOOL fHTTPs, IN BOOL fPost, IN LPCSTR pszURLPath, IN BSTR * pbstrXML);
    HRESULT _GetInfoFromDomainWithCacheCheck(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags);
    HRESULT _UseOptimizedService(IN LPCWSTR pwzServiceURL, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags);
    HRESULT _VerifyValidXMLResponse(IN BSTR * pbstrXML, IN LPWSTR pszRedirURL, IN DWORD cchSize);
    HRESULT _CheckInCache(IN LPWSTR pwzCacheURL, OUT BSTR * pbstrXML);
    HRESULT _CheckInCacheAndAddHash(IN LPCWSTR pwzDomain, IN BSTR bstrEmail, IN LPCSTR pszSubdir, IN LPWSTR pwzCacheURL, IN DWORD cchSize, IN BSTR bstrXMLRequest, OUT BSTR * pbstrXML);
    HRESULT _CacheResults(IN LPCWSTR pwzCacheURL, IN BSTR bstrXML);
    HRESULT _PerformAutoDiscovery(IN BSTR bstrEmailAddress, IN DWORD dwFlags, IN BSTR bstrXMLRequest, OUT IXMLDOMDocument ** ppXMLResponse);
    HRESULT _SendStatusMessage(UINT nStringID, LPCWSTR pwzArg);
    HRESULT _GetInfoFromDomainWithSubdirAndCacheCheck(IN BSTR bstrXMLRequest, IN BSTR bstrEmail, IN LPCWSTR pwzDomain, IN BSTR * pbstrXML, IN DWORD dwFlags, IN LPCSTR pszURLPath);
    HRESULT _UrlToComponents(IN LPCWSTR pszURL, IN BOOL * pfHTTPS, IN LPWSTR pszDomain, IN DWORD cchSize, IN LPSTR pszURLPath, IN DWORD cchSizeURLPath);

    virtual STDMETHODIMP _AsyncParseResponse(BSTR bstrEmail) {return S_OK;}

    virtual STDMETHODIMP _getPrimaryProviders(IN LPCWSTR pwzEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders);
    virtual STDMETHODIMP _getSecondaryProviders(IN LPCWSTR pwzEmailAddress, OUT IAutoDiscoveryProvider ** ppProviders, IN DWORD dwFlags);

    DWORD _AutoDiscoveryUIThreadProc(void);
    static DWORD CALLBACK AutoDiscoveryUIThreadProc(LPVOID pvThis) { return ((CAccountDiscoveryBase *) pvThis)->_AutoDiscoveryUIThreadProc(); };

    // Private Member Variables
    int                     m_cRef;

    HINTERNET               m_hInternetSession;

    // Async State
    HWND                    m_hwndAsync;
    UINT                    m_wMsgAsync;
    DWORD                   m_dwFlagsAsync;
    BSTR                    m_bstrEmailAsync;
    BSTR                    m_bstrXMLRequest;
    HANDLE                  m_hCreatedBackgroundTask;    // Handle to wait for background thread to start up.
    HRESULT                 m_hrSuccess;                 // Did the AutoDiscovery process succeed?

    HDPA                    m_hdpaPrimary;               // The Servers to contact.  Contains LPCWSTRs
    HDPA                    m_hdpaSecondary;             // The Servers to contact.  Contains LPCWSTRs
};





class CADProviders              : public CImpIDispatch
                                , public IAutoDiscoveryProvider
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IAutoDiscoveryProvider ***
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN VARIANT varIndex, OUT BSTR * pbstr);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CADProviders(IN HDPA hdpa, IN IUnknown * punkParent);
    virtual ~CADProviders(void);

    // Private Member Variables
    int                     m_cRef;

    HDPA                    m_hdpa;            // This contains LPWSTRs that contain servers
    IUnknown *              m_punkParent;      // We hold on to this guy to keep m_hdpa alive

    // Private Member Functions

    // Friend Functions
    friend HRESULT CADProviders_CreateInstance(IN HDPA hdpa, IN IUnknown * punkParent, OUT IAutoDiscoveryProvider ** ppProvider);
};



#endif // _FILE_H_AUTODISCOVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\cobjsafe.h ===
#ifndef _COBJSAFE_H_
#define _COBJSAFE_H_

// Static functions of interest to others
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
HRESULT MakeSafeForScripting(IUnknown **punk); // returns TRUE if punk is safe for scripting

class CObjectSafety : public IObjectSafety
{
public:
    CObjectSafety() : _dwSafetyOptions(0) { }

    // IUnknown (we multiply inherit from IUnknown, disambiguate here)
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    
    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
    
protected:
    DWORD           _dwSafetyOptions;   // IObjectSafety IID_IDispatch options

};
   
#endif // _COBJSAFE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\cobjsafe.cpp ===
#include "priv.h"

#include <comcat.h>
#include <hliface.h>
#include <mshtml.h>
#include <objsafe.h>
#include <perhist.h>
#include "cobjsafe.h"

// a default isafetyobject that we generally would use...  marks 
// deals with IDispatch 


HRESULT CObjectSafety::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (IsEqualIID(riid, IID_IDispatch))
    {
        *pdwEnabledOptions = _dwSafetyOptions;
    }
    else
    {
        ::DefaultGetSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
    }

    return S_OK;
}


HRESULT CObjectSafety::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch))
    {
        _dwSafetyOptions = (_dwSafetyOptions & ~dwOptionSetMask) |
                           (dwEnabledOptions & dwOptionSetMask);
        return S_OK;
    }
    else
    {
        return ::DefaultSetSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);
    }
}



// *** IObjectSafety
//
// A couple static functions called by sitemap (and webbrowser).
// These are static so anyone else in this dll who has an OC
// that's always safe can just call them.
//
// These functions say we are safe for these three interfaces we implement
//  IID_IDispatch
//  IID_IPersistStream
//  IID_IPersistPropertyBag
//
// The WebBrowser OC handles IDispatch differently.
//
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = 0;
    *pdwEnabledOptions = 0;

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistPropertyBag) ||
        IsEqualIID(riid, IID_IPersistHistory))
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }

    return S_OK;
}

HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistHistory) ||
        IsEqualIID(riid, IID_IPersistPropertyBag))
    {
        return S_OK;
    }

    return E_FAIL;
}


// When CWebBrowserOC is in the safe for scripting mode, we can't give out
// anyone else's IDispatch that is not also safe for scripting.
// This function encapsulates the basic functionality needed by both
// MakeSafeScripting and MakeSafeForInitializing (which we don't use)
BOOL MakeSafeFor(
IUnknown *punk,                 // object to test for safety
REFCATID catid,                 // category of safety
REFIID riid,                    // interface on which safety is desired
DWORD dwXSetMask,               // options to set
DWORD dwXOptions                // options to make safe for
                                    // (either INTERFACESAFE_FOR_UNTRUSTED_CALLER or
                                    //  INTERFACESAFE_FOR_UNTRUSTED_DATA)
)
{
    HRESULT hres;

    // first try IObjectSafety
    IObjectSafety *posafe;
    if (SUCCEEDED(punk->QueryInterface(IID_IObjectSafety, (LPVOID*) &posafe)))
    {
        hres = posafe->SetInterfaceSafetyOptions(riid, dwXSetMask, dwXOptions);
        posafe->Release();

        if (SUCCEEDED(hres))
            return TRUE;
    }

    // check the registry for "safe for scripting" component category

    // we need the classid -- get it thru IPersist
    CLSID clsid;
    IPersist *ppersist;
    hres = punk->QueryInterface(IID_IPersist, (LPVOID*) &ppersist);
    if (SUCCEEDED(hres))
    {
        hres = ppersist->GetClassID(&clsid);
        ppersist->Release();
    }
    if (FAILED(hres))
    {
        // trace from shdocvw, was TF_SHDCONTROL
        TraceMsg(TF_ALWAYS, "MakeSafeForScripting - object doesn't have IPersist!");
        return FALSE;
    }

    // Create the category manager
    ICatInformation *pcatinfo;
    hres = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                            NULL, CLSCTX_INPROC_SERVER,
                            IID_ICatInformation, (LPVOID*) &pcatinfo);
    if (FAILED(hres))
        return FALSE;

    // Ask if the object belongs to the specified category
    CATID rgcatid[1];
    rgcatid[0] = catid;

    hres = pcatinfo->IsClassOfCategories(clsid, 1, rgcatid, 0, NULL);
    pcatinfo->Release();

    return (hres==S_OK) ? TRUE : FALSE;;	
}

HRESULT MakeSafeForScripting(IUnknown** ppDisp)
{
    HRESULT hres = S_OK;

    if (!MakeSafeFor(*ppDisp, CATID_SafeForScripting, IID_IDispatch,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER))
    {
        // trace from shdocvw, was TF_SHDCONTROL
        TraceMsg(TF_ALWAYS, "MakeSafeForScripting - IDispatch not safe");

        (*ppDisp)->Release();
        *ppDisp = NULL;
        hres = E_FAIL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\cowsite.cpp ===
#include "priv.h"
#pragma hdrstop

#include "cowsite.h"

HRESULT CObjectWithSite::SetSite(IUnknown *punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}

HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

class CObjectWithSite : public IObjectWithSite
{
public:
    CObjectWithSite()  {_punkSite = NULL;};
    virtual ~CObjectWithSite() {ATOMICRELEASE(_punkSite);}

    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

protected:
    IUnknown*   _punkSite;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\debug.cpp ===
// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "AUTODISC"
#define SZ_MODULE           "AUTODISC"
#define DECLARE_DEBUG

void AssertMsg(BOOL fCondition, LPCSTR pszMessage, ...)
{
    ASSERT(fCondition);
}

void TraceMsg(DWORD dwFlags, LPCSTR pszMessage, ...)
{
}

#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define DECL_CRTFREE.
// (CPP_FUNCTIONS is the old name.)
//

#if defined(__cplusplus) && (defined(CPP_FUNCTIONS) || defined(DECL_CRTFREE))

#ifndef UNIX

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return (LPVOID)LocalAlloc(LPTR, nSize);
}

void  __cdecl operator delete(void *pv)
{
    //delete and LocalFree both handle NULL, others don't
    //If changed to GlobalFree or HeapFree - must check for NULL here
    LocalFree((HLOCAL)pv);
}
#endif

extern "C" int __cdecl _purecall(void) 
{
#ifdef ASSERT_MSG
    ASSERT_MSG(0, "purecall() hit");
#endif

#ifdef DEBUG
    DebugBreak();
#endif // DEBUG

    return 0;
}

#endif  // DECL_CRTFREE


#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\dllload.h ===
#ifndef _DLLLOAD_H_
#define _DLLLOAD_H_

#include <wininet.h>
#include <winineti.h>

#endif // _DLLLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\dllload.cpp ===
#include "priv.h"
#include <wininet.h>

#pragma warning(disable:4229)  // No warnings when modifiers used on data

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_ORD_VOID     
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID     
//
// 


/**********************************************************************/

void _GetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
#ifdef DEBUG
    CHAR szProcD[MAX_PATH];
    if (HIWORD(pszProc)) {
        lstrcpynA(szProcD, pszProc, ARRAYSIZE(szProcD));
    } else {
        wnsprintfA(szProcD, ARRAYSIZE(szProcD), "(ordinal %d)", LOWORD(pszProc));
    }
#endif // DEBUG
    // If it's already loaded, return.
    if (*ppfn) {
    return;
    }

    if (*phinst == NULL) {
#ifdef DEBUG
    TraceMsg(TF_WMOTHER, "DLLLOAD: Loading %s for the first time for %s", pszDLL, szProcD);
    
    if (g_dwBreakFlags & 0x00000080)
    {
        DebugBreak();
    }
#endif // DEBUG
    *phinst = LoadLibraryA(pszDLL);
    if (*phinst == NULL) {
        return;
    }
    }

#ifdef DEBUG
    TraceMsg(TF_WMOTHER, "DLLLOAD: GetProc'ing %s from %s for the first time", pszDLL, szProcD);
#endif // DEBUG
    *ppfn = GetProcAddress(*phinst, pszProc);
}

/*----------------------------------------------------------
Purpose: Performs a loadlibrary on the DLL only if the machine
     has the integrated shell installation.

*/
void _SHGetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    _GetProcFromDLL(phinst, pszDLL, ppfn, pszProc);
}

#define DELAY_LOAD_MAP(_hinst, _dll, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_MAP_HRESULT(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, HRESULT, _fnpriv, _fn, _args, _nargs, E_FAIL)
#define DELAY_MAP_DWORD(_hinst, _dll, _fnpriv, _fn, _args, _nargs) DELAY_LOAD_MAP(_hinst, _dll, DWORD, _fnpriv, _fn, _args, _nargs, 0)


#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err)    DELAY_LOAD_MAP(_hinst, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_DWORD(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, DWORD, _fn, _args, _nargs, 0)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, INT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}

//
// For private entrypoints exported by ordinal.
// 

#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_ORD_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs)


#define DELAY_LOAD_ORD_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _GetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}


//
//  Private exports by ordinal for integrated-shell installs
//


#define DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
    return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}
    
#define DELAY_LOAD_SHELL(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_SHELL_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)


#define DELAY_LOAD_SHELL_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
    _pfn##_fn _nargs;       \
    return;                     \
}



/**********************************************************************/
/**********************************************************************/
#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // for __endexcept

#pragma warning (disable:4096)      // '__cdecl' must be used with '...'
#pragma warning (disable:4201)      // nonstandard extension used : nameless struct/union
#pragma warning (disable:4115)      // named type definition in parentheses

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR FAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR FAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR FAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR FAR c_wszRip[] = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR FAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  FAR c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  FAR c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  FAR c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRip[] = SZ_MODULE "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  FAR c_szRipMsg[] = SZ_MODULE "  RIP: ";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR FAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR FAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#if !defined(UNIX) || (defined(UNIX) && !defined(NOSHELLDEBUG))

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
#undef _ASSERTE             // we substitute this ATL macro
#endif

#endif // !UNIX


// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_qwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern ULONGLONG g_qwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ASSERT           0x00000001      // Break on assertions
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
#define BF_THR              0x00000100      // Break when THR() receives a failure
#define BF_RIP              0x00000200      // Break on RIPs
#define BF_LEAKS            0x80000000      // Break on detecting a leak

// Trace flags for g_qwTraceFlags
#define TF_ALWAYS           0xFFFFFFFFFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
#define TF_MEMUSAGE                       0x0000000100000000      
#define TF_KEEP_ALLOCATION_STACKS         0x0000000200000000      
// (Upper 28 bits reserved for custom use per-module)

#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

// Old, archaic debug flags.  
// APPCOMPAT (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.

#ifdef DEBUG

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                _asm int 3                              \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
        } while (gAlwaysAssert);                        \
    }
#else
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                DebugBreak();                           \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
            __endexcept                                 \
        } while (gAlwaysAssert);                        \
    }
#endif

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

void CDECL CcshellFuncMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);


void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#ifdef UNICODE
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#else
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#endif

#endif // DEBUG



// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

// The old Win95 code used to use "Assert()".  We discourage the use
// of this macro now because it is not msdev-friendly.
#ifdef DISALLOW_Assert
#define Assert(f)        Dont_use_Assert___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#endif

#else  // DEBUG

#define ASSERT(f)
#define Assert(f)

#endif // DEBUG



// ASSERTMSG(f, szFmt, args...)
//
//   Behaves like ASSERT, except it prints the wsprintf-formatted message
//   instead of the file and line number.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CcshellAssertMsg        CcshellAssertMsgW
#else
#define CcshellAssertMsg        CcshellAssertMsgA
#endif

#define ASSERTMSG           CcshellAssertMsg

#else  // DEBUG

#define ASSERTMSG       1 ? (void)0 : (void)

#endif // DEBUG



// EVAL(f)
//
//   Behaves like ASSERT().  Evaluates the expression (f).  The expression 
//   is always evaluated, even in retail builds.  But the macro only asserts 
//   in the debug build.  This macro may be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
//   Do *not* use EVAL() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE), 0))

#else  // DEBUG

#define EVAL(exp)       ((exp) != 0)

#endif // DEBUG



// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//      welcome.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//
#ifdef DEBUG

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
BOOL CDECL CcshellRipMsgA(BOOL bRip, LPCSTR pszMsg, ...);
BOOL CDECL CcshellRipMsgW(BOOL bRip, LPCSTR pszMsg, ...);


#ifdef UNICODE
#define CcshellRip      CcshellRipW
#define CcshellRipMsg   CcshellRipMsgW
#else
#define CcshellRip      CcshellRipA
#define CcshellRipMsg   CcshellRipMsgA
#endif

#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG          CcshellRipMsg

#else  // DEBUG

#define RIP(f)
#define RIPMSG          1 ? (void)0 : (void)

#endif // DEBUG



// TraceMsg(dwMask, sz, args...) 
//
//   Generate wsprintf-formatted message using the specified trace dwMask.
//   dwMask may be one of the predefined bits:
//
//      TF_ERROR    - display "err <MODULE>  <string>"
//      TF_WARNING  - display "wn  <MODULE>  <string>"
//      TF_GENERAL  - display "t   <MODULE>  <string>"
//      TF_ALWAYS   - display "t   <MODULE>  <string>" regardless of g_qwTraceFlags.
//
//   or it may be a custom bit (any of the upper 28 bits).
//
//   The g_qwTraceFlags global governs whether the message is displayed (based
//   upon the dwMask parameter).
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   In addition to squirting the trace message, you may optionally cause
//   the trace message to stop if you need to trace down the source of
//   an error.  The BF_ONERRORMSG and BF_ONWARNMSG bits may be set in
//   g_dwBreakFlags to make TraceMsg stop when a TF_ERROR or TF_WARNING
//   message is displayed.  But typically these bits are disabled.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       only TF_ALWAYS and TF_ERROR messages spew
//      Full debug builds:  spew
//
#ifdef DEBUG

UINT GetStack(UINT nDepth, CHAR *szBuffer, UINT nBufferLength);
void CDECL CcshellDebugMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _DebugMsgA(ULONGLONG flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(ULONGLONG flag, LPCWSTR psz, ...);
#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define _DebugMsg               _DebugMsgA
#endif

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg

#endif

#else  // DEBUG

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#define TraceMsg        1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)

#endif // DEBUG



// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// TW32(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//   TW32 keys off the failure code of the Win32 error code.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#ifdef DEBUG

EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C DWORD   TraceWin32(DWORD dwTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

#define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
#define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
#define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
#define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))
#define TW32(x)     (TraceWin32((x), #x, __FILE__, __LINE__))

#else  // DEBUG

#define THR(x)          (x)
#define TBOOL(x)        (x)
#define TINT(x)         (x)
#define TPTR(x)         (x)
#define TW32(x)         (x)

#endif // DEBUG



// DBEXEC(flg, expr)
//
//   under DEBUG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DEBUG, does nothing (and does not evaluate either of its args)
//
#ifdef DEBUG

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

#else  // DEBUG

#define DBEXEC(flg, expr)   /*NOTHING*/

#endif // DEBUG


// string and buffer whacking functions
//
#ifdef DEBUG

EXTERN_C void DEBUGWhackPathBufferA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringW(LPWSTR psz, UINT cch);

#else // DEBUG

#define DEBUGWhackPathBufferA(psz, cch)
#define DEBUGWhackPathBufferW(psz, cch)
#define DEBUGWhackPathStringA(psz, cch)
#define DEBUGWhackPathStringW(psz, cch)

#endif // DEBUG

#ifdef UNICODE
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferW
#define DEBUGWhackPathString DEBUGWhackPathStringW
#else
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferA
#define DEBUGWhackPathString DEBUGWhackPathStringA
#endif


// Some trickery to map ATL debug macros to ours, so ATL code that stops
// or spews in our code will look like the rest of our squirties.

#ifdef DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
#define ShellAtlTrace   ShellAtlTraceW
#else
#define ShellAtlTrace   ShellAtlTraceA
#endif
// These are turned off because they normally don't give
// feedback of error cases and so many fire that they
// swamp out other useful debug spew.
//#define ATLTRACE            ShellAtlTrace
#endif

#else  // DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)

// We map ATLTRACE macros to our functions
#define ATLTRACE            1 ? (void)0 : (void)
#endif

#endif // DEBUG


// ------ Stay away from these macros below ----------
// APPCOMPAT (scotth):  remove these by 8/15/98.  They should not be used anymore. 
#ifdef DEBUG

#define AssertE(f)          ASSERT(f)
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg
#else  // DEBUG

#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define FullDebugMsg    1 ? (void)0 : (void)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define ASSERT_MSGW     1 ? (void)0 : (void)
#define ASSERT_MSG      1 ? (void)0 : (void)

#endif // DEBUG
// ------ Stay away from these macros above ----------



// It's necessary to find when classes that were designed to be single threaded are used
// across threads so they can be fixed to be multithreaded.  These asserts will point
// out such cases.
#ifdef DEBUG
#define ASSERT_SINGLE_THREADED              AssertMsg(_dwThreadIDForSingleThreadedAssert == GetCurrentThreadId(), TEXT("MULTI-THREADED BUG: This class is being used by more than one thread, but it's not thread safe."))
#define INIT_SINGLE_THREADED_ASSERT         _dwThreadIDForSingleThreadedAssert = GetCurrentThreadId();
#define SINGLE_THREADED_MEMBER_VARIABLE     DWORD _dwThreadIDForSingleThreadedAssert;
#else // DEBUG
#define ASSERT_SINGLE_THREADED              NULL;
#define INIT_SINGLE_THREADED_ASSERT         NULL;
#define SINGLE_THREADED_MEMBER_VARIABLE     
#endif // DEBUG



#ifdef DEBUG

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//
#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define FUNC_MSG        1 ? (void)0 : (void)


#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG



// COMPILETIME_ASSERT(f)
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:


#else  // NOSHELLDEBUG

#ifdef UNIX
#include <crtdbg.h>
#define ASSERT(f)	_ASSERT(f)
#include <mainwin.h>
#define TraceMsg(type, sformat)  DebugMessage(0, sformat)
#define TraceMSG(type, sformat, args)  DebugMessage(0, sformat, args)
#endif

#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG

// I'm a lazy typist...
#define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\dllmain.cpp ===
/*****************************************************************************\
    FILE: dllmain.cpp

    DESCRIPTION:
       Power Toy to add encryption option to Context menus in the shell.  This
    file will take care of the DLL lifetime.

    BryanSt 8/12/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include "objcache.h"

/*****************************************************************************
 *
 *  Dynamic Globals.  There should be as few of these as possible.
 *
 *  All access to dynamic globals must be thread-safe.
 *
 *****************************************************************************/

ULONG g_cRef = 0;           // Global reference count
CRITICAL_SECTION g_csDll;   // The shared critical section


#ifdef DEBUG
DWORD g_TlsMem = 0xffffffff;
#endif // DEBUG

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
//OBJECT_ENTRY(CLSID_MsgListView, CMsgListView)
END_OBJECT_MAP()

/*****************************************************************************
 *
 *  DllAddRef / DllRelease
 *
 *  Maintain the DLL reference count.
 *
 *****************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  DllGetClassObject
 *
 *  OLE entry point.  Produces an IClassFactory for the indicated GUID.
 *
 *  The artificial refcount inside DllGetClassObject helps to
 *  avoid the race condition described in DllCanUnloadNow.  It's
 *  not perfect, but it makes the race window much smaller.
 *
 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres;

    DllAddRef();
    if (0)//CLSID_MsgListView == rclsid)
    {
        hres = _Module.GetClassObject(rclsid, riid, ppvObj);
    }
    else
    {
        hres = CClassFactory_Create(rclsid, riid, ppvObj);
    }
    DllRelease();
    return hres;
}

/*****************************************************************************
 *
 *  DllCanUnloadNow
 *
 *  OLE entry point.  Fail iff there are outstanding refs.
 *
 *  There is an unavoidable race condition between DllCanUnloadNow
 *  and the creation of a new IClassFactory:  Between the time we
 *  return from DllCanUnloadNow() and the caller inspects the value,
 *  another thread in the same process may decide to call
 *  DllGetClassObject, thus suddenly creating an object in this DLL
 *  when there previously was none.
 *
 *  It is the caller's responsibility to prepare for this possibility;
 *  there is nothing we can do about it.
 *
 *****************************************************************************/

STDMETHODIMP DllCanUnloadNow(void)
{
    HRESULT hres;

    ENTERCRITICAL;

    hres = g_cRef ? S_FALSE : S_OK;

    if (S_OK == hres)
    {
        hres = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
    }

    TraceMsg(TF_WMOTHER, "DllCanUnloadNow() returning hres=%#08lx. (S_OK means yes)", hres);

    LEAVECRITICAL;

    return hres;
}

/*
//  Table of all window classes we register so we can unregister them
//  at DLL unload.
const LPCTSTR c_rgszClasses[] = {
//    g_cszPopServiceWndClass
};

//  Since we are single-binary, we have to play it safe and do
//  this cleanup (needed only on NT, but harmless on Win95).
#define UnregisterWindowClasses() \
    SHUnregisterClasses(HINST_THISDLL, c_rgszClasses, ARRAYSIZE(c_rgszClasses))
*/

/*****************************************************************************
 *
 *  Entry32
 *
 *  DLL entry point.
 *
 *  BUGBUG -- On a thread detach, must check if the thread owns any
 *  global timeouts.  If so, we must transfer the timeout to another
 *  thread or something.
 *
 *****************************************************************************/
STDAPI_(BOOL) DllEntry(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    static s_hresOle = E_FAIL;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef DEBUG
            CcshellGetDebugFlags();
#endif

            InitializeCriticalSection(&g_csDll);
            InitializeCriticalSection(&g_hCachedObjectSection);

            g_hinst = hinst;
//            _Module.Init(ObjectMap, hinst, &LIBID_AutoDiscovery);
            DisableThreadLibraryCalls(hinst);
            break;
        }

        case DLL_PROCESS_DETACH:
        {
//            _Module.Term();

//            UnregisterWindowClasses();
//            PurgeObjectCache();
            DeleteCriticalSection(&g_hCachedObjectSection);

            DeleteCriticalSection(&g_csDll);
            break;
        }
    }
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\dllreg.cpp ===
// dllreg.cpp -- autmatic registration and unregistration
//
#include "priv.h"

#include <advpub.h>
#include <comcat.h>
#include <autodiscovery.h>       // For LIBID_AutoDiscovery

// helper macros

// ADVPACK will return E_UNEXPECTED if you try to uninstall (which does a registry restore)
// on an INF section that was never installed.  We uninstall sections that may never have
// been installed, so this MACRO will quiet these errors.
#define QuietInstallNoOp(hr)   ((E_UNEXPECTED == hr) ? S_OK : hr)


BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL fResult = FALSE;

    // convert the libid into a string.
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKey(HKEY_CLASSES_ROOT, TEXT("TypeLib"), &hk) == ERROR_SUCCESS) {
        fResult = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }
    
    return fResult;
}



HRESULT MyRegTypeLib(void)
{
    HRESULT hr = S_OK;
    ITypeLib *pTypeLib;
    DWORD   dwPathLen;
    TCHAR   szTmp[MAX_PATH];
#ifdef UNICODE
    WCHAR   *pwsz = szTmp; 
#else
    WCHAR   pwsz[MAX_PATH];
#endif

    // Load and register our type library.
    dwPathLen = GetModuleFileName(HINST_THISDLL, szTmp, ARRAYSIZE(szTmp));
#ifndef UNICODE
    if (SHAnsiToUnicode(szTmp, pwsz, MAX_PATH)) 
#endif
    {
        hr = LoadTypeLib(pwsz, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library as we had some old junk that
            // was registered by a previous version of OleAut32, which is now causing
            // the current version to not work on NT...
            UnregisterTypeLibrary(&LIBID_AutoDiscovery);
            hr = RegisterTypeLib(pTypeLib, pwsz, NULL);

            if (FAILED(hr))
            {
                TraceMsg(TF_ALWAYS, "AUTODISC: RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_ALWAYS, "AUTODISC: LoadTypeLib failed (%x)", hr);
        }
    } 
#ifndef UNICODE
    else {
        hr = E_FAIL;
    }
#endif

    return hr;
}



/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "NO_LONGER_USED", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            szIEPath[0] = 0;
            hr = pfnri(HINST_THISDLL, szSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    hr = CallRegInstall("DLL_RegInstall");

#ifdef FEATURE_MAILBOX
    hr = CallRegInstall("DLL_RegInstallMailBox");
#else // FEATURE_MAILBOX
    CallRegInstall("DLL_RegUnInstallMailBox");
#endif // FEATURE_MAILBOX

    MyRegTypeLib();
    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    // UnInstall the registry values
    hr = CallRegInstall("DLL_RegUnInstall");
    CallRegInstall("DLL_RegUnInstallMailBox");
    UnregisterTypeLibrary(&LIBID_AutoDiscovery);

    return hr;
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

Description: Note that this function has special error handling.
             The function will keep hrExternal with the worse error
             but will only stop executing util the internal error (hr)
             gets really bad.  This is because we need the external
             error to catch incorrectly authored INFs but the internal
             error to be robust in attempting to install other INF sections
             even if one doesn't make it.
*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\dpa.h ===
#ifndef GUARD_D70787804D9C11d28784F6E920524153
#define GUARD_D70787804D9C11d28784F6E920524153

#include "comctrlp.h"

//  The Ex versions of EnumCallback, DestroyCallback, Sort, Search, etc.
//  do stricter type checking to make sure that the reference data /
//  parameter matches both on the calling side and the callback side.


template <class T> class CDPA
{

public:
    // Typedefs
    typedef int (CALLBACK *_PFNDPAENUMCALLBACK)(T *p, LPVOID pData);
    typedef int (CALLBACK *_PFNDPACOMPARE)(T *p1, T *p2, LPARAM lParam);

    // Functions

    CDPA() {}
    CDPA(HDPA hdpa) {m_hdpa = hdpa;}

    HDPA GetHDPA() {return m_hdpa;}
    void SetHDPA(const HDPA hdpa) {m_hdpa = hdpa;}

    operator bool () { return m_hdpa != NULL; }

    BOOL    Create(int cItemGrow)
    {return (m_hdpa = DPA_Create(cItemGrow)) != NULL;}

    BOOL    CreateEx(int cpGrow, HANDLE hheap)
    {return (m_hdpa = DPA_CreateEx(cpGrow, hheap)) != NULL;}

    BOOL    Destroy()
    {return DPA_Destroy(m_hdpa);}

    HDPA    Clone(HDPA hdpaNew)
    {return DPA_Clone(m_hdpa, hdpaNew);}

    T*      GetPtr(INT_PTR i)
    {return (T*) DPA_GetPtr(m_hdpa, i);}

    int     GetPtrIndex(T* p)
    {return DPA_GetPtrIndex(m_hdpa, (LPVOID) p);}

    BOOL    Grow(int cp)
    {return DPA_Grow(m_hdpa, cp);}

    BOOL    SetPtr(int i, T* p)
    {return DPA_SetPtr(m_hdpa, i, (LPVOID) p);}

    int     InsertPtr(int i, T* p)
    {return DPA_InsertPtr(m_hdpa, i, (LPVOID) p);}

    T*      DeletePtr(int i)
    {return (T*) DPA_DeletePtr(m_hdpa, i);}

    BOOL    DeleteAllPtrs()
    {return DPA_DeleteAllPtrs(m_hdpa);}

    void    EnumCallback(_PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
    {DPA_EnumCallback(m_hdpa, (PFNDPAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    EnumCallbackEx(int (CALLBACK *pfnCB)(T* p, T2 pData), T2 pData)
    {EnumCallback((_PFNDPAENUMCALLBACK)pfnCB, reinterpret_cast<LPVOID>(pData));}

    void    DestroyCallback(_PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
    {DPA_DestroyCallback(m_hdpa, (PFNDPAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    DestroyCallbackEx(int (CALLBACK *pfnCB)(T* p, T2 pData), T2 pData)
    {DestroyCallback((_PFNDPAENUMCALLBACK)pfnCB, reinterpret_cast<LPVOID>(pData));}

    int     GetPtrCount()
    {return DPA_GetPtrCount(m_hdpa);}

    T*      GetPtrPtr()
    {return (T*)DPA_GetPtrPtr(m_hdpa);}

    T*&     FastGetPtr(int i)
    {return (T*&)DPA_FastGetPtr(m_hdpa, i);}
    
    int     AppendPtr(T* pitem)
    {return DPA_AppendPtr(m_hdpa, (LPVOID) pitem);}

#ifdef __IStream_INTERFACE_DEFINED__
    HRESULT LoadStream(PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData)
    {return DPA_LoadStream(&m_hdpa, pfn, pstream, pvInstData);}

    HRESULT SaveStream(PFNDPASTREAM pfn, IStream * pstream, LPVOID pvInstData)
    {return DPA_SaveStream(m_hdpa, pfn, pstream, pvInstData);}
#endif

    BOOL    Sort(_PFNDPACOMPARE pfnCompare, LPARAM lParam)
    {return DPA_Sort(m_hdpa, (PFNDPACOMPARE)pfnCompare, lParam);}

    template<class T2>
    BOOL    SortEx(int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam), T2 lParam)
    {return Sort((_PFNDPACOMPARE)pfnCompare, reinterpret_cast<LPARAM>(lParam));}

    // Merge not supported through this object; use DPA_Merge

    int     Search(T* pFind, int iStart, _PFNDPACOMPARE pfnCompare,
                    LPARAM lParam, UINT options)
    {return DPA_Search(m_hdpa, (LPVOID) pFind, iStart, (PFNDPACOMPARE)pfnCompare, lParam, options);}

    template<class T2>
    int     SearchEx(T* pFind, int iStart,
                    int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam),
                    T2 lParam, UINT options)
    {return Search(pFind, iStart, (_PFNDPACOMPARE)pfnCompare, reinterpret_cast<LPARAM>(lParam), options);}
    
    int     SortedInsertPtr(T* pFind, int iStart, _PFNDPACOMPARE pfnCompare,
                    LPARAM lParam, UINT options, T* pitem)
    {return DPA_SortedInsertPtr(m_hdpa, (LPVOID) pFind, iStart, (PFNDPACOMPARE)pfnCompare, lParam, options, (LPVOID) pitem);}

    template<class T2>
    int     SortedInsertPtrEx(T* pFind, int iStart,
                    int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam),
                    T2 lParam, UINT options, T* pitem)
    {return SortedInsertPtr(pFind, iStart, (_PFNDPACOMPARE)pfnCompare,
                    reinterpret_cast<LPARAM>(lParam), options, pitem);}

private:
    HDPA m_hdpa;
};

template <class T> class CDSA
{
public:
    // Typedefs
    typedef int (CALLBACK *_PFNDSAENUMCALLBACK)(T *p, LPVOID pData);
    typedef int (CALLBACK *_PFNDSACOMPARE)(T *p1, T *p2, LPARAM lParam);

    // Functions

    CDSA() {}
    CDSA(HDSA hdsa) {m_hdsa = hdsa;}

    HDSA GetHDSA() {return m_hdsa;}
    void SetHDSA(const HDSA hdsa) {m_hdsa = hdsa;}

    operator bool () { return m_hdsa != NULL; }

    BOOL    Create(int cItemGrow)
    {return (m_hdsa = DSA_Create(sizeof(T), cItemGrow)) != NULL;}

    BOOL    Destroy()
    {BOOL fRet = DSA_Destroy(m_hdsa); m_hdsa = NULL; return fRet;}

    BOOL    GetItem(int i, T* pitem)
    {return DSA_GetItem(m_hdsa, i, (LPVOID)pitem);}

    T*      GetItemPtr(int i)
    {return (T*)DSA_GetItemPtr(m_hdsa, i);}

    BOOL    SetItem(int i, T* pitem)
    {return DSA_SetItem(m_hdsa, i, (LPVOID)pitem);}

    int     InsertItem(int i, T* pitem)
    {return DSA_InsertItem(m_hdsa, i, (LPVOID)pitem);}

    BOOL    DeleteItem(int i)
    {return DSA_DeleteItem(m_hdsa, i);}

    BOOL    DeleteAllItems()
    {return DSA_DeleteAllItems(m_hdsa);}

    void    EnumCallback(_PFNDSAENUMCALLBACK pfnCB, LPVOID pData)
    {DSA_EnumCallback(m_hdsa, (PFNDSAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    EnumCallbackEx(int (CALLBACK *pfnCB)(T *p, T2 pData), T2 pData)
    {EnumCallback((_PFNDSAENUMCALLBACK)pfnCB, reinterpret_cast<LPVOID>(pData));}

    void    DestroyCallback(_PFNDSAENUMCALLBACK pfnCB, LPVOID pData)
    {DSA_DestroyCallback(m_hdsa, (PFNDSAENUMCALLBACK)pfnCB, pData); m_hdsa = NULL;}

    template<class T2>
    void    DestroyCallbackEx(int (CALLBACK *pfnCB)(T *p, T2 pData), T2 pData)
    {DestroyCallback((_PFNDSAENUMCALLBACK)pfnCB, reinterpret_cast<LPVOID>(pData));}

    int     GetItemCount()
    {return DSA_GetItemCount(m_hdsa);}

    int     AppendItem(T* pitem)
    {return DSA_AppendItem(m_hdsa, (LPVOID)pitem);}

private:
    HDSA m_hdsa;
};


#endif // !GUARD_D70787804D9C11d28784F6E920524153
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\dspsprt.h ===
#ifndef __DSPSPRT_H__
#define __DSPSPRT_H__

// get ITypeInfo uuid/lcid out of type library
STDAPI GetTypeInfoFromLibId(LCID lcid, REFGUID libid,
    USHORT wVerMajor, USHORT wVerMinor, 
    REFGUID uuid, ITypeInfo **ppITypeInfo);

//
// Helper C++ class used to share code for the IDispatch implementations
//
// Inherit from this class passing this IDispatch's IID to the ctor
// 
class CImpIDispatch
{
    public:

        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;

    protected:
        CImpIDispatch(REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, REFIID riid);
        virtual ~CImpIDispatch(void);

        // For raising exceptions
        void Exception(WORD);

        // IDispatch members
        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    private:
        REFIID      m_riid;
        REFGUID     m_libid;
        USHORT      m_wVerMajor;
        USHORT      m_wVerMinor;

        ITypeInfo  *m_pITINeutral; // Cached Type information
};

#endif // __DSPSPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\dspsprt.cpp ===
#include "priv.h"
#pragma hdrstop

#include "dspsprt.h"

#define TF_IDISPATCH 0

EXTERN_C HINSTANCE g_hinst;

CImpIDispatch::CImpIDispatch(REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, REFIID riid) :
    m_libid(libid), m_wVerMajor(wVerMajor), m_wVerMinor(wVerMinor), m_riid(riid), m_pITINeutral(NULL)
{
    ASSERT(NULL == m_pITINeutral);
}

CImpIDispatch::~CImpIDispatch(void)
{
    ATOMICRELEASE(m_pITINeutral);
}

STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo = 1;
    return S_OK;
}

// helper function for pulling ITypeInfo out of our typelib
STDAPI GetTypeInfoFromLibId(LCID lcid, REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, 
                            REFGUID uuid, ITypeInfo **ppITypeInfo)
{
    *ppITypeInfo = NULL;        // assume failure

    ITypeLib *pITypeLib;
    HRESULT hr;
    USHORT wResID;

    if (!IsEqualGUID(libid, GUID_NULL))
    {
        // The type libraries are registered under 0 (neutral),
        // 7 (German), and 9 (English) with no specific sub-
        // language, which would make them 407 or 409 and such.
        // If you are sensitive to sub-languages, then use the
        // full LCID instead of just the LANGID as done here.
#ifdef DEBUG
        hr = E_FAIL;    // force load through GetModuleFileName(), to get fusion 1.0 support
#else
        hr = LoadRegTypeLib(libid, wVerMajor, wVerMinor, PRIMARYLANGID(lcid), &pITypeLib);
#endif
        wResID = 0;
    }
    else
    {
        // If libid is GUID_NULL, then get type lib from module and use wVerMajor as
        // the resource ID (0 means use first type lib resource).
        pITypeLib = NULL;
        hr = E_FAIL;
        wResID = wVerMajor;
    }

    // If LoadRegTypeLib fails, try loading directly with LoadTypeLib.
    if (FAILED(hr) && g_hinst)
    {
        WCHAR wszPath[MAX_PATH];
        GetModuleFileNameWrapW(g_hinst, wszPath, ARRAYSIZE(wszPath));
        // Append resource ID to path, if specified.
        if (wResID)
        {
            WCHAR wszResStr[10];
            wnsprintfW(wszResStr, ARRAYSIZE(wszResStr), L"\\%d", wResID);
            StrCatBuffW(wszPath, wszResStr, ARRAYSIZE(wszPath));
        }
        
        switch (PRIMARYLANGID(lcid))
        {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            hr = LoadTypeLib(wszPath, &pITypeLib);
            break;
        }
    }
    
    if (SUCCEEDED(hr))
    {
        // Got the type lib, get type info for the interface we want.
        hr = pITypeLib->GetTypeInfoOfGuid(uuid, ppITypeInfo);
        pITypeLib->Release();
    }
    return hr;
}


STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid, ITypeInfo **ppITypeInfo)
{
    *ppITypeInfo = NULL;

    if (0 != itInfo)
        return TYPE_E_ELEMENTNOTFOUND;

    // docs say we can ignore lcid if we support only one LCID
    // we don't have to return DISP_E_UNKNOWNLCID if we're *ignoring* it
    ITypeInfo **ppITI = &m_pITINeutral; // our cached typeinfo

    // Load a type lib if we don't have the information already.
    if (NULL == *ppITI)
    {
        ITypeInfo *pITIDisp;
        HRESULT hr = GetTypeInfoFromLibId(lcid, m_libid, m_wVerMajor, m_wVerMinor, m_riid, &pITIDisp);
        if (SUCCEEDED(hr))
        {
            // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
            // returns the ITypeInfo of the IDispatch-part only. We need to
            // find the ITypeInfo for the dual interface-part.
            //
            HREFTYPE hrefType;
            HRESULT hrT = pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType);
            if (SUCCEEDED(hrT))
            {
                hrT = pITIDisp->GetRefTypeInfo(hrefType, ppITI);
            }

            if (FAILED(hrT))
            {
                // I suspect GetRefTypeOfImplType may fail if someone uses
                // CImpIDispatch on a non-dual interface. In this case the
                // ITypeInfo we got above is just fine to use.
                *ppITI = pITIDisp;
            }
            else
            {
                pITIDisp->Release();
            }
        }

        if (FAILED(hr))
            return hr;
    }

    (*ppITI)->AddRef();
    *ppITypeInfo = *ppITI;
    return S_OK;
}

STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID)
{
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    //Get the right ITypeInfo for lcid.
    ITypeInfo *pTI;
    HRESULT hr = GetTypeInfo(0, lcid, &pTI);
    if (SUCCEEDED(hr))
    {
        hr = pTI->GetIDsOfNames(rgszNames, cNames, rgDispID);
        pTI->Release();
    }

#ifdef DEBUG
    TCHAR szParam[MAX_PATH] = TEXT("");
    if (cNames >= 1)
        SHUnicodeToTChar(*rgszNames, szParam, ARRAYSIZE(szParam));

    TraceMsg(TF_IDISPATCH, "CImpIDispatch::GetIDsOfNames(%s = %x) called hres(%x)",
            szParam, *rgDispID, hr);
#endif
    return hr;
}

STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid, 
                                   LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams, 
                                   VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE; // riid is supposed to be IID_NULL always

    IDispatch *pdisp;
    HRESULT hr = QueryInterface(m_riid, (void **)&pdisp);
    if (SUCCEEDED(hr))
    {
        //Get the ITypeInfo for lcid
        ITypeInfo *pTI;
        hr = GetTypeInfo(0, lcid, &pTI);
        if (SUCCEEDED(hr))
        {
            SetErrorInfo(0, NULL);  //Clear exceptions
    
            // This is exactly what DispInvoke does--so skip the overhead.
            hr = pTI->Invoke(pdisp, dispID, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            pTI->Release();
        }
        pdisp->Release();
    }
    return hr;
}

void CImpIDispatch::Exception(WORD wException)
{
    ASSERT(FALSE); // No one should call this yet
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\guids.cpp ===
/*****************************************************************************\
    FILE: guids.cpp

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.


    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/


#define INITGUID
#include "guids.h"

#include "priv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\emailassoc.h ===
/*****************************************************************************\
    FILE: EmailAssoc.h

    DESCRIPTION:
        This file implements email to application associations.

    BryanSt 3/14/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _EMAIL_ASSOCIATIONS_H
#define _EMAIL_ASSOCIATIONS_H
#ifdef FEATURE_EMAILASSOCIATIONS

#include "dllload.h"



//////////////////////////////////////
// EmailAccount
//////////////////////////////////////
HRESULT EmailAssoc_CreateEmailAccount(IN LPCWSTR pszEmailAddress, OUT HKEY * phkey);
HRESULT EmailAssoc_OpenEmailAccount(IN LPCWSTR pszEmailAddress, OUT HKEY * phkey);
HRESULT EmailAssoc_GetEmailAccountProtocol(IN HKEY hkey, IN LPWSTR pszProtocol, IN DWORD cchSize);
HRESULT EmailAssoc_SetEmailAccountProtocol(IN HKEY hkey, IN LPCWSTR pszProtocol);
HRESULT EmailAssoc_GetEmailAccountWebURL(IN HKEY hkey, IN LPWSTR pszURL, IN DWORD cchSize);
HRESULT EmailAssoc_SetEmailAccountWebURL(IN HKEY hkey, IN LPCWSTR pszURL);
HRESULT EmailAssoc_GetEmailAccountPreferredApp(IN HKEY hkey, IN LPWSTR pszMailApp, IN DWORD cchSize);
HRESULT EmailAssoc_SetEmailAccountPreferredApp(IN HKEY hkey, IN LPCWSTR pszMailApp);
HRESULT EmailAssoc_GetDefaultEmailAccount(IN LPWSTR pszProtocol, IN DWORD cchSize);
HRESULT EmailAssoc_SetDefaultEmailAccount(IN LPCWSTR pszProtocol);


//////////////////////////////////////
// MailApp
//////////////////////////////////////
HRESULT EmailAssoc_GetDefaultMailApp(IN LPWSTR pszMailApp, IN DWORD cchSize);
HRESULT EmailAssoc_SetDefaultMailApp(IN LPCWSTR pszMailApp);
HRESULT EmailAssoc_OpenMailApp(IN LPCWSTR pszMailApp, OUT HKEY * phkey);
HRESULT EmailAssoc_GetAppPath(IN HKEY hkey, IN LPTSTR pszAppPath, IN DWORD cchSize);
HRESULT EmailAssoc_GetAppCmdLine(IN HKEY hkey, IN LPTSTR pszCmdLine, IN DWORD cchSize);
HRESULT EmailAssoc_GetIconPath(IN HKEY hkey, IN LPTSTR pszIconPath, IN DWORD cchSize);
HRESULT EmailAssoc_GetFirstMailAppForProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp, IN DWORD cchSize);

BOOL EmailAssoc_DoesMailAppSupportProtocol(IN LPCWSTR pszMailApp, IN LPCWSTR pszProtocol);
HRESULT EmailAssoc_InstallLegacyMailAppAssociations(void);


//////////////////////////////////////
// Other
//////////////////////////////////////
HRESULT EmailAssoc_CreateWebAssociation(IN LPCWSTR pszEmail, IN IMailProtocolADEntry * pMailProtocol);
HRESULT EmailAssoc_GetEmailAccountGetAppFromProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp, IN DWORD cchSize);
HRESULT EmailAssoc_SetEmailAccountGetAppFromProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp);
HRESULT EmailAssoc_CreateStandardsBaseAssociation(IN LPCTSTR pszEmail, IN LPCTSTR pszProtocol);


#endif // FEATURE_EMAILASSOCIATIONS
#endif // _EMAIL_ASSOCIATIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\fromshell.h ===
/*****************************************************************************\
    FILE: fromshell.h

    DESCRIPTION:
        These declarations are from Copied Shell\{inc,lib}\ files.  I need
    to fork these since I moved out of the shell tree.

    BryanSt 4/10/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FROMSHELL_H
#define _FROMSHELL_H


// These declarations are from Copied Shell\{inc,lib}\ files
// ATOMICRELEASE
#ifndef ATOMICRELEASE
#ifdef __cplusplus
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#else
#define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#endif

// doing this as a function instead of inline seems to be a size win.
#ifdef NOATOMICRELESEFUNC
#define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#else
#define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#endif
#endif //ATOMICRELEASE



// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE


typedef UINT FAR *LPUINT;

// The following are declarations AutoDiscovery lost when it left the
// shell tree.
#define TF_ALWAYS                   0xFFFFFFFF

void TraceMsg(DWORD dwFlags, LPCSTR pszMessage, ...);
void AssertMsg(BOOL fCondition, LPCSTR pszMessage, ...);


//  IID_PPV_ARG(IType, ppType) 
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
//  IID_PPV_ARG_NULL(IType, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks a NULL between the
//      IID and PPV (for IShellFolder::GetUIObjectOf).
//
//  IID_X_PPV_ARG(IType, X, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks X between the
//      IID and PPV (for SHBindToObject).
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)

#define IN
#define OUT

#define ASSERT(condition)


// Convert an array name (A) to a generic count (c).
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

// General flag macros
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))


#define RECTWIDTH(rc)          ((rc).right - (rc).left)
#define RECTHEIGHT(rc)         ((rc).bottom - (rc).top)

#ifdef DEBUG
#define DEBUG_CODE(x)            x
#else // DEBUG
#define DEBUG_CODE(x)
#endif // DEBUG

#define HRESULT_TO_SCRIPT(hr)   ((S_OK == (hr)) ? S_OK : S_FALSE)
#define SUCCEEDED_SCRIPT(hr)    (S_OK == (hr))
#define FAILED_SCRIPT(hr)       (S_OK != (hr))
#define SCRIPT_TO_HRESULT(hr)   (((S_OK != (hr)) && (SUCCEEDED((hr)))) ? E_FAIL : hr)


////////////////
//  Critical section stuff
//
//  Helper macros that give nice debug support
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG






/////////////////////////////////////////////////////////////
// Are these even needed?
/////////////////////////////////////////////////////////////
#ifdef OLD_HLIFACE
#define HLNF_OPENINNEWWINDOW HLBF_OPENINNEWWINDOW
#endif // OLD_HLIFACE

#define ISVISIBLE(hwnd)  ((GetWindowStyle(hwnd) & WS_VISIBLE) == WS_VISIBLE)


#ifdef SAFERELEASE
#undef SAFERELEASE
#endif // SAFERELEASE
#define SAFERELEASE(p) ATOMICRELEASE(p)


#define IsInRange               InRange

//
// Neutral ANSI/UNICODE types and macros... 'cus Chicago seems to lack them
//

#ifdef  UNICODE
   typedef WCHAR TUCHAR, *PTUCHAR;

#else   /* UNICODE */

   typedef unsigned char TUCHAR, *PTUCHAR;
#endif /* UNICODE */


#endif // _FROMSHELL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\guids.h ===
/*****************************************************************************\
    FILE: guids.h

    DESCRIPTION:
        This file contains GUIDs that we couldn't get from the public headers
    for one reason or another.

    BryanSt 8/13/1999
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"

#ifndef MYGUIDS_H
#define MYGUIDS_H

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

//EXTERN_C const GUID FAR CLSID_MailBoxDeskBar;

// {ACFEEF34-7453-43ee-A6A6-8A8568FA176B} CLSID_MailBoxDeskBar
DEFINE_GUID(CLSID_MailBoxDeskBar, 0xacfeef34, 0x7453, 0x43ee, 0xa6, 0xa6, 0x8a, 0x85, 0x68, 0xfa, 0x17, 0x6b);

// NOTE: Eventually, we should move this into a \shell\published\inc\shlguid.w and publish it publicly.
// {B96D2802-4B41-4bc7-A6A4-55C5A12268CA}
DEFINE_GUID(CLSID_ACLEmailAddresses, 0xb96d2802, 0x4b41, 0x4bc7, 0xa6, 0xa4, 0x55, 0xc5, 0xa1, 0x22, 0x68, 0xca);

#undef MIDL_DEFINE_GUID

#endif // MYGUIDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\emailassoc.cpp ===
/*****************************************************************************\
    FILE: EmailAssoc.cpp

    DESCRIPTION:
        This file implements email to application associations.

    BryanSt 3/14/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>
#include <limits.h>         // INT_MAX
#include <commctrl.h>       // Str_SetPtr

#include "EmailAssoc.h"     // 

#ifdef FEATURE_EMAILASSOCIATIONS


todo; // Move this into AutoDiscovery.idl when we support the feature.
/*
    interface IEmailAssociations;

    cpp_quote("#ifndef __LPEMAILASSOCIATIONS_DEFINED")
    cpp_quote("#define __LPEMAILASSOCIATIONS_DEFINED")

    cpp_quote("//===================================================================")
    cpp_quote("//DESCRIPTION:")
    cpp_quote("//===================================================================")
    [
        object,
        oleautomation,
        dual,
        nonextensible,
        uuid(2154A5C4-9090-4746-A580-BF650D2404F6),        // IID_IEmailAssociations
    ]
    interface IEmailAssociations : IDispatch
    {
        //------------------------------------------------------------------
        // Pointer to an interface of this type
        //------------------------------------------------------------------
        typedef [unique] IEmailAssociations *LPEMAILASSOCIATIONS;      // For C callers

        //------------------------------------------------------------------
        // Properties
        //------------------------------------------------------------------
        [id(DISPIDAD_LENGTH), propget, SZ_DISPIDAD_GETLENGTH, displaybind, bindable] HRESULT length([retval, out] long * pnLength);
        [id(DISPIDAD_ITEM), propget, SZ_DISPIDAD_GETITEM, displaybind, bindable] HRESULT item([in] long nIndex,[retval, out] BSTR * pbstrEmailAddress);

        //------------------------------------------------------------------
        // Methods
        //------------------------------------------------------------------
    }
    cpp_quote("#endif //  __LPEMAILASSOCIATIONS_DEFINED")

    //----------------------------------------------------------------------
    // AutoDiscover Accounts Class
    //----------------------------------------------------------------------
    [
        uuid(CE682BA0-C554-43f7-99C6-2F00FE46C8BC),     // CLSID_EmailAssociations
        helpstring("Neptune AutoDiscover Accounts Class"),
    ]
    coclass EmailAssociations
    {
        [default] interface IEmailAssociations;
    };
*/


class CEmailAssociations : public CImpIDispatch
                        , public CObjectWithSite
                        , public IEmailAssociations
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IEmailAssociations ***
    virtual STDMETHODIMP get_length(OUT long * pnLength);
    virtual STDMETHODIMP get_item(IN long nIndex, OUT BSTR * pbstrEmailAddress);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

protected:
    CEmailAssociations();
    virtual ~CEmailAssociations(void);

    // Private Member Variables
    int                     m_cRef;
    LPWSTR                  m_pszDefault;
    HKEY                    m_hkey;


    // Private Member Functions
    HRESULT _getHkey(void);

    // Friend Functions
    friend HRESULT CEmailAssociations_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
};


//===========================
// *** Class Internals & Helpers ***
//===========================
HRESULT CEmailAssociations::_getHkey(void)
{
    HRESULT hr = S_OK;

    if (!m_hkey)
    {
        DWORD dwError = RegOpenKeyEx(HKEY_CURRENT_USER, SZ_REGKEY_EXPLOREREMAIL, 0, KEY_READ, &m_hkey);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

//===========================
// *** IEmailAssociations Interface ***
//===========================
HRESULT CEmailAssociations::get_length(OUT long * pnLength)
{
    HRESULT hr = _getHkey();

    if (SUCCEEDED(hr))
    {
        DWORD dwError = RegQueryInfoKey(m_hkey, NULL, NULL, 0, (ULONG *) pnLength, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


HRESULT CEmailAssociations::get_item(IN long nIndex, OUT BSTR * pbstrEmailAddress)
{
    HRESULT hr = _getHkey();

    *pbstrEmailAddress = NULL;
    if (SUCCEEDED(hr))
    {
        if (0 == nIndex)
        {
            if (!m_pszDefault)
            {
                TCHAR szCurrent[MAX_EMAIL_ADDRESSS];
                DWORD cb = sizeof(szCurrent);

                // We always hand out the default key for index == 0.
                DWORD dwError = RegQueryValueEx(m_hkey, NULL, NULL, NULL, (LPBYTE)szCurrent, &cb);
                hr = HRESULT_FROM_WIN32(dwError);
                if (SUCCEEDED(hr))
                {
                    Str_SetPtr(&m_pszDefault, szCurrent);
                }
            }

            if (m_pszDefault)
            {
                hr = HrSysAllocString(m_pszDefault, pbstrEmailAddress);
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            TCHAR szKeyName[MAX_PATH];
            FILETIME ftLastWriteTime;
            long nCurrent;              // Index counter
            DWORD cbSize;
            DWORD dwError;

            // populate the list
            for(nCurrent = 0;
                cbSize = ARRAYSIZE(szKeyName), dwError = RegEnumKeyEx(m_hkey, nCurrent, szKeyName, &cbSize, NULL, NULL, NULL, &ftLastWriteTime),
                    hr = HRESULT_FROM_WIN32(dwError), SUCCEEDED(hr);
                nCurrent++)
            {
                hr = E_FAIL;

                // Is this the default key?
                if (!StrCmpI(szKeyName, m_pszDefault))
                {
                    // Yes, so skip this index because we already returned it for slot zero (0).
                    nIndex++;
                }
                else
                {
                    if (nIndex == (nCurrent + 1))     // Is this the one the user wanted.
                    {
                        hr = HrSysAllocString(szKeyName, pbstrEmailAddress);
                        break;
                    }
                }
            }  // for
        }
    }

    return hr;
}




//===========================
// *** IUnknown Interface ***
//===========================
HRESULT CEmailAssociations::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CEmailAssociations, IEmailAssociations),
        QITABENT(CEmailAssociations, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


STDMETHODIMP_(DWORD) CEmailAssociations::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(DWORD) CEmailAssociations::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}




//===========================
// *** Class Methods ***
//===========================
CEmailAssociations::CEmailAssociations() : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IEmailAssociations)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    m_pszDefault = NULL;
    m_hkey = NULL;

    m_cRef = 1;
}


CEmailAssociations::~CEmailAssociations()
{
    Str_SetPtr(&m_pszDefault, NULL);
    if (m_hkey)
    {
        RegCloseKey(m_hkey);
    }

    DllRelease();
}


HRESULT CEmailAssociations_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj)
{
    HRESULT hr = CLASS_E_NOAGGREGATION;
    if (NULL == punkOuter)
    {
        CEmailAssociations * pmf = new CEmailAssociations();
        if (pmf)
        {
            hr = pmf->QueryInterface(riid, ppvObj);
            pmf->Release();
        }
        else
        {
            *ppvObj = NULL;
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}






//////////////////////////////////////
// EmailAccount
// 
// In these cases, HKEY points to:
// HKCU, "Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>"
// 
//////////////////////////////////////
HRESULT EmailAssoc_CreateEmailAccount(IN LPCWSTR pszEmailAddress, OUT HKEY * phkey)
{
    HRESULT hr;
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_EXPLOREREMAIL, pszEmailAddress);
    DWORD dwError = RegCreateKeyW(HKEY_CURRENT_USER, wzRegKey, phkey);

    hr = HRESULT_FROM_WIN32(dwError);
    if (SUCCEEDED(hr))
    {
        hr = EmailAssoc_GetDefaultEmailAccount(wzRegKey, ARRAYSIZE(wzRegKey));
        if (FAILED(hr))
        {
            // We don't have a default email account, so let's set this one.
            hr = EmailAssoc_SetDefaultEmailAccount(pszEmailAddress);
        }
    }

    return hr;
}


HRESULT EmailAssoc_OpenEmailAccount(IN LPCWSTR pszEmailAddress, OUT HKEY * phkey)
{
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_EXPLOREREMAIL, pszEmailAddress);
    DWORD dwError = RegOpenKeyW(HKEY_CURRENT_USER, wzRegKey, phkey);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetEmailAccountProtocol(IN HKEY hkey, IN LPWSTR pszProtocol, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszProtocol[0]));

    // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="WEB"
    DWORD dwError = SHGetValueW(hkey, NULL, SZ_REGVALUE_MAILPROTOCOL, &dwType, (void *)pszProtocol, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetEmailAccountProtocol(IN HKEY hkey, IN LPCWSTR pszProtocol)
{
    DWORD cbSize = ((lstrlenW(pszProtocol) + 1) * sizeof(pszProtocol[0]));

    // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="WEB"
    DWORD dwError = SHSetValueW(hkey, NULL, SZ_REGVALUE_MAILPROTOCOL, REG_SZ, (void *)pszProtocol, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetEmailAccountWebURL(IN HKEY hkey, IN LPWSTR pszURL, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszURL[0]));

    // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="WEB"
    DWORD dwError = SHGetValueW(hkey, SZ_REGVALUE_MAILPROTOCOLS L"\\" SZ_REGVALUE_WEB, SZ_REGVALUE_URL, &dwType, (void *)pszURL, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetEmailAccountWebURL(IN HKEY hkey, IN LPCWSTR pszURL)
{
    DWORD cbSize = ((lstrlenW(pszURL) + 1) * sizeof(pszURL[0]));

    // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="WEB"
    DWORD dwError = SHSetValueW(hkey, SZ_REGVALUE_MAILPROTOCOLS L"\\" SZ_REGVALUE_WEB, SZ_REGVALUE_URL, REG_SZ, (void *)pszURL, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetEmailAccountPreferredApp(IN HKEY hkey, IN LPWSTR pszMailApp, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszMailApp[0]));

    // Get HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","Preferred App"="<MailApp | AppID>"
    DWORD dwError = SHGetValueW(hkey, NULL, SZ_REGVALUE_PREFERREDAPP, &dwType, (void *)pszMailApp, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetEmailAccountPreferredApp(IN HKEY hkey, IN LPCWSTR pszMailApp)
{
    DWORD cbSize = ((lstrlenW(pszMailApp) + 1) * sizeof(pszMailApp[0]));

    // Set HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","Preferred App"="<MailApp | AppID>"
    DWORD dwError = SHSetValueW(hkey, NULL, SZ_REGVALUE_PREFERREDAPP, REG_SZ, (void *)pszMailApp, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetDefaultEmailAccount(IN LPWSTR pszProtocol, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszProtocol[0]));

    // Get HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\","(default)"="<Default Email Account>"
    DWORD dwError = SHGetValueW(HKEY_CURRENT_USER, SZ_REGKEY_EXPLOREREMAIL, NULL, &dwType, (void *)pszProtocol, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetDefaultEmailAccount(IN LPCWSTR pszProtocol)
{
    DWORD cbSize = ((lstrlenW(pszProtocol) + 1) * sizeof(pszProtocol[0]));

    // Get HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\","(default)"="<Default Email Account>"
    DWORD dwError = SHSetValueW(HKEY_CURRENT_USER, SZ_REGKEY_EXPLOREREMAIL, NULL, REG_SZ, (void *)pszProtocol, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}





//////////////////////////////////////
// MailApp
// 
// In these cases, HKEY points to:
// HKLM, "Software\Clients\Mail\<MailApp>"
// 
//////////////////////////////////////
HRESULT EmailAssoc_GetDefaultMailApp(IN LPWSTR pszMailApp, IN DWORD cchSize)
{
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszMailApp[0]));

    // Get HKLM,"Software\Clients\Mail","(default)"="<MailApp>"
    DWORD dwError = SHGetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_MAILCLIENTS, NULL, &dwType, (void *)pszMailApp, &cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_SetDefaultMailApp(IN LPCWSTR pszMailApp)
{
    DWORD cbSize = ((lstrlenW(pszMailApp) + 1) * sizeof(pszMailApp[0]));

    // Set HKLM,"Software\Clients\Mail","(default)"="<MailApp>"
    DWORD dwError = SHSetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_MAILCLIENTS, NULL, REG_SZ, (void *)pszMailApp, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_OpenMailApp(IN LPCWSTR pszMailApp, OUT HKEY * phkey)
{
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_MAILCLIENTS, pszMailApp);

    // TODO: We may want to support HKCU based "Clients\Mail".
    DWORD dwError = RegOpenKeyW(HKEY_LOCAL_MACHINE, wzRegKey, phkey);

    return HRESULT_FROM_WIN32(dwError);
}


HRESULT EmailAssoc_GetAppPath(IN HKEY hkey, IN LPTSTR pszAppPath, IN DWORD cchSize)
{
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszAppPath[0]));
    TCHAR szCmdLine[MAX_PATH];

    szCmdLine[0] = 0;   // This is optional

    // TODO: put our values under a "AutoDiscovery" key.
    DWORD dwError = SHGetValue(hkey, NULL, SZ_REGVALUE_READEMAILPATH, &dwType, (void *)pszAppPath, &cbSize);
    hr = HRESULT_FROM_WIN32(dwError);
    if (FAILED(hr))
    {
        // TODO: Use IQueryAssociations to load the string.  Then use ShellExecuteEx() with the "Open"
        //  verb so we let them load the "Shell\Open\Command" heirarchy.

        // Fall back to HKLM, "Software\Clients\Mail\<AppName>\Shell\Open\Command, "(default)"
        cbSize = (cchSize * sizeof(pszAppPath[0]));
        dwError = SHGetValue(hkey, SZ_REGKEY_SHELLOPENCMD, NULL, &dwType, (void *)pszAppPath, &cbSize);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            PathRemoveArgs(pszAppPath);
            PathUnquoteSpaces(pszAppPath);
        }
    }

    return hr;
}


HRESULT EmailAssoc_GetAppCmdLine(IN HKEY hkey, IN LPTSTR pszCmdLine, IN DWORD cchSize)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwType;
    DWORD cbSize = sizeof(szPath);
    TCHAR szCmdLine[MAX_PATH];

    szCmdLine[0] = 0;   // This is optional

    // TODO: put our values under a "AutoDiscovery" key.
    DWORD dwError = SHGetValue(hkey, NULL, SZ_REGVALUE_READEMAILPATH, &dwType, (void *)szPath, &cbSize);
    hr = HRESULT_FROM_WIN32(dwError);
    if (SUCCEEDED(hr))
    {
        cbSize = (cchSize * sizeof(pszCmdLine[0]));
        dwError = SHGetValue(hkey, NULL, SZ_REGVALUE_READEMAILCMDLINE, &dwType, (void *)pszCmdLine, &cbSize);
    }
    else
    {
        // TODO: Use IQueryAssociations to load the string.  Then use ShellExecuteEx() with the "Open"
        //  verb so we let them load the "Shell\Open\Command" heirarchy.

        // Fall back to HKLM, "Software\Clients\Mail\<AppName>\Shell\Open\Command, "(default)"
        cbSize = sizeof(szPath);
        dwError = SHGetValue(hkey, SZ_REGKEY_SHELLOPENCMD, NULL, &dwType, (void *)szPath, &cbSize);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            LPTSTR pszTempCmdLine = PathGetArgs(szPath);

            if (pszCmdLine)
            {
                StrCpyN(pszCmdLine, pszTempCmdLine, cchSize);
            }
            else
            {
                StrCpyN(pszCmdLine, TEXT(""), cchSize);
                hr = S_FALSE;
            }
        }
    }

    return hr;
}


HRESULT EmailAssoc_GetIconPath(IN HKEY hkey, IN LPTSTR pszIconPath, IN DWORD cchSize)
{
    HRESULT hr = EmailAssoc_GetAppPath(hkey, pszIconPath, cchSize);

    if (SUCCEEDED(hr))
    {
        // Get the path we will use for the icon.

        if (PathFindFileName(pszIconPath) && !StrCmpI(PathFindFileName(pszIconPath), TEXT("rundll32.exe")))
        {
            // The icon path is "Rundll32.exe" which will actually run their dll.
            // We will want to use the cmdline instead.

            hr = EmailAssoc_GetAppCmdLine(hkey, pszIconPath, cchSize);
            if (StrChr(pszIconPath, CH_COMMA))
            {
                StrChr(pszIconPath, CH_COMMA)[0] = 0; // Remove the function name.
            }

            PathUnquoteSpaces(pszIconPath);
        }
    }

    return hr;
}


BOOL EmailAssoc_DoesMailAppSupportProtocol(IN LPCWSTR pszMailApp, IN LPCWSTR pszProtocol)
{
    BOOL fSupports = FALSE;
    DWORD dwType;
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];
    WCHAR wzTemp[MAX_PATH];
    DWORD cbSize = sizeof(wzTemp);

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s\\Apps", SZ_REGKEY_MAILTRANSPORT, pszProtocol);

    // Read HKCR,"MailTransport\<Protocol>","(Default)"="<AppName | AppID>"
    // This key is used if the customer wants to force different apps per protocol.
    DWORD dwError = SHGetValueW(HKEY_CLASSES_ROOT, wzRegKey, pszMailApp, &dwType, (void *)wzTemp, &cbSize);
    if (ERROR_SUCCESS == dwError)
    {
        fSupports = TRUE;
    }

    return fSupports;
}


HRESULT EmailAssoc_GetFirstMailAppForProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp, IN DWORD cchSize)
{
    HRESULT hr;
    HKEY hkey;
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s\\Apps", SZ_REGKEY_MAILTRANSPORT, pszProtocol);
    DWORD dwError = RegOpenKey(HKEY_CLASSES_ROOT, wzRegKey, &hkey);
    hr = HRESULT_FROM_WIN32(dwError);
    if (SUCCEEDED(hr))
    {
        WCHAR wzTemp[MAX_PATH];
        DWORD cbSizeTemp = sizeof(wzTemp);
        DWORD cbSize = (cchSize * sizeof(pszMailApp[0]));
        DWORD dwType;

        // Read HKCR,"MailTransport\<Protocol>\Apps","<The First Value>"="<AppName | AppID>"
        dwError = SHEnumValueW(hkey, 0, pszMailApp, &cbSize, &dwType, (void *)wzTemp, &cbSizeTemp);
        hr = HRESULT_FROM_WIN32(dwError);

        RegCloseKey(hkey);
    }

    return hr;
}






//////////////////////////////////////
// Other
//////////////////////////////////////
HRESULT EmailAssoc_CreateWebAssociation(IN LPCTSTR pszEmail, IN IMailProtocolADEntry * pMailProtocol)
{
    BSTR bstrWebBaseEmailURL;
    HRESULT hr = pMailProtocol->get_ServerName(&bstrWebBaseEmailURL);

    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = EmailAssoc_CreateEmailAccount(pszEmail, &hkey);
        if (SUCCEEDED(hr))
        {
            hr = EmailAssoc_SetEmailAccountWebURL(hkey, bstrWebBaseEmailURL);
            if (SUCCEEDED(hr))
            {
                hr = EmailAssoc_SetEmailAccountProtocol(hkey, SZ_REGDATA_WEB);
            }

            RegCloseKey(hkey);
        }

        SysFreeString(bstrWebBaseEmailURL);
    }

    return hr;
}


HRESULT EmailAssoc_CreateStandardsBaseAssociation(IN LPCTSTR pszEmail, IN LPCTSTR pszProtocol)
{
    HKEY hkey;
    HRESULT hr = EmailAssoc_CreateEmailAccount(pszEmail, &hkey);

    if (SUCCEEDED(hr))
    {
        WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];
        DWORD cbSize = ((lstrlenW(L"") + 1) * sizeof(WCHAR));

        wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGVALUE_MAILPROTOCOLS, pszProtocol);

        // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>\MailProtocols\<protocol>","(default)"=""
        DWORD dwError = SHSetValueW(hkey, wzRegKey, NULL, REG_SZ, (void *)L"", cbSize);
        hr = HRESULT_FROM_WIN32(dwError);

        if (SUCCEEDED(hr))
        {
            WCHAR wzProtocol[MAX_PATH];

            SHTCharToUnicode(pszProtocol, wzProtocol, ARRAYSIZE(wzProtocol));
            cbSize = ((lstrlenW(SZ_REGDATA_WEB) + 1) * sizeof(SZ_REGDATA_WEB[0]));

            // Save HKCU,"Software\Microsoft\Windows\CurrentVersion\Explorer\Email\<EmailAddress>","MailProtocol"="<protocol>"
            DWORD dwError = SHSetValueW(hkey, NULL, SZ_REGVALUE_MAILPROTOCOL, REG_SZ, (void *)wzProtocol, cbSize);
            hr = HRESULT_FROM_WIN32(dwError);
        }

        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT EmailAssoc_GetEmailAccountGetAppFromProtocol(IN LPCWSTR pszProtocol, IN LPWSTR pszMailApp, IN DWORD cchSize)
{
    HRESULT hr;
    DWORD dwType;
    DWORD cbSize = (cchSize * sizeof(pszMailApp[0]));
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_MAILTRANSPORT, pszProtocol);

    // Read HKCR,"MailTransport\<Protocol>","(Default)"="<AppName | AppID>"
    // This key is used if the customer wants to force different apps per protocol.
    DWORD dwError = SHGetValueW(HKEY_CLASSES_ROOT, wzRegKey, NULL, &dwType, (void *)pszMailApp, &cbSize);
    hr = HRESULT_FROM_WIN32(dwError);
    if (FAILED(hr))
    {
        // The user didn't force an app based on the protocol, so let's try the default app.
        hr = EmailAssoc_GetDefaultMailApp(pszMailApp, cchSize);

        // Lets see if the default email add supports this protocol, because we always want
        // to give preferense to the user's choosen mail app.
        if (FAILED(hr) || !EmailAssoc_DoesMailAppSupportProtocol(pszMailApp, pszProtocol))
        {
            // It doesn't support the protocol, so lets get the first app that does.
            hr = EmailAssoc_GetFirstMailAppForProtocol(pszProtocol, pszMailApp, cchSize);
        }
    }

    return hr;
}


HRESULT EmailAssoc_SetEmailAccountGetAppFromProtocol(IN LPCWSTR pszProtocol, IN LPCWSTR pszMailApp)
{
    WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];
    DWORD cbSize = ((lstrlenW(pszMailApp) + 1) * sizeof(pszMailApp[0]));

    wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s", SZ_REGKEY_MAILTRANSPORT, pszProtocol);

    // Read HKCR,"MailTransport\<Protocol>","(Default)"="<AppName | AppID>"
    DWORD dwError = SHSetValueW(HKEY_CLASSES_ROOT, wzRegKey, NULL, REG_SZ, (void *)pszMailApp, cbSize);

    return HRESULT_FROM_WIN32(dwError);
}


LPCWSTR g_LegacyAssociations[][2] =
{
    {L"Outlook Express", L"POP3"},
    {L"Outlook Express", L"IMAP"},
    {L"Outlook Express", L"DAVMail"},
    {L"Microsoft Outlook", L"POP3"},
    {L"Microsoft Outlook", L"IMAP"},
    {L"Microsoft Outlook", L"MAPI"},
    {L"Eudora", L"POP3"},
    {L"Eudora", L"IMAP"},
};

// Description:
// This function will look at what applications are installed and setup the appropriate
// legacy email associations.
HRESULT EmailAssoc_InstallLegacyMailAppAssociations(void)
{
    HRESULT hr = S_OK;

    for (int nIndex = 0; nIndex < ARRAYSIZE(g_LegacyAssociations); nIndex++)
    {
        HKEY hkey;

        // Is the app installed?
        hr = EmailAssoc_OpenMailApp(g_LegacyAssociations[nIndex][0], &hkey);
        if (SUCCEEDED(hr))
        {
            // Yes, so let's install the legacy association.

            // TODO: we should use GetFileVersionInfo() and VerQueryValue() to make sure
            //   these are legacy versions.
            //hr = EmailAssoc_GetAppPath(IN HKEY hkey, IN LPTSTR pszAppPath, IN DWORD cchSize);

            WCHAR wzRegKey[MAXIMUM_SUB_KEY_LENGTH];

            wnsprintfW(wzRegKey, ARRAYSIZE(wzRegKey), L"%s\\%s\\Apps", SZ_REGKEY_MAILTRANSPORT, g_LegacyAssociations[nIndex][1]);
            SHSetValueW(HKEY_CLASSES_ROOT, wzRegKey, g_LegacyAssociations[nIndex][0], REG_SZ, (void *)L"", 4);

            RegCloseKey(hkey);
        }
    }

    return S_OK;        // We succeed any way because we are just trying to upgrade.
}




#endif // FEATURE_EMAILASSOCIATIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\mailprotocol.cpp ===
/*****************************************************************************\
    FILE: MailProtocol.cpp

    DESCRIPTION:
        This is the Autmation Object to AutoDiscovered email protocol information.

    BryanSt 2/15/2000
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "AutoDiscover.h"
#include "MailProtocol.h"



//===========================
// *** Class Internals & Helpers ***
//===========================

HRESULT _ReturnString(IN BSTR bstrToCopy, OUT BSTR * pbstr)
{
    HRESULT hr = E_INVALIDARG;

    if (pbstr)
    {
        if (bstrToCopy)
        {
            hr = HrSysAllocString(bstrToCopy, pbstr);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
            *pbstr = NULL;
        }
    }

    return hr;
}


HRESULT CMailProtocol::_Parse(IN IXMLDOMNode * pXMLNodeProtocol)
{
    HRESULT hr = XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_SERVER, &m_bstrServerName);

    if (SUCCEEDED(hr))
    {
        BSTR bstr;

        XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_TYPE, &m_bstrProtocol);
        XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_PORT, &m_bstrServerPort);
        XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_LOGINNAME, &m_bstrLoginName);

        XMLNode_GetChildTagTextValueToBool(pXMLNodeProtocol, SZ_XMLELEMENT_SSL, &m_fUseSSL);
        XMLNode_GetChildTagTextValueToBool(pXMLNodeProtocol, SZ_XMLELEMENT_AUTHREQUIRED, &m_fRequiresAuth);
        XMLNode_GetChildTagTextValueToBool(pXMLNodeProtocol, SZ_XMLELEMENT_SPA, &m_fUseSPA);
        XMLNode_GetChildTagTextValueToBool(pXMLNodeProtocol, SZ_XMLELEMENT_USEPOPAUTH, &m_fUsePOPAuth);

        if (SUCCEEDED(XMLNode_GetChildTagTextValue(pXMLNodeProtocol, SZ_XMLELEMENT_POSTHTML, &bstr)))
        {
            UnEscapeHTML(bstr, &m_bstrPostXML);
            SysFreeString(bstr);
        }
    }

    return hr;
}




//===========================
// *** IMailProtocolADEntry Interface ***
//===========================

HRESULT CMailProtocol::get_Protocol(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrProtocol, pbstr);
}


HRESULT CMailProtocol::get_ServerName(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrServerName, pbstr);
}


HRESULT CMailProtocol::get_ServerPort(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrServerPort, pbstr);
}


HRESULT CMailProtocol::get_LoginName(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrLoginName, pbstr);
}


HRESULT CMailProtocol::get_PostHTML(OUT BSTR * pbstr)
{
    return _ReturnString(m_bstrPostXML, pbstr);
}


HRESULT CMailProtocol::get_UseSSL(OUT VARIANT_BOOL * pfUseSSL)
{
    HRESULT hr = E_INVALIDARG;

    if (pfUseSSL)
    {
        *pfUseSSL = (m_fUseSSL ? VARIANT_TRUE : VARIANT_FALSE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CMailProtocol::get_IsAuthRequired(OUT VARIANT_BOOL * pfIsAuthRequired)
{
    HRESULT hr = E_INVALIDARG;

    if (pfIsAuthRequired)
    {
        *pfIsAuthRequired = (m_fRequiresAuth ? VARIANT_TRUE : VARIANT_FALSE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CMailProtocol::get_UseSPA(OUT VARIANT_BOOL * pfUseSPA)
{
    HRESULT hr = E_INVALIDARG;

    if (pfUseSPA)
    {
        *pfUseSPA = (m_fUseSPA ? VARIANT_TRUE : VARIANT_FALSE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CMailProtocol::get_SMTPUsesPOP3Auth(OUT VARIANT_BOOL * pfUsePOP3Auth)
{
    HRESULT hr = E_INVALIDARG;

    if (pfUsePOP3Auth)
    {
        *pfUsePOP3Auth = (m_fUsePOPAuth ? VARIANT_TRUE : VARIANT_FALSE);
        hr = S_OK;
    }

    return hr;
}



//===========================
// *** IUnknown Interface ***
//===========================
ULONG CMailProtocol::AddRef()
{
    m_cRef++;
    return m_cRef;
}


ULONG CMailProtocol::Release()
{
    ASSERT(m_cRef > 0);
    m_cRef--;

    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}


//===========================
// *** Class Methods ***
//===========================
HRESULT CMailProtocol::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    static const QITAB qit[] = {
        QITABENT(CMailProtocol, IMailProtocolADEntry),
        QITABENT(CMailProtocol, IDispatch),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


CMailProtocol::CMailProtocol() : CImpIDispatch(LIBID_AutoDiscovery, 1, 0, IID_IMailProtocolADEntry), m_cRef(1)
{
    DllAddRef();

    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!m_bstrProtocol);
    ASSERT(!m_bstrServerName);
    ASSERT(!m_bstrServerPort);
    ASSERT(!m_bstrLoginName);
    ASSERT(!m_bstrPostXML);
    ASSERT(!m_fUseSSL);
    ASSERT(!m_fRequiresAuth);
    ASSERT(!m_fUseSPA);
    ASSERT(!m_fUsePOPAuth);
}


CMailProtocol::~CMailProtocol()
{
    SysFreeString(m_bstrProtocol);
    SysFreeString(m_bstrServerName);
    SysFreeString(m_bstrServerPort);
    SysFreeString(m_bstrLoginName);
    SysFreeString(m_bstrPostXML);

    DllRelease();
}


HRESULT CMailProtocol_CreateInstance(IN IXMLDOMNode * pXMLNodeProtocol, IMailProtocolADEntry ** ppMailProtocol)
{
    HRESULT hr = E_INVALIDARG;

    if (pXMLNodeProtocol && ppMailProtocol)
    {
        CMailProtocol * pmf = new CMailProtocol();

        *ppMailProtocol = NULL;
        if (pmf)
        {
            hr = pmf->_Parse(pXMLNodeProtocol);
            if (SUCCEEDED(hr))
            {
                hr = pmf->QueryInterface(IID_PPV_ARG(IMailProtocolADEntry, ppMailProtocol));
            }

            pmf->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\mailboxui.cpp ===
/*****************************************************************************\
    FILE: MailBoxUI.cpp

    DESCRIPTION:
        This file implements the UI of the MailBox feature.  This UI is presented
    in a window.  Other components can put that window in the Desktop Toolbar
    or in an ActiveX Control to be displayed on the desktop HTML.

    BryanSt 2/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>

#include "MailBox.h"


#ifdef FEATURE_MAILBOX


//===========================
// *** Class Internals & Helpers ***
//===========================

#ifdef UNICODE
#define MAILBOXUI_CLASS_NAME              TEXT("MailBoxUI ToolbarW")
#else // UNICODE
#define MAILBOXUI_CLASS_NAME              TEXT("MailBoxUI ToolbarA")
#endif // UNICODE

HRESULT CMailBoxUI::_RegisterWindow(void)
{
    HRESULT hr = S_OK;
    WNDCLASS wc;

    //If the window class has not been registered, then do so.
    if (!GetClassInfo(HINST_THISDLL, MAILBOXUI_CLASS_NAME, &wc))
    {
        ZeroMemory(&wc, sizeof(wc));
        wc.style          = CS_GLOBALCLASS | CS_PARENTDC; // parentdc for perf
        wc.lpfnWndProc    = MailBoxUIWndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = 0;
        wc.hInstance      = g_hinst;
        wc.hIcon          = NULL;
        wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground  = (HBRUSH) (1+COLOR_BTNFACE);
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = MAILBOXUI_CLASS_NAME;
  
        if (!RegisterClass(&wc))
        {
            hr = E_FAIL;    // If RegisterClass fails, CreateWindow below will fail.
        }
    }

    return hr;
}


HRESULT CMailBoxUI::_CreateEditWindow(void)
{
    HRESULT hr = S_OK;
    DWORD dwType;
    TCHAR szEmailAddress[MAX_EMAIL_ADDRESSS];
    DWORD cbEmailAddress = sizeof(szEmailAddress);

    m_hwndEditBox = CreateWindowEx( WS_EX_CLIENTEDGE, TEXT("EDIT"), NULL, 
            (WS_CHILD | WS_TABSTOP | WS_VISIBLE | ES_AUTOHSCROLL), 
            2,1, 10, 0x1A, m_hwndMailBoxUI, NULL, HINST_THISDLL, (void*) this);

    if (m_hwndEditBox)
    {
        // We need to change the font to the Windows Shell Dlg font, 8
        HFONT hFont = (HFONT)(INT_PTR)SendMessage(GetParent(m_hwndMailBoxUI), WM_GETFONT, 0, 0L);
        if (hFont)
        {
            FORWARD_WM_SETFONT(m_hwndEditBox, hFont, FALSE, SendMessage);
        }

        szEmailAddress[0] = 0;
        DWORD dwError = SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_LAST_MAILBOX_EMAILADDRESS,
            &dwType, (void *)szEmailAddress, &cbEmailAddress);

        SetWindowText(m_hwndEditBox, szEmailAddress);

        // We want to subclass the window to capture Return/Enter.
        // There needs to be an easier way.
        SetWindowSubclass(m_hwndEditBox, EditMailBoxSubClassWndProc, 0, (DWORD_PTR)this);

        AddEmailAutoComplete(m_hwndEditBox);    // I love AutoComplete.
    }

    return hr;
}


LRESULT CMailBoxUI::_EditMailBoxSubClassWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL * pfHandled)
{
    LRESULT lResult = 0;

    switch (uMsg)
    {
    case WM_KEYUP:
        if (wParam == VK_RETURN)
        {
            TCHAR szEmailAddress[MAX_EMAIL_ADDRESSS];

            GetWindowText(m_hwndEditBox, szEmailAddress, ARRAYSIZE(szEmailAddress));
            if (SUCCEEDED(_OnExecuteGetEmail(szEmailAddress)))
            {
                // eat the enter/return key because we handled it.
                lResult = DLGC_WANTALLKEYS;
            }
        }
        break;
    }

    return lResult;
}


LRESULT CALLBACK CMailBoxUI::EditMailBoxSubClassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    CMailBoxUI * pMailBoxUI = (CMailBoxUI *)dwRefData;
    BOOL fHandled = FALSE;
    LRESULT lResult = 0;

    ASSERT(pMailBoxUI);
    if (pMailBoxUI)
    {
        lResult = pMailBoxUI->_EditMailBoxSubClassWndProc(uMsg, wParam, lParam, &fHandled);
    }

    if (!fHandled)
    {
        lResult = DefSubclassProc(hwnd, uMsg, wParam, lParam);
    }

    return lResult;
}


HRESULT CMailBoxUI::_CreateGoWindow(void)
{
    HRESULT hr = S_OK;

    if (SHRegGetBoolUSValue(SZ_REGKEY_IEMAIN, SZ_REGVALUE_USE_GOBUTTON, FALSE, /*default*/TRUE))
    {
        AssertMsg(!m_hwndGoButton, "Why is the go button already created? -BryanSt");

        hr = E_FAIL;
        COLORREF crMask = RGB(255, 0, 255);
        if (m_himlDefault == NULL)
        {
            m_himlDefault = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_GO), 16, 0, crMask,
                                                   IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }
        if (m_himlHot == NULL)
        {
            m_himlHot  = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_GOHOT), 16, 0, crMask,
                                               IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }

        // If we have the image lists, go ahead and create the toolbar control for the go button
        if (m_himlDefault && m_himlHot)
        {
            // Create the toolbar control for the go button
            m_hwndGoButton = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                    WS_CHILD | TBSTYLE_FLAT |
                                    TBSTYLE_TOOLTIPS |
                                    TBSTYLE_LIST |
                                    WS_CLIPCHILDREN |
                                    WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                    CCS_NORESIZE,
                                    0, 0, 0, 0, m_hwndMailBoxUI, NULL, HINST_THISDLL, NULL);
        }

        if (m_hwndGoButton)
        {
            // Init the toolbar control
            SendMessage(m_hwndGoButton, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
            SendMessage(m_hwndGoButton, TB_SETMAXTEXTROWS, 1, 0L);
            SendMessage(m_hwndGoButton, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, 500));
            SendMessage(m_hwndGoButton, TB_SETIMAGELIST, 0, (LPARAM)m_himlDefault);
            SendMessage(m_hwndGoButton, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlHot);

            LRESULT nRet = SendMessage(m_hwndGoButton, TB_ADDSTRING, (WPARAM)HINST_THISDLL, (LPARAM)IDS_MAILBOXUI_GOBUTTON_LABEL);
            ASSERT(nRet == 0);

            static const TBBUTTON tbb[] =
            {
                {0, 1, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0},
            };
            SendMessage(m_hwndGoButton, TB_ADDBUTTONS, ARRAYSIZE(tbb), (LPARAM)tbb);

            ShowWindow(m_hwndGoButton, SW_SHOW);
            hr = _OnSetSize();
        }
    }

    return hr;
}


HRESULT CMailBoxUI::_OnExecuteGetEmail(LPCTSTR pszEmailAddress)
{
    HRESULT hr = E_INVALIDARG;

    if (pszEmailAddress)
    {
        // Make sure the email address is valid.  If it isn't, then we should
        // Display a warning.
        if (!pszEmailAddress[0] || !StrChr(pszEmailAddress, CH_EMAIL_AT))
        {
            // Display a message box for now.
            // TOOD: Change this to a nice balloon in the future.
            TCHAR szErrorMessage[500];
            TCHAR szErrorTemplate[500];
            TCHAR szTitle[MAX_PATH];

            LoadStringW(HINST_THISDLL, IDS_MAILBOXUI_ERR_INVALID_EMAILADDR_TITLE, szTitle, ARRAYSIZE(szTitle));
            LoadStringW(HINST_THISDLL, IDS_MAILBOXUI_ERR_INVALID_EMAILADDR, szErrorTemplate, ARRAYSIZE(szErrorTemplate));
            wnsprintf(szErrorMessage, ARRAYSIZE(szErrorMessage), szErrorTemplate, pszEmailAddress);

            MessageBox(m_hwndMailBoxUI, szErrorMessage, szTitle, (MB_OK | MB_ICONHAND));
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // Indicate that we already displayed an error message.
        }
        else
        {
            // We will have this happen in a new process so we can be async
            // and to ensure that there is -zero- possibility to cause
            // instability in the shell.

            // We do this by creating a "rundll32.exe" process and have it call
            // us back by supplying the following command line arguments:
            // "<DllPath>\AutoDisc.dll,AutoDiscoverAndOpenEmail "-email <EmailAddressHere>""
            TCHAR szPath[MAX_PATH];

            if (GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath)))
            {
                TCHAR szCmdLine[MAX_URL_STRING];
                TCHAR szProcess[MAX_PATH];

#ifndef TESTING_IN_SAME_DIR
                StrCpyN(szProcess, TEXT("rundll32.exe"), ARRAYSIZE(szProcess));
#else // TESTING_IN_SAME_DIR
                GetCurrentDirectory(ARRAYSIZE(szProcess), szProcess);
                PathAppend(szProcess, TEXT("rundll32.exe"));
                if (!PathFileExists(szProcess))
                {
                    StrCpyN(szProcess, TEXT("rundll32.exe"), ARRAYSIZE(szProcess));
                }
#endif // TESTING_IN_SAME_DIR

                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%s,AutoDiscoverAndOpenEmail -email %s"), szPath, pszEmailAddress);

                ULARGE_INTEGER uiResult;
                uiResult.QuadPart = (ULONGLONG) ShellExecute(NULL, NULL, TEXT("rundll32.exe"), szCmdLine, NULL, SW_SHOW);
                if (32 < uiResult.QuadPart)
                {
                    AddEmailToAutoComplete(pszEmailAddress);

                    uiResult.LowPart = ERROR_SUCCESS;
                }

                hr = HRESULT_FROM_WIN32(uiResult.LowPart);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    return hr;
}


#define SIZEPX_ABOVEBELOW_EDITBOX        1
#define SIZEPX_LEFTRIGHT_EDITBOX         2

HRESULT CMailBoxUI::_OnSetSize(void)
{
    if (m_hwndEditBox && m_hwndGoButton)
    {
        // TODO: Get button size and then move it into position.  Including shrinking
        //    the editbox.
        RECT rcWindowSize;
        RECT rcGoWidth;

        GetClientRect(m_hwndMailBoxUI, &rcWindowSize);
        SendMessage(m_hwndGoButton, TB_GETITEMRECT, 0, (LPARAM)&rcGoWidth);
        
        SetWindowPos(m_hwndEditBox, NULL, SIZEPX_LEFTRIGHT_EDITBOX, SIZEPX_ABOVEBELOW_EDITBOX, RECTWIDTH(rcWindowSize)-RECTWIDTH(rcGoWidth)-(3 * SIZEPX_LEFTRIGHT_EDITBOX), 
                    RECTHEIGHT(rcWindowSize)-SIZEPX_ABOVEBELOW_EDITBOX, (SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER));
        SetWindowPos(m_hwndGoButton, NULL, RECTWIDTH(rcWindowSize)-SIZEPX_LEFTRIGHT_EDITBOX-RECTWIDTH(rcGoWidth), SIZEPX_ABOVEBELOW_EDITBOX,
                    RECTWIDTH(rcGoWidth), RECTHEIGHT(rcWindowSize)-(2*SIZEPX_ABOVEBELOW_EDITBOX), (SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER));
    }

    return S_OK;
}


LRESULT CALLBACK CMailBoxUI::MailBoxUIWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CMailBoxUI  *pThis = (CMailBoxUI*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (uMessage)
    {
    case WM_NCCREATE:
    {
        LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;
        pThis = (CMailBoxUI*)(pcs->lpCreateParams);
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
        return TRUE;
    }

    case WM_COMMAND:
        return pThis->_OnCommand(wParam, lParam);

    case WM_SETFOCUS:
        TraceMsg(0, "  Main MailBoxUIWndProc got focus", 0);
        return pThis->_OnSetFocus();

    case WM_NOTIFY:
        if (pThis->_OnNotify((LPNMHDR)lParam))
        {
            return 0;
        }
        break;

    case WM_KILLFOCUS:
        TraceMsg(0, "  Main MailBoxUIWndProc lost focus", 0);
        return pThis->_OnKillFocus();

    case WM_WINDOWPOSCHANGING:
        if (pThis)
        {
            pThis->_OnSetSize();
        }
        return 0;
    case WM_SIZE:
        if (pThis)
        {
            pThis->_OnSetSize();
        }
        return 0;
    default:
        TraceMsg(TF_ALWAYS, "in MailBoxUIWndProc() uMessage=%#08lx", uMessage);
        break;
   }

    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}


LRESULT CMailBoxUI::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    switch (HIWORD(wParam))
    {
        case EN_SETFOCUS:
            TraceMsg(0, "  Main MailBoxUIWndProc got EN_SETFOCUS", 0);
            _OnSetFocus();
            break;
        case EN_KILLFOCUS:
            TraceMsg(0, "  Main MailBoxUIWndProc got EN_KILLFOCUS", 0);
            _OnKillFocus();
            break;
        case STN_CLICKED:
            break;
        default:
            TraceMsg(TF_ALWAYS, "in CMailBoxUI::_OnCommand() HIWORD(wParam)=%#08lx", HIWORD(wParam));
            break;
    }
    return 0;
}


BOOL CMailBoxUI::_OnNotify(LPNMHDR pnm)
{
    if (pnm->hwndFrom == m_hwndGoButton)
    {
        switch (pnm->code)
        {
        case NM_CLICK:
            // Simulate an enter key press in the combobox
            SendMessage(m_hwndEditBox, WM_KEYDOWN, VK_RETURN, 0);
            SendMessage(m_hwndEditBox, WM_KEYUP, VK_RETURN, 0);
            break;
        }
    }

    return FALSE;   // We want the caller to still treat this as unhandled.
}


LRESULT CMailBoxUI::_OnSetFocus(void)
{
    // BUGBUG: should be IUnknown, but thats not working.  nb IDeskBand is the first iface, so ok
    //inform the input object site that the focus has changed
    if (m_pSite)
        m_pSite->OnFocusChangeIS((IDeskBand*)this, TRUE);

    return 0;
}

LRESULT CMailBoxUI::_OnKillFocus(void)
{
    // BUGBUG: should be IUnknown, but thats not working.  nb IDeskBand is the first iface, so ok
    //inform the input object site that the focus has changed
    if (m_pSite)
        m_pSite->OnFocusChangeIS((IDeskBand*)this, FALSE);

    return 0;
}



//===========================
// *** Public Methods ***
//===========================
HRESULT CMailBoxUI::CreateWindowMB(HWND hwndParent, HWND * phwndMailBoxUI)
{
    HRESULT hr = _RegisterWindow();

    if (!phwndMailBoxUI)
    {
        return E_INVALIDARG;
    }

    AssertMsg((NULL == m_hwndMailBoxUI), "Why is m_hwndMailBoxUI NULL? -BryanSt");

    // Can't create a child window without a parent.
    if (SUCCEEDED(hr) && !m_hwndMailBoxUI)
    {
        RECT  rc;

        GetClientRect(hwndParent, &rc);

        // TODO: Calc the real good size
        rc.bottom = rc.top - 0x1A;

        // Create the container window.
        m_hwndMailBoxUI = CreateWindowEx(0,
                     MAILBOXUI_CLASS_NAME,
                     NULL,
                     WS_CHILD | WS_CLIPSIBLINGS,
                     rc.left,
                     rc.top,
                     rc.right - rc.left,
                     rc.bottom - rc.top,
                     hwndParent,
                     NULL,
                     HINST_THISDLL,
                     (void*)this);

        if (m_hwndMailBoxUI)
        {
            hr = _CreateEditWindow();
            if (SUCCEEDED(hr))
            {
                hr = _CreateGoWindow();
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        *phwndMailBoxUI = m_hwndMailBoxUI;
    }

    return hr;
}


HRESULT CMailBoxUI::CloseWindowMB(void)
{
    HRESULT hr = S_OK;
    TCHAR szEmailAddress[MAX_EMAIL_ADDRESSS];
    DWORD cbEmailAddress = sizeof(cbEmailAddress);

    if (GetWindowText(m_hwndEditBox, szEmailAddress, ARRAYSIZE(szEmailAddress)))
    {
        // Save the Email Address.
        DWORD dwError = SHSetValue(HKEY_CURRENT_USER, SZ_REGKEY_AUTODISCOVERY, SZ_REGVALUE_LAST_MAILBOX_EMAILADDRESS,
            REG_SZ, (void *)szEmailAddress, ((lstrlen(szEmailAddress) + 1) * sizeof(szEmailAddress[0])));
    }

    RemoveWindowSubclass(m_hwndEditBox, EditMailBoxSubClassWndProc, 0);
    DestroyWindow(m_hwndEditBox);
    m_hwndEditBox = NULL;

    DestroyWindow(m_hwndGoButton);
    m_hwndGoButton = NULL;

    DestroyWindow(m_hwndMailBoxUI);
    m_hwndMailBoxUI = NULL;

    return hr;
}


//===========================
// *** IOleWindow Interface ***
//===========================
STDMETHODIMP CMailBoxUI::GetWindow(HWND *phWnd)
{
    *phWnd = m_hwndMailBoxUI;
    return S_OK;
}

STDMETHODIMP CMailBoxUI::ContextSensitiveHelp(BOOL fEnterMode)
{
    // TODO: Add help here.
    return S_OK;
}


//===========================
// *** IDockingWindow Interface ***
//===========================
STDMETHODIMP CMailBoxUI::ShowDW(BOOL fShow)
{
    TraceMsg(0, "::ShowDW %x", fShow);
    if (m_hwndMailBoxUI)
    {
        if (fShow)
            ShowWindow(m_hwndMailBoxUI, SW_SHOW);
        else
            ShowWindow(m_hwndMailBoxUI, SW_HIDE);
        return S_OK;
    }
    return E_FAIL;
}


STDMETHODIMP CMailBoxUI::CloseDW(DWORD dwReserved)
{
    TraceMsg(0, "::CloseDW", 0);
    ShowDW(FALSE);

    return S_OK;
}

STDMETHODIMP CMailBoxUI::ResizeBorderDW(LPCRECT prcBorder, IUnknown* punkSite, BOOL fReserved)
{
    // This method is never called for Band Objects.
    return E_NOTIMPL;
}


//===========================
// *** IInputObject Interface ***
//===========================
STDMETHODIMP CMailBoxUI::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
    TraceMsg(0, "::UIActivateIO %x", fActivate);
    if (fActivate)
        SetFocus(m_hwndEditBox);
    return S_OK;
}


STDMETHODIMP CMailBoxUI::HasFocusIO(void)
{
// If this window or one of its decendants has the focus, return S_OK. Return 
//  S_FALSE if we don't have the focus.
    TraceMsg(0, "::HasFocusIO", NULL);
    HWND hwnd = GetFocus();
    if (hwnd && ((hwnd == m_hwndMailBoxUI) ||
        (GetParent(hwnd) == m_hwndMailBoxUI) ||
        (GetParent(GetParent(hwnd)) == m_hwndMailBoxUI)))
    {
        return S_OK;
    }

    return S_FALSE;
}


STDMETHODIMP CMailBoxUI::TranslateAcceleratorIO(LPMSG pMsg)
{
    // If the accelerator is translated, return S_OK or S_FALSE otherwise.
    return S_FALSE;
}


//===========================
// *** IObjectWithSite Interface ***
//===========================
STDMETHODIMP CMailBoxUI::SetSite(IUnknown* punkSite)
{
    IUnknown_Set((IUnknown **) &m_pSite, punkSite);
    return ((m_pSite && punkSite) ? S_OK : ((!m_pSite && !punkSite) ? S_OK : E_FAIL));
}

STDMETHODIMP CMailBoxUI::GetSite(REFIID riid, LPVOID *ppvReturn)
{
    *ppvReturn = NULL;

    if (m_pSite)
        return m_pSite->QueryInterface(riid, ppvReturn);

    return E_FAIL;
}





//===========================
// *** IUnknown Interface ***
//===========================
STDMETHODIMP CMailBoxUI::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMailBoxUI, IOleWindow),
        QITABENT(CMailBoxUI, IDockingWindow),
        QITABENT(CMailBoxUI, IInputObject),
        QITABENT(CMailBoxUI, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}                                             

STDMETHODIMP_(DWORD) CMailBoxUI::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(DWORD) CMailBoxUI::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



//===========================
// *** Class Methods ***
//===========================
HRESULT CMailBoxUI::GetEditboxWindow(HWND * phwndEdit)
{
    HRESULT hr = E_FAIL;

    if (m_hwndEditBox)
    {
        *phwndEdit = m_hwndEditBox;
        hr = S_OK;
    }
    else
    {
        *phwndEdit = NULL;
    }

    return hr;
}


CMailBoxUI::CMailBoxUI()
{
    DllAddRef();

    m_himlDefault = NULL;
    m_himlHot = NULL;
    m_hwndMailBoxUI = NULL;
    m_hwndGoButton = NULL;
    m_hwndEditBox = NULL;
    m_pSite = NULL;

    m_cRef = 1;
}

CMailBoxUI::~CMailBoxUI()
{
    if (m_himlDefault) ImageList_Destroy(m_himlDefault);
    if (m_himlHot)  ImageList_Destroy(m_himlHot);

    ATOMICRELEASE(m_pSite);

    DllRelease();
}










#endif // FEATURE_MAILBOX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\instoxml.h ===
/*****************************************************************************\
    FILE: INStoXML.h

    DESCRIPTION:
        This code will convert an INS (internet settings) or ISP (Internet
    Service Provider) file to an Account AutoDiscovery XML file.

    BryanSt 11/8/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/


//===========================
// *** APIs ***
//===========================
bool IsINSFile(LPCWSTR pwszINSFile);
HRESULT ConvertINSToXML(LPCWSTR pwszINSFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\mailprotocol.h ===
/*****************************************************************************\
    FILE: MailProtocol.h

    DESCRIPTION:
        This is the Autmation Object to AutoDiscover account information.

    BryanSt 2/15/2000
    Copyright (C) Microsoft Corp 1999-2000. All rights reserved.
\*****************************************************************************/

#ifndef _FILE_H_MAILPROTOCOL
#define _FILE_H_MAILPROTOCOL

#include <cowsite.h>
#include <atlbase.h>

HRESULT CMailProtocol_CreateInstance(IN IXMLDOMNode * pXMLNodeProtocol, IMailProtocolADEntry ** ppMailProtocol);


class CMailProtocol             : public CImpIDispatch
                                , public IMailProtocolADEntry
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IMailProtocolADEntry ***
    virtual STDMETHODIMP get_Protocol(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_ServerName(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_ServerPort(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_LoginName(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_PostHTML(OUT BSTR * pbstr);
    virtual STDMETHODIMP get_UseSSL(OUT VARIANT_BOOL * pfUseSSL);
    virtual STDMETHODIMP get_IsAuthRequired(OUT VARIANT_BOOL * pfIsAuthRequired);
    virtual STDMETHODIMP get_UseSPA(OUT VARIANT_BOOL * pfUseSPA);
    virtual STDMETHODIMP get_SMTPUsesPOP3Auth(OUT VARIANT_BOOL * pfUsePOP3Auth);

    // *** IDispatch ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr) { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

private:
    CMailProtocol();
    virtual ~CMailProtocol(void);

    HRESULT _Parse(IN IXMLDOMNode * pXMLNodeProtocol);


    // Private Member Variables
    int                     m_cRef;

    BSTR                    m_bstrProtocol;
    BSTR                    m_bstrServerName;
    BSTR                    m_bstrServerPort;
    BSTR                    m_bstrLoginName;
    BSTR                    m_bstrPostXML;
    BOOL                    m_fUseSSL;
    BOOL                    m_fRequiresAuth;            // Mainly for SMTP.  Is Authentication required to connect to the server?
    BOOL                    m_fUseSPA;
    BOOL                    m_fUsePOPAuth;              // Get the auth settings from the POP protocol?
    

    // Friend Functions
    friend HRESULT CMailProtocol_CreateInstance(IN IXMLDOMNode * pXMLNodeProtocol, IMailProtocolADEntry ** ppMailProtocol);
};


#endif // _FILE_H_MAILPROTOCOL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\instoxml.cpp ===
/*****************************************************************************\
    FILE: INStoXML.cpp

    DESCRIPTION:
        This code will convert an INS (internet settings) or ISP (Internet
    Service Provider) file to an Account AutoDiscovery XML file.

    BryanSt 11/8/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <cowsite.h>
#include <atlbase.h>
#include "util.h"
#include "AutoDiscover.h"

#define XML_POST_REQUEST                    L"<?xml version=\"1.0\"?>\r\n<AUTODISCOVERY Version=\"0.1\">\r\n\t<REQUEST ACCOUNTTYPE=\"EMail\" EMAIL=\"%ls\">\r\n\t</REQUEST>\r\n</AUTODISCOVERY>\r\n"

#define XML_TEMPLATE_DISPNAME               "<USER DISPLAYNAME=\"%ls\" />"
#define XML_TEMPLATE_ACCOUNT                "<?xml version=\"1.0\"?>\r\n<AUTODISCOVERY Version=\"0.1\">\r\n %hs\r\n <ACCOUNT TYPE=\"EMail\" EXPIRE=\"7\">\r\n  <PROTOCOL TYPE=\"POP3\" SERVERNAME=\"%ls\">\r\n   <AUTH>\r\n    <PASSWORD TYPE=\"%ls\" />\r\n   </AUTH>\r\n  </PROTOCOL>\r\n  <PROTOCOL TYPE=\"SMTP\" SERVERNAME=\"%ls\">\r\n   <AUTH>\r\n    <PASSWORD TYPE=\"%ls\" />\r\n   </AUTH>\r\n  </PROTOCOL>\r\n </ACCOUNT>\r\n</AUTODISCOVERY>"

#define STR_SECTION_INET_MAIL               TEXT("Internet_Mail")

#define STR_INIKEY_POP_SERVER               TEXT("POP_Server")
#define STR_INIKEY_POP_NAME                 TEXT("POP_Logon_Name")
#define STR_INIKEY_SMTP_SERVER              TEXT("SMTP_Server")
#define STR_INIKEY_AUTH_TYPE                TEXT("Logon_Using_SPA")
#define STR_INIKEY_EMAIL_NAME               TEXT("Email_Name")          // DisplayName

#define STR_TYPE_POP3                       TEXT("POP3")
#define STR_YES                             TEXT("yes")
#define STR_SPA                             TEXT("SPA")


typedef struct tagAUTODISCOVERYSETTINGS
{
    LPWSTR pwszType;
    LPWSTR pwszPOPServer;
    LPWSTR pwszPOPServerLoginName;
    LPWSTR pwszSMTPServer;
    LPWSTR pwszDisplayName;
    LPWSTR pwszAuthType;
} AUTODISCOVERYSETTINGS;



//===========================
// *** API Internals & Helpers ***
//===========================
HRESULT _GetAutoDiscSettings(LPCWSTR pwszINSFile, AUTODISCOVERYSETTINGS * pads)
{
    WCHAR wzTemp[MAX_URL_STRING];
    HRESULT hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_POP_SERVER, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);

    if (SUCCEEDED(hr) && wzTemp[0])
    {
        pads->pwszPOPServer = StrDupW(wzTemp);
        hr = ((pads->pwszPOPServer) ? S_OK : E_OUTOFMEMORY);

        if (SUCCEEDED(hr))
        {
            pads->pwszType = StrDupW(STR_TYPE_POP3);
            hr = ((pads->pwszType) ? S_OK : E_OUTOFMEMORY);            
        }
    }

    hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_POP_NAME, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);
    if (SUCCEEDED(hr) && wzTemp[0])
    {
        pads->pwszPOPServerLoginName = StrDupW(wzTemp);
        hr = ((pads->pwszPOPServerLoginName) ? S_OK : E_OUTOFMEMORY);
    }

    hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_SMTP_SERVER, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);
    if (SUCCEEDED(hr) && wzTemp[0])
    {
        pads->pwszSMTPServer = StrDupW(wzTemp);
        hr = ((pads->pwszSMTPServer) ? S_OK : E_OUTOFMEMORY);
    }

    hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_AUTH_TYPE, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);
    if (SUCCEEDED(hr) && wzTemp[0] && StrCmpIW(wzTemp, STR_YES))
    {
        pads->pwszAuthType = StrDupW(STR_SPA);
        hr = ((pads->pwszAuthType) ? S_OK : E_OUTOFMEMORY);
    }

    hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_EMAIL_NAME, L"", wzTemp, ARRAYSIZE(wzTemp), pwszINSFile);
    if (SUCCEEDED(hr) && wzTemp[0])
    {
        pads->pwszDisplayName = StrDupW(wzTemp);
        hr = ((pads->pwszDisplayName) ? S_OK : E_OUTOFMEMORY);
    }

    return hr;
}


HRESULT _CreateXMLFromSettings(AUTODISCOVERYSETTINGS * pads, LPSTR * ppszXML)
{
    CHAR szUserTagXML[MAX_URL_STRING];
    CHAR szAccountXML[MAX_URL_STRING * 4];
    HRESULT hr = S_OK;

    szUserTagXML[0] = 0;
    szAccountXML[0] = 0;
    if (pads->pwszDisplayName)
    {
        wnsprintfA(szUserTagXML, ARRAYSIZE(szUserTagXML), XML_TEMPLATE_DISPNAME, pads->pwszDisplayName);
    }

    // TODO: Do we need to add the POP Login Name?
    wnsprintfA(szAccountXML, ARRAYSIZE(szAccountXML), XML_TEMPLATE_ACCOUNT, szUserTagXML, pads->pwszPOPServer, pads->pwszAuthType, pads->pwszSMTPServer, pads->pwszAuthType);
    *ppszXML = StrDupA(szAccountXML);
    hr = ((*ppszXML) ? S_OK : E_OUTOFMEMORY);

    return hr;
}


HRESULT _SaveToFile(LPCWSTR pwszFileName, LPCSTR pszXML)
{
    HANDLE hFile;
    HRESULT hr = CreateFileHrWrap(pwszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL, &hFile);

    if (SUCCEEDED(hr))
    {
        DWORD chFSWritten;

        hr = WriteFileWrap(hFile, pszXML, lstrlenA(pszXML), &chFSWritten, NULL);
        CloseHandle(hFile);
    }

    return hr;
}


HRESULT _FreeAutoDiscSettings(AUTODISCOVERYSETTINGS * pads)
{
    if (pads->pwszType)           LocalFree(pads->pwszType);
    if (pads->pwszPOPServer)      LocalFree(pads->pwszPOPServer);
    if (pads->pwszPOPServerLoginName)   LocalFree(pads->pwszPOPServerLoginName);
    if (pads->pwszSMTPServer)     LocalFree(pads->pwszSMTPServer);
    if (pads->pwszDisplayName)    LocalFree(pads->pwszDisplayName);
    if (pads->pwszAuthType)       LocalFree(pads->pwszAuthType);

    return S_OK;
}



//===========================
// *** APIs ***
//===========================
bool IsINSFile(LPCWSTR pwszINSFile)
{
    WCHAR wzPOPServer[MAX_PATH];
    bool fIsINSFile = false;
    HRESULT hr = GetPrivateProfileStringHrWrap(STR_SECTION_INET_MAIL, STR_INIKEY_POP_SERVER, L"", wzPOPServer, ARRAYSIZE(wzPOPServer), pwszINSFile);

    if (SUCCEEDED(hr) && wzPOPServer[0])
    {
        // We consider this a valid Account AutoDiscovery compatible INS/ISP
        // file if it has:
        // [Internet_Mail]
        // POP_Server=xxxxx

        fIsINSFile = true;
    }

    return fIsINSFile;
}


HRESULT ConvertINSToXML(LPCWSTR pwszINSFile)
{
    AUTODISCOVERYSETTINGS ads = {0};
    HRESULT hr = _GetAutoDiscSettings(pwszINSFile, &ads);

    if (SUCCEEDED(hr))
    {
        LPSTR pszXML;

        hr = _CreateXMLFromSettings(&ads, &pszXML);
        if (SUCCEEDED(hr))
        {
            hr = _SaveToFile(pwszINSFile, pszXML);
            LocalFree(pszXML);
        }

        _FreeAutoDiscSettings(&ads);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\mailbox.h ===
/*****************************************************************************\
    FILE: MailBox.h

    DESCRIPTION:
        This file implements defines all the shares components of the MailBox
    feature.

    BryanSt 2/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _MAILBOX_H
#define _MAILBOX_H

#include "dllload.h"

#ifdef FEATURE_MAILBOX

// FUTURE:
// 1. Check out aeditbox.cpp, we may want to steal OLECMDID_PASTE for copy/paste
// 2. We may need CAddressEditAccessible to be accessible.

HRESULT CMailBoxDeskBand_CreateInstance(IN IUnknown * punkOuter, REFIID riid, void ** ppvObj);
HRESULT AddEmailToAutoComplete(IN LPCWSTR pszEmailAddress);
STDAPI AddEmailAutoComplete(HWND hwndEdit);

INT_PTR CALLBACK MailBoxProgressDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK GetEmailAddressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);


/**************************************************************************
   CLASS: CMailBoxUI
**************************************************************************/
class CMailBoxUI : public IDockingWindow, 
                  public IInputObject, 
                  public IObjectWithSite
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(DWORD) AddRef();
    STDMETHODIMP_(DWORD) Release();

    //IOleWindow methods
    STDMETHOD (GetWindow)(HWND*);
    STDMETHOD (ContextSensitiveHelp)(BOOL);

    //IDockingWindow methods
    STDMETHOD (ShowDW)(BOOL fShow);
    STDMETHOD (CloseDW)(DWORD dwReserved);
    STDMETHOD (ResizeBorderDW)(LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

    //IInputObject methods
    STDMETHOD (UIActivateIO)(BOOL, LPMSG);
    STDMETHOD (HasFocusIO)(void);
    STDMETHOD (TranslateAcceleratorIO)(LPMSG);

    //IObjectWithSite methods
    STDMETHOD (SetSite)(IUnknown*);
    STDMETHOD (GetSite)(REFIID, LPVOID*);

    HRESULT CreateWindowMB(HWND hwndParent, HWND * phwndMailBoxUI);
    HRESULT CloseWindowMB(void);

    HRESULT GetEditboxWindow(HWND * phwndEdit);
    CMailBoxUI();
    ~CMailBoxUI();

private:
    // Private Member Variables
    DWORD m_cRef;

    IInputObjectSite *m_pSite;

    HWND m_hwndMailBoxUI;                   // The hwnd containing the editbox and the "Go" button.
    HWND m_hwndEditBox;                     // The editbox hwnd.
    HWND m_hwndGoButton;                    // The Go button hwnd.
    HIMAGELIST m_himlDefault;               // default gray-scale go button
    HIMAGELIST m_himlHot;                   // color go button

    HRESULT _CreateEditWindow(void);
    HRESULT _OnSetSize(void);

    // Private Member Functions
    LRESULT _OnKillFocus(void);
    LRESULT _OnSetFocus(void);
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL _OnNotify(LPNMHDR pnm);            // Return TRUE if the message was handled.
    LRESULT _EditMailBoxSubClassWndProc(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL * pfHandled);

    HRESULT _RegisterWindow(void);
    HRESULT _CreateGoWindow(void);
    HRESULT _OnExecuteGetEmail(LPCTSTR pszEmailAddress);

    static LRESULT CALLBACK MailBoxUIWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK EditMailBoxSubClassWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
};


/***************
TODO List: Wizard (Progress & Choose App)
15. Write caching code so we don't display the progress dialog when we already know the info.
4. Write "Choose App" Page.
3. Special Case AOL.
4. Cache for 1 month.
7. Support the no-dial up case.  Is that how we handle the off-line case?


TODO List: ActiveX Control
1. Create it.
2. Write State Logic (First Time, More than 1 email Address, Options, etc.)
3. Do we want to use balloons instead?


TODO List: Associations
1. Write Interface to register
2. Pre-Populate popular Apps
3. Get MSN working.
4. Add UI to change from default.
5. Rev server to support a second protocol type.


TODO List: OE The App
11. Rev OE to have an "-email" flag to autoconfigure.
16. Add the Please Wait Animation
17. Change it to use the interface to do the async work.
18. Meet with outlook.
19. Test with Eudora, Netscape, Lotus Notes.


TODO List: Email Associations Dialog
1. Add Another "Choose Default Mail Client".
2. Let the user change Apps


TODO List: DeskBar
5. Try adding icon to "Get E-mail" deskbar toolbar.
7. Support <ESC> to undo changes.
8. Set WordBreakProc so the user can CTRL-<Arrow> between "." and "@".


TODO List: Other




DONE:
2. Persist Last Entry
5. Fix font.
6. Make Return/Enter invoke [Go] button.
1. AutoComplete Email Addresses.
10. Launch new process to do the work
1. Design UI
2. Write Wizard


================================
BUGS: 
BUGS: Wizard (Progress & Choose App)
6. We may need to UTF8 encode the string when passing it to the command line so it will support cross codepage strings.
8. Find out what type of bitmap to use. (On top or on Left?)
9. Get the finished button to work correctly.
10. Timing: Hide wizard for 2 seconds and then show for at least 4.
11. Get last page to change "Next" to "Finished".
12. Copy NetPlWiz's code to create an Icon in the tab order.
14. Replace wizard's side graphic with one that includes an email message.

BUGS: OE The App
13. Make OE respect the flag if it already has any account.  But we need to check if this specific one exists.
14. Make OE work where it will pull up the app and open the accouts page.
15. Make the waiting wizard appear for at least 2-3 seconds(?)

BUGS: DeskBar
3. Resize Doesn't work when floating.
4. Test state when moving between bars.
7. Make editbox only as tall as it needs to be.
8. On focus, select all text.
9. Make the size correct when it's the first bar and docked to the bottom.
12. The editbox should be taller in the deskbar. (Same size as combobox)
1. Support Copy/Paste
2. Support Accessible so screen readers can read the content of the editbox.

*/

#endif // FEATURE_MAILBOX
#endif // _MAILBOX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\autodiscovery\client\mailbox.cpp ===
/*****************************************************************************\
    FILE: MailBox.cpp

    DESCRIPTION:
        This file implements the logic of the MailBox feature.

    BryanSt 2/26/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "priv.h"
#include <atlbase.h>        // USES_CONVERSION
#include "util.h"
#include "objctors.h"
#include <comdef.h>
#include <limits.h>         // INT_MAX
#include <commctrl.h>       // Str_SetPtr

#include "wizard.h"
#include "MailBox.h"
#include "emailassoc.h"

#ifdef FEATURE_MAILBOX
#define WM_AUTODISCOVERY_FINISHED               (WM_USER + 1)

// These are the wizard control IDs for the Back, Next, and Finished buttons.
#define IDD_WIZARD_BACK_BUTTON                0x3023
#define IDD_WIZARD_NEXT_BUTTON                0x3024
#define IDD_WIZARD_FINISH_BUTTON              0x3025



/**************************************************************************
   CLASS: CMailBoxProcess
**************************************************************************/
class CMailBoxProcess : public IUnknown
{
public:
    //IUnknown methods
    STDMETHODIMP QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(DWORD) AddRef();
    STDMETHODIMP_(DWORD) Release();

    HRESULT ParseCmdLine(LPTSTR lpCmdLine);
    HRESULT Run(void);

    CMailBoxProcess();
    ~CMailBoxProcess();

private:
    // Private Member Variables
    DWORD m_cRef;

    TCHAR m_szEmailAddress[MAX_EMAIL_ADDRESSS];
    TCHAR m_szNextText[MAX_PATH];
    BOOL m_fAutoDiscoveryFailed;            // Did the AutoDiscovery process fail?
    LPTSTR m_pszMailApp;                    // Which app was chosen?
    LPTSTR m_pszURL;                        // Which URL should be used to read mail?
    HWND m_hwndDialog;
    HRESULT m_hr;
    IMailAutoDiscovery * m_pMailAutoDiscovery;
    BOOL m_fGetDefaultAccount;              // If yes, open to wizard page asking for email address.
    BOOL m_fShowGetEmailAddressPage;        // Do we want to show the get email address wizard page?
    BOOL m_fCreateNewEmailAccount;          // Does the user want to create a new email account (like on one of the free email servers: hotmail, yahoo, etc.)

    // Private Member Functions
    HRESULT _DisplayDialogAndAutoDiscover(void);
    HRESULT _OpenWebBasedEmail(HKEY hkey);
    HRESULT _OpenExeBasedEmailApp(IN LPCWSTR pszMailApp);
    HRESULT _OpenProprietaryEmailApp(IN BSTR bstrProtocol, IN IMailProtocolADEntry * pMailProtocol);
    HRESULT _OpenEmailApp(void);
    HRESULT _RestoreNextButton(void);
    HRESULT _FillListWithApps(HWND hwndList);
    HRESULT _OnGetDispInfo(LV_DISPINFO * pDispInfo, bool fUnicode);
    HRESULT _OnChooseAppListFocus(void);
    HRESULT _OnChooseAppURLFocus(void);
    HRESULT _OnAppListSelection(LPNMLISTVIEW pListview);

    INT_PTR _MailBoxProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _GetEmailAddressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    INT_PTR _OnInit(HWND hDlg);
    INT_PTR _OnInitChooseApp(HWND hDlg);
    INT_PTR _OnUserCancelled(void);
    INT_PTR _OnFinished(HRESULT hr, BSTR bstrXML);
    INT_PTR _OnGetEmailAddressNext(void);
    INT_PTR _OnCommand(WPARAM wParam, LPARAM lParam);
    INT_PTR _OnFinishedManualAssociate(void);

    friend INT_PTR CALLBACK MailBoxProgressDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
    friend INT_PTR CALLBACK GetEmailAddressDialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

typedef struct tagEMAILCLIENT
{
    LPTSTR pszFriendlyName;
    LPTSTR pszPath;
    LPTSTR pszCmdLine;
    LPTSTR pszIconPath;
    LPTSTR pszEmailApp;
} EMAILCLIENT;





//===========================
// *** Class Internals & Helpers ***
//===========================
BOOL IsWhitespace(TCHAR Char)
{
    return ((Char == TEXT(' ')) || (Char == TEXT('\t')));
}


LPTSTR APIENTRY SkipWhite(LPTSTR pszString)
{
  while (pszString[0] && IsWhitespace(pszString[0]))
  {
      pszString = CharNext(pszString);
  }

  return pszString;
}


BOOL IsFlagSpecified(IN LPCTSTR pwzFlag, IN LPCTSTR pszArg)
{
    BOOL fIsFlagSpecified = FALSE;

    if ((TEXT('/') == pszArg[0]) ||
        (TEXT('-') == pszArg[0]))
    {
        if ((0 == StrCmpI(pwzFlag, &pszArg[1])) ||
            ((0 == StrCmpNI(pwzFlag, &pszArg[1], lstrlen(pwzFlag))) &&
             (IsWhitespace(pszArg[lstrlen(pwzFlag) + 1])) ) )
        {
            fIsFlagSpecified = TRUE;
        }
    }

    return fIsFlagSpecified;
}


LPTSTR GetNextArgument(LPTSTR pszCmdLine)
{
    pszCmdLine = StrChr(pszCmdLine, TEXT(' '));

    if (pszCmdLine)
    {
        pszCmdLine = SkipWhite(pszCmdLine);
    }

    return pszCmdLine;
}


void FreeEmailClient(EMAILCLIENT * pEmailClient)
{
    if (pEmailClient)
    {
        Str_SetPtr(&pEmailClient->pszFriendlyName, NULL);
        Str_SetPtr(&pEmailClient->pszPath, NULL);
        Str_SetPtr(&pEmailClient->pszCmdLine, NULL);
        Str_SetPtr(&pEmailClient->pszIconPath, NULL);
        Str_SetPtr(&pEmailClient->pszEmailApp, NULL);

        LocalFree(pEmailClient);
    }
}


HRESULT CMailBoxProcess::_DisplayDialogAndAutoDiscover(void)
{
    HWND hwndParent = NULL; // Do we need a parent?

    ATOMICRELEASE(m_pMailAutoDiscovery);
    m_fShowGetEmailAddressPage = (m_szEmailAddress[0] ? FALSE : TRUE);
    DisplayMailBoxWizard((LPARAM)this, m_fShowGetEmailAddressPage);

    HRESULT hr = m_hr;
    if (SUCCEEDED(hr))
    {
        // Create account.
        hr = E_FAIL;
        long nSize;

        // Loop thru the list looking for the first instance of a protocol
        // that we support.
        if (m_pMailAutoDiscovery)
        {
            hr = m_pMailAutoDiscovery->get_length(&nSize);
            if (SUCCEEDED(hr))
            {
                VARIANT varIndex;
                IMailProtocolADEntry * pMailProtocol = NULL;

                hr = E_FAIL;
                varIndex.vt = VT_I4;

                for (long nIndex = 0; (nIndex < nSize); nIndex++)
                {
                    varIndex.lVal = nIndex;
                    if (SUCCEEDED(m_pMailAutoDiscovery->get_item(varIndex, &pMailProtocol)))
                    {
                        BSTR bstrProtocol;
                        hr = pMailProtocol->get_Protocol(&bstrProtocol);

                        if (SUCCEEDED(hr))
                        {
                            // Is this protocol one of the ones we support?
                            if (!StrCmpIW(bstrProtocol, STR_PT_WEBBASED))
                            {
                                SysFreeString(bstrProtocol);
                                hr = EmailAssoc_CreateWebAssociation(m_szEmailAddress, pMailProtocol);
                                break;
                            }

                            // Is this protocol one of the ones we support?
                            if (!StrCmpIW(bstrProtocol, STR_PT_POP) || 
                                !StrCmpIW(bstrProtocol, STR_PT_IMAP) || 
                                !StrCmpIW(bstrProtocol, STR_PT_DAVMAIL))
                            {
                                hr = EmailAssoc_CreateStandardsBaseAssociation(m_szEmailAddress, bstrProtocol);
                                if (SUCCEEDED(hr))
                                {
                                    SysFreeString(bstrProtocol);
                                    break;
                                }
                            }

                            hr = _OpenProprietaryEmailApp(bstrProtocol, pMailProtocol);
                            SysFreeString(bstrProtocol);
                            if (SUCCEEDED(hr))
                            {
                                break;
                            }
                        }

                        ATOMICRELEASE(pMailProtocol);
                    }
                }

                ATOMICRELEASE(pMailProtocol);
            }
        }

        // We may have failed up until now because AutoDiscovery failed or was skipped,
        // but the user may have selected an app from the list.
        if (FAILED(hr))
        {
            if (m_pszMailApp)
            {
                HKEY hkey;

                hr = EmailAssoc_CreateEmailAccount(m_szEmailAddress, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = EmailAssoc_SetEmailAccountPreferredApp(hkey, m_pszMailApp);
                    RegCloseKey(hkey);
                }
            }
            else if (m_pszURL && m_pszURL[0])
            {
                HKEY hkey;

                hr = EmailAssoc_CreateEmailAccount(m_szEmailAddress, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = EmailAssoc_SetEmailAccountProtocol(hkey, SZ_REGDATA_WEB);
                    if (SUCCEEDED(hr))
                    {
                        hr = EmailAssoc_SetEmailAccountWebURL(hkey, m_pszURL);
                    }

                    RegCloseKey(hkey);
                }
            }
        }
    }

    return hr;
}


INT_PTR CALLBACK MailBoxProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CMailBoxProcess * pMBProgress = (CMailBoxProcess *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pMBProgress = (CMailBoxProcess *)pPropSheetPage->lParam;
        }
    }

    if (pMBProgress)
        return pMBProgress->_MailBoxProgressDialogProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CMailBoxProcess::_MailBoxProgressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fHandled = TRUE;   // handled

    switch (wMsg)
    {
    case WM_INITDIALOG:
        fHandled = _OnInit(hDlg);
        break;

    case WM_AUTODISCOVERY_FINISHED:
        fHandled = _OnFinished((HRESULT)wParam, (BSTR)lParam);
        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case LVN_GETDISPINFO:
            wMsg++;
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), ((TRUE == m_fShowGetEmailAddressPage) ? PSWIZB_NEXT | PSWIZB_BACK : PSWIZB_NEXT));
            fHandled = TRUE;   // Return zero to accept the activation.
            break;

        case PSN_WIZBACK:
            fHandled = TRUE; // Return zero to allow the user to go to the next page.
            break;

        case PSN_WIZNEXT:
            m_hr = S_FALSE;
            _RestoreNextButton();
            fHandled = 0; // Return zero to allow the user to go to the next page.
            break;

        case PSN_QUERYCANCEL:
            _OnUserCancelled();
            fHandled = FALSE;
            break;

        default:
            //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_MailBoxProgressDialogProc(wMsg = %d, pnmh->code = %d) WM_NOTIFY", wMsg, pnmh->code);
            break;
        }
    }

    default:
        //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_MailBoxProgressDialogProc(wMsg = %d) WM_NOTIFY", wMsg);
        fHandled = FALSE;   // Not handled
        break;
    }

    return fHandled;
}


INT_PTR CALLBACK ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CMailBoxProcess * pMBProgress = (CMailBoxProcess *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pMBProgress = (CMailBoxProcess *)pPropSheetPage->lParam;
        }
    }

    if (pMBProgress)
        return pMBProgress->_ChooseAppDialogProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


HRESULT CMailBoxProcess::_OnChooseAppURLFocus(void)
{
    HWND hwndURLEditbox = GetDlgItem(m_hwndDialog, IDC_CHOOSEAPP_WEBURL_EDIT);

    // Something happened to cause to have us shift into the "Other:" case.
    CheckDlgButton(m_hwndDialog, IDC_CHOOSEAPP_WEB_RADIO, BST_CHECKED);   // Uncheck the Web radio button
    CheckDlgButton(m_hwndDialog, IDC_CHOOSEAPP_OTHERAPP_RADIO, BST_UNCHECKED);   // Uncheck the Web radio button

    SetFocus(hwndURLEditbox);
    return S_OK;
}


INT_PTR CMailBoxProcess::_OnFinishedManualAssociate(void)
{
    // TODO: Only succeed the finished part if something is selected in the app list.
    //    Also gray out the button.
    m_hr = S_OK;

    // Did the user manually configure via "Web" or an app?
    
    if (IsDlgButtonChecked(m_hwndDialog, IDC_CHOOSEAPP_WEB_RADIO))
    {
        // Web.  So save the URL.
        TCHAR szURL[MAX_URL_STRING];

        GetWindowText(GetDlgItem(m_hwndDialog, IDC_CHOOSEAPP_WEBURL_EDIT), szURL, ARRAYSIZE(szURL));
        Str_SetPtr(&m_pszURL, szURL);
        Str_SetPtr(&m_pszMailApp, NULL);
    }

    return FALSE; // FALSE mean means allow it to close. TRUE means keep it open.
}

HRESULT CMailBoxProcess::_OnAppListSelection(LPNMLISTVIEW pListview)
{
    LPTSTR pszNewApp = NULL;        // None selected.

    // The user choose from the list.  So store the name of the app
    if (pListview && (-1 != pListview->iItem))
    {
        HWND hwndList = GetDlgItem(m_hwndDialog, IDC_CHOOSEAPP_APPLIST);
        LVITEM pItem = {0};

        pItem.iItem = pListview->iItem;
        pItem.iSubItem = pListview->iSubItem;
        pItem.mask = LVIF_PARAM;

        if (ListView_GetItem(hwndList, &pItem))
        {
            EMAILCLIENT * pEmailClient = (EMAILCLIENT *) pItem.lParam;

            if (pEmailClient)
            {
                pszNewApp = pEmailClient->pszEmailApp;
            }
        }
    }

    Str_SetPtr(&m_pszMailApp, pszNewApp);
    return S_OK;
}


HRESULT CMailBoxProcess::_OnChooseAppListFocus(void)
{
    HWND hwndAppList = GetDlgItem(m_hwndDialog, IDC_CHOOSEAPP_APPLIST);

    // Something happened to cause to have us shift into the "Other:" case.
    CheckDlgButton(m_hwndDialog, IDC_CHOOSEAPP_WEB_RADIO, BST_UNCHECKED);   // Uncheck the Web radio button
    CheckDlgButton(m_hwndDialog, IDC_CHOOSEAPP_OTHERAPP_RADIO, BST_CHECKED);   // Uncheck the Web radio button

    SetFocus(hwndAppList);
    return S_OK;
}


INT_PTR CMailBoxProcess::_ChooseAppDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fHandled = TRUE;   // handled

    switch (wMsg)
    {
    case WM_INITDIALOG:
        fHandled = _OnInitChooseApp(hDlg);
        PropSheet_SetWizButtons(GetParent(hDlg), ((TRUE == m_fShowGetEmailAddressPage) ? (PSWIZB_BACK | PSWIZB_FINISH) : PSWIZB_FINISH));
        break;

    case WM_COMMAND:
        fHandled = _OnCommand(wParam, lParam);
        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        int idEvent = pnmh->code;

        switch (idEvent)
        {
        case LVN_GETDISPINFOA:
            _OnGetDispInfo((LV_DISPINFO *)lParam, false);
            break;

        case LVN_GETDISPINFOW:
            _OnGetDispInfo((LV_DISPINFO *)lParam, true);
            break;

        case LVN_DELETEITEM:
            if (lParam)
            {
                FreeEmailClient((EMAILCLIENT *) ((NM_LISTVIEW *)lParam)->lParam);
            }
            break;

        case LVN_ITEMCHANGED:
            _OnChooseAppListFocus();
            _OnAppListSelection((LPNMLISTVIEW) lParam); // Keep track of the last selected item.
            break;

        case LVN_ITEMACTIVATE:
            break;

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), (PSWIZB_BACK | PSWIZB_FINISH));
            fHandled = TRUE;   // Return zero to accept the activation.
            break;

        case PSN_WIZBACK:
            // Set the prev. page to show
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LONG_PTR) 0);
            fHandled = -1;
            break;

        case PSN_WIZFINISH:
            fHandled = _OnFinishedManualAssociate();
            break;

        case PSN_QUERYCANCEL:
            m_hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
// TODO: 
            fHandled = FALSE;
            break;

        default:
            //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_ChooseAppDialogProc(wMsg = %d, pnmh->code = %d) WM_NOTIFY", wMsg, pnmh->code);
            break;
        }
        break;
    }

    default:
        fHandled = FALSE;   // Not handled
        //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_ChooseAppDialogProc(wMsg = %d)", wMsg);
        break;
    }

    return fHandled;
}


HRESULT CMailBoxProcess::_RestoreNextButton(void)
{
    HWND hwndNextButton = GetDlgItem(GetParent(m_hwndDialog), IDD_WIZARD_NEXT_BUTTON);

    if (hwndNextButton && m_szNextText[0])
    {
        SetWindowText(hwndNextButton, m_szNextText);
    }

    return S_OK;
}


INT_PTR CMailBoxProcess::_OnInit(HWND hDlg)
{
    BOOL fHandled = FALSE;   // Not handled
    HWND hwndWizard = GetParent(hDlg);
    TCHAR szSkipButton[MAX_PATH];
    HWND hwndNextButton = GetDlgItem(GetParent(hDlg), IDD_WIZARD_NEXT_BUTTON);

    m_hwndDialog = hDlg;
    if (hwndNextButton &&
        GetWindowText(hwndNextButton, m_szNextText, ARRAYSIZE(m_szNextText)))
    {
        // First, change the "Next" button into "Skip"
        // Save the text on the next button before we rename it.
        LoadString(HINST_THISDLL, IDS_SKIP_BUTTON, szSkipButton, ARRAYSIZE(szSkipButton));
        // Set the next text.
        SetWindowText(hwndNextButton, szSkipButton);
    }

    // Set Animation.
    HWND hwndAnimation = GetDlgItem(hDlg, IDC_AUTODISCOVERY_ANIMATION);
    if (hwndAnimation)
    {
        Animate_OpenEx(hwndAnimation, HINST_THISDLL, IDA_DOWNLOADINGSETTINGS);
    }

    // Start the background task.
    m_hr = CMailAccountDiscovery_CreateInstance(NULL, IID_PPV_ARG(IMailAutoDiscovery, &m_pMailAutoDiscovery));
    if (SUCCEEDED(m_hr))
    {
        m_hr = m_pMailAutoDiscovery->WorkAsync(hDlg, WM_AUTODISCOVERY_FINISHED);
        if (SUCCEEDED(m_hr))
        {
            m_hr = m_pMailAutoDiscovery->DiscoverMail(m_szEmailAddress);
        }
    }

    if (FAILED(m_hr))
    {
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
    }

    return fHandled;
}


INT_PTR CMailBoxProcess::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD wMsg = HIWORD(wParam);
    WORD idCtrl = LOWORD(wParam);

    switch (idCtrl)
    {
        case IDC_CHOOSEAPP_WEBURL_EDIT:
            switch (wMsg)
            {
                case EN_SETFOCUS:
                case STN_CLICKED:
                    _OnChooseAppURLFocus();
                    break;
                default:
                    //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wMsg=%#08lx, idCtrl=%#08lx", wMsg, idCtrl);
                    break;
            }
            break;

        case IDC_CHOOSEAPP_WEB_RADIO:
            switch (wMsg)
            {
                case BN_CLICKED:
                    _OnChooseAppURLFocus();
                    break;
                default:
                    //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wMsg=%#08lx, idCtrl=%#08lx", wMsg, idCtrl);
                    break;
            }
            break;

        case IDC_CHOOSEAPP_OTHERAPP_RADIO:
            switch (wMsg)
            {
                case BN_CLICKED:
                    _OnChooseAppListFocus();
                    break;
                default:
                    //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wMsg=%#08lx, idCtrl=%#08lx", wMsg, idCtrl);
                    break;
            }
            break;

        default:
            //TraceMsg(TF_ALWAYS, "in CMailBoxProcess::_OnCommand() wMsg=%#08lx, idCtrl=%#08lx", wMsg, idCtrl);
            break;
    }

    return fHandled;
}


INT_PTR CMailBoxProcess::_OnInitChooseApp(HWND hDlg)
{
    BOOL fHandled = FALSE;   // Not handled
    HWND hwndWizard = GetParent(hDlg);
    HWND hwndURLEditbox = GetDlgItem(hDlg, IDC_CHOOSEAPP_WEBURL_EDIT);

    m_hwndDialog = hDlg;
    // TODO: 2) Handle someone changing the combox box.

    LPCTSTR pszDomain = StrChr(m_szEmailAddress, CH_EMAIL_AT);
    if (pszDomain)
    {
        TCHAR szDesc[MAX_URL_STRING];

        pszDomain = CharNext(pszDomain);    // Skip past the "@"
        // Update the description on the dialog if the download failed.
        if (m_fAutoDiscoveryFailed)
        {
            TCHAR szTemplate[MAX_URL_STRING];

            LoadString(HINST_THISDLL, IDS_CHOOSEAPP_FAILED_RESULTS, szTemplate, ARRAYSIZE(szTemplate));
            wnsprintf(szDesc, ARRAYSIZE(szDesc), szTemplate, pszDomain);
            SetWindowText(GetDlgItem(hDlg, IDC_CHOOSEAPP_DESC), szDesc);
        }

        wnsprintf(szDesc, ARRAYSIZE(szDesc), TEXT("http://www.%s/"), pszDomain);
        SetWindowText(hwndURLEditbox, szDesc);
    }

    // Populate the List of Apps
    HWND hwndList = GetDlgItem(hDlg, IDC_CHOOSEAPP_APPLIST);

    if (hwndList)
    {
        HIMAGELIST himlLarge;
        HIMAGELIST himlSmall;

        if (Shell_GetImageLists(&himlLarge, &himlSmall))
        {
            RECT rc;
            LV_COLUMN col = {LVCF_FMT | LVCF_WIDTH, LVCFMT_LEFT};

            ListView_SetImageList(hwndList, himlLarge, LVSIL_NORMAL);
            ListView_SetImageList(hwndList, himlSmall, LVSIL_SMALL);

            GetWindowRect(hwndList, &rc);
            col.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL) - (4 * GetSystemMetrics(SM_CXEDGE));
            ListView_InsertColumn(hwndList, 0, &col);

            _FillListWithApps(hwndList);
// TODO: 1) On select in the list, force "Other:" to be checked.  2) If editbox changes, set "Web:"
        }
    }

    // Choose the Web Radio button because that will be the default.
    // (Most email systems tend to use web based)
    _OnChooseAppURLFocus();
    Edit_SetSel(hwndURLEditbox, 0, -1);

    return fHandled;
}


HRESULT _AddEmailClientToList(HWND hwndList, HKEY hkey, LPCTSTR pszMailApp, LPCTSTR pszFriendlyName)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = EmailAssoc_GetAppPath(hkey, szPath, ARRAYSIZE(szPath));

    if (SUCCEEDED(hr))
    {
        TCHAR szCmdLine[MAX_PATH];
        
        hr = EmailAssoc_GetAppCmdLine(hkey, szCmdLine, ARRAYSIZE(szCmdLine));
        if (SUCCEEDED(hr))
        {
            // Get the path we will use for the icon.
            TCHAR szIconPath[MAX_PATH];

            hr = EmailAssoc_GetIconPath(hkey, szIconPath, ARRAYSIZE(szIconPath));
            if (SUCCEEDED(hr))
            {
                EMAILCLIENT * pEmailClient = (EMAILCLIENT *) LocalAlloc(LPTR, sizeof(*pEmailClient));

                if (pEmailClient)
                {
                    if (PathFileExists(szIconPath))
                    {
                        // TODO: Add a separate reg value for icon in the new case.
                        Str_SetPtr(&pEmailClient->pszIconPath, szIconPath);
                    }

                    // TODO: We may want to use the dll's version resource because it
                    //   has a product description which may be localized.
                    Str_SetPtr(&pEmailClient->pszFriendlyName, pszFriendlyName);
                    Str_SetPtr(&pEmailClient->pszEmailApp, pszMailApp);
                    if (pEmailClient->pszFriendlyName)
                    {
                        Str_SetPtr(&pEmailClient->pszPath, szPath);
                        if (pEmailClient->pszPath)
                        {
                            if (szCmdLine[0])
                            {
                                Str_SetPtr(&pEmailClient->pszCmdLine, szCmdLine);
                            }

                            LV_ITEM item = {0};

                            item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
                            item.iItem = INT_MAX;
                            item.iSubItem = 0;
                            item.state = 0;
                            item.iImage = I_IMAGECALLBACK;
                            item.pszText = pEmailClient->pszFriendlyName;
                            item.lParam = (LPARAM)pEmailClient;

                            if (-1 == ListView_InsertItem(hwndList, &item))
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if (FAILED(hr))
                    {
                        FreeEmailClient(pEmailClient);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    return hr;
}


HRESULT CMailBoxProcess::_FillListWithApps(HWND hwndList)
{
    HRESULT hr = S_OK;
    HKEY hkey;

    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_MAILCLIENTS, 0, KEY_READ, &hkey);
    hr = HRESULT_FROM_WIN32(dwError);
    if (SUCCEEDED(hr))
    {
        TCHAR szFriendlyName[MAX_PATH];
        TCHAR szKeyName[MAX_PATH];
        TCHAR szCurrent[MAX_PATH];  // Nuke?
        TCHAR szFriendlyCurrent[MAX_PATH];
        FILETIME ftLastWriteTime;
        DWORD nIndex;              // Index counter
        DWORD cb;
        DWORD nSelected = 0;

        // find the currently selected client
        cb = sizeof(szCurrent);
        dwError = RegQueryValueEx(hkey, NULL, NULL, NULL, (LPBYTE)szCurrent, &cb);
        hr = HRESULT_FROM_WIN32(dwError);
        if (FAILED(hr))
        {
            // if not found then blank the friendly name and keyname.
            szCurrent[0] = 0;
            szFriendlyCurrent[0] = 0;
        }

        // populate the list
        for(nIndex = 0;
            cb = ARRAYSIZE(szKeyName), dwError = RegEnumKeyEx(hkey, nIndex, szKeyName, &cb, NULL, NULL, NULL, &ftLastWriteTime), hr = HRESULT_FROM_WIN32(dwError), SUCCEEDED(hr);
            nIndex++)
        {
            HKEY hkeyClient;

            // get the friendly name of the client
            dwError = RegOpenKeyEx(hkey, szKeyName, 0, KEY_READ, &hkeyClient);
            hr = HRESULT_FROM_WIN32(dwError);
            if (SUCCEEDED(hr))
            {
                cb = sizeof(szFriendlyName);

                dwError = RegQueryValueEx(hkeyClient, NULL, NULL, NULL, (LPBYTE)szFriendlyName, &cb);
                hr = HRESULT_FROM_WIN32(dwError);
                if (SUCCEEDED(hr))
                {
                    hr = _AddEmailClientToList(hwndList, hkeyClient, szKeyName, szFriendlyName);

                    // check to see if it's the current default
                    if (!StrCmp(szKeyName, szCurrent))
                    {
                        // save its the friendly name which we'll use later to
                        // select the current client and what index it is.
                        StrCpyN(szFriendlyCurrent, szFriendlyName, ARRAYSIZE(szFriendlyCurrent));
                        nSelected = nIndex;
                    }
                }

                // close key
                RegCloseKey(hkeyClient);
            }

        }   // for

        //  use a custom sort to delay the friendly names being used
//        ListView_SortItems(hwndList, _CompareApps, 0);

        // Lets select the appropriate entre.
        ListView_SetItemState(hwndList, nSelected, LVNI_FOCUSED, LVNI_SELECTED);

        // close the keys
        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT CMailBoxProcess::_OnGetDispInfo(LV_DISPINFO * pDispInfo, bool fUnicode)
{
    HRESULT hr = S_OK;

    if (pDispInfo && pDispInfo->item.mask & LVIF_IMAGE)
    {
        EMAILCLIENT * pEmailClient = (EMAILCLIENT *) pDispInfo->item.lParam;

        if (pEmailClient)
        {
            pDispInfo->item.iImage = -1;

            if (pEmailClient->pszIconPath)
            {
                pDispInfo->item.iImage = Shell_GetCachedImageIndex(pEmailClient->pszIconPath, 0, 0);
            }

            if (-1 == pDispInfo->item.iImage)
            {
                pDispInfo->item.iImage = Shell_GetCachedImageIndex(TEXT("shell32.dll"), II_APPLICATION, 0);
            }

            if (-1 != pDispInfo->item.iImage)
            {
                pDispInfo->item.mask = LVIF_IMAGE;
            }
        }
    }

    return hr;
}


INT_PTR CMailBoxProcess::_OnUserCancelled(void)
{
    m_hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // Means user cancelled
    _RestoreNextButton();

    return FALSE;   // Not handled
}



INT_PTR CMailBoxProcess::_OnFinished(HRESULT hr, BSTR bstrXML)
{
    SysFreeString(bstrXML);

    _RestoreNextButton();

    m_hr = hr;   // whatever the success value was...
    if (S_OK == m_hr)
    {
        // We succeeded so we can end the dialog
        PropSheet_PressButton(GetParent(m_hwndDialog), PSBTN_FINISH);
    }
    else
    {
        // The results came back but we can't continue.  So advance
        // to the Choose App page.
        m_fAutoDiscoveryFailed = TRUE;
        PropSheet_PressButton(GetParent(m_hwndDialog), PSBTN_NEXT);
    }

    return TRUE;   // handled
}


INT_PTR CALLBACK GetEmailAddressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CMailBoxProcess * pMBProgress = (CMailBoxProcess *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (WM_INITDIALOG == wMsg)
    {
        PROPSHEETPAGE * pPropSheetPage = (PROPSHEETPAGE *) lParam;

        if (pPropSheetPage)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, pPropSheetPage->lParam);
            pMBProgress = (CMailBoxProcess *)pPropSheetPage->lParam;
        }
    }

    if (pMBProgress)
        return pMBProgress->_GetEmailAddressDialogProc(hDlg, wMsg, wParam, lParam);

    return DefWindowProc(hDlg, wMsg, wParam, lParam);
}


INT_PTR CMailBoxProcess::_GetEmailAddressDialogProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fHandled = TRUE;   // handled

    switch (wMsg)
    {
    case WM_INITDIALOG:
        m_hwndDialog = hDlg;
        break;

    case WM_NOTIFY:
    {
        LPNMHDR pnmh = (LPNMHDR)lParam;
        switch (pnmh->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            fHandled = TRUE;   // Return zero to accept the activation.
            break;

        case PSN_WIZNEXT:
            fHandled = _OnGetEmailAddressNext();
            break;

        case PSN_QUERYCANCEL:
            m_hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // Means user cancelled
            fHandled = FALSE;
            break;

        default:
            //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_MailBoxProgressDialogProc(wMsg = %d, pnmh->code = %d) WM_NOTIFY", wMsg, pnmh->code);
            break;
        }
    }

    default:
        //TraceMsg(TF_ALWAYS, "CMailBoxProcess::_MailBoxProgressDialogProc(wMsg = %d) WM_NOTIFY", wMsg);
        fHandled = FALSE;   // Not handled
        break;
    }

    return fHandled;
}


INT_PTR CMailBoxProcess::_OnGetEmailAddressNext(void)
{
    BOOL fCancel = TRUE;

    GetWindowText(GetDlgItem(m_hwndDialog, IDC_GETEMAILADDRESS_EDIT), m_szEmailAddress, ARRAYSIZE(m_szEmailAddress));
    if (m_szEmailAddress[0] && StrChr(m_szEmailAddress, CH_EMAIL_AT))
    {
        // Looks valid to me.
        fCancel = 0;

        // TODO: Add more verification code
    }

    return fCancel; // 0 mean means allow it to close. TRUE means keep it open.
}


HRESULT CMailBoxProcess::_OpenEmailApp(void)
{
    HKEY hkey;
    HRESULT hr = EmailAssoc_OpenEmailAccount(m_szEmailAddress, &hkey);

    if (SUCCEEDED(hr))
    {
        WCHAR wzPreferredApp[MAX_PATH];

        // Did the user customize the app for this Email address? (Default is no)
        hr = EmailAssoc_GetEmailAccountPreferredApp(hkey, wzPreferredApp, ARRAYSIZE(wzPreferredApp));
        if (SUCCEEDED(hr))
        {
            // Yes, so let's launch that app.
            hr = _OpenExeBasedEmailApp(wzPreferredApp);
        }
        else
        {
            WCHAR wzProtocol[MAX_PATH];

            hr = EmailAssoc_GetEmailAccountProtocol(hkey, wzProtocol, ARRAYSIZE(wzProtocol));
            if (SUCCEEDED(hr))
            {
                // No, but that's fine because it's the default.
                if (!StrCmpIW(wzProtocol, SZ_REGDATA_WEB))
                {
                    hr = _OpenWebBasedEmail(hkey);
                }
                else
                {
                    hr = EmailAssoc_GetEmailAccountGetAppFromProtocol(wzProtocol, wzPreferredApp, ARRAYSIZE(wzPreferredApp));
                    if (SUCCEEDED(hr))
                    {
                        hr = _OpenExeBasedEmailApp(wzPreferredApp);
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT CMailBoxProcess::_OpenWebBasedEmail(HKEY hkey)
{
    WCHAR wzURL[MAX_URL_STRING];
    HRESULT hr = EmailAssoc_GetEmailAccountWebURL(hkey, wzURL, ARRAYSIZE(wzURL));

    if (0 == wzURL[0])
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // TODO: In the future, we can get more information from get_PostHTML().  With
        //     that information, we can either:
        // 1. Do an HTTP POST with header data that will simmulate logging into the server.
        //    This is good except that we need the password.
        // 2. We can put form value/data pair information into an pidl created from the URL.
        //    We can then have the browser pull this information out and pre-populate form
        //    items.  This will pre-populate the "User:" form item.  This way the user
        //    only needs to enter their password.
        hr = HrShellExecute(NULL, NULL, wzURL, NULL, NULL, SW_SHOW);
        if (SUCCEEDED(hr))
        {
            AddEmailToAutoComplete(m_szEmailAddress);
        }
    }

    return hr;
}


HRESULT CMailBoxProcess::_OpenExeBasedEmailApp(IN LPCWSTR pszMailApp)
{
    HKEY hkey;
    HRESULT hr = EmailAssoc_OpenMailApp(pszMailApp, &hkey);

    // TODO: Call _InstallLegacyAssociations() to make sure the associations are correct.
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_URL_STRING];

        hr = EmailAssoc_GetAppPath(hkey, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            TCHAR szCmdLine[MAX_URL_STRING];

            szCmdLine[0] = 0;
            if (SUCCEEDED(EmailAssoc_GetAppCmdLine(hkey, szCmdLine, ARRAYSIZE(szCmdLine))) &&  // optional
                !StrStrI(SZ_TOKEN_EMAILADDRESS, szCmdLine))
            {
                // They have a cmdline and they want us to replace a token.
                StrReplaceToken(SZ_TOKEN_EMAILADDRESS, m_szEmailAddress, szCmdLine, ARRAYSIZE(szCmdLine));
            }

            hr = HrShellExecute(NULL, NULL, szPath, (szCmdLine[0] ? szCmdLine : NULL), NULL, SW_SHOW);
            if (SUCCEEDED(hr))
            {
                AddEmailToAutoComplete(m_szEmailAddress);
            }
        }

        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT CMailBoxProcess::_OpenProprietaryEmailApp(BSTR bstrProtocol, IMailProtocolADEntry * pMailProtocol)
{
    HRESULT hr = E_FAIL;

    // TODO:
    MessageBox(NULL, TEXT("Open Proprietary Email App here.  We look up in the registry for these types of apps.  AOL, MSN, Compuserv are examples."), TEXT("Looser"), MB_OK);

    return hr;
}





//===========================
// *** Public Methods ***
//===========================
HRESULT CMailBoxProcess::ParseCmdLine(LPTSTR pszCmdLine)
{
    // We don't treat quote sections as blocks.
    PathUnquoteSpaces(pszCmdLine);

    while (pszCmdLine && pszCmdLine[0])
    {
        if (IsFlagSpecified(TEXT("email"), pszCmdLine))
        {
            pszCmdLine = GetNextArgument(pszCmdLine);

            if (pszCmdLine)
            {
                if ((TEXT('/') == pszCmdLine[0]) || (TEXT('-') == pszCmdLine[0]))
                {
                }
                else
                {
                    LPTSTR pszEndOfEmailAddress = StrChr(pszCmdLine, TEXT(' '));
                    SIZE_T cchSizeToCopy = ARRAYSIZE(m_szEmailAddress);

                    if (pszEndOfEmailAddress && (cchSizeToCopy > (SIZE_T)(pszEndOfEmailAddress - pszCmdLine)))
                    {
                        cchSizeToCopy = (pszEndOfEmailAddress - pszCmdLine) + 1;
                    }

                    StrCpyN(m_szEmailAddress, pszCmdLine, (int)cchSizeToCopy);
                    pszCmdLine = GetNextArgument(pszCmdLine);
                }
            }
            continue;
        }

        if (IsFlagSpecified(TEXT("GetDefaultAccount"), pszCmdLine))
        {
            pszCmdLine = GetNextArgument(pszCmdLine);

            m_fGetDefaultAccount = TRUE;
            continue;
        }

        if (IsFlagSpecified(TEXT("CreateNewEmailAccount"), pszCmdLine))
        {
            pszCmdLine = GetNextArgument(pszCmdLine);

            m_fCreateNewEmailAccount = TRUE;
            continue;
        }

        pszCmdLine = GetNextArgument(pszCmdLine);
    }

    return S_OK;
}


HRESULT CMailBoxProcess::Run(void)
{
    HRESULT hr = CoInitialize(0);

    if (SUCCEEDED(hr))
    {
        if (TRUE == m_fCreateNewEmailAccount)
        {
            // TODO: look in the registry for the default email account and
            //   copy it into m_szEmailAddress.
            MessageBox(NULL, TEXT("Create New Email Account"), TEXT("TODO: Add code here."), MB_OK);
        }
        else
        {
            if (TRUE == m_fGetDefaultAccount)
            {
                // If the caller wants to use the default email address, then look in the registry
                // for it and use that address.
                if (FAILED(EmailAssoc_GetDefaultEmailAccount(m_szEmailAddress, ARRAYSIZE(m_szEmailAddress))))
                {
                    m_szEmailAddress[0] = 0;
                }
            }

            // Legacy email applications didn't install email associations, so we
            // do that for them now.
            EmailAssoc_InstallLegacyMailAppAssociations();

            if (m_szEmailAddress[0])
            {
                // Since we know the email address, try t