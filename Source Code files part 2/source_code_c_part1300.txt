UE;
            FoundSource = Source->Next;

            //
            // Move to front of list of source modules.
            //

            Source->Next = FoundSource->Next;    // Remove from list
            FoundSource->Next = LsapAdtSourceModules; // point to first element
            LsapAdtSourceModules = FoundSource;       // Make it the first element

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tModule Found.\n");
#endif

        } else {

            Source = Source->Next;
        }
    }


    if (Found == TRUE) {

        //
        // Find the object
        //

        Object = (PLSAP_ADT_OBJECT)&(FoundSource->Objects);
        Found  = FALSE;

        while ((Object->Next != NULL) && !Found) {

            if (RtlEqualUnicodeString(&Object->Next->Name, ObjectTypeName, TRUE)) {

                Found = TRUE;
                FoundObject = Object->Next;

                //
                // Move to front of list of soure modules.
                //

                Object->Next = FoundObject->Next;          // Remove from list
                FoundObject->Next = FoundSource->Objects;  // point to first element
                FoundSource->Objects = FoundObject;        // Make it the first element

            } else {

                Object = Object->Next;
            }
        }
    }


    //
    // We are done playing with link fields of the source modules
    // and objects.  Free the lock.
    //

    LsapAdtSourceModuleUnlock();

    //
    // If we have found an object, use it as our base message
    // ID.  Otherwise, use SE_ACCESS_NAME_SPECIFIC_0.
    //

    if (Found) {

        BaseOffset = FoundObject->BaseOffset;
#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tObject Found.  Base Offset: 0x%lx\n", BaseOffset);
#endif

    } else {

        BaseOffset = SE_ACCESS_NAME_SPECIFIC_0;
#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tObject NOT Found.  Base Offset: 0x%lx\n", BaseOffset);
#endif
    }


    //
    // At this point, we have a base offset (even if we had to use our
    // default).
    //
    // Now cycle through the specific access bits and see which ones need
    // to be added to ResultantString.
    //

    {
        UNICODE_STRING  IntegerString;
        WCHAR           IntegerStringBuffer[10]; //must be 10 wchar bytes long
        ULONG           NextBit;

        IntegerString.Buffer = (PWSTR)IntegerStringBuffer;
        IntegerString.MaximumLength = 10*sizeof(WCHAR);
        IntegerString.Length = 0;

        for ( i=0, NextBit=1  ; i<16 ;  i++, NextBit <<= 1 ) {

            //
            // specific access flags are in the low-order bits of the mask
            //

            if ((NextBit & Accesses) != 0) {

                //
                // Found one  -  add it to ResultantString
                //

                Status = RtlIntegerToUnicodeString (
                             (BaseOffset + i),
                             10,        //Base
                             &IntegerString
                             );

                if (NT_SUCCESS(Status)) {

                    Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
                    ASSERT( NT_SUCCESS( Status ));

                    Status = RtlAppendUnicodeStringToString( ResultantString, &IntegerString);
                    ASSERT( NT_SUCCESS( Status ));

                    if ( Indent ) {
                        Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
                    } else {
                        Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
                    }
                    ASSERT( NT_SUCCESS( Status ));
                }
            }
        }
    }

    return(Status);


//ErrorAfterAlloc:
//
//    LsapFreeLsaHeap( ResultantString->Buffer );
//    ResultantString->Buffer = NULL;
//    (*FreeWhenDone) = FALSE;
//    return(Status);
}

// ======================================================================
// dbpriv.c
// ======================================================================

NTSTATUS
LsapBuildPrivilegeAuditString(
    IN PPRIVILEGE_SET PrivilegeSet,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DashString;
    BOOLEAN FreeDash;
    
    
    Status= LsapAdtBuildDashString(
                &DashString,
                &FreeDash
                );

    if ( !NT_SUCCESS( Status )) {
        return( Status );
    }

    *ResultantString = DashString;
    *FreeWhenDone = FALSE;
    
    return Status;
}

NTSTATUS
LsapAdtWriteLog(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters OPTIONAL,
    IN ULONG Options
    )
{
    return LsapAdtDemarshallAuditInfo( AuditParameters );
}

BOOLEAN
LsapAdtIsAuditingEnabledForCategory(
    IN POLICY_AUDIT_EVENT_TYPE AuditCategory,
    IN UINT AuditEventType
    )
{
    return TRUE;
}

VOID
LsapAuditFailed(
    IN NTSTATUS AuditStatus
    )
{
    UNREFERENCED_PARAMETER(AuditStatus);
}


#endif // !defined(lint)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\azaccess.h ===
EXTERN_C
DWORD InitAuthzAccessChecks();

EXTERN_C
DWORD
AuthzDoAccessCheck(
    IN ULONG NumAccessChecks, 
    IN DWORD Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\benchmrk.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       B E N C H M R K . C P P
//
//  Contents:   Benchmarking class
//
//  Notes:
//
//  Author:     billbe   13 Oct 1997
//
//---------------------------------------------------------------------------

#include "pch.h"

#pragma hdrstop

#include "benchmrk.h"

CBenchmark::CBenchmark()
: m_i64Frequency(1000),
  m_sznDescription(NULL),
  m_i64TotalTime(0),
  m_fStarted(FALSE)
{
    LARGE_INTEGER li1;

    // Check if QueryPerformanceCounter is supported
    if (QueryPerformanceCounter(&li1))
    {
        // Now get # of ticks per second
        QueryPerformanceFrequency(reinterpret_cast<LARGE_INTEGER*>
                (&m_i64Frequency));

        //wprintf(L"QueryPerformanceFrequency: %I64d\n", m_i64Frequency);
        m_fSupported = TRUE;
    }
    else
    {
        //        TraceTag(ttidBenchmark, "High performance counter is not supported.");
        m_fSupported = FALSE;
        wprintf(L"QueryPerformanceFrequency: not supported!!\n");
    }
}

CBenchmark::~CBenchmark()
{
    delete [] m_sznDescription;
}


void
CBenchmark::Start(PCWSTR sznDescription)
{
    // If QueryPerformanceCounter is supported
    if (m_fSupported)
    {
        // replace with new one if specified
        if (sznDescription)
        {
            // delete the old description
            delete [] m_sznDescription;

            m_sznDescription = new WCHAR[lstrlen(sznDescription) + 1];
            if (m_sznDescription)
            {
                lstrcpy(m_sznDescription, sznDescription);
            }
        }
        else
        {
            // no description specified clear the member variable
            m_sznDescription = NULL;
        }
        m_fStarted = TRUE;
        m_i64TotalTime = 0;

        // Record our start time
        QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>
                (&m_i64StartTime));
    }
}

void
CBenchmark::Stop()
{
    __int64 i64Stop;
    // Record our stop time
    QueryPerformanceCounter(reinterpret_cast<LARGE_INTEGER*>(&i64Stop));

    // If start was called prior to stop, then record the total time and
    // reset our m_fStarted flag
    //
    if (m_fStarted)
    {
        m_fStarted = FALSE;
        m_i64TotalTime = i64Stop - m_i64StartTime;
    }
    else
    {
        // invalidate previous benchmark since stop was called before start
        m_i64TotalTime = 0;
    }
}

PCWSTR
CBenchmark::SznBenchmarkSeconds(unsigned short usPrecision)
{
    WCHAR sznFmt[10];
    swprintf(sznFmt, L"%%.%df", usPrecision);
    swprintf(m_sznSeconds, sznFmt, DblBenchmarkSeconds());
    return m_sznSeconds;
}

CBenchmark g_timer;

void timer_start()
{
    g_timer.Start(NULL);
}

void timer_stop()
{
    g_timer.Stop();
}

PCWSTR timer_secs()
{
    return g_timer.SznBenchmarkSeconds(5);
}

double timer_time()
{
    return g_timer.DblBenchmarkSeconds();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\main.cpp ===
#include "pch.h"
#pragma hdrstop

#include "ntaccess.h"
#include "azaccess.h"
#include "bmcommon.h"
#include "benchmrk.h"

EXTERN_C AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager;
EXTERN_C AUTHZ_RM_AUDIT_INFO_HANDLE hRmAuditInfo;
double az_time, nt_time;
EXTERN_C PAUTHZ_ACCESS_REPLY pReply, pReplyOT;
EXTERN_C AUTHZ_AUDIT_INFO_HANDLE hAuditInfo;
void DoBenchMarks( IN ULONG NumIter, IN DWORD Flags )
{
    DWORD dwError=NO_ERROR;

    //
    // do NT access checks
    //
    dwError = InitNtAccessChecks();

    if ( dwError != NO_ERROR )
    {
        goto Cleanup;
    }

    wprintf(L"NtAccessChecks     : ");
    fflush(stdout);

    timer_start();
    
    dwError = DoNtAccessChecks( NumIter, Flags );

    if ( dwError != NO_ERROR )
    {
        goto Cleanup;
    }

    timer_stop();
    nt_time = timer_time();
    wprintf(L"%.2f sec\n", nt_time);
    
    //
    // do authz access checks
    //

    dwError = InitAuthzAccessChecks();

    if ( dwError != NO_ERROR )
    {
        goto Cleanup;
    }

    wprintf(L"AzAccessChecks     : ");
    fflush(stdout);

    timer_start();
    
    dwError = AuthzDoAccessCheck( NumIter, Flags );

    if ( dwError != NO_ERROR )
    {
        goto Cleanup;
    }

    timer_stop();
    az_time = timer_time();
    wprintf(L"%.2f sec\n", az_time);
    wprintf(L"perf ratio    : %2.2f \n", nt_time/az_time);
    
    //
    // make sure that both az and nt returned the same results
    //
    UINT len;
    
    if ( Flags & BMF_UseObjTypeList )
    {
        len = ObjectTypeListLength;

        for (UINT i=0; i < len; i++)
        {
            if ((pReplyOT->Error[i] != fNtAccessCheckResult[i]) ||
                ((pReplyOT->Error[i] == ERROR_SUCCESS) && (pReplyOT->GrantedAccessMask[i] != dwNtGrantedAccess[i])))
            {
                wprintf(L"AccessCheck mismatch @ %d\n", i);
                wprintf(L"AGA: %08lx\tAE: %08lx\nNGA: %08lx\tNE: %08lx\n",
                        pReplyOT->GrantedAccessMask[i],
                        pReplyOT->Error[i],
                        dwNtGrantedAccess[i],
                        fNtAccessCheckResult[i]);
            }
        }
    
    }
    else
    {
        if (
            ((pReply->Error[0] == ERROR_SUCCESS) && (0 == fNtAccessCheckResult[0])) ||
            ((pReply->Error[0] != ERROR_SUCCESS) && (1 == fNtAccessCheckResult[0])) ||
            ((pReply->Error[0] == ERROR_SUCCESS) && (pReply->GrantedAccessMask[0] != dwNtGrantedAccess[0]))
           )
        {
            wprintf(L"AccessCheck mismatch\n");
            wprintf(L"AGA: %08lx\tAE: %08lx\nNGA: %08lx\tNE: %08lx\n",
                    pReply->GrantedAccessMask[0],
                    pReply->Error[0],
                    dwNtGrantedAccess[0],
                    fNtAccessCheckResult[0]);
        }
    }

    //
    // make sure that both az and nt returned the same results
    //
    
    if ( Flags & BMF_UseObjTypeList )
    {
        len = ObjectTypeListLength;

        for (UINT i=0; i < len; i++)
        {

            if ((pReplyOT->Error[i] != fNtAccessCheckResult[i]) ||
                ((pReplyOT->Error[i] == ERROR_SUCCESS) && (pReplyOT->GrantedAccessMask[i] != dwNtGrantedAccess[i])))
            {
                wprintf(L"AccessCheck mismatch @ %d\n", i);
                wprintf(L"AGA: %08lx\tAE: %08lx\nNGA: %08lx\tNE: %08lx\n",
                        pReplyOT->GrantedAccessMask[i],
                        pReplyOT->Error[i],
                        dwNtGrantedAccess[i],
                        fNtAccessCheckResult[i]);
            }
        }
    
    }
    else
    {

        if (
            ((pReply->Error[0] == ERROR_SUCCESS) && (0 == fNtAccessCheckResult[0])) ||
            ((pReply->Error[0] != ERROR_SUCCESS) && (1 == fNtAccessCheckResult[0])) ||
            ((pReply->Error[0] == ERROR_SUCCESS) && (pReply->GrantedAccessMask[0] != dwNtGrantedAccess[0]))
           )
        {
            wprintf(L"AccessCheck mismatch\n");
            wprintf(L"AGA: %08lx\tAE: %08lx\nNGA: %08lx\tNE: %08lx\n",
                    pReply->GrantedAccessMask[0],
                    pReply->Error[0],
                    dwNtGrantedAccess[0],
                    fNtAccessCheckResult[0]);
        }
    }

    return;
    
Cleanup:
    wprintf(L"DoBenchMarks failed: %lx\n", dwError);
}


#define OTO_OT   1
#define OTO_SO   2
#define OTO_OTSO 3

PWCHAR szUsage = L"Usage: azbm iter-count ot-option access-mask sd-index audit-flag";


extern "C" int __cdecl wmain(int argc, PWSTR argv[])
{
    NTSTATUS Status;
    ULONG NumChecks = 10000;
    BOOLEAN WasEnabled;
    ULONG OtOptions;
    ACCESS_MASK DesiredAccess;
    ULONG SdIndex;
    DWORD fGenAudit;

    if ( argc != 6 )
    {
        wprintf(szUsage);
        exit(-1);
    }

    if (1 != swscanf(argv[1], L"%d", &NumChecks))
    {
        wprintf(L"Bad iteration-count");
        exit(-1);
    }
    
    if (1 != swscanf(argv[2], L"%d", &OtOptions))
    {
        wprintf(L"Bad ot-option");
        exit(-1);
    }
    
    if (1 != swscanf(argv[3], L"%x", &DesiredAccess))
    {
        wprintf(L"Bad access-mask");
        exit(-1);
    }
    g_DesiredAccess = DesiredAccess;

    
    if (1 != swscanf(argv[4], L"%d", &SdIndex))
    {
        wprintf(L"Bad sd-index");
        exit(-1);
    }
    g_szSd = g_aszSd[SdIndex];
    
    if (1 != swscanf(argv[5], L"%d", &fGenAudit))
    {
        wprintf(L"Bad audit-flag");
        exit(-1);
    }
    
    Status = RtlAdjustPrivilege(
                SE_AUDIT_PRIVILEGE,
                TRUE,                   // enable
                FALSE,                   // do it on the thread token
                &WasEnabled
                );
    if (!NT_SUCCESS(Status))
    {
        wprintf(L"RtlAdjustPrivilege: %lx\n", Status);
    }

    if ( fGenAudit )
    {
        if ( OtOptions & OTO_SO )
        {
            wprintf(L"regular access checks with audit\n");
            wprintf(L"---------------------\n");
            DoBenchMarks( NumChecks, BMF_GenerateAudit );
        }

        if ( OtOptions & OTO_OT )
        {
            wprintf(L"\n\naccess checks with obj-type list with audit\n");
            wprintf(L"--------------------------------\n");
            DoBenchMarks( NumChecks, BMF_UseObjTypeList | BMF_GenerateAudit );
        }
    }
    else
    {
        if ( OtOptions & OTO_SO )
        {
            wprintf(L"regular access checks\n");
            wprintf(L"---------------------\n");
            DoBenchMarks( NumChecks, 0 );
        }

        if ( OtOptions & OTO_OT )
        {
            wprintf(L"\n\naccess checks with obj-type list\n");
            wprintf(L"--------------------------------\n");
            DoBenchMarks( NumChecks, BMF_UseObjTypeList );
        }
    }
    AuthzFreeAuditInfo(hAuditInfo);
    AuthzFreeAuditQueue(NULL);
    AuthzFreeResourceManager(hAuthzResourceManager);
    
    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\bmcommon.h ===
#define BMF_GenerateAudit  1
#define BMF_UseObjTypeList 2


EXTERN_C DWORD ObjectTypeListLength;
EXTERN_C OBJECT_TYPE_LIST ObjectTypeList[];

EXTERN_C DWORD fNtAccessCheckResult[];
//EXTERN_C BOOL fAzAccessCheckResult[];

EXTERN_C DWORD dwNtGrantedAccess[];
//EXTERN_C DWORD dwAzGrantedAccess[];

//#define DESIRED_ACCESS MAXIMUM_ALLOWED
//#define DESIRED_ACCESS 0xff
//#define DESIRED_ACCESS 0x1000
#define DESIRED_ACCESS g_DesiredAccess

EXTERN_C PSID g_Sid1;

EXTERN_C ACCESS_MASK g_DesiredAccess;

EXTERN_C PWCHAR g_szSd;

EXTERN_C PWCHAR g_aszSd[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\ntaccess.c ===
#include "pch.h"
#pragma hdrstop

#include "bmcommon.h"

static GENERIC_MAPPING FileGenericMapping =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};

static PSECURITY_DESCRIPTOR pSD;
static HANDLE hToken;


EXTERN_C
DWORD 
InitNtAccessChecks()
{
    DWORD dwError=NO_ERROR;
    BOOL b;
    PWCHAR szMsg=NULL;
    HANDLE hProcessToken=NULL;
    
    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(g_szSd,
                                                             SDDL_REVISION_1,
                                                             &pSD, NULL);

    if (!b)
    {
        szMsg = L"SDDL";
        goto GetError;
    }

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_DUPLICATE,
                            &hProcessToken ) )
    {
        szMsg = L"OpenProcessToken";
        goto GetError;
    }

    
    if ( !DuplicateToken( hProcessToken, SecurityImpersonation, &hToken ) )
    {
        szMsg = L"DuplicateToken";
        goto GetError;
    }

    
    if ( !SetThreadToken( NULL, hToken ) )
    {
        szMsg = L"SetThreadToken";
        goto GetError;
    }
    
Cleanup:

    if ( hProcessToken )
    {
        CloseHandle( hProcessToken );
    }

    if ( szMsg )
    {
        wprintf (L"InitNtAccessChecks: %s: %x\n", szMsg, dwError);
    }

    return dwError;

GetError:
    dwError = GetLastError();
    goto Cleanup;
    
}

EXTERN_C
DWORD 
DoNtAccessChecks(
    IN ULONG NumChecks,
    IN DWORD Flags
    )
{
    DWORD dwError=NO_ERROR;
    PWCHAR StringSD = L"O:BAG:BAD:(OA;;GA;;;WD)S:(AU;FASA;GA;;;WD)";
    BOOL b;
    ULONG i;
    PRIVILEGE_SET Privs = { 0 };
    DWORD dwPrivLength=20*sizeof(LUID_AND_ATTRIBUTES);
    BOOL fGenOnClose[100];
    PWCHAR szMsg=NULL;
    HANDLE hObj= (HANDLE) 333444;

    if ( Flags & BMF_GenerateAudit )
    {
        if ( Flags & BMF_UseObjTypeList )
        {
            for (i=0; i < NumChecks; i++)
            {
                if (!AccessCheckByTypeResultListAndAuditAlarm(
                        L"supersystemwithaudit",
                        hObj,
                        L"Kernel speed test",
                        L"sample operation",
                        pSD,
                        g_Sid1,
                        DESIRED_ACCESS,
                        AuditEventObjectAccess,
                        0,
                        ObjectTypeList,
                        ObjectTypeListLength,
                        &FileGenericMapping,
                        FALSE,
                        dwNtGrantedAccess,
                        fNtAccessCheckResult,
                        fGenOnClose ))
                {
                    szMsg = L"AccessCheck";
                    goto GetError;
                }
            }
        }
        else
        {
            for (i=0; i < NumChecks; i++)
            {
                if (!AccessCheckAndAuditAlarm(
                        L"mysystem",
                        hObj,
                        L"File",
                        L"file-object",
                        pSD, DESIRED_ACCESS,
                        &FileGenericMapping,
                        FALSE,
                        &dwNtGrantedAccess[0],
                        &fNtAccessCheckResult[0],
                        &fGenOnClose[0] ))
                {
                    szMsg = L"AccessCheck";
                    goto GetError;
                }
            }
        }
    }
    else
    {
        if ( Flags & BMF_UseObjTypeList )
        {
            for (i=0; i < NumChecks; i++)
            {
                if (!AccessCheckByTypeResultList(
                    pSD,
                    g_Sid1,
                    hToken, DESIRED_ACCESS,
                    ObjectTypeList,
                    ObjectTypeListLength,
                    &FileGenericMapping,
                    &Privs, &dwPrivLength,
                    dwNtGrantedAccess,
                    fNtAccessCheckResult ))
                {
                    szMsg = L"AccessCheck";
                    goto GetError;
                }
            }
        }
        else
        {
            for (i=0; i < NumChecks; i++)
            {
                if (!AccessCheck( pSD, hToken, DESIRED_ACCESS,
                                  &FileGenericMapping,
                                  &Privs, &dwPrivLength,
                                  &dwNtGrantedAccess[0],
                                  &fNtAccessCheckResult[0] ))
                {
                    szMsg = L"AccessCheck";
                    goto GetError;
                }
            }
        }
    }
    
Cleanup:
    if ( szMsg )
    {
        wprintf (L"%s: %x\n", szMsg, dwError);
    }

    return dwError;

GetError:
    dwError = GetLastError();
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\bmcommon.c ===
#include "pch.h"

#pragma hdrstop

#include "bmcommon.h"


PWCHAR g_aszSd[] =
{
    L"O:BAG:BAD:(OA;;GA;;;WD)S:(AU;FASA;GA;;;WD)",

    L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)",

    //
    // mkdit.ini : [User]
    //
    L"O:BAG:DUD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;WD)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;AO)(A;;RPLCLORC;;;PS)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;PS)(OA;;CR;ab721a54-1e2f-11d0-9819-00aa0040529b;;PS)(OA;;CR;ab721a56-1e2f-11d0-9819-00aa0040529b;;PS)(OA;;RPWP;77B5B886-944A-11d1-AEBD-0000F80367C1;;PS)(OA;;RPWP;E45795B2-9455-11d1-AEBD-0000F80367C1;;PS)(OA;;RPWP;E45795B3-9455-11d1-AEBD-0000F80367C1;;PS)(OA;;RP;037088f8-0ae1-11d2-b422-00a0c968f939;;RS)(OA;;RP;4c164200-20c0-11d0-a768-00aa006e0529;;RS)(OA;;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;;RS)(A;;RC;;;AU)(OA;;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;;AU)(OA;;RP;77B5B886-944A-11d1-AEBD-0000F80367C1;;AU)(OA;;RP;E45795B3-9455-11d1-AEBD-0000F80367C1;;AU)(OA;;RP;e48d0154-bcf8-11d1-8702-00c04fb96050;;AU)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;WD)(OA;;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;;RS)(OA;;RPWP;bf967a7f-0de6-11d0-a285-00aa003049e2;;CA)S:(AU;IDSAFA;0xFFFFFF;;;WD)",

    //
    // mkdit.ini : [Computer]
    //
    L"O:BAG:DUD:(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;DA)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;AO)(A;;RPWPCRCCDCLCLORCWOWDSDDTSW;;;SY)(A;;RPCRLCLORCSDDT;;;CO)(OA;;WP;4c164200-20c0-11d0-a768-00aa006e0529;;CO)(A;;RPLCLORC;;;AU)(OA;;CR;ab721a53-1e2f-11d0-9819-00aa0040529b;;WD)(OA;;CCDC;;;PS)(OA;;CCDC;bf967aa8-0de6-11d0-a285-00aa003049e2;;PO)(OA;;RPWP;bf967a7f-0de6-11d0-a285-00aa003049e2;;CA)(OA;;SW;f3a64788-5306-11d1-a9c5-0000f80367c1;;PS)(OA;;RPWP;77B5B886-944A-11d1-AEBD-0000F80367C1;;PS)(OA;;SW;72e39547-7b18-11d1-adef-00c04fd8d5cd;;PS)(OA;;SW;72e39547-7b18-11d1-adef-00c04fd8d5cd;;CO)(OA;;SW;f3a64788-5306-11d1-a9c5-0000f80367c1;;CO)"
    
    //
    // Domain-DNS (from Praerit)
    //
    //L"D:(A;;RP;;;WD)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;ED)(OA;;CR;1131f6aa-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ab-9c07-11d1-f79f-00c04fc2dcd2;;BA)(OA;;CR;1131f6ac-9c07-11d1-f79f-00c04fc2dcd2;;BA)(A;;RPLCLORC;;;AU)(A;;RPWPCRLCLOCCRCWDWOSW;;;DA)(A;CI;RPWPCRLCLOCCRCWDWOSDSW;;;BA)(A;;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;SY)(A;CI;RPWPCRLCLOCCDCRCWDWOSDDTSW;;;EA)(A;CI;LC;;;RU)(OA;CIIO;RP;037088f8-0ae1-11d2-b422-00a0c968f939;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;59ba2f42-79a2-11d0-9020-00c04fc2d3cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;bc0ac240-79a9-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;4c164200-20c0-11d0-a768-00aa006e0529;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RP;5f202010-79a5-11d0-9020-00c04fc2d4cf;bf967aba-0de6-11d0-a285-00aa003049e2;RU)(OA;CIIO;RPLCLORC;;bf967a9c-0de6-11d0-a285-00aa003049e2;RU)(A;;RC;;;RU)(OA;CIIO;RPLCLORC;;bf967aba-0de6-11d0-a285-00aa003049e2;RU)S:(AU;CISAFA;WDWOSDDTWPCRCCDCSW;;;WD)"

};

PWCHAR g_szSd;

GUID Guid0 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x00}};
GUID Guid1 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x01}};
GUID Guid2 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x02}};
GUID Guid3 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x03}};
GUID Guid4 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x04}};
GUID Guid5 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x05}};
GUID Guid6 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x06}};
GUID Guid7 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x07}};
GUID Guid8 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x08}};


DWORD ObjectTypeListLength= 8;
OBJECT_TYPE_LIST ObjectTypeList[] =
{
    { 0, 0, &Guid0 },
    { 1, 0, &Guid1 },
    { 2, 0, &Guid2 },
    { 2, 0, &Guid3 },
    { 1, 0, &Guid4 },
    { 2, 0, &Guid5 },
    { 3, 0, &Guid6 },
    { 2, 0, &Guid7 }
};

DWORD fNtAccessCheckResult[200] = { 2 };
BOOL fAzAccessCheckResult[200];

DWORD dwNtGrantedAccess[200] = { 0xaabbccdd };
DWORD dwAzGrantedAccess[200];

// S-1-5-21-397955417-626881126-188441444-2101332
ULONG _Sid1[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};
PSID g_Sid1 = (PSID) _Sid1;

ACCESS_MASK g_DesiredAccess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\azaccess.c ===
#include "pch.h"
#pragma hdrstop

#include "bmcommon.h"

//
// S-1-5-21-397955417-626881126-188441444-2908314 (kumarp)
//
//WCHAR szSid[] = L"S-1-5-21-397955417-626881126-188441444-2908314";
WCHAR szSid[] = L"S-1-5-21-397955417-626881126-188441444-2101332";

//ULONG Sid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};

// S-1-5-21-397955417-626881126-188441444-2101332
//ULONG Sid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};

BOOL b;
DWORD AuthzRmAuditFlags = 0;
HANDLE hProcessToken=NULL;
static HANDLE hToken;
DWORD AuthzAuditFlags = 0;
PCWSTR ResourceManagerName = L"Speed Test Resource Manager";
AUTHZ_RM_AUDIT_INFO_HANDLE hRmAuditInfo = NULL;
AUTHZ_RESOURCE_MANAGER_HANDLE hAuthzResourceManager = NULL;
DWORD AuthzRmFlags = 0;
AUDIT_EVENT_INFO AuditEventInfo;
PCWSTR szOperationType = L"Access Check";
PCWSTR szObjectName = L"Joe";
PCWSTR szObjectType = L"Kernel Hacker";
PCWSTR szAdditionalInfo = L"None";
AUTHZ_AUDIT_INFO_HANDLE hAuditInfo = NULL;
AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext = NULL;
LUID luid = {0xdead,0xbeef};
ULONG i;

ULONG NumAccessChecks = 10;
AUTHZ_ACCESS_REQUEST RequestOT;
AUTHZ_ACCESS_REQUEST Request;
UCHAR Buffer[1024];
UCHAR Buffer2[1024];
UCHAR TypeListBuffer[1024];
PAUTHZ_ACCESS_REPLY pReply = (PAUTHZ_ACCESS_REPLY) Buffer;
PAUTHZ_ACCESS_REPLY pReplyOT = (PAUTHZ_ACCESS_REPLY) Buffer2;
PSECURITY_DESCRIPTOR pSD = NULL;
AUTHZ_HANDLE AuthzHandle = 0;
AUDIT_PARAMS AuditParams;
AUDIT_PARAM ParamArray[11];

PSID pSid;
PSID pUserSid;

BOOL
AuthzInit( )
{
    BOOL b;

    if (!ConvertStringSidToSid( szSid, &pSid ))
    {
        return FALSE;
    }

    AuditEventInfo.Version                 = AUDIT_TYPE_LEGACY;
    AuditEventInfo.u.Legacy.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
    AuditEventInfo.u.Legacy.AuditId        = SE_AUDITID_OBJECT_OPERATION;
    AuditEventInfo.u.Legacy.ParameterCount = 3;

    //
    // init request for obj-type access check
    //
    
    RequestOT.DesiredAccess        = DESIRED_ACCESS;
    RequestOT.ObjectTypeList       = ObjectTypeList;
    RequestOT.ObjectTypeListLength = ObjectTypeListLength;
    RequestOT.OptionalArguments    = NULL;
    RequestOT.PrincipalSelfSid     = NULL;
    //RequestOT.PrincipalSelfSid = g_Sid1;

    //
    // init non obj-type request 
    //

    Request.DesiredAccess        = DESIRED_ACCESS;
    Request.ObjectTypeList       = NULL;
    Request.ObjectTypeListLength = 0;
    Request.OptionalArguments    = NULL;
    Request.PrincipalSelfSid     = NULL;
    //Request.PrincipalSelfSid = g_Sid1;

    //
    // init reply for obj type list
    //
    pReplyOT->ResultListLength  = ObjectTypeListLength;
    pReplyOT->Error             = (PDWORD) (((PCHAR) pReplyOT) + sizeof(AUTHZ_ACCESS_REPLY));
    pReplyOT->GrantedAccessMask = (PACCESS_MASK) (pReplyOT->Error + pReplyOT->ResultListLength);

    //
    // init reply 
    //

    pReply->ResultListLength  = 1;
    pReply->Error             = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);

    b = AuthzInitializeResourceManager(
            NULL,
            NULL,
            NULL,
            L"Benchmark RM",
            AuthzRmFlags,
            &hAuthzResourceManager
            );

    if (!b)
    {
        printf("AuthzInitializeResourceManager\n");
        return FALSE;
    }

    AuditParams.Parameters = ParamArray;

    AuthzInitializeAuditParams(
        &AuditParams,
        &pUserSid,
        L"Authz Speed Tests",
        APF_AuditSuccess,
        1,
        APT_String, L"Test operation"
        );

    b = AuthzInitializeAuditInfo(
            &hAuditInfo,
            0,
            hAuthzResourceManager,
            &AuditEventInfo,
            &AuditParams,
            NULL,
            INFINITE,
            L"blah",
            L"blah",
            L"and",
            L"blah"
            );

    if (!b)
    {
        printf("AuthzInitAuditInfo FAILED with %d.\n", GetLastError());
        return 0;
    }

    b = AuthzModifyAuditQueue(
            NULL,
            AUTHZ_AUDIT_QUEUE_THREAD_PRIORITY,
            0,
            0,
            0,
            THREAD_PRIORITY_LOWEST
            );
    if (!b)
    {
        printf("AuthzModifyAuditQueue FAILED with %d.\n", GetLastError());
        return 0;
    }

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY,
                            &hProcessToken ) )
    {
        wprintf(L"OpenProcessToken failed %d\n", GetLastError());
        return 0;
    }


    b = AuthzInitializeContextFromToken(
            hProcessToken,
            hAuthzResourceManager,
            NULL,
            luid,
            0,
            NULL,
            &hAuthzClientContext
            );
    
    if (!b)
    {
        printf("AuthzInitializeContextFromToken failed %d\n", GetLastError());
        return FALSE;
    }

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ) )
    {
        return GetLastError();
    }

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(g_szSd, SDDL_REVISION_1, &pSD, NULL);

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return FALSE;
    }
    return TRUE;
}


DWORD
InitAuthzAccessChecks()
{
    if (!AuthzInit())
    {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD
AuthzDoAccessCheck(
    IN ULONG NumAccessChecks, 
    IN DWORD Flags
    )
{
    AUTHZ_AUDIT_INFO_HANDLE AdtInfo = Flags & BMF_GenerateAudit ? hAuditInfo : NULL;

    if ( Flags & BMF_UseObjTypeList )
    {
        for (i = 0; i < NumAccessChecks; i ++)
        {
            b = AuthzAccessCheck(
                hAuthzClientContext,
                &RequestOT,
                AdtInfo,
                pSD,
                NULL,
                0,
                pReplyOT,
                //&AuthzHandle
                NULL
                );
            if (!b)
            {
                printf("AuthzAccessCheck failed.\n");
                return GetLastError();
            }
//             else
//             {
//                 AuthzFreeHandle( AuthzHandle );
//             }
        }
    }
    else
    {
        for (i = 0; i < NumAccessChecks; i ++)
        {
            b = AuthzAccessCheck(
                hAuthzClientContext,
                &Request,
                AdtInfo,
                pSD,
                NULL,
                0,
                pReply,
                //&AuthzHandle
                NULL
                );
            if (!b)
            {
                printf("AuthzAccessCheck failed.\n");
                return GetLastError();
            }
//             else
//             {
//                 AuthzFreeHandle( AuthzHandle );
//             }
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\benchmrk.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       B E N C H M R K . H
//
//  Contents:   Benchmark class.
//
//  Notes:
//
//  Author:     billbe   13 Oct 1997
//
//---------------------------------------------------------------------------


#pragma once

const WCHAR c_sznEmpty[] = {'\0'};

class CBenchmark
{
public:
    CBenchmark();
    ~CBenchmark();
    void Start(PCWSTR sznDescription);
    void Stop();
    double DblBenchmarkSeconds()
    {
        return m_i64TotalTime / static_cast<double>(m_i64Frequency);
    }
    PCWSTR SznDescription(){return m_sznDescription ? m_sznDescription : c_sznEmpty;}
    PCWSTR SznBenchmarkSeconds(unsigned short usPrecision);
private:
    __int64 m_i64Frequency;
    PWSTR m_sznDescription;
    __int64 m_i64StartTime;
    __int64 m_i64TotalTime;
    BOOL m_fStarted;
    BOOL m_fSupported;
    WCHAR m_sznSeconds[50];

};

extern "C" void timer_start();
extern "C" void timer_stop();
extern "C" PCWSTR timer_secs();
EXTERN_C double timer_time();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\ntaccess.h ===
EXTERN_C
DWORD 
InitNtAccessChecks();

EXTERN_C
DWORD 
DoNtAccessChecks(
    IN ULONG NumChecks,
    IN DWORD Flags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\benchmark\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include "windows.h"
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

#include <ntlsa.h>
#include <msaudite.h>
// #include <rpc.h>
// #include <msobjs.h>

#define SECURITY_WIN32

// #include "sspi.h"
// #include "secint.h"
#include <sddl.h>

#include <authz.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\fundsrm\fundsrm.cpp ===
#include "fundsrm.h"
#include "fundsrmp.h"

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))


FundsRM::FundsRM(DWORD dwFundsAvailable) {
/*++

    Routine Description
    
        The constructor for the Funds resource manager.
        It initializes an instance of an Authz Resource Manager, providing it
        with the appropriate callback functions.
        It also creates a security descriptor for the fund, allowing only
        corporate and transfer expenditures, not personal. Additional logic
        could be added to allow VPs to override these restrictions, etc.

    Arguments
    
        DWORD dwFundsAvailable - The amount of money in the fund managed by this
        						 resource manager
    
    Return Value
        None.                       
--*/        
	
	//
	// The amount of money in the fund
	//
	
	_dwFundsAvailable = dwFundsAvailable;
	 
	//
	// Initialize the fund's resource manager
	//
	
	AuthzInitializeResourceManager(
        FundsAccessCheck,
        FundsComputeDynamicGroups,
        FundsFreeDynamicGroups,
        NULL, // no auditing
        0,    // no flags        
        &_hRM
        );

	//
	// Create the fund's security descriptor
	// 
	
    InitializeSecurityDescriptor(&_SD, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorGroup(&_SD, NULL, FALSE);
    SetSecurityDescriptorSacl(&_SD, FALSE, NULL, FALSE);
    SetSecurityDescriptorOwner(&_SD, NULL, FALSE);

	//
	// Initialize the DACL for the fund
	//
	
	PACL pDaclFund = (PACL)malloc(1024);
	InitializeAcl(pDaclFund, 1024, ACL_REVISION_DS);
	
	//
	// Add an access-allowed ACE for Everyone
	// Only company spending and transfers are allowed for this fund
	//
	
	AddAccessAllowedAce(pDaclFund,
						ACL_REVISION_DS,
						ACCESS_FUND_CORPORATE | ACCESS_FUND_TRANSFER, 
						EveryoneSid);
	
	//
	// Now set that ACE to a callback ACE
	//
	
	((PACE_HEADER)FirstAce(pDaclFund))->AceType = 
									ACCESS_ALLOWED_CALLBACK_ACE_TYPE;
	
	//
	// Add that ACL as the security descriptor's DACL
	//
	
	SetSecurityDescriptorDacl(&_SD, TRUE, pDaclFund, FALSE);
}

FundsRM::~FundsRM() {
/*++

    Routine Description
    
        The destructor for the Funds resource manager.
        Frees any dynamically allocated memory used.

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
	
	//
	// Deallocate the DACL in the security descriptor
	//
	
	PACL pDaclFund = NULL;
	BOOL fDaclPresent;
	BOOL fDaclDefaulted;
	GetSecurityDescriptorDacl(&_SD,
							  &fDaclPresent,
							  &pDaclFund,
							  &fDaclDefaulted);
	
	if( pDaclFund != NULL )
	{
		free(pDaclFund);
	}
	
	//
	// Deallocate the resource manager
	//
	
	AuthzFreeResourceManager(_hRM);
}



BOOL FundsRM::Authorize(LPTSTR szwUsername,
						DWORD dwRequestAmount,
						DWORD dwSpendingType) {
/*++

    Routine Description
    
        This function is called by a user who needs approval of a given amount
        of spending in a given spending type. Internally, this uses the 
        AuthzAccessCheck function to determine whether the given user
        should be allowed the requested spending.
        If the spending is approved, it is deducted from the fund's total.

    Arguments
    
        LPTSTR szwUsername - The name of the user, currently limited to 
        					 Bob, Martha, or Joe
        					 
		DWORD dwRequestAmount - The amount of spending requested, in cents
		
		DWORD dwSpendingType - The type of spending, ACCESS_FUND_PERSONAL,
							   ACCESS_FUND_TRANSFER, or ACCESS_FUND_CORPORATE
    
    Return Value
        BOOL - True if the spending was approved, FALSE otherwise                       
--*/        
	

	//
	// No need to check access if not enough money in fund
	//
	
	if( dwRequestAmount > _dwFundsAvailable ) 
	{
		return FALSE;
	}

	//
	// This would normally impersonate the RPC user and create the 
	// client context from the token. However, we can just use strings for now.
	//
	
	PSID pUserSid = NULL;
	
	if( wcscmp(szwUsername, L"Bob") == 0 ) 
	{
		pUserSid = BobSid;
	}
	else if( wcscmp(szwUsername, L"Martha") == 0 ) 
	{
		pUserSid = MarthaSid;
	} 
	else if( wcscmp(szwUsername, L"Joe") == 0 ) 
	{
		pUserSid = JoeSid;
	}
	
	//
	// Only the above usernames are supported
	//
	
	if( pUserSid == NULL ) {
		return FALSE;
	}
	
	
	//
	// Now we create a client context from the SID
	//
	
	AUTHZ_CLIENT_CONTEXT_HANDLE hCC = NULL;
	LUID ZeroLuid = { 0, 0};
	
 	AuthzInitializeContextFromSid(pUserSid,
 								  NULL, // this is local, no need for server
 								  _hRM, // Using the Fund resource manager
 								  NULL, // no expiration
 								  ZeroLuid,    // no need for unique luid
 								  0,	// no flags,
 								  NULL, // no args for ComputeDynamicGroups
 								  &hCC);
		
	

	//
	// Initialize the access check result structure
	//
	
	DWORD dwGrantedAccessMask = 0;
	DWORD dwErr = ERROR_ACCESS_DENIED; // default to deny
	AUTHZ_ACCESS_REPLY AccessReply = {0};
	
	AccessReply.ResultListLength = 1;
	AccessReply.GrantedAccessMask = &dwGrantedAccessMask;
	AccessReply.Error = &dwErr;
	
	//
	// Initialize the access check request
	//
	
	AUTHZ_ACCESS_REQUEST AccessRequest = {0};
	
	AccessRequest.DesiredAccess = dwSpendingType;
	AccessRequest.PrincipalSelfSid = NULL;
	AccessRequest.ObjectTypeList = NULL;
	AccessRequest.ObjectTypeListLength = 0;
	AccessRequest.OptionalArguments = &dwRequestAmount;	
	
	AuthzAccessCheck(hCC, 			// Bob is requesting the transfer
					 &AccessRequest,
					 NULL, 				// no auditing
					 &_SD,
					 NULL, 				// only one SD and one object
					 0, 				// no additional SDs
					 &AccessReply,
					 NULL 				// no need to cache the access check
					 );
	
	//
	// Now free the client context
	//
	
	AuthzFreeContext(hCC);
					 
	//
	// AuthzAccessCheck sets ERROR_SUCCESS if all acces bits are granted
	//
	
	if( dwErr == ERROR_SUCCESS ) 
	{
		
		_dwFundsAvailable -= dwRequestAmount;
		return TRUE;
	} 
	else 
	{
		return FALSE;
	}
}



DWORD FundsRM::FundsAvailable() {
/*++

    Routine Description
    
       Accessor for the funds available

    Arguments
    
        None.
    
    Return Value
        DWORD - The amount of money available in the fund
--*/        

	return _dwFundsAvailable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\fundsrm\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\fundsrm\fundsrm.h ===
#include "pch.h"

//
// Personal expenditures
//

#define ACCESS_FUND_PERSONAL 	 0x00000001

//
// Company spending
//

#define ACCESS_FUND_CORPORATE	 0x00000002

//
// Transfer to other funds
//

#define ACCESS_FUND_TRANSFER	 0x00000004



/*++

    Class Description
    
        This class handles the access control for a fund, using AuthZ and
        internal logic to determine whether certain users should be permitted
        certain types of actions on the fund.

--*/        

class FundsRM {
private:

	//
	// The amount of money available in the fund
	//
	
	DWORD _dwFundsAvailable; 
	
	//
	// The resource manager, initialized with the callback functions
	//
	
	AUTHZ_RESOURCE_MANAGER_HANDLE _hRM;
	
	//
	// The security descriptor for the fund, containing a callback ACE
	// which causes the resource manager callbacks to be used
	//
	
	SECURITY_DESCRIPTOR _SD;
	
public:

	//
	// Constructor for the resource manager
	// dwFundsAvailable is the initial funds deposited
	//
	
	FundsRM(DWORD dwFundsAvailable);
	
	//
	// Destructor
	//
	
	~FundsRM();
	
	// 
	// This function is called by a user who needs approval of a given amount
    // of spending in a given spending type. If the spending is approved, it
    // is deducted from the fund's total. If the spending is approved, TRUE
    // is returned. Otherwise FALSE is returned.
    //
    //   LPTSTR szwUsername - The name of the user, currently limited to 
    //    					 Bob, Martha, or Joe
    //    					 
	//	 DWORD dwRequestAmount - The amount of spending requested, in cents
	//	
	//	 DWORD dwSpendingType - The type of spending, ACCESS_FUND_PERSONAL,
	//						   ACCESS_FUND_TRANSFER, or ACCESS_FUND_CORPORATE
	//
	
	BOOL Authorize(LPTSTR szwUsername, DWORD RequestAmount, DWORD SpendingType);
	
	//
	// Returns the amount of funds still available
	//
	
	DWORD FundsAvailable();
	
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\fundsrm\fundsrmp.c ===
#include "pch.h"
#include "fundsrmp.h"

//
// The various SIDs, the easy way
//

DWORD BobGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00020001};
DWORD MarthaGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00020002};
DWORD JoeGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00020003};
DWORD VPGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00010001};
DWORD ManagerGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00010002};
DWORD EmployeeGuid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00010003};
DWORD EveryoneGuid[] = {0x101, 0x01000000, 0};
PSID BobSid = (PSID)BobGuid;
PSID MarthaSid= (PSID)MarthaGuid;
PSID JoeSid = (PSID)JoeGuid;
PSID VPSid = (PSID)VPGuid;
PSID ManagerSid = (PSID)ManagerGuid;
PSID EmployeeSid = (PSID)EmployeeGuid;
PSID EveryoneSid = (PSID)EveryoneGuid;

//
// Maximum spending approvals, in cents
//

DWORD MaxSpendingVP = 100000000;
DWORD MaxSpendingManager = 1000000;
DWORD MaxSpendingEmployee = 50000;


//
// The callback routines used with AuthZ
//

BOOL
FundsAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    )

/*++

    Routine Description
    
    	This is the callback access check. It is registered with a 
    	resource manager. AuthzAccessCheck calls this function when it
    	encounters a callback type ACE, one of:
    	ACCESS_ALLOWED_CALLBACK_ACE_TYPE 
    	ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE
    	ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE
    	
    	This function determines if the given callback ACE applies to the
    	client context (which has already had dynamic groups computed) and
    	the optional arguments, in this case the request amount.
    	
    	The list of groups which apply to the user is traversed. If a group
    	is found which allows the user the requested access, pbAceApplicable
    	is set to true and the function returns. If the end of the group list
    	is reached, pbAceApplicable is set to false and the function returns.
        
    Arguments
    
        hAuthzClientContext - handle to the AuthzClientContext.
        
        pAce - pointer to the Ace header.
        
        pArgs - optional arguments, in this case DWORD*, DWORD is  the spending
        	request amount in cents
        
        pbAceApplicable - returns true iff the ACE allows the client's request

    Return value
    
        Bool, true on success, false on error
        
    Error checking
    
    	Sample code, no error checking
    	
--*/
{
	//
	// First, look up the user's SID from the context
	//
	
	DWORD dwTokenGroupsSize = 0;
	PVOID pvTokenGroupsBuf = NULL;
	DWORD i;
	PDWORD pAccessMask = NULL;
	
	//
	// The requested spending amount, in cents
	//
	
	DWORD dwRequestedSpending = ((PDWORD)pArgs)[0];

	//
	// By default, the ACE does not apply to the request
	//
	
	*pbAceApplicable = FALSE;

	//
	// The object's access mask (right after the ACE_HEADER)
	// The access mask determines types of expenditures allowed
	// from this fund
	//
	
	pAccessMask = (PDWORD) (pAce + sizeof(ACE_HEADER));
	
	//
	// Get needed buffer size
	//
	
	AuthzGetContextInformation(hAuthzClientContext,
							   AuthzContextInfoGroupsSids,
							   NULL,
							   0, 
							   &dwTokenGroupsSize
							   );

	pvTokenGroupsBuf = malloc(dwTokenGroupsSize);
	
	//
	// Get the actual TOKEN_GROUPS array 
	//
	
	AuthzGetContextInformation(hAuthzClientContext,
							   AuthzContextInfoGroupsSids,
							   pvTokenGroupsBuf,
							   dwTokenGroupsSize,
							   &dwTokenGroupsSize
							   );
	
	
	//
	// Go through the groups until end is reached or a group applying to the
	// request is found
	//
	
	for( i = 0; 
		 i < ((PTOKEN_GROUPS)pvTokenGroupsBuf)->GroupCount 
		 && *pbAceApplicable != TRUE;
		 i++ ) 
	{
		//
		//	Again, this is the business logic.
		//	Each level of employee can approve different amounts.
		//
		
		//
		// VP
		//
		
		if( dwRequestedSpending <= MaxSpendingVP &&
			EqualSid(VPSid, ((PTOKEN_GROUPS)pvTokenGroupsBuf)->Groups[i].Sid) )
		{
			*pbAceApplicable = TRUE;

		}
			
		//	
		// Manager
		//
		
		if( dwRequestedSpending <= MaxSpendingManager &&
			EqualSid(ManagerSid, ((PTOKEN_GROUPS)pvTokenGroupsBuf)->Groups[i].Sid) )
		{
			*pbAceApplicable = TRUE;
		}
			
		//
		// Employee
		//
		
		if( dwRequestedSpending <= MaxSpendingEmployee &&
			EqualSid(EmployeeSid, ((PTOKEN_GROUPS)pvTokenGroupsBuf)->Groups[i].Sid) )
		{
			*pbAceApplicable = TRUE;
		}
	}
	
	return TRUE;
}



BOOL
FundsComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    )

/*++

    Routine Description
    
        Resource manager callback to compute dynamic groups.  This is used by the RM
        to decide if the specified client context should be included in any RM defined groups.
        
        In this example, the employees are hardcoded into their roles. However, this is the 
        place you would normally retrieve data from an external source to determine the 
        users' additional roles.
        
    Arguments
    
        hAuthzClientContext - handle to client context.
        Args - optional parameter to pass information for evaluating group membership.
        pSidAttrArray - computed group membership SIDs
        pSidCount - count of SIDs
        pRestrictedSidAttrArray - computed group membership restricted SIDs
        pRestrictedSidCount - count of restricted SIDs
        
    Return Value 
        
        Bool, true for success, false on failure.

    Error checking
    
    	Sample code, no error checking

--*/    
{
	//
	// First, look up the user's SID from the context
	//
	
	DWORD dwSidSize = 0;
	PVOID pvSidBuf = NULL;
	PSID  psSidPtr = NULL;

	//
	// Get needed buffer size
	//
	
	AuthzGetContextInformation(hAuthzClientContext,
							   AuthzContextInfoUserSid,
							   NULL,
							   0, 
							   &dwSidSize
							   );

	pvSidBuf = malloc(dwSidSize);
	
	//
	// Get the actual SID (inside a TOKEN_USER structure)
	//
	
	AuthzGetContextInformation(hAuthzClientContext,
							   AuthzContextInfoUserSid,
							   pvSidBuf,
							   dwSidSize,
							   &dwSidSize
							   );

	psSidPtr = ((PTOKEN_USER)pvSidBuf)->User.Sid;
	
	//
	// Allocate the memory for the returns, which will be deallocated by FreeDynamicGroups
	// Only a single group will be returned, determining the employee type
	//
	
	*pSidCount = 1;
	*pSidAttrArray = (PSID_AND_ATTRIBUTES)malloc( sizeof(SID_AND_ATTRIBUTES) );
	
	//
	// No restricted group sids
	//
	
	pRestrictedSidCount = 0;
	*pRestrictedSidAttrArray = NULL;
	
	(*pSidAttrArray)[0].Attributes = SE_GROUP_ENABLED;
	
	//
	// 		The hardcoded logic: 
	//		Bob is a VP
	//		Martha is a Manager
	//		Joe is an Employee
	//
	
	if( EqualSid(psSidPtr, BobSid) ) 
	{
		(*pSidAttrArray)[0].Sid = VPSid;
	} 
	else if( EqualSid(psSidPtr, MarthaSid) ) 
	{
		(*pSidAttrArray)[0].Sid = ManagerSid;
	}
	else if( EqualSid(psSidPtr, JoeSid) )
	{
		(*pSidAttrArray)[0].Sid = EmployeeSid;		
	}

	free(pvSidBuf);
	return TRUE;	
}

VOID
FundsFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    )

/*++

    Routine Description
    
        Frees memory allocated for the dynamic group array.

    Arguments
    
        pSidAttrArray - array to free.
    
    Return Value
        None.                       
--*/        
{
    if (pSidAttrArray != NULL)
    {
    	free(pSidAttrArray);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\fundsrm\main.cpp ===
#include "fundsrm.h"


#define BUFFER_SIZE 1024

LPTSTR BobName = L"Bob";
LPTSTR MarthaName = L"Martha";
LPTSTR JoeName = L"Joe";

LPTSTR CorporateName = L"Corporate";
LPTSTR TransferName = L"Transfer";
LPTSTR PersonalName = L"Personal";

typedef struct {
	LPTSTR Name;
	DWORD Amount;
	DWORD Type;
} TestStruct;

#define NUM_TESTS 12
TestStruct Tests[NUM_TESTS] = 
	{
		{ BobName, 5000000, ACCESS_FUND_CORPORATE },
		{ MarthaName, 5000000, ACCESS_FUND_CORPORATE },
		{ JoeName, 4000000, ACCESS_FUND_TRANSFER },
		{ BobName, 600000, ACCESS_FUND_PERSONAL },
		{ MarthaName, 200000, ACCESS_FUND_CORPORATE },
		{ JoeName, 300000, ACCESS_FUND_TRANSFER },
		{ BobName, 10000, ACCESS_FUND_CORPORATE },
		{ MarthaName, 70000, ACCESS_FUND_TRANSFER },
		{ JoeName, 40000, ACCESS_FUND_TRANSFER },
		{ BobName, 2000, ACCESS_FUND_CORPORATE },
		{ MarthaName, 7000, ACCESS_FUND_PERSONAL },
		{ JoeName, 1000, ACCESS_FUND_CORPORATE }
	
	};
	
 
void __cdecl wmain(int argc, char *argv[]) {
	
	//
	// Initialize the resource manager object
	//
	
	FundsRM *pFRM = new FundsRM(2000000000);

	/* 
		Now we are ready to request fund approvals
		Again, Bob is a VP, therefore he can approve up to 100000000 cents in spending
		Martha is a Manager, so she can approve up to 1000000 cents
		Joe is an employee, so he is limited to 50000 in approvals
		
		We have a fund which allows company expenditures and transfers, but does not allow
		funds for personal use.
	
		Bob will attempt to get approval for a 50000000 cent ($500k) transfer, he should
		succeed.
		
		Bob will also attempt a 20000 cent ($200) personal withdrawal. He should fail,
		since the fund does not allow personal use.
		
		Martha will attempt a 500000 ($5k) company spending approval. She should succeed.
		
		Finally, Joe will attempt a 50001 cent ($500.01) transfer. He should fail, since
		he is limited to $500 approvals.
	
	*/
	
	for(int i=0; i<NUM_TESTS; i++) {
		
		wprintf(L"%s ", Tests[i].Name);
		
		if( pFRM->Authorize(Tests[i].Name, Tests[i].Amount, Tests[i].Type) ) {
			
			wprintf(L"approved for a ");
		
		} else {
			
			wprintf(L"NOT approved for a ");
		}
		
		switch(Tests[i].Type) {
			case ACCESS_FUND_CORPORATE:
				wprintf(L"%s ", CorporateName);
				break;
			case ACCESS_FUND_TRANSFER:
				wprintf(L"%s ", TransferName);
				break;
			case ACCESS_FUND_PERSONAL:
				wprintf(L"%s ", PersonalName);
				break;
			default:
				wprintf(L"unknown ");
		}
		
		wprintf(L"expenditure of $%u.%2.2u, $%u.%2.2u left\n", 
										Tests[i].Amount/100,
										Tests[i].Amount%100,
										pFRM->FundsAvailable()/100,
										pFRM->FundsAvailable()%100);
	}
															
	
	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\fundsrm\fundsrmp.h ===
#pragma once

EXTERN_C BOOL
FundsAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    );

EXTERN_C BOOL
FundsComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    );

EXTERN_C VOID
FundsFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    );
    

EXTERN_C PSID BobSid;
EXTERN_C PSID MarthaSid;
EXTERN_C PSID JoeSid;
EXTERN_C PSID VPSid;
EXTERN_C PSID ManagerSid;
EXTERN_C PSID EmployeeSid;
EXTERN_C PSID EveryoneSid;

EXTERN_C DWORD MaxSpendingVP;
EXTERN_C DWORD MaxSpendingManager;
EXTERN_C DWORD MaxSpendingEmployee;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\mailrm\mailrm.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mailrm.cpp

Abstract:

   The implementation of the Mail resource manager

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "pch.h"
#include "mailrm.h"
#include "mailrmp.h"
#include <time.h>





MailRM::MailRM()
/*++

    Routine Description
    
        The constructor for the Mail resource manager.
        It initializes an instance of an Authz Resource Manager, providing it
        with the appropriate callback functions.
        It also creates a security descriptor for the mail RM, with a
        SACL and DACL.

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    //
    // Initialize the audit information
    //

    AUTHZ_RM_AUDIT_INFO_HANDLE hRMAuditInfo;

    if( FALSE == AuthzInitializeRMAuditInfo(&hRMAuditInfo,
                                            0,
                                            0,
                                            0,
                                            L"MailRM") )
    {
        throw (DWORD)ERROR_INTERNAL_ERROR;
    }

    if( FALSE == AuthzInitializeResourceManager(
        MailRM::AccessCheck,
        MailRM::ComputeDynamicGroups,
        MailRM::FreeDynamicGroups,
        hRMAuditInfo, 
        0,    // no flags        
        &_hRM
        ) )
    {
        AuthzFreeRMAuditInfo(hRMAuditInfo);

        throw (DWORD)ERROR_INTERNAL_ERROR;

    }

    //
    // Create the security descriptor
    // 

    try {
        InitializeMailSecurityDescriptor();    
    }
    catch(...)
    {
        AuthzFreeRMAuditInfo(hRMAuditInfo);
        AuthzFreeResourceManager(_hRM);
        throw;
    }

}



MailRM::~MailRM() 
/*++

    Routine Description
    
        The destructor for the Mail resource manager.
        Frees any dynamically allocated memory used, including
        deleting any registered mailboxes.

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    //
    // Deallocate the DACL and SACL in the security descriptor
    //
    
    PACL pAclMail = NULL;
    BOOL fPresent;
    BOOL fDefaulted;

    DWORD dwTmp;

    AUTHZ_RM_AUDIT_INFO_HANDLE hAuditInfo;

    if( FALSE != AuthzGetInformationFromResourceManager(
                                           _hRM,
                                           AuthzRMInfoRMAuditInfo,
                                           &hAuditInfo,
                                           sizeof(AUTHZ_RM_AUDIT_INFO_HANDLE),
                                           &dwTmp
                                           ) )
    {
        AuthzFreeRMAuditInfo(hAuditInfo);
    }

    GetSecurityDescriptorDacl(&_sd,
                              &fPresent,
                              &pAclMail,
                              &fDefaulted);
    
    if( pAclMail != NULL )
    {
        delete[] (PBYTE)pAclMail;
        pAclMail = NULL;
    }

    GetSecurityDescriptorSacl(&_sd,
                              &fPresent,
                              &pAclMail,
                              &fDefaulted);

    if( pAclMail != NULL )
    {
        delete[] (PBYTE)pAclMail;
    }

    //
    // Deallocate the resource manager
    //

    AuthzFreeResourceManager(_hRM);

    //
    // Delete the mailboxes
    //

    while( ! _mapSidMailbox.empty() )
    {
        delete (*(_mapSidMailbox.begin())).second;
        _mapSidMailbox.erase(_mapSidMailbox.begin());
    }

    //
    // Free the AuthZ client contexts
    //
    
    while( ! _mapSidContext.empty() )
    {
        AuthzFreeContext((*(_mapSidContext.begin())).second);
        _mapSidContext.erase(_mapSidContext.begin());
    }
}


void MailRM::InitializeMailSecurityDescriptor()
/*++

    Routine Description
    
        This private method initializes the MailRM's security descriptor.
        It should be called exactly once, and only by the constructor.
        
        It creates a security descriptor with the following DACL:
        
        CallbackDeny    READ                Insecure    11pm-5am OR Sensitive
        Allow           READ, WRITE         PrincipalSelf
        Allow           READ, WRITE, ADMIN  MailAdmins
        
        And the following SACL
        
        CallbackAudit   READ                Insecure    11pm-5am OR Sensitive
        (audit on both success and failure)

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    DWORD dwAclSize = sizeof(ACL);
    DWORD dwAceSize = 0;
    
    PMAILRM_OPTIONAL_DATA pOptionalData = NULL;

    //
    // Initialize the security descriptor
    // No need for owner or group
    //
    
    InitializeSecurityDescriptor(&_sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorGroup(&_sd, NULL, FALSE);
    SetSecurityDescriptorOwner(&_sd, MailAdminsSid, FALSE);

    // 
    // Callback deny ace RWA for Insecure group SID
    // Optional data: Sensitive mailbox OR 11pm-5am
    // Any users coming in over an insecure connection between 11pm and 5am
    // should be denied read access.
    // Also any users coming in over insecure connections to sensitive mailboxes
    // should be denied read access.
    //

    PACCESS_DENIED_CALLBACK_ACE pDenyAce = NULL;

    //
    // This audit ACE has the same conditions as the above deny ACE. It audits
    // any successful (should not happen with the above deny) or failed
    // authentications which fit the callback parameters.
    //

    PSYSTEM_AUDIT_CALLBACK_ACE pAuditAce = NULL;

    //
    // DACL for the security descriptor
    //
    
    PACL pDacl = NULL;

    //
    // SACL for the security descriptor
    //

    PACL pSacl = NULL;




    //
    // We allocate and initialize the callback deny ACE
    //

    //
    // Size of the callback access denied ACE with the optional data
    //

    dwAceSize   = sizeof(ACCESS_DENIED_CALLBACK_ACE) // ACE and 1 DWORD of SID
                - sizeof(DWORD)                      // minus the dword
                + GetLengthSid(InsecureSid)          // length of the SID
                + sizeof(MAILRM_OPTIONAL_DATA);      // size of optional data

    
    pDenyAce = (PACCESS_DENIED_CALLBACK_ACE)new BYTE[dwAceSize];

    if( pDenyAce == NULL )
    {
        throw (DWORD)ERROR_OUTOFMEMORY;
    }

    
    //
    // Manually initialize the ACE structure
    //

    pDenyAce->Header.AceFlags = 0;
    pDenyAce->Header.AceSize = dwAceSize;
    pDenyAce->Header.AceType = ACCESS_DENIED_CALLBACK_ACE_TYPE;
    pDenyAce->Mask = ACCESS_MAIL_READ;

    //
    // Copy the Insecure SID into the ACE
    //

    memcpy(&(pDenyAce->SidStart), InsecureSid, GetLengthSid(InsecureSid));

    // 
    // Our optional data is at the end of the ACE
    //

    pOptionalData = (PMAILRM_OPTIONAL_DATA)( (PBYTE)pDenyAce 
                                           + dwAceSize
                                           - sizeof(MAILRM_OPTIONAL_DATA) );

    
    //
    // Initialize the optional data as described above
    //
    
    pOptionalData->bIsSensitive =   MAILRM_SENSITIVE;
    pOptionalData->bLogicType =     MAILRM_USE_OR;
    pOptionalData->bStartHour =     MAILRM_DEFAULT_START_TIME;
    pOptionalData->bEndHour =       MAILRM_DEFAULT_END_TIME;

    
    
    //
    // Add the size of the callback ACE to the expected ACL size
    //
    
    dwAclSize += dwAceSize;

    //
    // We also need to add non-callback ACEs
    //

    dwAclSize += (   sizeof(ACCESS_ALLOWED_ACE)
                   - sizeof(DWORD) 
                   + GetLengthSid(PrincipalSelfSid)  );

    dwAclSize += (   sizeof(ACCESS_ALLOWED_ACE)
                   - sizeof(DWORD) 
                   + GetLengthSid(MailAdminsSid)     );


    

    // 
    // Now we can allocate the DACL
    //

    pDacl = (PACL) (new BYTE[dwAclSize]);
    
    if( pDacl == NULL )
    {
        delete[] (PBYTE)pDenyAce;
        throw (DWORD)ERROR_OUTOFMEMORY;
    }

    //
    // Finally, initialize the ACL and copy the ACEs into it
    //
    
    InitializeAcl(pDacl, dwAclSize, ACL_REVISION_DS);
    
    // 
    // Copy the ACE into the ACL
    //

    AddAce(pDacl,
           ACL_REVISION_DS,
           0xFFFFFFFF,      // Add to end
           pDenyAce,
           dwAceSize);

    delete[] (PBYTE)pDenyAce;

    //
    // Add a PRINCIPAL_SELF_SID allow read and write ace
    //

    AddAccessAllowedAce(pDacl,
                        ACL_REVISION_DS,
                        ACCESS_MAIL_READ | ACCESS_MAIL_WRITE,
                        PrincipalSelfSid);

    //
    // Add an allow mail administrators group full access
    //

    AddAccessAllowedAce(pDacl,
                    ACL_REVISION_DS,
                    ACCESS_MAIL_READ | ACCESS_MAIL_WRITE | ACCESS_MAIL_ADMIN,
                    MailAdminsSid);



    //
    // Now create the SACL, which will onlye have a single callback ACE
    //

    dwAclSize = sizeof(ACL);
    
    dwAceSize   = sizeof(SYSTEM_AUDIT_CALLBACK_ACE) // ACE and 1 DWORD of SID
                - sizeof(DWORD)                      // minus the dword
                + GetLengthSid(InsecureSid)          // length of the SID
                + sizeof(MAILRM_OPTIONAL_DATA);      // size of optional data

    //
    // Allocate the callback audit ACE
    //

    pAuditAce = (PSYSTEM_AUDIT_CALLBACK_ACE)new BYTE[dwAceSize];

    if( pAuditAce == NULL )
    {
        delete[] (PBYTE)pDacl;
        throw (DWORD)ERROR_OUTOFMEMORY;
    }

    //
    // Initialize the ACE structure
    //

    pAuditAce->Header.AceFlags  = FAILED_ACCESS_ACE_FLAG 
                                | SUCCESSFUL_ACCESS_ACE_FLAG;

    pAuditAce->Header.AceSize = dwAceSize;
    pAuditAce->Header.AceType = SYSTEM_AUDIT_CALLBACK_ACE_TYPE;
    pAuditAce->Mask = ACCESS_MAIL_READ;

    //
    // Copy the Insecure SID into the ACE
    //

    memcpy(&(pAuditAce->SidStart), InsecureSid, GetLengthSid(InsecureSid));

    pOptionalData = (PMAILRM_OPTIONAL_DATA)( (PBYTE)pAuditAce 
                                           + dwAceSize
                                           - sizeof(MAILRM_OPTIONAL_DATA) );

    //
    // Initialize the optional data as described above
    //
    
    pOptionalData->bIsSensitive =   MAILRM_SENSITIVE;
    pOptionalData->bLogicType =     MAILRM_USE_OR;
    pOptionalData->bStartHour =     MAILRM_DEFAULT_START_TIME;
    pOptionalData->bEndHour =       MAILRM_DEFAULT_END_TIME;


    dwAclSize += dwAceSize;

    //
    // Allocate the SACL
    //

    pSacl = (PACL)new BYTE[dwAclSize];

    if( pSacl == NULL )
    {
        delete[] (PBYTE)pDacl;
        throw (DWORD)ERROR_OUTOFMEMORY;
    }

    InitializeAcl(pSacl, dwAclSize, ACL_REVISION_DS);

    //
    // Now add the audit ACE to the SACL
    //

    AddAce(pSacl,
           ACL_REVISION_DS,
           0xFFFFFFFF,      // Add to end
           pAuditAce,
           dwAceSize);

    delete[] (PBYTE)pAuditAce;

    //
    // We now have the DACL and the SACL, set them
    // in the  security descriptor
    //

    SetSecurityDescriptorDacl(&_sd, TRUE, pDacl, FALSE);

    SetSecurityDescriptorSacl(&_sd, TRUE, pSacl, FALSE);

}



void MailRM::AddMailbox(Mailbox *pMailbox)
/*++

    Routine Description
    
        Registers a mailbox (and its user) with the resource manager.   

    Arguments
    
        pMailbox    -   Pointer to an allocated and initialized mailbox
    
    Return Value
        None.                       
--*/        
{
    _mapSidMailbox[pMailbox->GetOwnerSid()] = pMailbox;
}


Mailbox * MailRM::GetMailboxAccess(
                                const PSID psMailbox,
                                const PSID psUser,
                                DWORD dwIncomingIp,
                                ACCESS_MASK amAccessRequested
                                  )
/*++

    Routine Description
    
        This routine checks whether the user with SID psUser should
        be allowed access to the mailbox of user psMailbox. psUser
        is coming from dwIncomingIp, and desires amAccessRequested
        access mask.
        
    Arguments
    
        psMailbox   -   PSID of the user whose mailbox will be accessed
        
        psUser      -   PSID of the user accessing the mailbox
        
        dwIncomingIp-   IP address of the user accessing the mailbox
        
        amAccessRequested - Requested access type to the mailbox
    
    Return Value
        
        Non-NULL Mailbox * if access is granted.
        
        NULL if mailbox does not exist or access is denied.                       
--*/        

{

    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClient;

    AUTHZ_ACCESS_REQUEST AuthzAccessRequest;

    AUTHZ_ACCESS_REPLY AuthzAccessReply;

    AUTHZ_AUDIT_INFO_HANDLE hAuthzAuditInfo = NULL;
    
    PAUDIT_EVENT_INFO pAuditEventInfo = NULL;

    wstring wsAccessType;

    DWORD dwErr = ERROR_SUCCESS;

    ACCESS_MASK amAccessGranted = 0;

    WCHAR szIP[20];

    // 
    // Find the correct mailbox
    //

    Mailbox *pMbx = _mapSidMailbox[psMailbox];

    //
    // Initialize the auditing info for a Generic object
    //

	if( FALSE == AuthzInitializeAuditEvent(	&pAuditEventInfo,
											AUTHZ_INIT_GENERIC_AUDIT_EVENT,
											0,
											0,
											0) )
	{
		throw (DWORD)ERROR_INTERNAL_ERROR;
	}

	try {
		if( amAccessRequested & ACCESS_MAIL_READ )
		{
			wsAccessType.append(L"Read ");
		}
		
		if( amAccessRequested & ACCESS_MAIL_WRITE )
		{
			wsAccessType.append(L"Write ");
		}
	
		if( amAccessRequested & ACCESS_MAIL_ADMIN )
		{
			wsAccessType.append(L"Administer");
		}
	}
	catch(...)
	{
		throw (DWORD)ERROR_INTERNAL_ERROR;
	}

    wsprintf(szIP, L"IP: %d.%d.%d.%d",  (dwIncomingIp >> 24) & 0x000000FF,
                                        (dwIncomingIp >> 16) & 0x000000FF,
                                        (dwIncomingIp >> 8 ) & 0x000000FF,
                                        (dwIncomingIp      ) & 0x000000FF );

    if( NULL == AuthzInitializeAuditInfo(
							 &hAuthzAuditInfo,
                             0,
                             pAuditEventInfo,
                             NULL,
                             INFINITE,
                             wsAccessType.c_str(),
                             L"Mailbox",
                             pMbx->GetOwnerName(),
                             szIP) )
	{
		AuthzFreeAuditEvent(pAuditEventInfo);
		throw (DWORD)ERROR_INTERNAL_ERROR;
	}

	//
	// The audit event info is only needed for the above call, we can
	// deallocate it immediately after
	//

	AuthzFreeAuditEvent(pAuditEventInfo);


    //
    // Set up the Authz access request
    //

    AuthzAccessRequest.DesiredAccess = amAccessRequested;
    AuthzAccessRequest.ObjectTypeList = NULL;
    AuthzAccessRequest.ObjectTypeListLength = 0;
    AuthzAccessRequest.OptionalArguments = pMbx;

    //
    // The PrincipalSelf SID is the SID of the mailbox owner
    // This way, the PRINCIPAL_SELF_SID allow ACE grants access
    // only to the owner. PrincipalSelfSid in the ACE will be replaced
    // by this value for access check purposes. The owner of this mailbox
    // will have the same SID in his context. Therefore, the two SIDs will
    // match if there is a PrincipalSelfSid ACE in the ACL.
    //

    AuthzAccessRequest.PrincipalSelfSid = pMbx->GetOwnerSid();
    
    //
    // Prepare the reply structure
    //

    AuthzAccessReply.Error = &dwErr;
    AuthzAccessReply.GrantedAccessMask = &amAccessGranted;
    AuthzAccessReply.ResultListLength = 1;

    //
    // Create or retrieve the client context
    //

    if( _mapSidContext.find(pair<PSID, DWORD>(psUser, dwIncomingIp))
        == _mapSidContext.end())
    {
        //
        // No context available, initialize
        //

        LUID lIdentifier = {0L, 0L};

        //
        // Since we are using SIDs which are not generated by NT,
        // it would be pointless to resolve group memberships, since
        // the SIDs will not be recognized by any machine in the domain,
        // and none of our ACLs use actual NT account SIDs. Therefore,
        // we use the SKIP_LOCAL_GROUPS and SKIP_TOKEN_GROUPS flags,
        // the LOCAL prevents a check for groups on the local machine, 
        // and TOKEN prevents a search on the domain
        //

        if( FALSE == AuthzInitializeContextFromSid(
                            psUser,
                            NULL,
                            _hRM,
                            NULL,
                            lIdentifier,
                            AUTHZ_SKIP_LOCAL_GROUPS | AUTHZ_SKIP_TOKEN_GROUPS,
                            &dwIncomingIp,
                            &hAuthzClient) )
        {
            AuthzFreeAuditInfo(hAuthzAuditInfo, _hRM);
            throw (DWORD)ERROR_INTERNAL_ERROR;

        }

        _mapSidContext[pair<PSID, DWORD>(psUser, dwIncomingIp)] = 
                                                                hAuthzClient;
    }
    else
    {
        //
        // Use existing context
        //

        hAuthzClient = _mapSidContext[pair<PSID, DWORD>(psUser, dwIncomingIp)];

    }

    BOOL bTmp;

    //
    // Perform the access check
    //

    bTmp = AuthzAccessCheck(
                     hAuthzClient,
                     &AuthzAccessRequest,
                     hAuthzAuditInfo,
                     &_sd,
                     NULL,
                     0,
                     &AuthzAccessReply,
                     NULL
                     );

    AuthzFreeAuditInfo(hAuthzAuditInfo, _hRM);

    //
    // Determine whether to grant access
    // On AccessCheck error, deny access
    //

    if( dwErr == ERROR_SUCCESS && bTmp != FALSE)
    {
        return pMbx;
    }
    else
    {
        return NULL;
    }

}




BOOL MailRM::GetMultipleMailboxAccess(
                            IN      const PMAILRM_MULTI_REQUEST pRequest,
                            IN OUT  PMAILRM_MULTI_REPLY pReply
                            )
/*++

    Routine Description
    
        This routine performs a set of cached access checks in order to request
        access to a set of mailboxes for a single user (for example, mail admin
        sending out a message to all users). 
                
        No need to audit, since this type of access would be only done by an
        administrator, and multiple audits would most likely flood the mailbox.
        Something like this would be use, for example, to send out a message
        to all users.
		
		The cached access check first assumes all callback deny ACEs which match
        SIDs in the user's context apply, and no allow callback ACEs apply.
		Therefore, the cached access check may initially deny access when it
        should be granted. If a cached access check results
        in access denied, a regular access check is performed automatically
        by AuthZ. As a result, the cached access check is guaranteed to have
        the same results as a normal access check, though it will take
        significantly more time if many denies are encountered than if most
        access requests succeed.

    Arguments
    
        pRequest    -   Request structure describing the user and the mailboxes
        
        pReply      -   Reply structure returning mailbox pointers and granted
                        access masks. If the access check fails, a NULL pointer
                        is returned for the given mailbox. This is allocated
                        by the caller, and should have the same number of
                        elements as the request.
                                
    
    Return Value
    
        TRUE on success
        
        FALSE on failure. If failure, pReply may not be completely filled
        
--*/        


{

    AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClient;

    AUTHZ_ACCESS_REQUEST AuthzAccessRequest;

    AUTHZ_ACCESS_REPLY AuthzAccessReply;

    DWORD dwErr = ERROR_SUCCESS;

    ACCESS_MASK amAccessGranted = 0;

    AUTHZ_HANDLE hAuthzCached;

    //
    // Set up the Authz access request
    // Only the DesiredAccess and PrincipalSelfSid parameters will change
    // per mailbox. Initial access check is MAXIMUM_ALLOWED.
    //

    AuthzAccessRequest.ObjectTypeList = NULL;
    AuthzAccessRequest.ObjectTypeListLength = 0;

    //
    // Initial access check will be caching, therefore optional parameters
    // will not be used
    //

    AuthzAccessRequest.OptionalArguments = NULL;

    //
    // The PrincipalSelf SID is the SID of the mailbox owner
    // This way, the PRINCIPAL_SELF_SID allow ACE grants access
    // only to the owner
    //

    AuthzAccessRequest.PrincipalSelfSid = NULL;

    //
    // Initially ask for MAXIMUM_ALLOWED access
    //

    AuthzAccessRequest.DesiredAccess = MAXIMUM_ALLOWED;
    
    //
    // Prepare the reply structure
    //

    AuthzAccessReply.Error = &dwErr;
    AuthzAccessReply.GrantedAccessMask = &amAccessGranted;
    AuthzAccessReply.ResultListLength = 1;

    //
    // Create or retrieve the client context
    //

    if( _mapSidContext.find(
           pair<PSID, DWORD>(pRequest->psUser , pRequest->dwIp)) 
        == _mapSidContext.end())
    {
        //
        // No context available, initialize
        //

        LUID lIdentifier = {0L, 0L};

        //
        // The SIDs are not real, therefore do not attempt to resolve
        // local or domain group memberships for the token
        //

        AuthzInitializeContextFromSid(
                            pRequest->psUser,
                            NULL,
                            _hRM,
                            NULL,
                            lIdentifier,
                            AUTHZ_SKIP_LOCAL_GROUPS | AUTHZ_SKIP_TOKEN_GROUPS,
                            &(pRequest->dwIp),
                            &hAuthzClient);

       
        _mapSidContext[pair<PSID, DWORD>(pRequest->psUser,
                                         pRequest->dwIp)] = hAuthzClient;
    }
    else
    {
        //
        // Use existing context
        //

        hAuthzClient = _mapSidContext[pair<PSID, DWORD>(pRequest->psUser,
                                                        pRequest->dwIp)];
        
    }

    //
    // Perform a single AuthZ access check to get the cached handle
    //

    if( FALSE == AuthzAccessCheck(
                         hAuthzClient,
                         &AuthzAccessRequest,
                         NULL,
                         &_sd,
                         NULL,
                         0,
                         &AuthzAccessReply,
                         &hAuthzCached
                         ))
    {
        return FALSE;
    }

    //
    // Now use the cached access check for all of the access requests
    //

    DWORD i;
    Mailbox * mbx;

    for( i = 0; i < pRequest->dwNumElems; i++ )
    {
        mbx = _mapSidMailbox[pRequest->pRequestElem[i].psMailbox];

        AuthzAccessRequest.DesiredAccess = 
                                    pRequest->pRequestElem[i].amAccessRequested;

        AuthzAccessRequest.PrincipalSelfSid = mbx->GetOwnerSid();

        AuthzAccessRequest.OptionalArguments = mbx;
            

        if( FALSE == AuthzCachedAccessCheck(
                            hAuthzCached,
                            &AuthzAccessRequest,
                            NULL,
                            &AuthzAccessReply
                            ))
        {
            return FALSE;
        }

        //
        // Access check done, now fill in the access array element
        //

        if( dwErr == ERROR_SUCCESS )
        {
            pReply[i].pMailbox = mbx;

            pReply[i].amAccessGranted = amAccessGranted;
        }
        else
        {
            pReply[i].pMailbox = NULL;

            pReply[i].amAccessGranted = 0;
        }

    }

    return TRUE;

}




BOOL CALLBACK MailRM::AccessCheck(
                        IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
                        IN PACE_HEADER pAce,
                        IN PVOID pArgs OPTIONAL,
                        IN OUT PBOOL pbAceApplicable
                        )
/*++

    Routine Description
    
        This is the Authz callback access check for the mail resource manager.
        
        It determines whether the given callback ACE applies based on whether
        the mailbox contains sensitive information and the current time.
            
    Arguments
    
        pAuthzClientContext -   the AuthZ client context of the user accessing
                                the mailbox, with dynamic groups already
                                computed
        
        pAce                -   Pointer to the start of the callback ACE
                                The optional ACE data is in the last 4
                                bytes of the ACE
        
        pArgs               -   The optional argument passed to the
                                AuthzAccessCheck, pointer to the Mailbox
                                being accessed
        
        pbAceApplicable     -   Set to TRUE iff the ACE should be used in the
                                access check.
    
    Return Value
        
        TRUE on success
        
        FALSE on failure                       
--*/        
{

    BOOL bTimeApplies;
    BOOL bSensitiveApplies;

 
    //
    // If pArgs are not present, ACE is never applicable
    //

    if( pArgs == NULL )
    {
        *pbAceApplicable = FALSE;
        return TRUE;
    }

    //
    // Offset of the optional data, last 4 bytes of the callback ACE
    //

    PMAILRM_OPTIONAL_DATA pOptData = (PMAILRM_OPTIONAL_DATA) (
                                             (PBYTE)pAce 
                                           + pAce->AceSize
                                           - sizeof(MAILRM_OPTIONAL_DATA));

    //
    // Get current time and check if the ACE time restriction applies
    //

    time_t tTime;
    struct tm * tStruct;
    
    time(&tTime);
    tStruct = localtime(&tTime);

    if( WITHIN_TIMERANGE(tStruct->tm_hour,
                         pOptData->bStartHour,
                         pOptData->bEndHour) )
    {
        bTimeApplies = TRUE;
    }
    else
    {
        bTimeApplies = FALSE;
    }

    //
    // Check whether the mailbox is sensitive and the ACE applies to sensitive
    // mailboxes
    //

    if(    ((Mailbox *)pArgs)->IsSensitive() 
        && pOptData->bIsSensitive == MAILRM_SENSITIVE )
    {
        bSensitiveApplies = TRUE;
    }
    else
    {
        bSensitiveApplies = FALSE;
    }
    
    //
    // Make the final decision based on whether the optional argument
    // calls for an AND or OR condition
    //

    if( pOptData->bLogicType == MAILRM_USE_AND )
    {
        *pbAceApplicable = bSensitiveApplies && bTimeApplies;
    }
    else
    {
        *pbAceApplicable = bSensitiveApplies || bTimeApplies;

    }

    //
    // AccessCheck succeeded
    //

    return TRUE;
    
}







BOOL CALLBACK MailRM::ComputeDynamicGroups(
                        IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
                        IN PVOID Args,
                        OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
                        OUT PDWORD pSidCount,
                        OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
                        OUT PDWORD pRestrictedSidCount
                        )
/*++

    Routine Description
    
        This is the Authz callback which computes additional dynamic groups
        for the user context.
        
        If the user is originating at an IP address outside the company lan
        (company lan assumed to be 192.*), the InsecureSid SID is added
        to the client's context, signifying that the connection is not 
        secure. This enables callback ACEs which prohibit sensitive
        information from being sent over insecure connections.
            
    Arguments
    
        pAuthzClientContext -   the AuthZ client context of the user 
                
        pArgs               -   The optional argument passed to the
                                AuthzCreateContext, pointer to a DWORD
                                containing the user's IP address
                                        
        pSidAttrArray *     -   The additional SIDs, if any are assigned,
                                are returned here.
        
        pSidCount           -   Number of entries in pSidAttrArray
        
        pRestrictedSidAttrArray *   -   The additional restricted SIDs, if any 
                                        are assigned, are returned here.
        
        pRestrictedSidCount         -   Number of entries in pSidAttrArray

    
    Return Value
        
        TRUE on success
        
        FALSE on failure                       
--*/        

{

    //
    // No restrict-only groups used
    //

    *pRestrictedSidCount = 0;
    *pRestrictedSidAttrArray = NULL;

    //
    // Internal company network (secure) is 192.*, anything else is insecure
    //

    if( *( (DWORD *) Args) >= 0xC0000000 && *( (DWORD *) Args) < 0xC1000000 )
    {   
        //
        // Secure, within the company IP range, no restricted groups
        //

        *pSidCount = 0;
        *pSidAttrArray = NULL;

    }
    else
    {
        //
        // Insecure external connection, add the Insecure group SID
        //

        *pSidCount = 1;
        *pSidAttrArray = 
                    (PSID_AND_ATTRIBUTES)malloc( sizeof(SID_AND_ATTRIBUTES) );

        if( pSidAttrArray == NULL )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        (*pSidAttrArray)[0].Attributes = SE_GROUP_ENABLED;

        (*pSidAttrArray)[0].Sid = InsecureSid;


    }

                                              
    return TRUE;    
                                           
}


VOID CALLBACK MailRM::FreeDynamicGroups (
                        IN PSID_AND_ATTRIBUTES pSidAttrArray
                        )
/*++

    Routine Description
    
        This routine frees any memory allocated by ComputeDynamicGroups
                    
    Arguments
    
        pSidAttrArray   -   Pointer to the memory to be freed
    
    Return Value
        
        None

--*/        

{
    

    free(pSidAttrArray);

}



bool CompareSidStruct::operator()(const PSID pSid1, const PSID pSid2) const
/*++

    Routine Description

        This is a less-than function which places a complete ordering on
        a set of PSIDs by value, NULL PSIDs are valid. This is used by the 
        STL map.
        
        Since the number of subauthorities appears before the subauthorities
		themselves, that difference will be noticed for two SIDs of different
		size before the memcmp tries to access the nonexistant subauthority
		in the shorter SID, therefore an access violation will not occur.
                    
    Arguments
    
        pSid1   -   The first PSID
        pSid2   -   The second PSID
    
    Return Value
        
        true IFF pSid1 < pSid2

--*/        

{

    //
    // If both are NULL, false should be returned for complete ordering
    //

    if(pSid2 == NULL)
    {
        return false;
    }

    if(pSid1 == NULL)
    {
        return true;
    }

    if( memcmp(pSid1, pSid2, GetLengthSid(pSid1)) < 0 )
    {
        return true;
    }
    else
    {
        return false;
    }
}



bool CompareSidPairStruct::operator()(const pair<PSID, DWORD > pair1, 
                                      const pair<PSID, DWORD > pair2) const
/*++

    Routine Description

        This is a less-than function which places a complete ordering on
        a set of <PSID, DWORD> pairs by value, NULL PSIDs are valid. This
        is used by the STL map
                    
    Arguments
    
        pair1   -   The first pair
        pair2   -   The second pair
    
    Return Value
        
        true IFF pSid1 < pSid2 OR (pSid1 = pSid2 AND DWORD1 < DWORD2)

--*/        
{
    CompareSidStruct SidComp;
    
    if( pair1.second < pair2.second )
    {
        return true;
    }

    if( pair1.second > pair2.second )
    {
        return false;
    }

    return SidComp.operator()(pair1.first, pair2.first);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\mailrm\mailrmp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mailrmp.h

Abstract:

	Private header file for the resource manager

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#pragma once

#include "pch.h"




//
// Statically initialize the SIDs used
// We only need our own identifier authority (so as not to collide with 
// NT's accounts if we eventually allow the use of NT domain SIDs) and
// a single relative ID (the last number) identifying the user/group,
// since we are not using multiple domains. Mail domains could be added
// by adding a domain GUID to the user's SIDs before the user's RID.
//

#define MAILRM_IDENTIFIER_AUTHORITY { 0, 0, 0, 0, 0, 42 }

SID sInsecureSid = 		 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 1 };
SID sBobSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 2 };
SID sMarthaSid= 		 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 3 };
SID sJoeSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 4 };
SID sJaneSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 5 };
SID sMailAdminsSid = 	 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 6 };

PSID InsecureSid = 	&sInsecureSid;
PSID BobSid = &sBobSid;
PSID MarthaSid= &sMarthaSid;
PSID JoeSid = &sJoeSid;
PSID JaneSid = &sJaneSid;
PSID MailAdminsSid = &sMailAdminsSid;

//
// Principal self SID. When used in an ACE, the Authz access check replaces it
// by the passed in PrincipalSelfSid parameter during the access check. In this
// case, it is replaced by the owner's SID retrieved from the mailbox.
//

SID sPrincipalSelfSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_PRINCIPAL_SELF_RID
						  };

PSID PrincipalSelfSid = &sPrincipalSelfSid;

//
// A callback ACE can contain additional policy data after the regular ACE
// fields. This structure is appended to the end of every callback ACE used
// by the mail resource manager, enabling the access check algorithm to make
// policy-based access decisions, instead of the solely identity-based decisions
// used in standard ACE types. If the SID in a callback ACE matches the SID
// in the user's AuthZ context, verification is done whether this policy applies
// (verification done by the AccessCheck callback function in the MailRM class)
// Therefore, an ACE applies if and only if the ACE SID matches a SID in the 
// user's context AND the policy below applies
//

typedef struct
{
    //
    // Whether this ACE should apply to sensitive mailboxes
    // set to MAILRM_SENSITIVE if it shoult apply, 0 if not
	//
	
	BYTE bIsSensitive;

	//
	// Whether the Sensitive and Time conditions should be treated
	// with a logical AND or OR. If AND, both conditions have to be satisfied
	// for the ACE to apply. If OR, one or both conditions satisfied will
	// result in the ACE being applied
	//
	
	BYTE bLogicType;
	
	//
	// Start hour of time range to use (in the 24-hour format) to decide
	// whether the ACE should apply. Valid values are from 0 to 23. The
	// actual time must be within the defined time range for the time condition
	// to apply. In other words, bStartHour <= CurrentHour < EndHour
	//

	BYTE bStartHour;

	//
	// End hour of the time range
	//

	BYTE bEndHour;
} MAILRM_OPTIONAL_DATA, *PMAILRM_OPTIONAL_DATA;


//
// Flags used in the optional data structure for the callback ACEs
//


//
// If the sensitive field in the optional data is set with this, and the
// mailbox contains sensitive data, this condition applies
//

#define MAILRM_SENSITIVE 1

//
// Type of boolean logic to use on the time and sensitive conditions
// time applies AND sensitive applies
// time applies OR sensitive applies
//

#define MAILRM_USE_AND 0

#define MAILRM_USE_OR 1

//
// Default starting time for the callback ACEs: 11pm
//

#define MAILRM_DEFAULT_START_TIME 23

//
// Default end time for the callback ACEs: 5am
//

#define MAILRM_DEFAULT_END_TIME 5


//
// Macro to determine whether a time falls within a given time range
//

#define WITHIN_TIMERANGE(HOUR, START_HOUR, END_HOUR) \
	( ( (START_HOUR) > (END_HOUR) ) ^ \
	( (HOUR) >= min((START_HOUR), (END_HOUR)) && \
	  (HOUR) <  max((START_HOUR), (END_HOUR))))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\mailrm\mailrm.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mailrm.h

Abstract:

   The header file for the sample AuthZ resource manager for mailboxes

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/

#pragma once

#include "pch.h"

#include <string>
#include <map>

using namespace std;

//
// RM-specific access masks used in the ACEs inside the mail RM. 
// The lower 16 bits of the access mask are for user-specified rights
// such as these
//

//
// Access mask needed to read the contents of a mailbox
//

#define ACCESS_MAIL_READ     0x00000001

//
// Access mask needed to delete messages from a mailbox
//

#define ACCESS_MAIL_WRITE    0x00000002

//
// Access mask for Administrative access to a mailbox
//

#define ACCESS_MAIL_ADMIN    0x00000004

//
// The SIDs used in the RM, allocated elsewhere
//

extern PSID InsecureSid;
extern PSID BobSid;
extern PSID MarthaSid;
extern PSID JoeSid;
extern PSID JaneSid;
extern PSID MailAdminsSid;
extern PSID PrincipalSelfSid;


//
// Forward declarations
// 

class Mailbox;
class MailRM;

//
// Comparison for PSIDs which works with STL map and multimap
// These are needed to impose a total ordering on the SIDs by value
//

struct CompareSidStruct 
{
    bool operator()(const PSID pSid1, const PSID pSid2) const;
};

struct CompareSidPairStruct 
{
    bool operator()(const pair<PSID, DWORD > pair1, 
                    const pair<PSID, DWORD > pair2) const;
};


//
// Element of the multiple mailbox access request
//

typedef struct 
{
    //
    // Mailbox to access
    //

    PSID psMailbox;

    //
    // Access mask requested for mailbox
    //

    ACCESS_MASK amAccessRequested;

} MAILRM_MULTI_REQUEST_ELEM, *PMAILRM_MULTI_REQUEST_ELEM;


//
// Used for multiple mailbox access request
//

typedef struct 
{

    //
    // SID of the user getting access
    //

    PSID psUser;

    //
    // IP address of the user
    //

    DWORD dwIp;

    //
    // Number of MAILRM_MULTI_REQUEST_ELEM's
    //

    DWORD dwNumElems;

    //
    // Pointer to the first element
    //

    PMAILRM_MULTI_REQUEST_ELEM pRequestElem;

} MAILRM_MULTI_REQUEST, *PMAILRM_MULTI_REQUEST;


//
// Reply to a multiple mailbox access request is returned
// as an array of these. 
//

typedef struct 
{
    //
    // Pointer to mailbox, or NULL on failure
    //

    Mailbox * pMailbox;

    //
    // Granted access mask
    //

    ACCESS_MASK amAccessGranted;


} MAILRM_MULTI_REPLY, *PMAILRM_MULTI_REPLY;




class Mailbox
/*++
   
   Class:              Mailbox
   
   Description:        
        
        This class is the mailbox container for a user's mail. It contains the
        SID of the mailbox owner, and also keeps track of whether any sensitive
        information is contained in the mailbox.
 
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{

private:

    //
    // Whether the mailbox contains sensitive data
    //

    BOOL _bIsSensitive;

    //
    // Owner of the mailbox, for PRINCIPAL_SELF evaluation
    //

    PSID _pOwnerSid;

    //
    // All messages in the mailbox
    //

    wstring _MailboxData;

    //
    // Name of the mailbox/mail owner
    //

    wstring _MailboxOwner;

public:
    
    Mailbox(IN  PSID pOwnerSid,
            IN  BOOL bIsSensitive,
            IN  WCHAR *szOwner) 
        {   
            _bIsSensitive = bIsSensitive;
            _pOwnerSid = pOwnerSid;
            _MailboxOwner.append(szOwner); 
        }

    //
    // Accessors
    //

    BOOL IsSensitive() const 
        { return _bIsSensitive; }

    const PSID GetOwnerSid() const 
        { return _pOwnerSid; }

    const WCHAR * GetOwnerName() const 
        { return _MailboxOwner.c_str(); }

    const WCHAR * GetMail() const 
        { return _MailboxData.c_str(); }


public:

    //
    // Manipulate the stored mail
    //

    void SendMail(IN const WCHAR *szMessage,
                  IN BOOL bIsSensitive )
        { _MailboxData.append(szMessage); _bIsSensitive |= bIsSensitive; }

    void Flush() 
        { _MailboxData.erase(0, _MailboxData.length()); _bIsSensitive = FALSE; }
                                                                                       
};



class MailRM
/*++
   
   Class:              MailRM
   
   Description:        
        
        This class manages a set of mailboxes, granting access to the mailboxes
        based on a single internally stored security descriptor containing
        callback and regular ACEs. It also audits certain mailbox activity.
        
   Base Classes:       none
 
   Friend Classes:     none
 
--*/
{

private:

    //
    // Security descriptor common to all mailboxes
    //

    SECURITY_DESCRIPTOR _sd;
    

    //
    // Mapping of SIDs to mailboxes
    //

    //map<const PSID, Mailbox *, CompareSidStruct> _mapSidMailbox;
    map<const PSID, Mailbox *> _mapSidMailbox;
    //
    // AuthZ contexts should only be created once for a given SID,IP pair
    // This stores the contexts once they are created
    //

    map<pair<PSID, DWORD >,
        AUTHZ_CLIENT_CONTEXT_HANDLE,
        CompareSidPairStruct> _mapSidContext;

    //
    // Handle to the resource manager to be initialized with the callbacks
    //

    AUTHZ_RESOURCE_MANAGER_HANDLE _hRM;

public:

    //
    // Constructor, initializes resource manager
    //

    MailRM();
    
    //
    // Destructor, frees RM's memory
    //

    ~MailRM();


public:

    //
    // Attempts to access the mailbox as psUser from the given IP address, 
    // requesting amAccessRequested access mask. If access is granted and the
    // mailbox exists, the pointer to the mailbox is returned. 
    //

    Mailbox * GetMailboxAccess(
                            IN const PSID psMailbox,
                            IN const PSID psUser,
                            IN DWORD dwIncomingIp,
                            IN ACCESS_MASK amAccessRequested
                            );
    //
    // Attempt to access a set of mailboxes using a cached access check
    // pReply should be an allocated array with the same number of elements
    // as the request
    //

    BOOL GetMultipleMailboxAccess(
                            IN      const PMAILRM_MULTI_REQUEST pRequest,
                            IN OUT  PMAILRM_MULTI_REPLY pReply
                            );


    //
    // Adds a mailbox to be controlled by the RM
    //

    void AddMailbox(Mailbox * pMailbox);

private:

    //
    // Internal function to completely set up the security descriptor
    // Should only be called once per instance, by the contructor
    //

    void InitializeMailSecurityDescriptor();

    //
    // Resource manager callbacks
    // These must be static, since they are called as C functions.
    // Non-static member functions expect a this pointer as the first
    // argument on the stack, and therefore cannot be called as C 
    // functions. These callbacks do not depend on any instance-specific
    // data, and therefore can and should be static.
    //
            
    static BOOL CALLBACK AccessCheck(
                            IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
                            IN PACE_HEADER pAce,
                            IN PVOID pArgs OPTIONAL,
                            IN OUT PBOOL pbAceApplicable
                            );

    static BOOL CALLBACK ComputeDynamicGroups(
                            IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
                            IN PVOID Args,
                            OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
                            OUT PDWORD pSidCount,
                            OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
                            OUT PDWORD pRestrictedSidCount
                            );

    static VOID CALLBACK FreeDynamicGroups (
                            IN PSID_AND_ATTRIBUTES pSidAttrArray
                            );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\mailrm\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <authz.h>


#define SECURITY_WIN32

//#include "sspi.h"
//#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\mailrm\main.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.h

Abstract:

   The header file for the sample AuthZ mail resource manager test

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/



//
// This structure defines an access attempt by psUser to access the mailbox of
// the user psMailbox with amAccess access mask. psUser is coming in from dwIP
// IP address
//

typedef struct
{
    PSID psUser;
    PSID psMailbox;
    ACCESS_MASK amAccess;
    DWORD dwIP;
} testStruct;


//
// This structure defines a mailbox to create, owned by psUser (with name szName
// which is used for auditing). If bIsSensitive is true, the mailbox initially
// is marked as containing sensitive data
//

typedef struct
{
    PSID psUser;
    BOOL bIsSensitive;
    WCHAR * szName;   
} mailStruct;


//
// Forward declarations for functions in main.cpp
//

void PrintUser(const PSID psUser);
void PrintPerm(ACCESS_MASK am);
void PrintTest(testStruct tst);
void GetAuditPrivilege();
void PrintMultiTest(PMAILRM_MULTI_REQUEST pRequest,
                    PMAILRM_MULTI_REPLY pReply,
                    DWORD dwIdx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\makesd\main.c ===
#include "pch.h"
#include "makesd.h"

#include <stdio.h>

#define MAILRM_IDENTIFIER_AUTHORITY { 0, 0, 0, 0, 0, 42 }

SID sInsecureSid = 		 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 1 };
SID sBobSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 2 };
SID sMarthaSid= 		 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 3 };
SID sJoeSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 4 };
SID sJaneSid = 			 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 5 };
SID sMailAdminsSid = 	 { SID_REVISION, 1, MAILRM_IDENTIFIER_AUTHORITY, 6 };

PSID InsecureSid = 	&sInsecureSid;
PSID BobSid = &sBobSid;
PSID MarthaSid= &sMarthaSid;
PSID JoeSid = &sJoeSid;
PSID JaneSid = &sJaneSid;
PSID MailAdminsSid = &sMailAdminsSid;

//
// Principal self SID. When used in an ACE, the Authz access check replaces it
// by the passed in PrincipalSelfSid parameter during the access check. In this
// case, it is replaced by the owner's SID retrieved from the mailbox.
//

SID sPrincipalSelfSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_PRINCIPAL_SELF_RID
						  };

SID sNetworkSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_NETWORK_RID
						  };

SID sAuthenticatedSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_AUTHENTICATED_USER_RID,
						  };

SID sDialupSid =   { 
							SID_REVISION,
							1,
							SECURITY_NT_AUTHORITY,
							SECURITY_DIALUP_RID,
						  };

PSID PrincipalSelfSid = &sPrincipalSelfSid;
PSID NetworkSid = &sNetworkSid;
PSID AuthenticatedSid = &sAuthenticatedSid;
PSID DialupSid = &sDialupSid;



void __cdecl wmain(int argc, WCHAR *argv[])
{
    
    PSECURITY_DESCRIPTOR pSd;

    BOOL bSuccess;

    if( argc != 2 )
    {
        printf("Error: makesd <filename>\n");
    }

    bSuccess = CreateSecurityDescriptor2(
                        &pSd, // SD
                        0, // SD Control
                        PrincipalSelfSid, // owner
                        NULL, // group
                        TRUE, // DACL present
                        3, // 3 DACL ACEs
                        FALSE, // SACL not present
                        0, // 0 SACL ACEs
                        
                        // Var argl list
                        ACCESS_DENIED_ACE_TYPE,
                        OBJECT_INHERIT_ACE,
                        DialupSid,
                        FILE_GENERIC_READ,

                        ACCESS_ALLOWED_ACE_TYPE,
                        OBJECT_INHERIT_ACE,
                        AuthenticatedSid,
                        FILE_GENERIC_READ,

                        ACCESS_ALLOWED_CALLBACK_ACE_TYPE,
                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
                        PrincipalSelfSid,
                        FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE,
                        0,
                        NULL
                        
                        );

    if( !bSuccess )
    {
        printf("Error: %u\n", GetLastError());
        exit(0);
    }

    bSuccess = IsValidSecurityDescriptor(pSd);

    if( !bSuccess )
    {
        printf("Error: Invalid security descriptor\n");
        exit(0);
    }


    bSuccess = SetFileSecurity(
                    argv[1], 
                    DACL_SECURITY_INFORMATION,
                    pSd);

    if( !bSuccess )
    {
        printf("Error setting sec: %u\n", GetLastError());
        exit(0);
    }

    FreeSecurityDescriptor2(pSd);
    printf("Success\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\makesd\makesd.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    createsd.c

Abstract:

   Variable argument list function for creating a security descriptor
   
Author:

    t-eugenz - September 2000

Environment:

    User mode only.

Revision History:

    Created                 - September 2000

--*/

#include "pch.h"
#include "makesd.h"

#include <stdarg.h>
#include <stdio.h>

//
// ISSUE: Which public header is this in?
//

#define MAX_WORD 0xFFFF

#define FLAG_ON(flags,bit)        ((flags) & (bit))

void FreeSecurityDescriptor2(
                          IN            PSECURITY_DESCRIPTOR pSd
                          )
/*++

Routine Description:

    This frees a security descriptor created by CreateSecurityDescriptor    
    
Arguments:

    pSd             -   The pointer to the security descriptor to be freed
    
Return Value:

    none
    
--*/
{
    ASSERT( pSd != NULL );
    free(pSd);
}


#define F_IS_DACL_ACE           0x00000001
#define F_IS_CALLBACK           0x00000002
#define F_IS_OBJECT             0x00000004
#define F_RETURN_ALL_DATA       0x00000010

typedef struct
{
    DWORD           dwFlags;
    ACE_HEADER      pAce;
    ACCESS_MASK     amMask;
    PSID            pSid;
    DWORD           dwOptDataSize;
    PVOID           pvOptData;
    GUID *          pgObject;
    GUID *          pgInherit;
} ACE_REQUEST_STRUCT, *PACE_REQUEST_STRUCT;



BOOL GetNextAceInfo( IN OUT     va_list             *varArgList,
                     IN OUT     PACE_REQUEST_STRUCT pAceRequest
                     )
{

    DWORD dwAceSize = 0;
    BYTE bAceType = 0;
    BYTE bAceFlags = 0;
    DWORD amAccessMask = 0;
    PSID pSid = NULL;
    GUID * pgObject = NULL;
    GUID * pgInherit = NULL;
    DWORD dwOptDataSize = 0;
    PVOID pvOptData = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwMask = 0;
    DWORD dwFlags = 0;


    //
    // Read the first arg to determine the ACE type, 
    //

    bAceType = va_arg(*varArgList, BYTE);

    //
    // Different sets for DACL and SACL
    //

    if( pAceRequest->dwFlags & F_IS_DACL_ACE )
    {
        //
        // Calculate the size of the DACL ACE
        //

        switch( bAceType )
        {
        
        case ACCESS_ALLOWED_ACE_TYPE:

            dwAceSize += (
                             sizeof(ACCESS_ALLOWED_ACE) 
                           - sizeof(DWORD) 
                         );

            break;

        case ACCESS_DENIED_ACE_TYPE:

            dwAceSize += (
                             sizeof(ACCESS_DENIED_ACE) 
                           - sizeof(DWORD) 
                         );

            break;

        case ACCESS_ALLOWED_CALLBACK_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_ALLOWED_CALLBACK_ACE) 
                           - sizeof(DWORD)
                          );

            dwFlags |= F_IS_CALLBACK;

            break;

        case ACCESS_DENIED_CALLBACK_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_DENIED_CALLBACK_ACE) 
                           - sizeof(DWORD)
                          );

            dwFlags |= F_IS_CALLBACK;
            
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_ALLOWED_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            
            break;

        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_DENIED_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            
            break;

        case ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_ALLOWED_CALLBACK_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            dwFlags |= F_IS_CALLBACK;
            
            break;

        case ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(ACCESS_DENIED_CALLBACK_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            dwFlags |= F_IS_CALLBACK;
            
            break;

        default:

            dwErr = ERROR_INVALID_PARAMETER;

            goto error;
        }

    }
    else
    {

        switch( bAceType )
        {
        case SYSTEM_AUDIT_ACE_TYPE:

            dwAceSize += (
                             sizeof(SYSTEM_AUDIT_ACE) 
                           - sizeof(DWORD) 
                         );

            break;

        case SYSTEM_AUDIT_CALLBACK_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(SYSTEM_AUDIT_CALLBACK_ACE) 
                           - sizeof(DWORD)
                          );

            dwFlags |= F_IS_CALLBACK;
            
            break;


        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(SYSTEM_AUDIT_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            
            break;

        case SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE:

            dwAceSize +=  (
                             sizeof(SYSTEM_AUDIT_CALLBACK_OBJECT_ACE) 
                           - sizeof(DWORD)
                           - 2 * sizeof(GUID)
                          );

            dwFlags |= F_IS_OBJECT;
            dwFlags |= F_IS_CALLBACK;
            
            break;

        default:

            dwErr = ERROR_INVALID_PARAMETER;

            goto error;
        }
    }

    //
    // Now we know the arguments contained
    //

    //
    // The flags
    //

    bAceFlags = va_arg(*varArgList, BYTE);
    
    //
    // The SID
    //

    pSid = va_arg(*varArgList, PSID);
    
    dwAceSize += GetLengthSid( pSid );

    //
    // Access mask
    //

    amAccessMask = va_arg(*varArgList, ACCESS_MASK);

    //
    // If callback, next two arguments are optional data size and data
    //

    if( dwFlags & F_IS_CALLBACK )
    {
        dwOptDataSize = va_arg(*varArgList, DWORD);

        pvOptData = va_arg(*varArgList, PVOID);

        dwAceSize += dwOptDataSize;
    }

    //
    // May contain GUIDs if object ACE
    //

    if( dwFlags & F_IS_OBJECT )
    {
        //
        // Up to 2 GUIDs if both are not NULL
        //

        pgObject = va_arg(*varArgList, GUID *);

        pgInherit = va_arg(*varArgList, GUID *);

        if( pgObject != NULL )
        {
            dwAceSize += sizeof(GUID);
        }

        if( pgInherit != NULL )
        {
            dwAceSize += sizeof(GUID);
        }
    }

    //
    // Finally, verify the ACE is within max size
    //

    if( dwAceSize > MAX_WORD )
    { 
        dwErr = ERROR_INVALID_PARAMETER;
    }


    error:;
    

    if( dwErr != ERROR_SUCCESS )
    {
        SetLastError(dwErr);
        
        return 0;
    }
    else
    {
        //
        // Fill in the requested return values
        //

        if( pAceRequest->dwFlags & F_RETURN_ALL_DATA )
        {
            pAceRequest->dwFlags = dwFlags;
            pAceRequest->pAce.AceFlags = bAceFlags;
            pAceRequest->pAce.AceSize = (WORD)dwAceSize;
            pAceRequest->pAce.AceType = bAceType;
            pAceRequest->amMask = amAccessMask;
            pAceRequest->pSid = pSid;
            
            if( dwFlags & F_IS_CALLBACK )
            {
                pAceRequest->dwOptDataSize = dwOptDataSize;
                pAceRequest->pvOptData = pvOptData;
            }

            if( dwFlags & F_IS_OBJECT )
            {
                pAceRequest->pgObject = pgObject;
                pAceRequest->pgInherit = pgInherit;
            }

        }

        return dwAceSize;
    }
}


BOOL 
WINAPI
CreateSecurityDescriptor2(
         OUT           PSECURITY_DESCRIPTOR * ppSd,
         IN    const   DWORD dwOptions,
         IN    const   SECURITY_DESCRIPTOR_CONTROL sControl,
         IN    const   PSID  psOwner,
         IN    const   PSID  psGroup,
         IN    const   DWORD dwNumDaclAces,
         IN    const   DWORD dwNumSaclAces,
         ...
         )
/*++

Routine Description:

    Creates a security descriptor with a DACL and a SACL using a variable
    argument list as input. Following the above fixed arguments, the ACEs
    should be specified by using 4 arguments for any ACE, with 2 additional
    arguments if the ACE is a callback, and 2 more arguments if it's an
    object ACE.
    
    Any number of ACEs can be specified. First, dwNumDaclAces
    ACEs will be read into the DACL for the security descriptor, then
    dwNumSaclAces will be read into the SACL.
    
    ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE: 4 arguments in this sequence
    
        BYTE bAceType           -   The ACE type
        
        BYTE bAceFlags          -   The ACE flags
        
        PSID pSid               -   The SID for the ACE
        
        ACCESS_MASK amMask      -   The access mask for the ACE
    
    Callback ACEs have the above 4 arguments, and 2 additional arguments
    which immediately follow the above:
    
        DWORD dwOptDataSize     -   The size (in bytes) of the optional
                                    data to be appended to the end of the ACE

        PVOID pvOptData         -   Pointer to the optional data
        
    Object ACEs have the appropriate arguments from above, and 2 additional 
    arguments:
        
        GUID * pgObjectType     -   Pointer to the object guid, or NULL for none
        
        GUID * pgInheritType    -   Pointer to the inheritance guid, or NULL
                                    for none
    
        
    ISSUE: Should ACE flags be verified? SIDs?
           Should ACL size be verified, since max ACL size is a SHORT?
    
    
Arguments:

    ppSd            -   The pointer to the allocated security descriptor is 
                        stored here, and should be freed using 
                        FreeSecurityDescriptor()
                        
    sControl        -   Only allowed bits are 
                        SE_DACL_AUTO_INHERITED 
                        SE_SACL_AUTO_INHERITED                        
                        SE_SACL_PROTECTED
                    
    psOwner         -   SID of the owner for the security descriptor
    
    psGroup         -   SID of the group for the security descriptor
    
    bDaclPresent    -   Whether the DACL should be non-NULL
                        If this is FALSE, no ACEs should be passed in the
                        variable args section for the DACL.
    
    dwNumDaclAces   -   Number of ACEs in the variable arguments for the DACL
    
    bSaclPresent    -   Whether the SACL should be non-NULL
                        If this is FALSE, no ACEs should be passed in the
                        variable args section for the SACL.
    
    dwNumSaclAces   -   Number of ACEs in the variable arguments for the SACL
    
    ...             -   The rest of the arguments for the ACEs, variable list
    
Return Value:

    TRUE on success
    FALSE on failure, more information available with GetLastError()
        
--*/
{

    DWORD dwIdx = 0;
    DWORD dwTmp = 0;
    DWORD dwTempFlags = 0;

    //
    // Size of the security descriptor and ACLs
    //

    DWORD dwSizeSd = 0;
    DWORD dwDaclSize = 0;
    DWORD dwSaclSize = 0;

    //
    // Start of the security descriptor, must be a pointer
    // to a type with sizeof(type) = 1, such as BYTE, so that
    // adding a size offset will work.
    //

    PBYTE pSd = NULL;

    //
    // Current offset in the security descriptor, incremented while filling
    // in the security descriptor
    //

    DWORD dwCurOffset = 0;

    //
    // Temporary ACL header
    //

    ACL aclTemp;

    //
    // Output for the GetNextAceInfo
    //

    ACE_REQUEST_STRUCT AceRequest;

    //
    // Variable argument list
    //

    va_list varArgList;

    BOOL bArglistStarted = FALSE;

    DWORD dwErr = ERROR_SUCCESS;

    
    //
    // Verify the arguments we can verify
    //

    if(     ( ppSd == NULL )
        ||  ( sControl & ~(  SE_DACL_AUTO_INHERITED 
                           | SE_SACL_AUTO_INHERITED
                           | SE_SACL_PROTECTED ) )
        ||  ( !FLAG_ON( dwOptions, CREATE_SD_DACL_PRESENT) && (dwNumDaclAces != 0))
        ||  ( !FLAG_ON( dwOptions, CREATE_SD_SACL_PRESENT) && (dwNumSaclAces != 0))
        ||  ( dwNumDaclAces > MAX_WORD )
        ||  ( dwNumSaclAces > MAX_WORD )                )
       
            
    {
        dwErr = ERROR_INVALID_PARAMETER;

        goto error;
    }

    //
    // First, we need to calculate the size of the security descriptor and the
    // ACLs, if any
    //

    pSd = NULL;

    dwSizeSd = sizeof(SECURITY_DESCRIPTOR);

    dwDaclSize = 0;

    dwSaclSize = 0;

    if( psOwner != NULL )
    {
        dwSizeSd += GetLengthSid(psOwner);
    }
    
    if( psGroup != NULL )
    {
        dwSizeSd += GetLengthSid(psGroup);
    }
    
    //
    // Start the variable args with the last non-varibale arg
    //

    va_start(varArgList, dwNumSaclAces);

    bArglistStarted = TRUE;


    //
    // Calculate the sizes of the DACL ACEs and the DACL itself
    //

    if ( FLAG_ON( dwOptions, CREATE_SD_DACL_PRESENT ))
    {

        dwDaclSize += sizeof(ACL);

        //
        // Now add all the ACEs (including SIDs)
        //

        for( dwIdx = 0; dwIdx < dwNumDaclAces; dwIdx++ )
        {
            //
            // Request next DACL ACE type, no additional data
            //

            AceRequest.dwFlags = F_IS_DACL_ACE;

            dwTmp = GetNextAceInfo( &varArgList, &AceRequest );

            if( dwTmp == 0 )
            {
                dwErr = ERROR_INVALID_PARAMETER;

                goto error;
            }
            else
            {
                dwDaclSize += dwTmp;
            }
        }

    }


    //
    // Calculate the sizes of the SACL ACEs and the SACL itself
    //

    if ( FLAG_ON( dwOptions, CREATE_SD_SACL_PRESENT ))
    {
        dwSaclSize += sizeof(ACL);

        //
        // Now add all the ACEs (including SIDs)
        //

        for( dwIdx = 0; dwIdx < dwNumSaclAces; dwIdx++ )
        {
            //
            // Request next SACL ACE type, no additional data
            //

            AceRequest.dwFlags = 0;

            dwTmp = GetNextAceInfo( &varArgList, &AceRequest );

            if( dwTmp == 0 )
            {
                dwErr = ERROR_INVALID_PARAMETER;

                goto error;
            }
            else
            {
                dwSaclSize += dwTmp;
            }
        }

    }

    //
    // Done with first pass through argument list
    //

    va_end(varArgList);

    bArglistStarted = FALSE;

    //
    // Verify that the ACLs will fit in the size limits (since ACL size
    // is a WORD)
    //

    if(    ( dwDaclSize > MAX_WORD )
        || ( dwSaclSize > MAX_WORD )   )
    {
        dwErr = ERROR_INVALID_PARAMETER;

        goto error;
    }

    //
    // At this point we know the size of the security descriptor,
    // which is the sum of dwSizeSd, dwDaclSize, and dwSaclSize.
    // Therefore, we can allocate the memory and determine the offsets of
    // the two ACLs in the security descriptor, which will be self-relative.
    //

    pSd = malloc( dwSizeSd + dwDaclSize + dwSaclSize );

    if( pSd == NULL )
    {
        *ppSd = NULL;

        SetLastError(ERROR_OUTOFMEMORY);

        return FALSE;
    }


    //
    // Everything resides in the same memory block, so we can simply walk the
    // memory block and fill it in. We start just past the end of the
    // fixed size security descriptor structure. As we copy things into this
    // memory blocks, we also initialize the matching offsets in the 
    // SECURITY_DESCRIPTOR (which is at the head of the block)
    //

    //
    // Revision
    //

    ((SECURITY_DESCRIPTOR *)pSd)->Revision = SECURITY_DESCRIPTOR_REVISION;

    //
    // Padding
    //

    ((SECURITY_DESCRIPTOR *)pSd)->Sbz1 = 0;

    //
    // SECURITY_DESCRIPTOR_CONTROL should reflect the fact that it is
    // self-relative. DACL and SACL are always present and not defaulted,
    // thought they may be NULL. User-specified inheritance flags are
    // also considered. The SD must be self relative. sControl is 
    // verified earlier
    //

    ((SECURITY_DESCRIPTOR *)pSd)->Control =     sControl
                                            |   SE_DACL_PRESENT
                                            |   SE_SACL_PRESENT
                                            |   SE_SELF_RELATIVE;

    //
    // We start with the owner SID, which is right after the SECURITY_DESCRIPTOR
    // structure
    //

    dwCurOffset = sizeof(SECURITY_DESCRIPTOR);

    if( psOwner == NULL )
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Owner = NULL;
    }
    else
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Owner = (PSID)dwCurOffset;

        dwTmp = GetLengthSid(psOwner);

        memcpy( pSd + dwCurOffset, psOwner, dwTmp );

        dwCurOffset += dwTmp;
    }

    //
    // Following that, the group SID
    //

    if( psGroup == NULL )
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Group = NULL;
    }
    else
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Group = (PSID)dwCurOffset;

        dwTmp = GetLengthSid(psGroup);

        memcpy( pSd + dwCurOffset, psGroup, dwTmp );

        dwCurOffset += dwTmp;
    }

    
    //
    // Second pass through the optional arguments, this time
    // we copy the given ACEs into the security descriptor
    //

    va_start(varArgList, dwNumSaclAces);

    bArglistStarted = TRUE;

    //
    // Now we handle the DACL. If the DACL is not present, offset is NULL.
    // Otherwise, even if 0 ACEs, add the ACL structure
    //
    // ISSUE: In self-relative SD, is a 0 offset enough for no ACL, or must
    // the SE_DACL_PRESENT flag not be set?
    //

    if ( !FLAG_ON( dwOptions, CREATE_SD_DACL_PRESENT ))
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Dacl = NULL;
    }
    else
    {
        //
        // Set the DACL offset to the current offset
        //

        ((SECURITY_DESCRIPTOR *)pSd)->Dacl = (PACL)dwCurOffset;

        //
        // First, copy in the ACL structure as the header
        //

        aclTemp.AceCount = (WORD)dwNumDaclAces;

        aclTemp.AclRevision = ACL_REVISION_DS;

        aclTemp.AclSize = (SHORT)dwDaclSize;

        aclTemp.Sbz1 = 0;

        aclTemp.Sbz2 = 0;

        memcpy( pSd + dwCurOffset, &aclTemp, sizeof(ACL) );

        dwCurOffset += sizeof(ACL);

        //
        // Now go through all the optional arguments for the DACL
        // and add the matching ACEs
        //

       
        for( dwIdx = 0; dwIdx < dwNumDaclAces; dwIdx++ )
        {
            
            //
            // This time, retrieve all the data
            //

            AceRequest.dwFlags = F_IS_DACL_ACE | F_RETURN_ALL_DATA;

            dwTmp = GetNextAceInfo( &varArgList, &AceRequest );

            if( dwTmp == 0 )
            {
                dwErr = GetLastError();

                goto error;
            }

            //
            // The ACE header is already filled in, and contains the ACE size
            //

            memcpy( pSd + dwCurOffset, &(AceRequest.pAce), sizeof(ACE_HEADER) );

            dwCurOffset += sizeof(ACE_HEADER);

            //
            // Set the access mask
            //

            *((PACCESS_MASK)( pSd + dwCurOffset )) = AceRequest.amMask;

            dwCurOffset += sizeof(ACCESS_MASK);


            //
            // If object ACE, set the object flags and GUIDs
            //

            if( AceRequest.dwFlags & F_IS_OBJECT )
            {
                dwTmp = 0;

                if( AceRequest.pgObject != NULL )
                {
                    dwTmp |= ACE_OBJECT_TYPE_PRESENT;
                }

                if( AceRequest.pgInherit != NULL )
                {
                    dwTmp |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                }

                //
                // Set the object ACE flags
                //

                *((PDWORD)(pSd + dwCurOffset )) = dwTmp;

                dwCurOffset += sizeof(DWORD);

                //
                // Copy the GUIDs, if any
                //

                if( AceRequest.pgObject != NULL )
                {
                    memcpy( pSd + dwCurOffset,
                            AceRequest.pgObject, 
                            sizeof(GUID) );

                    dwCurOffset += sizeof(GUID);
                }
                
                if( AceRequest.pgInherit != NULL )
                {
                    memcpy( pSd + dwCurOffset, 
                            AceRequest.pgInherit, 
                            sizeof(GUID) );

                    dwCurOffset += sizeof(GUID);
                }
            }

            //
            // Copy the SID
            //

            dwTmp = GetLengthSid( AceRequest.pSid );

            memcpy( pSd + dwCurOffset, AceRequest.pSid, dwTmp );

            dwCurOffset += dwTmp;

            //
            // If callback ACE, copy the optional data, if any
            //

            if(     AceRequest.dwFlags & F_IS_CALLBACK
                &&  AceRequest.dwOptDataSize > 0    )
            {
                memcpy( pSd + dwCurOffset, 
                        AceRequest.pvOptData, 
                        AceRequest.dwOptDataSize );

                dwCurOffset += AceRequest.dwOptDataSize;
            }

            //
            // Done with the ACE
            //
        }

        //
        // Done with the DACL
        //
    }

    //
    // Now we handle the SACL
    //

    if ( !FLAG_ON( dwOptions, CREATE_SD_SACL_PRESENT ))
    {
        ((SECURITY_DESCRIPTOR *)pSd)->Sacl = NULL;
    }
    else
    {
        //
        // Set the SACL offset to the current offset
        //

        ((SECURITY_DESCRIPTOR *)pSd)->Sacl = (PACL)dwCurOffset;

        //
        // First, copy in the ACL structure as the header
        //

        aclTemp.AceCount = (WORD) dwNumDaclAces;

        aclTemp.AclRevision = ACL_REVISION_DS;

        aclTemp.AclSize = (WORD) dwSaclSize;

        aclTemp.Sbz1 = 0;

        aclTemp.Sbz2 = 0;

        memcpy( pSd + dwCurOffset, &aclTemp, sizeof(ACL) );

        dwCurOffset += sizeof(ACL);

        //
        // Now go through all the optional arguments for the DACL
        // and add the matching ACEs
        //

        for( dwIdx = 0; dwIdx < dwNumSaclAces; dwIdx++ )
        {
            //
            // This time, retrieve all the data
            //

            AceRequest.dwFlags = F_RETURN_ALL_DATA;

            dwTmp = GetNextAceInfo( &varArgList, &AceRequest );

            if( dwTmp == 0 )
            {
                dwErr = GetLastError();

                goto error;
            }

            //
            // The ACE header is already filled in, and contains the ACE size
            //

            memcpy( pSd + dwCurOffset, &(AceRequest.pAce), sizeof(ACE_HEADER) );

            dwCurOffset += sizeof(ACE_HEADER);

            //
            // Set the access mask
            //

            *((PACCESS_MASK)( pSd + dwCurOffset )) = AceRequest.amMask;

            dwCurOffset += sizeof(ACCESS_MASK);


            //
            // If object ACE, set the object flags and GUIDs
            //

            if( AceRequest.dwFlags & F_IS_OBJECT )
            {
                dwTmp = 0;

                if( AceRequest.pgObject != NULL )
                {
                    dwTmp |= ACE_OBJECT_TYPE_PRESENT;
                }

                if( AceRequest.pgInherit != NULL )
                {
                    dwTmp |= ACE_INHERITED_OBJECT_TYPE_PRESENT;
                }

                //
                // Set the object ACE flags
                //

                *((PDWORD)(pSd + dwCurOffset )) = dwTmp;

                dwCurOffset += sizeof(DWORD);

                //
                // Copy the GUIDs, if any
                //

                if( AceRequest.pgObject != NULL )
                {
                    memcpy( pSd + dwCurOffset,
                            AceRequest.pgObject, 
                            sizeof(GUID) );

                    dwCurOffset += sizeof(GUID);
                }
                
                if( AceRequest.pgInherit != NULL )
                {
                    memcpy( pSd + dwCurOffset, 
                            AceRequest.pgInherit, 
                            sizeof(GUID) );

                    dwCurOffset += sizeof(GUID);
                }
            }

            //
            // Copy the SID
            //

            dwTmp = GetLengthSid( AceRequest.pSid );

            memcpy( pSd + dwCurOffset, AceRequest.pSid, dwTmp );

            dwCurOffset += dwTmp;

            //
            // If callback ACE, copy the optional data, if any
            //

            if(     AceRequest.dwFlags & F_IS_CALLBACK
                &&  AceRequest.dwOptDataSize > 0    )
            {
                memcpy( pSd + dwCurOffset, 
                        AceRequest.pvOptData, 
                        AceRequest.dwOptDataSize );

                dwCurOffset += AceRequest.dwOptDataSize;
            }

            //
            // Done with the ACE
            //
        }
        
        //
        // Done with the SACL
        //
    }
            

    //
    // Done with the variable arg list
    //

    va_end(varArgList);

    bArglistStarted = FALSE;

    error:;

    if( dwErr != ERROR_SUCCESS )
    {
        if( bArglistStarted )
        {
            va_end(varArgList);
        }

        if( pSd != NULL )
        {
            free(pSd);
        }

        SetLastError(dwErr);

        return FALSE;
    }
    else
    {
        //
        // Make sure the sizes match
        //

        ASSERT( dwCurOffset == ( dwSizeSd + dwDaclSize + dwSaclSize ) );

        *ppSd = pSd;

        return TRUE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\mailrm\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

   The test for the Mail resource manager

Author:

    t-eugenz - August 2000

Environment:

    User mode only.

Revision History:

    Created - August 2000

--*/


#include "mailrm.h"
#include "main.h"


//
// The set of mailboxes to create
//

mailStruct pMailboxes[] =
{
    { BobSid, TRUE, L"Bob" },
    { MarthaSid, FALSE, L"Martha" },
    { JoeSid, FALSE, L"Joe" },
    { JaneSid, FALSE, L"Jane" },
    { MailAdminsSid, FALSE, L"Admin" },
    { NULL, FALSE, NULL }
};


//
// The set of single access attempts to run
//

testStruct pTests[] =
{
    { MailAdminsSid, BobSid, ACCESS_MAIL_READ, 0xC0000001 },
    { BobSid, BobSid, ACCESS_MAIL_READ, 0xD0000001 },
    { BobSid, BobSid, ACCESS_MAIL_WRITE, 0xD0000001 },
    { MarthaSid, BobSid, ACCESS_MAIL_READ, 0xC0000001 },
    { JaneSid, JaneSid, ACCESS_MAIL_READ, 0xC0000001 },
    { NULL, NULL, 0, 0 }
};



//
// The set of mailboxes to attempt to access for the multiple mailbox access
// check, and the access type to request
//

MAILRM_MULTI_REQUEST_ELEM pRequestElems[] = 
{
    { BobSid, ACCESS_MAIL_WRITE},
    { MarthaSid, ACCESS_MAIL_WRITE},
    { MarthaSid, ACCESS_MAIL_READ},
    { JaneSid, ACCESS_MAIL_WRITE}
};

//
// The rest of the information for the multiple access check
//

MAILRM_MULTI_REQUEST mRequest =
{
    MailAdminsSid, // Administrator performing the access
    0xC1000001, // Administrators coming from insecure 193.0.0.1
    4, // 4 mailboxes to access, as above
    pRequestElems // The list of mailboxes
};


void __cdecl wmain(int argc, char *argv[])
/*++

    Routine Description

        This runs a set of sample tests on the MailRM object.
        
        It first tries to enable the Audit privilege in the current process's
        token. If you would like to test auditing, make sure to run this with
        an account which has this privilege. Otherwise, the audits will be
        ignored (however, the rest of the example will still work).
        
        It then constructs the MailRM instance, and adds the set of managed
        mailboxes declared in main.h to the resource manager.
        
        Then it performs the set of access attempts listed in main.h on the
        resource manager.
        
        Finally, it attempts a multiple access check by administrators. The
        mailboxes accessed are listed above. Successfuly accessed mailboxes
        receive administrative notifications.
        

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    DWORD dwIdx;

    MailRM * pMRM;

    Mailbox * pMbx;

    //
    // Enable the Audit privilege in the process token
    // To disable audit generation, comment this out
    //
    
    try {
        GetAuditPrivilege();
    }
    catch(...)
    {
        wprintf(L"Error enabling Audit privilege, audits will not be logged\n");
    }

    //
    // Initialize the resource manager object
    //
    
    try {
        pMRM = new MailRM();
    }
    catch(...)
    {
        wprintf(L"Fatal exception while instantiating MailRM, exiting\n");
        exit(1);
    }
    


    //
    // Create mailboxes and register them with the resource manager
    //
    
    for( dwIdx = 0; pMailboxes[dwIdx].psUser != NULL; dwIdx++ )
    {
        pMRM->AddMailbox( new Mailbox(pMailboxes[dwIdx].psUser,
                                      pMailboxes[dwIdx].bIsSensitive,
                                      pMailboxes[dwIdx].szName) );

    }



    //
    // Run the access checks
    //

    wprintf(L"\n\nIndividual access checks\n");
    
    try {
		for( dwIdx =0; pTests[dwIdx].psUser != NULL; dwIdx++ )
		{
			pMbx = pMRM->GetMailboxAccess(pTests[dwIdx].psMailbox,
										  pTests[dwIdx].psUser,
										  pTests[dwIdx].dwIP,
										  pTests[dwIdx].amAccess);
			if( pMbx != NULL )
			{
				wprintf(L"Granted: ");
			}
			else
			{
				wprintf(L"Denied: ");
			}
	
			PrintTest(pTests[dwIdx]);
		}
	}
	catch(...)
	{
		wprintf(L"Failed on individual access checks\n");
	}

    //
    // Now perform the access check using the GetMultipleAccess, which
    // uses a cached access check internally.
    // For every mailbox successfuly opened for write,
    // we send an administrative note.
    //

    wprintf(L"\n\nMultiple cached access checks\n");

	PMAILRM_MULTI_REPLY pReply = new MAILRM_MULTI_REPLY[mRequest.dwNumElems];

	if( pReply == NULL )
	{
		wprintf(L"Out of memory, exiting\n");
		exit(1);
	}
    
	try {
		if( FALSE == pMRM->GetMultipleMailboxAccess(&mRequest, pReply) )
		{
			wprintf(L"Failed on multiple access check\n");
		}
		else
		{
	
			for( dwIdx = 0; dwIdx < mRequest.dwNumElems; dwIdx++ )
			{
	
				if(     pReply[dwIdx].pMailbox != NULL 
                    &&  (   mRequest.pRequestElem[dwIdx].amAccessRequested 
                          & ACCESS_MAIL_WRITE ) )
				{
					pReply[dwIdx].pMailbox->SendMail(
								L"Note: Mail server will be down for 1 hour\n\n",
								FALSE
								);
	
					wprintf(L"Granted: ");
				}
				else
				{
					wprintf(L"Denied: ");
				}
	
				PrintMultiTest(&mRequest, pReply, dwIdx);
	
			}
		}
	}
	catch(...)
	{
		wprintf(L"Multiple access check failed, exiting\n");
		exit(1);
	}


	//
	// Clean up
	//

	//
	// This also deletes all managed mailboxes
	//

    delete pMRM;                                                            

    delete[] pReply;

}

void GetAuditPrivilege()
/*++

    Routine Description

        This attempts to enable the AUDIT privilege in the current process's
        token, which will allow the process to generate audits.
        
        Failure to enable the privilege is ignored. Audits will simply not
        be generated, but the rest of the example will not be effected.
        
        The privilege is enabled for the duration of this process, since
        the process's token is modified, not the user's token. Therefore,
        there is no need to set the privileges back to their initial state.
        
        If this were a part of a larger system, it would be a good idea
        to only enable the Audit privilege when needed, and restore the
        original privileges afterwards. This can be done by passing
        a previous state parameter to AdjustTokenPrivileges, which 
        would save the original state (to be restored later).

    Arguments
    
        None.
    
    Return Value
        None.                       
--*/        
{
    HANDLE hProcess;
    HANDLE hToken;

    //
    // First, we get a handle to the process we are running in, requesting
    // the right to read process information
    //

    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION,
                           FALSE,
                           GetCurrentProcessId()
                           );
    
    if( hProcess == NULL )
    {
        throw (DWORD)ERROR_INTERNAL_ERROR ;
    }

    //
    // We need to be able to read the current privileges and set new privileges,
    // as required by AdjustTokenPrivileges
    //

    OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken);

    if( hProcess == NULL )
    {
        CloseHandle(hProcess);
        throw (DWORD)ERROR_INTERNAL_ERROR;
    }

    //
    // We have the token handle, no need for the process anymore
    //

    CloseHandle(hProcess);
    
    LUID lPrivAudit;
    
    LookupPrivilegeValue(NULL, SE_AUDIT_NAME, &lPrivAudit);
    
    // 
    // Only 1 privilege to enable
    //

    TOKEN_PRIVILEGES NewPrivileges;
    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    NewPrivileges.Privileges[0].Luid = lPrivAudit;

    //
    // Now adjust the privileges in the process token
    //

    AdjustTokenPrivileges(hToken, FALSE, &NewPrivileges, 0, NULL, NULL);

    //
    // And we're done with the token handle
    //

    CloseHandle(hToken);

}
        


//
// Functions to print the test output
//

void PrintUser(const PSID psUser)
{
    DWORD i;

    for(i=0; pMailboxes[i].psUser != NULL; i++)
    {
        if(EqualSid(psUser, pMailboxes[i].psUser))
        {
            wprintf(pMailboxes[i].szName);         
            return;
        }
    }
    wprintf(L"UnknownUser");
}

void PrintPerm(ACCESS_MASK am)
{
    wprintf(L" (");

    if( am & ACCESS_MAIL_READ ) wprintf(L" Read");
    if( am & ACCESS_MAIL_WRITE ) wprintf(L" Write");
    if( am & ACCESS_MAIL_ADMIN ) wprintf(L" Admin");

    wprintf(L" ) ");
}

void PrintTest(testStruct tst)
{
    wprintf(L"[ User: ");
    PrintUser(tst.psUser);
    wprintf(L", Mailbox: ");
    PrintUser(tst.psMailbox);
    PrintPerm(tst.amAccess);

    wprintf(L"IP: %d.%d.%d.%d ]\n", (tst.dwIP >> 24) & 0x000000FF,
                                  (tst.dwIP >> 16) & 0x000000FF,
                                  (tst.dwIP >> 8)  & 0x000000FF,
                                   tst.dwIP        & 0x000000FF );

}

void PrintMultiTest(PMAILRM_MULTI_REQUEST pRequest,
               PMAILRM_MULTI_REPLY pReply,
               DWORD dwIdx)
{
    wprintf(L"[ User: ");
    PrintUser(pRequest->psUser);
    wprintf(L", Mailbox: ");
    PrintUser(pRequest->pRequestElem[dwIdx].psMailbox);
    PrintPerm(pRequest->pRequestElem[dwIdx].amAccessRequested);

    wprintf(L"IP: %d.%d.%d.%d ]\n",   (pRequest->dwIp >> 24) & 0x000000FF,
                                      (pRequest->dwIp >> 16) & 0x000000FF,
                                      (pRequest->dwIp >> 8)  & 0x000000FF,
                                       pRequest->dwIp        & 0x000000FF );


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\makesd\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <aclapi.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <guiddef.h>

#define SECURITY_WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\makesd\makesd.h ===
#pragma once

#include "pch.h"

void FreeSecurityDescriptor2(
         IN            PSECURITY_DESCRIPTOR pSd
         );

#define CREATE_SD_DACL_PRESENT 0x0001
#define CREATE_SD_SACL_PRESENT 0x0002

EXTERN_C
BOOL 
WINAPI
CreateSecurityDescriptor2(
         OUT           PSECURITY_DESCRIPTOR * ppSd,
         IN    const   DWORD dwOptions,
         IN    const   SECURITY_DESCRIPTOR_CONTROL sControl,
         IN    const   PSID  psOwner,
         IN    const   PSID  psGroup,
         IN    const   DWORD dwNumDaclAces,
         IN    const   DWORD dwNumSaclAces,
         ...
         );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\qt\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>
#include <authzi.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\samplerm\guids.c ===
#include "pch.h"

GUID Guid0 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x00}};
GUID Guid1 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x01}};
GUID Guid2 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x02}};
GUID Guid3 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x03}};
GUID Guid4 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x04}};
GUID Guid5 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x05}};
GUID Guid6 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x06}};
GUID Guid7 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x07}};
GUID Guid8 = {0x6da8a4ff, 0xe52, 0x11d0, {0xa2, 0x86, 0x00, 0xaa, 0x00, 0x30, 0x49, 0x08}};

ULONG WorldSid[] = {0x101, 0x1000000, 0};

// S-1-5-21-397955417-626881126-188441444-2791022
ULONG KedarSid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x002a966e};

// S-1-5-21-397955417-626881126-188441444-2204519
ULONG RahulSid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x0021a367};

// S-1-5-21-397955417-626881126-188441444-2101332
ULONG RobertreSid[] = {0x00000501, 0x05000000, 0x00000015, 0x17b85159, 0x255d7266, 0x0b3b6364, 0x00201054};

ULONG SpecialSid[] = {0x101, 0x2000000, 2};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\qt\main.c ===
#include "pch.h"

AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET;
UCHAR                Buffer[2048];
AUTHZ_ACCESS_REQUEST Request       = {0};
PAUTHZ_ACCESS_REPLY  pReply        = (PAUTHZ_ACCESS_REPLY) Buffer;
BOOL                 b             = TRUE;
HANDLE               hToken        = NULL;
LUID                 Luid          = {0xdead,0xbeef};
NTSTATUS             Status        = STATUS_SUCCESS;
PAUDIT_PARAMS        pParams = NULL;

PHANDLE     pThreads           = NULL;
ACCESS_MASK DesiredAccess      = 0;
DWORD       dwThreads          = 0;
DWORD       dwThreadsRemaining = 0;
DWORD       dwAuditsPerThread  = 0;
BOOL        bAudit             = 0;
DWORD       i                  = 0;

PSECURITY_DESCRIPTOR pSD      = NULL;
PWCHAR               StringSD = L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";

AUTHZ_AUDIT_EVENT_HANDLE       hAuditEvent1  = NULL;
AUTHZ_AUDIT_EVENT_HANDLE       hAuditEvent2  = NULL;
AUTHZ_RESOURCE_MANAGER_HANDLE  hRM          = NULL;
AUTHZ_CLIENT_CONTEXT_HANDLE    hCC          = NULL;
AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hAuthzCache  = NULL;
AUTHZ_AUDIT_QUEUE_HANDLE       hAAQ         = NULL;    


ULONG                      
AccessCheckAuditWork(
    LPVOID lpParameter
    )
{
    
    DWORD i   = 0;
    DWORD num = *((PDWORD)lpParameter);

    for (i = 0; i < dwAuditsPerThread; i++)
    {
        b = AuthzAccessCheck(
                0,
                hCC,
                &Request,
                hAuditEvent2,
                pSD,
                NULL,
                0,
                pReply,
                NULL
                );

        b = AuthzAccessCheck(
                0,
                hCC,
                &Request,
                hAuditEvent1,
                pSD,
                NULL,
                0,
                pReply,
                NULL
                );

    }

    InterlockedDecrement( 
        &dwThreadsRemaining
        );

    wprintf(L"Thread Done %d (%d left).\n", num, dwThreadsRemaining);
    return TRUE;
}


void _cdecl wmain(int argc, WCHAR * argv[])
{
    if (argc != 5)
    {
        wprintf(L"usage: %s AccessMask dwThreads dwAuditsPerThread bAudit\n", argv[0]);
        exit(0);
    }

    DesiredAccess      = wcstol(argv[1], NULL, 16);
    dwThreads          = wcstol(argv[2], NULL, 10);
    dwAuditsPerThread  = wcstol(argv[3], NULL, 10);
    bAudit             = wcstol(argv[4], NULL, 10);

    dwThreadsRemaining = dwThreads;

    pThreads = LocalAlloc(
                   0, 
                   sizeof(HANDLE) * dwThreads
                   );

    if (NULL == pThreads)
    {
        wprintf(L"LocalAlloc failed with %d\n", GetLastError());
        return;
    }

    //
    // Create the SD for the access checks
    //

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(
            StringSD, 
            SDDL_REVISION_1, 
            &pSD, 
            NULL
            );

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }



    //
    // Authz stuff
    //

    b = AuthzInitializeResourceManager(
            0,
            NULL,
            NULL,
            NULL,
            L"Jeff's RM",
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }
    
    b = AuthziInitializeAuditQueue(
            AUTHZ_MONITOR_AUDIT_QUEUE_SIZE,
            10000,
            500,
            NULL,
            &hAAQ
            );

    if (!b)
    {
        printf("AuthzInitializeAuditQueue failed with %d.\n", GetLastError());
        return;
    }

    b = AuthziInitializeAuditEventType(
            0,
            SE_CATEGID_OBJECT_ACCESS,
            777,
            1,
            &hAET
            );

    if (!b)
    {
        wprintf(L"initaet returned %d\n", GetLastError());
        return;
    }

    b = AuthziAllocateAuditParams(
            &pParams,
            1
            );

    AuthziInitializeAuditParamsWithRM(
        0,
        hRM,
        1,
        pParams,
        APT_String, L"Hello???"
        );

    b = AuthziInitializeAuditEvent(
            AUTHZ_NO_ALLOC_STRINGS,
            hRM,
            hAET, //NULL,     // event
            pParams, //NULL,     // params
            hAAQ,     // queue
            INFINITE, // timeout
            L"op type",
            L"object type",
            L"object name",
            L"some additional info",
            &hAuditEvent2
            );

    b = AuthziInitializeAuditEvent(
            0,
            hRM,
            NULL,     // event
            NULL,     // params
            NULL,     // queue
            INFINITE, // timeout
            L"op type1",
            L"object type1",
            L"object name1",
            L"some additional info1",
            &hAuditEvent1
            );
    if (!b)
    {
        printf("AuthzInitializeAuditInfo failed with %d.\n", GetLastError());
        return;
    }

    //
    // Create a client context from the current token.
    //

    OpenProcessToken( 
        GetCurrentProcess(), 
        TOKEN_QUERY, 
        &hToken
        );

    b = AuthzInitializeContextFromToken(
            0,
            hToken,
            hRM,
            NULL,
            Luid,
            NULL,
            &hCC
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeContextFromToken failed with 0x%x\n", GetLastError());
        return;
    }            

    //
    // Now do the access check.
    //

    Request.ObjectTypeList = NULL;
    Request.PrincipalSelfSid = NULL;
    Request.DesiredAccess = DesiredAccess;

    pReply->ResultListLength = 1;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);
    pReply->SaclEvaluationResults = (PDWORD) (pReply->GrantedAccessMask + (pReply->ResultListLength * sizeof(ACCESS_MASK)));

    wprintf(L"* AccessCheck (PrincipalSelfSid == NULL, ResultListLength == 8)\n");
    
    b = AuthzAccessCheck(
            0,
            hCC,
            &Request,
            NULL,
            pSD,
            NULL,
            0,
            pReply,
            &hAuthzCache
            );

    if (!b)
    {
        wprintf(L"Initial AuthzAccessCheck failed with %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"Initial AuthzAccessCheck succeeded.  Here are results:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"ObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    wprintf(L"\nBeginning creation of audit threads.\n");

    for (i = 0; i < dwThreads; i++)
    {
        pThreads[i] = CreateThread(
                          NULL,
                          0,
                          AccessCheckAuditWork,
                          &i,
                          CREATE_SUSPENDED,
                          NULL
                          );
        
        if (pThreads[i] == NULL)
        {
            wprintf(L"CreateThread failed for thread %d with %d\n", i, GetLastError());
            return;
        }
    }

    for (i = 0; i < dwThreads; i++)
    {
        if (-1 == ResumeThread(
                      pThreads[i]
                      ))
        {
            wprintf(L"ResumeThread failed on thread %d with %d\n", i, GetLastError());
            fflush(stdout);
        }
    }

    Status = WaitForMultipleObjects(
                i, 
                pThreads, 
                TRUE, 
                INFINITE
                );

    if (!NT_SUCCESS(Status))
    {
        wprintf(L"Wait failed %d.\n", GetLastError());
    }

    wprintf(L"Done waiting for all threads.\n");
    
    AuthzFreeAuditEvent(
        hAuditEvent2
        );

    AuthziFreeAuditQueue(hAAQ);

    AuthzFreeContext(hCC);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\samplerm\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>
#include "samplerm.h"

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\stress\ac\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\stress\ai\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\samplerm\main.c ===
#include "pch.h"
#include "samplerm.h"



void _cdecl wmain( int argc, WCHAR * argv[] )
{
    NTSTATUS Status = STATUS_SUCCESS;

    BOOL b = TRUE;
    DWORD DesiredAccess;
    DWORD Callback;
    DWORD Iteration;

    AUTHZ_RESOURCE_MANAGER_HANDLE hRM = NULL;
    HANDLE hToken = NULL;
    LUID luid = {0xdead,0xbeef};
    AUTHZ_CLIENT_CONTEXT_HANDLE hCC1 = NULL;
    AUTHZ_CLIENT_CONTEXT_HANDLE hCC2 = NULL;
    AUTHZ_CLIENT_CONTEXT_HANDLE hCC3 = NULL;
    AUTHZ_ACCESS_REQUEST Request;
    PAUTHZ_ACCESS_REPLY pReply = (PAUTHZ_ACCESS_REPLY) Buffer;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwErr;
    ULONG i = 0, jj = 0;
    PACE_HEADER Ace = NULL;
    DWORD AceCount = 0;
    DWORD Len = 0;
    SID_AND_ATTRIBUTES SidAttr[1];
    AUTHZ_AUDIT_INFO_HANDLE hAuditInfo = NULL;
    AUTHZ_RM_AUDIT_INFO_HANDLE hRmAuditInfo;
    PAUDIT_PARAMS pAuditParams;

    AUTHZ_HANDLE AuthHandle = 0;
    PACL pAcl = NULL;
    AUDIT_EVENT_INFO AuditEventInfo;
    PSID pUserSid = NULL;
    AUTHZ_AUDIT_QUEUE_HANDLE hQueue;

    PWCHAR StringSD = L"O:BAG:DUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";
    //PWCHAR StringSD = L"O:BAG:DUD:(A;;0x100;;;SY)(A;;0x100;;;PS)S:(AU;IDSA;SD;;;DU)";

    if (argc != 4)
    {
        wprintf(L"usage: %s access iter [callback]\n", argv[0]);
        exit(0);
    }


    DesiredAccess = wcstol(argv[1], NULL, 16);
    Iteration = wcstol(argv[2], NULL, 16);
    Callback = wcstol(argv[3], NULL, 16);

    //
    // Create the SD for the access checks
    //

    b = ConvertStringSecurityDescriptorToSecurityDescriptorW(StringSD, SDDL_REVISION_1, &pSD, NULL);

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }

    //
    // If Callback aces are specified, change the DACL to use them
    //

    if (Callback)
    {
        pAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD);
        AceCount = pAcl->AceCount;
        
        for (i = 0, Ace = FirstAce(pAcl); i < AceCount; i++, Ace = NextAce(Ace))
        {
            switch(Ace->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                Ace->AceType = ACCESS_ALLOWED_CALLBACK_ACE_TYPE;
                break;
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                Ace->AceType = ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE;
                break;
            }
        }
    }


    AuditEventInfo.Version                 = AUDIT_TYPE_LEGACY;
    AuditEventInfo.u.Legacy.CategoryId     = SE_CATEGID_OBJECT_ACCESS;
    AuditEventInfo.u.Legacy.AuditId        = SE_AUDITID_OBJECT_OPERATION;
    AuditEventInfo.u.Legacy.ParameterCount = 11;

    b = AuthzInitializeAuditQueue(
        &hQueue,
        0,
        1000,
        100,
        NULL
        );

    if (!b)
    {
        wprintf(L"authzinitauditqueueueueue %d\n", GetLastError());
        return;
    }

    if (!b)
    {
        printf("AuthzAllocInitRmAuditInfoHandle FAILED.\n");
        return;
    }

    b = AuthzInitializeResourceManager(
            MyAccessCheck,
            MyComputeDynamicGroups,
            MyFreeDynamicGroups,
            L"some rm",
            0,                          // Flags
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

//     AuthzInitializeAuditParamsWithRM(
//         &pAuditParams,
//         hRM,
//         APF_AuditSuccess,
//         1,
//         APT_String, L"Jeff operation"
//         );
//
//
    b = AuthzInitializeAuditInfo(
            &hAuditInfo,
            0,
            hRM,
            &AuditEventInfo,
            NULL,//pAuditParams,
            hQueue,
            INFINITE,
            L"Cleaning",
            L"Toothbrush",
            L"Oral B",
            L"Rinse after brushing."
            );
    
    if (!b)
    {
        printf("AuthzInitAuditInfo FAILED with %d.\n", GetLastError());
        return;
    }

    OpenProcessToken( 
        GetCurrentProcess(), 
        TOKEN_QUERY, 
        &hToken
        );

    b = AuthzInitializeContextFromToken(
            hToken,
            hRM,
            NULL,
            luid,
            0,
            NULL,
            &hCC1
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeContextFromSid failed with 0x%x\n", GetLastError());
        return;
    }

    Request.ObjectTypeList = (POBJECT_TYPE_LIST) TypeListBuffer;
    Request.ObjectTypeList[0].Level = 0;
    Request.ObjectTypeList[0].ObjectType = &Guid0;
    Request.ObjectTypeList[0].Sbz = 0;
    Request.ObjectTypeListLength = 1;
    Request.OptionalArguments = NULL;
    Request.PrincipalSelfSid = NULL;
    Request.DesiredAccess = 0x100;

    //
    // The ResultListLength is set to the number of ObjectType GUIDs in the Request, indicating
    // that the caller would like detailed information about granted access to each node in the
    // tree.
    //
    RtlZeroMemory(Buffer, sizeof(Buffer));
    pReply->ResultListLength = 1;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);


    wprintf(L"* AccessCheck (PSS == NULL, ResultListLength == 1 with cache handle)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandle
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    AuthzFreeAuditInfo(hAuditInfo);
    AuthzFreeAuditQueue(hQueue);
    return;

    RtlZeroMemory(Buffer, sizeof(Buffer));
    pReply->ResultListLength = 1;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);

    wprintf(L"* AccessCheck (PSS == NULL, ResultListLength == 1 without cache handle)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            NULL
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }

    AuthzFreeAuditParams(pAuditParams);

    Request.ObjectTypeList = (POBJECT_TYPE_LIST) TypeListBuffer;

    Request.ObjectTypeList[0].Level = 0;
    Request.ObjectTypeList[0].ObjectType = &Guid0;
    Request.ObjectTypeList[0].Sbz = 0;

    Request.ObjectTypeList[1].Level = 1;
    Request.ObjectTypeList[1].ObjectType = &Guid1;
    Request.ObjectTypeList[1].Sbz = 0;

    Request.ObjectTypeList[2].Level = 2;
    Request.ObjectTypeList[2].ObjectType = &Guid2;
    Request.ObjectTypeList[2].Sbz = 0;

    Request.ObjectTypeList[3].Level = 2;
    Request.ObjectTypeList[3].ObjectType = &Guid3;
    Request.ObjectTypeList[3].Sbz = 0;

    Request.ObjectTypeList[4].Level = 1;
    Request.ObjectTypeList[4].ObjectType = &Guid4;
    Request.ObjectTypeList[4].Sbz = 0;

    Request.ObjectTypeList[5].Level = 2;
    Request.ObjectTypeList[5].ObjectType = &Guid5;
    Request.ObjectTypeList[5].Sbz = 0;

    Request.ObjectTypeList[6].Level = 3;
    Request.ObjectTypeList[6].ObjectType = &Guid6;
    Request.ObjectTypeList[6].Sbz = 0;

    Request.ObjectTypeList[7].Level = 2;
    Request.ObjectTypeList[7].ObjectType = &Guid7;
    Request.ObjectTypeList[7].Sbz = 0;

    Request.ObjectTypeListLength = 8;
    Request.OptionalArguments = NULL;

    Request.PrincipalSelfSid = NULL;
    Request.DesiredAccess = DesiredAccess;

    //
    // The ResultListLength is set to the number of ObjectType GUIDs in the Request, indicating
    // that the caller would like detailed information about granted access to each node in the
    // tree.
    //

    pReply->ResultListLength = 8;
    pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
    pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);

    wprintf(L"* AccessCheck (PrincipalSelfSid == NULL, ResultListLength == 8)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandle
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }


    //
    // In the original AuthzAccessCheck call, we passed in a handle to store caching information.  Now we
    // can use this handle to perform an AccessCheck on the same object.
    //

    if (AuthHandle)
    {
        wprintf(L"* Cached AccessCheck (PrincipalSelfSid == NULL, ResultListLength = 8)\n");
        b = AuthzCachedAccessCheck(
                AuthHandle,
                &Request,
                hAuditInfo,
                pReply
                );

        if (!b)
        {
            wprintf(L"\tFailed. LastError = %d\n", GetLastError());
            return;
        }
        else
        {
            wprintf(L"\tSucceeded.  Granted Access Masks:\n");

            for (i = 0; i < pReply->ResultListLength; i++)
            {
                wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                        i, pReply->GrantedAccessMask[i], pReply->Error[i]);
            }
        }

        //
        // Since we will no longer use this caching handle, free it.
        //

        AuthzFreeHandle(AuthHandle);
    }
    else
    {
        wprintf(L"No CachedAccessCheck done since NULL = AuthHandle\n");
    }

    //
    // We set the PrincipalSelfSid in the Request, and leave all other parameters the same.
    //

    Request.PrincipalSelfSid = (PSID) KedarSid;

    wprintf(L"* AccessCheck (PrincipalSelfSid == Kedard, ResultListLength == 8)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            &AuthHandle
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }
               
    //
    // Use our caching handle to perform the same AccessCheck with speed.
    //

    if (AuthHandle)
    {
        wprintf(L"* Cached AccessCheck (PrincipalSelfSid == Kedard, ResultListLength = 8)\n");
        b = AuthzCachedAccessCheck(
                AuthHandle,
                &Request,
                hAuditInfo,
                pReply
                );

        if (!b)
        {
            wprintf(L"\tFailed. LastError = %d\n", GetLastError());
            return;
        }
        else
        {
            wprintf(L"\tSucceeded.  Granted Access Masks:\n");

            for (i = 0; i < pReply->ResultListLength; i++)
            {
                wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                        i, pReply->GrantedAccessMask[i], pReply->Error[i]);
            }
        }

        //
        // Free the handle, since it will not be used again.
        //
        
        AuthzFreeHandle(AuthHandle);
    }
    else
    {
        wprintf(L"No CachedAccessCheck done since NULL = AuthHandle\n");
    }


    //
    // Set the ResultListLength to 1, indicating that we do not care about the results
    // of the AccessCheck at the individual nodes in the tree.  Rather, we care about
    // our permissions to the entire tree.  The returned access indicates if we have 
    // access to the whole thing.
    //

    pReply->ResultListLength = 1;

    wprintf(L"* AccessCheck (PrincipalSelfSid == Kedard, ResultListLength == 1)\n");
    b = AuthzAccessCheck(
            hCC1,
            &Request,
            hAuditInfo,
            pSD,
            NULL,
            0,
            pReply,
            NULL
            );

    if (!b)
    {
        wprintf(L"\tFailed. LastError = %d\n", GetLastError());
        return;
    }
    else
    {
        wprintf(L"\tSucceeded.  Granted Access Masks:\n");

        for (i = 0; i < pReply->ResultListLength; i++)
        {
            wprintf(L"\t\tObjectType %d :: AccessMask = 0x%x, Error = %d\n",
                    i, pReply->GrantedAccessMask[i], pReply->Error[i]);
        }
    }
    
//     for (i = 0; i < 10; i ++)
//     {
//        AuthzOpenObjectAuditAlarm(
//            hCC1,
//            &Request,
//            hAuditInfo,
//            pSD,
//            NULL,
//            0,
//            pReply
//            );
//
//        if (!b)
//        {
//            wprintf(L"AuthzOpenObjectAuditAlarm failed with %d\n", GetLastError);
//        }
//     }
    
    //
    // Free the RM auditing data before exiting.  This call is importants, as it also waits on 
    // threads used by the Authzs auditing component to complete.
    //

    //AuthzFreeRmAuditInfoHandle(hRmAuditInfo);
    
    //
    // Free the contexts that the RM created.
    //

    AuthzFreeContext(hCC1);
    AuthzFreeAuditQueue(hQueue);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\stress\logq\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>
#include <authzi.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\stress\rm\pch.h ===
#pragma once

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntlsa.h>
#include <msaudite.h>
#include <rpc.h>
#include <msobjs.h>
#include <aclapi.h>
#include <dsgetdc.h>
#include <objbase.h>
#include <iads.h>
#include <lm.h>
#include <winldap.h>
#include <shlobj.h>
#include <dsclient.h>
#include <ntdsapi.h>
#include <winbase.h>
#include <ntsam.h>
#include <sddl.h>
#include <seopaque.h>
#include <sertlp.h>
#include <authz.h>

#define SECURITY_WIN32

#include "sspi.h"
#include "secint.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\samplerm\samplerm.c ===
#include "pch.h"

BOOL
MyAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    )

/*++

    Routine Description
    
        This is a very trivial example of a callback access check routine.  Here we randomly decide 
        if the ACE applies to the given client context.  
        
    Arguments
    
        hAuthzClientContext - handle to AuthzClientContext.
        pAce - pointer to Ace header.
        pArgs - optional arguments that can be used in evaluating the ACE.  
        pbAceApplicable - returns the result of the evaluation.

    Return value
    
        Bool, true if ACE is applicable, false otherwise.
--*/
{
    *pbAceApplicable = (BOOL) rand() % 2;

    return TRUE;
}

BOOL
MyComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE hAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    )

/*++

    Routine Description
    
        Resource manager callback to compute dynamic groups.  This is used by the RM
        to decide if the specified client context should be included in any RM defined groups.
        
    Arguments
    
        hAuthzClientContext - handle to client context.
        Args - optional parameter to pass information for evaluating group membership.
        pSidAttrArray - computed group membership SIDs
        pSidCount - count of SIDs
        pRestrictedSidAttrArray - computed group membership restricted SIDs
        pRestrictedSidCount - count of restricted SIDs
        
    Return Value 
        
        Bool, true for success, false on failure.

--*/    
{
    ULONG Length = 0;

    if (Args == -1)
    {
        return TRUE;
    }

    *pSidCount = 2;
    *pRestrictedSidCount = 0;

    *pRestrictedSidAttrArray = 0;

    Length = RtlLengthSid((PSID) KedarSid);
    Length += RtlLengthSid((PSID) RahulSid);

    if (!(*pSidAttrArray = malloc(sizeof(SID_AND_ATTRIBUTES) * 2 + Length)))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    (*pSidAttrArray)[0].Attributes = SE_GROUP_ENABLED;
    (*pSidAttrArray)[0].Sid = ((PUCHAR) (*pSidAttrArray)) + 2 * sizeof(SID_AND_ATTRIBUTES);
    RtlCopySid(Length/2, (*pSidAttrArray)[0].Sid, (PSID) KedarSid);

    (*pSidAttrArray)[1].Attributes = SE_GROUP_USE_FOR_DENY_ONLY;
    (*pSidAttrArray)[1].Sid = ((PUCHAR) (*pSidAttrArray)) + 2 * sizeof(SID_AND_ATTRIBUTES) + Length/2;
    RtlCopySid(Length/2, (*pSidAttrArray)[1].Sid, (PSID) RahulSid);

    return TRUE;
}

VOID
MyFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    )

/*++

    Routine Description
    
        Frees memory allocated for the dynamic group array.

    Arguments
    
        pSidAttrArray - array to free.
    
    Return Value
        None.                       
--*/        
{
    if (pSidAttrArray) free(pSidAttrArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\stress\ai\main.c ===
#include "pch.h"


void _cdecl wmain(int argc, WCHAR * argv[])
{
    LONG                          i          = 0;
    LONG                          Iterations = 0;
    BOOL                          b          = TRUE;
    AUTHZ_AUDIT_INFO_HANDLE       hAAI       = NULL;
    AUTHZ_RESOURCE_MANAGER_HANDLE hRM        = NULL;

    if (argc != 2)
    {
        wprintf(L"usage: %s iterations\n", argv[0]);
        exit(0);
    }

    Iterations = wcstol(argv[1], NULL, 10);

    wprintf(L"AI Stress.  Init / Free AI for %d iters.  Press a key to start.\n", Iterations);
    getchar();

    b = AuthzInitializeResourceManager(
            NULL,
            NULL,
            NULL,
            L"Jeff's RM",
            0,            // Flags
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

    for (i = 0; i < Iterations; i++)
    {
        b = AuthzInitializeAuditInfo(
                &hAAI,
                0,
                hRM,
                NULL,
                NULL,
                NULL,
                INFINITE,
                L"",
                L"",
                L"",
                L""
                );

        if (!b)
        {
            wprintf(L"AuthzInitializeAuditInfo failed with %d\n", GetLastError());
            return;
        }

        b = AuthzFreeAuditInfo(
                hAAI
                );
    
        if (!b)
        {
            wprintf(L"AuthzFreeAuditInfo failed with %d\n", GetLastError());
            return;
        }
    }

    b = AuthzFreeResourceManager(
            hRM
            );

    if (!b)
    {
        wprintf(L"AuthzFreeResourceManager failed with %d\n", GetLastError());
        return;
    }

    wprintf(L"Done.  Press a key.\n");
    getchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\samplerm\samplerm.h ===
#pragma once

extern GUID Guid0;
extern GUID Guid1;
extern GUID Guid2;
extern GUID Guid3;
extern GUID Guid4;
extern GUID Guid5;
extern GUID Guid6;
extern GUID Guid7;
extern GUID Guid8;

extern ULONG WorldSid[];
extern ULONG KedarSid[];
extern ULONG RahulSid[];
extern ULONG RobertreSid[];
extern ULONG SpecialSid[];

#define BUFFERMAX 1024
#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))
#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

CHAR Buffer[BUFFERMAX];
CHAR TypeListBuffer[BUFFERMAX];

BOOL
MyAccessCheck(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PACE_HEADER pAce,
    IN PVOID pArgs OPTIONAL,
    IN OUT PBOOL pbAceApplicable
    );

BOOL
MyComputeDynamicGroups(
    IN AUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext,
    IN PVOID Args,
    OUT PSID_AND_ATTRIBUTES *pSidAttrArray,
    OUT PDWORD pSidCount,
    OUT PSID_AND_ATTRIBUTES *pRestrictedSidAttrArray,
    OUT PDWORD pRestrictedSidCount
    );

VOID
MyFreeDynamicGroups (
    IN PSID_AND_ATTRIBUTES pSidAttrArray
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\stress\logq\main.c ===
#include "pch.h"


void _cdecl wmain(int argc, WCHAR * argv[])
{
    AUTHZ_RESOURCE_MANAGER_HANDLE hRM         = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hAE         = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET        = NULL;
    LONG                          i           = 0;
    LONG                          Iterations  = 0;
    BOOL                          b           = TRUE;
    PAUDIT_PARAMS                 pParams     = NULL;

    b = AuthzInitializeResourceManager(
            0,
            NULL,
            NULL,
            NULL,
            L"3rd Party",
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

#define SE_AUDITID_THIRD_PARTY_AUDIT 0x259
    b = AuthziInitializeAuditEventType(
            0,
            SE_CATEGID_DETAILED_TRACKING,
            SE_AUDITID_THIRD_PARTY_AUDIT,
            2,
            &hAET
            );

    if (!b)
    {
        wprintf(L"AuthziInitializeAuditEventType failed with %d\n", GetLastError());
        return;
    }

    b = AuthziAllocateAuditParams(
            &pParams,
            2
            );

    if (!b)
    {
        wprintf(L"AuthzAllocateAuditParams failed with %d\n", GetLastError());
    }

    b = AuthziInitializeAuditParamsWithRM(
            0,
            hRM,
            2,
            pParams,
            APT_String, L"I am the 3rd Party, and the next param is a number.",
            APT_Ulong,  5
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeAuditParamsWithRM failed with %d\n", GetLastError());
    }

    b = AuthziInitializeAuditEvent(
            0,
            hRM,
            hAET,
            pParams,
            NULL,
            INFINITE,
            L"",
            L"",
            L"",
            L"",
            &hAE
            );

    if (!b)
    {
        wprintf(L"AuthziInitializeAuditEvent failed with %d\n", GetLastError());
        return;
    }

    for (i = 0; i < 1000; i++)
    {
    b = AuthziLogAuditEvent(
            0,
            hAE,
            NULL
            );

    if (!b)
    {
        wprintf(L"AuthzLogAuditEvent (no queue) failed with %d\n", GetLastError());
    }
    }

    b = AuthzFreeAuditEvent(
            hAE
            );

    if (!b)
    {
        wprintf(L"AuthziFreeAuditEvent failed with %d\n", GetLastError());
        return;
    }

    b = AuthziFreeAuditEventType(
            hAET
            );

    if (!b)
    {
        wprintf(L"AuthziFreeAuditEventType failed with %d\n", GetLastError());
        return;
    }
    b = AuthziFreeAuditParams(
            pParams
            );

    if (!b)
    {
        wprintf(L"AuthziFreeAuditParams failed with %d\n", GetLastError());
        return;
    }

    b = AuthzFreeResourceManager(
            hRM
            );

    if (!b)
    {
        wprintf(L"AuthzFreeResourceManager failed with %d\n", GetLastError());
        return;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\stress\ac\main.c ===
#include "pch.h"
#include <authzi.h>

PSID pSid = NULL;


void _cdecl wmain(int argc, WCHAR * argv[])
{
    LONG                          i           = 0;
    LONG                          ii          = 0;
    LONG                          j           = 0;
    LONG                          Iterations  = 0;
    BOOL                          b           = TRUE;
    AUTHZ_AUDIT_EVENT_HANDLE      hAAI1       = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hAAI2       = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hOA         = NULL;
    AUTHZ_RESOURCE_MANAGER_HANDLE hRM         = NULL;
    AUTHZ_AUDIT_QUEUE_HANDLE      hAAQ        = NULL;
    AUTHZ_CLIENT_CONTEXT_HANDLE   hCC         = NULL;
    PSECURITY_DESCRIPTOR          pSD         = NULL;
    PSECURITY_DESCRIPTOR          pSD2         = NULL;
    PSECURITY_DESCRIPTOR          pASD[2];
    PWCHAR                        StringSD    = L"O:BAG:BUD:(A;;0x40;;;s-1-2-2)(A;;0x1;;;BA)(OA;;0x2;6da8a4ff-0e52-11d0-a286-00aa00304900;;BA)(OA;;0x4;6da8a4ff-0e52-11d0-a286-00aa00304901;;BA)(OA;;0x8;6da8a4ff-0e52-11d0-a286-00aa00304903;;AU)(OA;;0x10;6da8a4ff-0e52-11d0-a286-00aa00304904;;BU)(OA;;0x20;6da8a4ff-0e52-11d0-a286-00aa00304905;;AU)(A;;0x40;;;PS)S:(AU;IDSAFA;0xFFFFFF;;;WD)";
    HANDLE                        hToken      = NULL;
    UCHAR                         Buffer[256];
    AUTHZ_ACCESS_REQUEST          Request     = {0};
    PAUTHZ_ACCESS_REPLY           pReply      = (PAUTHZ_ACCESS_REPLY) Buffer;
    LUID                          Luid        = {0xdead,0xbeef};
    PAUDIT_PARAMS                 pParams     = NULL;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE pAEI        = NULL;
    AUTHZ_ACCESS_CHECK_RESULTS_HANDLE hCache = NULL;
    
    if (argc != 2)
    {
        wprintf(L"usage: %s iterations\n", argv[0]);
        exit(0);
    }

    Iterations = wcstol(argv[1], NULL, 10);

    wprintf(L"Log Stress with queues.  Default and specific queue each with %d audits.  Press a key to start.\n", Iterations);
    getchar();

    if (!b)
    {
        wprintf(L"SDDL failed with %d\n", GetLastError());
        return;
    }

    b = AuthzInitializeResourceManager(
            0,
            NULL,
            NULL,
            NULL,
            L"Jeff's RM",
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

    //
    // Create a client context from the current token.
    //

    OpenProcessToken( 
        GetCurrentProcess(), 
        TOKEN_QUERY, 
        &hToken
        );

    b = AuthzInitializeContextFromToken(
            0,
            hToken,
            hRM,
            NULL,
            Luid,
            NULL,
            &hCC
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeContextFromToken failed with 0x%x\n", GetLastError());
        return;
    }            

    for (i = 0; i < Iterations; i++)
    {

        //
        // Create the SD for the access checks
        //

        b = ConvertStringSecurityDescriptorToSecurityDescriptorW(
                StringSD, 
                SDDL_REVISION_1, 
                &pSD, 
                NULL
                );

        pASD[0] = pSD;
        pASD[1] = pSD;

        AuthzInitializeObjectAccessAuditEvent(
            0,
            NULL,
            L"op",
            L"object type",
            L"object name",
            L"info",
            &hOA,
            0
            );
              
        if (!b)
        {
            wprintf(L"AuthzInitializeObjectAccessAuditEvent failed with %d\n", GetLastError());
            return;
        }

        b = AuthziInitializeAuditEvent(
                AUTHZ_NO_ALLOC_STRINGS | AUTHZ_DS_CATEGORY_FLAG,
                hRM,
                NULL,
                NULL,
                NULL,
                INFINITE,
                L"This is with the default RM queue.",
                L"This is with the default RM queue.",
                L"This is with the default RM queue.",
                L"This is with the default RM queue.",
                &hAAI1
                );

        if (!b)
        {
            wprintf(L"AuthzInitializeAuditInfo (no queue) failed with %d\n", GetLastError());
            return;
        }

        b = AuthziInitializeAuditQueue(
                AUTHZ_MONITOR_AUDIT_QUEUE_SIZE,
                1000,
                100,
                NULL,
                &hAAQ
                );

        if (!b)
        {
            wprintf(L"AuthziInitializeAuditQueue failed with %d\n", GetLastError());
            return;
        }

        b = AuthziAllocateAuditParams(
                &pParams,
                1
                );

        if (!b)
        {
            wprintf(L"AuthzAllocateAuditParams failed with %d\n", GetLastError());
        }

        b = AuthziInitializeAuditParams(
                0,
                pParams,
                &pSid,
                L"foo",
                1,
                APT_String, L"This audit was with a custom AUDIT_EVENT_INFO, AUDIT_PARAMS, and queue."
                );

//         b = AuthziInitializeAuditParamsWithRM(
//                 0,
//                 hRM,
//                 1,
//                 pParams,
//                 APT_String, L"This audit was with a custom AUDIT_EVENT_INFO, AUDIT_PARAMS, and queue."
//                 );

        if (!b)
        {
            wprintf(L"AuthzInitializeAuditParamsWithRM failed with %d\n", GetLastError());
        }

        b = AuthziInitializeAuditEventType(
                0,
                SE_CATEGID_OBJECT_ACCESS,
                567,
                1,
                &pAEI
                );

        if (!b)
        {
            wprintf(L"AuthzInitializeAuditEvent failed with %d\n", GetLastError());
        }

        b = AuthziInitializeAuditEvent(
                AUTHZ_NO_RM_AUDIT,
                NULL, //hRM,
                pAEI,
                pParams,
                NULL,
                INFINITE,
                L"This is with a specific queue and params.",
                L"This is with a specific queue and params.",
                L"This is with a specific queue and params.",
                L"This is with a specific queue and params.",
                &hAAI2
                );

        if (!b)
        {
            wprintf(L"AuthziInitializeAuditEvent (with queue) failed with %d\n", GetLastError());
            return;
        }

        for (ii = 0; ii < 100; ii++)
        {
           b = AuthziLogAuditEvent(
                0,
                hAAI2,
                NULL
                );
           if (!b)
           {
               wprintf(L"log failed with %d \n", GetLastError());
               return;
           }

        }
        Request.ObjectTypeList = NULL;
        Request.PrincipalSelfSid = NULL;
        Request.DesiredAccess = MAXIMUM_ALLOWED;

        pReply->ResultListLength = 1;
        pReply->Error = (PDWORD) (((PCHAR) pReply) + sizeof(AUTHZ_ACCESS_REPLY));
        pReply->GrantedAccessMask = (PACCESS_MASK) (pReply->Error + pReply->ResultListLength);
        pReply->SaclEvaluationResults = (PDWORD) pReply->GrantedAccessMask + (sizeof(ACCESS_MASK) * pReply->ResultListLength);


        b = AuthzAccessCheck(
                0,
                hCC,
                &Request,
                hOA,
                pSD,
                pASD,
                2,
                pReply,
                &hCache
                );

        if (!b)
        {
            wprintf(L"AuthzAccessCheck (with queue) failed with %d\n", GetLastError());
            return;
        }

        pSD2 = pSD;
        pSD = NULL;

        for (j = 0; j < 100; j++)
        {

            b = AuthzCachedAccessCheck(
                    0,
                    hCache,
                    &Request,
                    hOA,
                    pReply
                    );
            b = AuthzCachedAccessCheck(
                    0,
                    hCache,
                    &Request,
                    hAAI1,
                    pReply
                    );
            b = AuthzCachedAccessCheck(
                    0,
                    hCache,
                    &Request,
                    hAAI1,
                    pReply
                    );

            if (!b)
            {
                wprintf(L"CachedAuthzAccessCheck (no queue) failed with %d\n", GetLastError());
                return;
            }
        }
        
        b = AuthzFreeAuditEvent(
                hAAI2
                );

        b = AuthzFreeAuditEvent(
                hAAI1
                );
        
        b = AuthzFreeAuditEvent(
                hOA
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditInfo (no queue) failed with %d\n", GetLastError());
            return;
        }

        b = AuthziFreeAuditEventType(
                pAEI
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditEventType failed with %d\n", GetLastError());
            return;
        }

        b = AuthziFreeAuditParams(
                pParams
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditParams failed with %d\n", GetLastError());
            return;
        }

        b = AuthziFreeAuditQueue(
                hAAQ
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditQueue failed with %d\n", GetLastError());
            return;
        }

        b = AuthzFreeHandle(
                hCache
                );

        if (!b)
        {
            wprintf(L"AuthzFreeHandle failed with %d\n", GetLastError());
            return;
        }
    }
    
    b = AuthzFreeContext(
            hCC
            );

    if (!b)
    {
        wprintf(L"AuthzFreeContext failed with %d\n", GetLastError());
        return;
    }

    b = AuthzFreeResourceManager(
            hRM
            );

    if (!b)
    {
        wprintf(L"AuthzFreeResourceManager failed with %d\n", GetLastError());
        return;
    }

    wprintf(L"Done.  Press a key.\n");
    getchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\wmiaudit\adtdef.h ===
#ifndef _ADTDEF_H_
#define _ADTDEF_H_

//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T D E F . H
//
// Contents:    Audit related defs
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------


#define NYI FALSE

#define AdtWMINameSpace L"root\\default"

// typedef enum tag_CIMTYPE
//     {
//         CIM_ILLEGAL	= 0xfff,
//         CIM_EMPTY	= 0,
//         CIM_SINT8	= 16,
//         CIM_UINT8	= 17,
//         CIM_SINT16	= 2,
//         CIM_UINT16	= 18,
//         CIM_SINT32	= 3,
//         CIM_UINT32	= 19,
//         CIM_SINT64	= 20,
//         CIM_UINT64	= 21,
//         CIM_REAL32	= 4,
//         CIM_REAL64	= 5,
//         CIM_BOOLEAN	= 11,
//         CIM_STRING	= 8,
//         CIM_DATETIME	= 101,
//         CIM_REFERENCE	= 102,
//         CIM_CHAR16	= 103,
//         CIM_OBJECT	= 13,
//         CIM_FLAG_ARRAY	= 0x2000
//     }	CIMTYPE;

//typedef ULONG WMITYPE;

#endif // _ADTDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\stress\rm\main.c ===
#include "pch.h"
#include "\nt\public\internal\ds\inc\authzi.h"


void _cdecl wmain(int argc, WCHAR * argv[])
{
    LONG                          i          = 0;
    LONG                          j          = 0;
    LONG                          Iterations = 0;
    BOOL                          b          = TRUE;
    AUTHZ_AUDIT_EVENT_TYPE_HANDLE hAET       = NULL;
    AUTHZ_AUDIT_EVENT_HANDLE      hAE        = NULL;
    AUTHZ_RESOURCE_MANAGER_HANDLE hRM        = NULL;

    if (argc != 2)
    {
        wprintf(L"usage: %s iterations\n", argv[0]);
        exit(0);
    }

    Iterations = wcstol(argv[1], NULL, 10);

    wprintf(L"RM Stress.  Init / Free RM for %d iters.  Press a key to start.\n", Iterations);
    getchar();

    b = AuthzInitializeResourceManager(
            0,            // Flags
            NULL,
            NULL,
            NULL,
            L"Jeff's RM",
            &hRM
            );

    if (!b)
    {
        wprintf(L"AuthzInitializeResourceManager failed with %d\n", GetLastError());
        return;
    }

    for (i = 0; i < Iterations; i++)
    {

        b = AuthziInitializeAuditEventType(
                0,
                3,
                666,
                1,
                &hAET
                );

        if (!b)
        {
            wprintf(L"AuthziInitializeAuditEventType failed with %d\n", GetLastError());
            return;
        }

        b = AuthziInitializeAuditEvent(
                0,
                hRM,
                hAET,
                NULL,
                NULL,
                INFINITE,
                L"foo",
                L"foo",
                L"foo",
                L"foo",
                &hAE
                );

        if (!b)
        {
            wprintf(L"AuthziInitializeAuditEvent failed with %d\n", GetLastError());
            return;
        }

//         for (j = 0; j < 100; j++)
//         {
//             b = AuthziLogAuditEvent(
//                     0,
//                     hAE,
//                     NULL
//                     );
//         }

        b = AuthzFreeAuditEvent(
                hAE
                );

        if (!b)
        {
            wprintf(L"AuthzFreeAuditEvent failed with %d\n", GetLastError());
            return;
        }

        b = AuthziFreeAuditEventType(
                hAET
                );

        if (!b)
        {
            wprintf(L"AuthziFreeAuditEventType failed with %d\n", GetLastError());
            return;
        }

    }

    b = AuthzFreeResourceManager(
            hRM
            );

    if (!b)
    {
        wprintf(L"AuthzFreeResourceManager failed with %d\n", GetLastError());
        return;
    }
    wprintf(L"Done.  Press a key.\n");
    getchar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\wmiaudit\wmi-azaudit.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A Z E V E N T . C P P
//
// Contents:    Functions to construct and report Authz audit event
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

/*
  - how to create an event buffer without creating hEventSource?

  - need to protect rm->hAuditEvent using a critsec

 */

#include "pch.h"
#pragma hdrstop

// #include <nt.h>
// #include <ntrtl.h>
// #include <nturtl.h>

// #include <windows.h>
// #include <msaudite.h>

#include "authzp.h"

#include "adtdef.h"
//#include "p2prov.h"
#include "ncevent.h"
#include "azaudit.h"


// static AzAuditInfoInternal g_RmAuditInfo;

HRESULT WINAPI AuthzEventSourceCallback(
    HANDLE hEventSource,
    EVENT_SOURCE_MSG msg,
    PVOID pUser,
    PVOID pData
    )
{
    HRESULT hr = S_OK;

    switch (msg)
    {
        case ESM_START_SENDING_EVENTS:
            break;
            
        case ESM_STOP_SENDING_EVENTS:
            break;
            
        case ESM_NEW_QUERY:
            break;
            
        case ESM_CANCEL_QUERY:
            break;
            
        case ESM_ACCESS_CHECK:
            break;

        default:
            hr = E_FAIL;
            break;
    }
    
    UNREFERENCED_PARAMETER(hEventSource);
    UNREFERENCED_PARAMETER(pUser);
    UNREFERENCED_PARAMETER(pData);

    return hr;
}

PCWSTR c_aAzpAccessEventPropertyNames[] =
{
    L"OperationType",
    L"Objecttype",
    L"ObjectName",
//     L"HandleId",
//     L"OperationId",
    L"PrimaryUserSid",
    L"ClientUserSid",
    L"AccessMask",
};
const UINT c_cAzAccessProperties =
    sizeof(c_aAzpAccessEventPropertyNames) / sizeof(PCWSTR);

CIMTYPE c_aAzpAccessEventPropertyTypes[] =
{
    CIM_STRING,
    CIM_STRING,
    CIM_STRING,
//     CIM_UINT64,
//     CIM_UINT64,
    CIM_UINT8 | CIM_FLAG_ARRAY,
    CIM_UINT8 | CIM_FLAG_ARRAY,
    CIM_UINT32,
};
const UINT c_cAzAccessPropertyTypes =
    sizeof(c_aAzpAccessEventPropertyTypes) / sizeof(CIMTYPE);

const DWORD c_aAzAccessPropIndexes[c_cAzAccessProperties] =
{ 0, 1, 2, 3, 4, 5 }; //, 6, 7 };

DWORD AzpCreateAuditEvent(
    IN  HANDLE  hEventSource,
    OUT HANDLE* phAuditEvent,
    OUT HANDLE* phAuditEventPropSubset
    )
{
    DWORD dwError = NO_ERROR;
    HANDLE hAuditEvent = INVALID_HANDLE_VALUE;
    HANDLE hAuditEventPropSubset = INVALID_HANDLE_VALUE;

    //
    // initialize out params
    //
    *phAuditEvent = INVALID_HANDLE_VALUE;
    *phAuditEventPropSubset = INVALID_HANDLE_VALUE;
    
    //
    // create the audit event
    //
    ASSERT(c_cAzAccessProperties == c_cAzAccessPropertyTypes);
    
    hAuditEvent =
    //WmiCreateEventWithProps( hEventSource,
        WmiCreateObjectWithProps( hEventSource,
                                  L"AuditEvent_AuthzAccess",
                                  WMI_CREATEOBJ_LOCKABLE,
                                  c_cAzAccessProperties,
                                  c_aAzpAccessEventPropertyNames,
                                  c_aAzpAccessEventPropertyTypes );

    if (hAuditEvent == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    hAuditEventPropSubset =
    //        WmiCreateEventPropSubset( hAuditEvent,
        WmiCreateObjectPropSubset( hAuditEvent,
                                   //WMI_CREATEOBJ_LOCKABLE,
                                   0,
                                   c_cAzAccessProperties,
                                   (DWORD*) c_aAzAccessPropIndexes );
    
    if (hAuditEventPropSubset == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    *phAuditEvent = hAuditEvent;
    *phAuditEventPropSubset = hAuditEventPropSubset;
    
Cleanup:

    if (dwError != NO_ERROR)
    {
        if (hAuditEvent != INVALID_HANDLE_VALUE)
        {
            (void) WmiDestroyObject( hAuditEvent );
        }

        if (hAuditEventPropSubset != INVALID_HANDLE_VALUE)
        {
            (void) WmiDestroyObject( hAuditEventPropSubset );
        }
    }

    return dwError;
}

DWORD AzpInitRmAuditInfo(
    IN PAUTHZ_RM_AUDIT_INFO pRmAuditInfo
    )
{
    DWORD dwError = NO_ERROR;
    HANDLE hEventSource=NULL;

    //
    // connect to the WMI event server
    //
    hEventSource =
        WmiEventSourceConnect( L"root\\default",
                               L"AuthzAuditEventProvider", //kk
                               0, 0, 0, NULL, 
                               AuthzEventSourceCallback );
    if (hEventSource == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();;
        goto Cleanup;
    }
    

    //
    // if the RM does not want to provide its own event,
    // create a default one
    //
    if (!FLAG_ON(pRmAuditInfo->dwFlags, AUTHZ_RM_AUDIT_USE_GIVEN_EVENT))
    {
        ASSERT(pRmAuditInfo->hAuditEvent == INVALID_HANDLE_VALUE);

        dwError = AzpCreateAuditEvent( hEventSource,
                                       &pRmAuditInfo->hAuditEvent,
                                       &pRmAuditInfo->hAuditEventPropSubset );
        if (dwError != NO_ERROR)
        {
            goto Cleanup;
        }
    }

Cleanup:
    
    return dwError;
}

DWORD AzpInitClientAuditInfo(
    IN  PAUTHZ_RM_AUDIT_INFO     pRmAuditInfo,
    OUT PAUTHZ_CLIENT_AUDIT_INFO pClientAuditInfo
    )
{
    DWORD dwError = NO_ERROR;

    //
    // if the client wants us to create a separate event, create one.
    //
    if ( FLAG_ON( pClientAuditInfo->dwFlags, AUTHZ_CLIENT_AUDIT_USE_OWN_EVENT ))
    {
        ASSERT(FALSE); // nyi
        ASSERT(pClientAuditInfo->hAuditEvent == INVALID_HANDLE_VALUE);

        dwError = AzpCreateAuditEvent( pRmAuditInfo->hEventSource,
                                       &pClientAuditInfo->hAuditEvent,
                                       &pClientAuditInfo->hAuditEventPropSubset );
        if (dwError != NO_ERROR)
        {
            goto Cleanup;
        }
    }

Cleanup:
    
    return dwError;
}

DWORD
AzpGenerateAuditEvent(
    IN PAUTHZ_RM_AUDIT_INFO     pRmAuditInfo,
    IN PAUTHZ_CLIENT_AUDIT_INFO pClientAuditInfo,
    IN PAUTHZI_CLIENT_CONTEXT   pClientContext,
    IN PAUTHZ_AUDIT_INFO        pAuditInfo,
    IN DWORD                    dwAccessMask
    )
{
    DWORD dwError = NO_ERROR;
    BOOL fResult = 0;
    HANDLE hAuditEvent = NULL;
    HANDLE hAuditEventPropSubset = NULL;
    PSID psidPrimaryUser = NULL;
    PSID psidResourceManager = NULL;
    DWORD dwPrimaryUserSidSize = 0;
    DWORD dwRmSidSize = 0;
    
    //
    // kk code to get to client and rm audit info
    //

    
    //
    // determine which audit-event-handle to use
    //
    if (pAuditInfo->dwFlags & AUTHZ_AUDIT_USE_GIVEN_EVENT)
    {
        ASSERT(FALSE);
        hAuditEvent = pAuditInfo->hAuditEvent;
        hAuditEventPropSubset = pAuditInfo->hAuditEventPropSubset;
    }
    else if (pClientAuditInfo->dwFlags & (AUTHZ_CLIENT_AUDIT_USE_OWN_EVENT |
                                          AUTHZ_CLIENT_AUDIT_USE_GIVEN_EVENT))
    {
        hAuditEvent = pClientAuditInfo->hAuditEvent;
        hAuditEventPropSubset = pClientAuditInfo->hAuditEventPropSubset;
    }
    else
    {
        hAuditEvent = pRmAuditInfo->hAuditEvent;
        hAuditEventPropSubset = pRmAuditInfo->hAuditEventPropSubset;
    }

    ASSERT(hAuditEvent != INVALID_HANDLE_VALUE);
    ASSERT(hAuditEventPropSubset != INVALID_HANDLE_VALUE);

    //ASSERT(pClientContext->SidCount);
    //psidPrimaryUser = pClientContext->Sids[0].Sid;
    psidPrimaryUser = pClientAuditInfo->psidClient;
    dwPrimaryUserSidSize = pClientAuditInfo->dwClientSidSize;
    
    psidResourceManager = pRmAuditInfo->psidRmProcess;
    dwRmSidSize = pRmAuditInfo->dwRmProcessSidSize;

    //    fResult = WmiSetEventProps( hAuditEventPropSubset,
    fResult = WmiSetObjectProps( hAuditEventPropSubset,
                                pAuditInfo->szOperationType,
                                pAuditInfo->szObjectType,
                                pAuditInfo->szObjectName,
                                psidPrimaryUser,
                                dwPrimaryUserSidSize,
                                psidResourceManager,
                                dwRmSidSize,
                                dwAccessMask
                                );
    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    //
    // call LSA and send the event to it
    //

    fResult = WmiCommitObject( hAuditEvent );
    if (!fResult)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    
Cleanup:    

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\wmiaudit\wmi-azaudit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A Z E V E N T . H
//
// Contents:    Functions to construct and report Authz audit event
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------

#define AUTHZ_RM_AUDIT_USE_GIVEN_EVENT 0x0001

struct _AUTHZ_RM_AUDIT_INFO
{
    DWORD  dwFlags;

    PCWSTR szResourceManagerName;
    PSID   psidRmProcess;
    DWORD  dwRmProcessSidSize;

    HANDLE hEventSource;
    HANDLE hAuditEvent;
    HANDLE hAuditEventPropSubset;

    PVOID  pReserved;
};
typedef struct _AUTHZ_RM_AUDIT_INFO  AUTHZ_RM_AUDIT_INFO, 
                                    *PAUTHZ_RM_AUDIT_INFO;

#define AUTHZ_CLIENT_AUDIT_USE_OWN_EVENT   0x0001
#define AUTHZ_CLIENT_AUDIT_USE_GIVEN_EVENT 0x0002

struct _AUTHZ_CLIENT_AUDIT_INFO
{
    DWORD  dwFlags;
    HANDLE hAuditEvent;
    HANDLE hAuditEventPropSubset;

    PSID   psidClient;
    DWORD  dwClientSidSize;

    DWORD  dwProcessId; 
    PVOID  pReserved;
};
typedef struct _AUTHZ_CLIENT_AUDIT_INFO  AUTHZ_CLIENT_AUDIT_INFO,
                                        *PAUTHZ_CLIENT_AUDIT_INFO;

#define AUTHZ_AUDIT_USE_GIVEN_EVENT 0x0001

struct _AUTHZ_AUDIT_INFO
{
    DWORD  dwFlags;
    HANDLE hAuditEvent;
    HANDLE hAuditEventPropSubset;

    PCWSTR szOperationType;
    PCWSTR szObjectType;
    PCWSTR szObjectName;

    PVOID  pReserved;
};
typedef struct _AUTHZ_AUDIT_INFO  AUTHZ_AUDIT_INFO, 
                                 *PAUTHZ_AUDIT_INFO;

// struct AzAuditInfoInternalTag
// {
//     PCWSTR szResourceManagerName;
//     DWORD  dwFlags;
//     PVOID  pReserved;

//     HANDLE hEventSource;
//     HANDLE hAuditEvent;
//     HANDLE hAuditEventPropSubset;
// };
// typedef struct AzAuditInfoInternalTag AzAuditInfoInternal;

DWORD AzpInitRmAuditInfo(
    IN PAUTHZ_RM_AUDIT_INFO pRmAuditInfo
    );


DWORD AzpInitClientAuditInfo(
    IN PAUTHZ_RM_AUDIT_INFO pRmAuditInfo,
    IN PAUTHZ_CLIENT_AUDIT_INFO    pClientAuditInfo
    );

DWORD
AzpGenerateAuditEvent(
    IN PAUTHZ_RM_AUDIT_INFO     pRmAuditInfo,
    IN PAUTHZ_CLIENT_AUDIT_INFO pClientAuditInfo,
    IN PAUTHZI_CLIENT_CONTEXT   pClientContext,
    IN PAUTHZ_AUDIT_INFO        pAuditInfo,
    IN DWORD                    dwAccessMask
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\azdisp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    azdisp.h

Abstract:

    Declaration of CAz* dispatch interfaces

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/

#ifndef __AZDISP_H_
#define __AZDISP_H_

#include "resource.h"



///////////////////////
//CAzAdminManager
class ATL_NO_VTABLE CAzAdminManager :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzAdminManager, &CLSID_AzAdminManager>,
	public IDispatchImpl<IAzAdminManager, &IID_IAzAdminManager, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZADMINMANAGER)

BEGIN_COM_MAP(CAzAdminManager)
	COM_INTERFACE_ENTRY(IAzAdminManager)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzAdminManager
public:

        CAzAdminManager();
        virtual ~CAzAdminManager();

        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ ULONG lReserved,
            /* [in] */ ULONG lStoreType,
            /* [in] */ BSTR bstrPolicyURL);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumApplication( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarEnumApplication);
        
        virtual HRESULT STDMETHODCALLTYPE OpenApplication( 
            /* [in] */ BSTR bstrApplicationName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarApplication);
        
        virtual HRESULT STDMETHODCALLTYPE CreateApplication( 
            /* [in] */ BSTR bstrApplicationName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarApplication);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteApplication( 
            /* [in] */ BSTR bstrApplicationName);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumApplicationGroup( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarEnumApplicationGroup);
        
        virtual HRESULT STDMETHODCALLTYPE AddApplicationGroup( 
            /* [in] */ BSTR bstrGroupName);
        
        virtual HRESULT STDMETHODCALLTYPE OpenApplicationGroup( 
            /* [in] */ BSTR bstrGroupName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarApplicationGroup);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteApplicationGroup( 
            /* [in] */ BSTR bstrGroupName);
        
        virtual HRESULT STDMETHODCALLTYPE Submit( 
            /* [in] */ ULONG lReserved);

private:

};


///////////////////////
//CAzApplication
class ATL_NO_VTABLE CAzApplication :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzApplication, &CLSID_AzApplication>,
	public IDispatchImpl<IAzApplication, &IID_IAzApplication, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZAPPLICATION)

BEGIN_COM_MAP(CAzApplication)
	COM_INTERFACE_ENTRY(IAzApplication)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzApplication
public:

        CAzApplication();
        virtual ~CAzApplication();

        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ ULONG lPropId,
            /* [retval][out] */ VARIANT *pvarProp);
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumScope( 
            /* [retval][out] */ VARIANT *pvarEnumAzScope);
        
        virtual HRESULT STDMETHODCALLTYPE OpenScope( 
            /* [in] */ BSTR bstrScopeName,
            /* [retval][out] */ VARIANT *pvarScope);
        
        virtual HRESULT STDMETHODCALLTYPE CreateScope( 
            /* [in] */ BSTR bstrScopeName,
            /* [retval][out] */ VARIANT *pScope);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteScope( 
            /* [in] */ BSTR bstrScopeName);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumOperation( 
            /* [retval][out] */ VARIANT *pvarEnumOperation);
        
        virtual HRESULT STDMETHODCALLTYPE OpenOperation( 
            /* [in] */ BSTR bstrOperationName,
            /* [retval][out] */ VARIANT *pvarOperation);
        
        virtual HRESULT STDMETHODCALLTYPE CreateOperation( 
            /* [in] */ BSTR bstrOperationName,
            /* [retval][out] */ VARIANT *pvarOperation);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteOperation( 
            /* [in] */ BSTR bstrOperationName);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumTask( 
            /* [retval][out] */ VARIANT *pvarEnumAzTask);
        
        virtual HRESULT STDMETHODCALLTYPE OpenTask( 
            /* [in] */ BSTR bstrTaskName,
            /* [retval][out] */ VARIANT *pvarTask);
        
        virtual HRESULT STDMETHODCALLTYPE CreateTask( 
            /* [in] */ BSTR bstrTaskName,
            /* [retval][out] */ VARIANT *pvarTask);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteTask( 
            /* [in] */ BSTR bstrTaskName);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumApplicationGroup( 
            /* [retval][out] */ VARIANT *pvarEnumGroup);
        
        virtual HRESULT STDMETHODCALLTYPE OpenApplicationGroup( 
            /* [in] */ BSTR bstrGroupName,
            /* [retval][out] */ VARIANT *pvarGroup);
        
        virtual HRESULT STDMETHODCALLTYPE CreateApplicationGroup( 
            /* [in] */ BSTR bstrGroupName,
            /* [retval][out] */ VARIANT *pvarGroup);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteApplicationGroup( 
            /* [in] */ BSTR bstrGroupName);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumRole( 
            /* [retval][out] */ VARIANT *pvarEnumRole);
        
        virtual HRESULT STDMETHODCALLTYPE OpenRole( 
            /* [in] */ BSTR bstrRoleName,
            /* [retval][out] */ VARIANT *pvarRole);
        
        virtual HRESULT STDMETHODCALLTYPE CreateRole( 
            /* [in] */ BSTR bstrRoleName,
            /* [retval][out] */ VARIANT *pvarRole);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRole( 
            /* [in] */ BSTR bstrRoleName);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumJunctionPoint( 
            /* [retval][out] */ VARIANT *pvarEnumJunctionPoint);
        
        virtual HRESULT STDMETHODCALLTYPE OpenJunctionPoint( 
            /* [in] */ BSTR bstrJunctionPointName,
            /* [retval][out] */ VARIANT *pvarJunctionPoint);
        
        virtual HRESULT STDMETHODCALLTYPE CreateJunctionPoint( 
            /* [in] */ BSTR bstrJunctionPointName,
            /* [retval][out] */ VARIANT *pvarJunctionPoint);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteJunctionPoint( 
            /* [in] */ BSTR bstrJunctionPointName);
        
        virtual HRESULT STDMETHODCALLTYPE InitializeClientContextFromToken( 
            /* [in] */ ULONG lTokenHandle,
            /* [retval][out] */ VARIANT *pvarClientContext);

private:

};


///////////////////////
//CAzEnumApplication
class ATL_NO_VTABLE CAzEnumApplication :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzEnumApplication, &CLSID_AzEnumApplication>,
	public IDispatchImpl<IAzEnumApplication, &IID_IAzEnumApplication, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZENUMAPPLICATION)

BEGIN_COM_MAP(CAzEnumApplication)
	COM_INTERFACE_ENTRY(IAzEnumApplication)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzEnumApplication
public:

        CAzEnumApplication();
        virtual ~CAzEnumApplication();

        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ ULONG *plCount);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ VARIANT *pvarAzApplication);
        
private:

};


///////////////////////
//CAzOperation
class ATL_NO_VTABLE CAzOperation :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzOperation, &CLSID_AzOperation>,
	public IDispatchImpl<IAzOperation, &IID_IAzOperation, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZOPERATION)

BEGIN_COM_MAP(CAzOperation)
	COM_INTERFACE_ENTRY(IAzOperation)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzOperation
public:

        CAzOperation();
        virtual ~CAzOperation();

        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ ULONG lPropId,
            /* [retval][out] */ VARIANT *pvarProp);
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
private:

};

///////////////////////
//CAzEnumOperation
class ATL_NO_VTABLE CAzEnumOperation :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzEnumOperation, &CLSID_AzEnumOperation>,
	public IDispatchImpl<IAzEnumOperation, &IID_IAzEnumOperation, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZENUMOPERATION)

BEGIN_COM_MAP(CAzEnumOperation)
	COM_INTERFACE_ENTRY(IAzEnumOperation)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzEnumOperation
public:

        CAzEnumOperation();
        virtual ~CAzEnumOperation();

private:

        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ ULONG *plCount);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ VARIANT *pvarOperation);
        
};

///////////////////////
//CAzTask
class ATL_NO_VTABLE CAzTask :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzTask, &CLSID_AzTask>,
	public IDispatchImpl<IAzTask, &IID_IAzTask, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZTASK)

BEGIN_COM_MAP(CAzTask)
	COM_INTERFACE_ENTRY(IAzTask)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzTask
public:

        CAzTask();
        virtual ~CAzTask();

        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ ULONG lPropId,
            /* [retval][out] */ VARIANT *pvarProp);
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
private:

};

///////////////////////
//CAzEnumTask
class ATL_NO_VTABLE CAzEnumTask :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzEnumTask, &CLSID_AzEnumTask>,
	public IDispatchImpl<IAzEnumTask, &IID_IAzEnumTask, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZENUMTASK)

BEGIN_COM_MAP(CAzEnumTask)
	COM_INTERFACE_ENTRY(IAzEnumTask)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzEnumTask
public:

        CAzEnumTask();
        virtual ~CAzEnumTask();

        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ ULONG *plCount);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ VARIANT *pvarTask);
        
private:

};

///////////////////////
//CAzScope
class ATL_NO_VTABLE CAzScope :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzScope, &CLSID_AzScope>,
	public IDispatchImpl<IAzScope, &IID_IAzScope, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZSCOPE)

BEGIN_COM_MAP(CAzScope)
	COM_INTERFACE_ENTRY(IAzScope)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzScope
public:

        CAzScope();
        virtual ~CAzScope();

        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ ULONG lPropId,
            /* [retval][out] */ VARIANT *pvarProp);
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumApplicationGroup( 
            /* [retval][out] */ VARIANT *pvarEnumGroup);
        
        virtual HRESULT STDMETHODCALLTYPE OpenApplicationGroup( 
            /* [in] */ BSTR bstrGroupName,
            /* [retval][out] */ VARIANT *pvarGroup);
        
        virtual HRESULT STDMETHODCALLTYPE AddApplicationGroup( 
            /* [in] */ BSTR bstrGroupName);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteApplicationGroup( 
            /* [in] */ BSTR bstrGroupName);
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnumRole( 
            /* [retval][out] */ VARIANT *pvarEnumRole);
        
        virtual HRESULT STDMETHODCALLTYPE OpenRole( 
            /* [in] */ BSTR bstrRoleName,
            /* [retval][out] */ VARIANT *pvarRole);
        
        virtual HRESULT STDMETHODCALLTYPE AddRole( 
            /* [in] */ BSTR bstrRoleName);
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRole( 
            /* [in] */ BSTR bstrRoleName);

private:

};

///////////////////////
//CAzEnumScope
class ATL_NO_VTABLE CAzEnumScope :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzEnumScope, &CLSID_AzEnumScope>,
	public IDispatchImpl<IAzEnumScope, &IID_IAzEnumScope, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZENUMSCOPE)

BEGIN_COM_MAP(CAzEnumScope)
	COM_INTERFACE_ENTRY(IAzEnumScope)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzEnumScope
public:

        CAzEnumScope();
        virtual ~CAzEnumScope();

        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ ULONG *plCount);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ VARIANT *pvarTask);
        
private:

};

///////////////////////
//CAzApplicationGroup
class ATL_NO_VTABLE CAzApplicationGroup :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzApplicationGroup, &CLSID_AzApplicationGroup>,
	public IDispatchImpl<IAzApplicationGroup, &IID_IAzApplicationGroup, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZAPPLICATIONGROUP)

BEGIN_COM_MAP(CAzApplicationGroup)
	COM_INTERFACE_ENTRY(IAzApplicationGroup)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzApplicationGroup
public:

        CAzApplicationGroup();
        virtual ~CAzApplicationGroup();

        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ ULONG lPropId,
            /* [retval][out] */ VARIANT *pvarProp);
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
private:

};

///////////////////////
//CAzEnumApplicationGroup
class ATL_NO_VTABLE CAzEnumApplicationGroup :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzEnumApplicationGroup, &CLSID_AzEnumApplicationGroup>,
	public IDispatchImpl<IAzEnumApplicationGroup, &IID_IAzEnumApplicationGroup, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZENUMAPPLICATIONGROUP)

BEGIN_COM_MAP(CAzEnumApplicationGroup)
	COM_INTERFACE_ENTRY(IAzEnumApplicationGroup)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzEnumApplicationGroup
public:

        CAzEnumApplicationGroup();
        virtual ~CAzEnumApplicationGroup();

        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ ULONG *plCount);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ VARIANT *pvarTask);
        
private:

};

///////////////////////
//CAzRole
class ATL_NO_VTABLE CAzRole :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzRole, &CLSID_AzRole>,
	public IDispatchImpl<IAzRole, &IID_IAzRole, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZROLE)

BEGIN_COM_MAP(CAzRole)
	COM_INTERFACE_ENTRY(IAzRole)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzRole
public:

        CAzRole();
        virtual ~CAzRole();

        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ ULONG lPropId,
            /* [retval][out] */ VARIANT *pvarProp);
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
        virtual HRESULT STDMETHODCALLTYPE AddPropertyItem( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyItem( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
private:

};

///////////////////////
//CAzEnumRole
class ATL_NO_VTABLE CAzEnumRole :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzEnumRole, &CLSID_AzEnumRole>,
	public IDispatchImpl<IAzEnumRole, &IID_IAzEnumRole, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZENUMROLE)

BEGIN_COM_MAP(CAzEnumRole)
	COM_INTERFACE_ENTRY(IAzEnumRole)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzEnumRole
public:

        CAzEnumRole();
        virtual ~CAzEnumRole();

        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ ULONG *plCount);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ VARIANT *pvarTask);
        
private:

};

///////////////////////
//CAzJunctionPoint
class ATL_NO_VTABLE CAzJunctionPoint :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzJunctionPoint, &CLSID_AzJunctionPoint>,
	public IDispatchImpl<IAzJunctionPoint, &IID_IAzJunctionPoint, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZJUNCTIONPOINT)

BEGIN_COM_MAP(CAzJunctionPoint)
	COM_INTERFACE_ENTRY(IAzJunctionPoint)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzJunctionPoint
public:

        CAzJunctionPoint();
        virtual ~CAzJunctionPoint();

        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ ULONG lPropId,
            /* [retval][out] */ VARIANT *pvarProp);
        
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ ULONG lPropId,
            /* [in] */ VARIANT varProp);
        
private:

};

///////////////////////
//CAzEnumJunctionPoint
class ATL_NO_VTABLE CAzEnumJunctionPoint :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzEnumJunctionPoint, &CLSID_AzEnumJunctionPoint>,
	public IDispatchImpl<IAzEnumJunctionPoint, &IID_IAzEnumJunctionPoint, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZENUMJUNCTIONPOINT)

BEGIN_COM_MAP(CAzEnumJunctionPoint)
	COM_INTERFACE_ENTRY(IAzEnumJunctionPoint)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzEnumJunctionPoint
public:

        CAzEnumJunctionPoint();
        virtual ~CAzEnumJunctionPoint();

        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [retval][out] */ ULONG *plCount);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ VARIANT *pvarTask);
        
private:

};

///////////////////////
//CAzClientContext
class ATL_NO_VTABLE CAzClientContext :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzClientContext, &CLSID_AzClientContext>,
	public IDispatchImpl<IAzClientContext, &IID_IAzClientContext, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZCLIENTCONTEXT)

BEGIN_COM_MAP(CAzClientContext)
	COM_INTERFACE_ENTRY(IAzClientContext)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzClientContext
public:

        CAzClientContext();
        virtual ~CAzClientContext();

        virtual HRESULT STDMETHODCALLTYPE AccessCheck( 
            /* [in] */ BSTR bstrObjectName,
            /* [in] */ ULONG lScopeCount,
            /* [in] */ VARIANT varScopeNames,
            /* [in] */ ULONG lOperationCount,
            /* [in] */ VARIANT varOperations,
            /* [in] */ ULONG lParameterCount,
            /* [in] */ VARIANT varParameterNames,
            /* [in] */ VARIANT varParameterVariants,
            /* [in] */ ULONG lInterfaceCount,
            /* [in] */ VARIANT varInterfaceNames,
            /* [in] */ ULONG lInterfaceFlags,
            /* [in] */ VARIANT varInterfaces,
            /* [retval][out] */ VARIANT *pvarResults);
        
        virtual HRESULT STDMETHODCALLTYPE GetBusinessRuleString( 
            /* [retval][out] */ BSTR *pbstrBusinessRuleString);
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ ULONG lPropId,
            /* [retval][out] */ VARIANT *pvarProp);
        
private:

};

///////////////////////
//CAzAccessCheck
class ATL_NO_VTABLE CAzAccessCheck :
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAzAccessCheck, &CLSID_AzAccessCheck>,
	public IDispatchImpl<IAzAccessCheck, &IID_IAzAccessCheck, &LIBID_AZROLESLib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_AZACCESSCHECK)

BEGIN_COM_MAP(CAzAccessCheck)
	COM_INTERFACE_ENTRY(IAzAccessCheck)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

//IAzAccessCheck
public:

        CAzAccessCheck();
        virtual ~CAzAccessCheck();

        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BusinessRuleResult( 
            /* [in] */ BOOL bResult);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BusinessRuleString( 
            /* [in] */ BSTR bstrBusinessRuleString);
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BusinessRuleString( 
            /* [retval][out] */ BSTR *pbstrBusinessRuleString);
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_BusinessRuleExpiration( 
            /* [in] */ ULONG lExpirationPeriod);
        
        virtual HRESULT STDMETHODCALLTYPE GetParameter( 
            /* [in] */ BSTR bstrParameterName,
            /* [retval][out] */ VARIANT *pvarParameterName);
        
private:

};

#endif //__AZDISP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\wmiaudit\wmi2evt.cpp ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        W M I 2 E V T . C P P
//
// Contents:    Functions to convert WMI event into eventlog event format
//
//
// History:     
//   06-January-2000  kumarp        created
//
//------------------------------------------------------------------------

/*
   - how to find out the event name from hAuditEvent
   
   - 
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
//#include <winnt.h>
//#include <ntdef.h>
#include <stdio.h>
#include <msaudite.h>
#include <sddl.h>

#include "authzp.h"
#include "adtdef.h"
//#include "p2prov.h"
#include "ncevent.h"
#include "lsaptmp.h"

//
// Property conversion flags
//
const DWORD PCF_None = 0x00000000;
const DWORD PCF_Sid  = 0x00000001;
const DWORD PCF_  = 0x00000000;

struct _LsapAdtEventProperty
{
    PCWSTR   szName;
    CIMTYPE  Type;
    DWORD    dwFlag;
};
typedef struct _LsapAdtEventProperty LsapAdtEventProperty;


struct _LsapAdtEventMapEntry
{
    WORD     wCategory;
    DWORD    dwEventId;

    LsapAdtEventProperty* Properties;
};
typedef struct _LsapAdtEventMapEntry LsapAdtEventMapEntry;

LsapAdtEventProperty Properties_SE_AUDITID_AUTHZ[] =
{
    { L"ObjectServer",    CIM_STRING,  PCF_None },
    { L"ProcessId",       CIM_UINT32,  PCF_None },
    { L"OperationType",   CIM_STRING,  PCF_None },
    { L"Objecttype",      CIM_STRING,  PCF_None },
    { L"ObjectName",      CIM_STRING,  PCF_None },
    { L"HandleId",        CIM_UINT64,  PCF_None },
    { L"OperationId",     CIM_UINT64,  PCF_None },

    { L"PrimaryUserSid",  CIM_UINT8 | CIM_FLAG_ARRAY,  PCF_Sid },
    //             { L"PrimaryUserName", CIM_STRING,  PCF_None },
    //             { L"PrimaryDomain",   CIM_STRING,  PCF_None },
    //             { L"PrimaryLogonId",  CIM_UINT64,  PCF_None },

    { L"ClientUserSid",   CIM_UINT8 | CIM_FLAG_ARRAY,  PCF_Sid },
    //             { L"ClientUserName",  CIM_STRING,  PCF_None },
    //             { L"ClientDomain",    CIM_STRING,  PCF_None },
    //             { L"ClientLogonId",   CIM_UINT64,  PCF_None },

    { L"AccessMask",      CIM_UINT32,  PCF_None },
    { L"AdditionalInfo",  CIM_STRING,  PCF_None },
    
    { NULL,               CIM_ILLEGAL,  PCF_None },
};


LsapAdtEventMapEntry LsapAdtEvents[] =
{
    {
        SE_CATEGID_OBJECT_ACCESS,
        SE_AUDITID_OPEN_HANDLE, //kk        SE_AUDITID_AUTHZ,
        Properties_SE_AUDITID_AUTHZ
    }
};
const USHORT c_cEventMapEntries = sizeof(LsapAdtEvents) / sizeof(LsapAdtEventMapEntry);

const USHORT SE_AUDITID_FIRST = 0x200;
const USHORT SE_AUDITID_LAST = 0x2ff;
const USHORT SE_NUM_AUDITID = SE_AUDITID_LAST - SE_AUDITID_FIRST + 1;

USHORT g_EventMapRedir[SE_NUM_AUDITID];

VOID
LsapAdtInitEventMapRedir( )
{
    DWORD dwEventId;

    for (USHORT i=0; i < SE_NUM_AUDITID; i++)
    {
        dwEventId = SE_AUDITID_FIRST + i;
        g_EventMapRedir[i] = c_cEventMapEntries;
        
        for (USHORT j=0; j < c_cEventMapEntries; j++)
        {
            if ( LsapAdtEvents[j].dwEventId == dwEventId )
            {
                g_EventMapRedir[i] = j;
                break;
            }
        }
    }
}

NTSTATUS
LsapAdtInitEventMap( )
{
    NTSTATUS Status = STATUS_SUCCESS;

    LsapAdtInitEventMapRedir();
    
    return Status;
}

NTSTATUS
LsapAdtGetEventMapEntry(
    IN  DWORD dwEventId,
    OUT LsapAdtEventMapEntry** pEventMapEntry
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT usIndex;

    usIndex = g_EventMapRedir[dwEventId - SE_AUDITID_FIRST];
    ASSERT(usIndex <= c_cEventMapEntries);
    
    if ( usIndex < c_cEventMapEntries )
    {
        *pEventMapEntry = &LsapAdtEvents[usIndex];
    }
    else
    {
        *pEventMapEntry = NULL;
        Status = STATUS_NOT_FOUND;
    }

    return Status;
}

NTSTATUS
LsapAdtGetEventProperty(
    IN  HANDLE  hEvent,
    IN  PCWSTR  szPropertyName,
    IN  CIMTYPE PropertyType,
    IN  LPVOID  pData,
    IN  DWORD   dwBufferSize,
    IN  DWORD  *pdwBytesRead
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dwIndex;
    DWORD dwError = NO_ERROR;

    //    if (!WmiAddEventProp( hEvent, szPropertyName, PropertyType, &dwIndex ))
    if (!WmiAddObjectProp( hEvent, szPropertyName, PropertyType, &dwIndex ))
    {
        goto WinErrorCleanup;
    }
    
    //if (!WmiGetEventProp( hEvent, dwIndex,
    if (!WmiGetObjectProp( hEvent, dwIndex,
                          pData, dwBufferSize, pdwBytesRead ))
    {
        goto WinErrorCleanup;
    }

Cleanup:    
    return Status;
    
WinErrorCleanup:
    dwError = GetLastError();
    //kkStatus = mapit();
    goto Cleanup;
}


NTSTATUS
LsapAdtConvertPropertyToString(
    IN  LsapAdtEventProperty* pEventProperty,
    IN  PVOID  pValue,
    IN  DWORD  dwSize,
    OUT PWSTR  szStrValue,
 IN OUT DWORD *pdwRequiredSize
    )
{
    //
    // perf: use better string allocation scheme
    //

    NTSTATUS Status = STATUS_SUCCESS;
    DWORD    dwError = NO_ERROR;
    CIMTYPE  PropertyType;
    BOOL     fIsArrary=FALSE;
    DWORD    dwRequiredSize = 0xffffffff;
    USHORT   usUnitSize = 0xffff;
    DWORD    dwPropertyFlag;
    
    PropertyType = pEventProperty->Type;
    fIsArrary = FLAG_ON( PropertyType, CIM_FLAG_ARRAY );
    PropertyType &= ~CIM_FLAG_ARRAY;
    dwPropertyFlag = pEventProperty->dwFlag;

    if ( FLAG_ON( dwPropertyFlag, PCF_Sid ))
    {
        dwRequiredSize = 256;
    }
    else
    {
        switch (PropertyType)
        {
            default:
                ASSERT(FALSE);
                break;
                
            case CIM_SINT8:
            case CIM_UINT8:
                dwRequiredSize = 4;
                usUnitSize     = 1;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_SINT16:
            case CIM_UINT16:
                dwRequiredSize = 8;
                usUnitSize     = 2;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_SINT32:
            case CIM_UINT32:
                dwRequiredSize = 12;
                usUnitSize     = 4;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_SINT64:
            case CIM_UINT64:
                dwRequiredSize = 24;
                usUnitSize     = 8;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_STRING:
                dwRequiredSize = (dwSize / sizeof(WCHAR)) + 1;
                usUnitSize     = 1;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_BOOLEAN:
            case CIM_REAL32:
            case CIM_REAL64:
            case CIM_DATETIME:
            case CIM_REFERENCE:
            case CIM_CHAR16:
            case CIM_OBJECT:
                ASSERT(NYI);
                break;
        }
    }

    ASSERT(dwRequiredSize < 0xffffffff);

    if (*pdwRequiredSize < dwRequiredSize)
    {
        Status = STATUS_BUFFER_OVERFLOW;
        *pdwRequiredSize = dwRequiredSize;
        goto Cleanup;
    }

    dwRequiredSize = *pdwRequiredSize;
    
    if ( FLAG_ON( dwPropertyFlag, PCF_Sid ))
    {
        Status = LsapRtlConvertSidToString( (PSID) pValue, szStrValue,
                                            &dwRequiredSize );
        
        if ( !NT_SUCCESS( Status ))
        {
            goto WinErrorCleanup;
        }
    }
    else
    {
        switch (PropertyType)
        {
            default:
                ASSERT(FALSE);
                break;
                
            case CIM_SINT8:
                wsprintf( szStrValue, L"%d", (INT) *((CHAR *) pValue));
                break;
            
            case CIM_UINT8:
                wsprintf( szStrValue, L"%d", (UINT) *((UCHAR *) pValue));
                break;
            
            case CIM_SINT16:
                wsprintf( szStrValue, L"%d", (INT) *((SHORT *) pValue));
                break;
            
            case CIM_UINT16:
                wsprintf( szStrValue, L"%d", (UINT) *((USHORT *) pValue));
                break;
            
            case CIM_SINT32:
                wsprintf( szStrValue, L"%d", *((INT *) pValue));
                break;
            
            case CIM_UINT32:
                wsprintf( szStrValue, L"%d", *((UINT *) pValue));
                break;
            
            case CIM_SINT64:
                wsprintf( szStrValue, L"%I64d", (INT64) *((UCHAR *) pValue));
                break;
            
            case CIM_UINT64:
                wsprintf( szStrValue, L"%I64d", (UINT64) *((UCHAR *) pValue));
                break;
            
            case CIM_STRING:
                dwRequiredSize = (dwSize / sizeof(WCHAR)) + 1;
                usUnitSize     = 1;
                if ( fIsArrary )
                {
                    ASSERT(NYI);
                }
                break;
            
            case CIM_BOOLEAN:
            case CIM_REAL32:
            case CIM_REAL64:
            case CIM_DATETIME:
            case CIM_REFERENCE:
            case CIM_CHAR16:
            case CIM_OBJECT:
                ASSERT(NYI);
                break;
        }
    }


    
Cleanup:
    
    return Status;

WinErrorCleanup:
    dwError = GetLastError();
    //kk Status = mapit();
    goto Cleanup;
}
    
#define MAX_NUM_EVENTLOG_STRINGS 32
#define MAX_PROPERTY_SIZE 512

NTSTATUS
LsapAdtConvertAndReportEvent(
    IN  HANDLE hAuditEvent,
    IN  HANDLE hEventLog
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD    dwError = NO_ERROR;
    WORD     wEventType = 0;
    WORD     wCategory = 0;
    DWORD    dwEventId = 0;
    PSID     pUserSid = NULL;
    WORD     wNumStrings = 0;
    DWORD    dwDataSize = 0;
    PWSTR    pStrings[MAX_NUM_EVENTLOG_STRINGS] = { 0 };
    PVOID    pRawData = NULL;
    DWORD    dwEventIdIndex = 0;
    DWORD    dwNumBytesRead;
    DWORD    dwPropertyIndex = 0;
    PCWSTR   szPropertyName;
    CIMTYPE  PropertyType;
    BYTE     PropertyVal[MAX_PROPERTY_SIZE];
    WORD     wStringIndex=0;
    DWORD    dwRequiredSize;
    
    LsapAdtEventMapEntry* pEventMapEntry = NULL;
    LsapAdtEventProperty* pEventProperty = NULL;

    Status = LsapAdtGetEventProperty( hAuditEvent, L"AuditId", CIM_UINT32,
                                      &dwEventId, sizeof(dwEventId),
                                      &dwNumBytesRead );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsapAdtGetEventMapEntry( dwEventId, &pEventMapEntry );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    ASSERT( pEventMapEntry->dwEventId == dwEventId );
    
    pEventProperty = pEventMapEntry->Properties;
    
    while ( ( szPropertyName = pEventProperty->szName ) != NULL )
    {
        PropertyType = pEventProperty->Type;

        Status = LsapAdtGetEventProperty( hAuditEvent,
                                          szPropertyName,
                                          PropertyType,
                                          PropertyVal, MAX_PROPERTY_SIZE,
                                          &dwNumBytesRead );
        
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        // kk alloc strings, init dwRequiredSize
        Status = LsapAdtConvertPropertyToString( pEventProperty,
                                                 PropertyVal,
                                                 dwNumBytesRead,
                                                 pStrings[wNumStrings],
                                                 &dwRequiredSize );
        
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        pEventProperty++;
        wNumStrings++;
    }
                                      
        
    dwError = ReportEvent( hEventLog, wEventType, wCategory, dwEventId,
                           pUserSid, wNumStrings, dwDataSize,
                           (PCWSTR*) pStrings, pRawData );
    
    if (!dwError)
    {
        goto WinErrorCleanup;
    }

    
Cleanup:
    
    return Status;

WinErrorCleanup:
    dwError = GetLastError();
    //kkStatus = mapit();
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\adminmgr.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    adminmgr.cxx

Abstract:

    Routines implementing the Admin Manager object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"

//
// Global Data
//

//
// Global list of all admin manager for this process
//  Access serialized by AzGlResource
//

GENERIC_OBJECT_HEAD AzGlAdminManagers;

RTL_RESOURCE AzGlResource;

BOOL ResourceInitialized = FALSE;

GUID AzGlZeroGuid;

#if DBG
BOOL CritSectInitialized = FALSE;
#endif // DBG



BOOL
AzDllInitialize(VOID)
/*++

Routine Description

    This initializes global events and variables for the DLL.

Arguments

    none

Return Value

    Boolean: TRUE on success, FALSE on fail.

--*/
{
    BOOL RetVal = TRUE;

    //
    // Don't call back on thread start/stop
    // ???


    RtlZeroMemory( &AzGlZeroGuid, sizeof(AzGlZeroGuid) );

    // Initialize the resource
    //
    __try {

        RtlInitializeResource( &AzGlResource );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: RtlInitializeResource failed: 0x%lx\n",
                     GetExceptionCode() ));
    }

    ResourceInitialized = TRUE;

    //
    // Initialize the root of the tree of objects
    //

    AzpLockResourceExclusive( &AzGlResource );
    ObInitGenericHead( &AzGlAdminManagers, OBJECT_TYPE_ADMIN_MANAGER, NULL, NULL, NULL );
    AzpUnlockResource( &AzGlResource );

    //
    // Initialize the stack allocator
    //

    SafeAllocaInitialize(
        SAFEALLOCA_USE_DEFAULT,
        SAFEALLOCA_USE_DEFAULT,
        AzpAllocateHeap,
        AzpFreeHeap
        );

#if DBG
    //
    // Initialize the allocator
    //

    InitializeListHead ( &AzGlAllocatedBlocks );
    __try {
        InitializeCriticalSection ( &AzGlAllocatorCritSect );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: InitializCriticalSection (AzGlAllocatorCritSect) failed: 0x%lx\n",
                     GetExceptionCode() ));
    }

    CritSectInitialized = TRUE;
#endif // DBG

#ifdef AZROLESDBG
    //
    // Initialize debugging
    //
    __try {
        InitializeCriticalSection ( &AzGlLogFileCritSect );
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        RetVal = FALSE;
        KdPrint(("AzRoles.dll: InitializCriticalSection (AzGlLogFileCritSect) failed: 0x%lx\n",
                     GetExceptionCode() ));
    }

    // AzGlDbFlag = AZD_ALL;
    AzGlDbFlag = AZD_INVPARM; // | AZD_PERSIST | AZD_PERSIST_MORE;
    // AzGlLogFile = INVALID_HANDLE_VALUE;
#endif // AZROLESDBG

    return RetVal;

}


BOOL
AzDllUnInitialize(VOID)
/*++

Routine Description

    This uninitializes global events and variables for the DLL.

Arguments

    none

Return Value

    Boolean: TRUE on success, FALSE on fail.

--*/
{
    BOOL RetVal = TRUE;

    //
    // Don't call back on thread start/stop
    //
    // Handle detaching from a process.
    //

    //
    // Delete the resource
    //

    if ( ResourceInitialized ) {
        RtlDeleteResource( &AzGlResource );
        ResourceInitialized = FALSE;
    }

#if DBG
    //
    // Done with the allocator
    //

    if ( CritSectInitialized ) {
        ASSERT( IsListEmpty( &AzGlAllocatedBlocks ));
        DeleteCriticalSection ( &AzGlAllocatorCritSect );
        CritSectInitialized = FALSE;
    }
#endif // DBG

    return RetVal;

}

VOID
AzpUnload(
    VOID
    )
/*++

Routine Description

    Force the DLL unload routine to execute

Arguments

    NONE

Return Value

    NONE

--*/

{

#if DBG // Don't check this in ???
    AzDllUnInitialize();
    ASSERT( IsListEmpty( &AzGlAllocatedBlocks ));
#endif // DBG

}

DWORD
AzpAdminManagerInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzInitialize.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_ADMIN_MANAGER AdminManager = (PAZP_ADMIN_MANAGER) ChildGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Initialize the lists of child objects
    //  Let the generic object manager know all of the types of children we support
    //

    ASSERT( ParentGenericObject == NULL );
    UNREFERENCED_PARAMETER( ParentGenericObject );

    ChildGenericObject->ChildGenericObjectHead = &AdminManager->Applications;

    // List of child applications
    ObInitGenericHead( &AdminManager->Applications,
                       OBJECT_TYPE_APPLICATION,
                       ChildGenericObject,
                       &AdminManager->Groups,
                       NULL );                      // Doesn't share namespace

    // List of child groups
    ObInitGenericHead( &AdminManager->Groups,
                       OBJECT_TYPE_GROUP,
                       ChildGenericObject,
                       &AdminManager->AzpSids,
                       NULL );                      // Doesn't share namespace (YET)

    // List of child AzpSids
    ObInitGenericHead( &AdminManager->AzpSids,
                       OBJECT_TYPE_SID,
                       ChildGenericObject,
                       NULL,
                       NULL );                      // Doesn't share namespace


    return NO_ERROR;
}


VOID
AzpAdminManagerFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AdminManager object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_ADMIN_MANAGER AdminManager = (PAZP_ADMIN_MANAGER) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //

    AzpFreeString( &AdminManager->PolicyUrl );


}



DWORD
WINAPI
AzInitialize(
    IN DWORD StoreType,
    IN LPCWSTR PolicyUrl,
    IN DWORD Flags,
    IN DWORD Reserved,
    OUT PAZ_HANDLE AdminManagerHandle
    )
/*++

Routine Description:

    This routine initializes admin manager.  This routine must be called before any other
    routine.

Arguments:

    StoreType - Takes one of the AZ_ADMIN_STORE_* defines

    PolicyUrl - Specifies the location of the policy store

    Flags - Specifies flags that control the behavior of AzInitialize
        AZ_ADMIN_FLAG_CREATE: Create the policy database

    Reserved - Reserved.  Must by zero.

    AdminManagerHandle - Return a handle to the AdminManager.
        The caller must close this handle by calling AzCloseHandle.


Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - AZ_ADMIN_FLAG_CREATE flag was specified and the policy already exists
    ERROR_FILE_NOT_FOUND - AZ_ADMIN_FLAG_CREATE flag was not specified and the policy does not already exist

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT AdminManager = NULL;
    AZP_STRING AdminManagerName;
    AZP_STRING CapturedString;


    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );
    AzpInitString( &AdminManagerName, NULL );
    AzpInitString( &CapturedString, NULL );

    //
    // Initialization
    //

    __try {
        *AdminManagerHandle = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzInitialize: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    switch ( StoreType ) {
    case AZ_ADMIN_STORE_SAMPLE:
        break;

    case AZ_ADMIN_STORE_UNKNOWN:
    case AZ_ADMIN_STORE_AD:
    case AZ_ADMIN_STORE_XML:
    default:
        AzPrint(( AZD_INVPARM, "AzInitialize: StoreType invalid %ld\n", StoreType ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( Flags & ~AZ_ADMIN_FLAG_VALID ) {
        AzPrint(( AZD_INVPARM, "AzInitialize: Invalid flags 0x%lx\n", Flags ));
        WinStatus = ERROR_INVALID_FLAGS;
        goto Cleanup;
    }

    //
    // Capture the Policy URL
    //

    WinStatus = AzpCaptureString( &CapturedString,
                                  (LPWSTR) PolicyUrl,
                                  AZ_MAX_POLICY_URL_LENGTH,
                                  TRUE ); // NULL is OK

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Create the object
    //

    WinStatus = ObCreateObject(
                    NULL, // There is no parent object
                    &AzGlAdminManagers,
                    OBJECT_TYPE_ADMIN_MANAGER,
                    &AdminManagerName,
                    &AdminManager );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Set admin manager specific fields
    //

    AzpSwapStrings( &CapturedString, &((PAZP_ADMIN_MANAGER)AdminManager)->PolicyUrl );
    ((PAZP_ADMIN_MANAGER)AdminManager)->StoreType = StoreType;


    //
    // Load the objects for the database store
    //

    WinStatus = AzpPersistOpen(
                    (PAZP_ADMIN_MANAGER)AdminManager,
                    (Flags & AZ_ADMIN_FLAG_CREATE) != 0 );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Return the handle to the caller
    //

    ObIncrHandleRefCount( AdminManager );
    *AdminManagerHandle = AdminManager;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:
    if ( AdminManager != NULL ) {
        ObDereferenceObject( AdminManager );
    }

    AzpFreeString( &CapturedString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}



DWORD
WINAPI
AzCloseHandle(
    IN AZ_HANDLE AzHandle,
    IN DWORD Reserved
    )
/*++

Routine Description:

    Close a handle returned from any of the Az* routines

Arguments:

    AzHandle - Passes in the handle to be closed.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The passed in handle was invalid

    ERROR_SERVER_HAS_OPEN_HANDLES - That passed in handle is an AdminManager handle
        and the caller open handles to child objects.

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;
    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT) AzHandle;
    DWORD ObjectType;

    //
    // Grab the global lock
    //  Only for the admin manager case do we modify anything.
    //

    AzpLockResourceShared( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzCloseHandle: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Determine the type of the object
    //

    WinStatus = ObGetHandleType( GenericObject,
                                 TRUE,          // Ok to close handle for deleted object
                                 &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Grab the lock exclusively if we're going to change the database
    //

    if ( ObjectType == OBJECT_TYPE_ADMIN_MANAGER ) {
        AzpLockResourceSharedToExclusive( &AzGlResource );
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           TRUE,    // Allow deleted objects
                                           FALSE,   // No need to refresh cache on a close
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;

    //
    // Handle close of AdminManager handles
    //

    if ( ObjectType == OBJECT_TYPE_ADMIN_MANAGER ) {


        PAZP_ADMIN_MANAGER AdminManager = (PAZP_ADMIN_MANAGER) GenericObject;

        //
        // Fail if there are any child handles open
        //  Otherwise we'll have dangling references
        //

        if ( AdminManager->TotalHandleReferenceCount != 1 ) {
            WinStatus = ERROR_SERVER_HAS_OPEN_HANDLES;
            goto Cleanup;
        }

        //
        // Close the database store
        //

        AzpPersistClose( AdminManager );

        //
        // Remove the entry from the global list of AdminManagers
        //
        RemoveEntryList( &GenericObject->Next );

        // One from ObReferenceObjectByHandle,
        //  one for being in the global list,
        //  one because the handle itself isn't closed yet.
        ASSERT( GenericObject->ReferenceCount == 3 );

        // No longer in the global list
        ObDereferenceObject( GenericObject );

    }


    //
    // Actually close the handle
    //

    ObDecrHandleRefCount( GenericObject );

    //
    // ??? This is really an overactive assert.  Yank it once someone complains.
    ASSERT( (GenericObject->Flags & GENOBJ_FLAGS_DIRTY) == 0 );

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}


VOID
WINAPI
AzFreeMemory(
    IN PVOID Buffer
    )
/*++

Routine Description

    Free memory returned from AzXXXGetProperty

Arguments

    Buffer - address of buffer to free

Return Value

    None

--*/
{
    if ( Buffer != NULL ) {
        AzpFreeHeap( Buffer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\app.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scope.cxx

Abstract:

    Routines implementing the Application object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"




DWORD
AzpApplicationInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzApplicationCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_APPLICATION Application = (PAZP_APPLICATION) ChildGenericObject;
    PAZP_ADMIN_MANAGER AdminManager = (PAZP_ADMIN_MANAGER) ParentGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_ADMIN_MANAGER );

    //
    // Initialize the authz resource manager
    //


    if ( !AuthzInitializeResourceManager(
                AUTHZ_RM_FLAG_NO_AUDIT,     // We don't yet support auditting
                NULL,                       // No Callback ace function ???
                NULL,                       // We compute our own dynamic groups
                NULL,                       // "                               "
                Application->GenericObject.ObjectName.String,
                &Application->AuthzResourceManager ) ) {
        return GetLastError();
    }


    //
    // Initialize the lists of child objects
    //  Let the generic object manager know all of the types of children we support
    //

    ChildGenericObject->ChildGenericObjectHead = &Application->Operations;

    // List of child operations
    ObInitGenericHead( &Application->Operations,
                       OBJECT_TYPE_OPERATION,
                       ChildGenericObject,
                       &Application->Tasks,
                       NULL );                      // Doesn't share namespace (YET)

    // List of child tasks
    ObInitGenericHead( &Application->Tasks,
                       OBJECT_TYPE_TASK,
                       ChildGenericObject,
                       &Application->Scopes,
                       &Application->Operations );  // Shares namespace with operations

    // List of child scopes
    ObInitGenericHead( &Application->Scopes,
                       OBJECT_TYPE_SCOPE,
                       ChildGenericObject,
                       &Application->Groups,
                       NULL );                      // Doesn't share namespace

    // List of child groups
    ObInitGenericHead( &Application->Groups,
                       OBJECT_TYPE_GROUP,
                       ChildGenericObject,
                       &Application->Roles,
                       &AdminManager->Groups );     // Shares namespace with the groups of my parent object

    // List of child roles
    ObInitGenericHead( &Application->Roles,
                       OBJECT_TYPE_ROLE,
                       ChildGenericObject,
                       &Application->JunctionPoints,
                       NULL );                      // Doesn't share namespace

    // List of child junction points
    ObInitGenericHead( &Application->JunctionPoints,
                       OBJECT_TYPE_JUNCTION_POINT,
                       ChildGenericObject,
                       &Application->AzpSids,
                       NULL );                      // Doesn't share namespace

    // List of child AzpSids
    ObInitGenericHead( &Application->AzpSids,
                       OBJECT_TYPE_SID,
                       ChildGenericObject,
                       &Application->ClientContexts,
                       NULL );                      // Doesn't share namespace

    // List of child ClientContexts
    ObInitGenericHead( &Application->ClientContexts,
                       OBJECT_TYPE_CLIENT_CONTEXT,
                       ChildGenericObject,
                       NULL,
                       NULL );                      // Doesn't share namespace

    //
    // Applications are referenced by "JunctionPoints"
    //  Let the generic object manager know all of the lists we support
    //  This is a "back" link so we don't need to define which tasks can reference this operation.
    //

    ChildGenericObject->GenericObjectLists = &Application->backJunctionPoints;

    // Back link to junction points
    ObInitObjectList( &Application->backJunctionPoints,
                      NULL,
                      TRUE, // Backward link
                      0,    // No link pair id
                      NULL,
                      NULL,
                      NULL );

    return NO_ERROR;
}



VOID
AzpApplicationFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Application object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_APPLICATION Application = (PAZP_APPLICATION) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //

    if ( Application->AuthzResourceManager != NULL ) {
        if ( !AuthzFreeResourceManager( Application->AuthzResourceManager ) ) {
            ASSERT( FALSE );
        }
    }

}


DWORD
WINAPI
AzApplicationCreate(
    IN AZ_HANDLE AdminManagerHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ApplicationHandle
    )
/*++

Routine Description:

    This routine adds an application into the scope of the specified AdminManager.

Arguments:

    AdminManagerHandle - Specifies a handle to the AdminManager.

    ApplicationName - Specifies the name of the application to add.

    Reserved - Reserved.  Must by zero.

    ApplicationHandle - Return a handle to the application.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) AdminManagerHandle,
                    OBJECT_TYPE_ADMIN_MANAGER,
                    &(((PAZP_ADMIN_MANAGER)AdminManagerHandle)->Applications),
                    OBJECT_TYPE_APPLICATION,
                    ApplicationName,
                    Reserved,
                    (PGENERIC_OBJECT *) ApplicationHandle );
}



DWORD
WINAPI
AzApplicationOpen(
    IN AZ_HANDLE AdminManagerHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ApplicationHandle
    )
/*++

Routine Description:

    This routine opens an application into the scope of the specified AdminManager.

Arguments:

    AdminManagerHandle - Specifies a handle to the AdminManager.

    ApplicationName - Specifies the name of the application to open

    Reserved - Reserved.  Must by zero.

    ApplicationHandle - Return a handle to the application.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no application by that name

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
                    (PGENERIC_OBJECT) AdminManagerHandle,
                    OBJECT_TYPE_ADMIN_MANAGER,
                    &(((PAZP_ADMIN_MANAGER)AdminManagerHandle)->Applications),
                    OBJECT_TYPE_APPLICATION,
                    ApplicationName,
                    Reserved,
                    (PGENERIC_OBJECT *) ApplicationHandle );
}


DWORD
WINAPI
AzApplicationEnum(
    IN AZ_HANDLE AdminManagerHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE ApplicationHandle
    )
/*++

Routine Description:

    Enumerates all of the applications for the specified AdminManager.

Arguments:

    AdminManagerHandle - Specifies a handle to the AdminManager.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next application to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    ApplicationHandle - Returns a handle to the next application object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) AdminManagerHandle,
                    OBJECT_TYPE_ADMIN_MANAGER,
                    &(((PAZP_ADMIN_MANAGER)AdminManagerHandle)->Applications),
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) ApplicationHandle );

}


DWORD
WINAPI
AzApplicationGetProperty(
    IN AZ_HANDLE ApplicationHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for an application.

Arguments:

    ApplicationHandle - Specifies a handle to the application

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonGetProperty(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzApplicationSetProperty(
    IN AZ_HANDLE ApplicationHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for an application.

Arguments:

    ApplicationHandle - Specifies a handle to the application

    PropertyId - Specifies which property to set

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonSetProperty(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}



DWORD
WINAPI
AzApplicationDelete(
    IN AZ_HANDLE AdminManagerHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes an application from the scope of the specified AdminManager.
    Also deletes any child objects of ApplicationName.

Arguments:

    AdminManagerHandle - Specifies a handle to the AdminManager.

    ApplicationName - Specifies the name of the application to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) AdminManagerHandle,
                    OBJECT_TYPE_ADMIN_MANAGER,
                    &(((PAZP_ADMIN_MANAGER)AdminManagerHandle)->Applications),
                    OBJECT_TYPE_APPLICATION,
                    ApplicationName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\authz\test\wmiaudit\wmi-aztest.cpp ===
DWORD TestAzAudit(
    )

{
    DWORD dwError = NO_ERROR;
    PCWSTR szMsg = L"<unknown>";
    AUTHZ_RM_AUDIT_INFO RmAuditInfo;
    AUTHZ_CLIENT_AUDIT_INFO ClAuditInfo;
    AUTHZ_AUDIT_INFO AuditInfo;
    AUTHZI_CLIENT_CONTEXT ClContext;

    // -----------------------------------------------------------------
    // test AzpInitRmAuditInfo
    // -----------------------------------------------------------------

    ZeroMemory((PVOID) &RmAuditInfo, sizeof(RmAuditInfo));
    RmAuditInfo.szResourceManagerName = L"TestRm";

    HANDLE hToken;
    BYTE TokenUserInfoBuf[256];
    TOKEN_USER* pTokenUserInfo = (TOKEN_USER*) TokenUserInfoBuf;
    DWORD dwSize;

    if ( OpenProcessToken( GetCurrentProcess(),
                           TOKEN_READ,
                           &hToken ))
    {
        if ( GetTokenInformation( hToken, TokenUser,
                                  pTokenUserInfo, 250,
                                  &dwSize ))
        {
            dwSize = RtlLengthSid( pTokenUserInfo->User.Sid );
            RmAuditInfo.psidRmProcess = AuthzpAlloc( dwSize );
            if ( RmAuditInfo.psidRmProcess )
            {
                CopyMemory( RmAuditInfo.psidRmProcess,
                            pTokenUserInfo->User.Sid,
                            dwSize );
                RmAuditInfo.dwRmProcessSidSize = dwSize;
            }
            else
            {
                szMsg = L"AuthzpAlloc";
                goto Error;
            }
        }
        else
        {
            szMsg = L"GetTokenInformation";
            goto GetError;
        }
    }
    else
    {
        szMsg = L"OpenProcessToken";
        goto GetError;
    }

    RmAuditInfo.hEventSource          = INVALID_HANDLE_VALUE;
    RmAuditInfo.hAuditEvent           = INVALID_HANDLE_VALUE;
    RmAuditInfo.hAuditEventPropSubset = INVALID_HANDLE_VALUE;
    
    dwError = AzpInitRmAuditInfo( &RmAuditInfo );

    if ( dwError != NO_ERROR )
    {
        szMsg = L"AzpInitRmAuditInfo";
        goto Error;
    }

    // -----------------------------------------------------------------
    // test AzpInitClientAuditInfo
    // -----------------------------------------------------------------

    ZeroMemory((PVOID) &ClAuditInfo, sizeof(ClAuditInfo));

    ClAuditInfo.psidClient = RmAuditInfo.psidRmProcess;
    ClAuditInfo.dwClientSidSize = RmAuditInfo.dwRmProcessSidSize;
    
    ClAuditInfo.hAuditEvent           = INVALID_HANDLE_VALUE;
    ClAuditInfo.hAuditEventPropSubset = INVALID_HANDLE_VALUE;
    
    
    dwError = AzpInitClientAuditInfo( &RmAuditInfo, &ClAuditInfo );

    if ( dwError != NO_ERROR )
    {
        szMsg = L"AzpInitClientAuditInfo";
        goto Error;
    }

    // -----------------------------------------------------------------
    // test AzpGenerateAuditEvent
    // -----------------------------------------------------------------

    ZeroMemory((PVOID) &AuditInfo, sizeof(AuditInfo));

    AuditInfo.hAuditEvent           = INVALID_HANDLE_VALUE;
    AuditInfo.hAuditEventPropSubset = INVALID_HANDLE_VALUE;

    AuditInfo.szOperationType = L"kkOperation";
    AuditInfo.szObjectType    = L"kkObjectType";
    AuditInfo.szObjectName    = L"kkObjectName";

    ZeroMemory((PVOID) &ClContext, sizeof(ClContext));
    
    dwError = AzpGenerateAuditEvent( &RmAuditInfo, &ClAuditInfo, &ClContext,
                                     &AuditInfo, 0x1122 );

    if ( dwError != NO_ERROR )
    {
        szMsg = L"AzpGenerateAuditEvent";
        goto Error;
    }

Finish:
    return dwError;

GetError:
    dwError = GetLastError();

Error:
    (void) wprintf( L"%s: 0x%x\n", szMsg, dwError );
    goto Finish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\azdisp.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    azdisp.h

Abstract:

    Implementation of CAz* dispatch interfaces

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/

#include "pch.hxx"
#include "stdafx.h"
#include "azroles.h"
#include "azdisp.h"

/////////////////////////
//CAzAdminManager
/////////////////////////
CAzAdminManager::CAzAdminManager()
{
}

CAzAdminManager::~CAzAdminManager()
{
}

HRESULT
CAzAdminManager::Initialize(
    /* [in] */ ULONG lReserved,
    /* [in] */ ULONG lStoreType,
    /* [in] */ BSTR bstrPolicyURL)
{
    UNREFERENCED_PARAMETER(lReserved);
    UNREFERENCED_PARAMETER(lStoreType);
    UNREFERENCED_PARAMETER(bstrPolicyURL);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::CreateEnumApplication(
    /* [retval][out] */ VARIANT __RPC_FAR *pvarEnumApplication)
{
    UNREFERENCED_PARAMETER(pvarEnumApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::OpenApplication(
    /* [in] */ BSTR bstrApplicationName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarApplication)
{
    UNREFERENCED_PARAMETER(bstrApplicationName);
    UNREFERENCED_PARAMETER(pvarApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::CreateApplication(
    /* [in] */ BSTR bstrApplicationName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarApplication)
{
    UNREFERENCED_PARAMETER(bstrApplicationName);
    UNREFERENCED_PARAMETER(pvarApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::DeleteApplication(
    /* [in] */ BSTR bstrApplicationName)
{
    UNREFERENCED_PARAMETER(bstrApplicationName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::CreateEnumApplicationGroup(
    /* [retval][out] */ VARIANT __RPC_FAR *pvarEnumApplicationGroup)
{
    UNREFERENCED_PARAMETER(pvarEnumApplicationGroup);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::AddApplicationGroup(
    /* [in] */ BSTR bstrGroupName)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::OpenApplicationGroup(
    /* [in] */ BSTR bstrGroupName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarApplicationGroup)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    UNREFERENCED_PARAMETER(pvarApplicationGroup);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::DeleteApplicationGroup(
    /* [in] */ BSTR bstrGroupName)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAdminManager::Submit(
    /* [in] */ ULONG lReserved)
{
    UNREFERENCED_PARAMETER(lReserved);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}


/////////////////////////
//CAzApplication
/////////////////////////
CAzApplication::CAzApplication()
{
}

CAzApplication::~CAzApplication()
{
}

HRESULT
CAzApplication::GetProperty(
    /* [in] */ ULONG lPropId,
    /* [retval][out] */ VARIANT *pvarProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(pvarProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::SetProperty(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateEnumScope(
    /* [retval][out] */ VARIANT *pvarEnumAzScope)
{
    UNREFERENCED_PARAMETER(pvarEnumAzScope);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::OpenScope(
    /* [in] */ BSTR bstrScopeName,
    /* [retval][out] */ VARIANT *pvarScope)
{
    UNREFERENCED_PARAMETER(bstrScopeName);
    UNREFERENCED_PARAMETER(pvarScope);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateScope(
    /* [in] */ BSTR bstrScopeName,
    /* [retval][out] */ VARIANT *pScope)
{
    UNREFERENCED_PARAMETER(bstrScopeName);
    UNREFERENCED_PARAMETER(pScope);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::DeleteScope(
    /* [in] */ BSTR bstrScopeName)
{
    UNREFERENCED_PARAMETER(bstrScopeName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateEnumOperation(
    /* [retval][out] */ VARIANT *pvarEnumOperation)
{
    UNREFERENCED_PARAMETER(pvarEnumOperation);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::OpenOperation(
    /* [in] */ BSTR bstrOperationName,
    /* [retval][out] */ VARIANT *pvarOperation)
{
    UNREFERENCED_PARAMETER(bstrOperationName);
    UNREFERENCED_PARAMETER(pvarOperation);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateOperation(
    /* [in] */ BSTR bstrOperationName,
    /* [retval][out] */ VARIANT *pvarOperation)
{
    UNREFERENCED_PARAMETER(bstrOperationName);
    UNREFERENCED_PARAMETER(pvarOperation);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::DeleteOperation(
    /* [in] */ BSTR bstrOperationName)
{
    UNREFERENCED_PARAMETER(bstrOperationName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateEnumTask(
    /* [retval][out] */ VARIANT *pvarEnumAzTask)
{
    UNREFERENCED_PARAMETER(pvarEnumAzTask);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::OpenTask(
    /* [in] */ BSTR bstrTaskName,
    /* [retval][out] */ VARIANT *pvarTask)
{
    UNREFERENCED_PARAMETER(bstrTaskName);
    UNREFERENCED_PARAMETER(pvarTask);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateTask(
    /* [in] */ BSTR bstrTaskName,
    /* [retval][out] */ VARIANT *pvarTask)
{
    UNREFERENCED_PARAMETER(bstrTaskName);
    UNREFERENCED_PARAMETER(pvarTask);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::DeleteTask(
    /* [in] */ BSTR bstrTaskName)
{
    UNREFERENCED_PARAMETER(bstrTaskName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateEnumApplicationGroup(
    /* [retval][out] */ VARIANT *pvarEnumGroup)
{
    UNREFERENCED_PARAMETER(pvarEnumGroup);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::OpenApplicationGroup(
    /* [in] */ BSTR bstrGroupName,
    /* [retval][out] */ VARIANT *pvarGroup)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    UNREFERENCED_PARAMETER(pvarGroup);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateApplicationGroup(
    /* [in] */ BSTR bstrGroupName,
    /* [retval][out] */ VARIANT *pvarGroup)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    UNREFERENCED_PARAMETER(pvarGroup);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::DeleteApplicationGroup(
    /* [in] */ BSTR bstrGroupName)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateEnumRole(
    /* [retval][out] */ VARIANT *pvarEnumRole)
{
    UNREFERENCED_PARAMETER(pvarEnumRole);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::OpenRole(
    /* [in] */ BSTR bstrRoleName,
    /* [retval][out] */ VARIANT *pvarRole)
{
    UNREFERENCED_PARAMETER(bstrRoleName);
    UNREFERENCED_PARAMETER(pvarRole);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateRole(
    /* [in] */ BSTR bstrRoleName,
    /* [retval][out] */ VARIANT *pvarRole)
{
    UNREFERENCED_PARAMETER(bstrRoleName);
    UNREFERENCED_PARAMETER(pvarRole);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::DeleteRole(
    /* [in] */ BSTR bstrRoleName)
{
    UNREFERENCED_PARAMETER(bstrRoleName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateEnumJunctionPoint(
    /* [retval][out] */ VARIANT *pvarEnumJunctionPoint)
{
    UNREFERENCED_PARAMETER(pvarEnumJunctionPoint);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::OpenJunctionPoint(
    /* [in] */ BSTR bstrJunctionPointName,
    /* [retval][out] */ VARIANT *pvarJunctionPoint)
{
    UNREFERENCED_PARAMETER(bstrJunctionPointName);
    UNREFERENCED_PARAMETER(pvarJunctionPoint);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::CreateJunctionPoint(
    /* [in] */ BSTR bstrJunctionPointName,
    /* [retval][out] */ VARIANT *pvarJunctionPoint)
{
    UNREFERENCED_PARAMETER(bstrJunctionPointName);
    UNREFERENCED_PARAMETER(pvarJunctionPoint);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::DeleteJunctionPoint(
    /* [in] */ BSTR bstrJunctionPointName)
{
    UNREFERENCED_PARAMETER(bstrJunctionPointName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplication::InitializeClientContextFromToken(
    /* [in] */ ULONG lTokenHandle,
    /* [retval][out] */ VARIANT *pvarClientContext)
{
    UNREFERENCED_PARAMETER(lTokenHandle);
    UNREFERENCED_PARAMETER(pvarClientContext);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzEnumApplication
/////////////////////////
CAzEnumApplication::CAzEnumApplication()
{
}

CAzEnumApplication::~CAzEnumApplication()
{
}

HRESULT
CAzEnumApplication::Count(
    /* [retval][out] */ ULONG *plCount)
{
    UNREFERENCED_PARAMETER(plCount);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumApplication::Reset( void)
{
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumApplication::Next(
    /* [retval][out] */ VARIANT *pvarAzApplication)
{
    UNREFERENCED_PARAMETER(pvarAzApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}


/////////////////////////
//CAzOperaion
/////////////////////////
CAzOperation::CAzOperation()
{
}

CAzOperation::~CAzOperation()
{
}

HRESULT
CAzOperation::GetProperty(
    /* [in] */ ULONG lPropId,
    /* [retval][out] */ VARIANT *pvarProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(pvarProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzOperation::SetProperty(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzEnumOperation
/////////////////////////
CAzEnumOperation::CAzEnumOperation()
{
}

CAzEnumOperation::~CAzEnumOperation()
{
}

HRESULT
CAzEnumOperation::Count(
    /* [retval][out] */ ULONG *plCount)
{
    UNREFERENCED_PARAMETER(plCount);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumOperation::Reset( void)
{
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumOperation::Next(
    /* [retval][out] */ VARIANT *pvarAzApplication)
{
    UNREFERENCED_PARAMETER(pvarAzApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzTask
/////////////////////////
CAzTask::CAzTask()
{
}

CAzTask::~CAzTask()
{
}

HRESULT
CAzTask::GetProperty(
    /* [in] */ ULONG lPropId,
    /* [retval][out] */ VARIANT *pvarProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(pvarProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzTask::SetProperty(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzTask::AddPropertyItem(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzTask::DeletePropertyItem(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzEnumTask
/////////////////////////
CAzEnumTask::CAzEnumTask()
{
}

CAzEnumTask::~CAzEnumTask()
{
}

HRESULT
CAzEnumTask::Count(
    /* [retval][out] */ ULONG *plCount)
{
    UNREFERENCED_PARAMETER(plCount);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumTask::Reset( void)
{
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumTask::Next(
    /* [retval][out] */ VARIANT *pvarAzApplication)
{
    UNREFERENCED_PARAMETER(pvarAzApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzScope
/////////////////////////
CAzScope::CAzScope()
{
}

CAzScope::~CAzScope()
{
}

HRESULT
CAzScope::GetProperty(
    /* [in] */ ULONG lPropId,
    /* [retval][out] */ VARIANT *pvarProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(pvarProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::SetProperty(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::CreateEnumApplicationGroup(
    /* [retval][out] */ VARIANT *pvarEnumGroup)
{
    UNREFERENCED_PARAMETER(pvarEnumGroup);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::OpenApplicationGroup(
    /* [in] */ BSTR bstrGroupName,
    /* [retval][out] */ VARIANT *pvarGroup)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    UNREFERENCED_PARAMETER(pvarGroup);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::AddApplicationGroup(
    /* [in] */ BSTR bstrGroupName)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::DeleteApplicationGroup(
    /* [in] */ BSTR bstrGroupName)
{
    UNREFERENCED_PARAMETER(bstrGroupName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::CreateEnumRole(
    /* [retval][out] */ VARIANT *pvarEnumRole)
{
    UNREFERENCED_PARAMETER(pvarEnumRole);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::OpenRole(
    /* [in] */ BSTR bstrRoleName,
    /* [retval][out] */ VARIANT *pvarRole)
{
    UNREFERENCED_PARAMETER(bstrRoleName);
    UNREFERENCED_PARAMETER(pvarRole);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::AddRole(
    /* [in] */ BSTR bstrRoleName)
{
    UNREFERENCED_PARAMETER(bstrRoleName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzScope::DeleteRole(
    /* [in] */ BSTR bstrRoleName)
{
    UNREFERENCED_PARAMETER(bstrRoleName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzEnumScope
/////////////////////////
CAzEnumScope::CAzEnumScope()
{
}

CAzEnumScope::~CAzEnumScope()
{
}

HRESULT
CAzEnumScope::Count(
    /* [retval][out] */ ULONG *plCount)
{
    UNREFERENCED_PARAMETER(plCount);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumScope::Reset( void)
{
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumScope::Next(
    /* [retval][out] */ VARIANT *pvarAzApplication)
{
    UNREFERENCED_PARAMETER(pvarAzApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzApplicationGroup
/////////////////////////
CAzApplicationGroup::CAzApplicationGroup()
{
}

CAzApplicationGroup::~CAzApplicationGroup()
{
}

HRESULT
CAzApplicationGroup::GetProperty(
    /* [in] */ ULONG lPropId,
    /* [retval][out] */ VARIANT *pvarProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(pvarProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplicationGroup::SetProperty(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplicationGroup::AddPropertyItem(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzApplicationGroup::DeletePropertyItem(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzEnumApplicationGroup
/////////////////////////
CAzEnumApplicationGroup::CAzEnumApplicationGroup()
{
}

CAzEnumApplicationGroup::~CAzEnumApplicationGroup()
{
}

HRESULT
CAzEnumApplicationGroup::Count(
    /* [retval][out] */ ULONG *plCount)
{
    UNREFERENCED_PARAMETER(plCount);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumApplicationGroup::Reset( void)
{
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumApplicationGroup::Next(
    /* [retval][out] */ VARIANT *pvarAzApplication)
{
    UNREFERENCED_PARAMETER(pvarAzApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzRole
/////////////////////////
CAzRole::CAzRole()
{
}

CAzRole::~CAzRole()
{
}

HRESULT
CAzRole::GetProperty(
    /* [in] */ ULONG lPropId,
    /* [retval][out] */ VARIANT *pvarProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(pvarProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzRole::SetProperty(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzRole::AddPropertyItem(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzRole::DeletePropertyItem(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzEnumRole
/////////////////////////
CAzEnumRole::CAzEnumRole()
{
}

CAzEnumRole::~CAzEnumRole()
{
}

HRESULT
CAzEnumRole::Count(
    /* [retval][out] */ ULONG *plCount)
{
    UNREFERENCED_PARAMETER(plCount);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumRole::Reset( void)
{
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumRole::Next(
    /* [retval][out] */ VARIANT *pvarAzApplication)
{
    UNREFERENCED_PARAMETER(pvarAzApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzJunctionPoint
/////////////////////////
CAzJunctionPoint::CAzJunctionPoint()
{
}

CAzJunctionPoint::~CAzJunctionPoint()
{
}

HRESULT
CAzJunctionPoint::GetProperty(
    /* [in] */ ULONG lPropId,
    /* [retval][out] */ VARIANT *pvarProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(pvarProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzJunctionPoint::SetProperty(
    /* [in] */ ULONG lPropId,
    /* [in] */ VARIANT varProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(varProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzEnumJunctionPoint
/////////////////////////
CAzEnumJunctionPoint::CAzEnumJunctionPoint()
{
}

CAzEnumJunctionPoint::~CAzEnumJunctionPoint()
{
}

HRESULT
CAzEnumJunctionPoint::Count(
    /* [retval][out] */ ULONG *plCount)
{
    UNREFERENCED_PARAMETER(plCount);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumJunctionPoint::Reset( void)
{
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzEnumJunctionPoint::Next(
    /* [retval][out] */ VARIANT *pvarAzApplication)
{
    UNREFERENCED_PARAMETER(pvarAzApplication);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzClientContext
/////////////////////////
CAzClientContext::CAzClientContext()
{
}

CAzClientContext::~CAzClientContext()
{
}

HRESULT
CAzClientContext::AccessCheck(
    /* [in] */ BSTR bstrObjectName,
    /* [in] */ ULONG lScopeCount,
    /* [in] */ VARIANT varScopeNames,
    /* [in] */ ULONG lOperationCount,
    /* [in] */ VARIANT varOperations,
    /* [in] */ ULONG lParameterCount,
    /* [in] */ VARIANT varParameterNames,
    /* [in] */ VARIANT varParameterVariants,
    /* [in] */ ULONG lInterfaceCount,
    /* [in] */ VARIANT varInterfaceNames,
    /* [in] */ ULONG lInterfaceFlags,
    /* [in] */ VARIANT varInterfaces,
    /* [retval][out] */ VARIANT *pvarResults)
{
    UNREFERENCED_PARAMETER(bstrObjectName);
    UNREFERENCED_PARAMETER(lScopeCount);
    UNREFERENCED_PARAMETER(varScopeNames);
    UNREFERENCED_PARAMETER(lOperationCount);
    UNREFERENCED_PARAMETER(varOperations);
    UNREFERENCED_PARAMETER(lParameterCount);
    UNREFERENCED_PARAMETER(varParameterNames);
    UNREFERENCED_PARAMETER(varParameterVariants);
    UNREFERENCED_PARAMETER(lInterfaceCount);
    UNREFERENCED_PARAMETER(varInterfaceNames);
    UNREFERENCED_PARAMETER(lInterfaceFlags);
    UNREFERENCED_PARAMETER(varInterfaces);
    UNREFERENCED_PARAMETER(pvarResults);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzClientContext::GetBusinessRuleString(
    /* [retval][out] */ BSTR *pbstrBusinessRuleString)
{
    UNREFERENCED_PARAMETER(pbstrBusinessRuleString);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzClientContext::GetProperty(
    /* [in] */ ULONG lPropId,
    /* [retval][out] */ VARIANT *pvarProp)
{
    UNREFERENCED_PARAMETER(lPropId);
    UNREFERENCED_PARAMETER(pvarProp);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

/////////////////////////
//CAzAccessCheck
/////////////////////////
CAzAccessCheck::CAzAccessCheck()
{
}

CAzAccessCheck::~CAzAccessCheck()
{
}

HRESULT
CAzAccessCheck::put_BusinessRuleResult(
    /* [in] */ BOOL bResult)
{
    UNREFERENCED_PARAMETER(bResult);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAccessCheck::put_BusinessRuleString(
    /* [in] */ BSTR bstrBusinessRuleString)
{
    UNREFERENCED_PARAMETER(bstrBusinessRuleString);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAccessCheck::get_BusinessRuleString(
    /* [retval][out] */ BSTR *pbstrBusinessRuleString)
{
    UNREFERENCED_PARAMETER(pbstrBusinessRuleString);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAccessCheck::put_BusinessRuleExpiration(
    /* [in] */ ULONG lExpirationPeriod)
{
    UNREFERENCED_PARAMETER(lExpirationPeriod);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}

HRESULT
CAzAccessCheck::GetParameter(
    /* [in] */ BSTR bstrParameterName,
    /* [retval][out] */ VARIANT *pvarParameterName)
{
    UNREFERENCED_PARAMETER(bstrParameterName);
    UNREFERENCED_PARAMETER(pvarParameterName);
    HRESULT hr;

    hr = E_NOTIMPL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\azrolesp.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    azrolesp.h

Abstract:

    Definitions of C interfaces.

    One day all of these interfaces will be in the public SDK.  Only such
    interfaces exist in this file.

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/



#ifndef _AZROLESP_H_
#define _AZROLESP_H_

#if !defined(_AZROLESAPI_)
#define WINAZROLES DECLSPEC_IMPORT
#else
#define WINAZROLES
#endif

#ifdef __cplusplus
extern "C" {
#endif


/////////////////////////////////////////////////////////////////////////////
//
// Value definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Common Property IDs
//
// This list of property IDs are common to all objects.
// Each object should pick specific property ids after AZ_PROP_FIRST_SPECIFIC
//

#define AZ_PROP_NAME                          1
#define AZ_PROP_DESCRIPTION                   2
#define AZ_PROP_FIRST_SPECIFIC              100

//
// Object specific property IDs
//

#define AZ_PROP_OPERATION_ID                200

#define AZ_PROP_TASK_OPERATIONS             300
#define AZ_PROP_TASK_BIZRULE                301
#define AZ_PROP_TASK_BIZRULE_LANGUAGE       302

#define AZ_PROP_GROUP_TYPE                  400
#define AZ_GROUPTYPE_LDAP_QUERY           1
#define AZ_GROUPTYPE_MEMBERSHIP           2
#define AZ_PROP_GROUP_APP_MEMBERS           401
#define AZ_PROP_GROUP_APP_NON_MEMBERS       402
#define AZ_PROP_GROUP_LDAP_QUERY            403
#define AZ_PROP_GROUP_MEMBERS               404
#define AZ_PROP_GROUP_NON_MEMBERS           405

#define AZ_PROP_ROLE_APP_MEMBERS            500
#define AZ_PROP_ROLE_MEMBERS                501
#define AZ_PROP_ROLE_OPERATIONS             502
#define AZ_PROP_ROLE_SCOPES                 503

#define AZ_PROP_JUNCTION_POINT_APPLICATION  600


//
// Maximum length (in characters) of the object name
//

#define AZ_MAX_APPLICATION_NAME_LENGTH      512
#define AZ_MAX_OPERATION_NAME_LENGTH         64
#define AZ_MAX_TASK_NAME_LENGTH              64
#define AZ_MAX_SCOPE_NAME_LENGTH          65536
#define AZ_MAX_GROUP_NAME_LENGTH             64
#define AZ_MAX_ROLE_NAME_LENGTH              64
#define AZ_MAX_JUNCTION_POINT_NAME_LENGTH 65536
#define AZ_MAX_NAME_LENGTH                65536  // Max of the above

//
// Maximum length (in characters) of the description of an object
//

#define AZ_MAX_DESCRIPTION_LENGTH           256

//
// Maximum length (in characters) of various object strings
//

#define AZ_MAX_POLICY_URL_LENGTH          65536

#define AZ_MAX_TASK_BIZRULE_LENGTH        65536
#define AZ_MAX_TASK_BIZRULE_LANGUAGE_LENGTH  64

#define AZ_MAX_GROUP_LDAP_QUERY_LENGTH     4096

/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Handle to various objects returned to caller
//

typedef PVOID AZ_HANDLE;
typedef AZ_HANDLE *PAZ_HANDLE;

//
// Array of strings returned from various "GetProperty" procedures
//

typedef struct _AZ_STRING_ARRAY {

    //
    // Number of strings
    //
    ULONG StringCount;

    //
    // An array of StringCount pointers to strings.
    //
    LPWSTR *Strings;

} AZ_STRING_ARRAY, *PAZ_STRING_ARRAY;

//
// Array of SIDs returned from various "GetProperty" procedures
//

typedef struct _AZ_SID_ARRAY {

    //
    // Number of SIDs
    //
    ULONG SidCount;

    //
    // An array of SidCount pointers to SIDs.
    //
    PSID *Sids;

} AZ_SID_ARRAY, *PAZ_SID_ARRAY;


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

WINAZROLES
DWORD
WINAPI
AzInitialize(
    IN DWORD StoreType,
    IN LPCWSTR PolicyUrl,
    IN DWORD Flags,
    IN DWORD Reserved,
    OUT PAZ_HANDLE AdminManagerHandle
    );

//
// Flags to Admin Manager routines
//

#define AZ_ADMIN_FLAG_CREATE 0x0001  // Create the policy instead of opening it
#define AZ_ADMIN_FLAG_VALID  0x0001  // Mask of all valid flags

//
// Valid Store types
//

#define AZ_ADMIN_STORE_UNKNOWN  0x00    // Use the Policy URL to determine store type
#define AZ_ADMIN_STORE_AD       0x01    // Active Directory
#define AZ_ADMIN_STORE_XML      0x02    // XML file
#define AZ_ADMIN_STORE_SAMPLE   0x03    // Temporary sample provider



//
// Application routines
//
WINAZROLES
DWORD
WINAPI
AzApplicationCreate(
    IN AZ_HANDLE AdminManagerHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ApplicationHandle
    );

WINAZROLES
DWORD
WINAPI
AzApplicationOpen(
    IN AZ_HANDLE AdminManagerHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ApplicationHandle
    );

WINAZROLES
DWORD
WINAPI
AzApplicationEnum(
    IN AZ_HANDLE AdminManagerHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE ApplicationHandle
    );

WINAZROLES
DWORD
WINAPI
AzApplicationGetProperty(
    IN AZ_HANDLE ApplicationHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzApplicationSetProperty(
    IN AZ_HANDLE ApplicationHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzApplicationDelete(
    IN AZ_HANDLE AdminManagerHandle,
    IN LPCWSTR ApplicationName,
    IN DWORD Reserved
    );


//
// Operation routines
//
WINAZROLES
DWORD
WINAPI
AzOperationCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE OperationHandle
    );

WINAZROLES
DWORD
WINAPI
AzOperationOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE OperationHandle
    );

WINAZROLES
DWORD
WINAPI
AzOperationEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE OperationHandle
    );

WINAZROLES
DWORD
WINAPI
AzOperationGetProperty(
    IN AZ_HANDLE OperationHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzOperationSetProperty(
    IN AZ_HANDLE OperationHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzOperationDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved
    );


//
// Task routines
//
WINAZROLES
DWORD
WINAPI
AzTaskCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE TaskHandle
    );

WINAZROLES
DWORD
WINAPI
AzTaskOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE TaskHandle
    );

WINAZROLES
DWORD
WINAPI
AzTaskEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE TaskHandle
    );

WINAZROLES
DWORD
WINAPI
AzTaskGetProperty(
    IN AZ_HANDLE TaskHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzTaskSetProperty(
    IN AZ_HANDLE TaskHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzTaskAddPropertyItem(
    IN AZ_HANDLE TaskHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzTaskRemovePropertyItem(
    IN AZ_HANDLE TaskHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzTaskDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved
    );


//
// Scope routines
//
WINAZROLES
DWORD
WINAPI
AzScopeCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ScopeHandle
    );

WINAZROLES
DWORD
WINAPI
AzScopeOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ScopeHandle
    );

WINAZROLES
DWORD
WINAPI
AzScopeEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE ScopeHandle
    );

WINAZROLES
DWORD
WINAPI
AzScopeGetProperty(
    IN AZ_HANDLE ScopeHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzScopeSetProperty(
    IN AZ_HANDLE ScopeHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzScopeDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved
    );


//
// JunctionPoint routines
//
WINAZROLES
DWORD
WINAPI
AzJunctionPointCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR JunctionPointName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE JunctionPointHandle
    );

WINAZROLES
DWORD
WINAPI
AzJunctionPointOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR JunctionPointName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE JunctionPointHandle
    );

WINAZROLES
DWORD
WINAPI
AzJunctionPointEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE JunctionPointHandle
    );

WINAZROLES
DWORD
WINAPI
AzJunctionPointGetProperty(
    IN AZ_HANDLE JunctionPointHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzJunctionPointSetProperty(
    IN AZ_HANDLE JunctionPointHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzJunctionPointDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR JunctionPointName,
    IN DWORD Reserved
    );


//
// Group routines
//
WINAZROLES
DWORD
WINAPI
AzGroupCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE GroupHandle
    );

WINAZROLES
DWORD
WINAPI
AzGroupOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE GroupHandle
    );

WINAZROLES
DWORD
WINAPI
AzGroupEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE GroupHandle
    );

WINAZROLES
DWORD
WINAPI
AzGroupGetProperty(
    IN AZ_HANDLE GroupHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzGroupSetProperty(
    IN AZ_HANDLE GroupHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzGroupAddPropertyItem(
    IN AZ_HANDLE GroupHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzGroupRemovePropertyItem(
    IN AZ_HANDLE GroupHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzGroupDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved
    );


//
// Role routines
//
WINAZROLES
DWORD
WINAPI
AzRoleCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE RoleHandle
    );

WINAZROLES
DWORD
WINAPI
AzRoleOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE RoleHandle
    );

WINAZROLES
DWORD
WINAPI
AzRoleEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE RoleHandle
    );

WINAZROLES
DWORD
WINAPI
AzRoleGetProperty(
    IN AZ_HANDLE RoleHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzRoleSetProperty(
    IN AZ_HANDLE RoleHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzRoleAddPropertyItem(
    IN AZ_HANDLE RoleHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzRoleRemovePropertyItem(
    IN AZ_HANDLE RoleHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

WINAZROLES
DWORD
WINAPI
AzRoleDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved
    );

//
// Routines common to all objects
//

WINAZROLES
DWORD
WINAPI
AzCloseHandle(
    IN AZ_HANDLE AzHandle,
    IN DWORD Reserved
    );

WINAZROLES
DWORD
WINAPI
AzSubmit(
    IN AZ_HANDLE AzHandle,
    IN DWORD Reserved
    );

WINAZROLES
VOID
WINAPI
AzFreeMemory(
    IN PVOID Buffer
    );

//
// Private routine
//

WINAZROLES
VOID
WINAPI
AzpUnload(
    VOID
    );


#ifdef __cplusplus
}
#endif
#endif // _AZROLESP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\azroles.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    adminmgr.cxx

Abstract:

    Implementation of DLL Exports.

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/


#include "pch.hxx"
#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "azroles.h"
#include "azdisp.h"

#include "azroles_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_AzAdminManager, CAzAdminManager)
    OBJECT_ENTRY(CLSID_AzApplication, CAzApplication)
    OBJECT_ENTRY(CLSID_AzEnumApplication, CAzEnumApplication)
    OBJECT_ENTRY(CLSID_AzOperation, CAzOperation)
    OBJECT_ENTRY(CLSID_AzEnumOperation, CAzEnumOperation)
    OBJECT_ENTRY(CLSID_AzTask, CAzTask)
    OBJECT_ENTRY(CLSID_AzEnumTask, CAzEnumTask)
    OBJECT_ENTRY(CLSID_AzScope, CAzScope)
    OBJECT_ENTRY(CLSID_AzEnumScope, CAzEnumScope)
    OBJECT_ENTRY(CLSID_AzApplicationGroup, CAzApplicationGroup)
    OBJECT_ENTRY(CLSID_AzEnumApplicationGroup, CAzEnumApplicationGroup)
    OBJECT_ENTRY(CLSID_AzRole, CAzRole)
    OBJECT_ENTRY(CLSID_AzEnumRole, CAzEnumRole)
    OBJECT_ENTRY(CLSID_AzJunctionPoint, CAzJunctionPoint)
    OBJECT_ENTRY(CLSID_AzEnumJunctionPoint, CAzEnumJunctionPoint)
    OBJECT_ENTRY(CLSID_AzClientContext, CAzClientContext)
    OBJECT_ENTRY(CLSID_AzAccessCheck, CAzAccessCheck)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    BOOL ret = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        ret = AzDllInitialize();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        ret = AzDllUnInitialize();
    }
    return ret;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\genobj.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    genobj.cxx

Abstract:

    Generic object implementation.

    AZ roles has so many objects that need creation, enumeration, etc
    that it seems prudent to have a single body of code for doing those operations


Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#include "pch.hxx"

//
// Table of sizes of the specific objects
//

DWORD SpecificObjectSize[OBJECT_TYPE_MAXIMUM] = {
    0,                          // OBJECT_TYPE_ROOT
    sizeof(AZP_ADMIN_MANAGER),  // OBJECT_TYPE_ADMIN_MANAGER
    sizeof(AZP_APPLICATION),    // OBJECT_TYPE_APPLICATION
    sizeof(AZP_OPERATION),      // OBJECT_TYPE_OPERATION
    sizeof(AZP_TASK),           // OBJECT_TYPE_TASK
    sizeof(AZP_SCOPE),          // OBJECT_TYPE_SCOPE
    sizeof(AZP_GROUP),          // OBJECT_TYPE_GROUP
    sizeof(AZP_ROLE),           // OBJECT_TYPE_ROLE
    sizeof(AZP_JUNCTION_POINT), // OBJECT_TYPE_JUNCTION_POINT
    sizeof(AZP_SID),            // OBJECT_TYPE_SID
    sizeof(AZP_CLIENT_CONTEXT), // OBJECT_TYPE_CLIENT_CONTEXT
};

//
// Maximum length of the object name
//

DWORD MaxObjectNameLength[OBJECT_TYPE_MAXIMUM] = {
    0,           // OBJECT_TYPE_ROOT
    0,           // OBJECT_TYPE_ADMIN_MANAGER
    AZ_MAX_APPLICATION_NAME_LENGTH,
    AZ_MAX_OPERATION_NAME_LENGTH,
    AZ_MAX_TASK_NAME_LENGTH,
    AZ_MAX_SCOPE_NAME_LENGTH,
    AZ_MAX_GROUP_NAME_LENGTH,
    AZ_MAX_ROLE_NAME_LENGTH,
    AZ_MAX_JUNCTION_POINT_NAME_LENGTH,
    0,           // OBJECT_TYPE_SID
    0,           // OBJECT_TYPE_CLIENT_CONTEXT
};

//
// Table of object init routines
//
// Specifies a routine to call to initialize the object type specific fields
//  when adding a generic object.
//

OBJECT_INIT_ROUTINE *ObjectInitRoutine[OBJECT_TYPE_MAXIMUM] = {
    NULL,                    // OBJECT_TYPE_ROOT
    &AzpAdminManagerInit,    // OBJECT_TYPE_ADMIN_MANAGER
    &AzpApplicationInit,     // OBJECT_TYPE_APPLICATION
    &AzpOperationInit,       // OBJECT_TYPE_OPERATION
    &AzpTaskInit,            // OBJECT_TYPE_TASK
    &AzpScopeInit,           // OBJECT_TYPE_SCOPE
    &AzpGroupInit,           // OBJECT_TYPE_GROUP
    &AzpRoleInit,            // OBJECT_TYPE_ROLE
    &AzpJunctionPointInit,   // OBJECT_TYPE_JUNCTION_POINT
    &AzpSidInit,             // OBJECT_TYPE_SID
    &AzpClientContextInit,   // OBJECT_TYPE_CLIENT_CONTEXT
};

//
// Table of object free routines
//
// Specifies a routine to call to free the object type specific fields
//  when freeing a generic object.
//

OBJECT_FREE_ROUTINE *ObjectFreeRoutine[OBJECT_TYPE_MAXIMUM] = {
    NULL,                    // OBJECT_TYPE_ROOT
    &AzpAdminManagerFree,    // OBJECT_TYPE_ADMIN_MANAGER
    &AzpApplicationFree,     // OBJECT_TYPE_APPLICATION
    &AzpOperationFree,       // OBJECT_TYPE_OPERATION
    &AzpTaskFree,            // OBJECT_TYPE_TASK
    &AzpScopeFree,           // OBJECT_TYPE_SCOPE
    &AzpGroupFree,           // OBJECT_TYPE_GROUP
    &AzpRoleFree,            // OBJECT_TYPE_ROLE
    &AzpJunctionPointFree,   // OBJECT_TYPE_JUNCTION_POINT
    &AzpSidFree,             // OBJECT_TYPE_SID
    &AzpClientContextFree,   // OBJECT_TYPE_CLIENT_CONTEXT
};

//
// Table of object specific GetProperty routines
//
// Specifies a routine to call to get object type specific fields
//  when querying a generic object.
//
// NULL means there are no object specific fields.
//

OBJECT_GET_PROPERTY_ROUTINE *ObjectGetPropertyRoutine[OBJECT_TYPE_MAXIMUM] = {
    NULL,                           // OBJECT_TYPE_ROOT
    NULL,                           // OBJECT_TYPE_ADMIN_MANAGER
    NULL,                           // OBJECT_TYPE_APPLICATION
    &AzpOperationGetProperty,       // OBJECT_TYPE_OPERATION
    &AzpTaskGetProperty,            // OBJECT_TYPE_TASK
    NULL,                           // OBJECT_TYPE_SCOPE
    &AzpGroupGetProperty,           // OBJECT_TYPE_GROUP
    &AzpRoleGetProperty,            // OBJECT_TYPE_ROLE
    &AzpJunctionPointGetProperty,   // OBJECT_TYPE_JUNCTION_POINT
    NULL,                           // OBJECT_TYPE_SID
    NULL,                           // OBJECT_TYPE_CLIENT_CONTEXT
};

//
// Table of object specific SetProperty routines
//
// Specifies a routine to call to set object type specific fields
//  when modifying a generic object.
//
// NULL means there are no object specific fields.
//

OBJECT_SET_PROPERTY_ROUTINE *ObjectSetPropertyRoutine[OBJECT_TYPE_MAXIMUM] = {
    NULL,                           // OBJECT_TYPE_ROOT
    NULL,                           // OBJECT_TYPE_ADMIN_MANAGER
    NULL,                           // OBJECT_TYPE_APPLICATION
    &AzpOperationSetProperty,       // OBJECT_TYPE_OPERATION
    &AzpTaskSetProperty,            // OBJECT_TYPE_TASK
    NULL,                           // OBJECT_TYPE_SCOPE
    &AzpGroupSetProperty,           // OBJECT_TYPE_GROUP
    NULL,                           // OBJECT_TYPE_ROLE
    &AzpJunctionPointSetProperty,   // OBJECT_TYPE_JUNCTION_POINT
    NULL,                           // OBJECT_TYPE_SID
    NULL,                           // OBJECT_TYPE_CLIENT_CONTEXT
};

//
// Table of object specific AddPropertyItem routines
//
// Specifies a routine to call to add property type specific fields.
//
// NULL means there is no object specific action to take
//

OBJECT_ADD_PROPERTY_ITEM_ROUTINE *ObjectAddPropertyItemRoutine[OBJECT_TYPE_MAXIMUM] = {
    NULL,                       // OBJECT_TYPE_ROOT
    NULL,                       // OBJECT_TYPE_ADMIN_MANAGER
    NULL,                       // OBJECT_TYPE_APPLICATION
    NULL,                       // OBJECT_TYPE_OPERATION
    NULL,                       // OBJECT_TYPE_TASK
    NULL,                       // OBJECT_TYPE_SCOPE
    &AzpGroupAddPropertyItem,   // OBJECT_TYPE_GROUP
    NULL,                       // OBJECT_TYPE_ROLE
    &AzpJunctionPointAddPropertyItem,   // OBJECT_TYPE_JUNCTION_POINT
    NULL,                       // OBJECT_TYPE_SID
    NULL,                       // OBJECT_TYPE_CLIENT_CONTEXT
};


VOID
ObInitGenericHead(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN ULONG ObjectType,
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT_HEAD SiblingGenericObjectHead OPTIONAL,
    IN PGENERIC_OBJECT_HEAD SharedNamespace OPTIONAL
    )
/*++

Routine Description

    Initialize the head of a list of generic objects

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObjectHead - Specifies the list head to initialize

    ObjectType - Specifies the type of objects in the list

    ParentGenericObject - Specifies a back link to parent generic object
        that host the object head being initialized.

    SiblingGenericObjectHead - Specifies a pointer to an object head that
        is a sibling of the one being initialized.

    SharedNamespace - Specifies a pointer to an object head that shares
        a namespace with the objects in the list being initialized.
        The structure pointed to by SharedNamespace must already be initialized.

Return Value

    None

--*/

{

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Initialize the linked list
    //

    InitializeListHead( &GenericObjectHead->Head );

    //
    // Initialize the sequence number
    //  Start at 1 since a zero EnumerationContext means beginning of list.
    //

    GenericObjectHead->NextSequenceNumber = 1;

    //
    // Initialize the list of shared namespaces
    //

    if ( SharedNamespace == NULL ) {
        InitializeListHead( &GenericObjectHead->SharedNamespace );
    } else {
        InsertHeadList( &SharedNamespace->SharedNamespace, &GenericObjectHead->SharedNamespace );
    }

    //
    // Store the ObjectType
    //

    GenericObjectHead->ObjectType = ObjectType;

    //
    // Store the back pointer to the parent generic object
    //

    GenericObjectHead->ParentGenericObject = ParentGenericObject;

    //
    // Store the link to the next Generic head
    //

    GenericObjectHead->SiblingGenericObjectHead = SiblingGenericObjectHead;

}


VOID
ObFreeGenericHead(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead
    )
/*++

Routine Description

    Free any ojects on a generic head structure

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObjectHead - Specifies the list head to free

Return Value

    None

--*/

{
    PLIST_ENTRY ListEntry;
    PGENERIC_OBJECT GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Walk the list of child objects dereferencing each.
    //

    while ( !IsListEmpty( &GenericObjectHead->Head ) ) {

        //
        // Remove the entry from the list
        //

        ListEntry = RemoveHeadList( &GenericObjectHead->Head );

        GenericObject = CONTAINING_RECORD( ListEntry,
                                           GENERIC_OBJECT,
                                           Next );

        ObDereferenceObject( GenericObject );
    }

    //
    // Remove ourselves from the shared namespace list
    //

    RemoveEntryList( &GenericObjectHead->SharedNamespace );

}


PGENERIC_OBJECT
ObAllocateGenericObject(
    IN ULONG ObjectType,
    IN PAZP_STRING ObjectName
    )
/*++

Routine Description

    Allocate memory for the private object structure of the specified type

Arguments

    ObjectType - Specifies the type of object to create

    ObjectName - Name of the object

Return Value

    Returns a pointer to the allocated object.  The caller should dereference the
    returned object by calling ObDereferenceObject.

    NULL: not enough memory

--*/
{
    ULONG WinStatus;

    PGENERIC_OBJECT GenericObject;
    ULONG BaseSize;

    //
    // Ensure the object is supported
    //

    if ( ObjectType > OBJECT_TYPE_MAXIMUM  ||
         SpecificObjectSize[ObjectType] == 0 ) {

        ASSERT( ObjectType <= OBJECT_TYPE_MAXIMUM );
        ASSERT( SpecificObjectSize[ObjectType] != 0 );

        return NULL;
    }

    BaseSize = SpecificObjectSize[ObjectType];
    ASSERT( BaseSize >= sizeof(GENERIC_OBJECT) );

    //
    // Allocate the memory
    //

    GenericObject = (PGENERIC_OBJECT) AzpAllocateHeap( BaseSize );

    if ( GenericObject == NULL ) {
        return NULL;
    }

    //
    // Initialize it
    //

    RtlZeroMemory( GenericObject, BaseSize );

    InitializeListHead( &GenericObject->Next );
    GenericObject->ObjectType = ObjectType;

    GenericObject->ReferenceCount = 1;
    AzPrint(( AZD_REF, "0x%lx %ld (%ld): Allocate object\n", GenericObject, GenericObject->ObjectType, GenericObject->ReferenceCount ));

    //
    // Initialize the string name
    //

    WinStatus = AzpDuplicateString( &GenericObject->ObjectName, ObjectName );

    if ( WinStatus != NO_ERROR ) {
        AzpFreeHeap( GenericObject );
        GenericObject = NULL;
    }

    return GenericObject;
}

VOID
ObFreeGenericObject(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN JustRefresh
    )
/*++

Routine Description

    Free memory for the private object structure of the specified type

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObject - Specifies the pointer to the generic object to free

    JustRefresh - TRUE if only those attributes that can be refreshed from the
        policy store are to be freed.
        FALSE if all attributes are to be freed.

Return Value

    None.

--*/
{
    PGENERIC_OBJECT_HEAD ChildGenericObjectHead;

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    if ( !JustRefresh ) {
        ASSERT( GenericObject->HandleReferenceCount == 0 );
        ASSERT( GenericObject->ReferenceCount == 0 );
    }

    //
    // Delink the entry from the parent
    //

    if ( !JustRefresh ) {
        RemoveEntryList( &GenericObject->Next );
    }


    //
    // Call the routine to do object type specific freeing
    //

    if ( ObjectFreeRoutine[GenericObject->ObjectType] == NULL ) {
        ASSERT( ObjectFreeRoutine[GenericObject->ObjectType] != NULL );
    } else {

        ObjectFreeRoutine[GenericObject->ObjectType](GenericObject );

    }

    //
    // Free children of this object
    //  Loop for each type of child
    //

    if ( !JustRefresh ) {
        for ( ChildGenericObjectHead = GenericObject->ChildGenericObjectHead;
              ChildGenericObjectHead != NULL;
              ChildGenericObjectHead = ChildGenericObjectHead->SiblingGenericObjectHead ) {

            ObFreeGenericHead( ChildGenericObjectHead );
        }
    }


    //
    // Remove all references to/from this object
    //  If we're just refreshing, only remove the forward links
    //

    ObRemoveObjectListLinks( GenericObject, !JustRefresh );


    //
    // Free the fields
    //  Leave the name on 'JustRefresh' to support lookups by name.
    //

    if ( !JustRefresh ) {
        AzpFreeString( &GenericObject->ObjectName );
    }
    AzpFreeString( &GenericObject->Description );

    //
    // Free the object itself
    //

    if ( !JustRefresh ) {
        AzpFreeHeap( GenericObject );
    }
}


VOID
ObInsertGenericObject(
    IN PGENERIC_OBJECT_HEAD ParentGenericObjectHead,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description

    Insert the specified object into the specified list.

    On entry, AzGlResource must be locked exclusive.

Arguments

    ParentGenericObjectHead - Specifies the list head of the list to insert into

    ChildGenericObject - Specifies the object to insert into the list


Return Value

    None

--*/
{

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Set the sequence number
    //

    ChildGenericObject->SequenceNumber = ParentGenericObjectHead->NextSequenceNumber;
    ParentGenericObjectHead->NextSequenceNumber ++;

    //
    // Insert the object
    //  Insert at the tail to keep the list in sequence number order.
    //

    ASSERT( ParentGenericObjectHead->ObjectType == ChildGenericObject->ObjectType );
    InsertTailList( &ParentGenericObjectHead->Head, &ChildGenericObject->Next );

    //
    // Provide a back link
    //

    ASSERT( ChildGenericObject->ParentGenericObjectHead == NULL );
    ChildGenericObject->ParentGenericObjectHead = ParentGenericObjectHead;

    //
    // Increment the reference count to ensure the object isn't deleted
    //

    InterlockedIncrement( &ChildGenericObject->ReferenceCount );
    AzPrint(( AZD_REF, "0x%lx %ld (%ld): Insert object\n", ChildGenericObject, ChildGenericObject->ObjectType, ChildGenericObject->ReferenceCount ));

}

VOID
ObIncrHandleRefCount(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Increment the "handle" reference count on an object.

    On entry, AzGlResource must be locked shared.

Arguments

    GenericObject - Specifies the object to insert into the list

Return Value

    None

--*/
{

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Keep a reference to our parent object.
    //  We validate the handle by inspecting walking the list of children in our parent.
    //  So, prevent our parent from being deleted as long as the user has a handle to the child.
    //

    if ( GenericObject->ParentGenericObjectHead->ParentGenericObject != NULL ) {
        InterlockedIncrement ( &GenericObject->ParentGenericObjectHead->ParentGenericObject->ReferenceCount );
        AzPrint(( AZD_REF, "0x%lx %ld (%ld): Child handle ref\n", GenericObject->ParentGenericObjectHead->ParentGenericObject, GenericObject->ParentGenericObjectHead->ParentGenericObject->ObjectType, GenericObject->ParentGenericObjectHead->ParentGenericObject->ReferenceCount ));
    }

    //
    // The handle ref count is a real ref count.  Increment it too.
    //

    InterlockedIncrement( &GenericObject->ReferenceCount );
    AzPrint(( AZD_REF, "0x%lx %ld (%ld): Handle ref\n", GenericObject, GenericObject->ObjectType, GenericObject->ReferenceCount ));

    //
    // Increment the handle ref count
    //

    InterlockedIncrement( &GenericObject->HandleReferenceCount );
    AzPrint(( AZD_HANDLE, "0x%lx %ld (%ld): Open Handle\n", GenericObject, GenericObject->ObjectType, GenericObject->HandleReferenceCount ));

    //
    // Increment the total handle reference count on the entire tree of objects
    //
    InterlockedIncrement( &GenericObject->AdminManagerObject->TotalHandleReferenceCount );
}

VOID
ObDecrHandleRefCount(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Decrement the "handle" reference count on an object.

    On entry, AzGlResource must be locked shared.

Arguments

    GenericObject - Specifies the object to insert into the list

Return Value

    None

--*/
{

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Decrement the handle ref count
    //

    InterlockedDecrement( &GenericObject->HandleReferenceCount );
    AzPrint(( AZD_HANDLE, "0x%lx %ld (%ld): Close Handle\n", GenericObject, GenericObject->ObjectType, GenericObject->HandleReferenceCount ));

    //
    // Decrement the total handle reference count on the entire tree of objects
    //
    InterlockedDecrement( &GenericObject->AdminManagerObject->TotalHandleReferenceCount );

    //
    // The handle ref count is a real ref count.  Decrement it too.
    //

    ObDereferenceObject( GenericObject );

    //
    // Finally, decrement the ref count we have on our parent.
    //

    if ( GenericObject->ParentGenericObjectHead->ParentGenericObject != NULL ) {
        ObDereferenceObject( GenericObject->ParentGenericObjectHead->ParentGenericObject );
    }
}


DWORD
ObGetHandleType(
    IN PGENERIC_OBJECT Handle,
    IN BOOL AllowDeletedObjects,
    OUT PULONG ObjectType
    )
/*++

Routine Description

    This routine takes a handle passed by an application and safely determines what the
    handle type is.

    This routine allows a caller to support various handle types rather than being
    limited to one.

Arguments

    Handle - Handle to check

    AllowDeletedObjects - TRUE if it is OK to use a handle to a deleted object

    ObjectType - Returns the type of object the handle represents


Return Value

    NO_ERROR - the handle is OK
    ERROR_INVALID_HANDLE - the handle isn't OK

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT GenericObject = Handle;


    //
    // Initialization
    //

    if ( Handle == NULL ) {
        AzPrint(( AZD_HANDLE, "0x%lx: NULL handle is invalid\n", Handle ));
        return ERROR_INVALID_HANDLE;
    }

    //
    // Use a try/except since we're touching memory assuming the handle is valid
    //

    WinStatus = NO_ERROR;
    __try {

        //
        // Sanity check the scalar values on the object
        //

        if ( GenericObject->ObjectType >= OBJECT_TYPE_MAXIMUM ) {
            AzPrint(( AZD_HANDLE, "0x%lx %ld: Handle Object type is too large.\n", GenericObject, GenericObject->ObjectType ));
            WinStatus = ERROR_INVALID_HANDLE;

        } else if ( GenericObject->HandleReferenceCount <= 0 ) {
            AzPrint(( AZD_HANDLE, "0x%lx %ld: Handle has no handle reference count.\n", GenericObject, GenericObject->ObjectType ));
            WinStatus = ERROR_INVALID_HANDLE;

        } else if ( GenericObject->ParentGenericObjectHead == NULL ) {
            AzPrint(( AZD_HANDLE, "0x%lx %ld: Handle has no ParentGenericObjectHead.\n", GenericObject, GenericObject->ObjectType ));
            WinStatus = ERROR_INVALID_HANDLE;

        } else if ( !AllowDeletedObjects &&
                    (GenericObject->Flags & GENOBJ_FLAGS_DELETED) != 0 ) {
            AzPrint(( AZD_HANDLE, "0x%lx %ld: Object is deleted.\n", GenericObject, GenericObject->ObjectType ));
            WinStatus = ERROR_INVALID_HANDLE;

        } else {
            PGENERIC_OBJECT_HEAD ParentGenericObjectHead = GenericObject->ParentGenericObjectHead;

            //
            // Sanity check the object with its head
            //

            if ( ParentGenericObjectHead->ObjectType != GenericObject->ObjectType ) {

                AzPrint(( AZD_HANDLE, "0x%lx %ld: Object type doesn't match parent.\n", GenericObject, GenericObject->ObjectType ));
                WinStatus = ERROR_INVALID_HANDLE;

            } else if ( GenericObject->SequenceNumber >= ParentGenericObjectHead->NextSequenceNumber ) {

                AzPrint(( AZD_HANDLE, "0x%lx %ld: Sequence number doesn't match parent.\n", GenericObject, GenericObject->ObjectType ));
                WinStatus = ERROR_INVALID_HANDLE;

            } else {

                *ObjectType = GenericObject->ObjectType;
            }
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        AzPrint(( AZD_HANDLE, "0x%lx: AV accessing handle\n", GenericObject ));
        WinStatus = ERROR_INVALID_HANDLE;
    }

    return WinStatus;
}


DWORD
ObReferenceObjectByName(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN PAZP_STRING ObjectName,
    IN BOOLEAN RefreshCache,
    OUT PGENERIC_OBJECT *RetGenericObject
    )
/*++

Routine Description

    This routine finds an object by the specified name.

    On entry, AzGlResource must be locked shared.

Arguments

    GenericObjectHead - Head of the list of objects to check

    ObjectName - Object Name of the object to look for

    RefreshCache - If TRUE, the returned object has its cache entry refreshed from
        the policy database if needed.
        If FALSE, the entry is returned unrefreshed.

    RetGenericObject - On success, returns a pointer to the object
        The returned pointer must be dereferenced using ObDereferenceObject.

Return Value

    NO_ERROR: The object was returned
    ERROR_NOT_FOUND: The object could not be found
    Others: The object could not be refreshed

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT GenericObject;
    PLIST_ENTRY ListEntry;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    *RetGenericObject = NULL;

    //
    // Loop trying to find the named object
    //

    for ( ListEntry = GenericObjectHead->Head.Flink ;
          ListEntry != &GenericObjectHead->Head ;
          ListEntry = ListEntry->Flink) {

        GenericObject = CONTAINING_RECORD( ListEntry,
                                           GENERIC_OBJECT,
                                           Next );

        //
        // Ignore deleted objects
        //

        if ( GenericObject->Flags & GENOBJ_FLAGS_DELETED ) {
            continue;
        }

        //
        // If we found the object,
        //  grab a reference.
        //
        if ( AzpEqualStrings( &GenericObject->ObjectName, ObjectName ) ) {

            //
            // If the caller wants the object to be refreshed,
            //  do so now.
            //

            if ( RefreshCache &&
                 (GenericObject->Flags & GENOBJ_FLAGS_REFRESH_ME) != 0  ) {

                //
                // Need exclusive access
                //

                AzpLockResourceSharedToExclusive( &AzGlResource );

                WinStatus = AzpPersistRefresh( GenericObject );

                if ( WinStatus != NO_ERROR ) {
                    return WinStatus;
                }
            }

            //
            // Return the object to the caller
            //

            InterlockedIncrement( &GenericObject->ReferenceCount );
            AzPrint(( AZD_REF, "0x%lx %ld (%ld): Ref by name\n", GenericObject, GenericObject->ObjectType, GenericObject->ReferenceCount ));

            *RetGenericObject = GenericObject;
            return NO_ERROR;
        }
    }

    return ERROR_NOT_FOUND;
}


DWORD
ObReferenceObjectByHandle(
    IN PGENERIC_OBJECT Handle,
    IN BOOL AllowDeletedObjects,
    IN BOOLEAN RefreshCache,
    IN ULONG ObjectType
    )
/*++

Routine Description

    This routine takes a handle passed by an application and safely determines whether
    it is a valid handle.  If so, this routine increments the reference count on the
    handle to prevent the handle from being closed.

    On entry, AzGlResource must be locked shared.

Arguments

    Handle - Handle to check

    AllowDeletedObjects - TRUE if it is OK to use a handle to a deleted object

    RefreshCache - If TRUE, the returned object has its cache entry refreshed from
        the policy database if needed.
        If FALSE, the entry is returned unrefreshed.

    ObjectType - Specifies the type of object the caller expects the handle to be


Return Value

    NO_ERROR - the handle is OK
    ERROR_INVALID_HANDLE - the handle isn't OK

--*/
{
    DWORD WinStatus;
    PGENERIC_OBJECT GenericObject = Handle;
    ULONG LocalObjectType;

    PGENERIC_OBJECT Current;
    PLIST_ENTRY ListEntry;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    if ( Handle == NULL ) {
        AzPrint(( AZD_HANDLE, "0x%lx: NULL handle not allowed.\n", NULL ));
        return ERROR_INVALID_HANDLE;
    }

    //
    // Use a try/except since we're touching memory assuming the handle is valid
    //

    __try {


        WinStatus = ObGetHandleType( Handle, AllowDeletedObjects, &LocalObjectType );

        if ( WinStatus == NO_ERROR ) {

            if ( ObjectType != LocalObjectType ) {
                AzPrint(( AZD_HANDLE, "0x%lx %ld: Object Type not local object type\n", GenericObject, GenericObject->ObjectType ));
                WinStatus = ERROR_INVALID_HANDLE;
            } else {
                PGENERIC_OBJECT_HEAD ParentGenericObjectHead = GenericObject->ParentGenericObjectHead;

                //
                // Ensure the object is actually in the list
                //

                WinStatus = ERROR_INVALID_HANDLE;
                for ( ListEntry = ParentGenericObjectHead->Head.Flink ;
                      ListEntry != &ParentGenericObjectHead->Head ;
                      ListEntry = ListEntry->Flink) {

                    Current = CONTAINING_RECORD( ListEntry,
                                                 GENERIC_OBJECT,
                                                 Next );

                    //
                    // If we found the object,
                    //  grab a reference.
                    //
                    if ( Current == GenericObject ) {

                        //
                        // If the caller wants the object to be refreshed,
                        //  do so now.
                        //

                        if ( RefreshCache &&
                             (GenericObject->Flags & GENOBJ_FLAGS_REFRESH_ME) != 0  ) {

                            //
                            // Need exclusive access
                            //

                            AzpLockResourceSharedToExclusive( &AzGlResource );

                            WinStatus = AzpPersistRefresh( GenericObject );

                            if ( WinStatus != NO_ERROR ) {
                                break;
                            }
                        }

                        //
                        // Grab a reference to the object
                        //

                        InterlockedIncrement( &GenericObject->ReferenceCount );
                        AzPrint(( AZD_REF, "0x%lx %ld (%ld): Ref by Handle\n", GenericObject, GenericObject->ObjectType, GenericObject->ReferenceCount ));
                        WinStatus = NO_ERROR;
                        break;
                    }
                }

                //
                // If not,
                //  the handle is invalid.
                //

                if ( WinStatus == ERROR_INVALID_HANDLE ) {
                    AzPrint(( AZD_HANDLE, "0x%lx %ld: Handle not in list.\n", GenericObject, GenericObject->ObjectType ));
                }
            }

        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        AzPrint(( AZD_HANDLE, "0x%lx: AV accessing handle\n", GenericObject ));
        WinStatus = ERROR_INVALID_HANDLE;
    }

    return WinStatus;
}

VOID
ObDereferenceObject(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Decrement the reference count on an object.

    When the last reference count is removed, delete the object.

    On entry, AzGlResource must be locked shared.  If the ref count reaches zero,
        AzGlResource must be locked exclusively.  We can get away with that because
        we force the ref count to zero only when closing the AdminManager object.

Arguments

    GenericObject - Specifies the object to insert into the list

Return Value

    None

--*/
{
    ULONG RefCount;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Decrement the reference count
    //

    RefCount = InterlockedDecrement( &GenericObject->ReferenceCount );
    AzPrint(( AZD_REF, "0x%lx %ld (%ld): Deref\n", GenericObject, GenericObject->ObjectType, GenericObject->ReferenceCount ));

    //
    // Check if the object is no longer referenced
    //

    if ( RefCount == 0 ) {

        //
        // Grab the lock exclusively
        //

        ASSERT( GenericObject->HandleReferenceCount == 0 );
        AzpLockResourceSharedToExclusive( &AzGlResource );

        //
        // Free the object itself
        //

        ObFreeGenericObject( GenericObject, FALSE );

    }

}


DWORD
ObCreateObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN PAZP_STRING ChildObjectNameString,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine creates a child object in the scope of the specified parent object.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        be verified.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.

    ChildObjectType - Specifies the object type RetChildGenericObject.

    ChildObjectNameString - Specifies the name of the child object.
        This name must be unique at the current scope.

    RetChildGenericObject - Returns a pointer to the allocated generic child object
        This pointer must be dereferenced using ObDereferenceObject.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT_HEAD CurrentObjectHead;
    PGENERIC_OBJECT ChildGenericObject = NULL;

    //
    // Initialization
    //

    ASSERT( ChildObjectType != OBJECT_TYPE_ROOT );
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Do duplicate detection
    //
    // Loop through all of the lists that share a namespace
    //

    CurrentObjectHead = GenericChildHead;
    for (;;) {
        PLIST_ENTRY ListEntry;

        //
        // Ensure the new name doesn't exist in the current list
        //

        WinStatus = ObReferenceObjectByName( CurrentObjectHead,
                                             ChildObjectNameString,
                                             FALSE,    // No need to refresh the cache
                                             &ChildGenericObject );

        if ( WinStatus == NO_ERROR ) {
            WinStatus = ERROR_ALREADY_EXISTS;
            goto Cleanup;
        }

        //
        // If we've tried all of the lists,
        //  we're done.
        //

        ListEntry = CurrentObjectHead->SharedNamespace.Flink;
        CurrentObjectHead = CONTAINING_RECORD( ListEntry,
                                               GENERIC_OBJECT_HEAD,
                                               SharedNamespace );

        if ( CurrentObjectHead == GenericChildHead ) {
            break;
        }

    }


    //
    // Allocate the structure to return to the caller
    //

    ChildGenericObject = ObAllocateGenericObject( ChildObjectType, ChildObjectNameString );

    if ( ChildGenericObject == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Keep a pointer to the object at the root of the tree
    //  Back pointers don't increment reference count.
    //

    if ( ChildObjectType == OBJECT_TYPE_ADMIN_MANAGER  ) {
        ChildGenericObject->AdminManagerObject = (PAZP_ADMIN_MANAGER) ChildGenericObject;
    } else {
        ChildGenericObject->AdminManagerObject = (PAZP_ADMIN_MANAGER)
                    ParentGenericObject->AdminManagerObject;
    }

    //
    // Call the routine to do object type specific initialization
    //

    if ( ObjectInitRoutine[ChildObjectType] == NULL ) {
        ASSERT( ObjectInitRoutine[ChildObjectType] != NULL );
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    WinStatus = ObjectInitRoutine[ChildObjectType](
                                   ParentGenericObject,
                                   ChildGenericObject );

    if ( WinStatus != NO_ERROR ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Insert the child into the list of children for this parent
    //

    ObInsertGenericObject( GenericChildHead, ChildGenericObject );


    //
    // Return the pointer to the new structure
    //

    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:
    if ( WinStatus != NO_ERROR && ChildGenericObject != NULL ) {
        ObDereferenceObject( ChildGenericObject );
    }

    return WinStatus;
}


DWORD
ObCommonCreateObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine creates a child object in the scope of the specified parent object.

Arguments:

    ParentGenericObject - Specifies a handle to the parent object to add the child
        object onto.  This "handle" has been passed from the application and needs to
        be verified.

    ParentObjectType - Specifies the object type ParentGenericObject.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.  This is a computed pointer and is considered untrustworthy
        until ParentGenericObject has been verified.

    ChildObjectType - Specifies the object type RetChildGenericObject.

    ChildObjectName - Specifies the name of the child object.
        This name must be unique at the current scope.
        This name is passed from the application and needs to be verified.

    Reserved - Reserved.  Must by zero.

    RetChildGenericObject - Return a handle to the generic child object
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedParentObject = NULL;
    PGENERIC_OBJECT ChildGenericObject = NULL;
    AZP_STRING ChildObjectNameString;

    //
    // Grab the global lock
    //

    ASSERT( ParentObjectType != OBJECT_TYPE_ROOT );
    ASSERT( ChildObjectType != OBJECT_TYPE_ADMIN_MANAGER );
    AzpLockResourceExclusive( &AzGlResource );
    AzpInitString( &ChildObjectNameString, NULL );

    //
    // Initialization
    //

    __try {
        *RetChildGenericObject = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonCreateObject: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( ParentGenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ParentObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedParentObject = ParentGenericObject;


    //
    // Capture the object name string from the caller
    //

    WinStatus = AzpCaptureString( &ChildObjectNameString,
                                  ChildObjectName,
                                  MaxObjectNameLength[ChildObjectType],
                                  FALSE );  // NULL names not OK

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Create the object
    //

    WinStatus = ObCreateObject(
                        ParentGenericObject,
                        GenericChildHead,
                        ChildObjectType,
                        &ChildObjectNameString,
                        &ChildGenericObject );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Mark the object as needing to be written
    //

    ChildGenericObject->Flags |= GENOBJ_FLAGS_DIRTY;

    //
    // Return the handle to the caller
    //

    ObIncrHandleRefCount( ChildGenericObject );
    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedParentObject != NULL ) {
        ObDereferenceObject( ReferencedParentObject );
    }

    if ( ChildGenericObject != NULL ) {
        ObDereferenceObject( ChildGenericObject );
    }
    AzpFreeString( &ChildObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
ObCommonOpenObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine opens a child object in the scope of the specified parent object.

Arguments:

    ParentGenericObject - Specifies a handle to the parent object to open the child
        object from.  This "handle" has been passed from the application and needs to
        be verified.

    ParentObjectType - Specifies the object type ParentGenericObject.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.  This is a computed pointer and is considered untrustworthy
        until ParentGenericObject has been verified.

    ChildObjectType - Specifies the object type RetChildGenericObject.

    ChildObjectName - Specifies the name of the child object.
        This name is passed from the application and needs to be verified.

    Reserved - Reserved.  Must by zero.

    RetChildGenericObject - Return a handle to the generic child object
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no object by that name

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedParentObject = NULL;
    PGENERIC_OBJECT ChildGenericObject = NULL;

    AZP_STRING ChildObjectNameString;

    //
    // Grab the global lock
    //

    AzpLockResourceShared( &AzGlResource );
    ASSERT( ParentObjectType != OBJECT_TYPE_ROOT );
    ASSERT( ChildObjectType != OBJECT_TYPE_ADMIN_MANAGER );

    //
    // Initialization
    //

    AzpInitString( &ChildObjectNameString, NULL );
    __try {
        *RetChildGenericObject = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonOpenObject: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( ParentGenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ParentObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedParentObject = ParentGenericObject;


    //
    // Capture the object name string from the caller
    //

    WinStatus = AzpCaptureString( &ChildObjectNameString,
                                  ChildObjectName,
                                  MaxObjectNameLength[ChildObjectType],
                                  FALSE );  // NULL names not OK

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Find the named object
    //

    WinStatus = ObReferenceObjectByName( GenericChildHead,
                                         &ChildObjectNameString,
                                         TRUE,     // Refresh the cache for this object
                                         &ChildGenericObject );


    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Return the handle to the caller
    //

    ObIncrHandleRefCount( ChildGenericObject );
    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedParentObject != NULL ) {
        ObDereferenceObject( ReferencedParentObject );
    }

    if ( ChildGenericObject != NULL ) {
        ObDereferenceObject( ChildGenericObject );
    }

    AzpFreeString( &ChildObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}

DWORD
ObEnumObjects(
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN BOOL EnumerateDeletedObjects,
    IN BOOL RefreshCache,
    IN OUT PULONG EnumerationContext,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine enumerates the next child object from the scope of the specified parent object.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.

    EnumerateDeletedObjects - Specifies whether deleted objects are to be returned
        in the enumeration.

    RefreshCache - If TRUE, the returned object has its cache entry refreshed from
        the policy database if needed.
        If FALSE, the entry is returned unrefreshed.

    EnumerationContext - Specifies a context indicating the next object to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    RetChildGenericObject - Returns a pointer to the generic child object

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;

    PLIST_ENTRY ListEntry;
    PGENERIC_OBJECT ChildGenericObject = NULL;



    //
    // If we've already returned the whole list,
    //  don't bother walking the list.
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    if ( *EnumerationContext >= GenericChildHead->NextSequenceNumber ) {
        WinStatus = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

    //
    // Walk the list of children finding where we left off
    //

    for ( ListEntry = GenericChildHead->Head.Flink ;
          ListEntry != &GenericChildHead->Head ;
          ListEntry = ListEntry->Flink) {

        ChildGenericObject = CONTAINING_RECORD( ListEntry,
                                                GENERIC_OBJECT,
                                                Next );

        //
        // See if this is it
        //

        if ( ChildGenericObject->SequenceNumber > *EnumerationContext ) {

            //
            // Ignore deleted object if the caller doesn't want to see them
            //
            // If this is not a deleted object,
            //  or the caller wants deleted objects to be returned,
            //  return it.
            //

            if ((ChildGenericObject->Flags & GENOBJ_FLAGS_DELETED) == 0 ||
                EnumerateDeletedObjects ) {

                break;
            }

        }

        ChildGenericObject = NULL;

    }

    //
    // If we've already returned the whole list,
    //  indicate so.
    //

    if ( ChildGenericObject == NULL ) {
        WinStatus = ERROR_NO_MORE_ITEMS;
        goto Cleanup;
    }

    //
    // If the caller wants the object to be refreshed,
    //  do so now.
    //

    if ( RefreshCache &&
         (ChildGenericObject->Flags & GENOBJ_FLAGS_REFRESH_ME) != 0  ) {

        //
        // Need exclusive access
        //

        AzpLockResourceSharedToExclusive( &AzGlResource );

        WinStatus = AzpPersistRefresh( ChildGenericObject );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // Return the handle to the caller
    //

    *EnumerationContext = ChildGenericObject->SequenceNumber;
    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:
    return WinStatus;
}

DWORD
ObCommonEnumObjects(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN OUT PULONG EnumerationContext,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    )
/*++

Routine Description:

    This routine enumerates the next child object from the scope of the specified parent object.

Arguments:

    ParentGenericObject - Specifies a handle to the parent object to enumerate the child
        objects of.
        This "handle" has been passed from the application and needs to be verified.

    ParentObjectType - Specifies the object type ParentGenericObject.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.  This is a computed pointer and is considered untrustworthy
        until ParentGenericObject has been verified.

    EnumerationContext - Specifies a context indicating the next object to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    Reserved - Reserved.  Must by zero.

    RetChildGenericObject - Returns a handle to the generic child object
        The caller must close this handle by calling AzpDzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedParentObject = NULL;
    PGENERIC_OBJECT ChildGenericObject = NULL;

    //
    // Grab the global lock
    //
    ASSERT( ParentObjectType != OBJECT_TYPE_ROOT );

    AzpLockResourceShared( &AzGlResource );


    //
    // Initialize the return handle
    //

    __try {
        *RetChildGenericObject = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonEnumObjects: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( ParentGenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ParentObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedParentObject = ParentGenericObject;

    //
    // Call the common routine to do the actual enumeration
    //

    WinStatus = ObEnumObjects( GenericChildHead,
                               FALSE,   // Don't enumerate deleted objects
                               TRUE,    // Refresh the cache
                               EnumerationContext,
                               &ChildGenericObject );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Return the handle to the caller
    //

    ObIncrHandleRefCount( ChildGenericObject );
    *RetChildGenericObject = ChildGenericObject;

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedParentObject != NULL ) {
        ObDereferenceObject( ReferencedParentObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
ObCommonGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG ObjectType,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for a generic object.

Arguments:

    GenericObject - Specifies a handle to the object to get the property from.
        This "handle" has been passed from the application and needs to be verified.

    ObjectType - Specifies the expected object type GenericObject.

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object

        Any object specific properties.


Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;

    //
    // Grab the global lock
    //

    AzpLockResourceShared( &AzGlResource );


    //
    // Initialize the return value
    //

    __try {
        *PropertyValue = NULL;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
        goto Cleanup;
    }

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonGetProperty: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );
    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;

    //
    // Return any common attribute
    //
    //  Return object name to the caller
    //

    switch ( PropertyId ) {
    case AZ_PROP_NAME:

        *PropertyValue = AzpGetStringProperty( &GenericObject->ObjectName );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    //
    // Return object description to the caller
    //
    case AZ_PROP_DESCRIPTION:

        *PropertyValue = AzpGetStringProperty( &GenericObject->Description );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        break;

    default:
        ASSERT ( PropertyId >= AZ_PROP_FIRST_SPECIFIC );

        //
        // Call the routine to do object type specific querying
        //

        if ( ObjectGetPropertyRoutine[GenericObject->ObjectType] != NULL ) {

            WinStatus = ObjectGetPropertyRoutine[GenericObject->ObjectType](
                        GenericObject,
                        PropertyId,
                        PropertyValue );

        } else {
            AzPrint(( AZD_INVPARM, "ObCommonGetProperty: No get property routine.\n", GenericObject->ObjectType, PropertyId ));
            WinStatus = ERROR_INVALID_PARAMETER;
        }
        break;
    }




    //
    // Return the value to the caller
    //
    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}


DWORD
ObCommonSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG ObjectType,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for a generic object.

Arguments:

    GenericObject - Specifies a handle to the object to modify.
        This "handle" has been passed from the application and needs to be verified.

    ObjectType - Specifies the expected object type GenericObject.

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.


    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object

        Any object specific properties.


Return Value:

    NO_ERROR - The operation was successful
    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;
    AZP_STRING CapturedString;

    //
    // Grab the global lock
    //

    AzpInitString( &CapturedString, NULL );
    AzpLockResourceExclusive( &AzGlResource );


    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonSetProperty: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;

    //
    // Return any common attribute
    //
    //  Return object name to the caller
    //

    switch ( PropertyId ) {
    case AZ_PROP_NAME:

        //
        // Capture the input string
        //

        WinStatus = AzpCaptureString( &CapturedString,
                                      (LPWSTR) PropertyValue,
                                      MaxObjectNameLength[ObjectType],
                                      FALSE ); // NULL not ok

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Check to see if the name conflicts with an existing name
        // ???

        //
        // Swap the old/new names
        //

        AzpSwapStrings( &CapturedString, &GenericObject->ObjectName );
        break;

    //
    // Return object description to the caller
    //
    case AZ_PROP_DESCRIPTION:

        //
        // Capture the input string
        //

        WinStatus = AzpCaptureString( &CapturedString,
                                      (LPWSTR) PropertyValue,
                                      AZ_MAX_DESCRIPTION_LENGTH,
                                      TRUE ); // NULL is OK

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Swap the old/new names
        //

        AzpSwapStrings( &CapturedString, &GenericObject->Description );
        break;

    default:
        ASSERT ( PropertyId >= AZ_PROP_FIRST_SPECIFIC );

        //
        // Call the routine to do object type specific set property
        //

        if ( ObjectSetPropertyRoutine[GenericObject->ObjectType] != NULL ) {

            WinStatus = ObjectSetPropertyRoutine[GenericObject->ObjectType](
                        GenericObject,
                        PropertyId,
                        PropertyValue );

            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        } else {
            AzPrint(( AZD_INVPARM, "ObCommonSetProperty: non set property routine\n", GenericObject->ObjectType, PropertyId ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        break;
    }

    //
    // Mark the object as needing to be written
    //

    GenericObject->Flags |= GENOBJ_FLAGS_DIRTY;



    //
    // Return the value to the caller
    //
    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    AzpFreeString( &CapturedString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}

VOID
ObMarkObjectDeleted(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description

    Mark this object and all child objects as deleted.

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObject - Specifies the object to mark

Return Value

    None

--*/
{
    PGENERIC_OBJECT_HEAD ChildGenericObjectHead;

    PGENERIC_OBJECT ChildGenericObject;
    PLIST_ENTRY ListEntry;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Mark the entry as deleted
    //

    GenericObject->Flags |= GENOBJ_FLAGS_DELETED;

    //
    // Delete all children of this object
    //
    //  Loop for each type of child object
    //

    for ( ChildGenericObjectHead = GenericObject->ChildGenericObjectHead;
          ChildGenericObjectHead != NULL;
          ChildGenericObjectHead = ChildGenericObjectHead->SiblingGenericObjectHead ) {

        //
        // Loop for each child object
        //

        for ( ListEntry = ChildGenericObjectHead->Head.Flink ;
              ListEntry != &ChildGenericObjectHead->Head ;
              ListEntry = ListEntry->Flink) {

            ChildGenericObject = CONTAINING_RECORD( ListEntry,
                                                    GENERIC_OBJECT,
                                                    Next );

            //
            // Mark that object
            //

            ObMarkObjectDeleted( ChildGenericObject );

        }
    }

    //
    // Delete all references to this object
    //

    ObRemoveObjectListLinks( GenericObject, TRUE );

}


DWORD
ObCommonDeleteObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a child object from the scope of the specified parent object.

Arguments:

    ParentGenericObject - Specifies a handle to the parent object to delete the child
        object from.  This "handle" has been passed from the application and needs to
        be verified.

    ParentObjectType - Specifies the object type ParentGenericObject.

    GenericChildHead - Specifies a pointer to the head of the list of children of
        ParentGenericObject.  This is a computed pointer and is considered untrustworthy
        until ParentGenericObject has been verified.

    ChildObjectType - Specifies the object type RetChildGenericObject.

    ChildObjectName - Specifies the name of the child object.
        This name is passed from the application and needs to be verified.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedParentObject = NULL;
    PGENERIC_OBJECT ChildGenericObject = NULL;

    AZP_STRING ChildObjectNameString;


    //
    // Initialization
    //

    AzpInitString( &ChildObjectNameString, NULL );
    ASSERT( ParentObjectType != OBJECT_TYPE_ROOT );
    ASSERT( ChildObjectType != OBJECT_TYPE_ADMIN_MANAGER );

    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonDeleteObject: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( ParentGenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           FALSE,   // No need to refresh the cache on a delete
                                           ParentObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedParentObject = ParentGenericObject;


    //
    // Capture the object name string from the caller
    //

    WinStatus = AzpCaptureString( &ChildObjectNameString,
                                  ChildObjectName,
                                  MaxObjectNameLength[ChildObjectType],
                                  FALSE );  // NULL names not OK

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Find the object to delete.
    //

    WinStatus = ObReferenceObjectByName( GenericChildHead,
                                         &ChildObjectNameString,
                                         FALSE,    // no need to refresh the cache
                                         &ChildGenericObject );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Actually, delete the object
    //

    WinStatus = AzpPersistSubmit( ChildGenericObject, TRUE );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }


    //
    // Mark the entry (and its child objects) as deleted
    //  We do this since other threads may have references to the objects.
    //  We want to ensure those threads know the objects are deleted.
    //

    ObMarkObjectDeleted( ChildGenericObject );


    //
    // Remove the reference representing the list from the parent.
    //

    ObDereferenceObject( ChildGenericObject );


    //
    // Return to the caller
    //

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedParentObject != NULL ) {
        ObDereferenceObject( ReferencedParentObject );
    }

    if ( ChildGenericObject != NULL ) {
        ObDereferenceObject( ChildGenericObject );
    }

    AzpFreeString( &ChildObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


VOID
ObInitObjectList(
    IN OUT PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT_LIST NextGenericObjectList OPTIONAL,
    IN BOOL IsBackLink,
    IN ULONG LinkPairId,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead0 OPTIONAL,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead1 OPTIONAL,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead2 OPTIONAL
    )
/*++

Routine Description

    Initialize a list of generic objects.

    The caller must call ObFreeObjectList after calling this routine.

Arguments

    GenericObjectList - Specifies the object list to initialize

    NextGenericObjectList - Specifies a pointer to the next GenericObjectList
        that is hosted in the same generic object as this one.

    IsBackLink - TRUE if the link is a backlink
        See GENERIC_OBJECT_LIST definition.

    LinkPairId - LinkPairId for this object list.
        See GENERIC_OBJECT_LIST definition.

    GenericObjectHeadN - Specifies a pointer to the head of the list of objects
        that are candidates for being pointed to by the object list.

        If this object list is maintained by an external API (and not a "back" list),
        then at least one GenericObjectHead must be specified.

        If this is a back list, all GenericObjectHeads must be NULL.

Return Value

    None

--*/
{

    //
    // Initialize most fields to zero
    //

    RtlZeroMemory( GenericObjectList, sizeof(*GenericObjectList) );

    //
    // Initialize the pointer to the next generic object list for this object
    //

    GenericObjectList->NextGenericObjectList = NextGenericObjectList;

    //
    // Initialize the link pair information
    //

    GenericObjectList->IsBackLink = IsBackLink;
    GenericObjectList->LinkPairId = LinkPairId;

    //
    // Initialize the pointers to the object heads
    //

    GenericObjectList->GenericObjectHeads[0] = GenericObjectHead0;
    GenericObjectList->GenericObjectHeads[1] = GenericObjectHead1;
    GenericObjectList->GenericObjectHeads[2] = GenericObjectHead2;

    AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: ObInitObjectList\n", &GenericObjectList->GenericObjects, GenericObjectList->GenericObjects.Array ));

}

//
// Table of mappings to backlink object list tables
//

struct {
    ULONG LinkFromObjectType;
    ULONG LinkToObjectType;
    BOOL IsBackLink;
    ULONG LinkPairId;
    ULONG ObjectListOffset;
} ObjectListOffsetTable[] = {
    { OBJECT_TYPE_TASK,           OBJECT_TYPE_OPERATION,      FALSE, 0,                        offsetof(_AZP_TASK, Operations) },
    { OBJECT_TYPE_OPERATION,      OBJECT_TYPE_TASK,           TRUE,  0,                        offsetof(_AZP_OPERATION, backTasks) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_GROUP,          FALSE, AZP_LINKPAIR_MEMBERS,     offsetof(_AZP_GROUP, AppMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_GROUP,          TRUE,  AZP_LINKPAIR_MEMBERS,     offsetof(_AZP_GROUP, backAppMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_GROUP,          FALSE, AZP_LINKPAIR_NON_MEMBERS, offsetof(_AZP_GROUP, AppNonMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_GROUP,          TRUE,  AZP_LINKPAIR_NON_MEMBERS, offsetof(_AZP_GROUP, backAppNonMembers) },
    { OBJECT_TYPE_ROLE,           OBJECT_TYPE_GROUP,          FALSE, 0,                        offsetof(_AZP_ROLE, AppMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_ROLE,           TRUE,  0,                        offsetof(_AZP_GROUP, backRoles) },
    { OBJECT_TYPE_ROLE,           OBJECT_TYPE_OPERATION,      FALSE, 0,                        offsetof(_AZP_ROLE, Operations) },
    { OBJECT_TYPE_OPERATION,      OBJECT_TYPE_ROLE,           TRUE,  0,                        offsetof(_AZP_OPERATION, backRoles) },
    { OBJECT_TYPE_ROLE,           OBJECT_TYPE_SCOPE,          FALSE, 0,                        offsetof(_AZP_ROLE, Scopes) },
    { OBJECT_TYPE_SCOPE,          OBJECT_TYPE_ROLE,           TRUE,  0,                        offsetof(_AZP_SCOPE, backRoles) },
    { OBJECT_TYPE_JUNCTION_POINT, OBJECT_TYPE_APPLICATION,    FALSE, 0,                        offsetof(_AZP_JUNCTION_POINT, Applications) },
    { OBJECT_TYPE_APPLICATION,    OBJECT_TYPE_JUNCTION_POINT, TRUE,  0,                        offsetof(_AZP_APPLICATION, backJunctionPoints) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_SID_MEMBERS, offsetof(_AZP_GROUP, SidMembers) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_GROUP,          TRUE,  AZP_LINKPAIR_SID_MEMBERS, offsetof(_AZP_SID, backGroupMembers) },
    { OBJECT_TYPE_GROUP,          OBJECT_TYPE_SID,            FALSE, AZP_LINKPAIR_SID_NON_MEMBERS, offsetof(_AZP_GROUP, SidNonMembers) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_GROUP,          TRUE,  AZP_LINKPAIR_SID_NON_MEMBERS, offsetof(_AZP_SID, backGroupNonMembers) },
    { OBJECT_TYPE_ROLE,           OBJECT_TYPE_SID,            FALSE, 0,                        offsetof(_AZP_ROLE, SidMembers) },
    { OBJECT_TYPE_SID,            OBJECT_TYPE_ROLE,           TRUE,  0,                        offsetof(_AZP_SID, backRoles) },
};


PGENERIC_OBJECT_LIST
ObGetObjectListPtr(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG LinkToObjectType,
    IN PGENERIC_OBJECT_LIST LinkToGenericObjectList
    )
/*++

Routine Description

    Returns a pointer to a GENERIC_OBJECT_LIST structure within the passed in
    GenericObject the is suitable for linking an object of type LinkToObjectType
    into.

Arguments

    GenericObject - Specifies the object the link is from.

    LinkToObjectType - Specifies the object type the link is to.

    LinkToGenericObjectList - Specifies a pointer to the generic object list
        structure that is within the LinkToGenericObject.

Return Value

    Returns a pointer to the generic object list.

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList = NULL;
    ULONG i;


    //
    // Compute the address of the generic address list the object is in.
    //      We could do this more generically, but that would scatter this data
    //      over too wide an array.
    //

    for ( i=0; i<sizeof(ObjectListOffsetTable)/sizeof(ObjectListOffsetTable[0]); i++ ) {

        //
        // Find the entry in the table that matches our situation
        //

        if ( GenericObject->ObjectType == ObjectListOffsetTable[i].LinkFromObjectType &&
             LinkToObjectType == ObjectListOffsetTable[i].LinkToObjectType &&
             LinkToGenericObjectList->IsBackLink != ObjectListOffsetTable[i].IsBackLink &&
             LinkToGenericObjectList->LinkPairId == ObjectListOffsetTable[i].LinkPairId ) {

            GenericObjectList = (PGENERIC_OBJECT_LIST)
                (((LPBYTE)GenericObject)+(ObjectListOffsetTable[i].ObjectListOffset));
        }
    }

    ASSERT( GenericObjectList != NULL );

    return GenericObjectList;

}


VOID
ObRemoveObjectListLink(
    IN PGENERIC_OBJECT LinkFromGenericObject,
    IN PGENERIC_OBJECT LinkToGenericObject,
    IN PGENERIC_OBJECT_LIST LinkToGenericObjectList
    )
/*++

Routine Description

    Remove the link from LinkedFromGenericObject to LinkToGenericObject.

    On entry, AzGlResource must be locked exclusive.

Arguments

    LinkFromGenericObject - Specifies the object the link is from

    LinkToGenericObject - Specifies the object the link is to

    LinkToGenericObjectList - Specifies a pointer to the generic object list
        structure that is within the LinkToGenericObject.  (Notice, this isn't
        the object list we're removing LinkFromGenericObject from.  This is the
        'other' object list.)

Return Value

    None

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Get a pointer to the object list to remove this entry from
    //

    GenericObjectList = ObGetObjectListPtr( LinkFromGenericObject,
                                            LinkToGenericObject->ObjectType,
                                            LinkToGenericObjectList );

    ASSERT( GenericObjectList != NULL );


    //
    // Remove the entry from the list
    //

    AzpRemovePtrByPtr( &GenericObjectList->GenericObjects, LinkToGenericObject );

}

DWORD
ObLookupPropertyItem(
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName,
    OUT PULONG InsertionPoint OPTIONAL
    )
/*++

Routine Description:

    This routine determins if the specified object name is already in the
    object list.

    On entry, AzGlResource must be locked share

Arguments:

    GenericObjectList - Specifies the object list to be searched

    ObjectName - Specifies the ObjectName to lookup

    InsertionPoint - On ERROR_NOT_FOUND, returns the point where one would insert the named
        object.  On ERROR_ALREADY_EXISTS, returns an index to the object.

Return Value:

    ERROR_ALREADY_EXISTS - An object by that name already exists in the list

    ERROR_NOT_FOUND - There is no object by that name

    Misc other failure statuses.

--*/
{
    DWORD WinStatus = NO_ERROR;
    ULONG i;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    //
    // Loop through the existing list of names finding the insertion point.
    //  The list is maintained in alphabetical order.
    //  ??? Could be binary search
    //

    for ( i=0; i<GenericObjectList->GenericObjects.UsedCount; i++ ) {
        PGENERIC_OBJECT ExistingObject;
        LONG CompareResult;


        ExistingObject= (PGENERIC_OBJECT) (GenericObjectList->GenericObjects.Array[i]);

        CompareResult = AzpCompareStrings( ObjectName,
                                           &ExistingObject->ObjectName );

        if ( CompareResult == 0 ) {
            WinStatus = GetLastError();
            goto Cleanup;
        } else if ( CompareResult == CSTR_EQUAL ) {
            if ( InsertionPoint != NULL ) {
                *InsertionPoint = i;
            }
            WinStatus = ERROR_ALREADY_EXISTS;
            goto Cleanup;
        } else if ( CompareResult == CSTR_LESS_THAN ) {
            break;
        }

    }

    if ( InsertionPoint != NULL ) {
        *InsertionPoint = i;
    }
    WinStatus = ERROR_NOT_FOUND;


    //
    // Free any local resources
    //
Cleanup:

    return WinStatus;
}


DWORD
ObAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName
    )
/*++

Routine Description:

    Adds an object to the list of objects specified by GenericObjectList.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object the link is from

    GenericObjectList - Specifies the object list to add the object into.

    ObjectName - Specifies a pointer to name of the object to add.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_FOUND - There is no object by that name

    ERROR_ALREADY_EXISTS - An object by that name already exists in the list

--*/
{
    DWORD WinStatus;
    ULONG InsertionPoint;
    ULONG ObjectTypeIndex;

    PGENERIC_OBJECT FoundGenericObject = NULL;
    PGENERIC_OBJECT_LIST BackGenericObjectList;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Loop through the various lists of objects that can be referenced
    //

    for ( ObjectTypeIndex=0; ObjectTypeIndex<GEN_OBJECT_HEAD_COUNT; ObjectTypeIndex++ ) {

        //
        // Stop when there are no more lists to search
        //

        if ( GenericObjectList->GenericObjectHeads[ObjectTypeIndex] == NULL ) {
            break;
        }

        //
        // Find the specified object in this list
        //

        WinStatus = ObReferenceObjectByName(
                                GenericObjectList->GenericObjectHeads[ObjectTypeIndex],
                                ObjectName,
                                FALSE,  // No need to refresh the cache
                                &FoundGenericObject );


        if ( WinStatus == NO_ERROR ) {
            break;
        }

        //
        // If this is a link to a SID object,
        //  create the SID object.
        //
        // AzpSids are pseudo objects that come into existence as they are needed.
        //

        if ( AzpIsSidList( GenericObjectList ) ) {

            WinStatus = ObCreateObject(
                        GenericObjectList->GenericObjectHeads[0]->ParentGenericObject,
                        GenericObjectList->GenericObjectHeads[0],
                        OBJECT_TYPE_SID,
                        ObjectName,
                        &FoundGenericObject );


            if ( WinStatus != NO_ERROR ) {
                goto Cleanup;
            }

        }

    }

    //
    // If none of the lists had an object by the requested name,
    //  complain.
    //

    if ( FoundGenericObject == NULL ) {
        WinStatus = ERROR_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Prevent a reference to ourself
    //

    if ( GenericObject == FoundGenericObject ) {
        AzPrint(( AZD_INVPARM, "Reference to self\n" ));
        WinStatus = ERROR_DS_LOOP_DETECT;
        goto Cleanup;
    }

    //
    // Call the object specific routine to validate the request
    //

    if ( ObjectAddPropertyItemRoutine[GenericObject->ObjectType] != NULL ) {

        WinStatus = ObjectAddPropertyItemRoutine[GenericObject->ObjectType](
                    GenericObject,
                    GenericObjectList,
                    FoundGenericObject );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

    }



    //
    // Find the insertion point for this name.
    //

    WinStatus = ObLookupPropertyItem( GenericObjectList,
                                      ObjectName,
                                      &InsertionPoint );

    if ( WinStatus != ERROR_NOT_FOUND ) {
        goto Cleanup;
    }

    //
    // Insert the generic object into the list
    //

    WinStatus = AzpAddPtr(
        &GenericObjectList->GenericObjects,
        FoundGenericObject,
        InsertionPoint );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }



    //
    // Get a pointer to the backlink object list
    //

    BackGenericObjectList = ObGetObjectListPtr( FoundGenericObject,
                                                GenericObject->ObjectType,
                                                GenericObjectList );

    ASSERT( BackGenericObjectList != NULL );

    //
    // Maintain a back link from the generic object we just linked to back
    //  to this object.
    //

    WinStatus = AzpAddPtr(
        &BackGenericObjectList->GenericObjects,
        GenericObject,
        AZP_ADD_ENDOFLIST );

    if ( WinStatus != NO_ERROR ) {

        // Undo the forward link
        AzpRemovePtrByIndex( &GenericObjectList->GenericObjects, InsertionPoint );
        goto Cleanup;
    }


    //
    // Return to the caller
    //

    WinStatus = NO_ERROR;



    //
    // Free locally used resources
    //
Cleanup:

    if ( FoundGenericObject != NULL ) {
        ObDereferenceObject( FoundGenericObject );
    }

    return WinStatus;
}


DWORD
ObCommonAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG ObjectType,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN DWORD Reserved,
    IN LPWSTR ObjectName
    )
/*++

Routine Description:

    Adds an object to the list of objects specified by GenericObjectList.

Arguments:

    GenericObject - Specifies a handle to the object to add the object to.
        This "handle" has been passed from the application and needs to be verified.

    ObjectType - Specifies the object type of GenericObject.

    GenericObjectList - Specifies the object list to add the object into.
        This is a computed pointer and is considered untrustworthy
        until GenericObject has been verified.

    Reserved - Reserved.  Must by zero.

    ObjectName - Specifies a pointer to name of the object to add.


Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_FOUND - There is no object by that name

    ERROR_ALREADY_EXISTS - An object by that name already exists in the list

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedObject = NULL;

    AZP_STRING ObjectNameString;



    //
    // Initialization
    //

    AzpInitString( &ObjectNameString, NULL );

    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonAddPropertyItem: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedObject = GenericObject;


    //
    // Capture the object name string from the caller
    //

    if ( AzpIsSidList( GenericObjectList ) ) {
        WinStatus = AzpCaptureSid( &ObjectNameString,
                                   ObjectName );
    } else {
        WinStatus = AzpCaptureString( &ObjectNameString,
                                      ObjectName,
                                      AZ_MAX_NAME_LENGTH,   // Don't need to validate size exactly
                                      FALSE );  // NULL names not OK
    }

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Actually add the property item
    //

    WinStatus = ObAddPropertyItem( GenericObject,
                                   GenericObjectList,
                                   &ObjectNameString );


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedObject != NULL ) {
        ObDereferenceObject( ReferencedObject );
    }

    AzpFreeString( &ObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


DWORD
ObRemovePropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName
    )
/*++

Routine Description:

    Removes a generic object from the list of items specified by GenericObjectList

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object the link is from.

    GenericObjectList - Specifies the obejct list to remote the object from.

    ObjectName - Specifies a pointer to the name of the object to remove.


Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_FOUND - There is no object by that name in the list

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT FoundGenericObject;
    ULONG InsertionPoint;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Lookup that name in the object list
    //

    WinStatus = ObLookupPropertyItem( GenericObjectList,
                                      ObjectName,
                                      &InsertionPoint );

    if ( WinStatus != ERROR_ALREADY_EXISTS ) {
        return WinStatus;
    }

    FoundGenericObject = (PGENERIC_OBJECT) (GenericObjectList->GenericObjects.Array[InsertionPoint]);

    //
    // Remove the object from the list
    //

    AzpRemovePtrByIndex( &GenericObjectList->GenericObjects, InsertionPoint );

    //
    // Remove the back link, too
    //

    ObRemoveObjectListLink( FoundGenericObject, GenericObject, GenericObjectList );


    //
    // Return to the caller
    //

    return NO_ERROR;
}


DWORD
ObCommonRemovePropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG ObjectType,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN DWORD Reserved,
    IN LPWSTR ObjectName
    )
/*++

Routine Description:

    Removes a generic object from the list of items specified by GenericObjectList

Arguments:

    GenericObject - Specifies a handle to the object to remove the object from.
        This "handle" has been passed from the application and needs to be verified.

    ObjectType - Specifies the object type of GenericObject.

    GenericObjectList - Specifies the obejct list to remote the object from.
        This is a computed pointer and is considered untrustworthy
        until GenericObject has been verified.

    Reserved - Reserved.  Must by zero.

    ObjectName - Specifies a pointer to the name of the object to remove.


Return Value:

    NO_ERROR - The operation was successful.

    ERROR_NOT_FOUND - There is no object by that name in the list

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedObject = NULL;

    AZP_STRING ObjectNameString;


    //
    // Initialization
    //

    AzpInitString( &ObjectNameString, NULL );

    //
    // Grab the global lock
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "ObCommonRemovePropertyItem: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedObject = GenericObject;


    //
    // Capture the object name string from the caller
    //

    if ( AzpIsSidList( GenericObjectList ) ) {
        WinStatus = AzpCaptureSid( &ObjectNameString,
                                   ObjectName );
    } else {
        WinStatus = AzpCaptureString( &ObjectNameString,
                                      ObjectName,
                                      AZ_MAX_NAME_LENGTH,   // Don't need to validate size exactly
                                      FALSE );  // NULL names not OK
    }

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Remove the item from the list and backlist
    //

    WinStatus = ObRemovePropertyItem( GenericObject,
                                      GenericObjectList,
                                      &ObjectNameString );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Mark the object as needing to be written
    //

    GenericObject->Flags |= GENOBJ_FLAGS_DIRTY;


    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedObject != NULL ) {
        ObDereferenceObject( ReferencedObject );
    }

    AzpFreeString( &ObjectNameString );

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;
}


PAZ_STRING_ARRAY
ObGetPropertyItems(
    IN PGENERIC_OBJECT_LIST GenericObjectList
    )
/*++

Routine Description:

    Return a list of generic object names as an array of object name strings.

    On entry, AzGlResource must be locked shared

Arguments:

    GenericObjectList - Specifies the object list to get the entries for.

Return Value:

    Returns the array of object name strings in a single allocated buffer.
        Free the buffer using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    PAZP_PTR_ARRAY GenericObjects;
    ULONG i;

    ULONG Size;
    LPBYTE Where;

    PGENERIC_OBJECT GenericObject;

    PAZ_STRING_ARRAY StringArray;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    GenericObjects = &GenericObjectList->GenericObjects;


    //
    // Loop through the list of objects computing the size of the buffer to allocate
    //

    Size = 0;

    for ( i=0; i<GenericObjects->UsedCount; i++ ) {

        GenericObject = (PGENERIC_OBJECT) (GenericObjects->Array[i]);

        Size += GenericObject->ObjectName.StringSize;

    }

    //
    // Allocate a buffer to return to the caller
    //

    Size += sizeof(AZ_STRING_ARRAY) + (GenericObjects->UsedCount * sizeof(LPWSTR));

    StringArray = (PAZ_STRING_ARRAY) AzpAllocateHeap( Size );

    if ( StringArray == NULL ) {
        return NULL;
    }

    StringArray->StringCount = GenericObjects->UsedCount;
    StringArray->Strings = (LPWSTR *)(StringArray+1);
    Where = (LPBYTE)(&StringArray->Strings[GenericObjects->UsedCount]);


    //
    // Loop through the list of objects copying the names into the return buffer
    //

    for ( i=0; i<GenericObjects->UsedCount; i++ ) {

        GenericObject = (PGENERIC_OBJECT) (GenericObjects->Array[i]);

        StringArray->Strings[i] = (LPWSTR) Where;

        RtlCopyMemory( Where,
                       GenericObject->ObjectName.String,
                       GenericObject->ObjectName.StringSize );

        Where += GenericObject->ObjectName.StringSize;

    }

    ASSERT( (ULONG)(Where - (LPBYTE)StringArray) == Size );

    return StringArray;

}

VOID
ObRemoveObjectListLinks(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN BackwardLinksToo
    )
/*++

Routine Description

    Remove any links to/from the specified object.

    On entry, AzGlResource must be locked exclusive.

Arguments

    GenericObject - Specifies the object to remove links to/from

    BackwardLinksToo - TRUE if the back links are to be removed to.

Return Value

    None

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;
    PGENERIC_OBJECT OtherGenericObject;
    ULONG Index;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Walk all of the GenericObjectLists rooted on by this object
    //
    // The GenericObjectList may be forward links or backward links.  We don't care.
    // All links must be removed.
    //

    for ( GenericObjectList = GenericObject->GenericObjectLists;
          GenericObjectList != NULL;
          GenericObjectList = GenericObjectList->NextGenericObjectList ) {


        //
        // Skip back links if the caller wants them left
        //

        if ( !BackwardLinksToo && GenericObjectList->IsBackLink ) {
            continue;
        }

        AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: %ld: ObRemoveObjectListLinks\n", &GenericObjectList->GenericObjects, GenericObjectList->GenericObjects.Array, GenericObjectList->GenericObjects.UsedCount ));


        //
        // Walk the list removing the current entry and removing the corresponding
        //  pointer back.
        //

        while ( GenericObjectList->GenericObjects.UsedCount != 0 ) {

            //
            // Remove the last entry in the list
            //

            Index = GenericObjectList->GenericObjects.UsedCount - 1;

            OtherGenericObject = (PGENERIC_OBJECT)
                    (GenericObjectList->GenericObjects.Array[Index]);

            AzpRemovePtrByIndex( &GenericObjectList->GenericObjects,
                                 Index );

            //
            // Remove the entry in the opposite direction
            //

            ObRemoveObjectListLink( OtherGenericObject,
                                    GenericObject,
                                    GenericObjectList );

        }

        //
        // Free the array itself
        //

        ObFreeObjectList( GenericObjectList );
    }

}

VOID
ObFreeObjectList(
    IN OUT PGENERIC_OBJECT_LIST GenericObjectList
    )
/*++

Routine Description:

    Free any memory pointed to by an array of object name strings.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObjectList - Specifies the object list to free.

Return Value:

    Returns the array of object name strings in a single allocated buffer.
        Free the buffer using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    PAZP_PTR_ARRAY GenericObjects;

    //
    // Initialization
    //

    AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: ObFreeObjectList\n", &GenericObjectList->GenericObjects, GenericObjectList->GenericObjects.Array ));
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    GenericObjects = &GenericObjectList->GenericObjects;
    ASSERT( GenericObjects->UsedCount == 0 );


    //
    // Free the actual array
    //

    if ( GenericObjects->Array != NULL ) {
        AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: Free array\n", GenericObjects, GenericObjects->Array ));
        AzpFreeHeap( GenericObjects->Array );
        GenericObjects->Array = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\genobj.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    genobj.h

Abstract:

    Definitions for the generic object implementation.

    AZ roles has so many objects that need creation, enumeration, etc
    that it seems prudent to have a single body of code for doing those operations.


Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// A generic object list head.
//
// This structure represent the head of a linked list of objects.  The linked
// list of objects are considered to be "children" of this structure.
//

typedef struct _GENERIC_OBJECT_HEAD {

    //
    // Head of the linked list of objects
    //

    LIST_ENTRY Head;

    //
    // Back pointer to the GenericObject containing this structure
    //

    struct _GENERIC_OBJECT *ParentGenericObject;


    //
    // Each of the list heads that are rooted on a single object are linked
    //  together.  That list is headed by GENERIC_OBJECT->ChildGenericObjectHead.
    //  This field is a pointer to the next entry in the list.
    //

    struct _GENERIC_OBJECT_HEAD *SiblingGenericObjectHead;

    //
    // This is a circular list of all the GENERIC_OBJECT_HEAD structures of
    //  objects that share a namespace. For instance, an AzOperation and AzTask object
    //  may not have the same name.
    //

    LIST_ENTRY SharedNamespace;

    //
    // The next sequence number to give out.
    //

    ULONG NextSequenceNumber;

    //
    // Object type of objects in this list
    //

    ULONG ObjectType;

    //
    // The order of the defines below must match the tables at the top of genobj.cxx
    //
#define OBJECT_TYPE_ROOT            0
#define OBJECT_TYPE_ADMIN_MANAGER   1
#define OBJECT_TYPE_APPLICATION     2
#define OBJECT_TYPE_OPERATION       3
#define OBJECT_TYPE_TASK            4
#define OBJECT_TYPE_SCOPE           5
#define OBJECT_TYPE_GROUP           6
#define OBJECT_TYPE_ROLE            7
#define OBJECT_TYPE_JUNCTION_POINT  8
#define OBJECT_TYPE_SID             9
#define OBJECT_TYPE_CLIENT_CONTEXT 10
#define OBJECT_TYPE_MAXIMUM        11


} GENERIC_OBJECT_HEAD, *PGENERIC_OBJECT_HEAD;

//
// A generic object
//

typedef struct _GENERIC_OBJECT {

    //
    // Link to the next instance of an object of this type for the same parent object
    //

    LIST_ENTRY Next;

    //
    // Back pointer to the head of the list this object is in
    //

    PGENERIC_OBJECT_HEAD ParentGenericObjectHead;

    //
    // Pointer to the list heads for children of this object
    //  This is a static list of the various GENERIC_OBJECT_HEAD structures
    //  that exist in the object type specific portion of this object.
    //  The list allows the generic object code to have insight into the
    //  children of this object.
    //

    PGENERIC_OBJECT_HEAD ChildGenericObjectHead;

    //
    // Pointer to the list heads of pointers to other objects
    //  This is a static list of the various GENERIC_OBJECT_LIST structures
    //  that exist in the object type specific portion of this object.
    //  The list allows the generic object code to have insight into the
    //  other types of objects pointed to by this object.
    //

    struct _GENERIC_OBJECT_LIST *GenericObjectLists;

    //
    // Pointer to the generic object at the root of all generic objects
    //  (Pointer to an AdminManager object)
    //

    struct _AZP_ADMIN_MANAGER *AdminManagerObject;


    //
    // Name of the object
    //

    AZP_STRING ObjectName;


    //
    // Description of the object
    //

    AZP_STRING Description;

    //
    // GUID of the object
    //  The Guid of the object is assigned by the persistence provider.
    //  The GUID is needed to make the object rename safe.
    //

    GUID PersistenceGuid;


    //
    // Number of references to this instance of the object
    //  These are references from within our code.
    //

    LONG ReferenceCount;

    //
    // Number of references to this instance of the object
    //  These are references represented by handles passed back to our caller.
    //

    LONG HandleReferenceCount;

    //
    // Sequence number of this object.
    //  The list specified in Next is maintained in SequenceNumber order.
    //  New entries are added to the tail end.
    //  Enumerations are returned in SequenceNumber order.
    //  SequenceNumber is returned to the caller as the EnumerationContext.
    //
    // This mechanism allows insertions and deletions to be handled seemlessly.
    //

    ULONG SequenceNumber;

    //
    // Specific object type represented by this generic object
    //

    ULONG ObjectType;

    //
    // Flags describing attributes of the generic object
    //

    ULONG Flags;

#define GENOBJ_FLAGS_DELETED    0x01    // Object has been deleted
#define GENOBJ_FLAGS_DIRTY      0x02    // Object has been modified
#define GENOBJ_FLAGS_REFRESH_ME 0x04    // Object needs to be refreshed from cache

} GENERIC_OBJECT, *PGENERIC_OBJECT;

//
// Object List
//
// Some objects have lists of references to other objects.  These lists are
//  not parent/child relationships.  Rather they represent memberships, etc.
//
// This structure represents the head of such a list.
//
// Both the pointed-from and pointed-to object have a generic object list.  The
// "forward" link represents the list that is managed via external API.  The
// "backward" link is provided to allow fixup of references when an object is deleted.
// The "backward" link is also provided for cases where internal routines need to
// traverse the link relationship in the opposite direction of the external API.
// By convention, GENERIC_OBJECT_LIST instances in the forward direction are named
// simply by the name of the object to point to.  For instance, an object list that points
// to AZ_OPERATION objects might be called "Operations".  By convention, GENERIC_OBJECT_LIST
// instances in the backward direction are prefixed by the name "back".  For instance,
// "backTasks".
//
// Note, there really isn't any reason why we couldn't expose "AddPropertyItem" and
// "RemovePropertyItem" APIs for the "back" lists.  See the IsBackLink and LinkPairId
// definition.
//

typedef struct _GENERIC_OBJECT_LIST {

    //
    // Each of the object lists that are rooted on a single object are linked
    //  together.  That list is headed by GENERIC_OBJECT->GenericObjectLists.
    //  This field is a pointer to the next entry in the list.
    //

    struct _GENERIC_OBJECT_LIST *NextGenericObjectList;

    //
    // Since an object list is a list of other objects, we want to be able to
    //  generically find the other objects.  The array below is an array of pointers
    //  to the head of the lists that contain the other objects.
    //
    //
    // Unused elements in this array are set to NULL.
    //
    // These pointers are always pointers to a field in a "parent" structure.
    // Therefore, reference counts aren't needed.  Instead, the "child" structure
    // containing the pointer to the parent will be deleted before the parent structure.
    //

#define GEN_OBJECT_HEAD_COUNT 3
    PGENERIC_OBJECT_HEAD GenericObjectHeads[GEN_OBJECT_HEAD_COUNT];

    //
    // List identifier.
    //
    // The code maintains the link and the backlink.  To do that, the code needs to
    //  find one the "other" generic object list from this one.  That algorithm uses
    //  the IsBackLink and LinkPairId field.
    //
    // One object list has IsBackLink set TRUE and the other set FALSE.  This handles
    // the case where an object contain both a forward an backward object list.  For
    // instance, the AZ_GROUP object contains the AppMembers and backAppMembers fields.
    // This field differentiates between the two.
    //
    // There are cases where an object has multiple links between the same object types.
    // For instance, the AZ_GROUP object has both AppMembers and AppNonMembers links.
    // In those cases, the LinkPairId is set to a unique value to identify the pair.
    // In most cases, the value is simply zero.
    //
    BOOL IsBackLink;
    ULONG LinkPairId;

#define AZP_LINKPAIR_MEMBERS         1
#define AZP_LINKPAIR_NON_MEMBERS     2
#define AZP_LINKPAIR_SID_MEMBERS     3
#define AZP_LINKPAIR_SID_NON_MEMBERS 4


    //
    // The array of pointers to the generic objects.
    //
    // Being in this list does not increment the ReferenceCount on the pointed-to
    // generic object.
    //

    AZP_PTR_ARRAY GenericObjects;

} GENERIC_OBJECT_LIST, *PGENERIC_OBJECT_LIST;


/////////////////////////////////////////////////////////////////////////////
//
// Macro definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Macro to determine if a GENERIC_OBJECT_LIST is a list of sids
//

#define AzpIsSidList( _gol ) \
    ((_gol)->GenericObjectHeads[0] != NULL && \
     (_gol)->GenericObjectHeads[0]->ObjectType == OBJECT_TYPE_SID )



/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

VOID
ObInitGenericHead(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN ULONG ObjectType,
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT_HEAD SiblingGenericObjectHead OPTIONAL,
    IN PGENERIC_OBJECT_HEAD SharedNamespace OPTIONAL
    );

PGENERIC_OBJECT
ObAllocateGenericObject(
    IN ULONG ObjectType
    );

VOID
ObFreeGenericObject(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN JustRefresh
    );

VOID
ObInsertGenericObject(
    IN PGENERIC_OBJECT_HEAD GenericObjectHead,
    IN PGENERIC_OBJECT GenericObject
    );

VOID
ObIncrHandleRefCount(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
ObDecrHandleRefCount(
    IN PGENERIC_OBJECT GenericObject
    );

DWORD
ObGetHandleType(
    IN PGENERIC_OBJECT Handle,
    IN BOOL AllowDeletedObjects,
    OUT PULONG ObjectType
    );

DWORD
ObReferenceObjectByHandle(
    IN PGENERIC_OBJECT Handle,
    IN BOOL AllowDeletedObjects,
    IN BOOLEAN RefreshCache,
    IN ULONG ObjectType
    );

VOID
ObDereferenceObject(
    IN PGENERIC_OBJECT GenericObject
    );

typedef DWORD
(OBJECT_INIT_ROUTINE)(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

typedef VOID
(OBJECT_FREE_ROUTINE)(
    IN PGENERIC_OBJECT GenericObject
    );

typedef DWORD
(OBJECT_GET_PROPERTY_ROUTINE)(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

typedef DWORD
(OBJECT_SET_PROPERTY_ROUTINE)(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

typedef DWORD
(OBJECT_ADD_PROPERTY_ITEM_ROUTINE)(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    );

DWORD
ObCreateObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN PAZP_STRING ChildObjectNameString,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObCommonCreateObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObCommonOpenObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObEnumObjects(
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN BOOL EnumerateDeletedObjects,
    IN BOOL RefreshCache,
    IN OUT PULONG EnumerationContext,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObCommonEnumObjects(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN OUT PULONG EnumerationContext,
    IN DWORD Reserved,
    OUT PGENERIC_OBJECT *RetChildGenericObject
    );

DWORD
ObCommonGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG ObjectType,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    );

DWORD
ObCommonSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG ObjectType,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    );

VOID
ObMarkObjectDeleted(
    IN PGENERIC_OBJECT GenericObject
    );

DWORD
ObCommonDeleteObject(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN ULONG ParentObjectType,
    IN PGENERIC_OBJECT_HEAD GenericChildHead,
    IN ULONG ChildObjectType,
    IN LPCWSTR ChildObjectName,
    IN DWORD Reserved
    );

VOID
ObInitObjectList(
    IN OUT PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT_LIST NextGenericObjectList OPTIONAL,
    IN BOOL IsBackLink,
    IN ULONG LinkPairId,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead0 OPTIONAL,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead1 OPTIONAL,
    IN PGENERIC_OBJECT_HEAD GenericObjectHead2 OPTIONAL
    );

DWORD
ObAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName
    );

DWORD
ObCommonAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG ObjectType,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN DWORD Reserved,
    IN LPWSTR ObjectName
    );

DWORD
ObLookupPropertyItem(
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN AZP_STRING ObjectName,
    OUT PULONG InsertionPoint OPTIONAL
    );

DWORD
ObRemovePropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PAZP_STRING ObjectName
    );

DWORD
ObCommonRemovePropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG ObjectType,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN DWORD Reserved,
    IN LPWSTR ObjectName
    );

PAZ_STRING_ARRAY
ObGetPropertyItems(
    IN PGENERIC_OBJECT_LIST GenericObjectList
    );

VOID
ObRemoveObjectListLinks(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN BackwardLinksToo
    );

VOID
ObFreeObjectList(
    IN OUT PGENERIC_OBJECT_LIST GenericObjectList
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\group.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    group.cxx

Abstract:

    Routines implementing the Group object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"



DWORD
AzpGroupInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzGroupCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_GROUP Group = (PAZP_GROUP) ChildGenericObject;
    PAZP_ADMIN_MANAGER AdminManager = NULL;
    PAZP_APPLICATION Application = NULL;
    PAZP_SCOPE Scope = NULL;
    PGENERIC_OBJECT_HEAD ParentSids = NULL;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //
    // A group references SID objects that are siblings of itself.
    // That way, the back links on the SID object references just the groups
    // that are siblings of the SID object.
    //

    if ( ParentGenericObject->ObjectType == OBJECT_TYPE_ADMIN_MANAGER ) {
        AdminManager = (PAZP_ADMIN_MANAGER) ParentGenericObject;
        ParentSids = &AdminManager->AzpSids;

    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {
        AdminManager = ParentGenericObject->AdminManagerObject;
        Application = (PAZP_APPLICATION) ParentGenericObject;
        ParentSids = &Application->AzpSids;

    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE ) {
        AdminManager = ParentGenericObject->AdminManagerObject;
        Application = (PAZP_APPLICATION) ParentGenericObject->ParentGenericObjectHead->ParentGenericObject;
        Scope = (PAZP_SCOPE) ParentGenericObject;
        ParentSids = &Scope->AzpSids;

    } else {
        ASSERT( FALSE );
    }

    //
    // Groups reference other groups.
    //  These other groups can be siblings of this group or siblings of our parents.
    //
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &Group->AppMembers,
    ObInitObjectList( &Group->AppMembers,
                      &Group->AppNonMembers,
                      FALSE,    // Forward link
                      AZP_LINKPAIR_MEMBERS,
                      &AdminManager->Groups,
                      Application == NULL ? NULL : &Application->Groups,
                      Scope == NULL ? NULL : &Scope->Groups );

    // Same for non members
    ObInitObjectList( &Group->AppNonMembers,
                      &Group->backAppMembers,
                      FALSE,    // Forward link
                      AZP_LINKPAIR_NON_MEMBERS,
                      &AdminManager->Groups,
                      Application == NULL ? NULL : &Application->Groups,
                      Scope == NULL ? NULL : &Scope->Groups );

    // back links for the above
    ObInitObjectList( &Group->backAppMembers,
                      &Group->backAppNonMembers,
                      TRUE,     // backward link
                      AZP_LINKPAIR_MEMBERS,
                      NULL,
                      NULL,
                      NULL );

    ObInitObjectList( &Group->backAppNonMembers,
                      &Group->backRoles,
                      TRUE,     // backward link
                      AZP_LINKPAIR_NON_MEMBERS,
                      NULL,
                      NULL,
                      NULL );

    // Groups are referenced by "Roles"
    ObInitObjectList( &Group->backRoles,
                      &Group->SidMembers,
                      TRUE,     // Backward link
                      0,        // No link pair id
                      NULL,
                      NULL,
                      NULL );

    // Groups reference SID objects
    ObInitObjectList( &Group->SidMembers,
                      &Group->SidNonMembers,
                      FALSE,    // Forward link
                      AZP_LINKPAIR_SID_MEMBERS,
                      ParentSids,
                      NULL,
                      NULL );

    // Same for non members
    ObInitObjectList( &Group->SidNonMembers,
                      NULL,
                      FALSE,    // Forward link
                      AZP_LINKPAIR_SID_NON_MEMBERS,
                      ParentSids,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpGroupFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Group object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_GROUP Group = (PAZP_GROUP) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //

    AzpFreeString( &Group->LdapQuery );


}


DWORD
AzpGroupGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzGroupGetProperty.  It does any object specific
    property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_GROUP_TYPE                 PULONG - Group type of the group
        AZ_PROP_GROUP_APP_MEMBERS          AZ_STRING_ARRAY - Application groups that are members of this group
        AZ_PROP_GROUP_APP_NON_MEMBERS      AZ_STRING_ARRAY - Application groups that are non-members of this group
        AZ_PROP_GROUP_LDAP_QUERY           LPWSTR - Ldap query string of the group
        AZ_PROP_GROUP_MEMBERS              AZ_SID_ARRAY - NT sids that are members of this group
        AZ_PROP_GROUP_NON_MEMBERS          AZ_SID_ARRAY - NT sids that are non-members of this group

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_GROUP Group = (PAZP_GROUP) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //
    switch ( PropertyId ) {
    case AZ_PROP_GROUP_TYPE:

        *PropertyValue = AzpGetUlongProperty( Group->GroupType );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of app members to the caller
    case AZ_PROP_GROUP_APP_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Group->AppMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    case AZ_PROP_GROUP_APP_NON_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Group->AppNonMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of sid members to the caller
    case AZ_PROP_GROUP_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Group->SidMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    case AZ_PROP_GROUP_NON_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Group->SidNonMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    // Return ldap query string to the caller
    //
    case AZ_PROP_GROUP_LDAP_QUERY:

        *PropertyValue = AzpGetStringProperty( &Group->LdapQuery );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpGroupGetProperty: invalid opcode\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}


DWORD
AzpGroupSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzGroupSetProperty.  It does any object specific
    property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_GROUP_TYPE                 PULONG - Group type of the group
        AZ_PROP_GROUP_LDAP_QUERY           LPWSTR - Ldap query string of the group

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_GROUP Group = (PAZP_GROUP) GenericObject;
    AZP_STRING CapturedString;
    ULONG LocalGroupType;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpInitString( &CapturedString, NULL );


    //
    // Set the group type
    //

    switch ( PropertyId ) {
    case AZ_PROP_GROUP_TYPE:

        WinStatus = AzpCaptureUlong( PropertyValue, &LocalGroupType );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        if ( LocalGroupType != AZ_GROUPTYPE_LDAP_QUERY &&
             LocalGroupType != AZ_GROUPTYPE_MEMBERSHIP ) {

            AzPrint(( AZD_INVPARM, "AzpGroupGetProperty: invalid grouptype %ld\n", LocalGroupType ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;

        }

        Group->GroupType = LocalGroupType;

        break;

    //
    // Set LDAP Query string on the object
    //
    case AZ_PROP_GROUP_LDAP_QUERY:

        //
        // Capture the input string
        //

        WinStatus = AzpCaptureString( &CapturedString,
                                      (LPWSTR) PropertyValue,
                                      AZ_MAX_GROUP_LDAP_QUERY_LENGTH,
                                      TRUE ); // NULL is OK

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Only allow this propery if the group type is right
        //  (But let them clear it out)
        //

        if ( Group->GroupType != AZ_GROUPTYPE_LDAP_QUERY  &&
             CapturedString.StringSize != 0 ) {

            AzPrint(( AZD_INVPARM, "AzpGroupSetProperty: can't set ldap query before group type\n" ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        //
        // Swap the old/new names
        //

        AzpSwapStrings( &CapturedString, &Group->LdapQuery );
        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpGroupSetProperty: invalid propid %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Free any local resources
    //
Cleanup:
    AzpFreeString( &CapturedString );

    return WinStatus;
}

DWORD
AzpGroupCheckRefLoop(
    IN PAZP_GROUP ParentGroup,
    IN PAZP_GROUP CurrentGroup,
    IN ULONG GenericObjectListOffset
    )
/*++

Routine Description:

    This routine determines whether the group members of "CurrentGroup"
    reference "ParentGroup".  This is done to detect loops where the
    group references itself directly or indirectly.

    On entry, AzGlResource must be locked shared.

Arguments:

    ParentGroup - Group that contains the original membership.

    CurrentGroup - Group that is currently being inspected to see if it
        loops back to ParentGroup

    GenericObjectListOffset -  Offset to the particular GenericObjectList being
        checked.

Return Value:

    Status of the operation
    ERROR_DS_LOOP_DETECT - A loop has been detected.

--*/
{
    ULONG WinStatus;

    PGENERIC_OBJECT_LIST GenericObjectList;
    ULONG i;
    PAZP_GROUP NextGroup;

    //
    // Check for a reference to ourself
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    if ( ParentGroup == CurrentGroup ) {
        return ERROR_DS_LOOP_DETECT;
    }

    //
    // Compute a pointer to the membership list to check
    //

    GenericObjectList = (PGENERIC_OBJECT_LIST)
        (((LPBYTE)CurrentGroup)+GenericObjectListOffset);

    //
    // Check all groups that are members of the current group
    //

    for ( i=0; i<GenericObjectList->GenericObjects.UsedCount; i++ ) {

        NextGroup = (PAZP_GROUP) (GenericObjectList->GenericObjects.Array[i]);


        //
        // Recursively check this group
        //

        WinStatus = AzpGroupCheckRefLoop( ParentGroup, NextGroup, GenericObjectListOffset );

        if ( WinStatus != NO_ERROR ) {
            return WinStatus;
        }

    }

    return NO_ERROR;

}


DWORD
AzpGroupAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzGroupAddPropertyItem.  It does any object specific
    property adds

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    GenericObjectList - Specifies the object list the object is to be added to

    LinkedToObject - Specifies the object that is being linked to

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_GROUP Group = (PAZP_GROUP) GenericObject;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // All item adds are membership additions.
    //  Ensure the group has the right group type.
    //

    if ( Group->GroupType != AZ_GROUPTYPE_MEMBERSHIP ) {
        AzPrint(( AZD_INVPARM, "AzpGroupAddPropertyItem: invalid group type %ld\n", Group->GroupType ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Ensure this newly added membership doesn't cause a group membership loop
    //

    if ( !AzpIsSidList( GenericObjectList ) ) {
        WinStatus = AzpGroupCheckRefLoop( Group,
                                          (PAZP_GROUP)LinkedToObject,
                                          (ULONG)(((LPBYTE)GenericObjectList)-((LPBYTE)Group)) );
    }


    //
    // Free any local resources
    //
Cleanup:

    return WinStatus;
}


DWORD
AzpGroupGetGenericChildHead(
    IN AZ_HANDLE ParentHandle,
    OUT PULONG ObjectType,
    OUT PGENERIC_OBJECT_HEAD *GenericChildHead
    )
/*++

Routine Description:

    This routine determines whether ParentHandle supports Group objects as
    children.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an Admin Manager handle, an Application Handle, or a
        Scope handle.

    ObjectType - Returns the object type of the ParentHandle.

    GenericChildHead - Returns a pointer to the head of the list of groups objects
        that are children of the object specified by ParentHandle.  This in an unverified
        pointer.  The pointer is only valid after ParentHandle has been validated.

Return Value:

    Status of the operation.

--*/
{
    DWORD WinStatus;

    //
    // Determine the type of the parent handle
    //

    WinStatus = ObGetHandleType( (PGENERIC_OBJECT)ParentHandle,
                                 FALSE, // ignore deleted objects
                                 ObjectType );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }


    //
    // Verify that the specified handle support children groups.
    //

    switch ( *ObjectType ) {
    case OBJECT_TYPE_ADMIN_MANAGER:

        *GenericChildHead = &(((PAZP_ADMIN_MANAGER)ParentHandle)->Groups);
        break;

    case OBJECT_TYPE_APPLICATION:

        *GenericChildHead = &(((PAZP_APPLICATION)ParentHandle)->Groups);
        break;

    case OBJECT_TYPE_SCOPE:

        *GenericChildHead = &(((PAZP_SCOPE)ParentHandle)->Groups);
        break;

    default:
        return ERROR_INVALID_HANDLE;
    }

    return NO_ERROR;
}



DWORD
WINAPI
AzGroupCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE GroupHandle
    )
/*++

Routine Description:

    This routine adds a group into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an Admin Manager handle, an Application Handle, or a
        Scope handle.

    GroupName - Specifies the name of the group to add.

    Reserved - Reserved.  Must by zero.

    GroupHandle - Return a handle to the group.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports groups as children
    //

    WinStatus = AzpGroupGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_GROUP,
                    GroupName,
                    Reserved,
                    (PGENERIC_OBJECT *) GroupHandle );

}



DWORD
WINAPI
AzGroupOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE GroupHandle
    )
/*++

Routine Description:

    This routine opens a group into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an Admin Manager handle, an Application Handle, or a
        Scope handle.

    GroupName - Specifies the name of the group to open

    Reserved - Reserved.  Must by zero.

    GroupHandle - Return a handle to the group.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no group by that name

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports groups as children
    //

    WinStatus = AzpGroupGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_GROUP,
                    GroupName,
                    Reserved,
                    (PGENERIC_OBJECT *) GroupHandle );
}


DWORD
WINAPI
AzGroupEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE GroupHandle
    )
/*++

Routine Description:

    Enumerates all of the groups for the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an Admin Manager handle, an Application Handle, or a
        Scope handle.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next group to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    GroupHandle - Returns a handle to the next group object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports groups as children
    //

    WinStatus = AzpGroupGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) GroupHandle );

}


DWORD
WINAPI
AzGroupGetProperty(
    IN AZ_HANDLE GroupHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for a group.

Arguments:

    GroupHandle - Specifies a handle to the group

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME                  LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION           LPWSTR - Description of the object
        AZ_PROP_GROUP_TYPE            PULONG - Group type of the group
        AZ_PROP_GROUP_APP_MEMBERS     AZ_STRING_ARRAY - Application groups that are members of this group
        AZ_PROP_GROUP_APP_NON_MEMBERS AZ_STRING_ARRAY - Application groups that are non-members of this group
        AZ_PROP_GROUP_LDAP_QUERY      LPWSTR - Ldap query string of the group
        AZ_PROP_GROUP_MEMBERS         AZ_SID_ARRAY - NT sids that are members of this group
        AZ_PROP_GROUP_NON_MEMBERS     AZ_SID_ARRAY - NT sids that are non-members of this group


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonGetProperty(
                    (PGENERIC_OBJECT) GroupHandle,
                    OBJECT_TYPE_GROUP,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzGroupSetProperty(
    IN AZ_HANDLE GroupHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for a group.

Arguments:

    GroupHandle - Specifies a handle to the group

    PropertyId - Specifies which property to set

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME               LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION        LPWSTR - Description of the object
        AZ_PROP_GROUP_TYPE         PULONG - Group type of the group

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonSetProperty(
                    (PGENERIC_OBJECT) GroupHandle,
                    OBJECT_TYPE_GROUP,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}



DWORD
WINAPI
AzGroupAddPropertyItem(
    IN AZ_HANDLE GroupHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Adds an item to the list of items specified by PropertyId.

Arguments:

    GroupHandle - Specifies a handle to the task

    PropertyId - Specifies which property to modify

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to item to add.
        The specified value and type depends on PropertyId.  The valid values are:

        AZ_PROP_GROUP_APP_MEMBERS          LPWSTR - Application groups that are members of this group
        AZ_PROP_GROUP_APP_NON_MEMBERS      LPWSTR - Application groups that are non-members of this group
        AZ_PROP_GROUP_MEMBERS              PSID - NT sids that are members of this group
        AZ_PROP_GROUP_NON_MEMBERS          PSID - NT sids that are non-members of this group


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

    ERROR_NOT_FOUND - There is no object by that name

    ERROR_ALREADY_EXISTS - An item by that name already exists in the list

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;

    //
    // Validate the Property ID
    //

    switch ( PropertyId ) {
    case AZ_PROP_GROUP_APP_MEMBERS:
        GenericObjectList = &((PAZP_GROUP)GroupHandle)->AppMembers;
        break;
    case AZ_PROP_GROUP_APP_NON_MEMBERS:
        GenericObjectList = &((PAZP_GROUP)GroupHandle)->AppNonMembers;
        break;
    case AZ_PROP_GROUP_MEMBERS:
        GenericObjectList = &((PAZP_GROUP)GroupHandle)->SidMembers;
        break;
    case AZ_PROP_GROUP_NON_MEMBERS:
        GenericObjectList = &((PAZP_GROUP)GroupHandle)->SidNonMembers;
        break;
    default:
        AzPrint(( AZD_INVPARM, "AzGroupAddPropertyItem: invalid prop id %ld\n", PropertyId ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonAddPropertyItem(
                    (PGENERIC_OBJECT) GroupHandle,
                    OBJECT_TYPE_GROUP,
                    GenericObjectList,
                    Reserved,
                    (LPWSTR) PropertyValue );

}


DWORD
WINAPI
AzGroupRemovePropertyItem(
    IN AZ_HANDLE GroupHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Remove an item from the list of items specified by PropertyId.

Arguments:

    GroupHandle - Specifies a handle to the task

    PropertyId - Specifies which property to modify

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to item to remove.
        The specified value and type depends on PropertyId.  The valid values are:

        AZ_PROP_GROUP_APP_MEMBERS          LPWSTR - Application groups that are members of this group
        AZ_PROP_GROUP_APP_NON_MEMBERS      LPWSTR - Application groups that are non-members of this group
        AZ_PROP_GROUP_MEMBERS              PSID - NT sids that are members of this group
        AZ_PROP_GROUP_NON_MEMBERS          PSID - NT sids that are non-members of this group


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

    ERROR_NOT_FOUND - There is no item by that name in the list

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;

    //
    // Validate the Property ID
    //

    switch ( PropertyId ) {
    case AZ_PROP_GROUP_APP_MEMBERS:
        GenericObjectList = &((PAZP_GROUP)GroupHandle)->AppMembers;
        break;
    case AZ_PROP_GROUP_APP_NON_MEMBERS:
        GenericObjectList = &((PAZP_GROUP)GroupHandle)->AppNonMembers;
        break;
    case AZ_PROP_GROUP_MEMBERS:
        GenericObjectList = &((PAZP_GROUP)GroupHandle)->SidMembers;
        break;
    case AZ_PROP_GROUP_NON_MEMBERS:
        GenericObjectList = &((PAZP_GROUP)GroupHandle)->SidNonMembers;
        break;
    default:
        AzPrint(( AZD_INVPARM, "AzGroupRemovePropertyItem: invalid prop id %ld\n", PropertyId ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonRemovePropertyItem (
                    (PGENERIC_OBJECT) GroupHandle,
                    OBJECT_TYPE_GROUP,
                    GenericObjectList,
                    Reserved,
                    (LPWSTR) PropertyValue );

}


DWORD
WINAPI
AzGroupDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR GroupName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a group from the scope of the specified parent object.
    Also deletes any child objects of GroupName.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the group.
        This may be an Admin Manager handle, an Application Handle, or a
        Scope handle.

    GroupName - Specifies the name of the group to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports groups as children
    //

    WinStatus = AzpGroupGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_GROUP,
                    GroupName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\makefile.inc ===
PRIVLIB= $(O)\$(TARGETNAME)p.lib
$(O)\$(TARGETNAME).lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\$(TARGETNAME)p.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(TARGETNAME)p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\$(TARGETNAME)p.def: $(TARGETNAME).def
    $(C_PREPROCESSOR) $** -DPRIVATEEXPORT= > $@

stdafx_stub.cxx: stdafx.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\junction.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    junction.cxx

Abstract:

    Routines implementing the JunctionPoint object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"



DWORD
AzpJunctionPointInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzJunctionPointCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_JUNCTION_POINT JunctionPoint = (PAZP_JUNCTION_POINT) ChildGenericObject;
    // PAZP_APPLICATION Application = (PAZP_APPLICATION) ParentGenericObject;
    PAZP_ADMIN_MANAGER AdminManager;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION );
    AdminManager = ParentGenericObject->AdminManagerObject;

    //
    // JunctionPoints reference 'Applications' that are children of the same 'AdminManager' as the JunctionPoint object
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &JunctionPoint->Applications,
    ObInitObjectList( &JunctionPoint->Applications,
                      NULL,
                      FALSE, // Forward link
                      0,     // No link pair id
                      &AdminManager->Applications,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpJunctionPointFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for JunctionPoint object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_JUNCTION_POINT JunctionPoint = (PAZP_JUNCTION_POINT) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //


}


DWORD
AzpJunctionPointGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzJunctionPointGetProperty.  It does any object specific
    property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_JUNCTION_POINT_APPLICATION   LPWSTR - Application linked to this junction point

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_JUNCTION_POINT JunctionPoint = (PAZP_JUNCTION_POINT) GenericObject;

    PAZ_STRING_ARRAY TempStringArray = NULL;
    AZP_STRING TempString;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );
    AzpInitString( &TempString, NULL );


    //
    // Return any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // Return the application name to the caller
    //
    case AZ_PROP_JUNCTION_POINT_APPLICATION:


        //
        // The link is stored as an array since that's the common mechanism of
        //  keeping links between objects
        //

        TempStringArray = ObGetPropertyItems( &JunctionPoint->Applications );

        if ( TempStringArray == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // If there is a string to return,
        //  return just that one.
        //

        ASSERT( TempStringArray->StringCount <= 1 );

        if ( TempStringArray->StringCount != 0 ) {
            AzpInitString( &TempString, TempStringArray->Strings[0] );
        }

        //
        // Allocate it and return it
        //

        *PropertyValue = AzpGetStringProperty( &TempString );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpJunctionPointGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }


    //
    // Free any local resources
    //
Cleanup:
    if ( TempStringArray != NULL ) {
        AzFreeMemory( TempStringArray );
    }

    return WinStatus;
}

DWORD
AzpJunctionPointSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzJunctionPointSetProperty.  It does any object specific
    property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_JUNCTION_POINT_APPLICATION   LPWSTR - Application linked to this junction point


Return Value:

    Status of the operation

--*/
{
        DWORD WinStatus = NO_ERROR;

    PAZP_JUNCTION_POINT JunctionPoint = (PAZP_JUNCTION_POINT) GenericObject;

    PAZ_STRING_ARRAY TempStringArray = NULL;
    AZP_STRING CapturedString;
    AZP_STRING TempString;

    ULONG i;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpInitString( &CapturedString, NULL );


    //
    // Set any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // Set the application name
    //
    case AZ_PROP_JUNCTION_POINT_APPLICATION:

        //
        // Get the current list of items.
        //

        TempStringArray = ObGetPropertyItems( &JunctionPoint->Applications );

        if ( TempStringArray == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Capture the the new application name
        //

        WinStatus = AzpCaptureString( &CapturedString,
                                      (LPWSTR) PropertyValue,
                                      AZ_MAX_APPLICATION_NAME_LENGTH,
                                      FALSE );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Add the new application name
        //

        WinStatus = ObAddPropertyItem(
                        GenericObject,
                        &JunctionPoint->Applications,
                        &CapturedString );

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }


        //
        // Remove any old names
        //  Remove them all even if there is more than one
        //
        //

        for ( i=0; i<TempStringArray->StringCount; i++ ) {


            //
            // Ignore errors.  This is done on a best-effort basis
            //

            AzpInitString( &TempString, TempStringArray->Strings[i] );

            WinStatus = ObRemovePropertyItem(
                               GenericObject,
                               &JunctionPoint->Applications,
                               &TempString );

            ASSERT(WinStatus == NO_ERROR);

        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpJunctionPointSetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    WinStatus = NO_ERROR;

    //
    // Free any local resources
    //
Cleanup:
    if ( TempStringArray != NULL ) {
        AzFreeMemory( TempStringArray );
    }
    AzpFreeString( &CapturedString );

    return WinStatus;
}


DWORD
AzpJunctionPointCheckRefLoop(
    IN PAZP_JUNCTION_POINT ParentJunctionPoint,
    IN PAZP_APPLICATION CurrentApplication
    )
/*++

Routine Description:

    This routine determines whether the junction points of "CurrentApplication"
    reference the application that hosts "ParentJunctionPoint".
    This is done to detect loops where the
    junction point of one application references itself directly or indirectly.

    On entry, AzGlResource must be locked shared.

Arguments:

    ParentJunctionPoint - JunctionPoint object that is being modified.

    CurrentApplication - Application that is directly or indirectly referenced by the
        junction point.

Return Value:

    Status of the operation
    ERROR_DS_LOOP_DETECT - A loop has been detected.

--*/
{
    ULONG WinStatus;
    ULONG i;
    PLIST_ENTRY ListEntry;
    PAZP_APPLICATION ParentApplication;
    PAZP_JUNCTION_POINT JunctionPoint;
    PAZP_APPLICATION NextApplication;

    //
    // Check for a reference to ourself
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );

    ParentApplication = (PAZP_APPLICATION)
        ParentJunctionPoint->GenericObject.ParentGenericObjectHead->ParentGenericObject;

    if ( ParentApplication == CurrentApplication ) {
        return ERROR_DS_LOOP_DETECT;
    }

    //
    // Check all junction points of the current application
    //

    for ( ListEntry = CurrentApplication->JunctionPoints.Head.Flink ;
          ListEntry != &CurrentApplication->JunctionPoints.Head ;
          ListEntry = ListEntry->Flink) {

        JunctionPoint = (PAZP_JUNCTION_POINT)
                            CONTAINING_RECORD( ListEntry,
                                               GENERIC_OBJECT,
                                               Next );

        //
        // Check all applications (there should only be zero or one) linked to that junction point
        //

        for ( i=0; i<JunctionPoint->Applications.GenericObjects.UsedCount; i++ ) {

            NextApplication = (PAZP_APPLICATION)
                (JunctionPoint->Applications.GenericObjects.Array[i]);

            WinStatus = AzpJunctionPointCheckRefLoop( ParentJunctionPoint,
                                                      NextApplication );

            if ( WinStatus != NO_ERROR ) {
                return WinStatus;
            }
        }

    }

    return NO_ERROR;

}


DWORD
AzpJunctionPointAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzJunctionPointAddPropertyItem.
    It does any object specific property adds

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the junction point object to be modified

    GenericObjectList - Specifies the object list the object is to be added to

    LinkedToObject - Specifies the application object that is being linked to

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_JUNCTION_POINT JunctionPoint = (PAZP_JUNCTION_POINT) GenericObject;
    UNREFERENCED_PARAMETER( GenericObjectList );


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Ensure this newly added application doesn't cause a loop
    //

    WinStatus = AzpJunctionPointCheckRefLoop(
                        JunctionPoint,
                        (PAZP_APPLICATION)LinkedToObject );


    //
    // Free any local resources
    //

    return WinStatus;
}



DWORD
WINAPI
AzJunctionPointCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR JunctionPointName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE JunctionPointHandle
    )
/*++

Routine Description:

    This routine adds a junction point into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    JunctionPointName - Specifies the name of the junction point to add.

    Reserved - Reserved.  Must by zero.

    JunctionPointHandle - Return a handle to the junction point.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->JunctionPoints),
                    OBJECT_TYPE_JUNCTION_POINT,
                    JunctionPointName,
                    Reserved,
                    (PGENERIC_OBJECT *) JunctionPointHandle );
}



DWORD
WINAPI
AzJunctionPointOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR JunctionPointName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE JunctionPointHandle
    )
/*++

Routine Description:

    This routine opens a junction point into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    JunctionPointName - Specifies the name of the junction point to open

    Reserved - Reserved.  Must by zero.

    JunctionPointHandle - Return a handle to the junction point.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no junction point by that name

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->JunctionPoints),
                    OBJECT_TYPE_JUNCTION_POINT,
                    JunctionPointName,
                    Reserved,
                    (PGENERIC_OBJECT *) JunctionPointHandle );
}


DWORD
WINAPI
AzJunctionPointEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE JunctionPointHandle
    )
/*++

Routine Description:

    Enumerates all of the junction points for the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next junction point to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    JunctionPointHandle - Returns a handle to the next junction point object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->JunctionPoints),
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) JunctionPointHandle );

}


DWORD
WINAPI
AzJunctionPointGetProperty(
    IN AZ_HANDLE JunctionPointHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for a junction point.

Arguments:

    JunctionPointHandle - Specifies a handle to the junction point

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object
        AZ_PROP_JUNCTION_POINT_APPLICATION   LPWSTR - Application linked to this junction point


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonGetProperty(
                    (PGENERIC_OBJECT) JunctionPointHandle,
                    OBJECT_TYPE_JUNCTION_POINT,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzJunctionPointSetProperty(
    IN AZ_HANDLE JunctionPointHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for a junction point.

Arguments:

    JunctionPointHandle - Specifies a handle to the junction point

    PropertyId - Specifies which property to set

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object

        AZ_PROP_JUNCTION_POINT_APPLICATION   LPWSTR - Application linked to this junction point

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonSetProperty(
                    (PGENERIC_OBJECT) JunctionPointHandle,
                    OBJECT_TYPE_JUNCTION_POINT,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}



DWORD
WINAPI
AzJunctionPointDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR JunctionPointName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a junction point from the scope of the specified application.
    Also deletes any child objects of JunctionPointName.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    JunctionPointName - Specifies the name of the junction point to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->JunctionPoints),
                    OBJECT_TYPE_JUNCTION_POINT,
                    JunctionPointName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\context.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    context.cxx

Abstract:

    Routines implementing the client context API

Author:

    Cliff Van Dyke (cliffv) 22-May-2001

--*/

#include "pch.hxx"

DWORD
AzpClientContextInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzInitializeClientContextFrom*.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_CLIENT_CONTEXT ClientContext = (PAZP_CLIENT_CONTEXT) ChildGenericObject;
    UNREFERENCED_PARAMETER( ParentGenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // ClientContexts are referenced by "Applications"
    //  Let the generic object manager know all of the lists we support
    //  This is a "back" link so we don't need to define which applications can reference this client context.
    //

    ChildGenericObject->GenericObjectLists = &ClientContext->backApplications;

    // Back link to applications
    ObInitObjectList( &ClientContext->backApplications,
                      NULL,
                      TRUE, // Backward link
                      0,    // No link pair id
                      NULL,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpClientContextFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for ClientContext object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_CLIENT_CONTEXT ClientContext = (PAZP_CLIENT_CONTEXT) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //


    //
    // Free any authz context
    //

    if ( ClientContext->AuthzClientContext != NULL ) {
        if ( !AuthzFreeContext( ClientContext->AuthzClientContext ) ) {
            ASSERT( FALSE );
        }
    }


}


DWORD
AzpClientContextGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzClientContextGetProperty.  It does any object specific
    property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_CLIENT_CONTEXT_TYPE                 PULONG - ClientContext type of the group
        AZ_PROP_CLIENT_CONTEXT_APP_MEMBERS          AZ_STRING_ARRAY - Application groups that are members of this group
        ???

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_CLIENT_CONTEXT ClientContext = (PAZP_CLIENT_CONTEXT) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //
    switch ( PropertyId ) {
    case 1:
        UNREFERENCED_PARAMETER( PropertyValue );
        UNREFERENCED_PARAMETER( ClientContext );
        break;
    default:
        AzPrint(( AZD_INVPARM, "AzpClientContextGetProperty: invalid opcode\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}



DWORD
AzInitializeContextFromToken(
    IN AZ_HANDLE ApplicationHandle,
    IN HANDLE TokenHandle,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ClientContextHandle
    )
/*++

Routine Description:

    This routine is a worker routine for AzGroupCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ApplicationHandle - Specifies a handle to the application object that
        is this client context applies to.

    TokenHandle - Handle to the NT token describing the cleint.
        NULL implies the impersonation token of the caller's thread.
        The token mast have been opened for TOKEN_QUERY, TOKEN_IMPERSONATION, and
        TOKEN_DUPLICATE access.

    Reserved - Reserved.  Must by zero.

    ClientContextHandle - Return a handle to the client context
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    DWORD WinStatus;
    LUID Identifier = {0};
    PAZP_CLIENT_CONTEXT ClientContext = NULL;

    //
    // Call the common routine to create our client context object
    //

    WinStatus = ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->ClientContexts),
                    OBJECT_TYPE_CLIENT_CONTEXT,
                    NULL,
                    Reserved,
                    (PGENERIC_OBJECT *) &ClientContext );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Initialize Authz
    //

    if ( !AuthzInitializeContextFromToken(
                0,      // No Flags
                TokenHandle,
                (((PAZP_APPLICATION)ApplicationHandle)->AuthzResourceManager),
                NULL,   // No expiration time
                Identifier,
                NULL,   // No dynamic group args
                &ClientContext->AuthzClientContext ) ) {

        WinStatus = GetLastError();
        goto Cleanup;
    }


    WinStatus = NO_ERROR;
    *ClientContextHandle = ClientContext;
    ClientContext = NULL;

    //
    // Free any local resources
    //
Cleanup:
    if ( ClientContext != NULL ) {
        AzCloseHandle( ClientContext, 0 );
    }

    return WinStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\objects.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    objects.h

Abstract:

    Definitions for the sundry objects implemented by azroles


Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// An Admin Manager
//

typedef struct _AZP_ADMIN_MANAGER {

    //
    // All objects are a generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Define objects that can be children of this admin manager
    //

    GENERIC_OBJECT_HEAD Applications;
    GENERIC_OBJECT_HEAD Groups;
    GENERIC_OBJECT_HEAD AzpSids;

    //
    // Count of all handles referenced for the entire tree of objects
    //

    LONG TotalHandleReferenceCount;

    //
    // The peristence provider may store any value it needs to here between
    //  the call to AzpPersistOpen and AzpPersistClose.
    //

    PVOID PersistContext;

    //
    // Policy type/URL
    //

    ULONG StoreType;
    AZP_STRING PolicyUrl;


} AZP_ADMIN_MANAGER, *PAZP_ADMIN_MANAGER;

//
// An Application
//

typedef struct _AZP_APPLICATION {

    //
    // All objects are a generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //


    //
    // Define objects that can be children of this application
    //

    GENERIC_OBJECT_HEAD Operations;
    GENERIC_OBJECT_HEAD Tasks;
    GENERIC_OBJECT_HEAD Scopes;
    GENERIC_OBJECT_HEAD Groups;
    GENERIC_OBJECT_HEAD Roles;
    GENERIC_OBJECT_HEAD JunctionPoints;
    GENERIC_OBJECT_HEAD AzpSids;
    GENERIC_OBJECT_HEAD ClientContexts;

    //
    // An application object is referenced by JunctionPoint objects
    //
    GENERIC_OBJECT_LIST backJunctionPoints;

    //
    // An application is known as a resource manager to the authz code
    //

    AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager;


} AZP_APPLICATION, *PAZP_APPLICATION;

//
// An Operation
//

typedef struct _AZP_OPERATION {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //

    ULONG OperationId;

    //
    // An Operation object is referenced by Tasks objects and Role objects
    //

    GENERIC_OBJECT_LIST backTasks;
    GENERIC_OBJECT_LIST backRoles;


} AZP_OPERATION, *PAZP_OPERATION;

//
// A Task
//

typedef struct _AZP_TASK {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //

    AZP_STRING BizRule;
    AZP_STRING BizRuleLanguage;

    //
    // A Task object references a list of Operation objects
    //

    GENERIC_OBJECT_LIST Operations;


} AZP_TASK, *PAZP_TASK;

//
// A Scope
//

typedef struct _AZP_SCOPE {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //


    //
    // Roles defined for this scope
    //

    GENERIC_OBJECT_HEAD Groups;
    GENERIC_OBJECT_HEAD Roles;
    GENERIC_OBJECT_HEAD AzpSids;

    //
    // A Scope object is referenced by Role objects
    //

    GENERIC_OBJECT_LIST backRoles;


} AZP_SCOPE, *PAZP_SCOPE;

//
// A Group
//

typedef struct _AZP_GROUP {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //

    ULONG GroupType;
    AZP_STRING LdapQuery;


    //
    // A Group object references a list of Group objects as members and non members
    //

    GENERIC_OBJECT_LIST AppMembers;
    GENERIC_OBJECT_LIST AppNonMembers;

    GENERIC_OBJECT_LIST backAppMembers;
    GENERIC_OBJECT_LIST backAppNonMembers;


    //
    // A Group object is referenced by Role objects
    //
    GENERIC_OBJECT_LIST backRoles;

    //
    // A Group object references a list of Sid objects as members and non members
    //

    GENERIC_OBJECT_LIST SidMembers;
    GENERIC_OBJECT_LIST SidNonMembers;


} AZP_GROUP, *PAZP_GROUP;

//
// A Role
//

typedef struct _AZP_ROLE {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //


    //
    // A Role object references a list of Group objects, a list of operation object,
    //  and a list of Scope objects.
    //
    //

    GENERIC_OBJECT_LIST AppMembers;
    GENERIC_OBJECT_LIST Operations;
    GENERIC_OBJECT_LIST Scopes;

    //
    // A Role object references a list of Sid objects as members
    //

    GENERIC_OBJECT_LIST SidMembers;


} AZP_ROLE, *PAZP_ROLE;

//
// A JunctionPoint
//

typedef struct _AZP_JUNCTION_POINT {

    //
    // All objects are generic objects
    //

    GENERIC_OBJECT GenericObject;

    //
    // Attributes from the external definition of the object
    //

    //
    // A JunctionPoint object references a list of Application objects
    //  Actually, there can be at most one entry on this list.
    //

    GENERIC_OBJECT_LIST Applications;

} AZP_JUNCTION_POINT, *PAZP_JUNCTION_POINT;

//
// A Sid.
//
//  A Sid object is a pseudo-object.  It really doesn't exist from any external
//  interface.  It exists simply as a holder of back-references to real objects
//  that contain lists of sids
//

typedef struct _AZP_SID {

    //
    // All objects are generic objects
    //
    // Note that the "ObjectName" of the generic object is really a binary SID.
    //

    GENERIC_OBJECT GenericObject;

    //
    // A Sid is referenced by Group objects and Role Objects
    //

    GENERIC_OBJECT_LIST backGroupMembers;
    GENERIC_OBJECT_LIST backGroupNonMembers;

    GENERIC_OBJECT_LIST backRoles;

} AZP_SID, *PAZP_SID;

//
// A Client Context
//
//  A client context object is a pseudo-object.  It is not persisted.
//

typedef struct _AZP_CLIENT_CONTEXT {

    //
    // All objects are generic objects
    //
    // Note that the "ObjectName" of the generic object is empty
    //

    GENERIC_OBJECT GenericObject;

    //
    // A ClientContext is referenced by Application objects
    //

    GENERIC_OBJECT_LIST backApplications;

    //
    // A client context has an underlying authz context
    //

    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext;

} AZP_CLIENT_CONTEXT, *PAZP_CLIENT_CONTEXT;


/////////////////////////////////////////////////////////////////////////////
//
// Global definitions
//
/////////////////////////////////////////////////////////////////////////////

extern RTL_RESOURCE AzGlResource;
extern GUID AzGlZeroGuid;


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

DWORD
AzpAdminManagerInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpApplicationInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpOperationInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpTaskInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpScopeInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpGroupInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpRoleInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpJunctionPointInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpSidInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );
DWORD
AzpClientContextInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    );

DWORD
AzpOperationGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpOperationSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpTaskGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpTaskSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpGroupGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpGroupSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpJunctionPointSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    );

DWORD
AzpGroupAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    );

DWORD
AzpJunctionPointAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN PGENERIC_OBJECT LinkedToObject
    );

DWORD
AzpRoleGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpJunctionPointGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    );

DWORD
AzpRoleAddPropertyItem(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PGENERIC_OBJECT_LIST GenericObjectList,
    IN AZP_STRING ObjectName
    );

// ??? ditch functions that are no-ops
VOID
AzpAdminManagerFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpApplicationFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpOperationFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpTaskFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpScopeFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpGroupFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpRoleFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpJunctionPointFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpSidFree(
    IN PGENERIC_OBJECT GenericObject
    );

VOID
AzpClientContextFree(
    IN PGENERIC_OBJECT GenericObject
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\op.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    op.cxx

Abstract:

    Routines implementing the Operation object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"



DWORD
AzpOperationInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzOperationCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_OPERATION Operation = (PAZP_OPERATION) ChildGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION );
    UNREFERENCED_PARAMETER( ParentGenericObject );

    //
    // Operations are referenced by "Tasks" and "Roles"
    //  Let the generic object manager know all of the lists we support
    //  This is a "back" link so we don't need to define which tasks can reference this operation.
    //

    ChildGenericObject->GenericObjectLists = &Operation->backTasks;

    // Back link to tasks
    ObInitObjectList( &Operation->backTasks,
                      &Operation->backRoles,
                      TRUE, // Backward link
                      0,    // No link pair id
                      NULL,
                      NULL,
                      NULL );

    // Back link to roles
    ObInitObjectList( &Operation->backRoles,
                      NULL,
                      TRUE, // Backward link
                      0,    // No link pair id
                      NULL,
                      NULL,
                      NULL );

    return NO_ERROR;
}


VOID
AzpOperationFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Operation object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_OPERATION Operation = (PAZP_OPERATION) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //


}


DWORD
AzpOperationGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzOperationGetProperty.  It does any object specific
    property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_OPERATION_ID       PULONG - Operation ID of the operation

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_OPERATION Operation = (PAZP_OPERATION) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //  Return operation id to the caller
    //

    switch ( PropertyId ) {
    case AZ_PROP_OPERATION_ID:

        *PropertyValue = AzpGetUlongProperty( Operation->OperationId );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpOperationGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}


DWORD
AzpOperationSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzOperationSetProperty.  It does any object specific
    property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_OPERATION_ID       PULONG - Operation ID of the operation

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus;
    PAZP_OPERATION Operation = (PAZP_OPERATION) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //  Return ooperation id to the caller
    //

    switch ( PropertyId ) {
    case AZ_PROP_OPERATION_ID:

        WinStatus = AzpCaptureUlong( PropertyValue, &Operation->OperationId );

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpOperationSetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}



DWORD
WINAPI
AzOperationCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE OperationHandle
    )
/*++

Routine Description:

    This routine adds an operation into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    OperationName - Specifies the name of the operation to add.

    Reserved - Reserved.  Must by zero.

    OperationHandle - Return a handle to the operation.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Operations),
                    OBJECT_TYPE_OPERATION,
                    OperationName,
                    Reserved,
                    (PGENERIC_OBJECT *) OperationHandle );
}



DWORD
WINAPI
AzOperationOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE OperationHandle
    )
/*++

Routine Description:

    This routine opens an operation into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    OperationName - Specifies the name of the operation to open

    Reserved - Reserved.  Must by zero.

    OperationHandle - Return a handle to the operation.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no operation by that name

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Operations),
                    OBJECT_TYPE_OPERATION,
                    OperationName,
                    Reserved,
                    (PGENERIC_OBJECT *) OperationHandle );
}


DWORD
WINAPI
AzOperationEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE OperationHandle
    )
/*++

Routine Description:

    Enumerates all of the operations for the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next operation to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    OperationHandle - Returns a handle to the next operation object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Operations),
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) OperationHandle );

}


DWORD
WINAPI
AzOperationGetProperty(
    IN AZ_HANDLE OperationHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for an operation.

Arguments:

    OperationHandle - Specifies a handle to the operation

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object
        AZ_PROP_OPERATION_ID       PULONG - Operation ID of the operation


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonGetProperty(
                    (PGENERIC_OBJECT) OperationHandle,
                    OBJECT_TYPE_OPERATION,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzOperationSetProperty(
    IN AZ_HANDLE OperationHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for an operation.

Arguments:

    OperationHandle - Specifies a handle to the operation

    PropertyId - Specifies which property to set

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object
        AZ_PROP_OPERATION_ID       PULONG - Operation ID of the operation

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonSetProperty(
                    (PGENERIC_OBJECT) OperationHandle,
                    OBJECT_TYPE_OPERATION,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}



DWORD
WINAPI
AzOperationDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR OperationName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes an operation from the scope of the specified application.
    Also deletes any child objects of OperationName.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    OperationName - Specifies the name of the operation to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Operations),
                    OBJECT_TYPE_OPERATION,
                    OperationName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by azroles.rc
//
#define IDS_PROJNAME                    100
#define IDR_AZADMINMANAGER              101
#define IDR_AZAPPLICATION               102
#define IDR_AZENUMAPPLICATION           103
#define IDR_AZOPERATION                 104
#define IDR_AZENUMOPERATION             105
#define IDR_AZTASK                      106
#define IDR_AZENUMTASK                  107
#define IDR_AZSCOPE                     108
#define IDR_AZENUMSCOPE                 109
#define IDR_AZAPPLICATIONGROUP          110
#define IDR_AZENUMAPPLICATIONGROUP      111
#define IDR_AZROLE                      112
#define IDR_AZENUMROLE                  113
#define IDR_AZJUNCTIONPOINT             114
#define IDR_AZENUMJUNCTIONPOINT         115
#define IDR_AZCLIENTCONTEXT             116
#define IDR_AZACCESSCHECK               117


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\role.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    role.cxx

Abstract:

    Routines implementing the Role object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"



DWORD
AzpRoleInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzRoleCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_ROLE Role = (PAZP_ROLE) ChildGenericObject;
    PAZP_ADMIN_MANAGER AdminManager = NULL;
    PAZP_APPLICATION Application = NULL;
    PAZP_SCOPE Scope = NULL;

    PGENERIC_OBJECT_HEAD ParentSids = NULL;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //
    // A role references SID objects that are siblings of itself.
    // That way, the back links on the SID object references just the roles
    // that are siblings of the SID object.
    //

    if ( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ) {
        AdminManager = ParentGenericObject->AdminManagerObject;
        Application = (PAZP_APPLICATION) ParentGenericObject;
        ParentSids = &Application->AzpSids;

    } else if ( ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE ) {
        AdminManager = ParentGenericObject->AdminManagerObject;
        Application = (PAZP_APPLICATION) ParentGenericObject->ParentGenericObjectHead->ParentGenericObject;
        Scope = (PAZP_SCOPE) ParentGenericObject;
        ParentSids = &Scope->AzpSids;

    } else {
        ASSERT( FALSE );
    }

    //
    // Roles reference groups, operations, and scopes.
    //  These other groups can be siblings of this group or siblings of our parents.
    //
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &Role->AppMembers,

    // List of Groups
    ObInitObjectList( &Role->AppMembers,
                      &Role->Operations,
                      FALSE,    // Forward link
                      0,        // No link pair id
                      &AdminManager->Groups,
                      &Application->Groups,
                      Scope == NULL ? NULL : &Scope->Groups );

    // List of Operations
    ObInitObjectList( &Role->Operations,
                      &Role->Scopes,
                      FALSE,    // Forward link
                      0,        // No link pair id
                      &Application->Operations,
                      NULL,
                      NULL );

    // List of Scopes
    ObInitObjectList( &Role->Scopes,
                      &Role->SidMembers,
                      FALSE,    // Forward link
                      0,        // No link pair id
                      &Application->Scopes,
                      NULL,
                      NULL );

    // Role reference SID objects
    ObInitObjectList( &Role->SidMembers,
                      NULL,
                      FALSE,    // Forward link
                      0,        // No link pair id
                      ParentSids,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpRoleFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Role object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_ROLE Role = (PAZP_ROLE) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //


}


DWORD
AzpRoleGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzRoleGetProperty.  It does any object specific
    property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_ROLE_APP_MEMBERS  AZ_STRING_ARRAY - Application groups that are members of this role
        AZ_PROP_ROLE_MEMBERS      AZ_SID_ARRAY - NT Sids that are members of this role
        AZ_PROP_ROLE_OPERATIONS   AZ_STRING_ARRAY - Operations the can be performed by this role
        AZ_PROP_ROLE_SCOPES       AZ_STRING_ARRAY - Scopes this role applies to

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_ROLE Role = (PAZP_ROLE) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //
    //
    switch ( PropertyId ) {

    // Return the set of app members to the caller
    case AZ_PROP_ROLE_APP_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Role->AppMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of SID members to the caller
    case AZ_PROP_ROLE_MEMBERS:

        *PropertyValue = ObGetPropertyItems( &Role->SidMembers );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of operations to the caller
    case AZ_PROP_ROLE_OPERATIONS:

        *PropertyValue = ObGetPropertyItems( &Role->Operations );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    // Return the set of scopes to the caller
    case AZ_PROP_ROLE_SCOPES:

        *PropertyValue = ObGetPropertyItems( &Role->Scopes );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzpRoleGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}

DWORD
AzpRoleGetGenericChildHead(
    IN AZ_HANDLE ParentHandle,
    OUT PULONG ObjectType,
    OUT PGENERIC_OBJECT_HEAD *GenericChildHead
    )
/*++

Routine Description:

    This routine determines whether ParentHandle supports Role objects as
    children.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    ObjectType - Returns the object type of the ParentHandle.

    GenericChildHead - Returns a pointer to the head of the list of roles objects
        that are children of the object specified by ParentHandle.  This in an unverified
        pointer.  The pointer is only valid after ParentHandle has been validated.

Return Value:

    Status of the operation.

--*/
{
    DWORD WinStatus;

    //
    // Determine the type of the parent handle
    //

    WinStatus = ObGetHandleType( (PGENERIC_OBJECT)ParentHandle,
                                 FALSE, // ignore deleted objects
                                 ObjectType );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }


    //
    // Verify that the specified handle support children roles.
    //

    switch ( *ObjectType ) {
    case OBJECT_TYPE_APPLICATION:

        *GenericChildHead = &(((PAZP_APPLICATION)ParentHandle)->Roles);
        break;

    case OBJECT_TYPE_SCOPE:

        *GenericChildHead = &(((PAZP_SCOPE)ParentHandle)->Roles);
        break;

    default:
        return ERROR_INVALID_HANDLE;
    }

    return NO_ERROR;
}



DWORD
WINAPI
AzRoleCreate(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE RoleHandle
    )
/*++

Routine Description:

    This routine adds a role into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    RoleName - Specifies the name of the role to add.

    Reserved - Reserved.  Must by zero.

    RoleHandle - Return a handle to the role.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports roles as children
    //

    WinStatus = AzpRoleGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_ROLE,
                    RoleName,
                    Reserved,
                    (PGENERIC_OBJECT *) RoleHandle );

}



DWORD
WINAPI
AzRoleOpen(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE RoleHandle
    )
/*++

Routine Description:

    This routine opens a role into the scope of the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    RoleName - Specifies the name of the role to open

    Reserved - Reserved.  Must by zero.

    RoleHandle - Return a handle to the role.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no role by that name

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports roles as children
    //

    WinStatus = AzpRoleGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_ROLE,
                    RoleName,
                    Reserved,
                    (PGENERIC_OBJECT *) RoleHandle );
}


DWORD
WINAPI
AzRoleEnum(
    IN AZ_HANDLE ParentHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE RoleHandle
    )
/*++

Routine Description:

    Enumerates all of the roles for the specified parent object.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next role to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    RoleHandle - Returns a handle to the next role object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports roles as children
    //

    WinStatus = AzpRoleGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) RoleHandle );

}


DWORD
WINAPI
AzRoleGetProperty(
    IN AZ_HANDLE RoleHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for a role.

Arguments:

    RoleHandle - Specifies a handle to the role

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME           LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION    LPWSTR - Description of the object
        AZ_PROP_ROLE_APP_MEMBERS      AZ_STRING_ARRAY - Application groups that are members of this role
        AZ_PROP_ROLE_MEMBERS          AZ_SID_ARRAY - NT Sids that are members of this role
        AZ_PROP_ROLE_OPERATIONS       AZ_STRING_ARRAY - Operations the can be performed by this role
        AZ_PROP_ROLE_SCOPES           AZ_STRING_ARRAY - Scopes this role applies to


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonGetProperty(
                    (PGENERIC_OBJECT) RoleHandle,
                    OBJECT_TYPE_ROLE,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzRoleSetProperty(
    IN AZ_HANDLE RoleHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for a role.

Arguments:

    RoleHandle - Specifies a handle to the role

    PropertyId - Specifies which property to set

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object
        AZ_PROP_ROLE_TYPE         PULONG - Role type of the role

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonSetProperty(
                    (PGENERIC_OBJECT) RoleHandle,
                    OBJECT_TYPE_ROLE,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}



DWORD
WINAPI
AzRoleAddPropertyItem(
    IN AZ_HANDLE RoleHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Adds an item to the list of items specified by PropertyId.

Arguments:

    RoleHandle - Specifies a handle to the task

    PropertyId - Specifies which property to modify

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to item to add.
        The specified value and type depends on PropertyId.  The valid values are:

        AZ_PROP_ROLE_APP_MEMBERS      LPWSTR - Application groups that are members of this role
        AZ_PROP_ROLE_MEMBERS          PSID - NT Sids that are members of this role
        AZ_PROP_ROLE_OPERATIONS       LPWSTR - Operations the can be performed by this role
        AZ_PROP_ROLE_SCOPES           LPWSTR - Scopes this role applies to


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

    ERROR_NOT_FOUND - There is no object by that name

    ERROR_ALREADY_EXISTS - An item by that name already exists in the list

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;

    //
    // Validate the Property ID
    //

    switch ( PropertyId ) {
    case AZ_PROP_ROLE_APP_MEMBERS:
        GenericObjectList = &((PAZP_ROLE)RoleHandle)->AppMembers;
        break;
    case AZ_PROP_ROLE_MEMBERS:
        GenericObjectList = &((PAZP_ROLE)RoleHandle)->SidMembers;
        break;
    case AZ_PROP_ROLE_OPERATIONS:
        GenericObjectList = &((PAZP_ROLE)RoleHandle)->Operations;
        break;
    case AZ_PROP_ROLE_SCOPES:
        GenericObjectList = &((PAZP_ROLE)RoleHandle)->Scopes;
        break;
    default:
        AzPrint(( AZD_INVPARM, "AzRoleAddPropertyItem: invalid prop id %ld\n", PropertyId ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonAddPropertyItem(
                    (PGENERIC_OBJECT) RoleHandle,
                    OBJECT_TYPE_ROLE,
                    GenericObjectList,
                    Reserved,
                    (LPWSTR) PropertyValue );

}


DWORD
WINAPI
AzRoleRemovePropertyItem(
    IN AZ_HANDLE RoleHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Remove an item from the list of items specified by PropertyId.

Arguments:

    RoleHandle - Specifies a handle to the task

    PropertyId - Specifies which property to modify

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to item to remove.
        The specified value and type depends on PropertyId.  The valid values are:

        AZ_PROP_ROLE_APP_MEMBERS      LPWSTR - Application groups that are members of this role
        AZ_PROP_ROLE_MEMBERS          PSID - NT Sids that are members of this role
        AZ_PROP_ROLE_OPERATIONS       LPWSTR - Operations the can be performed by this role
        AZ_PROP_ROLE_SCOPES           LPWSTR - Scopes this role applies to


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

    ERROR_NOT_FOUND - There is no item by that name in the list

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;

    //
    // Validate the Property ID
    //

    switch ( PropertyId ) {
    case AZ_PROP_ROLE_APP_MEMBERS:
        GenericObjectList = &((PAZP_ROLE)RoleHandle)->AppMembers;
        break;
    case AZ_PROP_ROLE_MEMBERS:
        GenericObjectList = &((PAZP_ROLE)RoleHandle)->SidMembers;
        break;
    case AZ_PROP_ROLE_OPERATIONS:
        GenericObjectList = &((PAZP_ROLE)RoleHandle)->Operations;
        break;
    case AZ_PROP_ROLE_SCOPES:
        GenericObjectList = &((PAZP_ROLE)RoleHandle)->Scopes;
        break;
    default:
        AzPrint(( AZD_INVPARM, "AzRoleRemovePropertyItem: invalid prop id %ld\n", PropertyId ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonRemovePropertyItem (
                    (PGENERIC_OBJECT) RoleHandle,
                    OBJECT_TYPE_ROLE,
                    GenericObjectList,
                    Reserved,
                    (LPWSTR) PropertyValue );

}


DWORD
WINAPI
AzRoleDelete(
    IN AZ_HANDLE ParentHandle,
    IN LPCWSTR RoleName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a role from the scope of the specified parent object.
    Also deletes any child objects of RoleName.

Arguments:

    ParentHandle - Specifies a handle to the object that is the parent of the role.
        This may be an Application Handle or a Scope handle.

    RoleName - Specifies the name of the role to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    DWORD WinStatus;
    DWORD ObjectType;
    PGENERIC_OBJECT_HEAD GenericChildHead;

    //
    // Determine that the parent handle supports roles as children
    //

    WinStatus = AzpRoleGetGenericChildHead( ParentHandle,
                                             &ObjectType,
                                             &GenericChildHead );

    if ( WinStatus != NO_ERROR ) {
        return WinStatus;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ParentHandle,
                    ObjectType,
                    GenericChildHead,
                    OBJECT_TYPE_ROLE,
                    RoleName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\sample.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sample.cxx

Abstract:

    This file implements a sample peristance provider.

    This sample does not address buffer overflows, puts large buffers on the stack, etc.
    Caveat Emptor.

Author:

    Cliff Van Dyke (cliffv) 9-May-2001

--*/

#include "pch.hxx"
#include <stdio.h>
#include <stdlib.h>

//
// Local Storage
//
// Each provider is given a single PVOID on the AZP_ADMIN_MANAGER structure.
// That PVOID is a pointer to whatever context the provider needs to maintain a
// description of the local storage.
//
// The structure below is that context for the sample provider.
//

typedef struct _AZP_SAMPLE_CONTEXT {

    //
    // Handle to the file
    //

    HANDLE FileHandle;

    //
    // The next GUID to assign to an object
    //  ??? A real provider would allocate a real GUID
    //

    ULONG LastUsedGuid;

} AZP_SAMPLE_CONTEXT, *PAZP_SAMPLE_CONTEXT;

//
// Table of object type to text string mappings
//

LPWSTR ObjectTypeNames[] = {
    L"[ROOT]",
    L"[ADMIN_MANAGER]",
    L"[APPLICATION]",
    L"[OPERATION]",
    L"[TASK]",
    L"[SCOPE]",
    L"[GROUP]",
    L"[ROLE]",
    L"[JUNCTION_POINT]",
    L"[SID]" };
#define ObjectTypeNamesSize (sizeof(ObjectTypeNames)/sizeof(ObjectTypeNames[0]))

//
// Delimiter between names
//
#define SAMPLE_DELIM L"-->"
#define SAMPLE_DELIM_SIZE (sizeof(SAMPLE_DELIM)-sizeof(WCHAR))

//
// Define a buffer large enough for an object name
//
#define HUGE_BUFFER_SIZE (70000*sizeof(WCHAR))

DWORD
SampleReadFile(
    IN LPWSTR FileName,
    IN BOOL CreatePolicy,
    OUT HANDLE *RetFileHandle,
    OUT LPBYTE *RetBuffer,
    OUT PULONG RetBufferSize
    )
/*++

Routine Description:

    This routine read the policy file into a buffer.

Arguments:

    FileName - Name of the file containing the policy

    CreatePolicy - TRUE if the policy database is to be created.
        FALSE if the policy database already exists

    RetFileHandle - Returns a handle to the open file.
        The caller should close this file by calling CloseHandle.

    RetBuffer - Returns a pointer to a buffer containing the contents of the file
        The caller should free this buffer by calling AzpFreeHeap.

    RetBufferSize - Size (in bytes) of RetBuffer


Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus;
    HANDLE FileHandle;

    LPBYTE Buffer = NULL;
    ULONG BufferSize = 0;;
    ULONG BytesRead;


    //
    // Open the file
    //
    *RetFileHandle = INVALID_HANDLE_VALUE;
    *RetBuffer = NULL;
    *RetBufferSize = 0;

    FileHandle = CreateFileW( FileName,
                              GENERIC_READ|GENERIC_WRITE,
                              FILE_SHARE_READ|FILE_SHARE_WRITE,
                              NULL,
                              CreatePolicy ? CREATE_NEW : OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );

    if ( FileHandle == INVALID_HANDLE_VALUE ) {
        WinStatus = GetLastError();
        AzPrint(( AZD_PERSIST, "SampleReadFile: Cannot CreateFile %ld\n", WinStatus ));
        goto Cleanup;
    }

    //
    // Allocate a buffer to read the file into
    //

    BufferSize = GetFileSize( FileHandle, NULL );

    if ( BufferSize == 0xFFFFFFFF ) {
        WinStatus = GetLastError();
        AzPrint(( AZD_PERSIST, "SampleReadFile: Cannot GetFileSize %ld\n", WinStatus ));
        goto Cleanup;
    }

    Buffer = (LPBYTE) AzpAllocateHeap( BufferSize + sizeof(WCHAR) );
    if ( Buffer == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( BufferSize == 0 ) {
        *(LPWSTR)Buffer = '\0';
        WinStatus = NO_ERROR;
        goto Cleanup;
    }


    //
    // Read the file into the buffer
    //

    if ( !ReadFile( FileHandle,
                    Buffer,
                    BufferSize,
                    &BytesRead,
                    NULL ) ) {  // Not Overlapped

        WinStatus = GetLastError();
        AzPrint(( AZD_PERSIST, "SampleReadFile: Cannot ReadFile %ld\n", WinStatus ));
        goto Cleanup;
    }

    if ( BytesRead != BufferSize ) {
        WinStatus = ERROR_INTERNAL_DB_CORRUPTION;
        AzPrint(( AZD_PERSIST, "SampleReadFile: Cannot ReadFile right size %ld\n", WinStatus ));
        goto Cleanup;
    }
    WinStatus = NO_ERROR;

    //
    // Return the information to the caller
    //

Cleanup:
    if ( WinStatus == NO_ERROR ) {
        *RetFileHandle = FileHandle;
        *RetBuffer = Buffer;
        Buffer = NULL;
        *RetBufferSize = BufferSize;
    }

    //
    // Free locally used resources
    //

    if ( Buffer != NULL ) {
        AzpFreeHeap( Buffer );
    }

    return WinStatus;
}

BOOL
SampleGetALine(
    IN OUT LPWSTR * LinePointer,
    OUT PULONG RetLevel,
    OUT PULONG RetObjectType,
    OUT PULONG Guid,
    OUT LPWSTR FullNameBuffer,
    OUT LPWSTR *Name
    )
/*++

Routine Description:

    This routine gets the next line from a buffer containing the policy file.

Arguments:

    LinePointer - On input, points to the address of the line to read.
        On output, points to the next line.

    RetLevel - Returns the parent/child "generation" level of the current line.
        0 is AdminManager itself. Children of AdminManager are 1. etc.

    RetObjectType - Returns the object type of the line

    Guid - Returns the GUID of the object

    FullNameBuffer - Returns the full parent/child name of the object.  (e.g.
        AppName->ScopeName->RoleName)  Pass in a huge buffer here.

    Name - Returns a pointer into FullNameBuffer of the last component name.
        (e.g., a pointer to RoleName in the sample above)


Return Value:

    TRUE: Line was valid
    FALSE: EOF

--*/
{
    BOOL RetVal;
    LPWSTR Line = *LinePointer;
    LPWSTR Next = NULL;
    WCHAR *p;
    LONG Level = 0;

    ULONG ObjectTypeLength;
    LPWSTR ObjectTypeString;
    ULONG ObjectType = 0;

    ULONG ObjectNameLength;
    LPWSTR ObjectNameString;


    //
    // Get a pointer to the next line of the file
    //

    Next = wcschr( Line, '\n' );

    if ( Next == NULL ) {
        RetVal = FALSE;
        goto Cleanup;
    }

    Next ++;
    p = Line;

    //
    // Parse off the "Guid"
    //

    *Guid = wcstoul( p, &p, 10 );

    if ( *Guid == 0 ) {
        AzPrint(( AZD_PERSIST, "SampleGetALine: No Guid on line %ws\n", Line ));
        RetVal = FALSE;
        goto Cleanup;
    }

    // Skip over the space
    p++;

    //
    // Parse off the object name
    //

    ObjectNameString = p;
    ObjectNameLength = wcscspn( p, L"[\n" );

    if ( ObjectNameLength == 0 || ObjectNameLength == 1 ) {
        AzPrint(( AZD_PERSIST, "SampleGetALine: No object name on line %ws\n", Line ));
        RetVal = FALSE;
        goto Cleanup;
    }

    ObjectNameLength--;
    if ( ObjectNameString[ObjectNameLength] != ' ' ) {
        AzPrint(( AZD_PERSIST, "SampleGetALine: object name not blank terminated on line %ws\n", Line ));
        RetVal = FALSE;
        goto Cleanup;
    }

    RtlCopyMemory( FullNameBuffer, ObjectNameString, ObjectNameLength*sizeof(WCHAR) );
    FullNameBuffer[ObjectNameLength] = '\0';
    p = &p[ObjectNameLength+1];

    //
    // Parse off the object type string
    //

    ObjectTypeString = p;
    ObjectTypeLength = wcscspn( p, L" \n" );

    if ( ObjectTypeLength == 0 ) {
        AzPrint(( AZD_PERSIST, "SampleGetALine: No object type on line %ws\n", Line ));
        RetVal = FALSE;
        goto Cleanup;
    }

    p = &p[ObjectTypeLength+1];

    //
    // Convert the string to a number
    //

    for ( ObjectType = 0; ObjectType < ObjectTypeNamesSize; ObjectType++ ) {
        if ( wcsncmp( ObjectTypeString, ObjectTypeNames[ObjectType], ObjectTypeLength ) == 0 ) {
            break;
        }
    }

    if ( ObjectType >= ObjectTypeNamesSize ) {
        AzPrint(( AZD_PERSIST, "SampleGetALine: Bad object type %ws\n", Line ));
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Determine the level of this entry
    //

    Level = 1;  // AdminManager is level 0

    p = FullNameBuffer;
    *Name = p;

    for (;;) {
        p = wcsstr(p, SAMPLE_DELIM );

        if ( p == NULL ) {
            break;
        }

        p += SAMPLE_DELIM_SIZE/sizeof(WCHAR);

        Level ++;
        *Name = p;
    }

    RetVal = TRUE;

    //
    // Free locally used resources
    //
Cleanup:

    *RetObjectType = ObjectType;
    *RetLevel = Level;
    *LinePointer = Next;
    return RetVal;

}

DWORD
SamplePersistOpen(
    IN PAZP_ADMIN_MANAGER AdminManager,
    IN BOOL CreatePolicy
    )
/*++

Routine Description:

    This routine submits reads the authz policy database from storage.
    This routine also reads the policy database into cache.

    On Success, the caller should call SamplePersistClose to free any resources
        consumed by the open.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    AdminManager - Specifies the policy database that is to be read.

    CreatePolicy - TRUE if the policy database is to be created.
        FALSE if the policy database already exists

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus;
    PAZP_SAMPLE_CONTEXT PersistContext = NULL;
    LPWSTR Line;
    LPWSTR Next;

    LPBYTE Buffer = NULL;
    ULONG BufferSize;

    ULONG Level;
    ULONG CurrentLevel = 0;


    PGENERIC_OBJECT GenericObjectStack[8];
    LPWSTR BigBuffer = NULL;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    RtlZeroMemory( &GenericObjectStack[0], sizeof(GenericObjectStack) );
    GenericObjectStack[0] = (PGENERIC_OBJECT) AdminManager;

    SafeAllocaAllocate( BigBuffer, HUGE_BUFFER_SIZE );

    if ( BigBuffer == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Allocate a context describing this provider
    //

    PersistContext = (PAZP_SAMPLE_CONTEXT) AzpAllocateHeap( sizeof(*PersistContext) );

    if ( PersistContext == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    PersistContext->LastUsedGuid = 0;


    //
    // Read the file into a buffer
    //

    WinStatus = SampleReadFile( AdminManager->PolicyUrl.String,
                                CreatePolicy,
                                &PersistContext->FileHandle,
                                &Buffer,
                                &BufferSize );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_PERSIST, "SamplePersistOpen: Cannot SampleReadFile %ld\n", WinStatus ));
        goto Cleanup;
    }


    //
    // Loop through the file a line at a time
    //

    for ( Line = (LPWSTR)Buffer; Line != NULL ; Line = Next ) {
        ULONG ObjectType;
        LPWSTR ObjectNameString;
        AZP_STRING ObjectName;
        ULONG ObjectGuid;

        PGENERIC_OBJECT_HEAD ChildGenericObjectHead;

        //
        // Grab a line from the file
        //

        Next = Line;
        if ( !SampleGetALine( &Next,
                              &Level,
                              &ObjectType,
                              &ObjectGuid,
                              BigBuffer,
                              &ObjectNameString ) ) {
            break;
        }

        //
        // Cannot be more than one greater than the previous level
        //

        ASSERT( Level >= 1 );
        if ( Level > CurrentLevel+1 ) {
            AzPrint(( AZD_PERSIST, "SamplePersistOpen: %ld %ld File broken on line %ws\n", Level, CurrentLevel, Line ));
            WinStatus = ERROR_INTERNAL_DB_CORRUPTION;
            goto Cleanup;
        }

        //
        // Close any stacked pointers we'll no longer use
        //

        while ( CurrentLevel >= Level ) {
            ObDereferenceObject( GenericObjectStack[CurrentLevel] );
            GenericObjectStack[CurrentLevel] = NULL;
            CurrentLevel --;
        }
        CurrentLevel = Level;

        AzPrint(( AZD_PERSIST_MORE, "Open: %ws\n", ObjectNameString ));

        AzpInitString( &ObjectName, ObjectNameString );

        //
        // Search for the list to link this item into
        //

        for ( ChildGenericObjectHead = GenericObjectStack[CurrentLevel-1]->ChildGenericObjectHead;
              ChildGenericObjectHead != NULL;
              ChildGenericObjectHead = ChildGenericObjectHead->SiblingGenericObjectHead ) {

            if ( ObjectType == ChildGenericObjectHead->ObjectType ) {
                break;
            }
        }

        if ( ChildGenericObjectHead == NULL ) {
            AzPrint(( AZD_PERSIST,
                      "SamplePersistOpen: Parent doesn't support this child %ld %ws\n",
                      ObjectType,
                      ObjectNameString ));
            WinStatus = ERROR_INTERNAL_DB_CORRUPTION;
            goto Cleanup;
        }



        //
        // Actually create the object in the cache
        //

        WinStatus = ObCreateObject(
                        GenericObjectStack[CurrentLevel-1],   // ParentGenericObject
                        ChildGenericObjectHead,
                        ObjectType,
                        &ObjectName,
                        &GenericObjectStack[CurrentLevel] );  // Save pointer to generic object

        if ( ObjectType >= ObjectTypeNamesSize ) {
            AzPrint(( AZD_PERSIST,
                      "SamplePersistOpen: Cannot CreateObject from DB %ld %ld %ws\n",
                      WinStatus,
                      ObjectType,
                      ObjectNameString ));
            goto Cleanup;
        }

        //
        // Remember the GUID of the object
        //

        *(PULONG)&GenericObjectStack[CurrentLevel]->PersistenceGuid = ObjectGuid;
        PersistContext->LastUsedGuid = ObjectGuid;

        //
        // ??? A Real provider would set the attributes on the object here
        //


    }

    //
    // Return the context to the caller
    //

    AdminManager->PersistContext = PersistContext;
    PersistContext = NULL;
    WinStatus = NO_ERROR;
    //
    // Free locally used resources
    //
Cleanup:
    if ( PersistContext != NULL ) {
        AdminManager->PersistContext = PersistContext;
        SamplePersistClose( AdminManager );
    }

    while ( CurrentLevel >= 1 ) {
        ObDereferenceObject( GenericObjectStack[CurrentLevel] );
        GenericObjectStack[CurrentLevel] = NULL;
        CurrentLevel --;
    }

    if ( Buffer != NULL ) {
        AzpFreeHeap( Buffer );
    }

    SafeAllocaFree( BigBuffer );

    return WinStatus;

}

VOID
SamplePersistClose(
    IN PAZP_ADMIN_MANAGER AdminManager
    )
/*++

Routine Description:

    This routine submits close the authz policy database storage handles.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    AdminManager - Specifies the policy database that is to be read.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    PAZP_SAMPLE_CONTEXT PersistContext = (PAZP_SAMPLE_CONTEXT) AdminManager->PersistContext;
    ASSERT(PersistContext != NULL);

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Close the file handle
    //

    CloseHandle( PersistContext->FileHandle );

    //
    // Free the context itself
    //

    AzpFreeHeap( PersistContext );
    AdminManager->PersistContext = NULL;

}


DWORD
SamplePersistSubmit(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN DeleteMe
    )
/*++

Routine Description:

    This routine submits changes made to the authz policy database.

    If the object is being created, the GenericObject->PersistenceGuid field will be
    zero on input.  Upon successful creation, this routine will set PersistenceGuid to
    non-zero.  Upon failed creation, this routine will leave PersistenceGuid as zero.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object in the database that is to be updated
        in the underlying store.

    DeleteMe - TRUE if the object and all of its children are to be deleted.
        FALSE if the object is to be updated.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus;

    PAZP_SAMPLE_CONTEXT PersistContext = (PAZP_SAMPLE_CONTEXT) GenericObject->AdminManagerObject->PersistContext;

    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    BOOLEAN AllocatedGuid = FALSE;

    // Variables describing the GenericObject entry
    LPWSTR NewEntryBuffer = NULL;
    ULONG NewEntryLevel;
    ULONG NewEntryNameByteCount;
    AZP_STRING NewEntryObjectName;
    ULONG NewGuid;
    BOOL NewInserted = FALSE;


    PGENERIC_OBJECT CurrentGenericObject;
    PGENERIC_OBJECT NextGenericObject;
    ULONG BytesWritten;
    LPBYTE Where;

    LPWSTR Line;
    LPWSTR Next;
    LPWSTR CurrentFullObjectName = NULL;

    // Variables describing the existing file contents
    LPBYTE Buffer = NULL;
    ULONG BufferSize;

    //
    // Stack of descriptors of the buffers to write to the file
    //

    ULONG Index;
    ULONG StackIndex;
    LPBYTE BufferStack[30];
    ULONG SizeStack[30];
    LPSTR CommentStack[30];







    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    SafeAllocaAllocate( CurrentFullObjectName, HUGE_BUFFER_SIZE );

    if ( CurrentFullObjectName == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // If the object doesn't yet have a GUID,
    //  give it one.
    //

    if ( (*(PULONG)(&GenericObject->PersistenceGuid)) == 0 ) {
        PersistContext->LastUsedGuid ++;
        *(PULONG)(&GenericObject->PersistenceGuid) = PersistContext->LastUsedGuid;
        AllocatedGuid = TRUE;
    }
    NewGuid = *(PULONG)(&GenericObject->PersistenceGuid);

    //
    // Build the bytes to write to the file for the entry representing GenericObject
    //
    //

    SafeAllocaAllocate( NewEntryBuffer, HUGE_BUFFER_SIZE );

    if ( NewEntryBuffer == NULL ) {
        WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    NewEntryBuffer[0] = 0;
    NewEntryLevel = 0;

    //
    // Build the "GUID" first
    //

    swprintf( NewEntryBuffer, L"%ld ", *(PULONG)(&GenericObject->PersistenceGuid) );

    //
    // Build the object name next
    //
    Where = ((LPBYTE)NewEntryBuffer) + HUGE_BUFFER_SIZE - sizeof(WCHAR);

    NewEntryNameByteCount = sizeof(WCHAR);
    *((LPWSTR)Where) = '\0';

    for ( CurrentGenericObject=GenericObject;
          CurrentGenericObject != NULL;
          CurrentGenericObject=NextGenericObject ) {

        //
        // Copy the delimiter into the buffer
        //

        if ( CurrentGenericObject != GenericObject ) {
            Where -= SAMPLE_DELIM_SIZE;
            NewEntryNameByteCount += SAMPLE_DELIM_SIZE;
            RtlCopyMemory(
                   Where,
                   SAMPLE_DELIM,
                   SAMPLE_DELIM_SIZE );

        }
        //
        // Copy the name of the current object into the buffer
        //
        Where -= CurrentGenericObject->ObjectName.StringSize-sizeof(WCHAR);
        NewEntryNameByteCount += CurrentGenericObject->ObjectName.StringSize-sizeof(WCHAR);
        RtlCopyMemory(
               Where,
               CurrentGenericObject->ObjectName.String,
               CurrentGenericObject->ObjectName.StringSize-sizeof(WCHAR) );


        //
        // Get the address of the current object
        //
        NextGenericObject = CurrentGenericObject->ParentGenericObjectHead->ParentGenericObject;

        if ( NextGenericObject->ObjectType == OBJECT_TYPE_ADMIN_MANAGER ) {
            break;
        }

    }

    //
    // Move the data to the right spot in the buffer
    //

    NewEntryObjectName.String = &NewEntryBuffer[ (wcslen(NewEntryBuffer) * sizeof(WCHAR)) / sizeof(WCHAR) ];
    NewEntryObjectName.StringSize = NewEntryNameByteCount;

    RtlMoveMemory( NewEntryObjectName.String,
                   Where,
                   NewEntryNameByteCount );


    //
    // Output the object type
    //

    wcscat( NewEntryBuffer, L" " );
    if ( GenericObject->ObjectType < ObjectTypeNamesSize ) {
        wcscat( NewEntryBuffer, ObjectTypeNames[GenericObject->ObjectType] );
    } else {
        wcscat( NewEntryBuffer, L"[unknown]" );
    }


    //
    // Add modifiers
    //  ??? A real provider actually should persist the attributes of the object
    //

    if ( GenericObject->Flags & GENOBJ_FLAGS_DELETED ) {
        wcscat( NewEntryBuffer, L" [DEL]" );
    }
    if ( GenericObject->Flags & GENOBJ_FLAGS_DIRTY ) {
        wcscat( NewEntryBuffer, L" [DIRTY]" );
    }
    wcscat( NewEntryBuffer, L"\n" );
    AzPrint(( AZD_PERSIST_MORE, "%ws", NewEntryBuffer ));


    //
    // Read the file into a buffer
    //

    WinStatus = SampleReadFile( GenericObject->AdminManagerObject->PolicyUrl.String,
                                FALSE,  // Open existing file
                                &FileHandle,
                                &Buffer,
                                &BufferSize );

    if ( WinStatus != NO_ERROR ) {
        AzPrint(( AZD_PERSIST, "SamplePersistOpen: Cannot SampleReadFile %ld\n", WinStatus ));
        goto Cleanup;
    }


    //
    // Loop through the file a line at a time.
    //
    // Build a stack of the buffer fragments to write to the destination file.
    // Essentially, write the entire original buffer.
    // But, delete the object from the original buffer that has a guid matching the written object
    // And, insert the written object at the correct spot in the hierarchy.
    //
    //
    // The stack index points at the entry descrbing the 'remainder' of the buffer
    //
    StackIndex = 0;
    BufferStack[StackIndex] = Buffer;
    SizeStack[StackIndex] = BufferSize;
    CommentStack[StackIndex] = "First";

    for ( Line = (LPWSTR)Buffer; Line != NULL ; Line = Next ) {

        ULONG CurrentObjectType;
        LPWSTR CurrentObjectNameString;
        AZP_STRING CurrentObjectName;
        ULONG CurrentLevel;
        ULONG CurrentGuid;

        LONG CompareResult;
        BOOL InsertHere;


        //
        // Grab a line from the file
        //

        Next = Line;
        if ( !SampleGetALine( &Next,
                              &CurrentLevel,
                              &CurrentObjectType,
                              &CurrentGuid,
                              CurrentFullObjectName,
                              &CurrentObjectNameString ) ) {
            break;
        }

        AzpInitString( &CurrentObjectName, CurrentFullObjectName );

        //
        // Delete the object that has the matching guid
        //

        if ( CurrentGuid == NewGuid ) {

            //
            // Truncate the current buffer remainder to stop right before the current line
            //

            SizeStack[StackIndex] = (ULONG)(((LPBYTE)Line) - BufferStack[StackIndex]);

            //
            // Push a new 'remainder' onto the stack
            //

            StackIndex++;
            BufferStack[StackIndex] = (LPBYTE) Next;
            SizeStack[StackIndex] = (ULONG)(BufferSize - (BufferStack[StackIndex] - Buffer));
            CommentStack[StackIndex] = "Guid";
            continue;
        }


        //
        // Determine if this is where we insert the object being written
        //

        InsertHere = FALSE;
        CompareResult = AzpCompareStrings( &CurrentObjectName,
                                           &NewEntryObjectName );

        if ( CompareResult == 0 ) {
            WinStatus = GetLastError();
            goto Cleanup;


        //
        // If the current line has the same name as the one being written,
        //  inspect the types.
        //
        } else if ( CompareResult == CSTR_EQUAL ) {

            //
            // If the object types are the same,
            //  replace the current object.
            //

            if ( CurrentObjectType == GenericObject->ObjectType ) {

                ASSERT( FALSE );  // The GUIDS didn't match
                AzPrint(( AZD_PERSIST_MORE, "equal equal '%ws' '%ws'\n", CurrentObjectName.String, NewEntryObjectName.String ));
                continue;

            //
            // if the current object type is greater than the one being written,
            //  we've already passed it.
            //
            } else if ( CurrentObjectType > GenericObject->ObjectType ) {
                AzPrint(( AZD_PERSIST_MORE, "equal lt '%ws' '%ws'\n", CurrentObjectName.String, NewEntryObjectName.String ));
                InsertHere = TRUE;
            } else {
            }

        //
        // If the current line is greater than the one being written,
        //  we've already passed it.  We're done looping
        //
        } else if ( CompareResult == CSTR_GREATER_THAN ) {

            AzPrint(( AZD_PERSIST_MORE, "gt '%ws' '%ws'\n", CurrentObjectName.String, NewEntryObjectName.String ));
            InsertHere = TRUE;
        }

        //
        // Put the current object here
        //

        if ( InsertHere ) {
            if ( !DeleteMe ) {

                //
                // Truncate the current buffer remainder to stop right before the current line
                //

                SizeStack[StackIndex] = (ULONG)(((LPBYTE)Line) - BufferStack[StackIndex]);

                //
                // Push the new object onto the stack
                //

                StackIndex++;
                BufferStack[StackIndex] = (LPBYTE) NewEntryBuffer;
                SizeStack[StackIndex] = wcslen(NewEntryBuffer) * sizeof(WCHAR);
                CommentStack[StackIndex] = "New";
                NewInserted = TRUE;

                //
                // Push a new 'remainder' onto the stack
                //

                StackIndex++;
                BufferStack[StackIndex] = (LPBYTE) Line;
                SizeStack[StackIndex] = (ULONG)(BufferSize - (BufferStack[StackIndex] - Buffer));
                CommentStack[StackIndex] = "Post";

            }
            break;
        }

    }

    //
    // If we didn't insert it yet,
    //  do it now
    if ( !NewInserted && !DeleteMe ) {

        //
        // Push the new object onto the stack
        //

        StackIndex++;
        BufferStack[StackIndex] = (LPBYTE) NewEntryBuffer;
        SizeStack[StackIndex] = wcslen(NewEntryBuffer) * sizeof(WCHAR);
        CommentStack[StackIndex] = "New";
        NewInserted = TRUE;

    }

    //
    // Truncate the file since we're writing it from scratch
    //  ??? A real provider wouldn't write the whole database from scratch
    //

    if ( SetFilePointer( FileHandle, 0, NULL, FILE_BEGIN ) == INVALID_SET_FILE_POINTER ) {
        WinStatus = GetLastError();
        AzPrint(( AZD_PERSIST, "SamplePersistSubmit: Cannot SetFilePointer %ld\n", WinStatus ));
        goto Cleanup;
    }
    if ( !SetEndOfFile( FileHandle ) ) {
        WinStatus = GetLastError();
        AzPrint(( AZD_PERSIST, "SamplePersistSubmit: Cannot SetEndofFile %ld\n", WinStatus ));
        goto Cleanup;
    }

    //
    // Write the various parts of the data back to the file
    //
    // ???  A real provider should ensure that a failed write
    //  doesn't destroy previous good written data.  Either the write
    //  of the entire database can be atomic.  Or the write of this
    //  particular object can be atomic.
    //

    for ( Index=0; Index<=StackIndex; Index++ ) {

        if ( BufferStack[Index] != NULL && SizeStack[Index] != 0 ) {

            AzPrint(( AZD_PERSIST_MORE,
                      "%s: %ld %*.*ws\n",
                      CommentStack[Index],
                      SizeStack[Index],
                      SizeStack[Index]/sizeof(WCHAR),
                      SizeStack[Index]/sizeof(WCHAR),
                      BufferStack[Index] ));

            if ( !WriteFile( FileHandle,
                             BufferStack[Index],
                             SizeStack[Index],
                             &BytesWritten,
                             NULL ) ) {

                WinStatus = GetLastError();
                AzPrint(( AZD_PERSIST, "SamplePersistSubmit: Cannot WriteFile %ld\n", WinStatus ));
                goto Cleanup;
            }
        }
    }

    WinStatus = NO_ERROR;


    //
    // Free locally used resources
    //
Cleanup:
    if ( WinStatus != NO_ERROR ) {

        if ( AllocatedGuid ) {
            RtlZeroMemory( &GenericObject->PersistenceGuid, sizeof(GenericObject->PersistenceGuid) );
        }
    }

    if ( Buffer != NULL ) {
        AzpFreeHeap( Buffer );
    }

    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }

    SafeAllocaFree( NewEntryBuffer );
    SafeAllocaFree( CurrentFullObjectName );

    return WinStatus;

}

DWORD
SamplePersistRefresh(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine updates the attributes of the object from the policy database.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object in the database whose cache entry is to be
        updated
        The GenericObject->PersistenceGuid field should be non-zero on input.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus = NO_ERROR;

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // ??? A real provider needs to implement this routine
    //

    return WinStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\scope.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    scope.cxx

Abstract:

    Routines implementing the Scope object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"



DWORD
AzpScopeInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzScopeCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_SCOPE Scope = (PAZP_SCOPE) ChildGenericObject;
    PAZP_APPLICATION Application = (PAZP_APPLICATION) ParentGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION );

    //
    // Initialize the lists of child objects
    //  Let the generic object manager know all of the types of children we support
    //

    ChildGenericObject->ChildGenericObjectHead = &Scope->Groups;

    // List of child groups
    ObInitGenericHead( &Scope->Groups,
                       OBJECT_TYPE_GROUP,
                       ChildGenericObject,
                       &Scope->Roles,
                       &Application->Groups );     // Shares namespace with the groups of my parent object

    // List of child roles
    ObInitGenericHead( &Scope->Roles,
                       OBJECT_TYPE_ROLE,
                       ChildGenericObject,
                       &Scope->AzpSids,
                       NULL );                      // Doesn't share namespace

    // List of child AzpSids
    ObInitGenericHead( &Scope->AzpSids,
                       OBJECT_TYPE_SID,
                       ChildGenericObject,
                       NULL,
                       NULL );                      // Doesn't share namespace

    //
    // Scopes are referenced by "Roles"
    //  Let the generic object manager know all of the lists we support
    //  This is a "back" link so we don't need to define which Roles can reference this scope.
    //

    ChildGenericObject->GenericObjectLists = &Scope->backRoles;

    // Back link to roles
    ObInitObjectList( &Scope->backRoles,
                      NULL,
                      TRUE, // Backward link
                      0,    // No link pair id
                      NULL,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpScopeFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Scope object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_SCOPE Scope = (PAZP_SCOPE) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //


}



DWORD
WINAPI
AzScopeCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ScopeHandle
    )
/*++

Routine Description:

    This routine adds a scope into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    ScopeName - Specifies the name of the scope to add.

    Reserved - Reserved.  Must by zero.

    ScopeHandle - Return a handle to the scope.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Scopes),
                    OBJECT_TYPE_SCOPE,
                    ScopeName,
                    Reserved,
                    (PGENERIC_OBJECT *) ScopeHandle );
}



DWORD
WINAPI
AzScopeOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE ScopeHandle
    )
/*++

Routine Description:

    This routine opens a scope into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    ScopeName - Specifies the name of the scope to open

    Reserved - Reserved.  Must by zero.

    ScopeHandle - Return a handle to the scope.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no scope by that name

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Scopes),
                    OBJECT_TYPE_SCOPE,
                    ScopeName,
                    Reserved,
                    (PGENERIC_OBJECT *) ScopeHandle );
}


DWORD
WINAPI
AzScopeEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE ScopeHandle
    )
/*++

Routine Description:

    Enumerates all of the scopes for the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next scope to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    ScopeHandle - Returns a handle to the next scope object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Scopes),
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) ScopeHandle );

}


DWORD
WINAPI
AzScopeGetProperty(
    IN AZ_HANDLE ScopeHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for a scope.

Arguments:

    ScopeHandle - Specifies a handle to the scope

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonGetProperty(
                    (PGENERIC_OBJECT) ScopeHandle,
                    OBJECT_TYPE_SCOPE,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzScopeSetProperty(
    IN AZ_HANDLE ScopeHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for a scope.

Arguments:

    ScopeHandle - Specifies a handle to the scope

    PropertyId - Specifies which property to set

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonSetProperty(
                    (PGENERIC_OBJECT) ScopeHandle,
                    OBJECT_TYPE_SCOPE,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}



DWORD
WINAPI
AzScopeDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR ScopeName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a scope from the scope of the specified application.
    Also deletes any child objects of ScopeName.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    ScopeName - Specifies the name of the scope to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Scopes),
                    OBJECT_TYPE_SCOPE,
                    ScopeName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\persist.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    persist.cxx

Abstract:

    Routines implementing the common logic for persisting the authz policy.

    This file contains routine called by the core logic to submit changes.
    It also contains routines that are called by the particular providers to
    find out information about the changed objects.

Author:

    Cliff Van Dyke (cliffv) 9-May-2001

--*/

#include "pch.hxx"


//
// The enumeration context describes the current state of an enumeration
// through the list of all the objects in the authz policy database
//

typedef struct _AZP_PERSIST_ENUM_CONTEXT {

    //
    // Stack Index
    //  The enumeration walks the tree of objects. While enumerating child objects,
    //  the context of the parent object enumeration is kept on the stack of contexts.
    //

    ULONG StackIndex;
#define AZ_PERSIST_MAX_INDEX 4


    //
    // Pointer to the current Generic Child Head being enumerated
    //
    PGENERIC_OBJECT_HEAD GenericChildHead[AZ_PERSIST_MAX_INDEX];
    ULONG EnumerationContext[AZ_PERSIST_MAX_INDEX];

} AZP_PERSIST_ENUM_CONTEXT, *PAZP_PERSIST_ENUM_CONTEXT;



DWORD
AzpPersistOpen(
    IN PAZP_ADMIN_MANAGER AdminManager,
    IN BOOL CreatePolicy
    )
/*++

Routine Description:

    This routine open the authz policy database.
    This routine also reads the policy database into cache.

    On Success, the caller should call SamplePersistClose to free any resources
        consumed by the open.

    This routine routes the request to the correct provider.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    AdminManager - Specifies the policy database that is to be read.

    CreatePolicy - TRUE if the policy database is to be created.
        FALSE if the policy database already exists

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    ERROR_ALREADY_EXISTS - CreatePolicy is TRUE and the policy already exists
    ERROR_FILE_NOT_FOUND - CreatePolicy is FALSE and the policy does not already exist
    Other status codes

--*/
{

    //
    // Call the appropriate provider
    //
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    return SamplePersistOpen( AdminManager, CreatePolicy );

}

VOID
AzpPersistClose(
    IN PAZP_ADMIN_MANAGER AdminManager
    )
/*++

Routine Description:

    This routine closes the authz policy database storage handles.
    This routine routes the request to the correct provider.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    AdminManager - Specifies the policy database that is to be read.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    //
    // Call the appropriate provider
    //
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    SamplePersistClose( AdminManager );

}



DWORD
AzpPersistSubmit(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN DeleteMe
    )
/*++

Routine Description:

    This routine submits changes made to the authz policy database.
    This routine routes the request to the correct provider.

    If the object is being created, the GenericObject->PersistenceGuid field will be
    zero on input.  Upon successful creation, this routine will set PersistenceGuid to
    non-zero.  Upon failed creation, this routine will leave PersistenceGuid as zero.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object in the database that is to be updated
        in the underlying store.

    DeleteMe - TRUE if the object and all of its children are to be deleted.
        FALSE if the object is to be updated.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus = NO_ERROR;

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Only persist dirty objects
    //

    if ( (GenericObject->Flags & GENOBJ_FLAGS_DIRTY) != 0 ||
         DeleteMe ) {

        //
        // Call the appropriate provider
        //

        WinStatus = SamplePersistSubmit( GenericObject, DeleteMe );

        //
        // Turn off the dirty bit

        if ( WinStatus == NO_ERROR ) {
            GenericObject->Flags &= ~GENOBJ_FLAGS_DIRTY;
        }

    }

    return WinStatus;

}



DWORD
AzpPersistRefresh(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine updates the attributes of the object from the policy database.

    This routine routes the request to the correct provider.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies the object in the database whose cache entry is to be
        updated
        The GenericObject->PersistenceGuid field should be non-zero on input.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    DWORD WinStatus = NO_ERROR;

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    //  Clear the attributes from the object so that the underlying routines only have
    //  to re-populate the attributes.
    //

    ObFreeGenericObject( GenericObject, TRUE );

    //
    // Object no longer needs to be refreshed and is no longer dirty.
    //

    GenericObject->Flags &= ~(GENOBJ_FLAGS_REFRESH_ME|GENOBJ_FLAGS_DIRTY);


    //
    // Call the appropriate provider
    //

    WinStatus = SamplePersistRefresh( GenericObject );

    if ( WinStatus != NO_ERROR ) {

        //
        // Object needs to be refreshed
        //

        GenericObject->Flags |= GENOBJ_FLAGS_REFRESH_ME;

    }

    return WinStatus;

}


#if 0   // Providers don't actually call these yet
DWORD
AzpPersistEnumOpen(
    IN PAZP_ADMIN_MANAGER AdminManager,
    OUT PVOID *PersistEnumContext
    )
/*++

Routine Description:

    This routine begins an enumeration of the all objects in the authz policy database.

    A peristance provider will call this routine to determine which objects have changed.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    AdminManager - Specifies the policy database that is being queried

    PersistEnumContext - Returns a context that can be passed to AzpPersistEnumNext.
        This context must be closed by calling AzpPersistClose.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    PAZP_PERSIST_ENUM_CONTEXT Context = NULL;

    //
    // Allocate memory for the context
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    Context = (PAZP_PERSIST_ENUM_CONTEXT) AzpAllocateHeap( sizeof(*Context) );

    if ( Context == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize it
    //

    Context->StackIndex = 0;
    Context->GenericChildHead[0] = AdminManager->GenericObject.ChildGenericObjectHead;
    Context->EnumerationContext[0] = 0;

    //
    // Return the context to the caller
    //

    *PersistEnumContext = Context;
    return NO_ERROR;

}

DWORD
AzpPersistEnumNext(
    IN PVOID PersistEnumContext,
    OUT PGENERIC_OBJECT *GenericObject
    )
/*++

Routine Description:

    This routine returns the next object in the list of all objects in the authz policy database.

    A peristance provider will call this routine to determine which objects have changed.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    PersistEnumContext - A context describing the current state of the enumeration

    GenericObject - Returns a pointer to an next object.  The provider should inspect the
        GENOBJ_FLAGS_DELETED and GENOBJ_FLAGS_DIRTY flags to determine whether the
        object has been modified.

Return Value:

    NO_ERROR - The operation was successful (a GenericObject was returned)
    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

    Other status codes

--*/
{
    DWORD WinStatus;

    PAZP_PERSIST_ENUM_CONTEXT Context = (PAZP_PERSIST_ENUM_CONTEXT) PersistEnumContext;

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Loop until we find another object to return
    //

    for (;;) {

        //
        // Don't return pseudo objects to the caller.
        //

        if ( Context->GenericChildHead[Context->StackIndex]->ObjectType != OBJECT_TYPE_SID ) {

            //
            // Get the next object from the current list
            //

            WinStatus = ObEnumObjects( Context->GenericChildHead[Context->StackIndex],
                                       TRUE, // return deleted objects
                                       FALSE, // Don't refresh the cache
                                       &Context->EnumerationContext[Context->StackIndex],
                                       GenericObject );


            //
            // Before returning the current object,
            //  set up the context to enumerate all children of the current context
            //

            if ( WinStatus == NO_ERROR ) {

                //
                // Only push onto the stack if the current object can have children
                //

                if ( (*GenericObject)->ChildGenericObjectHead != NULL ) {

                    if ( Context->StackIndex+1 >= AZ_PERSIST_MAX_INDEX ) {
                        ASSERT(FALSE);
                        return ERROR_INTERNAL_ERROR;
                    }

                    Context->StackIndex++;
                    Context->GenericChildHead[Context->StackIndex] = (*GenericObject)->ChildGenericObjectHead;
                    Context->EnumerationContext[Context->StackIndex] = 0;
                }

                return NO_ERROR;
            }

            if ( WinStatus != ERROR_NO_MORE_ITEMS ) {
                return WinStatus;
            }
        }

        //
        // Move on to the next set of sibling object types.
        //

        Context->EnumerationContext[Context->StackIndex] = 0;
        if ( Context->GenericChildHead[Context->StackIndex]->SiblingGenericObjectHead != NULL ) {
            Context->GenericChildHead[Context->StackIndex] = Context->GenericChildHead[Context->StackIndex]->SiblingGenericObjectHead;
            continue;
        }

        //
        // There are no more sibling object types for the same parent.
        // Continue the enumeration of the parent objects
        //

        if ( Context->StackIndex == 0 ) {
            return ERROR_NO_MORE_ITEMS;
        }

        Context->StackIndex--;


    }



}

DWORD
AzpPersistEnumClose(
    IN PVOID PersistEnumContext
    )
/*++

Routine Description:

    This routine returns free any resources consumed by the PersistEnumContext.

    A peristance provider will call this routine after determining which objects have changed.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    PersistEnumContext - A context describing the current state of the enumeration

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other status codes

--*/
{
    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpFreeHeap( PersistEnumContext );
    return NO_ERROR;
}
#endif // 0   // Providers don't actually call these yet



DWORD
WINAPI
AzSubmit(
    IN AZ_HANDLE AzHandle,
    IN DWORD Reserved
    )
/*++

Routine Description:

    Submit the changes made to the object via the *Create, *SetProperty, or *SetPropertyItem
    APIs.

    On failure, any changes made to the object are undone.

Arguments:

    AzHandle - Passes in the handle to be updated.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful.

    ERROR_INVALID_HANDLE - The passed in handle was invalid

--*/
{
    DWORD WinStatus;

    PGENERIC_OBJECT ReferencedGenericObject = NULL;
    PGENERIC_OBJECT GenericObject = (PGENERIC_OBJECT) AzHandle;
    DWORD ObjectType;

    //
    // Grab the global lock
    //  Only for the admin manager case do we modify anything.
    //

    AzpLockResourceExclusive( &AzGlResource );

    //
    // Validate the input parameters
    //
    if ( Reserved != 0 ) {
        AzPrint(( AZD_INVPARM, "AzCloseHandle: Reserved != 0\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Determine the type of the object
    //

    WinStatus = ObGetHandleType( GenericObject,
                                 FALSE,   // Don't allow deleted objects
                                 &ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Grab the lock exclusively if we're going to change the database
    //

    if ( ObjectType == OBJECT_TYPE_ADMIN_MANAGER ) {
        AzPrint(( AZD_INVPARM, "AzCloseHandle: Can't persist admin manager.\n" ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Validate the passed in handle
    //

    WinStatus = ObReferenceObjectByHandle( GenericObject,
                                           FALSE,   // Don't allow deleted objects
                                           TRUE,    // Refresh the cache
                                           ObjectType );

    if ( WinStatus != NO_ERROR ) {
        goto Cleanup;
    }

    ReferencedGenericObject = GenericObject;

    //
    // Submit the change
    //    ??? On failure, update the cache to match the object
    //

    WinStatus = AzpPersistSubmit( GenericObject, FALSE );

    if ( WinStatus != NO_ERROR ) {

        //
        // Update the cache to match the real object
        //
        // If we were trying to persist a creation of the object,
        //  delete the object from the cache.
        //

        if ( IsEqualGUID( GenericObject->PersistenceGuid, AzGlZeroGuid ) ) {

            //
            // Mark the entry (and its child objects) as deleted
            //  We do this since other threads may have references to the objects.
            //  We want to ensure those threads know the objects are deleted.
            //

            ObMarkObjectDeleted( GenericObject );


            //
            // Remove the reference representing the list from the parent.
            //

            ObDereferenceObject( GenericObject );

        } else {


            //
            // Refresh the cache
            //  Ignore the status code
            //

            (VOID) AzpPersistRefresh( GenericObject );

        }
        goto Cleanup;
    }


    WinStatus = NO_ERROR;

    //
    // Free locally used resources
    //
Cleanup:

    if ( ReferencedGenericObject != NULL ) {
        ObDereferenceObject( ReferencedGenericObject );
    }

    //
    // Drop the global lock
    //

    AzpUnlockResource( &AzGlResource );

    return WinStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\persist.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    persist.h

Abstract:

    Routines implementing the common logic for persisting the authz policy.

    This file contains routine called by the core logic to submit changes.
    It also contains routines that are called by the particular providers to
    find out information about the changed objects.

Author:

    Cliff Van Dyke (cliffv) 9-May-2001

--*/


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Procedures that simply route to the providers
//

DWORD
AzpPersistOpen(
    IN PAZP_ADMIN_MANAGER AdminManager,
    IN BOOL CreatePolicy
    );

VOID
AzpPersistClose(
    IN PAZP_ADMIN_MANAGER AdminManager
    );

DWORD
AzpPersistSubmit(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN DeleteMe
    );

DWORD
AzpPersistRefresh(
    IN PGENERIC_OBJECT GenericObject
    );

//
// Procedures called by the providers
//

DWORD
AzpPersistEnumOpen(
    IN PAZP_ADMIN_MANAGER AdminManager,
    OUT PVOID *PersistEnumContext
    );

DWORD
AzpPersistEnumNext(
    IN PVOID PersistEnumContext,
    OUT PGENERIC_OBJECT *GenericObject
    );

DWORD
AzpPersistEnumClose(
    IN PVOID PersistEnumContext
    );

//
// Procedures implemented by the sample provider
//

DWORD
SamplePersistOpen(
    IN PAZP_ADMIN_MANAGER AdminManager,
    IN BOOL CreatePolicy
    );

VOID
SamplePersistClose(
    IN PAZP_ADMIN_MANAGER AdminManager
    );

DWORD
SamplePersistSubmit(
    IN PGENERIC_OBJECT GenericObject,
    IN BOOLEAN DeleteMe
    );

DWORD
SamplePersistRefresh(
    IN PGENERIC_OBJECT GenericObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\stdafx.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    stdafx.cxx

Abstract:

    generated file, don't change

// stdafx.cxx : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\stdafx.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    standard com include file

Author:

    Xiaoxi Tan (xtan) 11-May-2001

--*/

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E58F938B_4BAB_4FC1_BC5C_60D1A67E6C7E__INCLUDED_)
#define AFX_STDAFX_H__E58F938B_4BAB_4FC1_BC5C_60D1A67E6C7E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT 1
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E58F938B_4BAB_4FC1_BC5C_60D1A67E6C7E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\sid.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    sid.cxx

Abstract:

    Routines implementing the SID pseudo-object.

Author:

    Cliff Van Dyke (cliffv) 8-May-2001

--*/

#include "pch.hxx"



DWORD
AzpSidInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzSidCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_SID AzpSid = (PAZP_SID) ChildGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Behave differently depending on the object type of the parent object
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_ADMIN_MANAGER ||
            ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION ||
            ParentGenericObject->ObjectType == OBJECT_TYPE_SCOPE );

    //
    // Sids are referenced by groups and roles.
    //
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &AzpSid->backGroupMembers,

    // Sids are referenced by groups
    ObInitObjectList( &AzpSid->backGroupMembers,
                      &AzpSid->backGroupNonMembers,
                      TRUE,     // backward link
                      AZP_LINKPAIR_SID_MEMBERS,
                      NULL,
                      NULL,
                      NULL );

    ObInitObjectList( &AzpSid->backGroupNonMembers,
                      &AzpSid->backRoles,
                      TRUE,     // backward link
                      AZP_LINKPAIR_SID_NON_MEMBERS,
                      NULL,
                      NULL,
                      NULL );

    // Sids are referenced by "Roles"
    ObInitObjectList( &AzpSid->backRoles,
                      NULL,
                      TRUE,     // Backward link
                      0,        // No link pair id
                      NULL,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpSidFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Sid object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    // PAZP_SID AzpSid = (PAZP_SID) GenericObject;
    UNREFERENCED_PARAMETER( GenericObject );

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\stdafx_stub.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    stdafx_stub.cxx

Abstract:

    Stub file that does nothing but turn off some compiler warnings then
    includes the machine-generated stdafx.c

Author:

    Cliff Van Dyke (cliffv) 23-May-2001

--*/

#include "pch.hxx"

#pragma warning ( disable : 4100 ) // : unreferenced formal parameter
#pragma warning ( disable : 4189 ) // : local variable is initialized but not referenced
#pragma warning ( disable : 4505 ) // : unreferenced local function has been removed

#include "stdafx.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keycpl\apsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by KEYMGR.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1074
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\task.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    task.cxx

Abstract:

    Routines implementing the Task object

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/

#include "pch.hxx"



DWORD
AzpTaskInit(
    IN PGENERIC_OBJECT ParentGenericObject,
    IN PGENERIC_OBJECT ChildGenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for AzTaskCreate.  It does any object specific
    initialization that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    ParentGenericObject - Specifies the parent object to add the child object onto.
        The reference count has been incremented on this object.

    ChildGenericObject - Specifies the newly allocated child object.
        The reference count has been incremented on this object.

Return Value:

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    PAZP_TASK Task = (PAZP_TASK) ChildGenericObject;
    PAZP_APPLICATION Application = (PAZP_APPLICATION) ParentGenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );


    //
    // Sanity check the parent
    //

    ASSERT( ParentGenericObject->ObjectType == OBJECT_TYPE_APPLICATION );

    //
    // Tasks reference 'Operations' that are children of the same 'Application' as the Task object
    //  Let the generic object manager know all of the lists we support
    //

    ChildGenericObject->GenericObjectLists = &Task->Operations,
    ObInitObjectList( &Task->Operations,
                      NULL,
                      FALSE, // Forward link
                      0,     // No link pair id
                      &Application->Operations,
                      NULL,
                      NULL );


    return NO_ERROR;
}


VOID
AzpTaskFree(
    IN PGENERIC_OBJECT GenericObject
    )
/*++

Routine Description:

    This routine is a worker routine for Task object free.  It does any object specific
    cleanup that needs to be done.

    On entry, AzGlResource must be locked exclusively.

Arguments:

    GenericObject - Specifies a pointer to the object to be deleted.

Return Value:

    None

--*/
{
    PAZP_TASK Task = (PAZP_TASK) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );

    //
    // Free any local strings
    //

    AzpFreeString( &Task->BizRule );
    AzpFreeString( &Task->BizRuleLanguage );

}


DWORD
AzpTaskGetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzTaskGetProperty.  It does any object specific
    property gets.

    On entry, AzGlResource must be locked shared.

Arguments:

    GenericObject - Specifies a pointer to the object to be queried

    PropertyId - Specifies which property to return.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_TASK_BIZRULE          LPWSTR - Biz rule for the task
        AZ_PROP_TASK_BIZRULE_LANGUAGE LPWSTR - Biz language rule for the task
        AZ_PROP_TASK_OPERATIONS       AZ_STRING_ARRAY - Operations granted by this task

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_TASK Task = (PAZP_TASK) GenericObject;

    //
    // Initialization
    //

    ASSERT( AzpIsLockedShared( &AzGlResource ) );


    //
    // Return any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // Return BizRule to the caller
    //
    case AZ_PROP_TASK_BIZRULE:

        *PropertyValue = AzpGetStringProperty( &Task->BizRule );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    // Return BizRule language to the caller
    //
    case AZ_PROP_TASK_BIZRULE_LANGUAGE:

        *PropertyValue = AzpGetStringProperty( &Task->BizRuleLanguage );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    //
    // Return the set of operations to the caller
    //
    case AZ_PROP_TASK_OPERATIONS:

        *PropertyValue = ObGetPropertyItems( &Task->Operations );

        if ( *PropertyValue == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        }

        break;

    default:
        AzPrint(( AZD_INVPARM, "AzTaskGetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        break;
    }

    return WinStatus;
}


DWORD
AzpTaskSetProperty(
    IN PGENERIC_OBJECT GenericObject,
    IN ULONG PropertyId,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    This routine is a worker routine for AzTaskSetProperty.  It does any object specific
    property sets.

    On entry, AzGlResource must be locked exclusive.

Arguments:

    GenericObject - Specifies a pointer to the object to be modified

    PropertyId - Specifies which property to set.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_TASK_BIZRULE          LPWSTR - Biz rule for the task
        AZ_PROP_TASK_BIZRULE_LANGUAGE LPWSTR - Biz language rule for the task

Return Value:

    Status of the operation

--*/
{
    DWORD WinStatus = NO_ERROR;
    PAZP_TASK Task = (PAZP_TASK) GenericObject;
    AZP_STRING CapturedString;

    AZP_STRING ValidValue1;
    AZP_STRING ValidValue2;


    //
    // Initialization
    //

    ASSERT( AzpIsLockedExclusive( &AzGlResource ) );
    AzpInitString( &CapturedString, NULL );


    //
    // Set any object specific attribute
    //

    switch ( PropertyId ) {

    //
    // Set BizRule on the object
    //
    case AZ_PROP_TASK_BIZRULE:

        //
        // Capture the input string
        //

        WinStatus = AzpCaptureString( &CapturedString,
                                      (LPWSTR) PropertyValue,
                                      AZ_MAX_TASK_BIZRULE_LENGTH,
                                      TRUE ); // NULL is OK

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Swap the old/new names
        //

        AzpSwapStrings( &CapturedString, &Task->BizRule );
        break;

    //
    // Set BizRule language on the object
    //
    case AZ_PROP_TASK_BIZRULE_LANGUAGE:

        //
        // Capture the input string
         //

        WinStatus = AzpCaptureString( &CapturedString,
                                      (LPWSTR) PropertyValue,
                                      AZ_MAX_TASK_BIZRULE_LANGUAGE_LENGTH,
                                      TRUE ); // NULL is OK

        if ( WinStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // Ensure it is one of the valid values
        //

        AzpInitString( &ValidValue1, L"VBScript" );
        AzpInitString( &ValidValue2, L"JScript" );

        if ( !AzpEqualStrings( &CapturedString, &ValidValue1) &&
             !AzpEqualStrings( &CapturedString, &ValidValue2) ) {
            AzPrint(( AZD_INVPARM, "AzTaskSetProperty: invalid language %ws\n", CapturedString.String ));
            WinStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Swap the old/new names
        //

        AzpSwapStrings( &CapturedString, &Task->BizRuleLanguage );
        break;

    default:
        AzPrint(( AZD_INVPARM, "AzTaskSetProperty: invalid prop id %ld\n", PropertyId ));
        WinStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Free any local resources
    //
Cleanup:
    AzpFreeString( &CapturedString );

    return WinStatus;
}



DWORD
WINAPI
AzTaskCreate(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE TaskHandle
    )
/*++

Routine Description:

    This routine adds a task into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    TaskName - Specifies the name of the task to add.

    Reserved - Reserved.  Must by zero.

    TaskHandle - Return a handle to the task.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_ALREADY_EXISTS - An object by that name already exists

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonCreateObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Tasks),
                    OBJECT_TYPE_TASK,
                    TaskName,
                    Reserved,
                    (PGENERIC_OBJECT *) TaskHandle );
}



DWORD
WINAPI
AzTaskOpen(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved,
    OUT PAZ_HANDLE TaskHandle
    )
/*++

Routine Description:

    This routine opens a task into the scope of the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    TaskName - Specifies the name of the task to open

    Reserved - Reserved.  Must by zero.

    TaskHandle - Return a handle to the task.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - There is no task by that name

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonOpenObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Tasks),
                    OBJECT_TYPE_TASK,
                    TaskName,
                    Reserved,
                    (PGENERIC_OBJECT *) TaskHandle );
}


DWORD
WINAPI
AzTaskEnum(
    IN AZ_HANDLE ApplicationHandle,
    IN DWORD Reserved,
    IN OUT PULONG EnumerationContext,
    OUT PAZ_HANDLE TaskHandle
    )
/*++

Routine Description:

    Enumerates all of the tasks for the specified application.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    Reserved - Reserved.  Must by zero.

    EnumerationContext - Specifies a context indicating the next task to return
        On input for the first call, should point to zero.
        On input for subsequent calls, should point to the value returned on the previous call.
        On output, returns a value to be passed on the next call.

    TaskHandle - Returns a handle to the next task object.
        The caller must close this handle by calling AzCloseHandle.

Return Value:

    NO_ERROR - The operation was successful (a handle was returned)

    ERROR_NO_MORE_ITEMS - No more items were available for enumeration

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonEnumObjects(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Tasks),
                    EnumerationContext,
                    Reserved,
                    (PGENERIC_OBJECT *) TaskHandle );

}


DWORD
WINAPI
AzTaskGetProperty(
    IN AZ_HANDLE TaskHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    OUT PVOID *PropertyValue
    )
/*++

Routine Description:

    Returns the specified property for a task.

Arguments:

    TaskHandle - Specifies a handle to the task

    PropertyId - Specifies which property to return.

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to return the property in.
        The returned pointer must be freed using AzFreeMemory.
        The returned value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object

        AZ_PROP_TASK_BIZRULE          LPWSTR - Biz rule for the task
        AZ_PROP_TASK_BIZRULE_LANGUAGE LPWSTR - Biz language rule for the task


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonGetProperty(
                    (PGENERIC_OBJECT) TaskHandle,
                    OBJECT_TYPE_TASK,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzTaskSetProperty(
    IN AZ_HANDLE TaskHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Sets the specified property for a task.

Arguments:

    TaskHandle - Specifies a handle to the task

    PropertyId - Specifies which property to set

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to the property.
        The specified value and type depends in PropertyId.  The valid values are:

        AZ_PROP_NAME        LPWSTR - Object name of the object
        AZ_PROP_DESCRIPTION LPWSTR - Description of the object

Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonSetProperty(
                    (PGENERIC_OBJECT) TaskHandle,
                    OBJECT_TYPE_TASK,
                    PropertyId,
                    Reserved,
                    PropertyValue );
}


DWORD
WINAPI
AzTaskAddPropertyItem(
    IN AZ_HANDLE TaskHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Adds an item to the list of items specified by PropertyId.

Arguments:

    TaskHandle - Specifies a handle to the task

    PropertyId - Specifies which property to modify

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to item to add.
        The specified value and type depends on PropertyId.  The valid values are:

        AZ_PROP_TASK_OPERATIONS          LPWSTR - Operation granted by this task


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

    ERROR_NOT_FOUND - There is no object by that name

    ERROR_ALREADY_EXISTS - An item by that name already exists in the list

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;

    //
    // Validate the Property ID
    //

    switch ( PropertyId ) {
    case AZ_PROP_TASK_OPERATIONS:
        GenericObjectList = &((PAZP_TASK)TaskHandle)->Operations;
        break;
    default:
        AzPrint(( AZD_INVPARM, "AzTaskAddPropertyItem: invalid prop id %ld\n", PropertyId ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonAddPropertyItem(
                    (PGENERIC_OBJECT) TaskHandle,
                    OBJECT_TYPE_TASK,
                    GenericObjectList,
                    Reserved,
                    (LPWSTR) PropertyValue );

}


DWORD
WINAPI
AzTaskRemovePropertyItem(
    IN AZ_HANDLE TaskHandle,
    IN ULONG PropertyId,
    IN DWORD Reserved,
    IN PVOID PropertyValue
    )
/*++

Routine Description:

    Remove an item from the list of items specified by PropertyId.

Arguments:

    TaskHandle - Specifies a handle to the task

    PropertyId - Specifies which property to modify

    Reserved - Reserved.  Must by zero.

    PropertyValue - Specifies a pointer to item to remove.
        The specified value and type depends on PropertyId.  The valid values are:

        AZ_PROP_TASK_OPERATIONS          LPWSTR - Operation granted by this task


Return Value:

    NO_ERROR - The operation was successful

    ERROR_INVALID_PARAMETER - PropertyId isn't valid

    ERROR_NOT_FOUND - There is no item by that name in the list

--*/
{
    PGENERIC_OBJECT_LIST GenericObjectList;

    //
    // Validate the Property ID
    //

    switch ( PropertyId ) {
    case AZ_PROP_TASK_OPERATIONS:
        GenericObjectList = &((PAZP_TASK)TaskHandle)->Operations;
        break;
    default:
        AzPrint(( AZD_INVPARM, "AzTaskRemovePropertyItem: invalid prop id %ld\n", PropertyId ));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Call the common routine to do most of the work
    //

    return ObCommonRemovePropertyItem (
                    (PGENERIC_OBJECT) TaskHandle,
                    OBJECT_TYPE_TASK,
                    GenericObjectList,
                    Reserved,
                    (LPWSTR) PropertyValue );

}



DWORD
WINAPI
AzTaskDelete(
    IN AZ_HANDLE ApplicationHandle,
    IN LPCWSTR TaskName,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This routine deletes a task from the scope of the specified application.
    Also deletes any child objects of TaskName.

Arguments:

    ApplicationHandle - Specifies a handle to the application.

    TaskName - Specifies the name of the task to delete.

    Reserved - Reserved.  Must by zero.

Return Value:

    NO_ERROR - The operation was successful

    ERROR_NOT_FOUND - An object by that name cannot be found

--*/
{
    //
    // Call the common routine to do most of the work
    //

    return ObCommonDeleteObject(
                    (PGENERIC_OBJECT) ApplicationHandle,
                    OBJECT_TYPE_APPLICATION,
                    &(((PAZP_APPLICATION)ApplicationHandle)->Tasks),
                    OBJECT_TYPE_TASK,
                    TaskName,
                    Reserved );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\util.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    util.h

Abstract:

    Definitions of Utility routines

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#ifdef __cplusplus
extern "C" {
#endif

/////////////////////////////////////////////////////////////////////////////
//
// Macros
//
/////////////////////////////////////////////////////////////////////////////

//
// Macros for locking the global resource
//
#define AzpLockResourceExclusive( _Resource ) \
    RtlAcquireResourceExclusive( _Resource, TRUE )

#define AzpIsLockedExclusive( _Resource ) \
    ((_Resource)->NumberOfActive == -1 )

#define AzpLockResourceShared( _Resource ) \
    RtlAcquireResourceShared( _Resource, TRUE )

#define AzpLockResourceSharedToExclusive( _Resource ) \
    RtlConvertSharedToExclusive( _Resource )

#define AzpIsLockedShared( _Resource ) \
    ((_Resource)->NumberOfActive != 0 )

#define AzpUnlockResource( _Resource ) \
    RtlReleaseResource( _Resource )


/////////////////////////////////////////////////////////////////////////////
//
// Structure definitions
//
/////////////////////////////////////////////////////////////////////////////

//
// Generic counted string.
//  Can't use UNICODE_STRING since that is limited to 32K characters.
//
typedef struct _AZP_STRING {

    //
    // Pointer to the string
    //
    LPWSTR String;

    //
    // Size of the string in bytes (including trailing zero)
    //

    ULONG StringSize;

} AZP_STRING, *PAZP_STRING;

//
// Generic expandable array of pointers
//
typedef struct _AZP_PTR_ARRAY {

    //
    // Pointer to allocated array of pointers
    //

    PVOID *Array;

    //
    // Number of elements actually used in array
    //

    ULONG UsedCount;

    //
    // Number of elemets allocated in the array
    //

    ULONG AllocatedCount;
#define AZP_PTR_ARRAY_INCREMENT 4   // Amount to grow the array by

} AZP_PTR_ARRAY, *PAZP_PTR_ARRAY;




/////////////////////////////////////////////////////////////////////////////
//
// Global definitions
//
/////////////////////////////////////////////////////////////////////////////

extern LIST_ENTRY AzGlAllocatedBlocks;
extern CRITICAL_SECTION AzGlAllocatorCritSect;


/////////////////////////////////////////////////////////////////////////////
//
// Procedure definitions
//
/////////////////////////////////////////////////////////////////////////////

PVOID
AzpAllocateHeap(
    IN SIZE_T Size
    );

VOID
AzpFreeHeap(
    IN PVOID Buffer
    );

VOID
AzpInitString(
    OUT PAZP_STRING AzpString,
    IN LPWSTR String OPTIONAL
    );

DWORD
AzpDuplicateString(
    OUT PAZP_STRING AzpOutString,
    IN PAZP_STRING AzpInString
    );

DWORD
AzpCaptureString(
    OUT PAZP_STRING AzpString,
    IN LPCWSTR String,
    IN ULONG MaximumLength,
    IN BOOLEAN NullOk
    );

DWORD
AzpCaptureSid(
    OUT PAZP_STRING AzpString,
    IN PSID Sid
    );

DWORD
AzpCaptureUlong(
    IN PVOID PropertyValue,
    OUT PULONG UlongValue
    );

BOOL
AzpEqualStrings(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    );

LONG
AzpCompareStrings(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    );

VOID
AzpSwapStrings(
    IN OUT PAZP_STRING AzpString1,
    IN OUT PAZP_STRING AzpString2
    );

VOID
AzpFreeString(
    IN PAZP_STRING AzpString
    );

#define AZP_ADD_ENDOFLIST 0xFFFFFFFF
DWORD
AzpAddPtr(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Pointer,
    IN ULONG Index
    );

VOID
AzpRemovePtrByIndex(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN ULONG Index
    );

VOID
AzpRemovePtrByPtr(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Pointer
    );

PVOID
AzpGetStringProperty(
    IN PAZP_STRING AzpString
    );

PVOID
AzpGetUlongProperty(
    IN ULONG UlongValue
    );

BOOL
AzDllInitialize(VOID);

BOOL
AzDllUnInitialize(VOID);


/////////////////////////////////////////////////////////////////////////////
//
// Debugging Support
//
/////////////////////////////////////////////////////////////////////////////

#if DBG
#define AZROLESDBG 1
#endif // DBG

#ifdef AZROLESDBG
#define AzPrint(_x_) AzpPrintRoutine _x_

VOID
AzpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR FORMATSTRING,              // PRINTF()-STYLE FORMAT STRING.
    ...                                 // OTHER ARGUMENTS ARE POSSIBLE.
    );

//
// Values of DebugFlag
//
#define AZD_HANDLE       0x01    // Debug handle open/close
#define AZD_OBJLIST      0x02    // Object list linking
#define AZD_INVPARM      0x04    // Invalid Parameter
#define AZD_PERSIST      0x08    // Persistence code
#define AZD_PERSIST_MORE 0x10    // Persistence code (verbose mode)
#define AZD_REF          0x20    // Debug object ref count
#define AZD_ALL    0xFFFFFFFF

//
// Globals
//

extern CRITICAL_SECTION AzGlLogFileCritSect;
extern ULONG AzGlDbFlag;
// extern HANDLE AzGlLogFile;

#else
#define AzPrint(_x_)
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\tests\aztest.c ===
/*--

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    aztest.c

Abstract:

    Test program for the azroles DLL.

Author:

    Cliff Van Dyke (cliffv) 16-Apr-2001

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#define UNICODE 1
// #define SECURITY_WIN32 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "azrolesp.h"
#include <lmcons.h>
#include <lmerr.h>
#include <stdio.h>      // printf
#include <sddl.h>
#include <ntstatus.dbg>
#include <winerror.dbg>

//
// Sundry defines to enable optional tests
//

// #define ENABLE_LEAK 1       // Run a test that leaks memory
// #define ENABLE_CAUGHT_AVS 1 // Run a test that AVs in azroles.dll (but the AV is caught)


//
// Structure to define an operation to preform
//

typedef struct _OPERATION {

    // The operation
    ULONG Opcode;

// These are generic opcodes that work for all object types
#define AzoGenCreate    0
#define AzoGenOpen      1
#define AzoGenEnum      2
#define AzoGenGetProp   3
#define AzoGenSetProp   4
#define AzoGenAddProp   5
#define AzoGenRemProp   6
#define AzoGenDelete    7

#define AzoGenMax       50

//
// These are object specific opcodes
//

#define AzoApp          100
#define AzoAppCreate    (AzoApp+AzoGenCreate)
#define AzoAppOpen      (AzoApp+AzoGenOpen)
#define AzoAppEnum      (AzoApp+AzoGenEnum)
#define AzoAppGetProp   (AzoApp+AzoGenGetProp)
#define AzoAppSetProp   (AzoApp+AzoGenSetProp)
#define AzoAppDelete    (AzoApp+AzoGenDelete)

#define AzoOp           200
#define AzoOpCreate     (AzoOp+AzoGenCreate)
#define AzoOpOpen       (AzoOp+AzoGenOpen)
#define AzoOpEnum       (AzoOp+AzoGenEnum)
#define AzoOpGetProp    (AzoOp+AzoGenGetProp)
#define AzoOpSetProp    (AzoOp+AzoGenSetProp)
#define AzoOpDelete     (AzoOp+AzoGenDelete)

#define AzoTask         300
#define AzoTaskCreate   (AzoTask+AzoGenCreate)
#define AzoTaskOpen     (AzoTask+AzoGenOpen)
#define AzoTaskEnum     (AzoTask+AzoGenEnum)
#define AzoTaskGetProp  (AzoTask+AzoGenGetProp)
#define AzoTaskSetProp  (AzoTask+AzoGenSetProp)
#define AzoTaskAddProp  (AzoTask+AzoGenAddProp)
#define AzoTaskRemProp  (AzoTask+AzoGenRemProp)
#define AzoTaskDelete   (AzoTask+AzoGenDelete)

#define AzoScope        400
#define AzoScopeCreate  (AzoScope+AzoGenCreate)
#define AzoScopeOpen    (AzoScope+AzoGenOpen)
#define AzoScopeEnum    (AzoScope+AzoGenEnum)
#define AzoScopeGetProp (AzoScope+AzoGenGetProp)
#define AzoScopeSetProp (AzoScope+AzoGenSetProp)
#define AzoScopeDelete  (AzoScope+AzoGenDelete)

#define AzoGroup         500
#define AzoGroupCreate   (AzoGroup+AzoGenCreate)
#define AzoGroupOpen     (AzoGroup+AzoGenOpen)
#define AzoGroupEnum     (AzoGroup+AzoGenEnum)
#define AzoGroupGetProp  (AzoGroup+AzoGenGetProp)
#define AzoGroupSetProp  (AzoGroup+AzoGenSetProp)
#define AzoGroupAddProp  (AzoGroup+AzoGenAddProp)
#define AzoGroupRemProp  (AzoGroup+AzoGenRemProp)
#define AzoGroupDelete   (AzoGroup+AzoGenDelete)

#define AzoRole          600
#define AzoRoleCreate    (AzoRole+AzoGenCreate)
#define AzoRoleOpen      (AzoRole+AzoGenOpen)
#define AzoRoleEnum      (AzoRole+AzoGenEnum)
#define AzoRoleGetProp   (AzoRole+AzoGenGetProp)
#define AzoRoleSetProp   (AzoRole+AzoGenSetProp)
#define AzoRoleAddProp   (AzoRole+AzoGenAddProp)
#define AzoRoleRemProp   (AzoRole+AzoGenRemProp)
#define AzoRoleDelete    (AzoRole+AzoGenDelete)

#define AzoJP         700
#define AzoJPCreate   (AzoJP+AzoGenCreate)
#define AzoJPOpen     (AzoJP+AzoGenOpen)
#define AzoJPEnum     (AzoJP+AzoGenEnum)
#define AzoJPGetProp  (AzoJP+AzoGenGetProp)
#define AzoJPSetProp  (AzoJP+AzoGenSetProp)
#define AzoJPDelete   (AzoJP+AzoGenDelete)

//
// Real APIs that don't map to the generic APIs
#define AzoInit         1000
#define AzoClose        1001

//
// Pseudo opcode for TestLink subroutine
//

#define AzoTl          2000
#define AzoTlCreate    (AzoTl+AzoGenCreate)
#define AzoTlOpen      (AzoTl+AzoGenOpen)
#define AzoTlEnum      (AzoTl+AzoGenEnum)
#define AzoTlGetProp   (AzoTl+AzoGenGetProp)
#define AzoTlSetProp   (AzoTl+AzoGenSetProp)
#define AzoTlDelete    (AzoTl+AzoGenDelete)
#define AzoTlMax       2999

// Opcodes that aren't really API calls
#define AzoTestLink     0xFFFFFFFB
#define AzoGoSub        0xFFFFFFFC
#define AzoEcho         0xFFFFFFFD
#define AzoDupHandle    0xFFFFFFFE
#define AzoEndOfList    0xFFFFFFFF

    // Input Handle
    PAZ_HANDLE InputHandle;

    // Input Parameter
    LPWSTR Parameter1;

    // Output Handle
    PAZ_HANDLE OutputHandle;

    // Expected result status code
    ULONG ExpectedStatus;

    // List of operations to perform on each enumeration handle
    struct _OPERATION *EnumOperations;

    // Expected result String parameter
    LPWSTR ExpectedParameter1;

    // Property ID of Get/SetPropertyId functions
    ULONG PropertyId;

} OPERATION, *POPERATION;

//
// Global handles
//

AZ_HANDLE AdminMgrHandle1;
AZ_HANDLE AdminMgrHandle2;

AZ_HANDLE AppHandle1;
AZ_HANDLE AppHandle2;

AZ_HANDLE OpHandle1;
AZ_HANDLE TaskHandle1;
AZ_HANDLE ScopeHandle1;

AZ_HANDLE GroupHandleA;
AZ_HANDLE GroupHandle1;

AZ_HANDLE RoleHandleA;

AZ_HANDLE JPHandle1;
AZ_HANDLE JPHandleA;
AZ_HANDLE JPHandleB;

AZ_HANDLE GenParentHandle1;

AZ_HANDLE GenHandle1;
AZ_HANDLE GenHandle2;
AZ_HANDLE GenHandleE;
AZ_HANDLE GenHandleE2;

//
// Constant property values
//
ULONG Zero = 0;
ULONG Eight = 8;
ULONG GtMem = AZ_GROUPTYPE_MEMBERSHIP;
ULONG GtLdap = AZ_GROUPTYPE_LDAP_QUERY;

//
// Generic operations valid for all enumerations
//
//  Requires GenHandleE to already be set
//

// Test double close of enum handle
OPERATION OpAppChildGenEnum1[] = {
    { AzoDupHandle, &GenHandleE,    NULL,        &GenHandleE2, NO_ERROR },
    { AzoClose,     &GenHandleE,    NULL,        NULL,         NO_ERROR },
    { AzoClose,     &GenHandleE,    NULL,        NULL,         ERROR_INVALID_HANDLE },
    { AzoClose,     &GenHandleE2,   NULL,        NULL,         ERROR_INVALID_HANDLE },
    { AzoEndOfList }
};

// General purpose object enum
OPERATION OpAppChildGenEnum2[] = {
    { AzoGenGetProp, &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoGenGetProp, &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_DESCRIPTION },
    { AzoClose,      &GenHandleE,   NULL,        NULL,    NO_ERROR },
    { AzoEndOfList }
};

//
// Generic operations that work on *ALL* objects
//
//  Requires GenParentHandle1 to already be set
//

OPERATION OpGen[] = {
    { AzoEcho, NULL, L"Gen object test" },
    { AzoGenCreate,  &GenParentHandle1,L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoGenEnum,    &GenHandle1,      NULL,        &GenHandleE,      ERROR_INVALID_HANDLE },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum1 },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },
    { AzoGenCreate,  &GenParentHandle1,L"Name2",    &GenHandle2,      NO_ERROR },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },
    { AzoClose,      &GenHandle2,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Delete an object and make sure it doesn't get enumerated" },
    { AzoGenCreate,  &GenParentHandle1,L"Name3",    &GenHandle2,      NO_ERROR },
    { AzoGenDelete,  &GenParentHandle1,L"Name3",    NULL,             NO_ERROR },
    { AzoClose,      &GenHandle2,      NULL,        NULL,             NO_ERROR },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },

    { AzoEcho, NULL, L"Create an object whose name equals that of a deleted object" },
    { AzoGenCreate,  &GenParentHandle1,L"Name3",    &GenHandle2,      NO_ERROR },
    { AzoClose,      &GenHandle2,      NULL,        NULL,             NO_ERROR },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },

    { AzoEcho, NULL, L"Delete an object that isn't on the tail end of the enum list" },
    { AzoGenDelete,  &GenParentHandle1,L"Name2",    NULL,             NO_ERROR },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },

    { AzoEcho, NULL, L"Basic get/set property tests" },
    { AzoGenCreate,  &GenParentHandle1,L"Name4",    &GenHandle1,      NO_ERROR },
    { AzoGenGetProp, &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Name4",     AZ_PROP_NAME },
    { AzoGenGetProp, &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"",          AZ_PROP_DESCRIPTION },
    { AzoGenSetProp, &GenHandle1,      L"WasName4", NULL,             NO_ERROR, NULL, NULL,         AZ_PROP_NAME },
    { AzoGenSetProp, &GenHandle1,      L"Nam4 Desc",NULL,             NO_ERROR, NULL, NULL,         AZ_PROP_DESCRIPTION },
    { AzoGenGetProp, &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"WasName4",  AZ_PROP_NAME },
    { AzoGenGetProp, &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Nam4 Desc", AZ_PROP_DESCRIPTION },
    { AzoGenEnum,    &GenParentHandle1,NULL,        &GenHandleE,      NO_ERROR, OpAppChildGenEnum2 },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Open test" },
    { AzoGenOpen,    &GenParentHandle1,L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoGenGetProp, &GenHandle1,      NULL,        NULL,             NO_ERROR, NULL, L"Name1",     AZ_PROP_NAME },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoGenOpen,    &GenParentHandle1,L"NameBad",  &GenHandle1,      ERROR_NOT_FOUND },

    { AzoEndOfList }
};


//
// Generic operations valid for all children of "admin manager"
//

OPERATION OpAdmChildGen[] = {
    { AzoEcho, NULL, L"Admin Manager generic Child object test" },
    { AzoInit,       NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,  &AdminMgrHandle1, NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,      NULL,             NULL,        NULL,             NO_ERROR, OpGen },

    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAdmChildGenDupName[] = {
    { AzoEcho, NULL, L"Test creating two objects with the same name" },
    { AzoInit,       NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoGenCreate,  &AdminMgrHandle1, L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoGenCreate,  &AdminMgrHandle1, L"Name1",    &GenHandle2,      ERROR_ALREADY_EXISTS },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


//
// Generic operations valid for all children of "application"
//

OPERATION OpAppChildGen[] = {
    { AzoEcho, NULL, L"Application generic Child object test" },
    { AzoInit,       NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,  &AppHandle1,      NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,      NULL,             NULL,        NULL,             NO_ERROR, OpGen },

    { AzoClose,      &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAppChildGenHandleOpen[] = {
    { AzoEcho, NULL, L"Test closing the same handle twice" },
    { AzoInit,      NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate, &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoDupHandle, &AdminMgrHandle1, NULL,        &AdminMgrHandle2, NO_ERROR },
    { AzoClose,     &AdminMgrHandle2, NULL,        NULL,             ERROR_SERVER_HAS_OPEN_HANDLES },
    { AzoClose,     &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,     &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAppChildGenDupName[] = {
    { AzoEcho, NULL, L"Test creating two objects with the same name" },
    { AzoInit,       NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle2,      ERROR_ALREADY_EXISTS },
    { AzoGenCreate,  &AppHandle1,      L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoGenCreate,  &AppHandle1,      L"Name1",    &GenHandle2,      ERROR_ALREADY_EXISTS },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpAppChildGenLeak[] = {
    { AzoEcho, NULL, L"Test leaking a handle" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoClose,        &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


//
// Generic operations valid for all children of "scope"
//

OPERATION OpScopeChildGen[] = {
    { AzoEcho, NULL, L"Scope generic Child object test" },
    { AzoInit,       NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,&AppHandle1,      L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    // Do a bunch of stuff not specific to scope children
    { AzoDupHandle,  &ScopeHandle1,    NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,      NULL,             NULL,        NULL,             NO_ERROR, OpGen },

    { AzoClose,      &ScopeHandle1,    NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

OPERATION OpScopeChildGenDupName[] = {
    { AzoEcho, NULL, L"Test creating two objects with the same name" },
    { AzoInit,       NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,  &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,&AppHandle1,      L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    { AzoGenCreate,  &ScopeHandle1,    L"Name1",    &GenHandle1,      NO_ERROR },
    { AzoGenCreate,  &ScopeHandle1,    L"Name1",    &GenHandle2,      ERROR_ALREADY_EXISTS },
    { AzoClose,      &GenHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoClose,      &ScopeHandle1,    NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,      &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};




//
// Specific tests for Operation objects
//

OPERATION OpOperation[] = {
    { AzoEcho, NULL, L"Operation object specific tests" },
    { AzoInit,      NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate, &AdminMgrHandle1, L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoOpCreate,  &AppHandle1,      L"Oper 1",   &OpHandle1,       NO_ERROR },
    { AzoOpGetProp, &OpHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Zero,  AZ_PROP_OPERATION_ID },
    { AzoOpSetProp, &OpHandle1,    (LPWSTR)&Eight, NULL,             NO_ERROR, NULL, NULL,           AZ_PROP_OPERATION_ID },
    { AzoOpGetProp, &OpHandle1,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Eight, AZ_PROP_OPERATION_ID },
    { AzoClose,     &OpHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoClose,     &AppHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,     &AdminMgrHandle1, NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};



//
// Generic test of the ability of one object to link to another
//  AzoTestLink is the only opcode that can link to this subroutine of commands
//

AZ_STRING_ARRAY EmptyStringArray = { 0, NULL };

ULONG TestLinkOpcodeOffset;
ULONG TestLinkPropId;
AZ_HANDLE TestLinkHandleP;
AZ_HANDLE TestLinkHandleA;
WCHAR TestLinkObjectName[1000];

LPWSTR Object2x[] = { L"Object 2" };
AZ_STRING_ARRAY Object2 = { 1, Object2x };

LPWSTR Object3x[] = { L"Object 3" };
AZ_STRING_ARRAY Object3 = { 1, Object3x };

LPWSTR Object23x[] = { L"Object 2", L"Object 3" };
AZ_STRING_ARRAY Object23 = { 2, Object23x };

LPWSTR Object123x[] = { L"Object 1", L"Object 2", L"Object 3" };
AZ_STRING_ARRAY Object123 = { 3, Object123x };

LPWSTR Object123456x[] = { L"Object 1", L"Object 2", L"Object 3", L"Object 4", L"Object 5", L"Object 6" };
AZ_STRING_ARRAY Object123456 = { 6, Object123456x };

OPERATION OpTestLink[] = {
    { AzoEcho, NULL,  L"Create some objects to link the object to" },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 1",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 2",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 3",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL,  L"Reference an object that doesn't exist" },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, 1 },
    { AzoGenSetProp, &TestLinkHandleA,       L"random",   NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,       1 },
    { AzoGenAddProp, &TestLinkHandleA,       L"random",   NULL,             ERROR_NOT_FOUND, NULL, NULL,               1 },

    { AzoEcho, NULL,  L"Add and remove several objects" },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 2",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object2,            1 },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 3",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object23,           1 },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 1",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object123,          1 },
    { AzoGenRemProp, &TestLinkHandleA,       L"Object 1",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object23,           1 },
    { AzoGenRemProp, &TestLinkHandleA,       L"Object 2",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object3,            1 },

#if 0
    // This test has a couple problems.
    //  It assumes that the linked-to and linked-from objects have the same parents
    //  It assumes that an Open returns the same handle value as a previous close
    { AzoEcho, NULL,  L"Ensure the reference is still there after a close" },
    { AzoClose,       &TestLinkHandleA,       NULL,        NULL,             NO_ERROR },
    { AzoGenOpen,    &TestLinkHandleP,   TestLinkObjectName,  &TestLinkHandleA,     NO_ERROR },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object3,            1 },
#endif // 0

    { AzoEcho, NULL,  L"Add an item that already exists" },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 3",   NULL,             ERROR_ALREADY_EXISTS, NULL, NULL,          1 },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object3,            1 },
    { AzoGenRemProp, &TestLinkHandleA,       L"Object 3",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, 1 },

    { AzoEcho, NULL,  L"Try more than 4 since reference buckets come in multiples of 4" },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 4",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 5",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoTlCreate,    &TestLinkHandleP,        L"Object 6",   &OpHandle1,       NO_ERROR },
    { AzoClose,       &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 1",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 4",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 2",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 5",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 3",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,       L"Object 6",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,       NULL,        NULL,             NO_ERROR, NULL, (LPWSTR)&Object123456,       1 },

    { AzoTlDelete, &TestLinkHandleP,       L"Object 1",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete, &TestLinkHandleP,       L"Object 4",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete, &TestLinkHandleP,       L"Object 2",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete, &TestLinkHandleP,       L"Object 5",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete, &TestLinkHandleP,       L"Object 3",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoTlDelete, &TestLinkHandleP,       L"Object 6",   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoEndOfList }
};

//
// Generic test of the ability of an object to link to a sid
//  AzoTestLink is the only opcode that can link to this subroutine of commands
//

SID Sid1 = { 1, 1, {1}, 1 };
SID Sid2 = { 1, 1, {1}, 2 };
SID Sid3 = { 1, 1, {1}, 3 };
SID Sid4 = { 1, 1, {1}, 4 };
SID Sid5 = { 1, 1, {1}, 5 };
SID Sid6 = { 1, 1, {1}, 6 };
PSID Sid2x[] = { &Sid2 };
AZ_SID_ARRAY Sid2Array = { 1, Sid2x };

PSID Sid3x[] = { &Sid3 };
AZ_SID_ARRAY Sid3Array = { 1, Sid3x };

PSID Sid23x[] = { &Sid2, &Sid3 };
AZ_SID_ARRAY Sid23Array = { 2, Sid23x };

PSID Sid123x[] = { &Sid1, &Sid2, &Sid3 };
AZ_SID_ARRAY Sid123Array = { 3, Sid123x };

PSID Sid123456x[] = { &Sid1, &Sid2, &Sid3, &Sid4, &Sid5, &Sid6 };
AZ_SID_ARRAY Sid123456Array = { 6, Sid123456x };

OPERATION OpTestSid[] = {
    { AzoEcho, NULL,  L"Add and remove several links to sids" },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid2,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid2Array,            1 },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid3,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid23Array,           1 },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid1,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid123Array,          1 },
    { AzoGenRemProp, &TestLinkHandleA,   (LPWSTR)&Sid1,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid23Array,           1 },
    { AzoGenRemProp, &TestLinkHandleA,   (LPWSTR)&Sid2,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid3Array,            1 },

    { AzoEcho, NULL,  L"Add a link that already exists" },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid3,   NULL,             ERROR_ALREADY_EXISTS, NULL, NULL,          1 },
    { AzoGenGetProp, &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid3Array,            1 },
    { AzoGenRemProp, &TestLinkHandleA,   (LPWSTR)&Sid3,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, 1 },

    { AzoEcho, NULL,  L"Try more than 4 since reference buckets come in multiples of 4" },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid1,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid4,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid2,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid5,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid3,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenAddProp, &TestLinkHandleA,   (LPWSTR)&Sid6,   NULL,             NO_ERROR, NULL, NULL,                      1 },
    { AzoGenGetProp, &TestLinkHandleA,   NULL,            NULL,             NO_ERROR, NULL, (LPWSTR)&Sid123456Array,       1 },
    { AzoEndOfList }
};

//
// Specific tests for Task objects
//

OPERATION OpTask[] = {
    { AzoEcho, NULL, L"Task object specific tests" },
    { AzoInit,        NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,   &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoTaskCreate,  &AppHandle1,        L"Task 1",   &TaskHandle1,     NO_ERROR },
    { AzoTaskGetProp, &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE },
    { AzoTaskSetProp, &TaskHandle1,       L"Rule1",    NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_TASK_BIZRULE },
    { AzoTaskGetProp, &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"Rule1",    AZ_PROP_TASK_BIZRULE },

    { AzoEcho, NULL,  L"Try an invalid language" },
    { AzoTaskGetProp, &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoTaskSetProp, &TaskHandle1,       L"LANG1",    NULL,             ERROR_INVALID_PARAMETER, NULL, NULL, AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoTaskGetProp, &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE_LANGUAGE },

    { AzoEcho, NULL,  L"Try the valid languages" },
    { AzoTaskSetProp, &TaskHandle1,       L"VBScript", NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoTaskGetProp, &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"VBScript", AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoTaskSetProp, &TaskHandle1,       L"Jscript",  NULL,             NO_ERROR, NULL, L"",         AZ_PROP_TASK_BIZRULE_LANGUAGE },
    { AzoTaskGetProp, &TaskHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"Jscript",  AZ_PROP_TASK_BIZRULE_LANGUAGE },

    { AzoTestLink,    &AppHandle1,        (LPWSTR)"Operation", &TaskHandle1,     AzoOp, OpTestLink, L"Task 1", AZ_PROP_TASK_OPERATIONS },

    { AzoClose,       &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoClose,       &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,       &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

//
// Specific tests for Group objects
//

//
// Group object tests that are agnostic about the parent object
//  Requires GenParentHandle1 to already be set
//
OPERATION OpGenGroup[] = {
    { AzoEcho, NULL, L"Group object specific tests" },

    { AzoGroupCreate,  &GenParentHandle1,   L"Group A",   &GroupHandleA,    NO_ERROR },

    { AzoEcho, NULL, L"Create some groups to link the group to" },
    { AzoGroupCreate,  &GenParentHandle1,   L"Group 1",   &GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,       NULL,         NULL,             NO_ERROR },
    { AzoGroupCreate,  &GenParentHandle1,   L"Group 2",   &GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,       NULL,         NULL,             NO_ERROR },
    { AzoGroupCreate,  &GenParentHandle1,   L"Group 3",   &GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,       NULL,         NULL,             NO_ERROR },

    { AzoEcho, NULL,  L"Add membership to a group with no grouptype" },
    { AzoGroupAddProp, &GroupHandleA,       L"Group 1",   NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,      AZ_PROP_GROUP_APP_MEMBERS },
    { AzoGroupAddProp, &GroupHandleA,       (LPWSTR)&Sid1, NULL,            ERROR_INVALID_PARAMETER, NULL, NULL,      AZ_PROP_GROUP_MEMBERS },
    { AzoGroupSetProp, &GroupHandleA,       (LPWSTR)&Eight,NULL,            ERROR_INVALID_PARAMETER, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoGroupSetProp, &GroupHandleA,       (LPWSTR)&GtMem,NULL,            NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },

    { AzoEcho, NULL,  L"Reference ourself" },
    { AzoGroupGetProp, &GroupHandleA,       NULL,         NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_GROUP_APP_MEMBERS },
    { AzoGroupGetProp, &GroupHandleA,       NULL,         NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_GROUP_MEMBERS },
    { AzoGroupAddProp, &GroupHandleA,       L"Group A",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,               AZ_PROP_GROUP_APP_MEMBERS },

    { AzoTestLink,     &GenParentHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_MEMBERS },

    { AzoTestLink,     &GenParentHandle1,   (LPWSTR)"Sid", &GroupHandleA, AzoGroup, OpTestSid, L"Group A", AZ_PROP_GROUP_MEMBERS },

    { AzoEcho, NULL,  L"Same as above, but for the non-members attribute" },
    { AzoGroupGetProp, &GroupHandleA,       NULL,         NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoGroupGetProp, &GroupHandleA,       NULL,         NULL,             NO_ERROR, NULL, (LPWSTR)&EmptyStringArray, AZ_PROP_GROUP_NON_MEMBERS },
    { AzoGroupAddProp, &GroupHandleA,       L"Group A",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,       AZ_PROP_GROUP_APP_NON_MEMBERS },

    { AzoTestLink,     &GenParentHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_NON_MEMBERS },

    { AzoTestLink,     &GenParentHandle1,   (LPWSTR)"Sid", &GroupHandleA, AzoGroup, OpTestSid, L"Group A", AZ_PROP_GROUP_NON_MEMBERS },

    { AzoEcho, NULL,  L"Set LdapQuery string" },
    { AzoGroupGetProp, &GroupHandleA,       NULL,        NULL,             NO_ERROR, NULL, L"", AZ_PROP_GROUP_LDAP_QUERY },
    { AzoGroupSetProp, &GroupHandleA,       L"TheQuery", NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoGroupSetProp, &GroupHandleA,       (LPWSTR)&GtLdap,NULL,          NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoGroupSetProp, &GroupHandleA,       L"TheQuery", NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoGroupGetProp, &GroupHandleA,       NULL,        NULL,             NO_ERROR, NULL, L"TheQuery", AZ_PROP_GROUP_LDAP_QUERY },
    { AzoGroupSetProp, &GroupHandleA,       (LPWSTR)&GtMem,NULL,           NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoGroupSetProp, &GroupHandleA,       L"TheQuery", NULL,             ERROR_INVALID_PARAMETER, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },
    { AzoGroupSetProp, &GroupHandleA,       L"",         NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_GROUP_LDAP_QUERY },

    { AzoEcho, NULL, L"Test loops" },
    { AzoGroupCreate,  &GenParentHandle1,   L"Group B",   &GroupHandle1,    NO_ERROR },
    { AzoGroupSetProp, &GroupHandle1,       (LPWSTR)&GtMem,NULL,            NO_ERROR, NULL, NULL,      AZ_PROP_GROUP_TYPE },
    { AzoGroupAddProp, &GroupHandleA,       L"Group B",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_GROUP_APP_MEMBERS },
    { AzoGroupAddProp, &GroupHandle1,       L"Group A",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,               AZ_PROP_GROUP_APP_MEMBERS },
    { AzoGroupAddProp, &GroupHandleA,       L"Group B",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoGroupAddProp, &GroupHandle1,       L"Group A",   NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,               AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoGroupRemProp, &GroupHandleA,       L"Group B",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoGroupRemProp, &GroupHandleA,       L"Group B",   NULL,             NO_ERROR, NULL, NULL,               AZ_PROP_GROUP_APP_MEMBERS },

    { AzoClose,        &GroupHandle1,       NULL,         NULL,             NO_ERROR },
    { AzoClose,        &GroupHandleA,       NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for groups that are children of an admin manager
OPERATION OpAdmGroup[] = {
    { AzoEcho, NULL, L"Group objects that are children of an admin manager" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,    &AdminMgrHandle1,   NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,        NULL,               NULL,        NULL,             NO_ERROR, OpGenGroup },

    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for groups that are children of an application
OPERATION OpAppGroup[] = {
    { AzoEcho, NULL, L"Group objects that are children of an application" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,    &AppHandle1,        NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,        NULL,               NULL,        NULL,             NO_ERROR, OpGenGroup },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same admin manager as this group." },
    { AzoGroupOpen,   &AppHandle1,        L"Group A",      &GroupHandleA, NO_ERROR },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_MEMBERS },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoClose,       &GroupHandleA,      NULL,            NULL,          NO_ERROR },

    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for groups that are children of a scope
OPERATION OpScopeGroup[] = {
    { AzoEcho, NULL, L"Group objects that are children of an application" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,        L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    // Do a bunch of stuff not specific to application children
    { AzoDupHandle,    &ScopeHandle1,      NULL,        &GenParentHandle1,NO_ERROR },
    { AzoGoSub,        NULL,               NULL,        NULL,             NO_ERROR, OpGenGroup },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same admin manager as this group." },
    { AzoGroupOpen,   &ScopeHandle1,      L"Group A",      &GroupHandleA, NO_ERROR },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_MEMBERS },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoClose,       &GroupHandleA,      NULL,            NULL,          NO_ERROR },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same application as this group." },
    { AzoGroupOpen,   &ScopeHandle1,      L"Group A",      &GroupHandleA, NO_ERROR },
    { AzoTestLink,    &AppHandle1,        (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_MEMBERS },
    { AzoTestLink,    &AppHandle1,        (LPWSTR)"Group", &GroupHandleA, AzoGroup, OpTestLink, L"Group A", AZ_PROP_GROUP_APP_NON_MEMBERS },
    { AzoClose,       &GroupHandleA,      NULL,            NULL,          NO_ERROR },

    { AzoClose,        &ScopeHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

//
// Specific tests for Role objects
//


// Tests for Roles that are children of an application
OPERATION OpAppRole[] = {
    { AzoEcho, NULL, L"Role objects that are children of an application" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },

    { AzoRoleCreate,  &AppHandle1,   L"Role A",   &RoleHandleA,    NO_ERROR },

    // Test linking roles to groups
    { AzoEcho, NULL, L"Test linking to groups that are children of the same admin manager as the role object." },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same application as the role object." },
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    { AzoEcho, NULL, L"Test linking to SIDs." },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Sid", &RoleHandleA,     AzoGroup, OpTestSid, L"Role A", AZ_PROP_ROLE_MEMBERS },

    // Test linking roles to operations
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Operation", &RoleHandleA,     AzoOp, OpTestLink, L"Role A", AZ_PROP_ROLE_OPERATIONS },

    // Test linking roles to scopes
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Scope", &RoleHandleA,     AzoScope, OpTestLink, L"Role A", AZ_PROP_ROLE_SCOPES },

    { AzoClose,        &RoleHandleA,       NULL,        NULL,             NO_ERROR },

    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

// Tests for Roles that are children of an scope
OPERATION OpScopeRole[] = {
    { AzoEcho, NULL, L"Role objects that are children of an application" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoScopeCreate,  &AppHandle1,        L"Scope 1",  &ScopeHandle1,    NO_ERROR },

    { AzoRoleCreate,  &ScopeHandle1,   L"Role A",   &RoleHandleA,    NO_ERROR },

    // Test linking roles to groups
    { AzoEcho, NULL, L"Test linking to groups that are children of the same scope object as the role object." },
    { AzoTestLink,    &ScopeHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same application as the role object." },
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    { AzoEcho, NULL, L"Test linking to SIDs." },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Sid", &RoleHandleA,     AzoGroup, OpTestSid, L"Role A", AZ_PROP_ROLE_MEMBERS },

    { AzoEcho, NULL, L"Test linking to groups that are children of the same admin manager as the role object." },
    { AzoTestLink,    &AdminMgrHandle1,   (LPWSTR)"Group", &RoleHandleA,     AzoGroup, OpTestLink, L"Role A", AZ_PROP_ROLE_APP_MEMBERS },

    // Test linking roles to operations
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Operation", &RoleHandleA,     AzoOp, OpTestLink, L"Role A", AZ_PROP_ROLE_OPERATIONS },

    // Test linking roles to scopes
    { AzoTestLink,    &AppHandle1,   (LPWSTR)"Scope", &RoleHandleA,     AzoScope, OpTestLink, L"Role A", AZ_PROP_ROLE_SCOPES },

    { AzoClose,        &RoleHandleA,       NULL,        NULL,             NO_ERROR },

    { AzoClose,        &ScopeHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};

//
// Specific tests for JunctionPoint objects
//

OPERATION OpAppJunctionPoint[] = {
    { AzoEcho, NULL, L"JunctionPoint object specific tests" },
    { AzoInit,        NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,   &AdminMgrHandle1,   L"App 1",    &AppHandle1,      NO_ERROR },
    { AzoAppCreate,   &AdminMgrHandle1,   L"App 3",    &AppHandle2,      NO_ERROR },
    { AzoClose,       &AppHandle2,        NULL,        NULL,             NO_ERROR },
    { AzoAppCreate,   &AdminMgrHandle1,   L"App 2",    &AppHandle2,      NO_ERROR },

    { AzoJPCreate,  &AppHandle1,        L"JunctionPoint 1",   &JPHandle1,     NO_ERROR },
    { AzoJPGetProp, &JPHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_JUNCTION_POINT_APPLICATION },
    { AzoJPSetProp, &JPHandle1,       L"App 2",    NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_JUNCTION_POINT_APPLICATION },
    { AzoJPGetProp, &JPHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"App 2",    AZ_PROP_JUNCTION_POINT_APPLICATION },

    { AzoEcho, NULL, L"Ensure setting the attribute really changes it" },
    { AzoJPSetProp, &JPHandle1,       L"App 3",    NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_JUNCTION_POINT_APPLICATION },
    { AzoJPGetProp, &JPHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"App 3",    AZ_PROP_JUNCTION_POINT_APPLICATION },

    { AzoEcho, NULL, L"Ensure deleting the app deletes the reference" },
    { AzoAppDelete,   &AdminMgrHandle1,   L"App 3",    NULL,             NO_ERROR },
    { AzoJPGetProp, &JPHandle1,       NULL,        NULL,             NO_ERROR, NULL, L"",         AZ_PROP_JUNCTION_POINT_APPLICATION },

    { AzoEcho, NULL, L"Link a junction point to its own app" },
    { AzoJPSetProp, &JPHandle1,       L"App 1",    NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,        AZ_PROP_JUNCTION_POINT_APPLICATION },

    { AzoEcho, NULL, L"Detect a more complex cycle" },
    { AzoJPSetProp, &JPHandle1,       L"App 2",    NULL,             NO_ERROR, NULL, NULL,        AZ_PROP_JUNCTION_POINT_APPLICATION },
    { AzoJPCreate,  &AppHandle2,        L"JunctionPoint A",   &JPHandleA,     NO_ERROR },
    { AzoJPSetProp, &JPHandleA,       L"App 1",    NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,        AZ_PROP_JUNCTION_POINT_APPLICATION },
    { AzoJPCreate,  &AppHandle2,        L"JunctionPoint B",   &JPHandleB,     NO_ERROR },
    { AzoJPSetProp, &JPHandleA,       L"App 1",    NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,        AZ_PROP_JUNCTION_POINT_APPLICATION },
    { AzoJPSetProp, &JPHandleB,       L"App 1",    NULL,             ERROR_DS_LOOP_DETECT, NULL, NULL,        AZ_PROP_JUNCTION_POINT_APPLICATION },
    { AzoClose,       &JPHandleA,         NULL,        NULL,             NO_ERROR },
    { AzoClose,       &JPHandleB,         NULL,        NULL,             NO_ERROR },

    { AzoClose,       &JPHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoClose,       &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,       &AppHandle2,        NULL,        NULL,             NO_ERROR },
    { AzoClose,       &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};



//
// Ensure certain objects can't share names
//
OPERATION OpShare[] = {
    { AzoEcho, NULL, L"Certain objects can't share names" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },

    { AzoEcho, NULL, L"Create some tasks and ops as a starting point" },
    { AzoTaskCreate,   &AppHandle1,        L"Task 1",   &TaskHandle1,     NO_ERROR },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoOpCreate,     &AppHandle1,        L"Op 1",     &OpHandle1,       NO_ERROR },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Task and operations can't share names" },
    { AzoTaskCreate,   &AppHandle1,        L"Op 1",     &TaskHandle1,     ERROR_ALREADY_EXISTS },
    { AzoOpCreate,     &AppHandle1,        L"Task 1",   &OpHandle1,       ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Create some groups as a starting point" },
    { AzoGroupCreate,  &AdminMgrHandle1,   L"Group Adm",&GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,      NULL,        NULL,             NO_ERROR },
    { AzoGroupCreate,  &AppHandle1,        L"Group App",&GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create an app group that conflicts with an adm group, etc" },
    { AzoGroupCreate,  &AppHandle1,        L"Group Adm",&GroupHandleA,    ERROR_ALREADY_EXISTS },
    { AzoGroupCreate,  &AdminMgrHandle1,   L"Group App",&GroupHandleA,    ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Create a scope group" },
    { AzoScopeCreate,  &AppHandle1,        L"Scope 1",  &ScopeHandle1,    NO_ERROR },
    { AzoGroupCreate,  &ScopeHandle1,      L"Group Scp",&GroupHandle1,    NO_ERROR },
    { AzoClose,        &GroupHandle1,      NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"Create a scope group that conflicts with an adm group, etc" },
    { AzoGroupCreate,  &ScopeHandle1,      L"Group Adm",&GroupHandleA,    ERROR_ALREADY_EXISTS },
    { AzoGroupCreate,  &ScopeHandle1,      L"Group App",&GroupHandleA,    ERROR_ALREADY_EXISTS },

    { AzoEcho, NULL, L"Create an app/adm group that conflicts with a scope group" },
    { AzoGroupCreate,  &AppHandle1,        L"Group Scp",&GroupHandleA,    ERROR_ALREADY_EXISTS },
    { AzoGroupCreate,  &AdminMgrHandle1,   L"Group Scp",&GroupHandleA,    ERROR_ALREADY_EXISTS },

    { AzoClose,        &ScopeHandle1,      NULL,        NULL,            NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};


//
// Ensure peristence works
//
// App object enum
OPERATION OpAppEnum[] = {
    { AzoAppGetProp, &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoClose,      &GenHandleE,   NULL,        NULL,    NO_ERROR },
    { AzoEndOfList }
};
// Task object enum
OPERATION OpTaskEnum[] = {
    { AzoTaskGetProp, &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoClose,       &GenHandleE,   NULL,        NULL,    NO_ERROR },
    { AzoEndOfList }
};

// Operation object enum
OPERATION OpOpEnum[] = {
    { AzoOpGetProp,  &GenHandleE,   NULL,        NULL,    NO_ERROR, NULL, NULL, AZ_PROP_NAME },
    { AzoClose,      &GenHandleE,   NULL,        NULL,    NO_ERROR },
    { AzoEndOfList }
};
OPERATION OpPersist[] = {
    { AzoEcho, NULL, L"Ensure objects persist across a close" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, AZ_ADMIN_FLAG_CREATE },
    { AzoAppCreate,    &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoTaskCreate,   &AppHandle1,        L"Task 1",   &TaskHandle1,     NO_ERROR },
    { AzoOpCreate,     &AppHandle1,        L"Op 1",     &OpHandle1,       NO_ERROR },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },

    { AzoEcho, NULL, L"See if they're still there" },
    { AzoInit,         NULL,             L".\\TestFile",      &AdminMgrHandle1, NO_ERROR, NULL, NULL, 0 },
    { AzoAppEnum,      &AdminMgrHandle1,   NULL,        &GenHandleE,      NO_ERROR, OpAppEnum },
    { AzoAppOpen,      &AdminMgrHandle1,   L"MyApp",    &AppHandle1,      NO_ERROR },
    { AzoTaskEnum,     &AppHandle1,        NULL,        &GenHandleE,      NO_ERROR, OpTaskEnum },
    { AzoTaskOpen,     &AppHandle1,        L"Task 1",   &TaskHandle1,     NO_ERROR },
    { AzoOpEnum,       &AppHandle1,        NULL,        &GenHandleE,      NO_ERROR, OpOpEnum },
    { AzoOpOpen,       &AppHandle1,        L"Op 1",     &OpHandle1,       NO_ERROR },
    { AzoClose,        &OpHandle1,         NULL,        NULL,             NO_ERROR },
    { AzoClose,        &TaskHandle1,       NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AppHandle1,        NULL,        NULL,             NO_ERROR },
    { AzoClose,        &AdminMgrHandle1,   NULL,        NULL,             NO_ERROR },
    { AzoEndOfList }
};




VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr = Buffer;


    printf("------------------------------------\n");

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            printf("%02x ", BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            printf("  ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            printf("  %s\n", TextBuffer);
        }

    }

    printf("------------------------------------\n");
}

LPSTR
FindSymbolicNameForStatus(
    DWORD Id
    )
{
    ULONG i;

    i = 0;
    if (Id == 0) {
        return "STATUS_SUCCESS";
    }

    if (Id & 0xC0000000) {
        while (ntstatusSymbolicNames[ i ].SymbolicName) {
            if (ntstatusSymbolicNames[ i ].MessageId == (NTSTATUS)Id) {
                return ntstatusSymbolicNames[ i ].SymbolicName;
            } else {
                i += 1;
            }
        }
    }

    while (winerrorSymbolicNames[ i ].SymbolicName) {
        if (winerrorSymbolicNames[ i ].MessageId == Id) {
            return winerrorSymbolicNames[ i ].SymbolicName;
        } else {
            i += 1;
        }
    }

#ifdef notdef
    while (neteventSymbolicNames[ i ].SymbolicName) {
        if (neteventSymbolicNames[ i ].MessageId == Id) {
            return neteventSymbolicNames[ i ].SymbolicName
        } else {
            i += 1;
        }
    }
#endif // notdef

    return NULL;
}

VOID
PrintStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Print a net status code.

Arguments:

    NetStatus - The net status code to print.

Return Value:

    None

--*/
{

    switch (NetStatus) {
    case NO_ERROR:
        printf( "NO_ERROR" );
        break;

    case NERR_DCNotFound:
        printf( "NERR_DCNotFound" );
        break;

    case ERROR_LOGON_FAILURE:
        printf( "ERROR_LOGON_FAILURE" );
        break;

    case ERROR_ACCESS_DENIED:
        printf( "ERROR_ACCESS_DENIED" );
        break;

    case ERROR_NOT_SUPPORTED:
        printf( "ERROR_NOT_SUPPORTED" );
        break;

    case ERROR_NO_LOGON_SERVERS:
        printf( "ERROR_NO_LOGON_SERVERS" );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        printf( "ERROR_NO_SUCH_DOMAIN" );
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        printf( "ERROR_NO_TRUST_LSA_SECRET" );
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        printf( "ERROR_NO_TRUST_SAM_ACCOUNT" );
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        printf( "ERROR_DOMAIN_TRUST_INCONSISTENT" );
        break;

    case ERROR_BAD_NETPATH:
        printf( "ERROR_BAD_NETPATH" );
        break;

    case ERROR_FILE_NOT_FOUND:
        printf( "ERROR_FILE_NOT_FOUND" );
        break;

    case NERR_NetNotStarted:
        printf( "NERR_NetNotStarted" );
        break;

    case NERR_WkstaNotStarted:
        printf( "NERR_WkstaNotStarted" );
        break;

    case NERR_ServerNotStarted:
        printf( "NERR_ServerNotStarted" );
        break;

    case NERR_BrowserNotStarted:
        printf( "NERR_BrowserNotStarted" );
        break;

    case NERR_ServiceNotInstalled:
        printf( "NERR_ServiceNotInstalled" );
        break;

    case NERR_BadTransactConfig:
        printf( "NERR_BadTransactConfig" );
        break;

    case SEC_E_NO_SPM:
        printf( "SEC_E_NO_SPM" );
        break;
    case SEC_E_BAD_PKGID:
        printf( "SEC_E_BAD_PKGID" ); break;
    case SEC_E_NOT_OWNER:
        printf( "SEC_E_NOT_OWNER" ); break;
    case SEC_E_CANNOT_INSTALL:
        printf( "SEC_E_CANNOT_INSTALL" ); break;
    case SEC_E_INVALID_TOKEN:
        printf( "SEC_E_INVALID_TOKEN" ); break;
    case SEC_E_CANNOT_PACK:
        printf( "SEC_E_CANNOT_PACK" ); break;
    case SEC_E_QOP_NOT_SUPPORTED:
        printf( "SEC_E_QOP_NOT_SUPPORTED" ); break;
    case SEC_E_NO_IMPERSONATION:
        printf( "SEC_E_NO_IMPERSONATION" ); break;
    case SEC_E_LOGON_DENIED:
        printf( "SEC_E_LOGON_DENIED" ); break;
    case SEC_E_UNKNOWN_CREDENTIALS:
        printf( "SEC_E_UNKNOWN_CREDENTIALS" ); break;
    case SEC_E_NO_CREDENTIALS:
        printf( "SEC_E_NO_CREDENTIALS" ); break;
    case SEC_E_MESSAGE_ALTERED:
        printf( "SEC_E_MESSAGE_ALTERED" ); break;
    case SEC_E_OUT_OF_SEQUENCE:
        printf( "SEC_E_OUT_OF_SEQUENCE" ); break;
    case SEC_E_INSUFFICIENT_MEMORY:
        printf( "SEC_E_INSUFFICIENT_MEMORY" ); break;
    case SEC_E_INVALID_HANDLE:
        printf( "SEC_E_INVALID_HANDLE" ); break;
    case SEC_E_NOT_SUPPORTED:
        printf( "SEC_E_NOT_SUPPORTED" ); break;

    default: {
        LPSTR Name = FindSymbolicNameForStatus( NetStatus );

        if ( Name == NULL ) {
            printf( "(%lu)", NetStatus );
        } else {
            printf( "%s", Name );
        }
        break;
    }
    }

}

VOID
PrintIndent(
    IN ULONG Indentation,
    IN BOOLEAN Error
    )
/*++

Routine Description:

    Print line prefix for log file

Arguments:

    Indentation - Number of spaces to indent text by.

    Error - True if this is a program failure.

Return Value:

    None.

--*/
{
    static LPSTR Blanks = "                                                           ";

    printf( "%*.*s", Indentation, Indentation, Blanks );

    if ( Error ) {
        printf("[ERR] ");
    }

}

BOOL
DoOperations(
    IN POPERATION OperationsToDo,
    IN ULONG Indentation,
    IN ULONG SpecificOpcodeOffset,
    IN LPSTR EchoPrefix
    )
/*++

Routine Description:

    Do a set of operations

Arguments:

    OperationsToDo - a list of operations to do

    Indentation - Number of spaces to indent text by.
        This value increases on recursive calls.

    SpecificOpcodeOffset - Specifies an amount to add to a generic opcode to map
        it to a specific opcode.

    EchoPrefix - Specifies a string to print before all AzoEcho strings

Return Value:

    TRUE - tests completed successfully
    FALSE - tests failed

--*/
{
    BOOL RetVal = TRUE;
    POPERATION Operation;
    LPSTR OpName;
    ULONG Opcode;

    PVOID PropertyValue = NULL;
    ULONG PropType;
#define PT_NONE         0
#define PT_LPWSTR       1
#define PT_STRING_ARRAY 2
#define PT_ULONG        3
#define PT_SID_ARRAY    4

    ULONG PropertyId;

    BOOLEAN WasSetProperty;
    BOOLEAN WasGetProperty;
    HANDLE SubmitHandle;

    ULONG EnumerationContext = 0;
    BOOLEAN FirstIteration = TRUE;

    DWORD WinStatus;
    DWORD RealWinStatus;

    CHAR BigBuffer[1000];
    PAZ_STRING_ARRAY StringArray1;
    PAZ_STRING_ARRAY StringArray2;

    PAZ_SID_ARRAY SidArray1;
    PAZ_SID_ARRAY SidArray2;

    ULONG i;

    //
    // Leave room between tests
    //

    if ( Indentation == 0 ) {
        printf( "\n\n" );
    }


    //
    // Loop through each of the operations
    //

    for ( Operation=OperationsToDo; Operation->Opcode != AzoEndOfList && RetVal; ) {

        //
        // Mark that this change doesn't need to be submitted
        //

        SubmitHandle = INVALID_HANDLE_VALUE;

        //
        // Compute the mapped property ID
        //

        if ( TestLinkPropId != 0 && Operation->PropertyId != 0 ) {
            PropertyId = TestLinkPropId;
        } else {
            PropertyId = Operation->PropertyId;
        }


        //
        // Setup for get/set property
        //

        PropType = PT_NONE;

        // Do common types
        if ( PropertyId == AZ_PROP_NAME ||
             PropertyId == AZ_PROP_DESCRIPTION ) {

            PropType = PT_LPWSTR;
        }

        WasSetProperty = FALSE;
        WasGetProperty = FALSE;

        //
        // Map generic opcodes to a specific opcode
        //

        Opcode = Operation->Opcode;
        if ( Opcode < AzoGenMax ) {
            ASSERT( SpecificOpcodeOffset != 0 );
            Opcode += SpecificOpcodeOffset;

        } else if ( Opcode >= AzoTl && Opcode < AzoTlMax ) {
            ASSERT( TestLinkOpcodeOffset != 0 );
            Opcode = Opcode - AzoTl + TestLinkOpcodeOffset;
        }


        //
        // Perform the requested operation
        //

        switch ( Opcode ) {
        case AzoInit:
            OpName = "AzInitialize";
            WinStatus = AzInitialize(
                            AZ_ADMIN_STORE_SAMPLE,  // Shouldn't be a constant
                            Operation->Parameter1,
                            PropertyId, // Flags
                            0,  // reserved
                            Operation->OutputHandle );

            break;



        //
        // Application APIs
        //
        case AzoAppCreate:
            OpName = "AzApplicationCreate";
            WinStatus = AzApplicationCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoAppOpen:
            OpName = "AzApplicationOpen";
            WinStatus = AzApplicationOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoAppEnum:
            OpName = "AzApplicationEnum";
            WinStatus = AzApplicationEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoAppGetProp:
            OpName = "AzApplicationGetProperty";

            WinStatus = AzApplicationGetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            &PropertyValue );

            WasGetProperty = TRUE;

            break;

        case AzoAppSetProp:
            OpName = "AzApplicationSetProperty";

            WinStatus = AzApplicationSetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            WasSetProperty = TRUE;
            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoAppDelete:
            OpName = "AzApplicationDelete";
            WinStatus = AzApplicationDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            break;


        //
        // Operation APIs
        //
        case AzoOpCreate:
            OpName = "AzOperationCreate";
            WinStatus = AzOperationCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoOpOpen:
            OpName = "AzOperationOpen";
            WinStatus = AzOperationOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoOpEnum:
            OpName = "AzOperationEnum";
            WinStatus = AzOperationEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoOpGetProp:
            OpName = "AzOperationGetProperty";

            WinStatus = AzOperationGetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            &PropertyValue );

            WasGetProperty = TRUE;

            if ( PropertyId == AZ_PROP_OPERATION_ID ) {
                PropType = PT_ULONG;
            }

            break;

        case AzoOpSetProp:
            OpName = "AzOperationSetProperty";

            WinStatus = AzOperationSetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            WasSetProperty = TRUE;

            if ( PropertyId == AZ_PROP_OPERATION_ID ) {
                PropType = PT_ULONG;
            }

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoOpDelete:
            OpName = "AzOperationDelete";
            WinStatus = AzOperationDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            break;


        //
        // Task APIs
        //
        case AzoTaskCreate:
            OpName = "AzTaskCreate";
            WinStatus = AzTaskCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoTaskOpen:
            OpName = "AzTaskOpen";
            WinStatus = AzTaskOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoTaskEnum:
            OpName = "AzTaskEnum";
            WinStatus = AzTaskEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoTaskGetProp:
            OpName = "AzTaskGetProperty";

            WinStatus = AzTaskGetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            &PropertyValue );

            WasGetProperty = TRUE;

            if ( PropertyId == AZ_PROP_TASK_BIZRULE ||
                 PropertyId == AZ_PROP_TASK_BIZRULE_LANGUAGE ) {
                PropType = PT_LPWSTR;
            } else if ( PropertyId == AZ_PROP_TASK_OPERATIONS ) {
                PropType = PT_STRING_ARRAY;
            }

            break;

        case AzoTaskSetProp:
            OpName = "AzTaskSetProperty";

            WinStatus = AzTaskSetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            WasSetProperty = TRUE;

            if ( PropertyId == AZ_PROP_TASK_BIZRULE ||
                 PropertyId == AZ_PROP_TASK_BIZRULE_LANGUAGE ) {
                PropType = PT_LPWSTR;
            }

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoTaskAddProp:
            OpName = "AzTaskAddProperty";

            WinStatus = AzTaskAddPropertyItem(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoTaskRemProp:
            OpName = "AzTaskRemProperty";

            WinStatus = AzTaskRemovePropertyItem(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoTaskDelete:
            OpName = "AzTaskDelete";
            WinStatus = AzTaskDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            break;


        //
        // Scope APIs
        //
        case AzoScopeCreate:
            OpName = "AzScopeCreate";
            WinStatus = AzScopeCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoScopeOpen:
            OpName = "AzScopeOpen";
            WinStatus = AzScopeOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoScopeEnum:
            OpName = "AzScopeEnum";
            WinStatus = AzScopeEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoScopeGetProp:
            OpName = "AzScopeGetProperty";

            WinStatus = AzScopeGetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            &PropertyValue );

            WasGetProperty = TRUE;

            break;

        case AzoScopeSetProp:
            OpName = "AzScopeSetProperty";

            WinStatus = AzScopeSetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            WasSetProperty = TRUE;

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoScopeDelete:
            OpName = "AzScopeDelete";
            WinStatus = AzScopeDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            break;


        //
        // Group APIs
        //
        case AzoGroupCreate:
            OpName = "AzGroupCreate";
            WinStatus = AzGroupCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoGroupOpen:
            OpName = "AzGroupOpen";
            WinStatus = AzGroupOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoGroupEnum:
            OpName = "AzGroupEnum";
            WinStatus = AzGroupEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoGroupGetProp:
            OpName = "AzGroupGetProperty";

            WinStatus = AzGroupGetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            &PropertyValue );

            WasGetProperty = TRUE;

            if ( PropertyId == AZ_PROP_GROUP_TYPE ) {
                PropType = PT_ULONG;
            } else if ( PropertyId == AZ_PROP_GROUP_APP_MEMBERS ||
                        PropertyId == AZ_PROP_GROUP_APP_NON_MEMBERS ) {
                PropType = PT_STRING_ARRAY;
            } else if ( PropertyId == AZ_PROP_GROUP_LDAP_QUERY ) {
                PropType = PT_LPWSTR;
            } else if ( PropertyId == AZ_PROP_GROUP_MEMBERS ||
                        PropertyId == AZ_PROP_GROUP_NON_MEMBERS ) {
                PropType = PT_SID_ARRAY;
            }

            break;

        case AzoGroupSetProp:
            OpName = "AzGroupSetProperty";

            WinStatus = AzGroupSetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            WasSetProperty = TRUE;

            if ( PropertyId == AZ_PROP_GROUP_TYPE ) {
                PropType = PT_ULONG;
            } else if ( PropertyId == AZ_PROP_GROUP_APP_MEMBERS ||
                        PropertyId == AZ_PROP_GROUP_APP_NON_MEMBERS ) {
                PropType = PT_STRING_ARRAY;
            } else if ( PropertyId == AZ_PROP_GROUP_LDAP_QUERY ) {
                PropType = PT_LPWSTR;
            } else if ( PropertyId == AZ_PROP_GROUP_MEMBERS ||
                        PropertyId == AZ_PROP_GROUP_NON_MEMBERS ) {
                PropType = PT_SID_ARRAY;
            }

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoGroupAddProp:
            OpName = "AzGroupAddProperty";

            WinStatus = AzGroupAddPropertyItem(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoGroupRemProp:
            OpName = "AzGroupRemProperty";

            WinStatus = AzGroupRemovePropertyItem(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoGroupDelete:
            OpName = "AzGroupDelete";
            WinStatus = AzGroupDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            break;


        //
        // Role APIs
        //
        case AzoRoleCreate:
            OpName = "AzRoleCreate";
            WinStatus = AzRoleCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoRoleOpen:
            OpName = "AzRoleOpen";
            WinStatus = AzRoleOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoRoleEnum:
            OpName = "AzRoleEnum";
            WinStatus = AzRoleEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoRoleGetProp:
            OpName = "AzRoleGetProperty";

            WinStatus = AzRoleGetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            &PropertyValue );

            WasGetProperty = TRUE;

            if ( PropertyId == AZ_PROP_ROLE_APP_MEMBERS ||
                 PropertyId == AZ_PROP_ROLE_OPERATIONS ||
                 PropertyId == AZ_PROP_ROLE_SCOPES ) {
                PropType = PT_STRING_ARRAY;
            } else if ( PropertyId == AZ_PROP_ROLE_MEMBERS ) {
                PropType = PT_SID_ARRAY;
            }

            break;

        case AzoRoleSetProp:
            OpName = "AzRoleSetProperty";

            WinStatus = AzRoleSetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            WasSetProperty = TRUE;

            if ( PropertyId == AZ_PROP_ROLE_APP_MEMBERS ||
                 PropertyId == AZ_PROP_ROLE_OPERATIONS ||
                 PropertyId == AZ_PROP_ROLE_SCOPES ) {
                PropType = PT_STRING_ARRAY;
            } else if ( PropertyId == AZ_PROP_ROLE_MEMBERS ) {
                PropType = PT_SID_ARRAY;
            }

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoRoleAddProp:
            OpName = "AzRoleAddProperty";

            WinStatus = AzRoleAddPropertyItem(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoRoleRemProp:
            OpName = "AzRoleRemProperty";

            WinStatus = AzRoleRemovePropertyItem(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoRoleDelete:
            OpName = "AzRoleDelete";
            WinStatus = AzRoleDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            break;


        //
        // JunctionPoint APIs
        //
        case AzoJPCreate:
            OpName = "AzJunctionPointCreate";
            WinStatus = AzJunctionPointCreate(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            SubmitHandle = *Operation->OutputHandle;

            break;

        case AzoJPOpen:
            OpName = "AzJunctionPointOpen";
            WinStatus = AzJunctionPointOpen(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0,  // reserved
                            Operation->OutputHandle );

            break;

        case AzoJPEnum:
            OpName = "AzJunctionPointEnum";
            WinStatus = AzJunctionPointEnum(
                            *Operation->InputHandle,
                            0,  // reserved
                            &EnumerationContext,
                            Operation->OutputHandle );

            break;

        case AzoJPGetProp:
            OpName = "AzJunctionPointGetProperty";

            WinStatus = AzJunctionPointGetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            &PropertyValue );

            WasGetProperty = TRUE;

            if ( PropertyId == AZ_PROP_JUNCTION_POINT_APPLICATION ) {
                PropType = PT_LPWSTR;
            }

            break;

        case AzoJPSetProp:
            OpName = "AzJunctionPointSetProperty";

            WinStatus = AzJunctionPointSetProperty(
                            *Operation->InputHandle,
                            PropertyId,
                            0,  // reserved
                            Operation->Parameter1 );

            WasSetProperty = TRUE;

            if ( PropertyId == AZ_PROP_JUNCTION_POINT_APPLICATION ) {
                PropType = PT_LPWSTR;
            }

            SubmitHandle = *Operation->InputHandle;

            break;

        case AzoJPDelete:
            OpName = "AzJunctionPointDelete";
            WinStatus = AzJunctionPointDelete(
                            *Operation->InputHandle,
                            Operation->Parameter1,
                            0 );  // reserved

            break;





        case AzoClose:
            OpName = "AzCloseHandle";
            WinStatus = AzCloseHandle(
                            *Operation->InputHandle,
                            0 );  // reserved

            break;

        // Pseudo function test links between objects
        case AzoTestLink:
            OpName = "TestLink";

            // Handle to the parent of the object being linked from
            TestLinkHandleP = *Operation->InputHandle;

            // Handle to the object being linked from
            TestLinkHandleA = *Operation->OutputHandle;

            // PropId to use for all set/get property
            TestLinkPropId = PropertyId;

            // Opcode offset to use for linked-to objects
            TestLinkOpcodeOffset = Operation->ExpectedStatus;

            // Name of the object being linked from
            wcscpy(TestLinkObjectName, Operation->ExpectedParameter1);


            WinStatus = Operation->ExpectedStatus;

            //
            // Build a new echo prefix
            //

            strcpy( BigBuffer, EchoPrefix );
            strcat( BigBuffer, "->" );
            strcat( BigBuffer, (LPSTR)Operation->Parameter1 );

            //
            // Print a description of the operation
            //

            PrintIndent( Indentation, FALSE );
            printf( "\n%s - Test linking '%s' objects to the object named '%ws' using propid '%ld'.\n",
                    BigBuffer,
                    Operation->Parameter1,
                    TestLinkObjectName,
                    TestLinkPropId );

            break;

        // Pseudo function to duplicate a handle
        case AzoDupHandle:
            OpName = "DupHandle";
            *Operation->OutputHandle = *Operation->InputHandle;
            WinStatus = NO_ERROR;

            break;

        // Pseudo function to execute a "subroutine" of operations
        case AzoGoSub:
            OpName = "GoSub";
            WinStatus = NO_ERROR;

            break;

        // Pseudo function to echo text to stdout
        case AzoEcho:
            OpName = BigBuffer;
            strcpy( OpName, "\n");
            if ( EchoPrefix ) {
                strcat( OpName, EchoPrefix );
                strcat( OpName, " -" );
            }
            WinStatus = NO_ERROR;

            break;

        default:

            OpName = "<Unknown>";
            PrintIndent( Indentation+4, TRUE );
            RetVal = FALSE;
            printf( "Need to fix test app to handle a new opcode: %ld\n", Opcode );
            WinStatus = Operation->ExpectedStatus;
            break;

        }

        //
        // Print the operation
        //

        if ( FirstIteration ) {

            if ( Opcode != AzoTestLink ) {

                PrintIndent( Indentation, FALSE );
                printf( "%s ", OpName );

                if ( Operation->Parameter1 != NULL ) {
                    if ( WasSetProperty ) {
                        switch ( PropType ) {
                        case PT_LPWSTR:
                            printf( "'%ws' ", Operation->Parameter1 );
                            break;
                        case PT_ULONG:
                            printf( "'%ld' ", *(PULONG)Operation->Parameter1 );
                            break;
                        }
                    } else {
                        printf( "'%ws' ", Operation->Parameter1 );
                    }
                }
                if ( PropertyId != 0 ) {
                    printf( "(%ld) ", PropertyId );
                }

                if ( Operation->ExpectedStatus != NO_ERROR ) {

                    printf("(");
                    PrintStatus( Operation->ExpectedStatus );
                    printf(") ");
                }
                printf( "\n" );
            }
        }
        FirstIteration = FALSE;

        //
        // Handle ERROR_NO_MORE_ITEMS/NO_ERROR mapping
        //

        RealWinStatus = WinStatus;
        if ( Operation->EnumOperations != NULL ) {
            if ( WinStatus == ERROR_NO_MORE_ITEMS ) {
                WinStatus = NO_ERROR;
            }
        }


        //
        // Ensure we got the right status code
        //

        if ( WinStatus != Operation->ExpectedStatus ) {
            PrintIndent( Indentation+4, TRUE );
            RetVal = FALSE;
            printf( "Returned '" );
            PrintStatus( WinStatus );
            printf( "' instead of '");
            PrintStatus( Operation->ExpectedStatus );
            printf( "'");
            printf( "\n" );
            break;
        }

        //
        // Do GetProperty specific code
        //

        if ( WasGetProperty ) {

            //
            // Print the property
            //

            switch ( PropType ) {
            case PT_LPWSTR:
                if ( PropertyValue == NULL ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "<NULL>\n", PropertyValue );
                } else {
                    PrintIndent( Indentation+4, FALSE );
                    printf( "'%ws'\n", PropertyValue );
                }

                //
                // Check if that value is expected
                //

                if ( Operation->ExpectedParameter1 != NULL &&
                     wcscmp( Operation->ExpectedParameter1, PropertyValue) != 0 ) {

                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "Expected '%ws' instead of '%ws'\n", Operation->ExpectedParameter1, PropertyValue );
                }

                break;

            case PT_STRING_ARRAY:
                StringArray1 = (PAZ_STRING_ARRAY) PropertyValue;;

                if ( PropertyValue == NULL ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "<NULL>\n", PropertyValue );
                } else {

                    for ( i=0; i<StringArray1->StringCount; i++ ) {
                        PrintIndent( Indentation+4, FALSE );
                        printf( "'%ws'\n", StringArray1->Strings[i] );
                    }
                }

                //
                // Check if that value is expected
                //

                if ( Operation->ExpectedParameter1 != NULL ) {
                    StringArray2 = (PAZ_STRING_ARRAY)Operation->ExpectedParameter1;

                    if ( StringArray1->StringCount != StringArray2->StringCount ) {
                        PrintIndent( Indentation+4, TRUE );
                        RetVal = FALSE;
                        printf( "Expected '%ld' strings instead of '%ld' strings\n", StringArray2->StringCount, StringArray1->StringCount );
                    } else {

                        for ( i=0; i<StringArray1->StringCount; i++ ) {

                            if ( wcscmp( StringArray1->Strings[i], StringArray2->Strings[i]) != 0 ) {

                                PrintIndent( Indentation+4, TRUE );
                                RetVal = FALSE;
                                printf( "Expected string %ld to be '%ws' instead of '%ws'\n",
                                        i,
                                        StringArray2->Strings[i],
                                        StringArray1->Strings[i] );

                            }
                        }
                    }
                }

                break;

            case PT_ULONG:
                if ( PropertyValue == NULL ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "<NULL>\n", PropertyValue );
                } else {
                    PrintIndent( Indentation+4, FALSE );
                    printf( "'%ld'\n", *(PULONG)PropertyValue );
                }

                //
                // Check if that value is expected
                //

                if ( *(PULONG)(Operation->ExpectedParameter1) != *(PULONG)PropertyValue ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "Expected '%ld' instead of '%ld'\n",
                                 *(PULONG)(Operation->ExpectedParameter1),
                                 *(PULONG)PropertyValue );
                }
                break;

            case PT_SID_ARRAY:
                SidArray1 = (PAZ_SID_ARRAY) PropertyValue;;

                if ( PropertyValue == NULL ) {
                    PrintIndent( Indentation+4, TRUE );
                    RetVal = FALSE;
                    printf( "<NULL>\n" );
                } else {
                    LPWSTR TempString;

                    for ( i=0; i<SidArray1->SidCount; i++ ) {
                        PrintIndent( Indentation+4, FALSE );

                        if ( !ConvertSidToStringSidW( SidArray1->Sids[i],
                                                      &TempString ) ) {
                            PrintIndent( Indentation+4, TRUE );
                            RetVal = FALSE;
                            printf( "Cannot convert sid.\n" );

                        } else {
                            printf( "'%ws'\n", TempString );
                        }
                    }
                }

                //
                // Check if that value is expected
                //

                if ( Operation->ExpectedParameter1 != NULL ) {
                    SidArray2 = (PAZ_SID_ARRAY)Operation->ExpectedParameter1;

                    if ( SidArray1->SidCount != SidArray2->SidCount ) {
                        PrintIndent( Indentation+4, TRUE );
                        RetVal = FALSE;
                        printf( "Expected '%ld' sids instead of '%ld' sids\n", SidArray2->SidCount, SidArray1->SidCount );
                    } else {

                        for ( i=0; i<SidArray1->SidCount; i++ ) {

                            if ( !EqualSid( SidArray1->Sids[i], SidArray2->Sids[i]) ) {
                                LPWSTR TempString1;
                                LPWSTR TempString2;

                                if ( !ConvertSidToStringSidW( SidArray1->Sids[i],
                                                             &TempString1 ) ) {
                                    PrintIndent( Indentation+4, TRUE );
                                    RetVal = FALSE;
                                    printf( "Cannot convert sid.\n" );
                                    continue;
                                }

                                if ( !ConvertSidToStringSidW( SidArray2->Sids[i],
                                                             &TempString2 ) ) {
                                    PrintIndent( Indentation+4, TRUE );
                                    RetVal = FALSE;
                                    printf( "Cannot convert sid.\n" );
                                    continue;
                                }

                                PrintIndent( Indentation+4, TRUE );
                                RetVal = FALSE;
                                printf( "Expected string %ld to be '%ws' instead of '%ws'\n",
                                        i,
                                        TempString2,
                                        TempString1 );

                            }
                        }
                    }
                }

                break;

            default:
                ASSERT(FALSE);
            }

            //
            // Free the returned buffer
            //

            AzFreeMemory( PropertyValue );

        }

        //
        // Submit the changes to the database
        //

        if ( WinStatus == NO_ERROR && SubmitHandle != INVALID_HANDLE_VALUE ) {

            WinStatus = AzSubmit( SubmitHandle,
                                  0);  // reserved

            if ( WinStatus != NO_ERROR ) {
                PrintIndent( Indentation+4, TRUE );
                RetVal = FALSE;
                printf( "AzSubmit failed %ld\n", WinStatus );
            }
        }


        //
        // Execute a "subroutine" of operations
        //

        if ( Opcode == AzoGoSub ) {

            if (!DoOperations( Operation->EnumOperations, Indentation + 4, SpecificOpcodeOffset, EchoPrefix ) ) {
                RetVal = FALSE;
            }

        //
        // Execute a the special TestLink "subroutine" of operations
        //

        } else if ( Opcode == AzoTestLink ) {

            if (!DoOperations( Operation->EnumOperations, Indentation + 4, SpecificOpcodeOffset, BigBuffer ) ) {
                RetVal = FALSE;
            }

            TestLinkPropId = 0;


        //
        // Do enumeration specific code
        //

        } else if ( Operation->EnumOperations != NULL && RealWinStatus == NO_ERROR ) {

            PrintIndent( Indentation+4, FALSE );
            printf( "%ld:\n", EnumerationContext );

            if (!DoOperations( Operation->EnumOperations, Indentation + 8, SpecificOpcodeOffset, EchoPrefix ) ) {
                RetVal = FALSE;
                break;
            }

            continue;
        }

        //
        // Do the next operation
        //

        EnumerationContext = 0;
        FirstIteration = TRUE;
        Operation++;
    }

    return RetVal;
}


int __cdecl
main(
    IN int argc,
    IN char ** argv
    )
/*++

Routine Description:

    Test azroles.dll

Arguments:

    argc - the number of command-line arguments.

    argv - an array of pointers to the arguments.

Return Value:

    Exit status

--*/
{
    BOOL RetVal = TRUE;

    ULONG TestNum;
    ULONG Index;
    ULONG Index2;
    CHAR EchoPrefix[1024];

    //
    // Objects that are children of "AdminManager"
    //
    DWORD GenAdmChildTests[] =    {     AzoApp,        AzoGroup };
    LPSTR GenAdmChildTestName[] = {     "Application", "Group" };
    POPERATION SpeAdmChildTestOps[] = { NULL,          OpAdmGroup };
    POPERATION GenAdmChildTestOps[] = { OpAdmChildGen, OpAdmChildGenDupName
#ifdef ENABLE_LEAK
        , OpAdmChildGenLeak
#endif // ENABLE_LEAK
    };

    //
    // Objects that are children of "Application"
    //
    DWORD GenAppChildTests[] =    {     AzoOp,       AzoTask, AzoScope, AzoGroup,   AzoRole,   AzoJP };
    LPSTR GenAppChildTestName[] = {     "Operation", "Task",  "Scope",  "Group",    "Role",    "JunctionPoint" };
    POPERATION SpeAppChildTestOps[] = { OpOperation, OpTask,  NULL,     OpAppGroup, OpAppRole, OpAppJunctionPoint };
    POPERATION GenAppChildTestOps[] = { OpAppChildGen, OpAppChildGenHandleOpen, OpAppChildGenDupName };

    //
    // Objects that are children of "Scope"
    //
    DWORD GenScopeChildTests[] =    {     AzoGroup,    AzoRole };
    LPSTR GenScopeChildTestName[] = {     "Group",     "Role" };
    POPERATION SpeScopeChildTestOps[] = { OpScopeGroup, OpScopeRole };
    POPERATION GenScopeChildTestOps[] = { OpScopeChildGen, OpScopeChildGenDupName };


    struct {

        //
        // Name of the parent object
        LPSTR ParentName;

        //
        // List of children to test for this parent
        DWORD ChildCount;
        DWORD *ChildOpcodeOffsets;
        LPSTR *ChildTestNames;
        // Operation to perform that is specific to the child type
        POPERATION *ChildOperations;

        //
        // List of tests to perform for each child type
        //
        DWORD OperationCount;
        POPERATION *Operations;
    } ParentChildTests[] = {
        { "AdminManager",
           sizeof(GenAdmChildTestName)/sizeof(GenAdmChildTestName[0]),
           GenAdmChildTests,
           GenAdmChildTestName,
           SpeAdmChildTestOps,
           sizeof(GenAdmChildTestOps)/sizeof(GenAdmChildTestOps[0]),
           GenAdmChildTestOps },
        { "Application",
           sizeof(GenAppChildTestName)/sizeof(GenAppChildTestName[0]),
           GenAppChildTests,
           GenAppChildTestName,
           SpeAppChildTestOps,
           sizeof(GenAppChildTestOps)/sizeof(GenAppChildTestOps[0]),
           GenAppChildTestOps },
        { "Scope",
           sizeof(GenScopeChildTestName)/sizeof(GenScopeChildTestName[0]),
           GenScopeChildTests,
           GenScopeChildTestName,
           SpeScopeChildTestOps,
           sizeof(GenScopeChildTestOps)/sizeof(GenScopeChildTestOps[0]),
           GenScopeChildTestOps },
    };

    // Delete the testfile
    DeleteFileA( ".\\TestFile" );


// #if 0
    //
    // Loop for each object that can be the parent of another object
    //

    for ( TestNum=0; TestNum < sizeof(ParentChildTests)/sizeof(ParentChildTests[0]); TestNum++ ) {

        //
        // Loop for each child of the parent object
        //
        for ( Index=0; Index < ParentChildTests[TestNum].ChildCount; Index ++ ) {

            //
            // output the test name
            //

            strcpy( EchoPrefix, ParentChildTests[TestNum].ParentName );
            strcat( EchoPrefix, "->" );
            strcat( EchoPrefix, ParentChildTests[TestNum].ChildTestNames[Index] );

            printf("\n%s - Perform tests of '%s' objects that are children of '%s' objects\n",
                    EchoPrefix,
                    ParentChildTests[TestNum].ChildTestNames[Index],
                    ParentChildTests[TestNum].ParentName );

            //
            // Do the various generic tests that apply to all objects
            //

            for ( Index2=0; Index2 < ParentChildTests[TestNum].OperationCount; Index2 ++ ) {

                if ( !DoOperations(
                            ParentChildTests[TestNum].Operations[Index2],
                            0,
                            ParentChildTests[TestNum].ChildOpcodeOffsets[Index],
                            EchoPrefix ) ) {

                    RetVal = FALSE;
                    goto Cleanup;
                }

                // Delete the testfile
                if ( !DeleteFileA( ".\\TestFile" )) {
                    printf( "Cannot delete TestFile %ld\n", GetLastError() );
                    RetVal = FALSE;
                    goto Cleanup;
                }

            }

            //
            // Do the one test that is specific to this parent/child relationship
            //

            if ( ParentChildTests[TestNum].ChildOperations[Index] == NULL ) {
                // ??? Should complain here.  Test is missing
            } else {

                if ( !DoOperations(
                            ParentChildTests[TestNum].ChildOperations[Index],
                            0,
                            ParentChildTests[TestNum].ChildOpcodeOffsets[Index],
                            EchoPrefix ) ) {

                    RetVal = FALSE;
                    goto Cleanup;
                }

                // Delete the testfile
                if ( !DeleteFileA( ".\\TestFile" )) {
                    printf( "Cannot delete TestFile %ld\n", GetLastError() );
                    RetVal = FALSE;
                    goto Cleanup;
                }
            }
        }
    }


    //
    // Do name sharing specific tests
    //
    if ( !DoOperations( OpShare, 0, 0, "NameShare" ) ) {
        RetVal = FALSE;
        goto Cleanup;
    }

    // Delete the testfile
    if ( !DeleteFileA( ".\\TestFile" )) {
        printf( "Cannot delete TestFile %ld\n", GetLastError() );
        RetVal = FALSE;
        goto Cleanup;
    }
// #endif // 0

    //
    // Do peristence specific tests
    //
    if ( !DoOperations( OpPersist, 0, 0, "Persist" ) ) {
        RetVal = FALSE;
        goto Cleanup;
    }

    // Delete the testfile
    if ( !DeleteFileA( ".\\TestFile" )) {
        printf( "Cannot delete TestFile %ld\n", GetLastError() );
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Check for memory leaks
    //

    if ( RetVal ) {
        AzpUnload();
    }


    //
    // Done
    //
Cleanup:
    printf( "\n\n" );
    if ( RetVal ) {
        printf( "Tests completed successfully!\n");
        return 0;
    } else {
        printf( "One or more tests failed.\n");
        return 1;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\audit\exts\adtexts.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        N E W E X T . C
//
// Contents:    LSA debugger extensions that use the new style 
//              extension API.
//
//
// History:     
//   07-January-2000  kumarp        created
//
// Note:
// 
// If you want to add extensions to this file, read the following
// guidelines from andreva first:
//
// Everyone who debugs or runs stress will expect debugger extensions 
// to work on both 32 bit and 64 bit TARGETS.  The Debugger extensions must 
// therefore be TARGET independent.  We the only viable solution to this is to 
// get structure definitions from the symbol information, instead of 
// from the header file.  So the way we solve this problem is:
//
// - A debugger extension can only include windows.h and wdbgexts.h
// - A debugger extensions NEVER includes header files from 
//   the component it tries to analyze\debug.
// - Debugger extensions use the new routines we provide to query 
//   type information.
//
//------------------------------------------------------------------------

#include <windows.h>
#include <dbghelp.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <ntverp.h>

// ----------------------------------------------------------------------
//
// globals
//
WINDBG_EXTENSION_APIS   ExtensionApis;
EXT_API_VERSION         ApiVersion =
{
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER64,
    0
};
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

// ----------------------------------------------------------------------
//
// The following 3 functions must be present in the extension dll.
// They were lifted straight from base\tools\kdexts\kdexts.c
//
VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis, // 64Bit Change
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
// ----------------------------------------------------------------------


BOOL
GetGlobalVar (
    IN  PUCHAR   Name, 
    IN  USHORT   Size,
    OUT PVOID    pOutValue
   ) 
/*++

Routine Description:

    Get value of global vars of primitive type OR
    Get the address instead for non-primitive global vars.

    Primitive type is defined as the one not-involving any struct/union
    in its type definition. Pointer to struct/unions are ok.
    for example: USHORT, ULONG, PVOID etc.

Arguments:

    Name      - global var name
                (for example: "lsasrv!LsapAdtContextList")

    Size      - size in bytes for primitive types, 0 otherwise

    pOutValue - pointer to return val.

Return Value:

    TRUE on success, FALSE otherwise

Notes:

--*/
{
    ULONG64 Temp=0;

    SYM_DUMP_PARAM Sym =
    {
        sizeof (SYM_DUMP_PARAM),
        Name,
        DBG_DUMP_NO_PRINT | DBG_DUMP_COPY_TYPE_DATA,
        0, 
        NULL,
        &Temp,
        NULL,
        0,
        NULL
    };

    ULONG RetVal;

    RetVal = Ioctl( IG_DUMP_SYMBOL_INFO, &Sym, Sym.size );

    //
    // store only the correct number of bytes from the value read
    //
    switch(Size)
    {
        default:
        case 0:
            *((PUCHAR*) pOutValue)  = (PUCHAR) Sym.addr;
            break;

        case 1:
            *((UCHAR*) pOutValue)   = (UCHAR) Temp;
            break;
            
        case 2:
            *((USHORT*) pOutValue)  = (USHORT) Temp;
            break;
            
        case 4:
            *((DWORD*) pOutValue)   = (DWORD) Temp;
            break;
            
        case 8:
            *((ULONG64*) pOutValue) = Temp;
            break;
    }
   
   return (RetVal == NO_ERROR);
}

//
// helper macro to get field of AUDIT_CONTEXT struct
//
#define GetAuditContextField(addr,f)    \
          GetFieldData( (ULONG64) addr, \
                        "AUDIT_CONTEXT",\
                        #f,             \
                        sizeof(f),      \
                        &f )

//
// helper macro to get LIST_ENTRY.Flink
//
#define GetFlink(addr,pflink) \
          GetFieldData( addr,\
                        "LIST_ENTRY", \
                        "Flink",\
                        sizeof(ULONG64),\
                        pflink )
void
DumpAuditContextList(
    )
/*++

Routine Description:

    Dump the audit context list.

Arguments:
    None

Return Value:

    None

Notes:
    It appears that there is a built in support for dumping
    lists using SYM_DUMP_PARAM.listLink but I came to know about it too late.

--*/
{
    LIST_ENTRY LsapAdtContextList = { (PLIST_ENTRY) 22, (PLIST_ENTRY) 33 };
    ULONG64    pLsapAdtContextList=0;
    ULONG      LsapAdtContextListCount=0;
    ULONG64    Temp=0;
    ULONG64    Scan=0;
    ULONG64    Link=0;
    USHORT     CategoryId;
    USHORT     AuditId;
    USHORT     ParameterCount;
    
    ULONG Status=NO_ERROR;
    ULONG i;

    if (!GetGlobalVar( "lsasrv!LsapAdtContextListCount",
                       sizeof(LsapAdtContextListCount),
                       &LsapAdtContextListCount ))
    {
        goto Cleanup;
    }

    dprintf( "# contexts: %ld\n", LsapAdtContextListCount );

    if ( ((LONG) LsapAdtContextListCount) < 0 )
    {
        dprintf("...List/ListCount may be corrupt\n");
        goto Cleanup;
    }

    if ( LsapAdtContextListCount == 0 )
    {
        goto Cleanup;
    }

    if (!GetGlobalVar( "lsasrv!LsapAdtContextList",
                       0,
                       &pLsapAdtContextList ))
    {
        dprintf("...error reading lsasrv!LsapAdtContextList\n");
        goto Cleanup;
    }
    
    Status = GetFlink( pLsapAdtContextList, &Scan );
    if ( Status != NO_ERROR )
    {
        dprintf("...error reading lsasrv!LsapAdtContextList.Flink\n");
        goto Cleanup;
    }

    dprintf("LsapAdtContextList @ %p\n", pLsapAdtContextList);
    
    for (i=0; i < LsapAdtContextListCount; i++)
    {
        dprintf("%02d) [%p]: ", i, Scan);
        
        if ( Scan == pLsapAdtContextList )
        {
            dprintf("...pre-mature end of list\nList/ListCount may be corrupt\n");
            break;
        }
        else if ( Scan == 0 )
        {
            dprintf("...NULL list element found!\nList/ListCount may be corrupt\n");
            break;
        }

        Status = GetAuditContextField( Scan, CategoryId );
                        
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.CategoryId\n");
            break;
        }

        dprintf("Category: %03x\t", CategoryId);
        
        Status = GetAuditContextField( Scan, AuditId );
                        
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.AuditId\n");
            break;
        }

        dprintf("AuditId: %03x\t", AuditId);
        
        Status = GetAuditContextField( Scan, Link );
        if ( Status != NO_ERROR )
        {
            dprintf("...error reading AUDIT_CONTEXT.Link\n");
            break;
        }
            
        Status = GetFlink( Link, &Scan );
        if ( Status != NO_ERROR )
        {
            goto Cleanup;
        }

        dprintf("\n");
    }

Cleanup:
    if ( Status != NO_ERROR )
    {
        dprintf("...failed\n");
    }
}

DECLARE_API(AuditContexts)
{
    DumpAuditContextList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\azroles\util.cxx ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Utility routines

Author:

    Cliff Van Dyke (cliffv) 11-Apr-2001

--*/


#include "pch.hxx"

#if DBG
//
// List of all allocated blocks
//  AccessSerialized by AzGlAllocatorCritSect
LIST_ENTRY AzGlAllocatedBlocks;
CRITICAL_SECTION AzGlAllocatorCritSect;

#endif // DBG



PVOID
AzpAllocateHeap(
    IN SIZE_T Size
    )
/*++

Routine Description

    Memory allocator

Arguments

    Size - Size (in bytes) to allocate

Return Value

    Returns a pointer to the allocated memory.
    NULL - Not enough memory

--*/
{
#if DBG
    ULONG HeaderSize = ROUND_UP_COUNT( sizeof(LIST_ENTRY), ALIGN_WORST );

    PLIST_ENTRY RealBlock;

    //
    // Allocate a block with a header
    //

    RealBlock = (PLIST_ENTRY) LocalAlloc( 0, HeaderSize + Size );

    if ( RealBlock == NULL ) {
        return NULL;
    }

    //
    // Link the block since we're nosey.
    //

    EnterCriticalSection( &AzGlAllocatorCritSect );
    InsertHeadList( &AzGlAllocatedBlocks, RealBlock );
    LeaveCriticalSection( &AzGlAllocatorCritSect );

    return (PVOID)(((LPBYTE)RealBlock)+HeaderSize);

#else // DBG
    return LocalAlloc( 0, Size );
#endif // DBG
}

VOID
AzpFreeHeap(
    IN PVOID Buffer
    )
/*++

Routine Description

    Memory de-allocator

Arguments

    Buffer - address of buffer to free

Return Value

    None

--*/
{
#if DBG
    ULONG HeaderSize = ROUND_UP_COUNT( sizeof(LIST_ENTRY), ALIGN_WORST );
    PLIST_ENTRY RealBlock;

    RealBlock = (PLIST_ENTRY)(((LPBYTE)Buffer)-HeaderSize);

    EnterCriticalSection( &AzGlAllocatorCritSect );
    RemoveEntryList( RealBlock );
    LeaveCriticalSection( &AzGlAllocatorCritSect );

    LocalFree( RealBlock );
#else // DBG
    LocalFree( Buffer );
#endif // DBG

}


VOID
AzpInitString(
    OUT PAZP_STRING AzpString,
    IN LPWSTR String OPTIONAL
    )
/*++

Routine Description

    Initialize our private string structure to point to a passed in string.

Arguments

    AzpString - Initialized string

    String - zero terminated string to be reference
        If NULL, AzpString will be initialized to empty.

Return Value

    None

--*/
{
    //
    // Initialization
    //

    if ( String == NULL ) {
        AzpString->String = NULL;
        AzpString->StringSize = 0;
    } else {
        AzpString->String = String;
        AzpString->StringSize = (ULONG) ((wcslen(String)+1)*sizeof(WCHAR));
    }

}

DWORD
AzpCaptureString(
    OUT PAZP_STRING AzpString,
    IN LPCWSTR String,
    IN ULONG MaximumLength,
    IN BOOLEAN NullOk
    )
/*++

Routine Description

    Capture the passed in string.

Arguments

    AzpString - Captured copy of the passed in string.
        On success, string must be freed using AzpFreeString

    String - zero terminated string to capture

    MaximumLength - Maximum length of the string (in characters).

    NullOk - if TRUE, a NULL string or zero length string is OK.

Return Value

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    ULONG WinStatus;
    ULONG StringSize;

    //
    // Initialization
    //

    AzpInitString( AzpString, NULL );

    if ( String == NULL ) {
        if ( !NullOk ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureString: NULL not ok\n" ));
            return ERROR_INVALID_PARAMETER;
        }
        return NO_ERROR;
    }

    __try {

        //
        // Validate a passed in LPWSTR
        //

        ULONG StringLength;

        StringLength = (ULONG) wcslen( String );

        if ( StringLength == 0 ) {
            if ( !NullOk ) {
                AzPrint(( AZD_INVPARM, "AzpCaptureString: zero length not ok\n" ));
                return ERROR_INVALID_PARAMETER;
            }
            return NO_ERROR;
        }

        if ( StringLength > MaximumLength ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureString: string too long %ld %ld %ws\n", StringLength, MaximumLength, String ));
            return ERROR_INVALID_PARAMETER;
        }

        StringSize = (StringLength+1)*sizeof(WCHAR);


        //
        // Allocate and copy the string
        //

        AzpString->String = (LPWSTR) AzpAllocateHeap( StringSize );

        if ( AzpString->String == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            RtlCopyMemory( AzpString->String,
                           String,
                           StringSize );

            AzpString->StringSize = StringSize;

            WinStatus = NO_ERROR;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());

        AzpFreeString( AzpString );
    }

    return WinStatus;
}

DWORD
AzpCaptureSid(
    OUT PAZP_STRING AzpString,
    IN PSID Sid
    )
/*++

Routine Description

    Capture the passed in SID

Arguments

    AzpString - Captured copy of the passed in sid.
        On success, string must be freed using AzpFreeString

    Sid - Sid to capture

Return Value

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory
    Other exception status codes

--*/
{
    ULONG WinStatus;
    ULONG StringSize;

    //
    // Initialization
    //

    AzpInitString( AzpString, NULL );


    __try {

        //
        // Validate a passed in SID
        //

        if ( !RtlValidSid( Sid ) ) {
            AzPrint(( AZD_INVPARM, "AzpCaptureString: SID not valid\n" ));
            return ERROR_INVALID_PARAMETER;
        }

        StringSize = RtlLengthSid( Sid );

        //
        // Allocate and copy the SID
        //

        AzpString->String = (LPWSTR) AzpAllocateHeap( StringSize );

        if ( AzpString->String == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            RtlCopyMemory( AzpString->String,
                           Sid,
                           StringSize );

            AzpString->StringSize = StringSize;

            WinStatus = NO_ERROR;
        }

    } __except( EXCEPTION_EXECUTE_HANDLER ) {

        WinStatus = RtlNtStatusToDosError( GetExceptionCode());

        AzpFreeString( AzpString );
    }

    return WinStatus;
}

DWORD
AzpCaptureUlong(
    IN PVOID PropertyValue,
    OUT PULONG UlongValue
    )
/*++

Routine Description

    Support routine for the SetProperty API.
    Capture a parameter for the user application.

Arguments

    PropertyValue - Specifies a pointer to the property.

    UlongValue - Value to return to make a copy of.

Return Value
    NO_ERROR - The operation was successful
    Other exception status codes


--*/
{
    DWORD WinStatus;

    __try {
        *UlongValue = *(PULONG)PropertyValue;
        WinStatus = NO_ERROR;
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        WinStatus = RtlNtStatusToDosError( GetExceptionCode());
    }

    return WinStatus;
}

DWORD
AzpDuplicateString(
    OUT PAZP_STRING AzpOutString,
    IN PAZP_STRING AzpInString
    )
/*++

Routine Description

    Make a duplicate of the passed in string

Arguments

    AzpOutString - Returns a copy of the passed in string.
        On success, string must be freed using AzpFreeString.

    AzpInString - Specifies a string to make a copy of.

Return Value

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory

--*/
{
    ULONG WinStatus;

    //
    // Initialization
    //

    AzpInitString( AzpOutString, NULL );

    //
    // Handle an empty string
    //

    if ( AzpInString->StringSize == 0 || AzpInString->String == NULL ) {

        WinStatus = NO_ERROR;

    //
    // Allocate and copy the string
    //

    } else {
        AzpOutString->String = (LPWSTR) AzpAllocateHeap( AzpInString->StringSize );

        if ( AzpOutString->String == NULL ) {
            WinStatus = ERROR_NOT_ENOUGH_MEMORY;
        } else {

            RtlCopyMemory( AzpOutString->String,
                           AzpInString->String,
                           AzpInString->StringSize );

            AzpOutString->StringSize = AzpInString->StringSize;

            WinStatus = NO_ERROR;
        }
    }

    return WinStatus;
}

BOOL
AzpEqualStrings(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    )
/*++

Routine Description

    Does a case insensitive comparison of two strings

Arguments

    AzpString1 - First string to compare

    AzpString2 - Second string to compare

Return Value

    TRUE: the strings are equal
    FALSE: the strings are not equal

--*/
{

    //
    // Simply compare the strings
    //
    return (AzpCompareStrings( AzpString1, AzpString2 ) == CSTR_EQUAL);

}


LONG
AzpCompareStrings(
    IN PAZP_STRING AzpString1,
    IN PAZP_STRING AzpString2
    )
/*++

Routine Description

    Does a case insensitive comparison of two strings

Arguments

    AzpString1 - First string to compare

    AzpString2 - Second string to compare

Return Value

    0: An error ocurred.  Call GetLastError();
    CSTR_LESS_THAN: String 1 is less than string 2
    CSTR_EQUAL: String 1 is equal to string 2
    CSTR_GREATER_THAN: String 1 is greater than string 2

--*/
{

    //
    // Handle NULL
    //

    if ( AzpString1->String == NULL ) {
        if ( AzpString2->String == NULL ) {
            return CSTR_EQUAL;
        }else {
            return CSTR_LESS_THAN;
        }
    } else {
        if ( AzpString2->String == NULL ) {
            return CSTR_GREATER_THAN;
        }
    }


    //
    // Compare the Unicode strings
    //  Don't compare the trailing zero character.
    //  (Some callers pass in strings where the trailing character isn't a zero.)
    //

    return CompareStringW( LOCALE_SYSTEM_DEFAULT,
                           NORM_IGNORECASE,
                           AzpString1->String,
                           (AzpString1->StringSize/sizeof(WCHAR))-1,
                           AzpString2->String,
                           (AzpString2->StringSize/sizeof(WCHAR))-1 );

}

VOID
AzpSwapStrings(
    IN OUT PAZP_STRING AzpString1,
    IN OUT PAZP_STRING AzpString2
    )
/*++

Routine Description

    Swap two strings

Arguments

    AzpString1 - First string to swap

    AzpString2 - Second string to swap

Return Value

    None

--*/
{
    AZP_STRING TempString;

    TempString = *AzpString1;
    *AzpString1 = *AzpString2;
    *AzpString2 = TempString;

}

VOID
AzpFreeString(
    IN PAZP_STRING AzpString
    )
/*++

Routine Description

    Free the specified string

Arguments

    AzpString - String to be freed.

Return Value

    None

--*/
{
    if ( AzpString->String != NULL ) {
        AzpFreeHeap( AzpString->String );
    }

    AzpInitString( AzpString, NULL );
}


DWORD
AzpAddPtr(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Pointer,
    IN ULONG Index
    )
/*++

Routine Description

    Inserts a pointer into the array of pointers.

    The array will be automatically expanded to be large enough to contain the new pointer.
    All existing pointers from slot # 'Index' through the end of the existing array will
        be shifted to later slots.

Arguments

    AzpPtrArray - Array that the pointer will be inserted into.

    Pointer - Pointer to be inserted.

    Index - Index into the array where the 'Pointer' will be inserted
        If Index is larger than the current size of the array or AZP_ADD_ENDOFLIST,
        'Pointer' will be inserted after the existing elements of the array.

Return Value

    NO_ERROR - The operation was successful
    ERROR_NOT_ENOUGH_MEMORY - not enough memory


--*/
{

    //
    // Ensure Index isn't too large
    //

    if ( Index > AzpPtrArray->UsedCount ) {
        Index = AzpPtrArray->UsedCount;
    }

    //
    // If the array isn't large enough, make it bigger
    //

    if ( AzpPtrArray->UsedCount >= AzpPtrArray->AllocatedCount ) {
        PVOID *TempArray;

        //
        // Allocate a new array
        //

        TempArray = (PVOID *) AzpAllocateHeap(
                        (AzpPtrArray->AllocatedCount + AZP_PTR_ARRAY_INCREMENT) * sizeof(PVOID) );

        if ( TempArray == NULL ) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Copy the data into the new array and free the old array
        //

        if ( AzpPtrArray->Array != NULL ) {

            RtlCopyMemory( TempArray,
                           AzpPtrArray->Array,
                           AzpPtrArray->AllocatedCount * sizeof(PVOID) );

            AzpFreeHeap( AzpPtrArray->Array );
            AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: Free old array\n", AzpPtrArray, AzpPtrArray->Array ));
        }

        //
        // Grab the pointer to the new array and clear the new part of the array
        //

        AzpPtrArray->Array = TempArray;
        AzPrint(( AZD_OBJLIST, "0x%lx: 0x%lx: Allocate array\n", AzpPtrArray, AzpPtrArray->Array ));

        RtlZeroMemory( &TempArray[AzpPtrArray->UsedCount],
                       AZP_PTR_ARRAY_INCREMENT * sizeof(PVOID) );

        AzpPtrArray->AllocatedCount += AZP_PTR_ARRAY_INCREMENT;

    }

    //
    // Shift any old data
    //

    if ( Index != AzpPtrArray->UsedCount ) {

        RtlMoveMemory( &(AzpPtrArray->Array[Index+1]),
                       &(AzpPtrArray->Array[Index]),
                       (AzpPtrArray->UsedCount-Index) * sizeof(PVOID) );
    }

    //
    // Insert the new element
    //

    AzpPtrArray->Array[Index] = Pointer;
    AzpPtrArray->UsedCount ++;

    return NO_ERROR;
}


VOID
AzpRemovePtrByIndex(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN ULONG Index
    )
/*++

Routine Description

    Remove a pointer from the array of pointers.

    All existing pointers from slot # 'Index' through the end of the existing array will
        be shifted to earlier slots.

Arguments

    AzpPtrArray - Array that the pointer will be removed into.

    Index - Index into the array where the 'Pointer' will be removed from.


Return Value

    None

--*/
{

    //
    // Ensure Index isn't too large
    //

    ASSERT( Index < AzpPtrArray->UsedCount );


    //
    // Shift any old data
    //

    if ( Index+1 != AzpPtrArray->UsedCount ) {

        RtlMoveMemory( &(AzpPtrArray->Array[Index]),
                       &(AzpPtrArray->Array[Index+1]),
                       (AzpPtrArray->UsedCount-Index-1) * sizeof(PVOID) );
    }

    //
    // Clear the last element
    //

    AzpPtrArray->UsedCount--;
    AzpPtrArray->Array[AzpPtrArray->UsedCount] = NULL;

}


VOID
AzpRemovePtrByPtr(
    IN PAZP_PTR_ARRAY AzpPtrArray,
    IN PVOID Pointer
    )
/*++

Routine Description

    Removed a pointer from the array of pointers.

    All existing pointers following the specified pointer will
        be shifted to earlier slots.

Arguments

    AzpPtrArray - Array that the pointer will be removed into.

    Pointer - Pointer to be removed


Return Value

    None

--*/
{
    ULONG i;
    BOOLEAN FoundIt = FALSE;

    for ( i=0; i<AzpPtrArray->UsedCount; i++ ) {

        if ( Pointer == AzpPtrArray->Array[i] ) {
            AzpRemovePtrByIndex( AzpPtrArray, i );
            FoundIt = TRUE;
            break;
        }
    }

    ASSERT( FoundIt );

}



PVOID
AzpGetStringProperty(
    IN PAZP_STRING AzpString
    )
/*++

Routine Description

    Support routine for the GetProperty API.  Convert an AzpString to the form
    supported by GetProperty.

    Empty string are returned as Zero length string instead of NULL

Arguments

    AzpString - Specifies a string to make a copy of.

Return Value

    Pointer to allocated string.
        String should be freed using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    LPWSTR String;
    ULONG AllocatedSize;

    //
    // Allocate and copy the string
    //

    AllocatedSize = AzpString->StringSize ? AzpString->StringSize : sizeof(WCHAR);
    String = (LPWSTR) AzpAllocateHeap( AllocatedSize );

    if ( String != NULL ) {

        //
        // Convert NULL strings to zero length strings
        //

        if ( AzpString->StringSize == 0 ) {
            *String = L'\0';

        } else {

            RtlCopyMemory( String,
                           AzpString->String,
                           AzpString->StringSize );
        }

    }

    return String;
}

PVOID
AzpGetUlongProperty(
    IN ULONG UlongValue
    )
/*++

Routine Description

    Support routine for the GetProperty API.  Convert a ULONG to the form
    supported by GetProperty.

Arguments

    UlongValue - Value to return to make a copy of.

Return Value

    Pointer to allocated string.
        String should be freed using AzFreeMemory.
    NULL - Not enough memory was available to allocate the string

--*/
{
    PULONG RetValue;

    //
    // Allocate and copy the string
    //

    RetValue = (PULONG) AzpAllocateHeap( sizeof(ULONG) );

    if ( RetValue != NULL ) {

        *RetValue = UlongValue;

    }

    return RetValue;
}


//
// Debugging support
//
#ifdef AZROLESDBG
#include <stdio.h>
CRITICAL_SECTION AzGlLogFileCritSect;
ULONG AzGlDbFlag;
// HANDLE AzGlLogFile;

#define MAX_PRINTF_LEN 1024        // Arbitrary.

VOID
AzpPrintRoutineV(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    va_list arglist
    )
/*++

Routine Description

    Debug routine for azroles

Arguments

    DebugFlag - Flag to indicating the functionality being debugged

    --- Other printf parameters

Return Value

--*/

{
    static LPSTR AzGlLogFileOutputBuffer = NULL;
    ULONG length;
    int   lengthTmp;
    // DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    static LogProblemWarned = FALSE;

    //
    // If we aren't debugging this functionality, just return.
    //
    if ( DebugFlag != 0 && (AzGlDbFlag & DebugFlag) == 0 ) {
        return;
    }


    //
    // Allocate a buffer to build the line in.
    //  If there isn't already one.
    //

    length = 0;

    if ( AzGlLogFileOutputBuffer == NULL ) {
        AzGlLogFileOutputBuffer = (LPSTR) LocalAlloc( 0, MAX_PRINTF_LEN + 1 );

        if ( AzGlLogFileOutputBuffer == NULL ) {
            return;
        }
    }

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Never print empty lines.
        //

        if ( Format[0] == '\n' && Format[1] == '\0' ) {
            return;
        }

#if 0
        //
        // If the log file is getting huge,
        //  truncate it.
        //

        if ( AzGlLogFile != INVALID_HANDLE_VALUE &&
             !TruncateLogFileInProgress ) {

            //
            // Only check every 50 lines,
            //

            LineCount++;
            if ( LineCount >= 50 ) {
                DWORD FileSize;
                LineCount = 0;

                //
                // Is the log file too big?
                //

                FileSize = GetFileSize( AzGlLogFile, NULL );
                if ( FileSize == 0xFFFFFFFF ) {
                    (void) DbgPrint( "[NETLOGON] Cannot GetFileSize %ld\n",
                                     GetLastError );
                } else if ( FileSize > AzGlParameters.LogFileMaxSize ) {
                    TruncateLogFileInProgress = TRUE;
                    LeaveCriticalSection( &AzGlLogFileCritSect );
                    NlOpenDebugFile( TRUE );
                    NlPrint(( NL_MISC,
                              "Logfile truncated because it was larger than %ld bytes\n",
                              AzGlParameters.LogFileMaxSize ));
                    EnterCriticalSection( &AzGlLogFileCritSect );
                    TruncateLogFileInProgress = FALSE;
                }

            }
        }

        //
        // If we're writing to the debug terminal,
        //  indicate this is a azroles message.
        //

        if ( AzGlLogFile == INVALID_HANDLE_VALUE ) {
            length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length], "[AZROLES] " );
        }

        //
        // Put the timestamp at the begining of the line.
        //
        {
            SYSTEMTIME SystemTime;
            GetLocalTime( &SystemTime );
            length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length],
                                  "%02u/%02u %02u:%02u:%02u ",
                                  SystemTime.wMonth,
                                  SystemTime.wDay,
                                  SystemTime.wHour,
                                  SystemTime.wMinute,
                                  SystemTime.wSecond );
        }
#endif // 0

        //
        // Indicate the type of message on the line
        //
        {
            char *Text;

            switch (DebugFlag) {
            case AZD_HANDLE:
                Text = "HANDLE"; break;
            case AZD_OBJLIST:
                Text = "OBJLIST"; break;
            case AZD_INVPARM:
                Text = "INVPARM"; break;
            case AZD_PERSIST:
            case AZD_PERSIST_MORE:
                Text = "PERSIST"; break;
            case AZD_REF:
                Text = "REF"; break;
            default:
                Text = "UNKNOWN"; break;

            case 0:
                Text = NULL;
            }
            if ( Text != NULL ) {
                length += (ULONG) sprintf( &AzGlLogFileOutputBuffer[length], "[%s] ", Text );
            }
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    lengthTmp = (ULONG) _vsnprintf( &AzGlLogFileOutputBuffer[length],
                                    MAX_PRINTF_LEN - length - 1,
                                    Format,
                                    arglist );

    if ( lengthTmp < 0 ) {
        length = MAX_PRINTF_LEN - 1;
        // always end the line which cannot fit into the buffer
        AzGlLogFileOutputBuffer[length-1] = '\n';
    } else {
        length += lengthTmp;
    }

    BeginningOfLine = (length > 0 && AzGlLogFileOutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {
        AzGlLogFileOutputBuffer[length-1] = '\r';
        AzGlLogFileOutputBuffer[length] = '\n';
        AzGlLogFileOutputBuffer[length+1] = '\0';
        length++;
    }


#if 0
    //
    // If the log file isn't open,
    //  just output to the debug terminal
    //

    if ( AzGlLogFile == INVALID_HANDLE_VALUE ) {
#if DBG
        if ( !LogProblemWarned ) {
            (void) DbgPrint( "[NETLOGON] Cannot write to log file [Invalid Handle]\n" );
            LogProblemWarned = TRUE;
        }
#endif // DBG

    //
    // Write the debug info to the log file.
    //

    } else {
        if ( !WriteFile( AzGlLogFile,
                         AzGlLogFileOutputBuffer,
                         length,
                         &BytesWritten,
                         NULL ) ) {
#if DBG
            if ( !LogProblemWarned ) {
                (void) DbgPrint( "[NETLOGON] Cannot write to log file %ld\n", GetLastError() );
                LogProblemWarned = TRUE;
            }
#endif // DBG
        }

    }
#else // 0
    printf( "%s", AzGlLogFileOutputBuffer );
#endif // 0

}

VOID
AzpPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

    //
    // vsprintf isn't multithreaded + we don't want to intermingle output
    // from different threads.
    //

    EnterCriticalSection( &AzGlLogFileCritSect );

    //
    // Simply change arguments to va_list form and call NlPrintRoutineV
    //

    va_start(arglist, Format);

    AzpPrintRoutineV( DebugFlag, Format, arglist );

    va_end(arglist);

    LeaveCriticalSection( &AzGlLogFileCritSect );

} // AzPrintRoutine
#endif // AZROLESDBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keycpl\res.h ===
#ifndef _RES_H_
#define _RES_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RES.H

Abstract:

    Resource symbols for keymgr application
     
Author:

    990518  dane    Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#define IDI_UPGRADE                          100

#define IDS_APP_NAME                         500
#define IDS_APP_DESCRIPTION                  504

// NEXT CONTROL VALUE 1091
// NEXT RESOURCE VALUE ?
// NEXT COMMAND VALUE ?
// NEXT SYMED VALUE ?

#endif  //  _RES_H_

//
///// End of file: Res.h   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keycpl\keymgr.h ===
#ifndef _KEYMGR_H_
#define _KEYMGR_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.H

Abstract:

    KeyMgr application public API definitions
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#endif  //  _KEYMGR_H_

//
///// End of file: KeyMgr.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keycpl\keymgr.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.CPP

Abstract:

    Keyring WinMain() and application support
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated
    georgema        000501  used to be EXE, changed to CPL

Comments:
    This executable is the control panel applet to allow a user some control 
    over the contents of the Windows Keyring, the so-called "Geek UI".  It was 
    originally an EXE, but that architecture is not as optimized for merging 
    with other control panel applets.  It has been changed to a CPL executable, 
    and can be either left as a CPL if it is desired that it should show up 
    automatically in the master control panel window, or rahter renamed to 
    a DLL file extension if it is desired that a control panel applet container
    application should load it explicitly without it otherwise being visible 
    to the system.

Environment:
    Win98, Win2000

Revision History:

--*/

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)


//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <cpl.h>
#include "Res.h"
#include "keymgr.h"

#undef GSHOW
//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//
static const char       _THIS_FILE_[ ] = __FILE__;
//static const WORD       _THIS_MODULE_ = LF_MODULE_UPGRADE;

//////////////////////////////////////////////////////////////////////////////
//
//  Global state info
//


HINSTANCE               g_hInstance = NULL;
HMODULE                 hDll = NULL;
LONG (*CPlFunc)(HWND,UINT,LPARAM,LPARAM);

__declspec(dllexport) LONG APIENTRY CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2)
{
    INT_PTR nResult;
    CPLINFO *lpCPlInfo;

    // Handle commands to this dll/cpl from the enclosing presentation app.
    // Default return from any command is 0 (success), except those commands
    //  which ask for specific data in the return value
    
    switch(uMsg) {
        case CPL_INIT:
            hDll = LoadLibrary(L"keymgr.dll");
            if (NULL == hDll) {
#ifdef GMSHOW
                MessageBox(NULL,L"Failed to load dll",NULL,MB_OK);
#endif
                return FALSE;
            }
            CPlFunc = (LONG (*)(HWND,UINT,LPARAM,LPARAM)) GetProcAddress(hDll,"CPlApplet");
            if (NULL == CPlFunc) {
#ifdef GMSHOW
                MessageBox(NULL,L"Failed to find dll export",NULL,MB_OK);
#endif
                return FALSE;
            }
            return CPlFunc(hwndCPl,uMsg,lParam1,lParam2);
            break;
            
        case CPL_GETCOUNT:
            return 1;       // only 1 applet icon in this cpl file
            break;

        case CPL_NEWINQUIRE:
            break;
            
        case CPL_INQUIRE:
            lpCPlInfo = (CPLINFO *) lParam2;  // acquire ptr to target data 
            lpCPlInfo->lData = 0;             // no effect
            lpCPlInfo->idIcon = IDI_UPGRADE;  // store items needed to show the applet
            lpCPlInfo->idName = IDS_APP_NAME;
            lpCPlInfo->idInfo = IDS_APP_DESCRIPTION; // description string
            break;
            
        case CPL_EXIT:
            FreeLibrary(hDll);
            break;
            
        // This will end up handling doubleclick and stop messages
        default:
#ifdef GMSHOW
                MessageBox(NULL,L"Call to linked dll",NULL,MB_OK);
#endif
            return CPlFunc(hwndCPl,uMsg,lParam1,lParam2);
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\apsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by keymgr.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1092
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\diskio.cpp ===
// Dependencies:  shellapi.h, shell32.lib for SHGetFileInfo()
//               windows.h, kernel32.lib for GetDiskFreeSpace()
//               io.h   for _waccess()

#include <windef.h>
#include <windows.h>
#include <string.h>
#include <io.h>
#include <stdio.h>
//#include <shellapi.h>
#include <shlwapi.h>
//#include <shlobjp.h>

#include "switches.h"
#include "wizres.h"

extern HINSTANCE g_hInstance;

#if !defined(SHFMT_OPT_FULL)
#if defined (__cplusplus)
extern "C" {
#endif
DWORD WINAPI SHFormatDrive(HWND,UINT,UINT,UINT);

#define SHFMT_ID_DEFAULT 0xffff
#define SHFMT_OPT_FULL 0x0001
#define SHFMT_OPT_SYSONLY 0x0002
#define SHFMT_ERROR 0xffffffffL
#define SHFMT_CANCEL 0xfffffffeL
#define SHFMT_NOFORMAT 0xffffffdL
#if defined (__cplusplus)
}
#endif
#endif
// Miscellaneous declarations not contain in header files
// These will be miscellaneous items found in other files within this project
int RMessageBox(HWND hw,UINT_PTR uiResIDTitle, UINT_PTR uiResIDText, UINT uiType);
extern HWND      c_hDlg;
extern WCHAR     pszFileName[];


INT     g_iFileSize = 0;
INT     g_iBufferSize = 0;
INT     g_iSectorSize = 0;
HANDLE  g_hFile = NULL;

BOOL GetFileSize(WCHAR *pszFilePath,INT *icbSize) 
{
    WIN32_FILE_ATTRIBUTE_DATA stWFAD = {0};
    if (NULL == pszFilePath) return FALSE;
    if (NULL == icbSize) return FALSE;
    if (!GetFileAttributesEx(pszFilePath,GetFileExInfoStandard,&stWFAD)) return FALSE;
#ifdef LOUDLY
#ifdef LOUDLY
    WCHAR rgc[100];
    swprintf(rgc,L"GetFileSize returns %d\n",stWFAD.nFileSizeLow);
    OutputDebugString(rgc);
#endif
#endif
    *icbSize = stWFAD.nFileSizeLow;
    return TRUE;
}

DWORD GetDriveFreeSpace(WCHAR *pszFilePath) 
{
    WCHAR *pwc;
    WCHAR rgcModel[]={L"A:"};

    DWORD dwSpc,dwBps,dwCfc,dwTcc,dwFree;
    if (NULL == pszFilePath) return 0;
    rgcModel[0] = *pszFilePath;
    if (!GetDiskFreeSpace(rgcModel,&dwSpc,&dwBps,&dwCfc,&dwTcc))
    {
#ifdef LOUDLY
        WCHAR rgwc[100];
        swprintf(rgwc,L"GetDriveFreeSpace encountered error %x\n",GetLastError());
        OutputDebugString(rgwc);
        OutputDebugString(L"GetDriveFreeSpace returning 0\n");
#endif
        return 0;
    }
    dwFree = dwBps * dwCfc * dwSpc;
#ifdef LOUDLY
    WCHAR rgc[100];
    swprintf(rgc,L"GetDriveFreeSpace returns %d\n",dwFree);
    OutputDebugString(rgc);
#endif
    return dwFree;
}


DWORD GetDriveSectorSize(WCHAR *pszFilePath) 
{
    WCHAR *pwc;
    WCHAR rgcModel[]={L"A:"};

    DWORD dwSpc,dwBps,dwCfc,dwTcc;
    if (NULL == pszFilePath) return 0;
    rgcModel[0] = *pszFilePath;
    if (!GetDiskFreeSpace(rgcModel,&dwSpc,&dwBps,&dwCfc,&dwTcc))
    {
#ifdef LOUDLY
        WCHAR rgwc[100];
        swprintf(rgwc,L"GetDriveSectorSize encountered error %x\n",GetLastError());
        OutputDebugString(rgwc);
        OutputDebugString(L"GetDriveSectorSize returning 0\n");
#endif
        return 0;
    }
#ifdef LOUDLY
    WCHAR rgc[100];
    swprintf(rgc,L"GetDriveSectorSize returns %d\n",dwBps);
    OutputDebugString(rgc);
#endif
    return dwBps;
}

// take data size, sector size, return ptr to finished buffer
LPVOID CreateFileBuffer(INT iDataSize,INT iSectorSize)
{
    INT iSize;
    LPVOID lpv;
    if (iDataSize == iSectorSize) iSize = iDataSize;
    else 
    {
        iSize = iDataSize/iSectorSize;
        iSize += 1;
        iSize *= iSectorSize;
    }
    g_iBufferSize = iSize;
    lpv = VirtualAlloc(NULL,iSize,MEM_COMMIT,PAGE_READWRITE | PAGE_NOCACHE);
#ifdef LOUDLY
    WCHAR rgc[100];
    if (lpv) OutputDebugString(L"CreateFileBuffer succeeded\n");
    else OutputDebugString(L"CreateFileBuffer failed ******\n");
    swprintf(rgc,L"File Buffer size is %d\n",g_iBufferSize);
    OutputDebugString(rgc);
#endif
    return lpv;
}

// take ptr to buffer, release using VirtualFree()
void ReleaseFileBuffer(LPVOID lpv)
{   
    ZeroMemory(lpv,g_iBufferSize);
    VirtualFree(lpv,0,MEM_RELEASE);
#ifdef LOUDLY
    OutputDebugString(L"ReleaseFileBuffer called\n");
#endif
    return;
}

/*
MediumIsPresent() returns true if there is a readable medium present in the drive.
*/
BOOL FileMediumIsPresent(TCHAR *pszPath) {
    UINT uMode = 0;                           
    BOOL bResult = FALSE;
    TCHAR rgcModel[]=TEXT("A:");
    DWORD dwError = 0;

    if (*pszPath == 0) return FALSE;
    rgcModel[0] = *pszPath;
    uMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    if (0 == _waccess(rgcModel,0)) {
        bResult = TRUE;
    }
    else dwError = GetLastError();
#ifdef LOUDLY
    WCHAR rgwc[100];
    swprintf(rgwc,L"_waccess returns error %x for %s\n",dwError,rgcModel);
    OutputDebugString(rgwc);
    if (!bResult) OutputDebugString(L"FileMediumIsPresent returning FALSE\n");
    else OutputDebugString(L"FileMediumIsPresent returning TRUE\n");
#endif

    // Correct certain obvious errors with the user's help
    if (ERROR_UNRECOGNIZED_MEDIA == dwError)
    {
        // unformatted disk
        WCHAR rgcFmt[200] = {0};
        WCHAR rgcMsg[200] = {0};
        WCHAR rgcTitle[200] = {0};

#ifdef LOUDLY
        OutputDebugString(L"FileMediumIsPresent found an unformatted medium\n");
#endif
        INT iCount = LoadString(g_hInstance,IDS_MBTFORMAT,rgcTitle,200 - 1);
        iCount = LoadString(g_hInstance,IDS_MBMFORMAT,rgcFmt,200 - 1);
        if (0 == iCount) goto LblNoBox;
        swprintf(rgcMsg,rgcFmt,rgcModel);
        INT iDrive = PathGetDriveNumber(rgcModel);
        int iRet =  MessageBox(c_hDlg,rgcMsg,rgcTitle,MB_YESNO);
        if (IDYES == iRet) 
        {
            dwError = SHFormatDrive(c_hDlg,iDrive,SHFMT_ID_DEFAULT,0);
            if (0 == bResult) bResult = TRUE;
        }
    }
LblNoBox:
    uMode = SetErrorMode(uMode);
    return bResult;
}

//
// On save, create file if 
// absent.  Return handle on success, NULL on fail.  FileName will be in
// c_rgcFileName.
//

HANDLE GetInputFile(void) {
    HANDLE       hFile = INVALID_HANDLE_VALUE;
    DWORD       dwErr;
    WIN32_FILE_ATTRIBUTE_DATA stAttributes = {0};

#ifdef LOUDLY
    OutputDebugString(L"GetInputFile() opening input file ");
    OutputDebugString(pszFileName);
    OutputDebugString(L"\n");
#endif
    if (FileMediumIsPresent(pszFileName)) {
        g_iSectorSize = GetDriveSectorSize(pszFileName);
        if (0 == g_iSectorSize) return NULL;
        
        if (GetFileAttributesEx(pszFileName,GetFileExInfoStandard,&stAttributes))
        {
            // file exists and we have a size for it.
            g_iFileSize = stAttributes.nFileSizeLow;
        }
        else 
        {
            dwErr = GetLastError();
            if (dwErr == ERROR_FILE_NOT_FOUND) 
                RMessageBox(c_hDlg,IDS_MBTWRONGDISK ,IDS_MBMWRONGDISK ,MB_ICONEXCLAMATION);
            else
            {
#ifdef LOUDLY
                {
                    WCHAR rgs[200] = {0};
                    swprintf(rgs,L"GetFileAttributesEx() failed, error = %x\n",dwErr);
                    OutputDebugString(rgs);
                }
#endif
                RMessageBox(c_hDlg,IDS_MBTDISKERROR ,IDS_MBMDISKERROR ,MB_ICONEXCLAMATION);
            }
            g_hFile = NULL;
            return NULL;
        } // end GetFileAttributes
        hFile = CreateFileW(pszFileName,
                            GENERIC_READ,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_NO_BUFFERING,
                            NULL);
        if (INVALID_HANDLE_VALUE == hFile) {
            dwErr = GetLastError();
            if (dwErr == ERROR_FILE_NOT_FOUND) 
                RMessageBox(c_hDlg,IDS_MBTWRONGDISK ,IDS_MBMWRONGDISK ,MB_ICONEXCLAMATION);
            else
                RMessageBox(c_hDlg,IDS_MBTDISKERROR ,IDS_MBMDISKERROR ,MB_ICONEXCLAMATION);
       }
    }
    else {
        RMessageBox(c_hDlg,IDS_MBTNODISK ,IDS_MBMNODISK ,MB_ICONEXCLAMATION);
    }
    if ((NULL == hFile) || (INVALID_HANDLE_VALUE == hFile)) {
        g_hFile = NULL;
        return NULL;
    }
    g_hFile = hFile;
    return hFile;
}

void CloseInputFile(void) 
{
#ifdef LOUDLY
    OutputDebugString(L"Input file closed\n");
#endif
    if (g_hFile) 
    {
        CloseHandle(g_hFile);
        g_hFile = NULL;
    }
    
    return;
}

HANDLE GetOutputFile(void) {
    //HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hFile = NULL;
    DWORD dwErr;
    
    if (FileMediumIsPresent(pszFileName)) {

        g_iSectorSize = GetDriveSectorSize(pszFileName);
        if (0 == g_iSectorSize) return NULL;
        
        hFile = CreateFileW(pszFileName,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_FLAG_NO_BUFFERING,
                            NULL);
        if ((NULL == hFile) || (INVALID_HANDLE_VALUE == hFile)) {
            dwErr = GetLastError();
#ifdef LOUDLY
                TCHAR rgct[500];
                swprintf(rgct,L"File create returns %x\n",dwErr);
                OutputDebugString(rgct);
#endif
            if ((dwErr == ERROR_FILE_EXISTS)) {
                if (IDYES != RMessageBox(c_hDlg,IDS_MBTOVERWRITE ,IDS_MBMOVERWRITE ,MB_YESNO)) {
                    // Overwrite abandoned.
                    g_hFile = NULL;
                    return NULL;
                }
                else {
                    SetFileAttributes(pszFileName,FILE_ATTRIBUTE_NORMAL);
                    hFile = CreateFileW(pszFileName,
                                        GENERIC_WRITE,
                                        0,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_FLAG_NO_BUFFERING,
                                        NULL);
#ifdef LOUDLY
                    dwErr = GetLastError();
                    swprintf(rgct,L"File create failed %x\n",dwErr);
                    OutputDebugString(rgct);
#endif
                }
            } // end if already exists error
        } // end if NULL == hFile
    }
    else {
        RMessageBox(c_hDlg,IDS_MBTNODISK ,IDS_MBMNODISK ,MB_ICONEXCLAMATION);
    }
    if (INVALID_HANDLE_VALUE == hFile) {
        g_hFile = NULL;
        return NULL;
    }
#ifdef LOUDLY
    OutputDebugString(L"File successfully created\n");
#endif
    g_hFile = hFile;
    return hFile;
}

/*
DWORD ReadPrivateData(PWSTR,LPBYTE *,INT *)
DWORD WritePrivateData(PWSTR,LPBYTE,INT)

These functions read or write a reasonably short block of data to a disk
device, avoiding buffering of the data.  This allows the data to be wiped 
by the client before the buffers are released.

The DWORD return value is that which would return from GetLastError() and
can be handled accordingly.

ReadPrivateData() returns a malloc'd pointer which must be freed by the client.  It
also returns the count of bytes read from the medium to the INT *.  The file is
closed following the read operation before the function returns.

WritePrivateData() writes a count of bytes from LPBYTE to the disk.  When it returns,
the buffer used to do so has been flushed and the file is closed.
*/

/*
    prgb = byte ptr to data returned from the read
    piCount = size of active data field within the buffer

    Note that even if the read fails (file not found, read error, etc.) the buffer
    ptr is still valid.
*/
//ReadFile(c_hFile,c_pPrivate,c_cbPrivate,&c_cbPrivate,NULL) return bytes read
INT ReadPrivateData(BYTE **prgb,INT *piCount)
{
    LPVOID lpv;
    DWORD dwBytesRead;

    if (NULL == prgb) return 0;
    if (NULL == piCount) return 0;
    
    if (g_hFile)
    {
        lpv = CreateFileBuffer(g_iFileSize,g_iSectorSize);
        if (NULL == lpv) 
        {
            *prgb = 0;      // indicate no need to free this buffer
            *piCount = 0;
            return 0;
        }
        *prgb = (BYTE *)lpv;        // even if no data, gotta free using VirtualFree()
        *piCount = 0;
        if (0 == ReadFile(g_hFile,lpv,g_iBufferSize,&dwBytesRead,NULL)) return 0;
        *piCount = g_iFileSize;
#ifdef LOUDLY
    OutputDebugString(L"ReadPrivateData success\n");
#endif
        return g_iFileSize;
    }
    return 0;
}

/*
    Write data to file at g_rgwczFileName
    Convert size to multiple of sector size
    Alloc buffer
    Copy data to buffer
    Write data
    Scrub Buffer, release
    return 0
*/
BOOL WritePrivateData(BYTE *lpData,INT icbData) {
    DWORD dwcb = 0;
    LPVOID lpv;
    if (NULL == g_hFile) return FALSE;
    if (NULL == lpData) return FALSE;
    if (0 == icbData) return FALSE;

    if (g_hFile)
    {
        g_iFileSize = icbData;
        lpv = CreateFileBuffer(g_iFileSize,g_iSectorSize);
        if (NULL == lpv) 
        {
            return FALSE;
        }
        ZeroMemory(lpv,g_iBufferSize);
        memcpy(lpv,lpData,icbData);
        WriteFile(g_hFile,lpv,g_iBufferSize,&dwcb,NULL);
        VirtualFree(lpv,g_iBufferSize,MEM_RELEASE);
    }
    // ret TRUE iff file write succeeds and count of bytes is correct
#ifdef LOUDLY
    if (dwcb) OutputDebugString(L"WritePrivateData succeeded\n");
    else OutputDebugString(L"WritePrivateData failed ***\n");
#endif
    if (dwcb != g_iBufferSize) return FALSE;
    else return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\gmdebug.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gmdebug.cpp

Abstract:

    Debug support routines - show simple data in message box using
    simple macros when GMDEBUG is defined.

Author:

    georgema        000310  created

Environment:

Revision History:

--*/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>

ULONG DbgPrint(PCH Fmt,...);


TCHAR Bug[256];

void ShowBugString(const TCHAR *pC) {
    if (NULL == pC) {
        _stprintf(Bug,_T("NULL ptr"));
    }
    else {
        _stprintf(Bug,_T("%s"),pC);
    }
    MessageBox(NULL,Bug,_T("Bug"),MB_OK);
}
void ShowBugDecimal(INT i) {
    _stprintf(Bug,_T("Decimal: %d"),i);
    MessageBox(NULL,Bug,_T("Bug"),MB_OK);
}
void ShowBugHex(DWORD dwIn) {
    _stprintf(Bug,_T("Hex: %X"),dwIn);
    MessageBox(NULL,Bug,_T("Bug"),MB_OK);
}

void OutBug(TCHAR *pc,DWORD dwin) {
    _stprintf(Bug,pc,dwin);
    OutputDebugString(Bug);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\dlg.cpp ===
/*+

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DLG.CPP

Abstract:

    C_Dlg implementation
     
Author:

    990518  dane    Created. 
    990721  dane    Added _THIS_MODULE_ for logging macros.
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include "Dlg.h"



//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//
static const char       _THIS_FILE_[ ] = __FILE__;


//////////////////////////////////////////////////////////////////////////////
//
//  Static member initialization
//
LPCTSTR          C_Dlg::SZ_HWND_PROP = _T("hwnd");

//////////////////////////////////////////////////////////////////////////////
//
//  C_Dlg
//
//  Constructor.
//
//  parameters:
//      hwndParent      parent window for the dialog (may be NULL)
//      hInstance       instance handle of the parent window (may be NULL)
//      lIDD            dialog template id
//      pfnDlgProc      pointer to the function that will process messages for
//                      the dialog.  if it is NULL, the default dialog proc
//                      will be used.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_Dlg::C_Dlg(
    HWND                hwndParent,
    HINSTANCE           hInstance,
    LONG                lIDD,
    DLGPROC             pfnDlgProc     // = NULL
    )
:   m_hwndParent(hwndParent),
    m_hInstance(hInstance),
    m_lIDD(lIDD),
    m_pfnDlgProc(pfnDlgProc),
    m_hwnd(NULL)
{

    ASSERT(NULL != SZ_HWND_PROP);
    if (NULL == m_pfnDlgProc)
    {
        // Use the default dialog proc
        //
        m_pfnDlgProc = (DLGPROC) C_Dlg::DlgProc;
    }
}   //  C_Dlg::C_Dlg



//////////////////////////////////////////////////////////////////////////////
//
//  ~C_Dlg
//
//  Destructor.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_Dlg::~C_Dlg( )
{
    OnShutdown();
}   //  C_Dlg::~C_Dlg


void C_Dlg::CenterWindow() {
    RECT rectWorkArea;
    RECT  rectWindow;
    DWORD FreeWidth, Width, FreeHeight, Height;

    if (! SystemParametersInfo(SPI_GETWORKAREA, 0, &rectWorkArea, 0))
    {
        return;
    }

    GetWindowRect(m_hwnd, &rectWindow);

    Height = (rectWorkArea.bottom - rectWorkArea.top);

    Width  = (rectWorkArea.right - rectWorkArea.left);

    FreeHeight  = Height - 
                 (rectWindow.bottom   - rectWindow.top);

    FreeWidth = Width - 
                 (rectWindow.right    - rectWindow.left);

    DWORD  dxOffset = FreeWidth / 2;
    DWORD  dyOffset = FreeHeight / 2;

    MoveWindow(m_hwnd, 
               dxOffset,
               dyOffset, 
               (rectWindow.right - rectWindow.left), (rectWindow.bottom - rectWindow.top), 
               TRUE
               );

    return;
}
//////////////////////////////////////////////////////////////////////////////
//
//  DoModal
//
//  Display the dialog box modally and wait for it to be closed.
//
//  parameters:
//      lparam          user-defined data that will be passed to the dialog
//                      proc as the lparam of the WM_INITDIALOG message.
//
//  returns:
//      User-defined result code returned by EndDialog( ).
//
//////////////////////////////////////////////////////////////////////////////
INT_PTR 
C_Dlg::DoModal(
    LPARAM              lparam      // = NULL
    )
{

    INT_PTR                 nResult = DialogBoxParam(m_hInstance, 
                                                 MAKEINTRESOURCE(m_lIDD), 
                                                 m_hwndParent, 
                                                 m_pfnDlgProc,
                                                 lparam
                                                 );
    if (-1 == nResult)
    {
        DWORD           dwErr = GetLastError( );
    }

    return nResult;

}   //  C_Dlg::DoModal




//////////////////////////////////////////////////////////////////////////////
//
//  DlgProc
//
//  Window procedure for wizard pages.  All messages are routed here, then
//  dispatched to the appropriate C_Dlg object.
//
//  parameters:
//      hwndDlg        window handle of the page for which the message is
//                      intended
//      uMessage        the message
//      wparam          message-specific data
//      lparam          message-specific data
//
//  returns:
//      TRUE            if the message was processed
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
 
BOOL  CALLBACK
C_Dlg::DlgProc(
    HWND                hwndDlg,
    UINT                uMessage,
    WPARAM              wparam,
    LPARAM              lparam
    )
{

    CHECK_MESSAGE(hwndDlg, uMessage, wparam, lparam);

    // Get the pointer to the C_Dlg object corresponding to the hwndDlg
    //
    C_Dlg*          pDlg = NULL;

    if (WM_INITDIALOG == uMessage)
    {
        // For WM_INITDIALOG, the pointer to the dialog object will be in
        // the lparam.
        //
        pDlg = (C_Dlg*) lparam;
    }
    else
    {
        // For all other messages, it will be attached to the HWND
        //
        HRESULT             hr = C_Dlg::DlgFromHwnd(hwndDlg, &pDlg);
        if (FAILED(hr))
        {
            return FALSE;
        }
        ASSERT(NULL != pDlg);
    }

    // Let the page route application-specific messages
    //
    if (WM_APP <= uMessage)
    {
        return pDlg->OnAppMessage(uMessage, wparam, lparam);
    }

    // Route Windows messages to appropriate handler
    //
    switch (uMessage)
    {
    case WM_INITDIALOG:
        return pDlg->OnInitDialog(hwndDlg,
                                  (HWND)wparam
                                  );
    case WM_HELP:
        return pDlg->OnHelpInfo(lparam);
        
    case WM_CONTEXTMENU:
        return pDlg->OnContextMenu(wparam,lparam);
        
    case WM_COMMAND:
        return pDlg->OnCommand(HIWORD(wparam), LOWORD(wparam), (HWND)lparam);
        
    case WM_NOTIFY:
        return RouteNotificationMessage(pDlg, (NMHDR*)lparam);
        break;

    case WM_DESTROY:
        return pDlg->OnDestroyDialog();
        break;
        
    default:
        // Message was not processed
        //
        return FALSE;
    }   //  switch (uMessage)

}   //  C_Dlg::DlgProc



//////////////////////////////////////////////////////////////////////////////
//
//  RouteNotificationMessage
//
//  Routes notification messages from wizard buttons to the appropriate page
//  and handler.
//
//  parameters:
//      hwndDlg        window handle of page to which message is to be sent
//      pnmhdr          pointer to the NMHDR structure containing info about
//                      the particular notification
//
//  returns:
//      TRUE            if the message is processed
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_Dlg::RouteNotificationMessage(
    C_Dlg*          pDlg,
    NMHDR*              pnmhdr
    )
{

    if (NULL == pDlg)
    {
        //FIX220699
        return FALSE;
        //return E_INVALIDARG;
    }

    // If any specific notifications are to be handled, switch on pnmhdr->code.
    //
    return pDlg->OnNotify(pnmhdr);

}   //  C_Dlg::RouteNotificationMessage


//////////////////////////////////////////////////////////////////////////////
//
//  LinkHwnd
//
//  Store the pointer to this object in a window handle property.  This
//  provides a way to get to the object when all that is known is the HWND.
//  Particularly useful in window procedures.
//
//  parameters:
//      None.
//
//  returns:
//      TRUE            if the operation is successful
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_Dlg::LinkHwnd( )
{

    ASSERT(IsWindow(m_hwnd));
    if (! IsWindow(m_hwnd))
    {
        return FALSE;
    }

    return SetProp(m_hwnd, SZ_HWND_PROP, (HANDLE)this);

}   //  C_Dlg::LinkHwnd

//////////////////////////////////////////////////////////////////////////////
//
//  UnlinkHwnd
//
//  Remove the pointer to the associated object from a window handle.  The
//  pointer must have been set with LinkHwnd( ).
//
//  parameters:
//      None.
//
//  returns:
//      TRUE            if the window handle is removed and it is a pointer to
//                      this object
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_Dlg::UnlinkHwnd( )
{

    ASSERT(IsWindow(m_hwnd));
    if (! IsWindow(m_hwnd))
    {
        return FALSE;
    }

    C_Dlg*          pDlg = (C_Dlg*)RemoveProp(m_hwnd, SZ_HWND_PROP);

    ASSERT(this == pDlg);
    return (this == pDlg);

}   //  C_Dlg::UnlinkHwnd

//////////////////////////////////////////////////////////////////////////////
//
//  DlgFromHwnd
//
//  Retrieves the pointer to the associated object from a window handle.  The
//  pointer was stored in a property by LinkHwnd( ).
//
//  parameters:
//      hwnd            the window handle containing the pointer
//      ppDlg           pointer to a buffer that will receive the pointer to
//                      the C_Dlg object
//
//  returns:
//      S_OK            if the operation is successful
//      E_INVALIDARG    if hwnd is not a valid window or ppDlg is NULL
//      E_POINTER       if the retrieved pointer is NULL
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
C_Dlg::DlgFromHwnd(
    HWND                hwnd,
    C_Dlg**         ppDlg
    )
{

    if (! ::IsWindow(hwnd))
    {
             return (E_INVALIDARG);
    }

    ASSERT(NULL != ppDlg);
    if (NULL == ppDlg)
    {
        return (E_INVALIDARG);
    }

    *ppDlg = (C_Dlg*) GetProp(hwnd, SZ_HWND_PROP);

    if (NULL == *ppDlg)
    {
        return (E_POINTER);
    }

    return (S_OK);

}   //  C_Dlg::DlgFromHwnd

//
///// End of file: Dlg.cpp   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\dlg.h ===
#ifndef _DLG_H_
#define _DLG_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    DLG.CPP

Abstract:

    C_Dlg implementation
     
Author:

    990518  dane    Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#include <windows.h>
#include <commctrl.h>
#include <tchar.h>
#include "macros.h"
#include <shfusion.h>

//////////////////////////////////////////////////////////////////////////////
//
// C_Dlg
//
// Base dialog class: handles default message routing and processing.
//
class C_Dlg 
{
public:                 // operations
    C_Dlg(
        HWND                hwndParent,
        HINSTANCE           hInstance,
        LONG                lIDD,
        DLGPROC             pfnDlgProc = NULL
        );

    ~C_Dlg( );

    virtual INT_PTR
    DoModal(
        LPARAM              lparam = NULL
        );

    BOOL
    EndDialog(
        INT                 nResult = 0
        )
    {
        ASSERT(NULL != m_hwnd);
        return ::EndDialog(m_hwnd, nResult);
    }   //  EndDialog

    // Link the object to the window handle
    //
    virtual BOOL
    OnInitDialog(
        HWND                hwndDlg,
        HWND                hwndFocus
        )
    {
        // Save the page's window handle & link the window handle to the page
        // object.
        //
        m_hwnd = hwndDlg;
        LinkHwnd( );

        // Let the system set the default keyboard focus.
        //
        return TRUE;
    }   //  

    virtual BOOL
    OnDestroyDialog(void)
    {
        return TRUE;
    }

    virtual BOOL
    OnCommand(
        WORD                wNotifyCode,
        WORD                wId,
        HWND                hwndSender
        )
    {
        // Message was not processed
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnHelpInfo(
        LPARAM             lParam
        )
    {
        // Message was not processed
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnContextMenu(
        WPARAM             wParam,
        LPARAM             lParam
        )
    {
        // Message was not processed
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnQueryCancel( )
    {
        // The message was not processed.
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnHelp( )
    {
        // User has clicked the Help button.
        // TODO: Display help

        // The message was not processed.
        //
        return FALSE;
    }   //  

    virtual BOOL
    OnNotify(
        LPNMHDR             pnmh
        )
    {
        // Message was not processed.
        //
        return FALSE;
    }   //  

    virtual void
    CenterWindow();

    virtual void
    OnShutdown() {
        return;
    }
    
#if 0
    // Notification message return their results via the DWL_MSGRESULT window
    // long.  This wrapper keeps me from having to remember that.
    //
    virtual LONG
    SetNotificationMessageResult(
        LONG                lResult
        )
    {
        return SetWindowLong(m_hwnd, DWL_MSGRESULT, lResult);
    }   //  SetNotificationMessageResult
#endif

    // Process application-specific messages (WM_APP + n)
    //
    virtual BOOL
    OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam
        )
    {
        // Message was not processed.
        //
        return FALSE;
    }   //  OnAppMessage

    static HRESULT
    DlgFromHwnd(
        HWND            hwnd,
        C_Dlg**      ppDlg
        );

    const HWND
    Hwnd( ) const
    {
        return m_hwnd;
    }   //  Hwnd

    virtual void
    AssertValid( ) const
    {
        ASSERT(NULL != m_hwnd);
    }   //  AssertValid
protected:              // operations

    static LPCTSTR          SZ_HWND_PROP;

    BOOL
    LinkHwnd( );

    BOOL
    UnlinkHwnd( );

    static BOOL CALLBACK
    DlgProc(
        HWND            hwndDlg,
        UINT            uMessage,
        WPARAM          wparam,
        LPARAM          lparam
        );

    static BOOL
    RouteNotificationMessage(
        C_Dlg*      pDlg,
        NMHDR*          pnmhdr
        );

protected:              // data
    // Window handle of the dialog's parent window (may be NULL)
    //
    HWND                m_hwndParent;

    // Window handle of the dialog (may NOT be NULL)
    //
    HWND                m_hwnd;

    // Instance handle of the application displaying this dialog (may be NULL)
    //
    HINSTANCE           m_hInstance;

    //  Identifier for the dialog template associated with this object
    //
    LONG                m_lIDD;

    // Procedure that processes message sent to this dialog
    //
    DLGPROC             m_pfnDlgProc;

private:                // operations

    // Explicitly disallow copy constructor and assignment operator.
    //
    C_Dlg(
        const C_Dlg&      rhs
        );

    C_Dlg&
    operator=(
        const C_Dlg&      rhs
        );

private:                // data

};  //  C_Dlg


#endif  //  _DLG_H_

//
///// End of file: DLG.h   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\gmdebug.h ===
#ifndef _GMDEBUG_H_
#define _GMDEBUG_H_
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    gmdebug.h

Abstract:

    A few functions and macros for simple standalone debugging support
  
Author:

    georgema        000310  created

Environment:
    Win98, Win2000

Revision History:

--*/

#include <tchar.h>

#ifdef GMDEBUG
void ShowBugString(const TCHAR *pC);
void ShowBugDecimal(INT i);
void ShowBugHex(DWORD dwIn);
void OutBug(TCHAR *pc,DWORD dwin);
#endif
#ifdef GMDEBUG
#define BUGSTRING(x) ShowBugString(x)
#define BUGDECIMAL(x) ShowBugDecimal(x)
#define BUGHEX(x) ShowBugHex(x)
#define BUGOUT(c,x) OutBug(c,x)
#else
#define BUGSTRING(x)
#define BUGDECIMAL(x)
#define BUGHEX(x)
#define BUGOUT(c,x)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\keymgr.h ===
#ifndef _KEYMGR_H_
#define _KEYMGR_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.H

Abstract:

    KeyMgr application public API definitions
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/
#ifdef __cplusplus
extern "C" {
#endif
BOOL WINAPI DllMain(HINSTANCE,DWORD,LPVOID);
LONG WINAPI CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2);
void APIENTRY KRShowKeyMgr(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveWizardExW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowSaveFromMsginaW(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
void APIENTRY PRShowRestoreFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow);
#ifdef __cplusplus
}
#endif
#endif  //  _KEYMGR_H_

//
///// End of file: KeyMgr.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\macros.h ===
#ifndef _MACROS_H_
#define _MACROS_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    MACROS.H

Abstract:

    Project agnostic utility macros
     
Author:

    990518  dane    Created. 
    990721  dane    Removed ASSERTs from ROE_*.  A failure does not
                    necessarily an ASSERT need.
    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#include <crtdbg.h>

#if _MSC_VER > 1000

// make the beginning and end of a namespace stand out
//
#define BEGIN_NAMESPACE(name)   namespace name {
#define END_NAMESPACE(name)     };
#define USING_NAMESPACE(name)   using namespace name
#else
#define BEGIN_NAMESPACE(name)   
#define END_NAMESPACE(name)     
#define USING_NAMESPACE(name)  
#endif  //  _MSC_VER > 1000


// Heap allocation...use CRT debug new when _DEBUG is defined
//
#ifdef      _DEBUG
#define _NEW     new(_CLIENT_BLOCK, _THIS_FILE_, __LINE__)
#else   //  ! _DEBUG
#define _NEW     new
#endif  //  _DEBUG

#define _DELETE      delete

// aliases for assertion macros
//
#ifdef      ASSERT
#undef  ASSERT
#endif  //  ASSERT

#ifdef      VERIFY
#undef  VERIFY
#endif  //  VERIFY

#ifdef      _DEBUG
#define ASSERT(cond)      _ASSERTE(cond)
#define VERIFY(cond)      _ASSERTE(cond)
#else   //  NDEBUG
#define ASSERT(cond)      ((void)0)
#define VERIFY(cond)      (cond)
#endif  //  _DEBUG

// aliases for segment names
//
#ifdef      DATASEG_READONLY
#undef  DATASEG_READONLY
#endif  //  DATASEG_READONLY
#define DATASEG_READONLY        ".rdata"

//////////////////////////////////////////////////////////////////////////////
//
// RETURN ON ERROR macros
//
// ROE_HRESULT
// ROE_LRESULT
// ROE_POINTER
//
// Checks a return code or condition and returns a user-supplied error code if
// an error has occurred.
//
// Usage:
//      TYPE Foo( )
//      {
//          TYPE    status = Bar( );
//          ROE_TYPE(status, ret);
//          
//          // continue processing...
//      }
//
//
#define ROE_HRESULT(hr, ret)                                    \
            if (FAILED(hr))                                     \
            {                                                   \
                LogError(0, _THIS_FILE_, __LINE__,                 \
                         _T("0x%08X 0x%08X\n"), \
                         hr, ret);                              \
                return (ret);                                   \
            }

#define ROE_LRESULT(lr, ret)                                    \
            if (ERROR_SUCCESS != lr)                            \
            {                                                   \
                LogError(0, _THIS_FILE_, __LINE__,                 \
                         _T("0x%08X 0x%08X\n"),  \
                         lr, ret);                              \
                return (ret);                                   \
            }

#define ROE_POINTER(p, ret)                                     \
            if (NULL == (p))                                    \
            {                                                   \
                LogError(0, _THIS_FILE_, __LINE__,                 \
                         _T("0x%08X\n"),    \
                         ret);                                  \
                return (ret);                                   \
            }

#define ROE_CONDITION(cond, ret)                                \
            if (! (cond))                                       \
            {                                                   \
                LogError(0, _THIS_FILE_, __LINE__,                 \
                         _T("0x%08X 0x%08X\n"),  \
                         ##cond, ret);                          \
                return (ret);                                   \
            }

//////////////////////////////////////////////////////////////////////////////
//
// CHECK macros
//
// CHECK_HRESULT
// CHECK_LRESULT
// CHECK_POINTER
// CHECK_MESSAGE
//
// Checks a return code or condition and returns a user-supplied error code if
// an error has occurred.
//
// Usage:
//      TYPE Foo( )
//      {
//          TYPE    status = Bar( );
//          CHECK_TYPE(status);
//          
//          // continue processing...
//      }
//
//
#define CHECK_HRESULT(hr)                                       \
            (FAILED(hr))                                        \
                ? LogError(0, _THIS_FILE_, __LINE__, _T("0x%08X"), hr), hr \
                : hr

#define CHECK_LRESULT(lr)                                       \
            (ERROR_SUCCESS != lr)                               \
                ? LogError(0, _THIS_FILE_, __LINE__, _T("0x%08X"), lr), lr \
                : lr

#define CHECK_POINTER(p)                                        \
            (NULL == (p))                                       \
                ? LogError(0, _THIS_FILE_, __LINE__, _T("NULL pointer"), p), p \
                : p

#ifdef      _DEBUG
#define CHECK_MESSAGE(hwnd, msg, wparam, lparam)                \
            {                                                   \
                LogInfo(0, _THIS_FILE_, __LINE__,                  \
                        _T("MESSAGE: 0x%08X, 0x%08X, 0x%08X, 0x%08X\n"), \
                         hwnd, msg, wparam, lparam);            \
            }                                                   
#else
#define CHECK_MESSAGE(hwnd, msg, wparam, lparam) ((void)0)
#endif  //  _DEBUG


// count of elements in an array
//
#define COUNTOF(array)  (sizeof(array) / sizeof(array[0]))

#endif  //  _MACROS_H_

//
///// End of file: Macros.h   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\krdlg.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KRDLG.CPP

Abstract:

    Implementation of the dialog behaviors for three application dialogs:
    the add/edit credential dialog, the delete credential dialog, and
    the password change dialog.  These dialogs are derived fom C_Dlg

    Password change operates only on credentials of the form 
    domain\username.  Note that changing a password for such a credential
    will change the psw for all creds with the same domain\username to 
    match (this is done by the credential mgr).

    Add and Edit use the same dialog, differing in implementation on
    the basis of a flag which initializes the two dialogs differently
    and causes the edit case to also delete the underlying previous 
    version of the credential.
  
Author:

    johnhaw         991118  original version created
    georgema        000310  modified, removed "gizmo" services, modified
                             to use the new credential mgr
    georgema        000415  modified, use comboboxex to hold icon as well
                             as user name
    georgema        000515  modified to CPL from EXE, smartcard support 
                             added
    georgema        000712  modified to use cred control in lieu of combo
                             and edit boxes for username/password entry.
                             Delegating smartcard handling to cred ctrl.
Environment:
    Win2000

--*/

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)

// test/dev switch variables
#include "switches.h"
#define COOLTIPS
#define ODDUIBUG
#define EDITOFFERPASSWORD

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <stdlib.h>
#include <crtdbg.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>
#include <ntlsa.h>
#include <windows.h>
#include <winbase.h>
#include <dsgetdc.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <windns.h>
#include <shellapi.h>
#include "Dlg.h"
#include "Res.h"
#include "KRDlg.h"
#include "keymgr.h"
// wrapper for certificates in "mystore"

#include <tchar.h>
#include <wincrui.h>
#include "wincred.h"
#include "gmdebug.h"

#include <htmlhelp.h>
#include <credp.h>
#include <comctrlp.h>
#include <shfusion.h>

// in pswchg.cpp:
NET_API_STATUS NetUserChangePasswordEy(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);

// estimate of maximum size of target suffixes, possibly localized
#define MAXSUFFIXSIZE (64)

// TCHAR length of a whitespace
#define LENGTHOFWHITESPACE (1)

#ifndef CRED_SESSION_WILDCARD_NAME
#define CRED_SESSION_WILDCARD_NAME CRED_SESSION_WILDCARD_NAME_W
#endif

#define CRED_TYPE_UNKNOWN 0x88

// hack: special data value for RAS cred
#define SESSION_FLAG_VALUE (0x2222)  

BOOL    fNew;                       // interlock to prevent multiple dlgs

extern HINSTANCE g_hInstance;
extern C_KeyringDlg *pDlg;
LONG_PTR g_CurrentKey;              // currently selected item in the main dlg
BOOL    g_fPswChanged;              // password window touched by user
DWORD   g_dwHCookie;                // HTML HELP system cookie


// Globals used for interwindow communication between the main dialog 
// and the add/new dialog

HWND    g_hMainDlg;                 // used to give add/new access to target list
C_AddKeyDlg *g_AKdlg;               // used for notifications

CREDENTIAL *g_pExistingCred;        // current cred under edit
DWORD   g_dwPersist;
DWORD   g_dwType;
TCHAR   g_szTargetName[CRED_MAX_GENERIC_TARGET_NAME_LENGTH + MAXSUFFIXSIZE + 1];
#ifdef SHOWPASSPORT
TCHAR   g_rgcPassport[MAXSUFFIXSIZE];
#endif
//TCHAR   g_rgcGeneric[MAXSUFFIXSIZE];  // Hold suffix read in from resources
//TCHAR   rgcDomain[MAXSUFFIXSIZE];   // Hold suffix read in from resources
TCHAR   g_rgcCert[MAXSUFFIXSIZE];     // Hold suffix read in from resources

#ifndef GMDEBUG

#define GM_DEBUG(a) 

#else

#define GM_DEBUG(a,b) _DebugPrint(a,b)

void
__cdecl
_DebugPrint(
    LPCTSTR szFormat,
    ...
    )
{
    TCHAR szBuffer[1024];
    va_list ap;

    va_start(ap, szFormat);
    _vstprintf(szBuffer, szFormat, ap);
    OutputDebugString(szBuffer); 
}

void
BugBox(INT n,INT_PTR i) {
    TCHAR rgc[512];
    _stprintf(rgc,L"Hex %d : %08.8x",n,i);
    MessageBox(NULL,rgc,NULL,MB_OK);
}

#endif

DWORD GetPersistenceOptions(void);


//////////////////////////////////////////////////////////////////////////////
//
// KRShowKeyMgr() - static function to present the main keymgr dialog.
//
//
//////////////////////////////////////////////////////////////////////////////

#define KEYMGRMUTEX (TEXT("KeyMgrMutex"))

// Create and show the keyring main dialog.  Return -1 (unable to create)
// on errors.  If creation goes OK, return the retval from DoModal of
// the keyring dialog class.
//
BOOL WINAPI DllMain(HINSTANCE hinstDll,DWORD fdwReason,LPVOID lpvReserved) {
    BOOL bSuccess = TRUE;
    switch(fdwReason) {
        case DLL_PROCESS_ATTACH:
            SHFusionInitializeFromModuleID(hinstDll,123);
            DisableThreadLibraryCalls(hinstDll);
            g_hInstance = hinstDll;
            break;
        case DLL_PROCESS_DETACH:
            SHFusionUninitialize();
            break;
    }
    return bSuccess;
}

void WINAPI KRShowKeyMgr(HWND hwParent,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow) {
    HANDLE hMutex = CreateMutex(NULL,TRUE,KEYMGRMUTEX);
    if (NULL == hMutex) return;
    if (ERROR_ALREADY_EXISTS == GetLastError()) {
        CloseHandle(hMutex);
        return;
    }
    INITCOMMONCONTROLSEX stICC;
    BOOL fICC;
    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC = ICC_WIN95_CLASSES | ICC_STANDARD_CLASSES;
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
{
    WCHAR wc[500];
    if (fICC) OutputDebugString(L"Common control init OK\n");
    else 
    {
        DWORD dwe = GetLastError();
        OutputDebugString(L"Common control init FAILED\n");
        swprintf(wc,L"CCInit error = %x\n",dwe);
        OutputDebugString(wc);
    }
}
#endif
    if (NULL != pDlg) return;
    if (!CredUIInitControls()) return;
    pDlg = new C_KeyringDlg(hwParent,g_hInstance,IDD_KEYRING,NULL);
    if (NULL == pDlg) return;
    INT_PTR nResult = pDlg->DoModal((LPARAM) pDlg);
    delete pDlg;
    pDlg = NULL;
    CloseHandle(hMutex);
    return;
}

//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//
static const char       _THIS_FILE_[ ] = __FILE__;

//////////////////////////////////////////////////////////////////////////////
//
//  Help String Maps - Used only for handling WM_CONTEXTMENU, if context help
//                     is to appear on right-click
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
//  Help RESID -> STRINGID map functions
//
//           Probably more concise than writing the code to process an
//           association array
//
//////////////////////////////////////////////////////////////////////////////


UINT C_KeyringDlg::MapID(UINT uiID) {
    switch(uiID) {
        case IDC_KEYLIST:
          return IDH_KEYLIST;
        case IDC_NEWKEY:
          return IDH_NEW;
        case IDC_DELETEKEY:
          return IDH_DELETE;
        case IDC_CHANGE_PASSWORD:
          return IDH_CHANGEPASSWORD;
        case IDC_EDITKEY:
          return IDH_EDIT;
        case IDOK:
        case IDCANCEL:
            return IDH_CLOSE;
        
        default:
          return IDS_NOHELP;
    }
}

UINT C_AddKeyDlg::MapID(UINT uiID) {
   switch(uiID) {
        case 1003:
          return IDH_CUIUSER;
        case 1005:
          return IDH_CUIPSW;
        case 1010:
          return IDH_CUIVIEW;
        case IDOK:
            return IDH_CLOSE;
        case IDCANCEL:
          return IDH_DCANCEL;
        case IDD_ADDCRED:
          return IDH_ADDCRED;
        case IDC_TARGET_NAME:
          return IDH_TARGETNAME;
        case IDC_OLD_PASSWORD:
          return IDH_OLDPASSWORD;
        case IDC_NEW_PASSWORD:
          return IDH_NEWPASSWORD;
        case IDC_CONFIRM_PASSWORD:
          return IDH_CONFIRM;
        case IDD_KEYRING:
          return IDH_KEYRING;
        case IDC_KEYLIST:
          return IDH_KEYLIST;
        case IDC_NEWKEY:
          return IDH_NEW;
        case IDC_EDITKEY:
          return IDH_EDIT;
        case IDC_DELETEKEY:
          return IDH_DELETE;
        case IDC_CHANGE_PASSWORD:
          return IDH_CHANGEPASSWORD;
        default:
          return IDS_NOHELP;
   }
}

//////////////////////////////////////////////////////////////////////////////
//
//  C_AddKeyDlg
//
//  Constructor.
//
//  parameters:
//      hwndParent      parent window for the dialog (may be NULL)
//      hInstance       instance handle of the parent window (may be NULL)
//      lIDD            dialog template id
//      pfnDlgProc      pointer to the function that will process messages for
//                      the dialog.  if it is NULL, the default dialog proc
//                      will be used.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_AddKeyDlg::C_AddKeyDlg(
    HWND                hwndParent,
    HINSTANCE           hInstance,
    LONG                lIDD,
    DLGPROC             pfnDlgProc  //   = NULL
    )
:   C_Dlg(hwndParent, hInstance, lIDD, pfnDlgProc)
{
   m_hInst = hInstance;
}   //  C_AddKeyDlg::C_AddKeyDlg


// EditFillDialog - read current credential and fill dialog fields with
//  the data so recovered.

BOOL gTestReadCredential(void) {
    TCHAR       *pC;
    INT_PTR     iIndex,iWhere;
    BOOL        f;
    LRESULT     lR,lRet;
    TCHAR       szTitle[CRED_MAX_STRING_LENGTH];        // buffer to hold window title string
    DWORD       dwType;
    
    g_pExistingCred = NULL;
    
    // Fetch current credential from list into g_szTargetName
    lR = SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETCURSEL,0,0L);
    
    if (lR == LB_ERR) 
        return FALSE;
    else {
        g_CurrentKey = lR;
        lRet = SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETTEXT,lR,(LPARAM) g_szTargetName);
    }
    
    if (lRet == 0) return FALSE;       // zero characters returned

    // Get the target type from the combo box item data
    dwType = (DWORD) SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETITEMDATA,lR,0);
    if (LB_ERR == dwType) return FALSE;

    // null term the targetname, trimming the suffix if there is one
    pC = _tcschr(g_szTargetName,g_rgcCert[0]);
    if (pC) {
        pC--;
        *pC = 0x0;               // null terminate namestring
    }

    // replace special ras cred name string at this point
    if (dwType == SESSION_FLAG_VALUE) {
        _tcscpy(g_szTargetName,CRED_SESSION_WILDCARD_NAME);
        dwType = CRED_TYPE_DOMAIN_PASSWORD;
    }
    // Attempt to read the credential from the store
    // The returned credential will have to be freed if leaving this block
    f = (CredRead(g_szTargetName,
             (ULONG) dwType,
             0,
             &g_pExistingCred));
    if (!f) 
        return FALSE;           // g_pExistingCred is empty
        
    return TRUE;                // g_pExistingCred has been filled
}

void
C_AddKeyDlg::EditFillDialog(void) {
    TCHAR       *pC;
    INT_PTR     iIndex,iWhere;
    BOOL        f;
    LRESULT     lR,lRet;
    TCHAR       szTitle[CRED_MAX_STRING_LENGTH];        // buffer to hold window title string

    if (NULL == g_pExistingCred) return;

    // Set up persistence in the UI
    // bugbug
    g_dwPersist = g_pExistingCred->Persist;
    g_dwType =  g_pExistingCred->Type;

    // Enable the change password stuff only on domain password creds
    //
    switch (g_pExistingCred->Type){
        case CRED_TYPE_DOMAIN_PASSWORD:
            ShowWindow(m_hwndChgPsw,SW_NORMAL);
            ShowWindow(m_hwndPswLbl,SW_NORMAL);
            //deliberate fallthrough
        case CRED_TYPE_DOMAIN_CERTIFICATE:
            LoadString ( m_hInst, IDS_TITLE, szTitle, 200 );
            SendMessage(m_hDlg,WM_SETTEXT,0,(LPARAM) szTitle);
            break;
        default:
            break;
    }
    
    // Write targetname to the UI
    SendMessage(m_hwndTName, WM_SETTEXT,0,(LPARAM) g_pExistingCred->TargetName);

    // Write username to the UI - take directly from the existing cred
    if (!Credential_SetUserName(m_hwndCred,g_pExistingCred->UserName)) {
        // make a copy of the original username
        _tcscpy(m_szUsername,g_pExistingCred->UserName);
    }

}

// Get permissible persistence types for cred_type_domain_password credentials, which is
//  all this UI currently handles.
DWORD GetPersistenceOptions(void) {

    BOOL bResult;
    DWORD i[CRED_TYPE_MAXIMUM];
    DWORD j;
    DWORD dwCount = CRED_TYPE_MAXIMUM;

    bResult = CredGetSessionTypes(dwCount,i);
    if (!bResult) {
        return CRED_PERSIST_NONE;
    }

    j = i[CRED_TYPE_DOMAIN_PASSWORD];
    return j;
}
// Create a composite description string from 3 sources:
//  1.  the descriptive text for this type of cred
//  2.  a general phrase "This informaiton will be available until "
//  3.  the persistence tail: "you log off." or "you delete it."
void C_AddKeyDlg::ShowDescriptionText(DWORD dwtype, DWORD Persist) 
{
#define DESCBUFFERLEN 500
    WCHAR szMsg[DESCBUFFERLEN + 1];
    WCHAR szTemp[DESCBUFFERLEN + 1];
    INT iRem = DESCBUFFERLEN;       // remainging space in the buffer
    
    memset(szMsg,0,sizeof(szMsg));
    
    if ((dwtype != CRED_TYPE_DOMAIN_PASSWORD) &&
       (dwtype != CRED_TYPE_DOMAIN_CERTIFICATE))
    {
        LoadString ( m_hInst, IDS_DESCAPPCRED, szTemp, DESCBUFFERLEN );
        wcscpy(szMsg,szTemp);
        iRem -= wcslen(szMsg);
    }
    else 
    {
        if (Persist == CRED_PERSIST_LOCAL_MACHINE)
            LoadString ( m_hInst, IDS_DESCLOCAL, szTemp, DESCBUFFERLEN );
        else
            LoadString ( m_hInst, IDS_DESCBASE, szTemp, DESCBUFFERLEN );
        wcscpy(szMsg,szTemp);
        iRem -= wcslen(szMsg);
    }
    
    LoadString ( m_hInst, IDS_PERSISTBASE, szTemp, DESCBUFFERLEN );
    iRem -= wcslen(szTemp);
    if (0 < iRem) wcscat(szMsg,szTemp);

    if (Persist == CRED_PERSIST_SESSION)
            LoadString ( m_hInst, IDS_PERSISTLOGOFF, szTemp, DESCBUFFERLEN );
    else
            LoadString ( m_hInst, IDS_PERSISTDELETE, szTemp, DESCBUFFERLEN );

    iRem -= wcslen(szTemp);
    if (0 < iRem) wcscat(szMsg,szTemp);
    SendMessage(m_hwndDescription, WM_SETTEXT,0,(LPARAM) szMsg);
    return;

}

//////////////////////////////////////////////////////////////////////////////
//
//  OnInitDialog
//
//  Dialog control and data initialization.
//
//  parameters:
//      hwndDlg         window handle of the dialog box
//      hwndFocus       window handle of the control that will receive focus
//
//  returns:
//      TRUE            if the system should set the default keyboard focus
//      FALSE           if the keyboard focus is set by this app
//
//////////////////////////////////////////////////////////////////////////////

BOOL
C_AddKeyDlg::OnInitDialog(
    HWND                hwndDlg,
    HWND                hwndFocus
    )
{
    C_Dlg::OnInitDialog(hwndDlg, hwndFocus);

    CenterWindow();

    m_hDlg = hwndDlg;
    
    m_hwndCred  = GetDlgItem(m_hDlg,IDC_CRED);
    if (!Credential_InitStyle(m_hwndCred,CRS_USERNAMES | CRS_CERTIFICATES | CRS_SMARTCARDS)) return FALSE;
    
    m_hwndTName  = GetDlgItem(m_hDlg,IDC_TARGET_NAME);
    m_hwndChgPsw = GetDlgItem(m_hDlg,IDC_CHGPSW);
    m_hwndPswLbl = GetDlgItem(m_hDlg,IDC_DOMAINPSWLABEL);
    m_hwndDescription = GetDlgItem(m_hDlg,IDC_DESCRIPTION);
    
    // Establish limits on string lengths from the user
    SendMessage(m_hwndTName,EM_LIMITTEXT,CRED_MAX_GENERIC_TARGET_NAME_LENGTH,0);

    // Show dummy password for edited credential
    if (m_bEdit) Credential_SetPassword(m_hwndCred,L"********");
    
    // Set up the allowable persistence options depending on the type of user session
    // Set the default persistence unless overriden by a cred read on edit
    g_dwPersist = GetPersistenceOptions();
    g_dwType = CRED_TYPE_DOMAIN_PASSWORD;

    // By default, hide all optional controls.  These will be enabled as appropriate
    ShowWindow(m_hwndChgPsw,SW_HIDE);
    ShowWindow(m_hwndPswLbl,SW_HIDE);

    
    if (m_bEdit) {
        EditFillDialog();
    }

    g_fPswChanged = FALSE;
    ShowDescriptionText(g_dwType,g_dwPersist);
#ifdef LOUDLY
    OutputDebugString(L"Dialog init complete--------\n");
#endif
    return TRUE;
    // On exit from OnInitDialog, g_szTargetName holds the currently selected 
    //  credential's old name, undecorated (having had a null dropped before
    //  the suffix)
}   //  C_AddKeyDlg::OnInitDialog

BOOL
C_AddKeyDlg::OnDestroyDialog(
    void    )
{
    return TRUE;
}
//////////////////////////////////////////////////////////////////////////////
//
//  OnAppMessage
//
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_AddKeyDlg::OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam)
{
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OnCommand
//
//  Route WM_COMMAND message to appropriate handlers.
//
//  parameters:
//      wNotifyCode     code describing action that has occured
//      wSenderId       id of the control sending the message, if the message
//                      is from a dialog
//      hwndSender      window handle of the window sending the message if the
//                      message is not from a dialog
//
//  returns:
//      TRUE            if the message was processed completely
//      FALSE           if Windows is to process the message
//
////////////////////////////////////////////////////////////////////////////


BOOL
C_AddKeyDlg::OnHelpInfo(LPARAM lp) {

    HELPINFO* pH;
    INT iMapped;
    pH = (HELPINFO *) lp;
    HH_POPUP stPopUp;
    RECT rcW;
    UINT gID;

    gID = pH->iCtrlId;
    iMapped = MapID(gID);
    
    if (iMapped == 0) return TRUE;
    
    if (IDS_NOHELP != iMapped) {

      memset(&stPopUp,0,sizeof(stPopUp));
      stPopUp.cbStruct = sizeof(HH_POPUP);
      stPopUp.hinst = g_hInstance;
      stPopUp.idString = iMapped;
      stPopUp.pszText = NULL;
      stPopUp.clrForeground = -1;
      stPopUp.clrBackground = -1;
      stPopUp.rcMargins.top = -1;
      stPopUp.rcMargins.bottom = -1;
      stPopUp.rcMargins.left = -1;
      stPopUp.rcMargins.right = -1;
      // bug 393244 - leave NULL to allow HHCTRL.OCX to get font information of its own,
      //  which it needs to perform the UNICODE to multibyte conversion. Otherwise, 
      //  HHCTRL must convert using this font without charset information.
      stPopUp.pszFont = NULL;
      if (GetWindowRect((HWND)pH->hItemHandle,&rcW)) {
          stPopUp.pt.x = (rcW.left + rcW.right) / 2;
          stPopUp.pt.y = (rcW.top + rcW.bottom) / 2;
      }
      else stPopUp.pt = pH->MousePos;
      HtmlHelp((HWND) pH->hItemHandle,NULL,HH_DISPLAY_TEXT_POPUP,(DWORD_PTR) &stPopUp);
    }
    return TRUE;
}

BOOL
C_AddKeyDlg::OnCommand(
    WORD                wNotifyCode,
    WORD                wSenderId,
    HWND                hwndSender
    )
{
    BOOL fHandled = FALSE;          // indicate message handled
    LRESULT lR;
    INT_PTR f;

    switch (wSenderId)
    {
    case IDC_CRED:
        {
            if (wNotifyCode == CRN_USERNAMECHANGE) {
#ifdef LOUDLY
                OutputDebugString(L"Username changed!\n");
#endif
                // Show dummy password for edited credential
                if (m_bEdit) Credential_SetPassword(m_hwndCred,NULL);
                g_fPswChanged = FALSE;
            }
            if (wNotifyCode == CRN_PASSWORDCHANGE) {
#ifdef LOUDLY
                OutputDebugString(L"Password changed!\n");
#endif
                g_fPswChanged = TRUE;
            }
        }
        break;
        
    case IDOK:
        if (BN_CLICKED == wNotifyCode)
        {
#ifdef LOUDLY
                OutputDebugString(L"Call to OnOK\n");
#endif
            OnOK( );
            fHandled = TRUE;
        }
        break;
        
    case IDC_CHGPSW:
        {
            OnChangePassword();
            //EndDialog(IDCANCEL);  do not cancel out of properties dialog
            break;
        }

    case IDCANCEL:
        if (BN_CLICKED == wNotifyCode)
        {
            EndDialog(IDCANCEL);
            fHandled = TRUE;
        }
        break;

    }   //  switch

    return fHandled;

}   //  C_AddKeyDlg::OnCommand

////////////////////////////////////////////////////////////////////////////
//
//  OnOK
//
//  Validate user name, synthesize computer name, and destroy dialog.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
C_AddKeyDlg::OnOK( )
{
    LONG_PTR j,lCType;
    TCHAR szMsg[MAX_STRING_SIZE];
    TCHAR szTitle[MAX_STRING_SIZE];
    
    TCHAR szUser[CRED_MAX_STRING_LENGTH + 1];   // in from dialog
    TCHAR szPsw[CRED_MAX_STRING_LENGTH + 1];    // in from dialog
    TCHAR *pszNewTarget;                        // in from dialog
    TCHAR *pszTrimdName;                        // mod'd in from dialog
    DWORD dwFlags = 0;                          // in from dialog
    
    CREDENTIAL stCredential;                    // local copy of cred
    
    UINT  cbPassword;
    BOOL  bResult;
    BOOL  IsCertificate = FALSE;
    BOOL  fDeleteOldCred = FALSE;
    BOOL  fRenameCred = FALSE;
    BOOL  fPreserve = FALSE;
    BOOL  fPsw = FALSE;

    ASSERT(::IsWindow(m_hwnd));
    
    szPsw[0]= 0;
    szUser[0] = 0;

    // Start with a blank cred if this is not an edit, else make a copy of existing one
    if ((m_bEdit) && (g_pExistingCred))
        memcpy((void *) &stCredential,(void *) g_pExistingCred,sizeof(CREDENTIAL));
    else
        memset((void *) &stCredential,0,sizeof(CREDENTIAL));
    
    pszNewTarget = (TCHAR *) malloc((CRED_MAX_GENERIC_TARGET_NAME_LENGTH + 1) * sizeof(TCHAR));
    if (NULL == pszNewTarget) {
        return;
    }
    pszNewTarget[0] = 0;

    // Get Username from the cred control - find out if is a certificate by
    //  IsMarshalledName().
    if (Credential_GetUserName(m_hwndCred,szUser,CRED_MAX_STRING_LENGTH))
        IsCertificate = CredIsMarshaledCredential(szUser);
#ifdef LOUDLY
    if (IsCertificate) OutputDebugString(L"User is a certificate\n");
#endif

    // fetch password/PIN into szPsw.  set fPsw if value is valid
    fPsw = Credential_GetPassword(m_hwndCred,szPsw,CRED_MAX_STRING_LENGTH);
#ifdef LOUDLY
    if (fPsw) OutputDebugString(L"Password control is enabled\n");
    OutputDebugString(szUser);
    OutputDebugString(L":");
    OutputDebugString(szPsw);
    OutputDebugString(L"\n");
#endif

    // Check to see that both name and psw are not missing
    if ( wcslen ( szUser ) == 0 && 
         wcslen ( szPsw )  == 0  ) {
#ifdef LOUDLY
    OutputDebugString(L"Missing username andor password\n");
#endif
        LoadString ( m_hInst, IDS_ADDFAILED, szMsg, MAX_STRING_SIZE );
        LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
        MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
        if (pszNewTarget) free(pszNewTarget);
        return; 
    }
    
    // If the user has typed a \\server style target name, strip the leading hacks
    j = SendMessage(m_hwndTName,WM_GETTEXT,CRED_MAX_GENERIC_TARGET_NAME_LENGTH,(LPARAM)pszNewTarget);
    ASSERT(j);
    pszTrimdName = pszNewTarget;
    while (*pszTrimdName == TCHAR('\\')) pszTrimdName++;

    // Now have:
    //  pszTrimdName
    //  uzUser
    //  szPsw
    //  fPsw
    
    // If target name edited, will need to rename
    // If type changed or psw edited, psw blob will be removed/replaced
    // If type changed, will need to remove old cred
    
    if ((m_bEdit) && (g_pExistingCred)) {
    
        if (0 != _tcscmp(pszTrimdName,g_szTargetName)) fRenameCred = TRUE;
#ifdef LOUDLY
    OutputDebugString(L"Is edit mode\n");
    if (fRenameCred) OutputDebugString(L"Cred will be renamed\n");
#endif
        // Note that currently DOMAIN_VISIBLE_PASSWORD creds cannot be edited
        //  or created, so there is no handler for those types.
        if (g_pExistingCred->Type == CRED_TYPE_GENERIC) {
            lCType = CRED_TYPE_GENERIC;        
        }
        else  {
            if (IsCertificate) lCType = CRED_TYPE_DOMAIN_CERTIFICATE;
            else lCType = CRED_TYPE_DOMAIN_PASSWORD;
        }

        if ((DWORD)lCType != g_pExistingCred->Type) {
            dwFlags &= ~CRED_PRESERVE_CREDENTIAL_BLOB;
            fDeleteOldCred = TRUE;
        }
        else dwFlags |= CRED_PRESERVE_CREDENTIAL_BLOB;
        
        if (g_fPswChanged) dwFlags &= ~CRED_PRESERVE_CREDENTIAL_BLOB;
    }
    else {
#ifdef LOUDLY
        OutputDebugString(L"Is not edit mode\n");
#endif
        // if is a certificate marshalled name is cert or generic
        // if not is generic or domain 
        if (IsCertificate) {
            lCType = CRED_TYPE_DOMAIN_CERTIFICATE;
        }
        else {
            lCType = CRED_TYPE_DOMAIN_PASSWORD;
        }
    }
    
    // Save credential.  If certificate type, do not include a psw blob.
    // After save, if the name had changed, rename the cred

    stCredential.UserName = szUser;
    stCredential.Type = (DWORD) lCType;
    
    // If not an edit, fill in targetname, else do rename later
    if (!m_bEdit) stCredential.TargetName = pszTrimdName;
    stCredential.Persist = g_dwPersist;
    
    // fill credential blob data with nothing if the cred control UI has
    // disabled the password box.  Otherwise supply psw information if
    // the user has edited the box contents.
    if (fPsw) {
        if (g_fPswChanged) {
#ifdef LOUDLY
            OutputDebugString(L"Storing new password data\n");
#endif
            cbPassword = wcslen(szPsw) * sizeof(TCHAR);
            stCredential.CredentialBlob = (unsigned char *)szPsw;
            stCredential.CredentialBlobSize = cbPassword;
        }
#ifdef LOUDLY
        else OutputDebugString(L"No password data stored.\n");
#endif
    }

    if (lCType == CRED_TYPE_DOMAIN_PASSWORD) {
        // validate proper UPN or domain-prefixed credentials.
        DNS_STATUS dS = DnsValidateName(szUser,DnsNameDomain);
        // gm bugbug - this looks wrong
        if (DNS_RCODE_NOERROR == dS) {
           LoadString ( m_hInst, IDS_BADUSERDOMAINNAME, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
           if (pszNewTarget) free(pszNewTarget);
           return;
        }
    }

    bResult = CredWrite(&stCredential,dwFlags);
    memset(szPsw,0,sizeof(szPsw));      // delete psw local copy
    
    if ( bResult != TRUE )
    {
#ifdef LOUDLY
    WCHAR szw[200];
    DWORD dwE = GetLastError();
    swprintf(szw,L"CredWrite failed. Last Error is %x\n",dwE);
    OutputDebugString(szw);
#endif
        AdviseUser();
        if (pszNewTarget) free(pszNewTarget);
        return;
    }
    
    // Delete old credential only if type has changed
    // Otherwise if name changed, do a rename of the cred
    // If the old cred is deleted, rename is obviated
    if (fDeleteOldCred) {
#ifdef LOUDLY
    OutputDebugString(L"CredDelete called\n");
#endif
        CredDelete(g_szTargetName,(ULONG) g_pExistingCred->Type,0);
    } 
    else if (fRenameCred) {
        bResult = CredRename(g_szTargetName, pszTrimdName, (ULONG) stCredential.Type,0);
#ifdef LOUDLY
    OutputDebugString(L"CredRename called\n");
#endif
        if (!bResult) {
            // bugbug: How can rename fail?
            // If it does, what would you tell the user?
            LoadString ( m_hInst, IDS_RENAMEFAILED, szMsg, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
            if (pszNewTarget) free(pszNewTarget);
            return;
        }
    }

#ifdef EDITOFFERPASSWORD
    // Offer the possibility of changing the password on the domain if the 
    //  password field was edited, but the username was unchanged.
    if (g_fPswChanged && m_bEdit) {
        if (g_pExistingCred->Type == CRED_TYPE_DOMAIN_PASSWORD) {
#ifdef LOUDLY
    OutputDebugString(L"Cred change - offer domain password change\n");
#endif
            LoadString ( m_hInst, IDS_DOMAINOFFER, szMsg, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            if (IDYES == MessageBox ( m_hDlg,  szMsg, szTitle, MB_YESNO )) 
                OnChangePassword();
            else {
                LoadString ( m_hInst, IDS_DOMAINEDIT, szMsg, MAX_STRING_SIZE );
                LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
                MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
            }
        }
    }
#endif

    if (pszNewTarget) free(pszNewTarget);
    EndDialog(IDOK);
}   //  C_AddKeyDlg::OnOK

void C_AddKeyDlg::OnChangePassword()
{
   
    C_ChangePasswordDlg   CPdlg(m_hDlg, g_hInstance, IDD_CHANGEPASSWORD, NULL);
    CPdlg.m_szDomain[0] = 0;
    CPdlg.m_szUsername[0] = 0;
    INT_PTR nResult = CPdlg.DoModal((LPARAM)&CPdlg);
}

// Simple test for likelihood that a name is a domain type.

BOOL IsDomainNameType(LPCTSTR pName) {
    TCHAR *pC;
    pC = _tcschr(pName,TCHAR('@'));
    if (NULL != pC) return TRUE;
    pC = _tcschr(pName,TCHAR('\\'));
    if (NULL != pC) return TRUE;
    return FALSE;

}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//////////////////////////////////////////////////////////////////////////////
//
//  C_KeyringDlg
//
//  Constructor.
//
//  parameters:
//      rSetupInfo      reference to a C_UpgradeInfo object containing default
//                      setup parameters
//      hwndParent      parent window for the dialog (may be NULL)
//      hInstance       instance handle of the parent window (may be NULL)
//      lIDD            dialog template id
//      pfnDlgProc      pointer to the function that will process messages for
//                      the dialog.  if it is NULL, the default dialog proc
//                      will be used.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_KeyringDlg::C_KeyringDlg(
    HWND                hwndParent,
    HINSTANCE           hInstance,
    LONG                lIDD,
    DLGPROC             pfnDlgProc  //   = NULL
    )
:   C_Dlg(hwndParent, hInstance, lIDD, pfnDlgProc)
{
   m_hInst = hInstance;             // our instance handle
   g_AKdlg = NULL;                  // addkey dialog not up
   fInit = FALSE;                   // initial screen draw undone
}  //  C_KeyringDlg::C_KeyringDlg


// BuildList() is called to initialize the keyring UI credential list, and
//  again after completion of the add dialog, plus again after handling
//  the credential delete button.
//

void C_KeyringDlg::BuildList()
{
    // Call CredEnumerate(), and populate a list using the TargetName
    //  field of each credential returned.  Note that the associated tag
    //  data for each list box entry will be the numeric credential type.
    //
    // Enable or Disable the DELETE button as appropriate.

    DWORD dwCredCount = 0;
    CREDENTIAL **pCredentialPtrArray;
    BOOL bResult;
    DWORD i,dwCredType;
    PCREDENTIAL pThisCred;
    TCHAR *pTargetName;
    LRESULT idx;
    HWND hH;
    TCHAR szMsg[64];
    BOOL fSession = FALSE;
    INT iCredCount = 0;

    // clear the listbox
    ::SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_RESETCONTENT,NULL,0);
    bResult = CredEnumerate(NULL,0,&dwCredCount,&pCredentialPtrArray);
#ifdef LOUDLY
    if (!bResult) 
    {
        DWORD dwe = GetLastError();
        OutputDebugString(L"CredEnumerate failed\n");
        swprintf(szMsg,L"CredEnumerate error %x\n",dwe);
        OutputDebugString(szMsg);
    }
#endif
    if (bResult) {
        for (i=0 ; i < dwCredCount ; i++) {
#ifdef LOUDLY
    if (!bResult) OutputDebugString(L"Adding a cred to the window\n");
#endif
            pThisCred = pCredentialPtrArray[i];
            pTargetName = pThisCred->TargetName;

            // handle CRED_SESSION_WILDCARD_NAME_W by replacing the string
            if (0 == _tcsicmp(pTargetName,CRED_SESSION_WILDCARD_NAME)) {
                LoadString ( m_hInst, IDS_SESSIONCRED, szMsg, 64 );
                pTargetName = szMsg;
                dwCredType = SESSION_FLAG_VALUE;
            }
            else dwCredType = pThisCred->Type;
            
            // name suffixes are localizable
            switch (dwCredType) {
            
                case CRED_TYPE_GENERIC:
                    continue;
                    break;

                // this particular type is not visible in keymgr
                case CRED_TYPE_DOMAIN_VISIBLE_PASSWORD:
#ifndef SHOWPASSPORT
                    continue;
#endif
#ifdef SHOWPASSPORT
                    _tcscpy(g_szTargetName,pTargetName);
                    _tcscat(g_szTargetName,_T(" "));
                    _tcscat(g_szTargetName,g_rgcPassport);
                    break;
#endif
                    
                case CRED_TYPE_DOMAIN_PASSWORD:
                case SESSION_FLAG_VALUE:
                    // find RAS credential
                    _tcscpy(g_szTargetName,pTargetName);
                    break;
                    
                case CRED_TYPE_DOMAIN_CERTIFICATE:
                    _tcscpy(g_szTargetName,pTargetName);
                    _tcscat(g_szTargetName,_T(" "));
                    _tcscat(g_szTargetName,g_rgcCert);
                    break;
                    
                default:
                    break;
            }
            idx = ::SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_ADDSTRING,NULL,(LPARAM) g_szTargetName);
            if (idx != LB_ERR) {
                idx = ::SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_SETITEMDATA,(WPARAM)idx,dwCredType);
            }
        }
    }
    // if FALSE below, causes: no creds, no logon session, invalid flags
    if (bResult) CredFree(pCredentialPtrArray);
#ifdef ODDUIBUG
    //SetCurrentKey(g_CurrentKey);
#else
    SetCurrentKey(g_CurrentKey);
#endif
}

// Set the cursor on the keys list to the first item initially.
// Thereafter, this function permits the last cursor to be reloaded after
//  doing something to the list.  The only time we reset the cursor is 
//  after adding a credential, because the behavior of the cursor is very
//  difficult to do properly under those circumstances, as you don't know
//  where the item will be inserted relative to where you are. (At least
//  not without a great deal of trouble)
void C_KeyringDlg::SetCurrentKey(LONG_PTR iKey) {

    LONG_PTR iKeys;
    HWND hH;
    LRESULT idx;
    BOOL fDisabled = FALSE;

    // If there are items in the list, select the first one and set focus to the list
    iKeys = ::SendDlgItemMessage ( m_hDlg, IDC_KEYLIST, LB_GETCOUNT, (WPARAM) 0, 0L );
    fDisabled = (GetPersistenceOptions() == CRED_PERSIST_NONE);

    // If there are no creds and credman is disabled, the dialog should not be displayed
    // If there are creds, and credman is disabled, show the dialog without the ADD button
    if (fDisabled && !fInit)
    {
        // Make the intro text better descriptive of this condition
        WCHAR szMsg[MAX_STRING_SIZE+1];
        LoadString ( m_hInst, IDS_INTROTEXT, szMsg, MAX_STRING_SIZE );
        hH = GetDlgItem(m_hDlg,IDC_INTROTEXT);
        if (hH) SetWindowText(hH,szMsg);
        
        // we already know that the credcount is nonzero (see startup code for keymgr)
        // remove the add button
        hH = GetDlgItem(m_hDlg,IDC_NEWKEY);
        if (hH)
        {
            EnableWindow(hH,FALSE);
            ShowWindow(hH,SW_HIDE);
        }
        // move remaining buttons upfield 22 units
        hH = GetDlgItem(m_hDlg,IDC_DELETEKEY);
        if (hH)
        {
            HWND hw1;
            HWND hw2;
            RECT rw1;
            RECT rw2;
            INT xsize;
            INT ysize;
            INT delta;
            BOOL bOK = FALSE;

            hw1 = hH;
            hw2 = GetDlgItem(m_hDlg,IDC_EDITKEY);
            if (hw1 && hw2)
            {
                 if (GetWindowRect(hw1,&rw1) &&
                      GetWindowRect(hw2,&rw2))
                {
                    MapWindowPoints(NULL,m_hDlg,(LPPOINT)(&rw1),2);
                    MapWindowPoints(NULL,m_hDlg,(LPPOINT)(&rw2),2);
                    delta = rw2.top - rw1.top;
                    xsize = rw2.right - rw2.left;
                    ysize = rw2.bottom - rw2.top;
                    bOK = MoveWindow(hw1,rw1.left,rw1.top - delta,xsize,ysize,TRUE);
                    if (bOK) 
                    {
                         bOK = MoveWindow(hw2,rw2.left,rw2.top - delta,xsize,ysize,TRUE);
                    }
                }
            }
        }
    }

    // Set the default button to either properties or add
    if ( iKeys > 0 )
    {
        hH = GetDlgItem(m_hDlg,IDC_KEYLIST);
        //PostMessage(m_hDlg,DM_SETDEFID,(WPARAM)IDC_EDITKEY,(LPARAM)0);
        PostMessage(hH,WM_SETFOCUS,NULL,0);
        if (iKey >= iKeys) iKey = 0;
        idx = SendDlgItemMessage ( m_hDlg, IDC_KEYLIST, LB_SETCURSEL, iKey, 0L );

        hH = GetDlgItem(m_hDlg,IDC_EDITKEY);
        if (hH) EnableWindow(hH,TRUE);
        hH = GetDlgItem(m_hDlg,IDC_DELETEKEY);
        if (hH) EnableWindow(hH,TRUE);
    }
    else
    {
        if (!fDisabled)
        {
            // no items in the list, set focus to the New button
            hH = GetDlgItem(m_hDlg,IDC_NEWKEY);
            //PostMessage(m_hDlg,DM_SETDEFID,(WPARAM)IDC_NEWKEY,(LPARAM)0);
            PostMessage(hH,WM_SETFOCUS,NULL,0);
        }

        hH = GetDlgItem(m_hDlg,IDC_EDITKEY);
        if (hH) EnableWindow(hH,FALSE);
        hH = GetDlgItem(m_hDlg,IDC_DELETEKEY);
        if (hH) EnableWindow(hH,FALSE);
    }
}

// Get target string from keys listbox, return assocd data as type

LONG_PTR C_KeyringDlg::GetCredentialType() {
    TCHAR *pC;
    LONG_PTR idx;

    idx = ::SendDlgItemMessage ( m_hDlg, IDC_KEYLIST, LB_GETCURSEL, 0, 0L );
    if ( idx == LB_ERR) return CRED_TYPE_UNKNOWN;
    
    idx = ::SendDlgItemMessage ( m_hDlg, IDC_KEYLIST, LB_GETITEMDATA, idx, 0 );
    if (idx != LB_ERR) return idx;
    else return CRED_TYPE_UNKNOWN;
}

// Remove the currently highlighted key from the listbox

void C_KeyringDlg::DeleteKey()
{

    TCHAR szMsg[MAX_STRING_SIZE + MAXSUFFIXSIZE];
    TCHAR szTitle[MAX_STRING_SIZE];
    TCHAR *pC;                      // point this to the raw name 
    LONG_PTR dwCredType;
    LONG_PTR lr = LB_ERR;
    LONG_PTR idx = LB_ERR;
    BOOL bResult = FALSE;
    INT i=0;
    
    if (!gTestReadCredential()) return;

    LoadString ( m_hInst, IDS_DELETEWARNING, szMsg, MAX_STRING_SIZE );
    LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
    lr = MessageBox ( m_hDlg,  szMsg, szTitle, MB_OKCANCEL );
    if (IDOK != lr) return;
    
    // trim the suffix from the targetname, null term
    pC = _tcschr(g_szTargetName,g_rgcCert[0]);
    if (pC) {
        *(pC - LENGTHOFWHITESPACE) = 0x0;  // null terminate namestring
    }
    
    bResult = CredDelete(g_szTargetName,(DWORD) g_pExistingCred->Type,0);
    if (bResult != TRUE) {
       LoadString ( m_hInst, IDS_DELETEFAILED, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK);
    }
    if (g_pExistingCred) CredFree(g_pExistingCred);
    g_pExistingCred = NULL;
}

BOOL
C_KeyringDlg::OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam
        )
    {
        return TRUE;
    }   //  OnAppMessage


//////////////////////////////////////////////////////////////////////////////
//
//  OnInitDialog
//
//  Dialog control and data initialization.
//
//  parameters:
//      hwndDlg         window handle of the dialog box
//      hwndFocus       window handle of the control that will receive focus
//
//  returns:
//      TRUE            if the system should set the default keyboard focus
//      FALSE           if the keyboard focus is set by this app
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_KeyringDlg::OnInitDialog(
    HWND                hwndDlg,
    HWND                hwndFocus
    )
{
    BOOL bRc;
    // these really should all be in the keyringdlg class
    fNew = FALSE;
    DWORD i;
    LRESULT lr;

    HtmlHelp(NULL,NULL,HH_INITIALIZE,(DWORD_PTR) &g_dwHCookie);

    // Allow other dialog to query the contents of the listbox
    g_hMainDlg = hwndDlg;
    m_hDlg = hwndDlg;
    g_CurrentKey = 0;

    // Fetch Icons from the image and assoc them with this dialog
    HICON hI = LoadIcon(m_hInst,MAKEINTRESOURCE(IDI_SMALL));
    lr = SendMessage(hwndDlg,WM_SETICON,(WPARAM) ICON_SMALL,(LPARAM)hI);

    C_Dlg::OnInitDialog(hwndDlg, hwndFocus);

    CenterWindow();
    // Even if mirrored language is default, set list box style to LTR
#ifdef FORCELISTLTR
    {
        LONG_PTR lExStyles;
        HWND hwList;
        hwList = GetDlgItem(hwndDlg,IDC_KEYLIST);
        if (hwList) 
        {
            lExStyles = GetWindowLongPtr(hwList,GWL_EXSTYLE);
            lExStyles &= ~WS_EX_RTLREADING;
            SetWindowLongPtr(hwList,GWL_EXSTYLE,lExStyles);
            InvalidateRect(hwList,NULL,TRUE);
        }
    }
#endif
    // read in the suffix strings for certificate types
    // locate first differing character
    //
    // This code assumes that the strings all have a common preamble, 
    //  and that all are different in the first character position
    //  past the preamble.  Localized strings should be selected which
    //  have this property, like (Generic) and (Certificate).
    i = LoadString(g_hInstance,IDS_CERTSUFFIX,g_rgcCert,MAXSUFFIXSIZE);
    ASSERT(i !=0);
    i = LoadString(g_hInstance,IDS_PASSPORTSUFFIX,g_rgcPassport,MAXSUFFIXSIZE);

    // Read currently saved creds and display names in list box
    BuildList();
#ifdef ODDUIBUG
    SetCurrentKey(g_CurrentKey);
#endif
    InitTooltips();
    fInit = TRUE;       // prevent repeating button movement/setup
    return TRUE;
}   //  C_KeyringDlg::OnInitDialog

BOOL
C_KeyringDlg::OnDestroyDialog(
    void    )
{
    HtmlHelp(NULL,NULL,HH_UNINITIALIZE,(DWORD_PTR)g_dwHCookie);
    return TRUE;
}

BOOL C_KeyringDlg::DoEdit(void) {
   LRESULT lR;
   HWND hB;
   
   if (fNew) return TRUE;
   fNew = TRUE;
   
   lR = SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_GETCURSEL,0,0L);
   if (LB_ERR == lR) {
        // On error, no dialog shown, edit command handled
        fNew = FALSE;
        return TRUE;
   }
   else {
       // something selected
       g_CurrentKey = lR;

       // If a session cred, show it specially, indicate no edit allowed
       lR = SendDlgItemMessage(m_hDlg,IDC_KEYLIST,LB_GETITEMDATA,lR,0);
       if (lR == SESSION_FLAG_VALUE)  {
            // load string and display message box
            TCHAR szMsg[MAX_STRING_SIZE];
            TCHAR szTitle[MAX_STRING_SIZE];
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_CANNOTEDIT, szMsg, MAX_STRING_SIZE );
            MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
            fNew = FALSE;
            return TRUE;
       }
#ifdef SHOWPASSPORT
#ifdef NEWPASSPORT
       // if a passport cred, show it specially, indicate no edit allowed
       if (lR == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD) {
            // load string and display message box
            TCHAR szMsg[MAX_STRING_SIZE];
            TCHAR szTitle[MAX_STRING_SIZE];
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_PASSPORT2, szMsg, MAX_STRING_SIZE );
            INT iResponse = MessageBox ( m_hDlg,  szMsg, szTitle, MB_YESNO );
            if (IDYES == iResponse) 
            {
                HANDLE hWnd;
                HKEY hKey = NULL;
                DWORD dwType;
                BYTE rgb[500];
                DWORD cbData = sizeof(rgb);
                BOOL Flag = TRUE;
                // launch the passport web site
#ifndef PASSPORTURLINREGISTRY
                ShellExecute(m_hDlg,L"open",L"http://www.passport.com",NULL,NULL,SW_SHOWNORMAL);
#else 
                // read registry key to get target string for ShellExec
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                        L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                                        0,
                                        KEY_QUERY_VALUE,
                                        &hKey))
                {
                    if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                   L"Properties",
                                   NULL,
                                   &dwType,
                                   rgb,
                                   &cbData))
                    {
                        ShellExecute(m_hDlg,L"open",(LPCTSTR)rgb,NULL,NULL,SW_SHOWNORMAL);
                        Flag = FALSE;
                    }
                }
#ifdef LOUDLY
                else 
                {
                    OutputDebugString(L"DoEdit: reg key HKCU... open failed\n");
                }
#endif
                if (Flag)
                {
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                            L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport",
                                            0,
                                            KEY_QUERY_VALUE,
                                            &hKey))
                    {
                        if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                       L"Properties",
                                       NULL,
                                       &dwType,
                                       rgb,
                                       &cbData))
                        {
                            ShellExecute(m_hDlg,L"open",(LPCTSTR)rgb,NULL,NULL,SW_SHOWNORMAL);
                            Flag = FALSE;
                        }
                    }
#ifdef LOUDLY
                    else 
                    {
                        OutputDebugString(L"DoEdit: reg key HKLM... open failed\n");
                    }
#endif
                }
                if (Flag)
                {
                    LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
                    LoadString ( m_hInst, IDS_PASSPORTNOURL, szMsg, MAX_STRING_SIZE );
                    MessageBox ( m_hDlg,  szMsg, szTitle, MB_ICONHAND );
#ifdef LOUDLY
                    OutputDebugString(L"DoEdit: Passport URL missing\n");
#endif
                }
#endif
            }
            fNew = FALSE;
            return TRUE;
       }
#else
       // if a passport cred, show it specially, indicate no edit allowed
       if (lR == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD) {
            // load string and display message box
            TCHAR szMsg[MAX_STRING_SIZE];
            TCHAR szTitle[MAX_STRING_SIZE];
            LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
            LoadString ( m_hInst, IDS_PASSPORT, szMsg, MAX_STRING_SIZE );
            MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
            fNew = FALSE;
            return TRUE;
       }
#endif
#endif
   }

   // cred is selected, not special type.  Attempt to read it
   
   if (FALSE == gTestReadCredential()) {
       fNew = FALSE;
       return TRUE;
   }
   g_AKdlg = new C_AddKeyDlg(g_hMainDlg,g_hInstance,IDD_ADDCRED,NULL);
   if (NULL == g_AKdlg) {
        // failed to instantiate add/new dialog
        fNew = FALSE;
       if (g_pExistingCred) CredFree(g_pExistingCred);
       g_pExistingCred = NULL;
        return TRUE;

   }
   else {
       // read OK, dialog OK, proceed with edit dlg
       g_AKdlg->m_bEdit = TRUE;   
       INT_PTR nResult = g_AKdlg->DoModal((LPARAM)g_AKdlg);
       // a credential name may have changed, so reload the list
       delete g_AKdlg;
       g_AKdlg = NULL;
       if (g_pExistingCred) CredFree(g_pExistingCred);
       g_pExistingCred = NULL;
       fNew = FALSE;
   }
   return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  OnCommand
//
//  Route WM_COMMAND message to appropriate handlers.
//
//  parameters:
//      wNotifyCode     code describing action that has occured
//      wSenderId       id of the control sending the message, if the message
//                      is from a dialog
//      hwndSender      window handle of the window sending the message if the
//                      message is not from a dialog
//
//  returns:
//      TRUE            if the message was processed completely
//      FALSE           if Windows is to process the message
//
//////////////////////////////////////////////////////////////////////////////

BOOL
C_KeyringDlg::OnHelpInfo(LPARAM lp) {

    HELPINFO* pH;
    INT iMapped;
    pH = (HELPINFO *) lp;
    HH_POPUP stPopUp;
    RECT rcW;
    UINT gID;

    gID = pH->iCtrlId;
    iMapped = MapID(gID);
    
    if (iMapped == 0) return TRUE;
    
    if (IDS_NOHELP != iMapped) {

      memset(&stPopUp,0,sizeof(stPopUp));
      stPopUp.cbStruct = sizeof(HH_POPUP);
      stPopUp.hinst = g_hInstance;
      stPopUp.idString = iMapped;
      stPopUp.pszText = NULL;
      stPopUp.clrForeground = -1;
      stPopUp.clrBackground = -1;
      stPopUp.rcMargins.top = -1;
      stPopUp.rcMargins.bottom = -1;
      stPopUp.rcMargins.left = -1;
      stPopUp.rcMargins.right = -1;
      // bug 393244 - leave NULL to allow HHCTRL.OCX to get font information of its own,
      //  which it needs to perform the UNICODE to multibyte conversion. Otherwise, 
      //  HHCTRL must convert using this font without charset information.
      stPopUp.pszFont = NULL;
      if (GetWindowRect((HWND)pH->hItemHandle,&rcW)) {
          stPopUp.pt.x = (rcW.left + rcW.right) / 2;
          stPopUp.pt.y = (rcW.top + rcW.bottom) / 2;
      }
      else stPopUp.pt = pH->MousePos;
      HtmlHelp((HWND) pH->hItemHandle,NULL,HH_DISPLAY_TEXT_POPUP,(DWORD_PTR) &stPopUp);
    }
    return TRUE;
}

#if 1
BOOL 
C_KeyringDlg::OnHelpButton(void) {
    return FALSE;
}
#else
BOOL
C_KeyringDlg::OnHelpButton(void) {
    TCHAR rgc[MAX_PATH + 1];
    TCHAR rgcHelpFile[]=TEXT("\\keyhelp.chm");
    
    GetSystemDirectory(rgc,MAX_PATH);
    if (_tcslen(rgc) + _tcslen(rgcHelpFile) > MAX_PATH) return FALSE;
    _tcscat(rgc,rgcHelpFile);

    HWND hwnd = (m_hwnd,rgc,HH_DISPLAY_TOC,NULL);
    if (NULL != hwnd) return TRUE;
    return FALSE;
}
#endif

BOOL
C_KeyringDlg::OnCommand(
    WORD                wNotifyCode,
    WORD                wSenderId,
    HWND                hwndSender
    )
{

    // Was the message handled?
    //
    BOOL fHandled = FALSE;
    HWND hB;
    BOOL f = TRUE;

    switch (wSenderId)
    {
    case IDC_HELPKEY:
        OnHelpButton();
        break;
        
    case IDC_KEYLIST:
        if (LBN_SELCHANGE == wNotifyCode)
            break;

        if (LBN_DBLCLK == wNotifyCode) {
            fHandled = DoEdit();
            BuildList();                // targetname could have changed
            SetCurrentKey(g_CurrentKey);
            break;
        }
    case IDCANCEL:
    case IDOK:
        if (BN_CLICKED == wNotifyCode)
        {
            
            OnOK( );
            fHandled = TRUE;
        }
        break;
        
   case IDC_EDITKEY:
        {
            fHandled = DoEdit();
            BuildList();                // targetname could have changed
            SetCurrentKey(g_CurrentKey);
            break;
        }

   // NEW and DELETE can alter the count of creds, and the button population
    
   case IDC_NEWKEY:
       {
           if (fNew) break;
           fNew = TRUE;
           g_pExistingCred = NULL;
           g_AKdlg = new C_AddKeyDlg(g_hMainDlg,g_hInstance,IDD_ADDCRED,NULL);
           if (NULL == g_AKdlg) {
                fNew = FALSE;
                fHandled = TRUE;
                break;
           }
           else {
               g_AKdlg->m_bEdit = FALSE;   
               INT_PTR nResult = g_AKdlg->DoModal((LPARAM)g_AKdlg);
               // a credential name may have changed
               delete g_AKdlg;
               g_AKdlg = NULL;
               BuildList();
               SetCurrentKey(g_CurrentKey);
               fNew = FALSE;
           }
           break;
       }
       break;
       
   case IDC_DELETEKEY:
       DeleteKey();             // frees g_pExistingCred as a side effect
       // refresh list display
       BuildList();
       SetCurrentKey(g_CurrentKey);
       break;

    }   //  switch

    return fHandled;

}   //  C_KeyringDlg::OnCommand



//////////////////////////////////////////////////////////////////////////////
//
//  OnOK
//
//  Validate user name, synthesize computer name, and destroy dialog.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
C_KeyringDlg::OnOK( )
{
    ASSERT(::IsWindow(m_hwnd));
    EndDialog(IDOK);
}   //  C_KeyringDlg::OnOK

//////////////////////////////////////////////////////////////////////////////
//
// ToolTip Support
//
//
//////////////////////////////////////////////////////////////////////////////

TCHAR szTipString[500];
WNDPROC lpfnOldWindowProc = NULL;

// Derive a bounding rectangle for the nth element of a list box, 0 based.
// Refuse to generate rectangles for nonexistent elements.  Return TRUE if a
//  rectangle was generated, otherwise FALSE.
//
// Get item number from pD->lParam
// Fetch that text string from listbox at pD->hwnd
// trim suffix
// Call translation API
// Write back the string
BOOL
SetToolText(NMTTDISPINFO *pD) {
    CREDENTIAL *pCred = NULL;       // used to read cred under mouse ptr
    INT_PTR iWhich;                 // which index into list
    HWND hLB;                       // list box hwnd
    //NMHDR *pHdr;                    // notification msg hdr
    TCHAR rgt[500];                 // temp string for tooltip
    TCHAR szCredName[500];          // credname
    TCHAR *pszTargetName;           // ptr to target name in pCred
    INT iLen;
    DWORD dwType;                   // type of target cred
    TCHAR       *pC;                // used for suffix trimming
    INT_PTR     iIndex,iWhere;
    BOOL        f;                  // used for suffix trimming
    LRESULT     lRet;               // api ret value
    TCHAR       szTitle[CRED_MAX_STRING_LENGTH]; //  window title string
    ULONG ulOutSize;                // ret from CredpValidateTargetName()
    WILDCARD_TYPE OutType;          // enum type to receive ret from api
    UNICODE_STRING OutUString;      // UNICODESTRING to package ret from api
    WCHAR *pwc;
    UINT iString;                 // resource # of string
    TCHAR rgcFormat[500];           // Hold tooltip template string
    NTSTATUS ns;


    //pHdr = &(pD->hdr);
    hLB = GetDlgItem(g_hMainDlg,IDC_KEYLIST);
    
    iWhich = SendMessage(hLB,LB_GETTOPINDEX,0,0);
    iWhich += pD->lParam;
    
#ifdef LOUDLY
    TCHAR rga[100];
    _stprintf(rga,L"Text reqst for %d\n",iWhich);
    OutputDebugString(rga);
#endif

    // Read the indicated cred from the store, by first fetching the name string and type
    //  from the listbox
    lRet = SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETTEXT,iWhich,(LPARAM) szCredName);
    // Nonexistant item return LB_ERR, not zero characters!
    if (LB_ERR == lRet) return FALSE;
    if (lRet == 0) return FALSE;       // zero characters returned
    dwType = (DWORD) SendDlgItemMessage(g_hMainDlg,IDC_KEYLIST,LB_GETITEMDATA,iWhich,0);
#ifdef LOUDLY
    OutputDebugString(L"Target: ");
    OutputDebugString(szCredName);
    OutputDebugString(L"\n");
#endif
    // null term the targetname, trimming the suffix if there is one
    pC = _tcschr(szCredName,g_rgcCert[0]);
    if (pC) {
        pC--;
        *pC = 0x0;               // null terminate namestring
    }
    
#ifdef LOUDLY
    OutputDebugString(L"Trimmed target: ");
    OutputDebugString(szCredName);
    OutputDebugString(L"\n");
#endif

    // watch out for special cred
    if (dwType == SESSION_FLAG_VALUE) {
        _tcscpy(szCredName,CRED_SESSION_WILDCARD_NAME);
        dwType = CRED_TYPE_DOMAIN_PASSWORD;
    }
    // Attempt to read the credential from the store
    // The returned credential will have to be freed if leaving this block
    f = (CredRead(szCredName,
             (ULONG) dwType ,
             0,
             &pCred));
    if (!f) return FALSE;        // if read fails, forget filling the dialog
#ifdef LOUDLY
    if (f) OutputDebugString(L"Successful Cred Read\n");
#endif
    // clear tip strings
    szTipString[0] = 0;
    rgt[0] = 0;

#ifndef SIMPLETOOLTIPS
    pszTargetName = pCred->TargetName;
    if (NULL == pszTargetName) return FALSE;

    ns = CredpValidateTargetName(
                            pCred->TargetName,
                            pCred->Type,
                            MightBeUsernameTarget,
                            NULL,
                            NULL,
                            &ulOutSize,
                            &OutType,
                            &OutUString);

    if (!SUCCEEDED(ns)) return FALSE;

    pwc = OutUString.Buffer;

    switch (OutType) {
        case WcDfsShareName:
            iString = IDS_TIPDFS;
            break;
        case WcServerName:
            iString = IDS_TIPSERVER;
            break;
        case WcServerWildcard:
            iString = IDS_TIPTAIL;
            pwc++;              // trim off the leading '.'
            break;
        case WcDomainWildcard:
            iString = IDS_TIPDOMAIN;
            break;
        case WcUniversalSessionWildcard:
            iString = IDS_TIPDIALUP;
            break;
        case WcUniversalWildcard:
            iString = IDS_TIPOTHER;
            break;
        case WcUserName:
            iString = IDS_TIPUSER;
            break;
        default:
            iString = -1;
            break;
    }

    // Show tip text unless we fail to get the string
    // On fail, show the username

    if (0 != LoadString(g_hInstance,iString,rgcFormat,500))
        _stprintf(rgt,rgcFormat,pwc);
    else 
#endif
        if (0 != LoadString(g_hInstance,IDS_LOGASUSER,rgcFormat,500))
            _stprintf(rgt,rgcFormat,iWhich,pCred->UserName);
        else rgt[0] = 0;
        
#ifdef LOUDLY
    OutputDebugString(L"Tip text:");
    //OutputDebugString(pCred->UserName);
    OutputDebugString(rgt);
    OutputDebugString(L"\n");
#endif
    if (rgt[0] == 0) {
        if (pCred) CredFree(pCred);
        return FALSE;
    }
    //_tcscpy(szTipString,pCred->UserName);    // copy to a more persistent buffer
    _tcscpy(szTipString,rgt);    // copy to a more persistent buffer
    pD->lpszText = szTipString;  // point the response to it
    pD->hinst = NULL;
    if (pCred) CredFree(pCred);
    return TRUE;
}

LRESULT CALLBACK ListBoxSubClassFunction(HWND hW,WORD Message,WPARAM wparam,LPARAM lparam) {
    if (Message == WM_NOTIFY) {
        if ((int) wparam == IDC_KEYLIST) {
            NMHDR *pnm = (NMHDR *) lparam;
            if (pnm->code == TTN_GETDISPINFO) {
                NMTTDISPINFO *pDi;
                pDi = (NMTTDISPINFO *) pnm;
                SetToolText(pDi);
            }
        }
    }
    return CallWindowProc(lpfnOldWindowProc,hW,Message,wparam,lparam);
}

BOOL
C_KeyringDlg::InitTooltips(void) {
    TOOLINFO ti;
    HWND hw;
    memset(&ti,0,sizeof(TOOLINFO));
    ti.cbSize = sizeof(TOOLINFO);
    INT n = 0;
    BOOL fGo;
    RECT rTip;
    RECT rLB;   // list box bounding rect for client portion
    TCHAR szTemp[200];
    HWND hLB = GetDlgItem(m_hDlg,IDC_KEYLIST);
    if (NULL == hLB) return FALSE;
    HWND hwndTip = CreateWindowEx(NULL,TOOLTIPS_CLASS,NULL,
                     WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                     CW_USEDEFAULT,CW_USEDEFAULT,
                     CW_USEDEFAULT,CW_USEDEFAULT,
                     m_hDlg,NULL,m_hInstance,
                     NULL);
    if (NULL == hwndTip) {
        return FALSE;
    }
    SetWindowPos(hwndTip,HWND_TOPMOST, 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);  

    // Subclass the list box here in order to get the TTN_GETDISPINFO notification
    lpfnOldWindowProc = (WNDPROC) SetWindowLongPtr(hLB,GWLP_WNDPROC,(LONG_PTR) ListBoxSubClassFunction);
    INT_PTR iHeight = SendMessage(hLB,LB_GETITEMHEIGHT,0,0);
    if (LB_ERR == iHeight) return FALSE;
    if (!GetClientRect(hLB,&rLB)) return FALSE;
    if (iHeight == 0) return FALSE;
    INT_PTR m = rLB.bottom - rLB.top;   // unit count client area height
    m = m/iHeight;                  // find out how many items
    INT_PTR i;                          // loop control
    LONG itop = 0;                   // top of tip item rect
    
    for (i=0 ; i < m ; i++) {
    
        ti.uFlags = TTF_SUBCLASS;
        ti.hwnd = hLB;            // window that gets the TTN_GETDISPINFO
        ti.uId = IDC_KEYLIST;
        ti.hinst = m_hInstance;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        
        ti.rect.top =    itop;
        ti.rect.bottom = itop + (LONG) iHeight - 1;
        ti.rect.left =   rLB.left;
        ti.rect.right =  rLB.right;

        itop += (LONG) iHeight;

        ti.lParam = (LPARAM) n++;
        
#ifdef LOUDLY2
        OutputDebugString(L"Adding a tip control region\n");
        _stprintf(szTemp,L"top = %d bottom = %d left = %d right = %d\n",ti.rect.top,ti.rect.bottom,ti.rect.left,ti.rect.right);
        OutputDebugString(szTemp);
#endif
        // Add the keylist to the tool list as a single unit
        SendMessage(hwndTip,TTM_ADDTOOL,(WPARAM) 0,(LPARAM)(LPTOOLINFO)&ti);
    }
    return TRUE;
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//////////////////////////////////////////////////////////////////////////////
//
//  C_ChangePasswordDlg
//
//  Constructor.
//
//  parameters:
//      hwndParent      parent window for the dialog (may be NULL)
//      hInstance       instance handle of the parent window (may be NULL)
//      lIDD            dialog template id
//      pfnDlgProc      pointer to the function that will process messages for
//                      the dialog.  if it is NULL, the default dialog proc
//                      will be used.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
C_ChangePasswordDlg::C_ChangePasswordDlg(
    HWND                hwndParent,
    HINSTANCE           hInstance,
    LONG                lIDD,
    DLGPROC             pfnDlgProc  //   = NULL
    )
:   C_Dlg(hwndParent, hInstance, lIDD, pfnDlgProc)
{
   m_hInst = hInstance;
}   //  C_ChangePasswordDlg::C_ChangePasswordDlg

//////////////////////////////////////////////////////////////////////////////
//
//  OnInitDialog
//
//  Dialog control and data initialization.
//
//  parameters:
//      hwndDlg         window handle of the dialog box
//      hwndFocus       window handle of the control that will receive focus
//
//  returns:
//      TRUE            if the system should set the default keyboard focus
//      FALSE           if the keyboard focus is set by this app
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_ChangePasswordDlg::OnInitDialog(
    HWND                hwndDlg,
    HWND                hwndFocus
    )
{
   TCHAR szMsg[CRED_MAX_USERNAME_LENGTH];
   TCHAR szTitle[MAX_STRING_SIZE];
   CREDENTIAL *pOldCred = NULL;
   BOOL bResult;
   TCHAR *pC;

   C_Dlg::OnInitDialog(hwndDlg, hwndFocus);

   CenterWindow();

   SetFocus (GetDlgItem ( hwndDlg, IDC_OLD_PASSWORD));
   m_hDlg = hwndDlg;

   // read the currently selected credential, read the cred to get the username,
   // extract the domain, and set the text to show the affected domain.
   bResult = CredRead(g_szTargetName,CRED_TYPE_DOMAIN_PASSWORD,0,&pOldCred);
   if (bResult != TRUE) {
      LoadString ( m_hInst, IDS_PSWFAILED, szMsg, MAX_STRING_SIZE );
      LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
      MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
      EndDialog(IDOK);
      return TRUE;
   
   }

   // Get the domain and user names from the username string in the credential
   // handle domain\user, domain.etc.etc\user, user@domain.etc.etc
   _tcscpy(m_szFullUsername,pOldCred->UserName);
   _tcscpy(szMsg,pOldCred->UserName);       // use szMsg for scratch
   pC = _tcschr(szMsg,((TCHAR)'\\'));
   if (NULL != pC) {
        // name is format domain\something
        *pC = 0;
        _tcscpy(m_szDomain,szMsg);
        _tcscpy(m_szUsername, (pC + 1));
   }
   else {
        // see if name@something
        pC = _tcschr(szMsg,((TCHAR)'@'));
        if (NULL == pC) {
           LoadString ( m_hInst, IDS_DOMAINFAILED, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
           if (pOldCred) CredFree(pOldCred);
           return TRUE; // don't call EndDialog()
        }
        *pC = 0;
        _tcscpy(m_szDomain,(pC + 1));
        _tcscpy(m_szUsername, szMsg);
   }

   if (pOldCred) CredFree(pOldCred);

   if (0 != LoadString(g_hInstance,IDS_CPLABEL,szTitle,MAX_STRING_SIZE)) {
        _tcscat(szTitle,m_szDomain);
        SetDlgItemText(m_hwnd,IDC_CPLABEL,szTitle);
   }
   return TRUE;
}   //  C_ChangePasswordDlg::OnInitDialog

//////////////////////////////////////////////////////////////////////////////
//
//  OnCommand
//
//  Route WM_COMMAND message to appropriate handlers.
//
//  parameters:
//      wNotifyCode     code describing action that has occured
//      wSenderId       id of the control sending the message, if the message
//                      is from a dialog
//      hwndSender      window handle of the window sending the message if the
//                      message is not from a dialog
//
//  returns:
//      TRUE            if the message was processed completely
//      FALSE           if Windows is to process the message
//
//////////////////////////////////////////////////////////////////////////////
BOOL
C_ChangePasswordDlg::OnCommand(
    WORD                wNotifyCode,
    WORD                wSenderId,
    HWND                hwndSender
    )
{
    // Was the message handled?
    //
    BOOL                fHandled = FALSE;

    switch (wSenderId)
    {
    case IDOK:
        if (BN_CLICKED == wNotifyCode)
        {
            OnOK( );
            fHandled = TRUE;
        }
        break;
    case IDCANCEL:
        if (BN_CLICKED == wNotifyCode)
        {
            EndDialog(IDCANCEL);
            fHandled = TRUE;
        }
        break;

    }   //  switch

    return fHandled;

}   //  C_ChangePasswordDlg::OnCommand



////////////////////////////////////////////////////////////////////////////
//
//  OnOK
//
//  Validate user name, synthesize computer name, and destroy dialog.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
C_ChangePasswordDlg::OnOK( )
{
   DWORD dwBytes;
   TCHAR szMsg[CRED_MAX_USERNAME_LENGTH];
   TCHAR szTitle[MAX_STRING_SIZE];
   BOOL  bDefault;
   ULONG Error = 0;
   LRESULT lResult;

   BOOL bResult;

   ASSERT(::IsWindow(m_hwnd));

   // get old and new passwords from the dialog box
   GetDlgItemText ( m_hDlg, IDC_OLD_PASSWORD, m_szOldPassword, MAX_STRING_SIZE );
   GetDlgItemText ( m_hDlg, IDC_NEW_PASSWORD, m_szNewPassword, MAX_STRING_SIZE );
   GetDlgItemText ( m_hDlg, IDC_CONFIRM_PASSWORD, m_szConfirmPassword, MAX_STRING_SIZE );
   if ( wcslen ( m_szOldPassword ) == 0 && wcslen ( m_szNewPassword ) ==0 && wcslen (m_szConfirmPassword) == 0 )
   {
       // must have something filled in
       return; 
   }
   else if ( wcscmp ( m_szNewPassword, m_szConfirmPassword) != 0 )
   {
       LoadString ( m_hInst, IDS_NEWPASSWORDNOTCONFIRMED, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       return; // don't call EndDialog()

   }
   else
   {
       HCURSOR hCursor, hOldCursor;

       hOldCursor = NULL;
       hCursor = ::LoadCursor ( m_hInst, IDC_WAIT );
       if ( hCursor )
       {
           hOldCursor = ::SetCursor ( hCursor );
       }
       // let's try changing it
       // The targetname is not used.  Only the domain name the username, and
       //  old/new passwords are used
#ifdef LOUDLY
       OutputDebugString(L"Changing password on the domain :");
       OutputDebugString(m_szDomain);
       OutputDebugString(L" for ");
       OutputDebugString(m_szUsername);
       OutputDebugString(L" to ");
       OutputDebugString(m_szNewPassword);
       OutputDebugString(L"\n");
#endif
// gm: pass full username and crack it in NetUserChangePasswordEy, so that routine can 
//  decide whether we are facing a Kerberos domain
       Error = NetUserChangePasswordEy ( NULL, m_szFullUsername, m_szOldPassword, m_szNewPassword );
       if ( hOldCursor )
           ::SetCursor ( hOldCursor );
   }

   if ( Error == NERR_Success )
   {
#ifdef LOUDLY
        OutputDebugString(L"Remote password set succeeded\n");
#endif
        // Store the new credential in the keyring.  It will overlay
        //  a previous version if present
        // Note that the user must have knowledge of and actually type in
        //  the old password as well as the new password.  If the user
        //  elects to update only the local cache, the old password 
        //  information is not actually used.
        // CredWriteDomainCredentials() is used
        // m_szDomain holds the domain name
        // m_szUsername holds the username
        // m_szNewPassword holds the password
        CREDENTIAL                    stCredential;
        UINT                          cbPassword;

        memcpy((void *)&stCredential,(void *)g_pExistingCred,sizeof(CREDENTIAL));
        // password length does not include zero term
        cbPassword = _tcslen(m_szNewPassword) * sizeof(TCHAR);
        // Form the domain\username composite username
        stCredential.Type = CRED_TYPE_DOMAIN_PASSWORD;
        stCredential.TargetName = g_szTargetName;
        stCredential.CredentialBlob = (unsigned char *)m_szNewPassword;
        stCredential.CredentialBlobSize = cbPassword;
        stCredential.UserName = m_szFullUsername;
        stCredential.Persist = g_dwPersist;


        bResult = CredWrite(&stCredential,0);

        if (bResult) {
           LoadString ( m_hInst, IDS_DOMAINCHANGE, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
        }
        else {
           LoadString ( m_hInst, IDS_LOCALFAILED, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
        }

        // BUGBUG - what to do if the local update operation fails?
        // This is not a very big failure, as the first prompt would 
        //  ripple through all domain\username matching creds on the 
        //  keyring and update them later.  You're pretty much stuck
        //  here, since the domain probably will not let you reset the
        //  psw to the old value.
   }
   else
   {
       // Attempt to be specific about failure to change the psw on the
       // remote system
#ifdef LOUDLY
       OutputDebugString(L"Remote password set failed\n");
#endif       
       if (Error == ERROR_INVALID_PASSWORD) {
           LoadString ( m_hInst, IDS_CP_INVPSW, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else if (Error == NERR_UserNotFound) {
           LoadString ( m_hInst, IDS_CP_NOUSER, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else if (Error == NERR_PasswordTooShort) {
           LoadString ( m_hInst, IDS_CP_BADPSW, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else if (Error == NERR_InvalidComputer) {
           LoadString ( m_hInst, IDS_CP_NOSVR, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else if (Error == NERR_NotPrimary) {
           LoadString ( m_hInst, IDS_CP_NOTALLOWED, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
       else  {
           // Reaching here signifies a failure to set the remote domain
           //  password for more general reasons
           LoadString ( m_hInst, IDS_DOMAINFAILED, szMsg, MAX_STRING_SIZE );
           LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
           MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       }
   }

    // clean any psw buffers, release the old cred, and go.
    memset(m_szOldPassword,0,sizeof(m_szOldPassword));
    memset(m_szNewPassword,0,sizeof(m_szNewPassword));   
    EndDialog(IDOK);
    
}   //  C_ChangePasswordDlg::OnOK

void C_AddKeyDlg::AdviseUser(void) {
    DWORD dwErr;
    TCHAR szMsg[MAX_STRING_SIZE];
    TCHAR szTitle[MAX_STRING_SIZE];
    
    dwErr = GetLastError();

    if (dwErr == ERROR_NO_SUCH_LOGON_SESSION) {
       LoadString ( m_hInst, IDS_NOLOGON, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       // return leaving credential dialog up
       return;
    }
    else if (dwErr == ERROR_BAD_USERNAME) {
       LoadString ( m_hInst, IDS_BADUNAME, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       // return leaving credential dialog up
       return;
    }
    else if (dwErr == ERROR_INVALID_PASSWORD) {
       LoadString ( m_hInst, IDS_BADPASSWORD, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       // return leaving credential dialog up
       return;
    }
    else {
        // ERROR_INVALID_PARAMETER, ERROR_INVALID_FLAGS, etc
       LoadString ( m_hInst, IDS_ADDFAILED, szMsg, MAX_STRING_SIZE );
       LoadString ( m_hInst, IDS_APP_NAME, szTitle, MAX_STRING_SIZE );
       MessageBox ( m_hDlg,  szMsg, szTitle, MB_OK );
       // return leaving credential dialog up
       return;
    }
}

//
///// End of file: krDlg.cpp   ///////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\krdlg.h ===
#ifndef _KRDLG_H_
#define _KRDLG_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    krdlg.h

Abstract:

    keyring dialog class definitions

Author:

    johnhaw     991118  created
    georgema    000310  modified

Environment:

Revision History:

--*/

#include "switches.h"

#include "Dlg.h"
#include <scuisupp.h>
#include <wincred.h>

#define MAX_STRING_SIZE    256


void CheckForCredentialExpiry( HINSTANCE hInst, HWND hWnd );


//////////////////////////////////////////////////////////////////////////////
//
// C_ChangePasswordDlg
//
class C_ChangePasswordDlg 
:   public C_Dlg
{
public:                 // operations
    C_ChangePasswordDlg(
        HWND                hwndParent,
        HINSTANCE           hInstance,
        LONG                lIDD,
        DLGPROC             pfnDlgProc = NULL
        );

    ~C_ChangePasswordDlg( )
    {
    }   //  ~C_ChangePasswordDlg

    virtual BOOL
    OnInitDialog(
        HWND                hwndDlg,
        HWND                hwndFocus
        );

    virtual BOOL
    OnCommand(
        WORD                wNotifyCode,
        WORD                wSenderId,
        HWND                hwndSender
        );

    virtual void
    AssertValid( ) const
    {
        C_Dlg::AssertValid( );
    }   //  AssertValid

protected:              // operations

public:              // data

   HINSTANCE m_hInst;
   HWND m_hDlg;

   TCHAR m_szFullUsername[MAX_STRING_SIZE];
   TCHAR m_szUsername[MAX_STRING_SIZE];
   TCHAR m_szDomain[MAX_STRING_SIZE];
   TCHAR m_szOldPassword[MAX_STRING_SIZE];
   TCHAR m_szNewPassword[MAX_STRING_SIZE];
   TCHAR m_szConfirmPassword[MAX_STRING_SIZE];

   BOOL m_bIsDefault;

   
private:                // operations

    virtual void
    OnOK( );

    // Explicitly disallow copy constructor and assignment operator.
    //
    C_ChangePasswordDlg(
        const C_ChangePasswordDlg&      rhs
        );

    C_ChangePasswordDlg&
    operator=(
        const C_ChangePasswordDlg&      rhs
        );

private:                // data

};  //  C_ChangePasswordDlg




//////////////////////////////////////////////////////////////////////////////
//
// C_KeyringDlg
//

class C_KeyringDlg 
:   public C_Dlg
{
public:                 // operations
    C_KeyringDlg(
        HWND                hwndParent,
        HINSTANCE           hInstance,
        LONG                lIDD,
        DLGPROC             pfnDlgProc = NULL
        );

    // Perform miscellaneous cleanups required as the dialog is
    //  destroyed

    ~C_KeyringDlg( )
    {
    }   //  ~C_KeyringDlg

    virtual BOOL
    OnInitDialog(
        HWND                hwndDlg,
        HWND                hwndFocus
        );

    virtual BOOL
    OnDestroyDialog(void);
    
    virtual BOOL
    OnCommand(
        WORD                wNotifyCode,
        WORD                wSenderId,
        HWND                hwndSender
        );

// TOOL TIP functions

    virtual BOOL
    InitTooltips(void);

// HELP functions

    virtual BOOL
    OnHelpInfo(
        LPARAM lp
        );


    virtual UINT
    MapID(UINT uid);
    

    virtual void
    AssertValid( ) const
    {
        C_Dlg::AssertValid( );
    }   //  AssertValid

    virtual BOOL
    OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam
        );

    // Register the windows messages expected from the smartcard 
    //  subsystem
    BOOL 
    RegisterMessages(void);

protected:              

    HINSTANCE m_hInst;
    HWND    m_hDlg;
    BOOL    fInit;

   
private:                // operations

    virtual void
    OnOK( );

    BOOL DoEdit(void);

    void BuildList();
    void SetCurrentKey(LONG_PTR iKey);
    void DeleteKey();
    void OnChangePassword();
    LONG_PTR C_KeyringDlg::GetCredentialType();
    BOOL
    OnHelpButton(void);

    // Explicitly disallow copy constructor and assignment operator.
    //
    C_KeyringDlg(
        const C_KeyringDlg&      rhs
        );

    C_KeyringDlg&
    operator=(
        const C_KeyringDlg&      rhs
        );

private:                // data

};  //  C_KeyringDlg



//////////////////////////////////////////////////////////////////////////////
//
// C_AddKeyDlg
//

class C_AddKeyDlg 
:   public C_Dlg
{
public:                 // operations
    C_AddKeyDlg(
        HWND                hwndParent,
        HINSTANCE           hInstance,
        LONG                lIDD,
        DLGPROC             pfnDlgProc = NULL
        );

    ~C_AddKeyDlg( )
    {
    }   //  ~C_AddKeyDlg

    virtual BOOL
    OnInitDialog(
        HWND                hwndDlg,
        HWND                hwndFocus
        );

    virtual BOOL
    OnDestroyDialog(void);

    virtual BOOL
    OnCommand(
        WORD                wNotifyCode,
        WORD                wSenderId,
        HWND                hwndSender
        );

    virtual BOOL
    OnHelpInfo(
        LPARAM lp
        );


    virtual UINT
    MapID(
        UINT uid
    );
    
virtual void
    AssertValid( ) const
    {
        C_Dlg::AssertValid( );
    }   //  AssertValid

    virtual BOOL
    OnAppMessage(
        UINT                uMessage,
        WPARAM              wparam,
        LPARAM              lparam
        );

    void 
    AdviseUser(void);

    BOOL
    AddItem(TCHAR *psz,INT iImageIndex,INT *pIndexOut);

    BOOL 
    SetItemData(INT_PTR iIndex,LPARAM dwData);

    BOOL 
    GetItemData(INT_PTR iIndex,LPARAM *dwData);

    BOOL 
    SetItemIcon(INT iIndex,INT iWhich);

    void 
    UpdateSCard(INT,CERT_ENUM *pCE);

    void 
    SaveName(void);

    void 
    RestoreName(void);

    void
    ShowDescriptionText(DWORD,DWORD);
    
public:
    // Public data members
    BOOL    m_bEdit;            // set outside the class 
    HWND    m_hDlg;             // used by C_KeyringDlg for g_wmUpdate
    
private:

    void 
    EditFillDialog(void);

    HWND    m_hwndTName;
    HWND    m_hwndCred;
    HWND    m_hwndDomain;
    HWND    m_hwndChgPsw;
    HWND    m_hwndPswLbl;
    HWND    m_hwndDescription;

    INT     m_iUNCount;
    TCHAR   *pUNList;

    HINSTANCE m_hInst;
    DWORD   m_dwOldType;
    TCHAR   m_szUsername[CRED_MAX_USERNAME_LENGTH];
    TCHAR   m_szPassword[MAX_STRING_SIZE];
    TCHAR   m_szDomain[MAX_STRING_SIZE];

   
private:                // operations

    void OnChangePassword();

    DWORD
    SetPersistenceOptions(void);
    
    virtual void
    OnOK( );

    // Explicitly disallow copy constructor and assignment operator.
    //
    C_AddKeyDlg(
        const C_AddKeyDlg&      rhs
        );

    C_AddKeyDlg&
    operator=(
        const C_AddKeyDlg&      rhs
        );

};  //  C_AddKeyDlg



#endif  //  _KRDLG_H_

//
///// End of file: KrDlg.h   ///////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\keymgr.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    KEYMGR.CPP

Abstract:

    Keyring WinMain() and application support
     
Author:

    990917  johnhaw Created. 
    georgema        000310  updated
    georgema        000501  used to be EXE, changed to CPL

Comments:
    This executable is the control panel applet to allow a user some control 
    over the contents of the Windows Keyring, the so-called "Geek UI".  It was 
    originally an EXE, but that architecture is not as optimized for merging 
    with other control panel applets.  It has been changed to a CPL executable, 
    and can be either left as a CPL if it is desired that it should show up 
    automatically in the master control panel window, or rahter renamed to 
    a DLL file extension if it is desired that a control panel applet container
    application should load it explicitly without it otherwise being visible 
    to the system.

Environment:
    Win98, Win2000

Revision History:

--*/

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)


//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <windows.h>
#include <tchar.h>
#include <stdlib.h>
#include <cpl.h>
#include "Dlg.h"
#include "Res.h"
#include "keymgr.h"
#include "krDlg.h"
#include <wincrui.h>
#include "switches.h"
#include <shfusion.h>

//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//
static const char       _THIS_FILE_[ ] = __FILE__;
//static const WORD       _THIS_MODULE_ = LF_MODULE_UPGRADE;

//////////////////////////////////////////////////////////////////////////////
//
//  Global state info
//
HINSTANCE               g_hInstance = NULL;
C_KeyringDlg *pDlg = NULL;
void WINAPI KRShowKeyMgr(HWND,HINSTANCE,LPWSTR,int);

extern "C"LONG APIENTRY CPlApplet(HWND hwndCPl,UINT uMsg,LPARAM lParam1,LPARAM lParam2)
{
    INT_PTR nResult;
    CPLINFO *lpCPlInfo;

    // Handle commands to this dll/cpl from the enclosing presentation app.
    // Default return from any command is 0 (success), except those commands
    //  which ask for specific data in the return value
    
    switch(uMsg) {
        case CPL_INIT:
            g_hInstance = GetModuleHandle(L"keymgr.dll");
            if (NULL == g_hInstance) {
#ifdef LOUDLY
                MessageBox(NULL,L"DLL Init",NULL,MB_OK);
#endif
                return FALSE;
            }
            return TRUE;
            break;
            
        case CPL_GETCOUNT:
            return 1;       // only 1 applet icon in this cpl file
            break;

        case CPL_NEWINQUIRE:
            break;
            
        case CPL_INQUIRE:
            lpCPlInfo = (CPLINFO *) lParam2;  // acquire ptr to target data 
            lpCPlInfo->lData = 0;             // no effect
            lpCPlInfo->idIcon = IDI_UPGRADE;  // store items needed to show the applet
            lpCPlInfo->idName = IDS_APP_NAME;
            lpCPlInfo->idInfo = IDS_APP_DESCRIPTION; // description string
            break;
            
        case CPL_DBLCLK:
#ifdef LOUDLY
                MessageBox(NULL,L"DLL Select",NULL,MB_OK);
#endif
            // user has selected this cpl applet - put up our dialog
            if (NULL == pDlg){
                KRShowKeyMgr(NULL,g_hInstance,NULL,0);
#if 0
                INITCOMMONCONTROLSEX stICC;
                BOOL fICC;
                stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
                stICC.dwICC = ICC_WIN95_CLASSES | ICC_STANDARD_CLASSES;
                fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
                if (fICC) OutputDebugString(L"Common control init OK\n");
                else OutputDebugString(L"Common control init FAILED\n");
#endif
                if (!CredUIInitControls()) return 1;
                pDlg = new C_KeyringDlg(NULL, g_hInstance, IDD_KEYRING, NULL);
                // nonzero return on failure to allocate the dialog object
                if (NULL == pDlg) return 1;
            	nResult = pDlg->DoModal((LPARAM)pDlg);
#endif
            }
            break;
            
        case CPL_STOP:
#ifdef LOUDLY
                MessageBox(NULL,L"DLL Stop",NULL,MB_OK);
#endif
            if (NULL != pDlg) {
                delete pDlg;
                pDlg = NULL;
            }
            break;
            
        case CPL_EXIT:
            break;
            
        default:
            break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\pswchg.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincred.h>
#include <align.h>
#include <lm.h>
#include <ntsecapi.h>
#include <dsgetdc.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// !!!!!
// this file is a duplicate of a nearly identical file in the credui project.  It should be removed when
// the implementation of NetUserChangePassword() is updated to handle unc names and MIT Kerberos
// realms properly.  For now, it wraps NetUserChangePassword() to handle the extra cases.

// Dependent libraries:
//  secur32.lib, netapi32.lib

// external fn:  NET_API_STATUS NetUserChangePasswordEy(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR)

BOOL 
IsMITName (
    LPCWSTR UserName
)
{
    BOOL fReturn = FALSE;
    HKEY MitKey;
    DWORD Index;
    PWSTR Realms;
    DWORD RealmSize;
    int err;
    DWORD NumRealms;
    DWORD MaxRealmLength;
    FILETIME KeyTime;
    WCHAR *szUncTail;
    
    if (NULL == UserName) return FALSE;
    
    szUncTail = wcschr(UserName,'@');
    if (NULL == szUncTail) return FALSE;
    szUncTail++;                        // point to char following @

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains"),
                0,
                KEY_READ,
                &MitKey );

    if ( err == 0 )
    {
#ifdef LOUDLY
        OutputDebugString(L"Kerberos domains key opened\n");
#endif
        err = RegQueryInfoKey( MitKey,
                               NULL,
                               NULL,
                               NULL,
                               &NumRealms,
                               &MaxRealmLength,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

        MaxRealmLength++ ;

        MaxRealmLength *= sizeof( WCHAR );

        Realms = (PWSTR) malloc(MaxRealmLength );


        if ( Realms)
        {
#ifdef LOUDLY
        OutputDebugString(L"Kerberos realms found\n");
#endif

            for ( Index = 0 ; Index < NumRealms ; Index++ )
            {
                RealmSize = MaxRealmLength ;

                err = RegEnumKeyEx( MitKey,
                                  Index,
                                  Realms,
                                  &RealmSize,
                                  NULL,
                                  NULL,
                                  NULL,
                                  &KeyTime );
                if (err == 0)
                {
#ifdef LOUDLY
                    OutputDebugString(L"Fetched realm: ");
                    OutputDebugString(Realms);
                    OutputDebugString(L"\n");
                    OutputDebugString(L"Username suffix: ");
                    OutputDebugString(szUncTail);
                    OutputDebugString(L"\n");
#endif
                    if (0 == _wcsicmp(szUncTail, Realms))
                    {
#ifdef LOUDLY
                        OutputDebugString(L"Username maps to an MIT realm\n");
#endif
                        fReturn = TRUE;
                        break;
                    }
                }
            }
        }
        free(Realms);
    }
    return fReturn;
}

NTSTATUS
MitChangePasswordEy(
    LPCWSTR       DomainName,
    LPCWSTR       UserName,
    LPCWSTR       OldPassword,
    LPCWSTR       NewPassword,
    NTSTATUS      *pSubStatus
    )
{
    HANDLE hLsa = NULL;
    NTSTATUS Status;
    NTSTATUS SubStatus;
    
    STRING Name;
    ULONG PackageId;
    
    PVOID Response = NULL ;
    ULONG ResponseSize;
    
    PKERB_CHANGEPASSWORD_REQUEST ChangeRequest = NULL;
    ULONG ChangeSize;
    
    UNICODE_STRING User,Domain,OldPass,NewPass;

    Status = LsaConnectUntrusted(&hLsa);
    if (!SUCCEEDED(Status)) goto Cleanup;
#ifdef LOUDLY
    OutputDebugString(L"We have an LSA handle\n");
#endif

    RtlInitString(
        &Name,
        MICROSOFT_KERBEROS_NAME_A
        );

    Status = LsaLookupAuthenticationPackage(
                hLsa,
                &Name,
                &PackageId
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#ifdef LOUDLY
    OutputDebugString(L"Authentication package found\n");
#endif

    RtlInitUnicodeString(
        &User,
        UserName
        );
    RtlInitUnicodeString(
        &Domain,
        DomainName
        );
    RtlInitUnicodeString(
        &OldPass,
        OldPassword
        );
    RtlInitUnicodeString(
        &NewPass,
        NewPassword
        );

    ChangeSize = ROUND_UP_COUNT(sizeof(KERB_CHANGEPASSWORD_REQUEST),4)+
                                    User.Length +
                                    Domain.Length +
                                    OldPass.Length +
                                    NewPass.Length ;
    ChangeRequest = (PKERB_CHANGEPASSWORD_REQUEST) LocalAlloc(LMEM_ZEROINIT, ChangeSize );

    if ( ChangeRequest == NULL )
    {
        Status = STATUS_NO_MEMORY ;
        goto Cleanup ;
    }

    ChangeRequest->MessageType = KerbChangePasswordMessage;

    ChangeRequest->AccountName = User;
    ChangeRequest->AccountName.Buffer = (LPWSTR) ROUND_UP_POINTER(sizeof(KERB_CHANGEPASSWORD_REQUEST) + (PBYTE) ChangeRequest,4);

    RtlCopyMemory(
        ChangeRequest->AccountName.Buffer,
        User.Buffer,
        User.Length
        );

    ChangeRequest->DomainName = Domain;
    ChangeRequest->DomainName.Buffer = ChangeRequest->AccountName.Buffer + ChangeRequest->AccountName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->DomainName.Buffer,
        Domain.Buffer,
        Domain.Length
        );

    ChangeRequest->OldPassword = OldPass;
    ChangeRequest->OldPassword.Buffer = ChangeRequest->DomainName.Buffer + ChangeRequest->DomainName.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->OldPassword.Buffer,
        OldPass.Buffer,
        OldPass.Length
        );

    ChangeRequest->NewPassword = NewPass;
    ChangeRequest->NewPassword.Buffer = ChangeRequest->OldPassword.Buffer + ChangeRequest->OldPassword.Length / sizeof(WCHAR);

    RtlCopyMemory(
        ChangeRequest->NewPassword.Buffer,
        NewPass.Buffer,
        NewPass.Length
        );


    //
    // We are running as the caller, so state we are impersonating
    //

    //ChangeRequest->Impersonating = TRUE;
#ifdef LOUDLY
    OutputDebugString(L"Attempting to call the authentication package\n");
#endif
    Status = LsaCallAuthenticationPackage(
                hLsa,
                PackageId,
                ChangeRequest,
                ChangeSize,
                &Response,
                &ResponseSize,
                &SubStatus
                );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
#ifdef LOUDLY
        WCHAR szsz[200];
        swprintf(szsz,L"Call failed. Status %x SubStatus %x\n",Status, SubStatus);
        OutputDebugString(szsz);
#endif
        if (NT_SUCCESS(Status))
        {
            Status = SubStatus;
            *pSubStatus = STATUS_UNSUCCESSFUL ;
        } 
        else 
        {
            *pSubStatus = SubStatus;
        }
    }

Cleanup:

    if (hLsa) LsaDeregisterLogonProcess(hLsa);

    if (Response != NULL) LsaFreeReturnBuffer(Response);
    if (ChangeRequest != NULL) LocalFree(ChangeRequest);
    
    return(Status);
}

/*

NetUserChangePasswordEy()

A wrapper function to superset the functionality of NetUserChangePassword(), specifically
by adding support for changing the account password for an MIT Kerberos principal.

This routine accepts:

1.  uncracked username, with NULL domain
2.  cracked username, with domain portion routed to the domain argument

In case 1, it handles all cases, including MIT realm password changes
In case 2, it will not handle MIT realms.  

Case 2 is provided for backwards compatibility with NetUserChangePassword().  It is intended
that callers should pass the uncracked name, and remove the cracking code from the client.

*/
NET_API_STATUS
NetUserChangePasswordEy (
    LPCWSTR domainname,
    LPCWSTR username,
    LPCWSTR oldpassword,
    LPCWSTR newpassword
)
{
    NTSTATUS ns;    // status from call
    NET_API_STATUS nas;
    NTSTATUS ss;    // substatus
#ifdef LOUDLY
    OutputDebugString(L"NetUserChangePasswordEy called for ");
    OutputDebugString(username);
    OutputDebugString(L"\n");
#endif
    // domainname may be a kerberos realm
    // If not a UNC name, call through to NetUserChangePassword
    // else
    //  locate UNC suffix
    //  search all domains returned by DsEnumerateDomainTrusts() for a match
    //  On match, if is kerberos realm, call MitChangePasswordEy()
    //  else call NetUserChangePassword
    if ((domainname == NULL) && IsMITName(username))
    {
        ns = MitChangePasswordEy(domainname, username, oldpassword, newpassword, &ss);
        // remap certain errors returned by MitChangePasswordEy to coincide with those of NetUserChangePassword
        if (NT_SUCCESS(ns)) nas = NERR_Success;
        else
        {
            switch (ns)
            {
                case STATUS_CANT_ACCESS_DOMAIN_INFO:
                case STATUS_NO_SUCH_DOMAIN:
                {
                    nas = NERR_InvalidComputer;
                    break;
                }
                case STATUS_NO_SUCH_USER:
                case STATUS_WRONG_PASSWORD_CORE:
                case STATUS_WRONG_PASSWORD:
                {
                    nas = ERROR_INVALID_PASSWORD;
                    break;
                }
                case STATUS_ACCOUNT_RESTRICTION:
                case STATUS_ACCESS_DENIED:
                case STATUS_BACKUP_CONTROLLER:
                {
                    nas = ERROR_ACCESS_DENIED;
                    break;
                }
                case STATUS_PASSWORD_RESTRICTION:
                {
                    nas = NERR_PasswordTooShort;
                    break;
                }
                        
                default:
                    nas = -1;       // will produce omnibus error message when found (none of the above)
                    break;
            }
        }
    }
    else if (NULL == domainname)
    {
        WCHAR RetUserName[CRED_MAX_USERNAME_LENGTH + 1];
        WCHAR RetDomainName[CRED_MAX_USERNAME_LENGTH + 1];
        RetDomainName[0] = 0;
        DWORD Status = CredUIParseUserNameW(
                        username,
                        RetUserName,
                        CRED_MAX_USERNAME_LENGTH,
                        RetDomainName,
                        CRED_MAX_USERNAME_LENGTH);
        switch (Status)
        {
            case NO_ERROR:
            {
#ifdef LOUDLY
                OutputDebugString(L"Non-MIT password change for ");
                OutputDebugString(RetUserName);
                OutputDebugString(L" of domain ");
                OutputDebugString(RetDomainName);
                OutputDebugString(L"\n");
#endif
                nas = NetUserChangePassword(RetDomainName,RetUserName,oldpassword,newpassword);
                break;
            }
            case ERROR_INSUFFICIENT_BUFFER:
                nas = ERROR_INVALID_PARAMETER;
                break;
            case ERROR_INVALID_ACCOUNT_NAME:
            default:
                nas = NERR_UserNotFound;
                break;
        }

    }
    else 
    {
        // both username and domainname passed.
        nas = NetUserChangePassword(domainname,username,oldpassword,newpassword);
    }
#ifdef LOUDLY
    WCHAR szsz[200];
    swprintf(szsz,L"NUCPEy returns %x\n",nas);
    OutputDebugString(szsz);
#endif
    return nas;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\res.h ===
#ifndef _RES_H_
#define _RES_H_

/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RES.H

Abstract:

    Resource symbols for keymgr application
     
Author:

    georgema        000310  updated

Environment:
    Win98, Win2000

Revision History:

--*/

#define IDI_UPGRADE                         100
#define IDI_LARGE                           111
#define IDI_SMALL                           112

// app general items
#define IDB_BANNER                          1701
#define IDS_INF_FILE                        1702
#define IDS_INVALID_OS_PROMPT               1703

// strings for cpl display
#define IDS_APP_NAME                        1704
#define IDS_APP_DESCRIPTION                 1705

// dialogs
#define IDD_ADDCRED                         1706
#define IDD_KEYRING                         1707
#define IDD_CHANGEPASSWORD                  1708

// IDD_KEYRING
#define IDC_KEYLIST                         1709
#define IDC_NEWKEY                          1710
#define IDC_DELETEKEY                       1711
#define IDC_EDITKEY                         1712
#define IDC_CHGPSW                 1713
#define IDC_HELPKEY                1731
#define IDC_CHANGE_PASSWORD 1724
#define IDC_PREVIEW                         1730
#define IDC_INTROTEXT                       1731

// IDD_CHANGEPASSWORD
#define IDC_OLD_PASSWORD_LABEL              1714
#define IDC_OLD_PASSWORD                    1715
#define IDC_NEW_PASSWORD_LABEL              1716
#define IDC_NEW_PASSWORD                    1717
#define IDC_CONFIRM_PASSWORD_LABEL          1718
#define IDC_CONFIRM_PASSWORD                1719
#define IDC_CPLABEL                         1729

// IDD_ADDCRED
#define IDC_TARGET_NAME_LABEL               1720
#define IDC_TARGET_NAME                     1721
#define IDC_CRED                            1722
#define IDC_DESCRIPTION                     1723
#define IDC_DOMAINPSWLABEL                  1732

// Title strings for dialogs
#define IDS_TITLE                           1800

// Suffixes used to indicate cred types in key list
//#define IDS_GENERICSUFFIX                   1802
#define IDS_CERTSUFFIX                      1803
#define IDS_PASSPORTSUFFIX                  1832

// Error text used in message boxes
#define IDS_DELETEWARNING                   1804
#define IDS_CANNOTEDIT                      1805
#define IDS_DELETEFAILED                    1807
#define IDS_NONAMESELECTED                  1808
#define IDS_EDITFAILED                      1809
#define IDS_ADDFAILED                       1810
#define IDS_BADUNAME                        1812
#define IDS_NOLOGON                         1813
#define IDS_BADUSERDOMAINNAME               1814
#define IDS_CHANGEPWDFAILED                 1815
#define IDS_PSWFAILED                       1816
#define IDS_DOMAINFAILED                    1817
#define IDS_NEWPASSWORDNOTCONFIRMED         1818
#define IDS_SINGLEEXPIRY                    1819
#define IDS_BADPASSWORD                     1841
#define IDS_RENAMEFAILED                    1842

// change password errors - used in message boxes
#define IDS_CP_INVPSW                       1820
#define IDS_CP_NOUSER                       1821
#define IDS_CP_BADPSW                       1822
#define IDS_CP_NOSVR                        1823
#define IDS_CP_NOTALLOWED                   1824
#define IDS_CPLABEL                         1826

#define IDS_SESSIONCRED                     1825

#define IDS_DOMAINEDIT                      1827
#define IDS_DOMAINCHANGE                    1828
#define IDS_LOCALFAILED                     1829
#define IDS_DOMAINOFFER                     1830
#define IDS_PASSPORT                        1831
#define IDS_PASSPORT2                       1844
#define IDS_PASSPORTNOURL                   1851

#define IDS_DESCBASE                        1845
#define IDS_DESCAPPCRED                     1846
#define IDS_PERSISTBASE                     1847
#define IDS_PERSISTLOGOFF                   1848
#define IDS_PERSISTDELETE                   1849
#define IDS_DESCLOCAL                       1850

// Help strings - context help for controls
#define IDS_NOHELP                          1900

#define IDH_KEYRING                         1901
#define IDH_KEYLIST                         1902
#define IDH_ADDCRED                         1903
#define IDH_NEW                             1904
#define IDH_DELETE                          1905
#define IDH_EDIT                            1906
#define IDH_CHANGEPASSWORD                  1907

#define IDH_OLDPASSWORD                     1908
#define IDH_NEWPASSWORD                     1909
#define IDH_CONFIRM                         1910

#define IDH_TARGETNAME                      1911
#define IDH_CUIUSER                         1912
#define IDH_CUIPSW                          1913
#define IDH_CUIVIEW                         1914
#define IDH_CLOSE                           1915
#define IDH_DCANCEL                          1916

#define IDS_TIPDFS                          1833
#define IDS_TIPSERVER                       1834
#define IDS_TIPTAIL                         1835
#define IDS_TIPDOMAIN                       1836
#define IDS_TIPDIALUP                       1837
#define IDS_TIPOTHER                        1838
#define IDS_TIPUSER                         1839
#define IDS_LOGASUSER                       1840
#define IDS_INTROTEXT                       1843

// NEXT CONTROL VALUE (1735)
// NEXT STRING VALUE (1844)
// NEXT HELP VALUE (1921)
// NEXT RESOURCE VALUE ?
// NEXT COMMAND VALUE ?
// NEXT SYMED VALUE ?

#endif  //  _RES_H_

//
///// End of file: Res.h   ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\switches.h ===
#ifndef _SWITCHES_
#define _SWITCHES_

// Option switches to switch in or out various code features.  Some are
//  related to debugging, others are code features.


// keymgr switches
// GMDEBUG - various debug stuff
// LOUDLY - turns on verbose debug output during run

#undef GMDEBUG
#undef LOUDLY

// Implement pop CHM file on context help not found when item selected?
#undef LINKCHM

// NOBLANKPASSWORD - disallow blank password
#undef  NOBLANKPASSWORD

// show passport creds in the key list?
#define SHOWPASSPORT

// simple tooltips show only the user account name for the target
#undef SIMPLETOOLTIPS

#define NEWPASSPORT
#define PASSPORTURLINREGISTRY

// This setting forces the string renditions in the main dialog list box to be LTR,
//  regardless of the RTL/LTR orientation of the system selected language.
//  See bug 344434
#undef FORCELISTLTR
#define PASSWORDHINT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\wizard.h ===
// menu commands

// Options menu
#define IDM_WIZARD      100
#define IDM_EXIT        101

// Help menu
#define IDM_ABOUT       200

// icons
#define EXE_ICON        300

// ids
#define ID_EDITCHILD	1000

// constants
#define NUM_PAGES	3
#define MAX_BUF		5000
#define MAX_LINE	512

// Function prototypes

// procs
long APIENTRY MainWndProc(HWND, UINT, UINT, LONG);
BOOL APIENTRY About(HWND, UINT, UINT, LONG);

// Pages for Wizard
BOOL APIENTRY PageProc0(HWND, UINT, UINT, LONG);
BOOL APIENTRY PageProc1(HWND, UINT, UINT, LONG);
BOOL APIENTRY PageProc2(HWND, UINT, UINT, LONG);

//functions
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
int CreateWizard(HWND, HINSTANCE);
void InitPropertyPage( PROPSHEETPAGE*,INT,DLGPROC,DWORD,LPARAM);
void SetPageText(PROPSHEETPAGE *,INT,INT);
void SetPageCaption(PROPSHEETPAGE *,INT);
void GenerateResult(HWND);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\client\lsadllp.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lsadllp.h

Abstract:

    Local Security Authority DLL include file.

Author:

    Jim Kelly (JimK) 20-Feb-1991

Revision History:

--*/

#ifndef _LSADLLP_
#define _LSADLLP_

#include <nt.h>
#include <ntrtl.h>
#include <ntlsa.h>
#include "aup.h"        // Common AUTHENTICATION related definitions

#endif // _LSADLLP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\systok.cpp ===
//
//  systok.cpp
//
//  Copyright (c) Microsoft Corp, 1998
//
//  This file contains source code for testing protected storage's key
//  backup and recovery capabilities under a real world scenario, by creating
//  a local user account, performing a data protection operation, and then
//  change the pwd, then performing data unprotect, and comparing the data.
//
//  History:
//
//  Todds       8/15/98     Created
//
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>
#include <userenv.h>
#include <lm.h>
#include <psapi.h>
#include "switches.h"


#define TERROR(msg)          LogError(__FILE__, __LINE__, msg)
#define TERRORVAL(msg, val)  LogErrorVal(__FILE__, __LINE__, msg, val)
#define TCOMMENT(msg)        LogComment(msg)
#define MyAlloc(cb)          HeapAlloc(GetProcessHeap(), 0, cb)
#define MyFree(pv)           HeapFree(GetProcessHeap(), 0, pv)
#define WSZ_BYTECOUNT(s)     (2 * wcslen(s) + 2)
#define CHECK_NULL(s)        if (s == NULL) \
                                LogError(__FILE__, __LINE__, L"## CHECK_NULL ##")

#define MAX_BLOBS           20
#define MAX_PROCESSES       200
#define MAX_SD              2048
#define BLOB_INCREMENT      0x4001 // 1 page + 1 byte...




//
//  Error Logging Functions  # defined as follows to include
//  Line and FILE macros:
//
//  TERROR       -   LogError()
//  TERRORVAL    -   LogErrorVal()
//
//

void
LogError(LPSTR szFile,
         int iLine,
         LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    swprintf(buffer, L"ERROR Line: %i -> %s\n", iLine, wszMsg);
    OutputDebugStringW(buffer);
    wprintf(buffer);


}

void
LogErrorVal(LPSTR  szFile,
            int    iLine,
            LPWSTR wszMsg,
            DWORD  dwVal)
{

    WCHAR buffer[256]; // this should be adequate.
    swprintf(buffer, L"%s Error:: %x", wszMsg, dwVal);
    LogError(szFile, iLine, buffer);
}

void
LogComment(LPWSTR wszMsg)
{

    //
    //  Event log or testutil logging later...
    //

    WCHAR buffer[512];
    OutputDebugStringW(wszMsg);
    wprintf(wszMsg);
}



void 
DumpBin(CRYPT_DATA_BLOB hash)
{

    WCHAR buff[256], out[256];
    ULONG cb;

    swprintf(out, L"");
    while (hash.cbData > 0) {
        cb = min(4, hash.cbData);
        hash.cbData -= cb;
        for (; cb > 0; cb--, hash.pbData++) {
            swprintf(buff, L"%02X", *hash.pbData);
            wcscat(out, buff);
        }
        wcscat(out, L" ");
    }
    
    wcscat(out, L"\n");

    TCOMMENT(out);
}
//
//  SetSidOnAcl
//


BOOL
SetSidOnAcl(
    PSID pSid,
    PACL pAclSource,
    PACL *pAclDestination,
    DWORD AccessMask,
	BYTE AceFlags,
    BOOL bAddSid
    )
{
    ACL_SIZE_INFORMATION AclInfo;
    DWORD dwNewAclSize, dwErr = S_OK;
    LPVOID pAce;
    DWORD AceCounter;
    BOOL bSuccess=FALSE; // assume this function will fail

    //
    // If we were given a NULL Acl, just provide a NULL Acl
    //
    if(pAclSource == NULL) {
        *pAclDestination = NULL;
        return TRUE;
    }

    if(!IsValidSid(pSid)) return FALSE;

    if(!GetAclInformation(
        pAclSource,
        &AclInfo,
        sizeof(ACL_SIZE_INFORMATION),
        AclSizeInformation
        )) return FALSE;

    //
    // compute size for new Acl, based on addition or subtraction of Ace
    //
    if(bAddSid) {
        dwNewAclSize=AclInfo.AclBytesInUse  +
            sizeof(ACCESS_ALLOWED_ACE)  +
            GetLengthSid(pSid)          -
            sizeof(DWORD)               ;
    }
    else {
        dwNewAclSize=AclInfo.AclBytesInUse  -
            sizeof(ACCESS_ALLOWED_ACE)  -
            GetLengthSid(pSid)          +
            sizeof(DWORD)               ;
    }

    *pAclDestination = (PACL)MyAlloc(dwNewAclSize);

    if(*pAclDestination == NULL) 
    {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    
    //
    // initialize new Acl
    //
    if(!InitializeAcl(
            *pAclDestination, 
            dwNewAclSize, 
            ACL_REVISION
            )){
        dwErr = GetLastError();
        TERRORVAL(L"InitilizeAcl failed!", dwErr);
        goto ret;
    }

    //
    // if appropriate, add ace representing pSid
    //
    if(bAddSid) {
		PACCESS_ALLOWED_ACE pNewAce;

        if(!AddAccessAllowedAce(
            *pAclDestination,
            ACL_REVISION,
            AccessMask,
            pSid
            )) {
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }

		//
		// get pointer to ace we just added, so we can change the AceFlags
		//
		if(!GetAce(
			*pAclDestination,
			0, // this is the first ace in the Acl
			(void**) &pNewAce
			)){
        
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }

		pNewAce->Header.AceFlags = AceFlags;	
    }

    //
    // copy existing aces to new Acl
    //
    for(AceCounter = 0 ; AceCounter < AclInfo.AceCount ; AceCounter++) {
        //
        // fetch existing ace
        //
        if(!GetAce(pAclSource, AceCounter, &pAce)){
            dwErr = GetLastError();
            TERRORVAL(L"GetAce failed!", dwErr);
            goto ret;
        }
        //
        // check to see if we are removing the Ace
        //
        if(!bAddSid) {
            //
            // we only care about ACCESS_ALLOWED aces
            //
            if((((PACE_HEADER)pAce)->AceType) == ACCESS_ALLOWED_ACE_TYPE) {
                PSID pTempSid=(PSID)&((PACCESS_ALLOWED_ACE)pAce)->SidStart;
                //
                // if the Sid matches, skip adding this Sid
                //
                if(EqualSid(pSid, pTempSid)) continue;
            }
        }

        //
        // append ace to Acl
        //
        if(!AddAce(
            *pAclDestination,
            ACL_REVISION,
            MAXDWORD,  // maintain Ace order
            pAce,
            ((PACE_HEADER)pAce)->AceSize
            )) {
         
            dwErr = GetLastError();
            TERRORVAL(L"AddAccessAllowedAce failed!", dwErr);
            goto ret;
        }
    }

    bSuccess=TRUE; // indicate success

    
ret:

    //
    // free memory if an error occurred
    //
    if(!bSuccess) {
        if(*pAclDestination != NULL)
            MyFree(*pAclDestination);
    }

    

    return bSuccess;
}
//
//  AddSIDToKernelObject()
//
//  This function takes a given SID and dwAccess and adds it to a given token.
//
//  **  Be sure to restore old kernel object
//  **  using call to GetKernelObjectSecurity()
//
BOOL
AddSIDToKernelObjectDacl(PSID                   pSid,
                         DWORD                  dwAccess,
                         HANDLE                 OriginalToken,
                         PSECURITY_DESCRIPTOR*  ppSDOld)
{

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_DESCRIPTOR     sdNew;
    DWORD                   cbByte = MAX_SD, cbNeeded = 0, dwErr = 0; 
    PACL                    pOldDacl = NULL, pNewDacl = NULL;
    BOOL                    fDaclPresent, fDaclDefaulted, fRet = FALSE;                    
   
    pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbByte);
    if (NULL == pSD) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        return FALSE;
    }

    if (!InitializeSecurityDescriptor(
                &sdNew, 
                SECURITY_DESCRIPTOR_REVISION
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"InitializeSecurityDescriptor failed!", dwErr);
        goto ret;
    }

    if (!GetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        pSD,
        cbByte,
        &cbNeeded
        )) {
        
        dwErr = GetLastError();
        if (cbNeeded > MAX_SD && dwErr == ERROR_MORE_DATA) { 
    
            MyFree(pSD);
            pSD = NULL;
            pSD = (PSECURITY_DESCRIPTOR) MyAlloc(cbNeeded);
            if (NULL == pSD) {
                TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
                dwErr = E_OUTOFMEMORY;
                goto ret;
            }
            
            dwErr = S_OK;
            if (!GetKernelObjectSecurity(
                OriginalToken,
                DACL_SECURITY_INFORMATION,
                pSD,
                cbNeeded,
                &cbNeeded
                )) {
                dwErr = GetLastError();
            }
            
        }
        
        if (dwErr != S_OK) {
            TERRORVAL(L"GetKernelObjectSecurity failed!", dwErr);
            goto ret;
        }
    }
    
    if (!GetSecurityDescriptorDacl(
        pSD,
        &fDaclPresent,
        &pOldDacl,
        &fDaclDefaulted
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"GetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    }
    
    if (!SetSidOnAcl(
        pSid,
        pOldDacl,
        &pNewDacl,
        dwAccess,
        0,
        TRUE
        )) {
        goto ret;
    }
    
    if (!SetSecurityDescriptorDacl(
        &sdNew,
        TRUE,
        pNewDacl,
        FALSE
        )) {
        dwErr = GetLastError();
        TERRORVAL(L"SetSecurityDescriptorDacl failed!", dwErr);
        goto ret;
    } 
    
    if (!SetKernelObjectSecurity(
        OriginalToken,
        DACL_SECURITY_INFORMATION,
        &sdNew
        )) {
        
        dwErr = GetLastError();
        TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
        goto ret;
    }
    
    *ppSDOld = pSD;
    fRet = TRUE;

ret:

    if (NULL != pNewDacl) {
        MyFree(pNewDacl);
    }

    if (!fRet) {
        if (NULL != pSD) {
            MyFree(pSD);
            *ppSDOld = NULL;
        }

    }
       
    return fRet;
}


//
//  DataFree()
//
//  Utility for freeing array of DATA_BLOB structs
//
void
DataFree(DATA_BLOB* arDataBlob, 
         BOOL       fCryptAlloc)
{

    if (arDataBlob == NULL) return; // not alloc'd
    
    for (DWORD i = 0; i < MAX_BLOBS;i++) {

        if (arDataBlob[i].pbData != NULL) {
            
            if (!fCryptAlloc) { 
                MyFree(arDataBlob[i].pbData);
            } else { // Data member alloc'd by DataProtect call
                LocalFree(arDataBlob[i].pbData);
            }
        }
       
    }

    MyFree(arDataBlob);
}

    


BOOL
SetPrivilege(
    HANDLE hToken,          // token handle
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    TOKEN_PRIVILEGES tp;
    LUID luid;
    TOKEN_PRIVILEGES tpPrevious;
    DWORD cbPrevious=sizeof(TOKEN_PRIVILEGES);

    if(!LookupPrivilegeValue( NULL, Privilege, &luid )) return FALSE;

    //
    // first pass.  get current privilege setting
    //
    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = 0;

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tp,
            sizeof(TOKEN_PRIVILEGES),
            &tpPrevious,
            &cbPrevious
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    //
    // second pass.  set privilege based on previous setting
    //
    tpPrevious.PrivilegeCount       = 1;
    tpPrevious.Privileges[0].Luid   = luid;

    if(bEnablePrivilege) {
        tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
    }
    else {
        tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED &
            tpPrevious.Privileges[0].Attributes);
    }

    AdjustTokenPrivileges(
            hToken,
            FALSE,
            &tpPrevious,
            cbPrevious,
            NULL,
            NULL
            );

    if (GetLastError() != ERROR_SUCCESS) return FALSE;

    return TRUE;
}

BOOL
SetCurrentPrivilege(
    LPCTSTR Privilege,      // Privilege to enable/disable
    BOOL bEnablePrivilege   // to enable or disable privilege
    )
{
    BOOL bSuccess=FALSE; // assume failure
    HANDLE hToken;

    if (!OpenThreadToken(
            GetCurrentThread(), 
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            FALSE,
            &hToken)){       
                
        if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
            &hToken
            )) return FALSE;
    }

    if(SetPrivilege(hToken, Privilege, bEnablePrivilege)) bSuccess=TRUE;
    CloseHandle(hToken);

    return bSuccess;
}


//
//  GetUserSid
//
//  This function takes a token, and returns the user SID from that token.
//
//  Note:   SID must be freed by MyFree()
//          hToken is optional...  NULL means we'll grab it.
//
extern "C" BOOL
GetUserSid(HANDLE   hClientToken,
           PSID*    ppSid,
           DWORD*   lpcbSid)
{
    DWORD                       cbUserInfo = 0;
    PTOKEN_USER                 pUserInfo = NULL;
    PUCHAR                      pnSubAuthorityCount = 0;
    DWORD                       cbSid = 0;
    BOOL                        fRet = FALSE;
    HANDLE                      hToken = hClientToken;
    
    *ppSid = NULL;

    if (NULL == hClientToken) {
        
        if (!OpenThreadToken(   
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &hToken
            )) { 
            
            // not impersonating, use process token...
            if (!OpenProcessToken(
                GetCurrentProcess(),
                TOKEN_QUERY,
                &hToken
                )) {

                TERRORVAL(L"OpenProcessToken failed!", GetLastError());
                return FALSE;
            }
        }
    }
    
    // this will fail, usually w/ ERROR_INSUFFICIENT_BUFFER
    GetTokenInformation(
        hToken, 
        TokenUser, 
        NULL, 
        0, 
        &cbUserInfo
        );
    
    pUserInfo = (PTOKEN_USER) MyAlloc(cbUserInfo);
    if (NULL == pUserInfo) {
        TERRORVAL(L"ALLOC FAILURE!", E_OUTOFMEMORY);
        return FALSE;
    }
    
    if (!GetTokenInformation(
        hToken,
        TokenUser,
        pUserInfo,
        cbUserInfo,
        &cbUserInfo
        )) {
        
        TERRORVAL(L"GetTokenInformation failed!", GetLastError());
        goto ret;
    }
 
    //
    //  Now that we've got the SID AND ATTRIBUTES struct, get the SID lenght,
    //  alloc room, and return *just the SID*
    //
    if (!IsValidSid(pUserInfo->User.Sid)) goto ret;
    pnSubAuthorityCount = GetSidSubAuthorityCount(pUserInfo->User.Sid);
    cbSid = GetSidLengthRequired(*pnSubAuthorityCount);

    *ppSid = (PSID) MyAlloc(cbSid);
    if (NULL == *ppSid ) {
        TERRORVAL(L"Alloc failed!", E_OUTOFMEMORY);
        goto ret;
    }

    if (!CopySid(
            cbSid,
            *ppSid, 
            pUserInfo->User.Sid
            )) {
        
        TERRORVAL(L"CopySid failed!", GetLastError());
        goto copyerr;
    }

    *lpcbSid = cbSid; // may be useful later on...
    fRet = TRUE;

ret:
    if (NULL == hClientToken && NULL != hToken) { // supplied our own
        CloseHandle(hToken);
    }

    if (NULL != pUserInfo) {
        MyFree(pUserInfo);
    }

    return fRet;

copyerr:

    if (NULL != *ppSid) {
        MyFree(*ppSid);
        *ppSid = NULL;
    }

    goto ret;
}

//
//  IsLocalSystem()
//  This function makes the determination if the given process token
//  is running as local system.
//
BOOL
IsLocalSystem(HANDLE hToken) 
{


    PSID                        pLocalSid = NULL, pTokenSid = NULL;
    SID_IDENTIFIER_AUTHORITY    IDAuthorityNT      = SECURITY_NT_AUTHORITY;
    DWORD                       cbSid = 0;    
    BOOL                        fRet = FALSE;

    if (!GetUserSid(
            hToken,
            &pTokenSid,
            &cbSid
            )) {
        goto ret;
    }

    if (!AllocateAndInitializeSid(
                &IDAuthorityNT,
                1,
                SECURITY_LOCAL_SYSTEM_RID,
                0,0,0,0,0,0,0,
                &pLocalSid
                )) {

        TERRORVAL(L"AllocateAndInitializeSid failed!", GetLastError());
        goto ret;
    }

    if (EqualSid(pLocalSid, pTokenSid)) {
        fRet = TRUE; // got one!
    } 

ret:

    if (NULL != pTokenSid) {
        MyFree(pTokenSid);
    }

    if (NULL != pLocalSid) {
        FreeSid(pLocalSid);
    }

    return fRet;
}




//
//  GetLocalSystemToken()
//
//  This function grabs a process token from a LOCAL SYSTEM process and uses it
//  to run as local system for the duration of the test
//
extern "C" DWORD
GetLocalSystemToken(HANDLE* phRet)
{

    HANDLE  hProcess = NULL;
    HANDLE  hPToken = NULL, hPTokenNew = NULL, hPDupToken = NULL;

    DWORD   rgPIDs[MAX_PROCESSES], cbNeeded = 0, dwErr = S_OK, i = 0;
    DWORD   cbrgPIDs = sizeof(DWORD) * MAX_PROCESSES;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pSid = NULL;
    DWORD                   cbSid = 0;
    BOOL                    fSet = FALSE;

    //  SLOW BUFFERs
    BYTE    rgByte[MAX_SD], rgByte2[MAX_SD];
    DWORD   cbByte = MAX_SD, cbByte2 = MAX_SD;
  
    *phRet = NULL;

    if(!SetCurrentPrivilege(SE_DEBUG_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (debug) failed!");
        return E_FAIL;
    }

    if(!SetCurrentPrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE)) {
        TERROR(L"SetCurrentPrivilege (to) failed!");
        return E_FAIL;
    }

    if (!EnumProcesses(
                rgPIDs,
                cbrgPIDs,
                &cbNeeded
                )) {

        dwErr = GetLastError();
        TERRORVAL(L"EnumProcesses failed!", dwErr);
        goto ret;
    }

    //
    //  Get current user's sid for use in expanding SD.
    //
    if (!GetUserSid(
        NULL, 
        &pSid,
        &cbSid
        )) {
        goto ret;
    }

    //
    //  Walk processes until we find one that's running as
    //  local system
    //
    for (i = 1; i < (cbNeeded / sizeof(DWORD)); i++) {

        hProcess = OpenProcess(
                    PROCESS_ALL_ACCESS,
                    FALSE,
                    rgPIDs[i]
                    );
        
        if (NULL == hProcess) {
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcess failed!", dwErr);
            goto ret;
        }

        if (!OpenProcessToken(
                    hProcess,
                    READ_CONTROL | WRITE_DAC,
                    &hPToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }

        //
        //  We've got a token, but we can't use it for 
        //  TOKEN_DUPLICATE access.  So, instead, we'll go
        //  ahead and whack the DACL on the object to grant us
        //  this access, and get a new token.
        //  **** BE SURE TO RESTORE hProcess to Original SD!!! ****
        //
        if (!AddSIDToKernelObjectDacl(
                         pSid,
                         TOKEN_DUPLICATE,
                         hPToken,
                         &pSD
                         )) {
            goto ret;
        }
                       
        fSet = TRUE;
        
        if (!OpenProcessToken(
            hProcess,
            TOKEN_DUPLICATE,
            &hPTokenNew
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"OpenProcessToken failed!", dwErr);
            goto ret;
        }
        
        //
        //  Duplicate the token
        //
        if (!DuplicateTokenEx(
                    hPTokenNew,
                    TOKEN_ALL_ACCESS,
                    NULL,
                    SecurityImpersonation,
                    TokenPrimary,
                    &hPDupToken
                    )) {

            dwErr = GetLastError();
            TERRORVAL(L"DuplicateToken failed!", dwErr);
            goto ret;
        }

        if (IsLocalSystem(hPDupToken)) {
            *phRet = hPDupToken;
            break; // found a local system token
        }

        //  Loop cleanup
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {

            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed!", dwErr);
            goto ret;
        } 
        
        fSet = FALSE;
        
        if (NULL != hPDupToken) {
            CloseHandle(hPDupToken);
            hPDupToken = NULL;
        }

        if (NULL != pSD) { 
            MyFree(pSD);
            pSD = NULL;
        }

        if (NULL != hPToken) {
            CloseHandle(hPToken);
            hPToken = NULL;
        }

        if (NULL != hProcess) {
            CloseHandle(hProcess);
            hProcess = NULL;
        }

    } // ** FOR ** 

ret:


    //***** REMEMBER TO RESTORE ORIGINAL SD TO OBJECT*****
    
    if (fSet) {
        
        if (!SetKernelObjectSecurity(
            hPToken,
            DACL_SECURITY_INFORMATION,
            pSD
            )) {
            
            dwErr = GetLastError();
            TERRORVAL(L"SetKernelObjectSecurity failed (cleanup)!", dwErr);
        } 
    }

    if (NULL != pSid) {
        MyFree(pSid);
    }

    if (NULL != hPToken) {
        CloseHandle(hPToken);
    }
    
    if (NULL != pSD) {
        MyFree(pSD);
    }

    if (NULL != hProcess) {
        CloseHandle(hProcess);
    }
    
    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\client\austub.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    austub.c

Abstract:

    Local Security Authority AUTHENTICATION service client stubs.

Author:

    Jim Kelly (JimK) 20-Feb-1991

Environment:   Kernel or User Modes

Revision History:

--*/

#include "lsadllp.h"
#include <string.h>
#include <zwapi.h>

#ifdef _NTSYSTEM_
//
// Unfortunately the security header files are just not at all constructed
// in a manner compatible with kernelmode. For some reason they are totally
// reliant on usermode header definitions. Just assume the text and const
// pragma's will work. If they don't work on an architecture, they can be
// fixed.
//
#pragma alloc_text(PAGE,LsaFreeReturnBuffer)
#pragma alloc_text(PAGE,LsaRegisterLogonProcess)
#pragma alloc_text(PAGE,LsaConnectUntrusted)
#pragma alloc_text(PAGE,LsaLookupAuthenticationPackage)
#pragma alloc_text(PAGE,LsaLogonUser)
#pragma alloc_text(PAGE,LsaCallAuthenticationPackage)
#pragma alloc_text(PAGE,LsaDeregisterLogonProcess)
//#pragma const_seg("PAGECONST")
#endif //_NTSYSTEM_

const WCHAR LsapEvent[] = L"\\SECURITY\\LSA_AUTHENTICATION_INITIALIZED";
const WCHAR LsapPort[] = L"\\LsaAuthenticationPort";


NTSTATUS
LsaFreeReturnBuffer (
    IN PVOID Buffer
    )


/*++

Routine Description:

    Some of the LSA authentication services allocate memory buffers to
    hold returned information.  This service is used to free those buffers
    when no longer needed.

Arguments:

    Buffer - Supplies a pointer to the return buffer to be freed.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    Others - returned by NtFreeVirtualMemory().

--*/

{

    NTSTATUS Status;
    ULONG_PTR Length;

    Length = 0;
    Status = ZwFreeVirtualMemory(
                 NtCurrentProcess(),
                 &Buffer,
                 &Length,
                 MEM_RELEASE
                 );

    return Status;
}


NTSTATUS
LsaRegisterLogonProcess(
    IN PSTRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    )

/*++

Routine Description:

    This service connects to the LSA server and verifies that the caller
    is a legitimate logon process. this is done by ensuring the caller has
    the SeTcbPrivilege privilege. It also opens the caller's process for
    PROCESS_DUP_HANDLE access in anticipation of future LSA authentication
    calls.

Arguments:

    LogonProcessName  - Provides a name string that identifies the logon
        process.  This should be a printable name suitable for display to
        administrators.  For example, "User32LogonProces" might be used
        for the windows logon process name.  No check is made to determine
        whether the name is already in use.  This name must NOT be longer
        than 127 bytes long.

    LsaHandle - Receives a handle which must be provided in future
        authenticaiton services.

    SecurityMode - The security mode the system is running under.  This
        value typically influences the logon user interface.  For example,
        a system running with password control will prompt for username
        and passwords before bringing up the UI shell.  One running without
        password control would typically automatically bring up the UI shell
        at system initialization.

Return Value:

    STATUS_SUCCESS - The call completed successfully.

    STATUS_PRIVILEGE_NOT_HELD  - Indicates the caller does not have the
        privilege necessary to act as a logon process.  The SeTcbPrivilege
        privilege is needed.


    STATUS_NAME_TOO_LONG - The logon process name provided is too long.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    UNICODE_STRING PortName, EventName;
    LSAP_AU_REGISTER_CONNECT_INFO ConnectInfo;
    ULONG ConnectInfoLength;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE EventHandle;


    //
    // Validate input parameters
    //

    if (LogonProcessName->Length > LSAP_MAX_LOGON_PROC_NAME_LENGTH) {
        return STATUS_NAME_TOO_LONG;
    }


    //
    // Wait for LSA to initialize...
    //


    RtlInitUnicodeString( &EventName, LsapEvent );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = NtWaitForSingleObject( EventHandle, TRUE, NULL);
    IgnoreStatus = NtClose( EventHandle );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.Length = sizeof( DynamicQos );
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;




    //
    // Set up the connection information to contain the logon process
    // name.
    //

    ConnectInfoLength = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    strncpy(
        ConnectInfo.LogonProcessName,
        LogonProcessName->Buffer,
        LogonProcessName->Length
        );
    ConnectInfo.LogonProcessNameLength = LogonProcessName->Length;
    ConnectInfo.LogonProcessName[ConnectInfo.LogonProcessNameLength] = '\0';


    //
    // Connect to the LSA server
    //

    *LsaHandle = NULL;
    RtlInitUnicodeString(&PortName,LsapPort);
    Status = ZwConnectPort(
                 LsaHandle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 &ConnectInfo,
                 &ConnectInfoLength
                 );
    if ( !NT_SUCCESS(Status) ) {
        //DbgPrint("LSA AU: Logon Process Register failed %lx\n",Status);
        return Status;
    }

    if ( !NT_SUCCESS(ConnectInfo.CompletionStatus) ) {
        //DbgPrint("LSA AU: Logon Process Register rejected %lx\n",ConnectInfo.CompletionStatus);
        if ( LsaHandle && *LsaHandle != NULL ) {
            ZwClose( *LsaHandle );
            *LsaHandle = NULL;
        }
    }

    (*SecurityMode) = ConnectInfo.SecurityMode;

    return ConnectInfo.CompletionStatus;

}


NTSTATUS
LsaConnectUntrusted(
    OUT PHANDLE LsaHandle
    )

/*++

Routine Description:

    This service connects to the LSA server and sets up an untrusted
    connection.  It does not check anything about the caller.

Arguments:


    LsaHandle - Receives a handle which must be provided in future
        authenticaiton services.


Return Value:

    STATUS_SUCCESS - The call completed successfully.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    UNICODE_STRING PortName, EventName;
    LSAP_AU_REGISTER_CONNECT_INFO ConnectInfo;
    ULONG ConnectInfoLength;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE EventHandle;



    //
    // Wait for LSA to initialize...
    //


    RtlInitUnicodeString( &EventName, LsapEvent );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = NtWaitForSingleObject( EventHandle, TRUE, NULL);
    IgnoreStatus = NtClose( EventHandle );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;




    //
    // Set up the connection information to contain the logon process
    // name.
    //

    ConnectInfoLength = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    RtlZeroMemory(
        &ConnectInfo,
        ConnectInfoLength
        );


    //
    // Connect to the LSA server
    //

    RtlInitUnicodeString(&PortName,LsapPort);
    Status = ZwConnectPort(
                 LsaHandle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 &ConnectInfo,
                 &ConnectInfoLength
                 );
    if ( !NT_SUCCESS(Status) ) {
        //DbgPrint("LSA AU: Logon Process Register failed %lx\n",Status);
        return Status;
    }

    if ( !NT_SUCCESS(ConnectInfo.CompletionStatus) ) {
        //DbgPrint("LSA AU: Logon Process Register rejected %lx\n",ConnectInfo.CompletionStatus);
        ;
    }

    return ConnectInfo.CompletionStatus;

}


NTSTATUS
LsaLookupAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN PSTRING PackageName,
    OUT PULONG AuthenticationPackage
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    PackageName - Supplies a string which identifies the
        Authentication Package.  "MSV1.0" is the standard NT
        authentication package name.  The package name must not
        exceed 127 bytes in length.

    AuthenticationPackage - Receives an ID used to reference the
        authentication package in subsequent authentication services.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

    STATUS_NAME_TOO_LONG - The authentication package name provided is too
        long.



Routine Description:

    This service is used to obtain the ID of an authentication package.
    This ID may then be used in subsequent authentication services.


--*/

{

    NTSTATUS Status;
    LSAP_AU_API_MESSAGE Message = {0};
    PLSAP_LOOKUP_PACKAGE_ARGS Arguments;

    //
    // Validate input parameters
    //

    if (PackageName->Length > LSAP_MAX_PACKAGE_NAME_LENGTH) {
        return STATUS_NAME_TOO_LONG;
    }



    Arguments = &Message.Arguments.LookupPackage;

    //
    // Set arguments
    //

    strncpy(Arguments->PackageName, PackageName->Buffer, PackageName->Length);
    Arguments->PackageNameLength = PackageName->Length;
    Arguments->PackageName[Arguments->PackageNameLength] = '\0';



    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuLookupPackageApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    Status = ZwRequestWaitReplyPort(
            LsaHandle,
            (PPORT_MESSAGE) &Message,
            (PPORT_MESSAGE) &Message
            );

    //
    // Return the authentication package ID.
    // If the call failed for any reason, this will be garbage,
    // but who cares.
    //

    (*AuthenticationPackage) = Arguments->AuthenticationPackage;


    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
        if ( !NT_SUCCESS(Status) ) {
            //DbgPrint("LSA AU: Package Lookup Failed %lx\n",Status);
            ;
        }
    } else {
#if DBG
        DbgPrint("LSA AU: Package Lookup NtRequestWaitReply Failed %lx\n",Status);
#else
        ;
#endif
    }

    return Status;
}


NTSTATUS
LsaLogonUser (
    IN HANDLE LsaHandle,
    IN PSTRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    OriginName - Supplies a string which identifies the origin of the
        logon attempt.  For example, "TTY1" specify terminal 1, or
        "LAN Manager - remote node JAZZ" might indicate a network
        logon attempt via LAN Manager from a remote node called
        "JAZZ".

    LogonType - Identifies the type of logon being attempted.  If the
        type is Interactive or Batch then a PrimaryToken will be
        generated to represent this new user.  If the type is Network
        then an impersonation token will be generated.

    AuthenticationPackage - Supplies the ID of the authentication
        package to use for the logon attempt.  The standard
        authentication package name for NT is called "MSV1.0".

    AuthenticationInformation - Supplies the authentication
        information specific to the authentication package.  It is
        expected to include identification and authentication
        information such as user name and password.

    AuthenticationInformationLength - Indicates the length of the
        authentication information buffer.

    LocalGroups - Optionally supplies a list of additional group
        identifiers to add to the authenticated user's token.  The
        WORLD group will always be included in the token.  A group
        identifying the logon type (INTERACTIVE, NETWORK, BATCH) will
        also automatically be included in the token.

    SourceContext - Supplies information identifying the source
        component (e.g., session manager) and context that may be
        useful to that component.  This information will be included
        in the token and may later be retrieved.

    ProfileBuffer - Receives a pointer to any returned profile and
        accounting information about the logged on user's account.
        This information is authentication package specific and
        provides such information as the logon shell, home directory
        and so forth.  For an authentication package value of
        "MSV1.0", a MSV1_0_PROFILE_DATA data structure is returned.

        This buffer is allocated by this service and must be freed
        using LsaFreeReturnBuffer() when no longer needed.

    ProfileBufferLength - Receives the length (in bytes) of the
        returned profile buffer.

    LogonId - Points to a buffer which receives a LUID that uniquely
        identifies this logon session.  This LUID was assigned by the
        domain controller which authenticated the logon information.

    Token - Receives a handle to the new token created for this
        authentication.

    Quotas - When a primary token is returned, this parameter will be
        filled in with process quota limits that are to be assigned
        to the newly logged on user's initial process.

    SubStatus - If the logon failed due to account restrictions, this
        out parameter will receive an indication as to why the logon
        failed.  This value will only be set to a meaningful value if
        the user has a legitimate account, but may not currently
        logon for some reason.  The substatus values for
        authentication package "MSV1.0" are:

            STATUS_INVALID_LOGON_HOURS

            STATUS_INVALID_WORKSTATION

            STATUS_PASSWORD_EXPIRED

            STATUS_ACCOUNT_DISABLED

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  Indicates the caller does not have
        enough quota to allocate the profile data being returned by
        the authentication package.

    STATUS_NO_LOGON_SERVERS - Indicates that no domain controllers
        are currently able to service the authentication request.

    STATUS_LOGON_FAILURE - Indicates the logon attempt failed.  No
        indication as to the reason for failure is given, but typical
        reasons include mispelled usernames, mispelled passwords.

    STATUS_ACCOUNT_RESTRICTION - Indicates the user account and
        password were legitimate, but that the user account has some
        restriction preventing successful logon at this time.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

    STATUS_BAD_VALIDATION_CLASS - The authentication information
        provided is not a validation class known to the specified
        authentication package.

Routine Description:

    This routine is used to authenticate a user logon attempt.  This is
    used only for user's initial logon, necessary to gain access to NT
    OS/2.  Subsequent (supplementary) authentication requests must be done
    using LsaCallAuthenticationPackage().  This service will cause a logon
    session to be created to represent the new logon.  It will also return
    a token representing the newly logged on user.

--*/

{

    NTSTATUS Status;
    LSAP_AU_API_MESSAGE Message = {0};
    PLSAP_LOGON_USER_ARGS Arguments;

    Arguments = &Message.Arguments.LogonUser;

    //
    // Set arguments
    //

    Arguments->AuthenticationPackage      = AuthenticationPackage;
    Arguments->AuthenticationInformation  = AuthenticationInformation;
    Arguments->AuthenticationInformationLength = AuthenticationInformationLength;
    Arguments->OriginName                 = (*OriginName);
    Arguments->LogonType                  = LogonType;
    Arguments->SourceContext              = (*SourceContext);

    Arguments->LocalGroups                = LocalGroups;
    if ( ARGUMENT_PRESENT(LocalGroups) ) {
        Arguments->LocalGroupsCount       = LocalGroups->GroupCount;
    } else {
        Arguments->LocalGroupsCount       = 0;
    }


    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuLogonUserApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    Status = ZwRequestWaitReplyPort(
            LsaHandle,
            (PPORT_MESSAGE) &Message,
            (PPORT_MESSAGE) &Message
            );

    //
    // We may be returning bogus return values here, but it doesn't
    // matter.  They will just be ignored if an error occured.
    //

    (*SubStatus)           = Arguments->SubStatus;

    if ( NT_SUCCESS( Status ) )
    {
        Status = Message.ReturnedStatus ;

        // Don't not clear the ProfileBuffer even in case of error, cause
        // subauth packages need the ProfileBuffer.
        *ProfileBuffer = Arguments->ProfileBuffer ;
        *ProfileBufferLength = Arguments->ProfileBufferLength ;

        if ( NT_SUCCESS( Status ) )
        {
            *LogonId = Arguments->LogonId ;
            *Token = Arguments->Token ;
            *Quotas = Arguments->Quotas ;
        } else {
            *Token = NULL;
        }

    } else {

        *ProfileBuffer = NULL ;
        *Token = NULL ;
    }

    return Status;


}


NTSTATUS
LsaCallAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer OPTIONAL,
    OUT PULONG ReturnBufferLength OPTIONAL,
    OUT PNTSTATUS ProtocolStatus OPTIONAL
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    AuthenticationPackage - Supplies the ID of the authentication
        package to use for the logon attempt.  The standard
        authentication package name for NT is called "MSV1.0".

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Receives a pointer to a returned protocol
        message whose format and semantics are specific to the
        authentication package.

        This buffer is allocated by this service and must be freed
        using LsaFreeReturnBuffer() when no longer needed.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned profile buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the call could
        not be completed because the client does not have sufficient
        quota to allocate the return buffer.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

Routine Description:

    This routine is used when a logon process needs to communicate with an
    authentication package.  There are several reasons why a logon process
    may want to do this.  Some examples are:

     o  To implement multi-message authentication protocols (such as
        the LAN Manager Challenge-response protocol.

     o  To notify the authentication package of interesting state
        change information, such as LAN Manager notifying the MSV1.0
        package that a previously unreachable domain controller is
        now reachable.  In this example, the authentication package
        would re-logon any users logged on to that domain controller.


--*/

{

    NTSTATUS Status;
    LSAP_AU_API_MESSAGE Message = {0};
    PLSAP_CALL_PACKAGE_ARGS Arguments;



    Arguments = &Message.Arguments.CallPackage;

    //
    // Set arguments
    //

    Arguments->AuthenticationPackage = AuthenticationPackage;
    Arguments->ProtocolSubmitBuffer  = ProtocolSubmitBuffer;
    Arguments->SubmitBufferLength    = SubmitBufferLength;



    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuCallPackageApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    Status = ZwRequestWaitReplyPort(
            LsaHandle,
            (PPORT_MESSAGE) &Message,
            (PPORT_MESSAGE) &Message
            );

    //
    // We may be returning bogus return values here, but it doesn't
    // matter.  They will just be ignored if an error occured.
    //

    if ( ProtocolReturnBuffer )
    {
        (*ProtocolReturnBuffer) = Arguments->ProtocolReturnBuffer;
    }

    if ( ReturnBufferLength )
    {
        (*ReturnBufferLength)   = Arguments->ReturnBufferLength;
    }

    if ( ProtocolStatus )
    {
        (*ProtocolStatus)       = Arguments->ProtocolStatus;
    }


    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
#if DBG
        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("LSA AU: Call Package Failed %lx\n",Status);
        }
    } else {
        DbgPrint("LSA AU: Call Package Failed %lx\n",Status);
#endif //DBG
    }



    return Status;

}


NTSTATUS
LsaDeregisterLogonProcess (
    IN HANDLE LsaHandle
    )

/*++

    This function deletes the caller's logon process context.


                        ---  WARNING  ---

        Logon Processes are part of the Trusted Computer Base, and,
        as such, are expected to be debugged to a high degree.  If
        a logon process deregisters, we will believe it.  This
        allows us to re-use the old Logon Process context value.
        If the Logon process accidently uses its context value
        after freeing it, strange things may happen.  LIkewise,
        if a client calls to release a context that has already
        been released, then LSA may grind to a halt.



Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.


Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{

    NTSTATUS Status;
    LSAP_AU_API_MESSAGE Message = {0};
    NTSTATUS TempStatus;

    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuDeregisterLogonProcessApi;
    Message.PortMessage.u1.s1.DataLength = 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    Status = ZwRequestWaitReplyPort(
            LsaHandle,
            (PPORT_MESSAGE) &Message,
            (PPORT_MESSAGE) &Message
            );

    TempStatus = ZwClose(LsaHandle);
    ASSERT(NT_SUCCESS(TempStatus));

    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
#if DBG
        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("LSA AU: DeRregisterLogonProcess Failed 0x%lx\n",Status);
        }
    } else {
        DbgPrint("LSA AU: Package Lookup NtRequestWaitReply Failed 0x%lx\n",Status);
#endif
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\wizres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wizard.RC
//
#define IDD_SWELCOME           551
#define IDD_SPAGEXS             559
#define IDD_SPAGEXR             560
#define IDD_SPAGE1             552
#define IDD_SFINISH            553
#define IDD_RWELCOME           554
#define IDD_RPAGE1             555
#define IDD_RFINISH            556
#define IDD_RBACKUP            557
#define IDD_PROGRESS           558
#define IDD_SPAGE2              561

#define IDC_SWELCOME1          1501
#define IDC_SWELCOME2          1502
#define IDC_SINSTRUCTIONS      1503
#define IDC_SP1E1              1504
#define IDC_SP1E2              1505
#define IDC_SFINISH1           1506
#define IDC_SFINISH2           1507
#define IDC_RWELCOME1          1508
#define IDC_RWELCOME2          1509
#define IDC_RINSTRUCTIONS      1510
#define IDC_RP1E1              1511
#define IDC_RP1E2              1512
#define IDC_RP1E3              1525
#define IDC_RFINISH1           1513
#define IDC_RFINISH2           1514
#define IDC_RBACKUP            1515
#define IDC_PROGRESS1         1516
#define IDC_SCOMBO            1517
#define IDC_RCOMBO            1518
#define IDC_COMBO             1521
#define IDC_DRIVEPROMPT      1519
#define IDC_DRIVEINSTRUCTIONS 1523
#define IDC_SPROGRESS         1524

#define IDS_SWELCOME1          651
#define IDS_SWELCOME2          652
#define IDS_SP1INSTRUCTIONS    653
#define IDS_SP1TITLE           654
#define IDS_SP1SUBTITLE        655
#define IDS_SFINISH1           656
#define IDS_SFINISH2           657
#define IDS_RWELCOME1          658
#define IDS_RWELCOME2          659
#define IDS_RP1TITLE           661
#define IDS_RP1SUBTITLE        662
#define IDS_RBTITLE            665
#define IDS_RBSUBTITLE         666
#define IDS_RBACKUP            667
#define IDS_RFINISH1           663
#define IDS_RFINISH2           664
#define IDS_RP1INSTR          668
#define IDS_BADPSW             670
#define IDS_RFFILEMISSING      673
#define IDS_SERROR             674
#define IDS_RERROR             675
#define IDS_RPSWERROR          676
#define IDS_NOPSW              677
#define IDS_OLDEXISTS          678
#define IDS_ENCRYPTED          679
#define IDS_NOTREMOVEABLE      680
#define IDS_RPSWTOOSHORT       682
#define IDS_RPSWUNSPEC         683
#define IDS_RPSWDENIED         684
#define IDS_SACCTTYPE          685
#define IDS_WRONGPSW           686
#define IDS_SFINISH1A          687
#define IDS_SFINISH2A          688
#define IDS_RPSWINVALID        689
#define IDS_RPSWNOACCOUNT      690
#define IDS_SDRIVEINSTRUCTIONS  691
#define IDS_SPXTITLE              692
#define IDS_SPXSUBTITLE          693
#define IDS_RDRIVEINSTRUCTIONS  694
#define IDS_RPXTITLE              695
#define IDS_RPXSUBTITLE          696
#define IDS_SP1RETRY             697
#define IDS_SP1RETRYTITLE        698
#define    IDS_BACKUPCAPTION    699
#define    IDS_RESTORECAPTION    700
#define    IDS_MBTINVALIDPSW    701
#define    IDS_MBTMISSINGPSW    702
#define    IDS_MBMWRONGDISK    703
#define    IDS_MBTWRONGDISK     704
#define    IDS_MBMDISKERROR     705
#define    IDS_MBTDISKERROR      706
#define    IDS_MBMNODISK         707
#define    IDS_MBTNODISK         708
#define    IDS_MBMOVERWRITE     709
#define    IDS_MBTOVERWRITE     710
#define    IDS_MBTNOACCOUNT     711
#define    IDS_MBTERROR          712
#define    IDS_MBTREPLACE        713
#define    IDS_MBTWRONGPSW     714
#define    IDS_MBTINVALIDDISK    715
#define    IDS_MBTFORMAT        716
#define    IDS_MBMFORMAT        717
#define    IDS_SDRIVEPROMPT     718
#define    IDS_RDRIVEPROMPT     719
#define    IDS_MBTNODRIVE       720
#define    IDS_MBMNODRIVE       721
#define    IDS_SONLYONEDRIVE    722
#define    IDS_RONLYONEDRIVE    723
#define    IDS_SP2TITLE          724
#define    IDS_SP2SUBTITLE       725
#define    IDS_SPROGRESS         726
#define    IDS_FMBMNODISK        727
#define    IDS_MBTNOSPACE         728
#define    IDS_MBMNOSPACE        729

#define IDB_TITLE              451
#define IDB_WATERMARK          452

//#define IDC_STATIC             -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\keymgr\wizard.cpp ===
//
//  prwizard.cpp
//
//  Copyright (c) Microsoft Corp, 2000
//
//  This file contains source code for presenting UI wizards to guide the user
//  in creating a password recovery key disk/file, and using such a file to 
//  reset the password on an account.
//
//  History:
//
//  georgema       8/17/2000     Created
//
//
//  Exports: PRShowSaveWizard
//           PRShowRestoreWizard
//
// Dependencies:  shellapi.h, shell32.lib for SHGetFileInfo()

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <shellapi.h>
#include <ole2.h>
#include <wincrypt.h>
#include <security.h>
#include <secext.h>
#include <tchar.h>
#include <io.h>         // _waccess
#include <stdlib.h>
#include <commdlg.h>
#include <passrec.h>
#include <ntsecapi.h>
#include <lm.h>
#include <prsht.h>      // includes the property sheet functionality
#include "wizres.h"   // includes the definitions for the resources
#include <winioctl.h>   // disk geometry/characteristics stuff
#include <commctrl.h>
#include <netlib.h>

#include "switches.h"
#include "keymgr.h"
// All of these definitions are for updating the password hint for the user
// DirectUser and DirectUI
#ifdef PASSWORDHINT
 #include <shgina.h>
#endif
// End password hint changes
#include <comctrlp.h>
#include <shfusion.h>

#define LOGONCHANGE
#define FILESPACENEEDED 8192

extern HINSTANCE g_hInstance;   // shared with keymgr
extern HANDLE g_hFile;
extern INT g_iFileSize;

DWORD GetDriveFreeSpace(WCHAR *);
INT ReadPrivateData(BYTE **,INT *);
BOOL WritePrivateData(BYTE *,INT);
HANDLE GetOutputFile(void);
HANDLE GetInputFile(void);
void CloseInputFile(void);
void ReleaseFileBuffer(LPVOID);

BOOL c_bSaveComplete = FALSE;
#define LERROR_NO_ACCOUNT (0x80008888)

// Option switches
TCHAR pszFileName[]       = TEXT("A:\\userkey.psw");

// Symbols and variables of global significance

#define NUMSAVEPAGES    5
#define NUMRESTOREPAGES 4
#define TEMPSTRINGBUFSIZE 500
#define PSWBUFSIZE 20

#define TIMERPERIOD 1000
#define TIMERID 1001

// Error values from SaveThread
#define ERRNOFILE 2
#define ERRSAVEERROR 1
#define ERRSUCCESS 0

// Global vars contain common data needed by the pages

WCHAR     Buf[TEMPSTRINGBUFSIZE];       // gen purpose scratch string
WCHAR    rgszDrives[200];               // drive strings cache
INT         c_ArrayCount = 0;
INT         c_DriveCount = 0;
INT         c_fDrivesCounted = FALSE;
WCHAR     c_rgcPsw[PSWBUFSIZE];
WCHAR     c_rgcOldPsw[PSWBUFSIZE];
WCHAR     c_rgcFileName[MAX_PATH];
WCHAR     c_rgcUser[MAX_PATH] = {0};
WCHAR     c_rgcDomain[MAX_PATH];
HCURSOR   c_hCursor;
HWND      c_hDlg;

UINT_PTR  c_iTimer;
HWND     c_hProgress;
INT       c_iProg = 0;
HWND      c_TimerAssociatedWindow;

// Recovery data

BYTE    *c_pPrivate = NULL;
INT c_cbPrivate = 0;

// Page control handles

HWND      c_hwndSWelcome1;
HWND      c_hwndSWelcome2;
HWND      c_hwndSInstructions;
HWND      c_hwndSP1E1;
HWND      c_hwndSP1E2;
HWND      c_hwndSFinish1;
HWND      c_hwndSFinish2;
HWND      c_hwndSCancel;

HWND      c_hwndDriveInstructions;
HWND      c_hwndDrivePrompt;
HWND      c_hwndCBDriveList;

HWND      c_hwndRWelcome1;
HWND      c_hwndRWelcome2;
HWND      c_hwndRInstructions;
HWND      c_hwndRP1E1;
HWND      c_hwndRP1E2;
HWND      c_hwndRP1E3;
HWND      c_hwndRBackup;
HWND      c_hwndRFinish1;
HWND      c_hwndRFinish2;
HWND      c_hwndRCancel;

HFONT      c_hTitleFont;
BOOL       c_fIsBackup;

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Common utility functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
WCHAR *RString(INT iResID) 
{
    if (NULL == g_hInstance) goto RSError;
    INT iCount = LoadString(g_hInstance,iResID,Buf,TEMPSTRINGBUFSIZE);
    return Buf;
RSError:
    Buf[0] = 0;
    return Buf;
}

int RMessageBox(HWND hw,UINT_PTR uiResIDTitle, UINT_PTR uiResIDText, UINT uiType) 
{
    WCHAR tBuf[TEMPSTRINGBUFSIZE];
    WCHAR mBuf[TEMPSTRINGBUFSIZE];
    INT_PTR iCount = 0;
    tBuf[0] = 0;
    mBuf[0] = 0;
    if (NULL == g_hInstance) goto RMError;
    if (uiResIDTitle < 4096)
        iCount = LoadString(g_hInstance,(UINT)uiResIDTitle,tBuf,TEMPSTRINGBUFSIZE);
    else
        wcscpy(tBuf,(WCHAR *)uiResIDTitle);
    if (uiResIDTitle < 4096)
        iCount = LoadString(g_hInstance,(UINT)uiResIDText,mBuf,TEMPSTRINGBUFSIZE);
    else 
        wcscpy(mBuf,(WCHAR *)uiResIDText);
    if (0 == iCount) goto RMError;
    return MessageBox(hw,mBuf,tBuf,uiType);
RMError:
    return -1;
}

void RSetControlText(UINT uiControlID, UINT uiTextID)
{
    WCHAR tBuf[TEMPSTRINGBUFSIZE];
    INT iCount;
    if (NULL == g_hInstance) goto RSError;
    if (0 == uiTextID) goto RSError;
    iCount = LoadString(g_hInstance,uiTextID,tBuf,TEMPSTRINGBUFSIZE);
    if (0 == iCount) goto RSError;
    SetDlgItemText(c_hDlg,uiControlID,tBuf);
    return;
RSError:
    SetDlgItemText(c_hDlg,uiControlID,L"");
    return;
}

//
// Generate a font handle
//

HFONT CreateFontY(LPCTSTR pszFontName,LONG lWeight,LONG lHeight) {
    NONCLIENTMETRICS ncm = {0};
    
    if (NULL == pszFontName) return NULL;
    if (0 == lHeight) return NULL;
    ncm.cbSize = sizeof(ncm);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS,0,&ncm,0)) return NULL;
    LOGFONT TitleLogFont = ncm.lfMessageFont;
    TitleLogFont.lfWeight = lWeight;
    lstrcpy(TitleLogFont.lfFaceName,pszFontName);

    HDC hdc = GetDC(NULL);
    if (NULL == hdc) return NULL;
    INT FontSize = lHeight;
    TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72;
    HFONT h = CreateFontIndirect(&TitleLogFont);
    ReleaseDC(NULL,hdc);
    return h;
}

void CenterPage(HWND hwndIn) {
    RECT rectWorkArea;
    RECT rectWindow;
    DWORD FreeWidth, Width, FreeHeight, Height;

    if (!SystemParametersInfo(SPI_GETWORKAREA,0,&rectWorkArea,0))
    {
        return;
    }
    GetWindowRect(hwndIn,&rectWindow);
    Height = (rectWorkArea.bottom - rectWorkArea.top);
    Width = (rectWorkArea.right - rectWorkArea.left);
    FreeHeight = Height - (rectWindow.bottom - rectWindow.top);
    FreeWidth = Width - (rectWindow.right - rectWindow.left);
    MoveWindow(hwndIn,
                FreeWidth / 2,
                FreeHeight / 2,
                (rectWindow.right - rectWindow.left),
                (rectWindow.bottom - rectWindow.top),
                TRUE);
    return;
}
//
// Fetch psw, handle non-identical, ret TRUE only if c_rgcPsw filled with 
// password
//
// Used in the restore wizard.
//

BOOL FetchPsw(HWND hE1,HWND hE2) {
    TCHAR rgcE1[PSWBUFSIZE];
    TCHAR rgcE2[PSWBUFSIZE];
    INT_PTR iCount;

    rgcE1[0] = 0;
    rgcE2[0] = 0;
    if (NULL == hE1) return FALSE;
    if (NULL == hE2) return FALSE;
    iCount = SendMessage(hE1,WM_GETTEXT,PSWBUFSIZE,(LPARAM) rgcE1);
    iCount = SendMessage(hE2,WM_GETTEXT,PSWBUFSIZE,(LPARAM) rgcE2);

    if (0 != _tcscmp(rgcE1,rgcE2)) {
        RMessageBox(c_hDlg,IDS_MBTINVALIDPSW ,IDS_BADPSW ,MB_ICONHAND);
        return FALSE;
    }
#ifdef NOBLANKPASSWORD
    if (0 == _tcslen(rgcE1)) {
        RMessageBox(c_hDlg,IDS_MBTMISSINGPSW ,IDS_NOPSW ,MB_ICONHAND);
        return FALSE;
    }
#endif
    _tcscpy(c_rgcPsw,rgcE1);
    return TRUE;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// File and Disk manipulation functions
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#define FILENAMESIZE 255;

BOOL FileMediumIsRemoveable(TCHAR *pszPath) {
    return (DRIVE_REMOVABLE == GetDriveType(pszPath));
}

/*
FileMediumIsEncrypted

Accepts an input file path which may be a filename, and returns TRUE if the file
is/would be encrypted.

Note that this function touches the drive.  Attempting to call FileMediumIsEncrypted() 
on a floppy drive path with no floppy in the drive produces a pop-up error box.
*/

BOOL FileMediumIsEncrypted(TCHAR *pszPath) {
    TCHAR rgcPath[MAX_PATH];
    TCHAR *pOldHack = NULL;
    TCHAR *pHack;
    DWORD dwAttr;
#ifdef GMDEBUG
    OutputDebugString(L"File path = ");
    OutputDebugString(pszPath);
    OutputDebugString(L"\n");
#endif
    _tcsncpy(rgcPath,pszPath,MAX_PATH-1);
    pHack = rgcPath;
    do {
        pOldHack = pHack;
        pHack = _tcschr(++pHack,TCHAR('\\'));
    } while (pHack);
    if (pOldHack == NULL) return FALSE;
    *pOldHack = 0;
#ifdef GMDEBUG
    OutputDebugString(L"Trimmed path =");
    OutputDebugString(pszPath);
    OutputDebugString(L"\n");
#endif
    dwAttr = GetFileAttributes(rgcPath);
    if (-1 == dwAttr) {
        return FALSE;
    }
    if (dwAttr & FILE_ATTRIBUTE_ENCRYPTED) {
#ifdef GMDEBUG
        OutputDebugString(L"File is encrypted\n");
#endif
        return TRUE;
    }
    else return FALSE;
}

/*
CountRemoveableDrives

Called to determine whether it is appropriate to display the drive selection page.

The return value is the number of such drives available.  

    If 0, a message box announces that a backup cannot be made and why
    If 1, the drive select page should be skipped
    If more than one, the user chooses the drive
    
*/

INT CountRemoveableDrives(void) {
    //TCHAR rgszDrives[100];
    DWORD dwcc;
    TCHAR *pc;
    INT iCount = 0;

    if (c_fDrivesCounted) return c_DriveCount;
    dwcc = GetLogicalDriveStrings(200,rgszDrives);
    if (0 == dwcc) return 0;
    pc = rgszDrives;
    while (*pc != 0) {
        if (FileMediumIsRemoveable(pc)) {
            if (DRIVE_CDROM != GetDriveType(pc)) {
                iCount++;
            }
        }
        while(*pc != 0) pc++;
        pc++;
    }
    c_DriveCount = iCount;
    c_fDrivesCounted = TRUE;

    // If only 1 drive, go ahead and stamp the filename
    if (1 == iCount) pszFileName[0] = rgszDrives[0];

    return iCount;
}

// Get the UI string for the named drive
BOOL GetDriveUIString(WCHAR *pszFilePath,WCHAR *pszUIString,INT icbSize,HANDLE *phImageList,INT *piIconIndex) 
{
    WCHAR *pwc;
    WCHAR rgcModel[] = {L"A:\\"};
    SHFILEINFO sfi = {0};
    
    if (NULL == pszFilePath) return FALSE;
    if (NULL == pszUIString) return FALSE;
    rgcModel[0] = *pszFilePath;
    DWORD_PTR dwRet = SHGetFileInfo(rgcModel,FILE_ATTRIBUTE_DIRECTORY,&sfi,sizeof(sfi),
        0 |
        SHGFI_SYSICONINDEX |
        SHGFI_SMALLICON    |
        SHGFI_DISPLAYNAME);
    
    if ( 0 == dwRet) return FALSE;   // failed to get the string
    
    wcsncpy(pszUIString,sfi.szDisplayName,(icbSize / sizeof(WCHAR)) -sizeof(WCHAR));
    *piIconIndex = sfi.iIcon;
    *phImageList = (HANDLE) dwRet;
    
    return TRUE;
}

/*
ShowRemoveableDrives

Called from within SPageProcX, the page procedure for the drive selection page, this 
function gets the available logical drives on the system, filters them one by one
keeping only removeable and unencrypted volumes.

These are assigned to up to six radio button text labels on IDD_SPAGEX

The return value is the number of such drives available.  

    If 0, a message box announces the failure condition, and the wizard exits
    If 1, this page is skipped, and that drive letter is inserted in the file name string
    If more than one, the user chooses the drive
    
*/

INT ShowRemoveableDrives(void) {
    //TCHAR rgszDrives[200];
    DWORD dwcc;
    TCHAR *pc;
    WCHAR rgcszUI[80];
    HANDLE hIcons;
    INT iIcons;
    HWND hPrompt;
    HWND hCombo;
    HANDLE hImageList = NULL;
    BOOL fSetImageList = TRUE;
    COMBOBOXEXITEM stItem = {0};
    INT iDrive = 0;

    ASSERT(c_hwndCBDriveList);
    // test and show
    dwcc = GetLogicalDriveStrings(200,rgszDrives);
    if (0 == dwcc) goto fail;
    pc = rgszDrives;
    while (*pc != 0) {
        rgcszUI[0] = 0;
        if (!GetDriveUIString(pc,rgcszUI,80,&hIcons,&iIcons)) goto fail;

        if ((fSetImageList) && (hIcons != NULL))
        {
            // set image list for the edit control to the system image list
            //  returned from GetDriveUIString
            SendMessage(c_hwndCBDriveList,CBEM_SETIMAGELIST,
                        0,(LPARAM)(HIMAGELIST) hIcons);
            fSetImageList = FALSE;
        }
#ifdef LOUDLY
        {
            OutputDebugString(L"Drive ");
            OutputDebugString(pc);
            OutputDebugString(L"=");
            OutputDebugString(rgcszUI);
            OutputDebugString(L"\n");
        }
#endif
        if (FileMediumIsRemoveable(pc)) {
            if (DRIVE_CDROM != GetDriveType(pc)) {
#ifdef LOUDLY
        {
            WCHAR sz[100];
            _stprintf(sz,L"Drive %s added as removeable drive index %d\n",pc,iDrive);
            OutputDebugString(sz);
        }
#endif
                // add string to combo box
                stItem.mask = CBEIF_SELECTEDIMAGE |CBEIF_IMAGE | CBEIF_TEXT | CBEIF_LPARAM;
                stItem.pszText = rgcszUI;
                stItem.iImage = iIcons;
                stItem.iSelectedImage = iIcons;
                stItem.lParam = iDrive;
                stItem.iItem = -1;
                SendMessage(c_hwndCBDriveList,CBEM_INSERTITEM,0,(LPARAM) &stItem);
            }
        }
        iDrive++;
        while(*pc != 0) pc++;
        pc++;
    }
    c_ArrayCount = iDrive;
    SendMessage(c_hwndCBDriveList,CB_SETCURSEL,0,0);
    return 1;
fail:
    // show message box
    return 0;
}

// Get drive letter for zero-based drive number from the drive name strings in rgszDrives.
//  Note that c_ArrayCount is 1-based.
WCHAR GetDriveLetter(INT iDrive) 
{
    WCHAR *pc;
    pc = rgszDrives;                // point to global array of strings
    if (iDrive == 0) return *pc;    // base drive letter
    if (iDrive < 0) return *pc;    // unselected drive letter, return base
    if (iDrive >= c_ArrayCount) return *pc;
    for (INT i=0;i<iDrive;i++) 
    {   
        while(*pc == 0) pc++;
        while(*pc++ != 0);
    }
    return *pc;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Password restore/recover functionality routines called within the UI 
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/****************************************************************************\

ExistsOldKey

Inputs: TCHAR pszUser

Returns: TRUE if user has an existing password backup, FALSE otherwise.

The username string is an account name on the local machine, not prefixed by the 
machine name.

\****************************************************************************/

BOOL ExistsOldKey(TCHAR *pszUser) {
    DWORD BUStatus;
    if (0 == PRQueryStatus(NULL, pszUser,&BUStatus)) {
        if (0 == BUStatus) return TRUE;
    }
    return FALSE;
}

/****************************************************************************\

GetNames()

Gets local machine domain name and the username for later use by LogonUser() to 
test the password entered by the user.  A username may be passed in via psz.  If 
psz is NULL, the currently logged in username will be used.  Retrieved strings are 
placed in global strings c_rgcDomain and c_rgcUser.

Inputs: WCHAR username string 

Call with NULL psz to use currently logged on username

Returns:    void

If function fails, the affected global string is set to empty string.
 
\****************************************************************************/
void GetNames(WCHAR *psz) {
    OSVERSIONINFOEXW versionInfo;
    BOOL fIsDC = FALSE;
    WCHAR *pName = NULL;
    DWORD dwStatus;
    DWORD dwcb;
    
    versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    if (GetVersionEx((OSVERSIONINFO *)&versionInfo)) 
    {
        fIsDC = (versionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER);
    }
    if (fIsDC)
    {
        dwStatus = NetpGetDomainName(&pName);
        if (dwStatus == NO_ERROR)
        {
            wcscpy(c_rgcDomain,pName);
            NetApiBufferFree(pName);
        }
        else c_rgcDomain[0] = 0;
    }
    else
    {
        dwStatus = NetpGetComputerName(&pName);
        if (dwStatus == NO_ERROR)
        {
            wcscpy(c_rgcDomain,pName);
            NetApiBufferFree(pName);
        }
        else c_rgcDomain[0] = 0;
    }
    if (psz)
    {
        wcscpy(c_rgcUser,psz);
    }
    else 
    {
        dwcb = MAX_PATH;
        GetUserNameW(c_rgcUser,&dwcb);
    }
#ifdef LOUDLY
    OutputDebugString(L"GetNames: ");
    OutputDebugString(c_rgcDomain);
    OutputDebugString(L" ");
    OutputDebugString(c_rgcUser);
    OutputDebugString(L"\n");
    OutputDebugString(L"Passed Username = ");
    if (psz)OutputDebugString(psz);
    OutputDebugString(L"\n");
#endif
}

#ifdef PASSWORDHINT
HRESULT 
SetUserHint(LPCWSTR pszAccountName,LPCWSTR pszNewHint)
{
    HRESULT hr;
    ILogonEnumUsers *pUsers = NULL;
    VARIANT var;

    hr = CoCreateInstance(CLSID_ShellLogonEnumUsers,
                        NULL, 
                        CLSCTX_INPROC_SERVER,
                        IID_ILogonEnumUsers,
                        (void **) &pUsers);
    if (SUCCEEDED(hr))
    {
        ILogonUser       *pUser = NULL;
        
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pszAccountName);
        hr = pUsers->item(var,&pUser);
        if (SUCCEEDED(hr))
        {
            VariantClear(&var);                 // free embedded bstr
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(pszNewHint);
            hr = pUser->put_setting(L"Hint",var);
            // There is no fallback for failure to set the hint.  Just proceed.
            pUser->Release();
        }
        VariantClear(&var);                 // free embedded bstr
        pUsers->Release();
    }
     return hr;
}
#endif

DWORD
SetAccountPassword(void) {
    NET_API_STATUS ns;
    DWORD dwErr;
    BOOL fRet = FALSE;

#ifdef LOUDLY
    OutputDebugString(L"SetAccountPassword called\n");
#endif
    c_pPrivate = 0;
    if (!ReadPrivateData(&c_pPrivate,&c_cbPrivate)){
        dwErr = GetLastError();
#ifdef LOUDLY
    	OutputDebugString(L"ReadFile failed\n");
#endif
        goto cleanup;
    }
#ifdef LOUDLY
    if (0 == c_cbPrivate) OutputDebugString(L"recovery file is empty\n");
    if (0 != c_cbPrivate) OutputDebugString(L"SAP: nonempty private blob, new password :");
    OutputDebugString(c_rgcPsw);
    OutputDebugString(L"\n");
#endif
    if( (c_rgcUser[0]   == 0)) {
        memset(c_rgcPsw,0,sizeof(c_rgcPsw));
        return LERROR_NO_ACCOUNT;
    }
    dwErr = PRRecoverPassword(c_rgcUser,
                        c_pPrivate,
                      c_cbPrivate,
                      c_rgcPsw);

    // Release the disk buffer of private data, flush the password buffer
    if (NULL != c_pPrivate) ReleaseFileBuffer((LPVOID) c_pPrivate);
    c_pPrivate = NULL;
    CloseInputFile();
    memset(c_rgcPsw,0,PSWBUFSIZE * sizeof(TCHAR));
   
    if (0 != dwErr) {
#ifdef LOUDLY
        TCHAR Bufr[100];
        _stprintf(Bufr,L"PRRecoverPassword returns %0x\n",dwErr);
        OutputDebugString(Bufr);
#endif
    }
#ifdef PASSWORDHINT
    else
    {
        INT_PTR icb = 0;
        WCHAR szHint[256];
        szHint[0] = 0;
        icb = SendMessage(c_hwndRP1E3,WM_GETTEXT,255,(LPARAM)szHint);
        SetUserHint(c_rgcUser,szHint);
    }
#endif
cleanup:
    return dwErr;
}

/****************************************************************************\

SaveInfo

Inputs: void, uses globals c_rgcUser, c_rgcPsw

Returns:  INT, returns nonzero if a password backup has been generated on the host
            machine, and a valid private blob has been generated and written to the
            target disk

\****************************************************************************/
INT
SaveInfo(void) {

    BOOL fError = TRUE;
    DWORD dwRet;
    BOOL fStatus = FALSE;
    BYTE *pPrivate = NULL;
    DWORD cbPrivate = 0;

    c_hCursor = LoadCursor(g_hInstance,IDC_WAIT);
    c_hCursor = SetCursor(c_hCursor);

#ifdef LOUDLY
    OutputDebugString(L"SaveInfo: Username = ");
    OutputDebugString(c_rgcUser);
    OutputDebugString(L"\n");
#endif
#ifdef LOUDLY
    OutputDebugString(c_rgcUser);
    OutputDebugString(L" \\ ");
    OutputDebugString(c_rgcPsw);
    OutputDebugString(L"\n");
#endif

    dwRet = PRGenerateRecoveryKey(c_rgcUser,
                                  c_rgcPsw,
                                  &pPrivate,
                                  &cbPrivate);
#ifdef LOUDLY
    OutputDebugString(L"PRGenerateRecoveryKey returns\n");
#endif

if (ERROR_SUCCESS != dwRet) {
#ifdef LOUDLY
        OutputDebugString(L"GenerateRecoveryKey failed\n");
#endif
        goto cleanup;
    }

    if (!WritePrivateData(pPrivate,cbPrivate)) {
#ifdef LOUDLY
    OutputDebugString(L"WriteOutputFile failed\n");
#endif
        // delete output file if created
        DeleteFile(pszFileName);
        goto cleanup;
    }

    SetFileAttributes(pszFileName,FILE_ATTRIBUTE_READONLY);
    if (0 == cbPrivate) goto cleanup;

    fStatus = TRUE;
    fError = FALSE;
cleanup:
    // zero buffer of c_usPassword (our local psw buffer)
    memset(c_rgcPsw,0,sizeof(c_rgcPsw));
    memset(pPrivate,0,cbPrivate);
    
    if (fError) {
        KillTimer(c_TimerAssociatedWindow,TIMERID);
        RMessageBox(c_hDlg,IDS_MBTERROR ,IDS_SERROR ,MB_ICONHAND);
        c_iTimer = SetTimer(c_TimerAssociatedWindow,TIMERID,TIMERPERIOD,NULL);
    }
//cleanupnomsg:
    if (fError) {
        // delete output file
        if (g_hFile) {
            CloseHandle(g_hFile);
            g_hFile = NULL;
            DeleteFile(pszFileName);
        }
    }
    if (NULL != g_hFile) {
        CloseHandle(g_hFile);
        g_hFile = NULL;
    }
    if (pPrivate) LocalFree(pPrivate);
    return fStatus;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// WELCOME page proc doesn't have to do much
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INT_PTR CALLBACK SPageProc0(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   switch (message)
   {
       case WM_INITDIALOG:
           {
               TCHAR SBuf[TEMPSTRINGBUFSIZE];
               c_hDlg = hDlg;
               c_hwndSWelcome1 = GetDlgItem(hDlg,IDC_SWELCOME1);
               if (NULL != c_hTitleFont) SendMessage(c_hwndSWelcome1,WM_SETFONT,(WPARAM) c_hTitleFont,(LPARAM) TRUE);
               LoadString(g_hInstance,IDS_SWELCOME1,SBuf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSWelcome1,WM_SETTEXT,0,(LPARAM)SBuf);
               c_hwndSWelcome2 = GetDlgItem(hDlg,IDC_SWELCOME2);
               LoadString(g_hInstance,IDS_SWELCOME2,SBuf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSWelcome2,WM_SETTEXT,0,(LPARAM)SBuf);
               break;
           }
       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               // crack the incoming command messages
               INT NotifyId = HIWORD(wParam);
               INT ControlId = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg,DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_SETACTIVE:
                   // state following a BACK from the next page

                   CenterPage(GetParent(hDlg));

                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
                   break;

               case PSN_RESET:
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;
               
               case PSN_WIZNEXT:
                   break;
                   
               default:
                   return FALSE;
           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// PAGE1 page proc, where the real work is done
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

DWORD c_iThread;
DWORD dwThreadReturn;

DWORD WINAPI SaveThread(LPVOID lpv) {
       HWND hw = (HWND) lpv;
       c_bSaveComplete = FALSE;
       if (g_hFile == NULL) {
           c_bSaveComplete = TRUE;
           dwThreadReturn = ERRNOFILE;
           return 2;
       }
       if (FALSE == SaveInfo()) {
           if (g_hFile) CloseHandle(g_hFile);
           g_hFile = NULL;
           c_bSaveComplete = TRUE;
           dwThreadReturn = ERRSAVEERROR;
           return 1;
       }
       if (g_hFile) CloseHandle(g_hFile);
       g_hFile = NULL;
       c_bSaveComplete = TRUE;
       dwThreadReturn = ERRSUCCESS;
       return 0;
}

// Dialog procedure for the drive selection page.  This page is common to both the backup and
// restore wizards, with the instruction text being selected on the basis of which mode is being
// exercised.

INT_PTR CALLBACK SPageProcX(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           {
              c_hwndDriveInstructions = GetDlgItem(hDlg,IDC_DRIVEINSTRUCTIONS);
              c_hwndDrivePrompt = GetDlgItem(hDlg,IDC_DRIVEPROMPT);
              c_hwndCBDriveList = GetDlgItem(hDlg,IDC_COMBO);
              if (1 == CountRemoveableDrives()) 
              {
                 if (c_fIsBackup) 
                 {
                     WCHAR temp[TEMPSTRINGBUFSIZE];
                     WCHAR *pc = RString(IDS_SONLYONEDRIVE);
                     swprintf(temp,pc,pszFileName[0]);
                     SendMessage(c_hwndDriveInstructions,WM_SETTEXT,0,(LPARAM)temp);
                 }
                 else
                 {
                     WCHAR temp[TEMPSTRINGBUFSIZE];
                     WCHAR *pc = RString(IDS_RONLYONEDRIVE);
                     swprintf(temp,pc,pszFileName[0]);
                     SendMessage(c_hwndDriveInstructions,WM_SETTEXT,0,(LPARAM)temp);
                 }
                  ShowWindow(c_hwndDrivePrompt,SW_HIDE);
                  ShowWindow(c_hwndCBDriveList,SW_HIDE);
              }
              else
              {
                  ShowRemoveableDrives();
              }
              break;
           }

       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               i = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;

               case PSN_SETACTIVE:
                   // Set data in the UI, Set up sequence buttons
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                   break;
                       
               case PSN_WIZNEXT:

				   // take first character (drive letter) of the text associated with the 
				   // selected radio button and copy it to the filename in the drive
				   // letter position.
                    {
                        LRESULT lr;
                        INT iDrive = 0;
                        COMBOBOXEXITEM stCBItem = {0};
                        lr = SendMessage(c_hwndCBDriveList,CB_GETCURSEL,0,0);
                        if (CB_ERR == lr) OutputDebugString(L"ComboBox select error\n");
                        if (CB_ERR == lr) iDrive = 0;
                        else 
                        {
                            stCBItem.mask = CBEIF_LPARAM;
                            stCBItem.iItem = lr;
                            lr = SendMessage(c_hwndCBDriveList,CBEM_GETITEM,0,(LPARAM)&stCBItem);
                            if (CB_ERR != lr)
                            {
                                iDrive = (INT) stCBItem.lParam;
                            }
                        }
                        pszFileName[0] = GetDriveLetter(iDrive);
#ifdef LOUDLY
                        WCHAR sz[200];
                        _stprintf(sz,L"Index value = %d\n",iDrive);
                        OutputDebugString(sz);
                        OutputDebugString(L"File target set to ");
                        OutputDebugString(pszFileName);
                        OutputDebugString(L"\n");
#endif
                    }
                   if (!c_fIsBackup) {
                       if (NULL == GetInputFile()) {
                           // failed to open file
                           SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGEXS);
                           return TRUE;
                       }
                   }
                   return FALSE;
                   break;

               default:
                   return FALSE;

           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

INT_PTR CALLBACK SPageProc1(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           {
               HWND hC = GetDlgItem(hDlg,PSBTN_CANCEL);
               if (NULL != hC) ShowWindow(hC,SW_HIDE);
               c_hwndSInstructions = GetDlgItem(hDlg,IDC_SINSTRUCTIONS);
               c_hwndSP1E1 = GetDlgItem(hDlg,IDC_SP1E1);
               LoadString(g_hInstance,IDS_SP1INSTRUCTIONS,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSInstructions,WM_SETTEXT,0,(LPARAM)Buf);
               break;
           }

       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               i = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   // reset data to the original values
                   SendMessage(c_hwndSP1E1,WM_SETTEXT,0,0);
                   //SendMessage(c_hwndSP1E2,WM_SETTEXT,0,0);
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;

               case PSN_SETACTIVE:
                   // Set data in the UI, Set up sequence buttons
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                   break;

               case PSN_WIZNEXT:
                {
                        //Fetch the data and process it - if FALSE, stay on this page
                        // allow null password
                        HANDLE hToken = NULL;
                        BOOL fPswOK = FALSE;

                        SendMessage(c_hwndSP1E1,WM_GETTEXT,sizeof(c_rgcPsw),(LPARAM)c_rgcPsw);

                        fPswOK = LogonUser(c_rgcUser,c_rgcDomain,c_rgcPsw,
                                                LOGON32_LOGON_INTERACTIVE,
                                                LOGON32_PROVIDER_DEFAULT,
                                                &hToken);
                        if (hToken) CloseHandle(hToken);
#ifdef LOGONCHANGE
                        if (!fPswOK)
                        {
                            DWORD dwErr = GetLastError();
                            if ((ERROR_ACCOUNT_RESTRICTION != dwErr) || (wcslen(c_rgcPsw) != 0))
                            {
                                RMessageBox(c_hDlg,IDS_MBTWRONGPSW,IDS_WRONGPSW,MB_ICONHAND);
                                SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                                return TRUE;
                            }
                        }
#else
                        if (!fPswOK) 
                        {
                           RMessageBox(c_hDlg,IDS_MBTWRONGPSW,IDS_WRONGPSW,MB_ICONHAND);
                           SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                           return TRUE;
                        }
#endif
                        if ( ExistsOldKey(c_rgcUser)) {
                            INT i;
                            i = RMessageBox(c_hDlg,IDS_MBTREPLACE ,IDS_OLDEXISTS ,MB_YESNO);
                            if (i != IDYES) 
                            {
                                SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                                return TRUE;
                            }
                        }
                        
                        if (NULL == GetOutputFile()) {
                            SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                            return TRUE;
                        }

                        if (FILESPACENEEDED > GetDriveFreeSpace(pszFileName))
                        {
                            // if still not enough space, let go of the attempt to create an output file, 
                            //  or successive attempts will fail for a sharing violation
                            if (g_hFile) 
                            {
                                CloseHandle(g_hFile);
                                g_hFile = NULL;
                            }
                            RMessageBox(c_hDlg,IDS_MBTNOSPACE ,IDS_MBMNOSPACE ,MB_OK);
                            SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_SPAGE1);
                            return TRUE;
                        }
                        
                        // SaveInfo() will zero the psw buffer
                        CreateThread(NULL,0,SaveThread,(LPVOID)NULL,0,&c_iThread);
                        return FALSE;
                   }
                   break;

               default:
                   return FALSE;

           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FINISH page proc - reach this page only on success?
//
// This page receives timer interrupts, advancing the progress bar at each one.  When c_bSaveComplete indicates
// that the operation is complete, it shuts off the timer and waits for the user to advance to the next page.
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
INT_PTR CALLBACK SPageProc2(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   WCHAR Msg[200];
   WCHAR Tpl[200];
   Tpl[0] = 0;
   Msg[0] = 0;

   LoadString(g_hInstance,IDS_SPROGRESS,Tpl,200 -1);
   HWND hP = GetDlgItem(hDlg,IDC_SPROGRESS);
   
   switch (message)
   {
       case WM_TIMER:
           // advance the progress bar
           SendMessage(c_hProgress,PBM_STEPIT,0,0);
           c_iProg += 5;
           if (100 <= c_iProg) c_iProg = 95;
           // Stop advancing when c_bSaveComplete is nonzero, and
           if (c_bSaveComplete) {
#ifdef LOUDLY
        OutputDebugString(L"SPageProc2: Save Complete on timer tick\n");
#endif
               KillTimer(hDlg,TIMERID);
               c_iTimer =0;
               memset(c_rgcPsw,0,PSWBUFSIZE * sizeof(TCHAR));
               if (dwThreadReturn == ERRSUCCESS) {
                   // set text to indicate complete
                   SendMessage(c_hProgress,PBM_SETPOS,100,0);
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
                   c_iProg = 100;
               }
               else {
                   SendMessage(c_hProgress,PBM_SETPOS,0,0);
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK);
                   c_iProg = 0;
               }
           }
           swprintf(Msg,Tpl,c_iProg);
           if (hP) SendMessage(hP,WM_SETTEXT,0,(LPARAM)Msg);
           break;
            
       case WM_INITDIALOG:
           {
               // instead of starting the timer here, do it on the set active
               //  notification, since the init is not redone if you rearrive at
               //  this page after an error.
               c_hProgress = GetDlgItem(hDlg,IDC_PROGRESS1);
               break;
           }

       case WM_COMMAND:
            break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {
               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   memset(c_rgcPsw,0,PSWBUFSIZE * sizeof(TCHAR));
                   // rest to the original values
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;

               case PSN_SETACTIVE:
                   PropSheet_SetWizButtons(GetParent(hDlg),0);
                   PropSheet_CancelToClose(GetParent(hDlg));
                   SendMessage(c_hProgress,PBM_SETSTEP,5,0);
                   SendMessage(c_hProgress,PBM_SETPOS,0,0);
                   // Start a timer
                   c_iTimer = 0;
                   c_iProg = 0;
                   c_iTimer = SetTimer(hDlg,TIMERID,TIMERPERIOD,NULL);
                   c_TimerAssociatedWindow = hDlg;
                   // Set controls to state indicated by data
                   // Set BACK/FINISH instead of BACK/NEXT
                   break;

               case PSN_WIZBACK:
                   break;


               case PSN_WIZNEXT:
                   // Done
                  memset(c_rgcPsw,0,PSWBUFSIZE * sizeof(TCHAR));
                  if (c_iTimer) KillTimer(hDlg,TIMERID);
                  c_iTimer = 0;
                  break;

               default:
                   return FALSE;
           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

INT_PTR CALLBACK SPageProc3(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           {
               // instead of starting the timer here, do it on the set active
               //  notification, since the init is not redone if you rearrive at
               //  this page after an error.
               c_hwndSFinish1 = GetDlgItem(hDlg,IDC_SFINISH1);
               c_hwndSFinish2 = GetDlgItem(hDlg,IDC_SFINISH2);
               if (NULL != c_hTitleFont) SendMessage(c_hwndSFinish1,WM_SETFONT,(WPARAM) c_hTitleFont,(LPARAM) TRUE);     
               LoadString(g_hInstance,IDS_SFINISH1,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSFinish1,WM_SETTEXT,0,(LPARAM)Buf);
               PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH);
               LoadString(g_hInstance,IDS_SFINISH2,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndSFinish2,WM_SETTEXT,0,(LPARAM)Buf);
               break;
           }

       case WM_COMMAND:
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {
               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   // reset to the original values
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;

               case PSN_SETACTIVE:
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH);
                   PropSheet_CancelToClose(GetParent(hDlg));
                   break;

               case PSN_WIZBACK:
                   break;


               case PSN_WIZFINISH:
                   // Done
                   memset(c_rgcPsw,0,PSWBUFSIZE * sizeof(TCHAR));
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;

               default:
                   return FALSE;
           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// WELCOME page proc doesn't have to do much
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INT_PTR CALLBACK RPageProc0(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
   switch (message)
   {
       case WM_INITDIALOG:
           {
               c_hDlg = hDlg;
               c_hwndRWelcome1 = GetDlgItem(hDlg,IDC_RWELCOME1);
               if (NULL != c_hTitleFont) SendMessage(c_hwndRWelcome1,WM_SETFONT,(WPARAM) c_hTitleFont,(LPARAM) TRUE);
               LoadString(g_hInstance,IDS_RWELCOME1,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndRWelcome1,WM_SETTEXT,0,(LPARAM)Buf);
               c_hwndRWelcome2 = GetDlgItem(hDlg,IDC_RWELCOME2);
               LoadString(g_hInstance,IDS_RWELCOME2,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndRWelcome2,WM_SETTEXT,0,(LPARAM)Buf);
               break;
           }
       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               // crack the incoming command messages
               INT NotifyId = HIWORD(wParam);
               INT ControlId = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg,DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_SETACTIVE:
                   // state following a BACK from the next page
               
                   CenterPage(GetParent(hDlg));

                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_NEXT);
                   break;

               case PSN_WIZNEXT:
                    break;
                   
               case PSN_RESET:
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;
               
               default:
                   return FALSE;
           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// PAGE1 page proc, where the real work is done
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INT_PTR CALLBACK RPageProc1(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
    INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           {
               Buf[0] = 0;
               c_hwndRInstructions = GetDlgItem(hDlg,IDC_RINSTRUCTIONS);
               c_hwndRP1E1 = GetDlgItem(hDlg,IDC_RP1E1);
               c_hwndRP1E2 = GetDlgItem(hDlg,IDC_RP1E2);
               c_hwndRP1E3 = GetDlgItem(hDlg,IDC_RP1E3);
               LoadString(g_hInstance,IDS_RP1INSTR,Buf,TEMPSTRINGBUFSIZE);
               SendMessage(c_hwndRInstructions,WM_SETTEXT,0,(LPARAM)Buf);
               break;
           }

       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
           {
               i = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {
               DWORD dwRet;

               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   // reset data to the original values
                   if (c_pPrivate) free(c_pPrivate);
                   c_pPrivate = NULL;
                   memset(c_rgcPsw,0,PSWBUFSIZE * sizeof(TCHAR));
                   SendMessage(c_hwndRP1E1,WM_SETTEXT,0,0);
                   SendMessage(c_hwndRP1E2,WM_SETTEXT,0,0);
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;

               case PSN_SETACTIVE:
                   // Set data in the UI, Set up sequence buttons
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                   break;

               case PSN_WIZBACK:
                   CloseInputFile();
                   return FALSE;
                   break;
                   
                case PSN_WIZNEXT:
                   //Fetch the data and process it
                   if (!FetchPsw(c_hwndRP1E1,c_hwndRP1E2)) {
                       // psw buffers empty if you get here - FetchPsw will have told
                       //  the user what to do
                       SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_RPAGE1);
                       return TRUE;
                   }
                   
                   // SetAccountPassword will clean the psw buffers
                   dwRet = SetAccountPassword();
                   if (ERROR_SUCCESS == dwRet) {
                       if (c_pPrivate) free(c_pPrivate);
                       c_pPrivate = NULL;
                       return FALSE;
                   }
                   else if (NERR_PasswordTooShort == dwRet) {
                       // Password doesn't conform - try again
                       RMessageBox(hDlg,IDS_MBTINVALIDPSW,IDS_RPSWTOOSHORT,MB_ICONHAND);
                       SendMessage(c_hwndRP1E1,WM_SETTEXT,0,(LPARAM)0);
                       SendMessage(c_hwndRP1E2,WM_SETTEXT,0,(LPARAM)0);
                       SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_RPAGE1);
                       return TRUE;
                   }
                   else if (NTE_BAD_DATA == dwRet){
                       // ya might get this using an obsolete disk?
                       if (c_pPrivate) free(c_pPrivate);
                       c_pPrivate = NULL;
                       RMessageBox(hDlg,IDS_MBTINVALIDDISK ,IDS_RPSWERROR ,MB_ICONHAND);
                       SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_RWELCOME);
                       return TRUE;
                   }
                   else {
                       RMessageBox(hDlg,IDS_MBTERROR,IDS_RPSWUNSPEC,MB_ICONHAND);
                       SetWindowLong(hDlg,DWLP_MSGRESULT,IDD_RWELCOME);
                       return TRUE;
                   }
                   return FALSE;
                   break;

               default:
                   return FALSE;

           }
           break;

       default:
           return FALSE;
   }
   return TRUE;   
}


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// FINISH page proc - reach this page only on success?
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

INT_PTR CALLBACK RPageProc2(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam)
{
    INT i;
    
   switch (message)
   {
       case WM_INITDIALOG:
           c_hwndRFinish1 = GetDlgItem(hDlg,IDC_RFINISH1);
               if (NULL != c_hTitleFont) SendMessage(c_hwndRFinish1,WM_SETFONT,(WPARAM) c_hTitleFont,(LPARAM) TRUE);
           LoadString(g_hInstance,IDS_RFINISH1,Buf,TEMPSTRINGBUFSIZE);
           SendMessage(c_hwndRFinish1,WM_SETTEXT,0,(LPARAM)Buf);
           c_hwndRFinish2 = GetDlgItem(hDlg,IDC_RFINISH2);
           LoadString(g_hInstance,IDS_RFINISH2,Buf,TEMPSTRINGBUFSIZE);
           SendMessage(c_hwndRFinish2,WM_SETTEXT,0,(LPARAM)Buf);
           break;

       case WM_COMMAND:
           if (HIWORD(wParam) == BN_CLICKED)
            {
               i = LOWORD(wParam);
           }
           break;              

       case WM_NOTIFY:
           switch (((NMHDR FAR *) lParam)->code) 
           {
               case PSN_KILLACTIVE:
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   return 1;
                   break;

               case PSN_RESET:
                   // rest to the original values
                   SetWindowLong(hDlg, DWLP_MSGRESULT, FALSE);
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;

               case PSN_SETACTIVE:
                   // Set controls to state indicated by data
                   // Set BACK/FINISH instead of BACK/NEXT
                   PropSheet_SetWizButtons(GetParent(hDlg),PSWIZB_FINISH);
                   PropSheet_CancelToClose(GetParent(hDlg));
                   break;

                case PSN_WIZBACK:
                    break;


                case PSN_WIZFINISH:
                    // Done
                   if (c_hTitleFont) DeleteObject(c_hTitleFont);
                   break;

               default:
                   return FALSE;
       }
       break;

       default:
           return FALSE;
   }
   return TRUE;   
}

/////////////////////////////////////////////////////////////////////////
// 
// Common Routines for all pages


// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void InitPropertyPage( PROPSHEETPAGE* psp,
                       INT idDlg,
                       DLGPROC pfnDlgProc,
                       DWORD dwFlags,
                       LPARAM lParam)
{
    memset((LPVOID)psp,0,sizeof(PROPSHEETPAGE));
    psp->dwFlags = dwFlags;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pfnDlgProc = pfnDlgProc;
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->hInstance = g_hInstance;
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Set the text for title and subtitle for Wizard97 style pages
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void SetPageHeaderText(PROPSHEETPAGE *psp,
                       INT iTitle,
                       INT iSubTitle)
{
    if (0 != (psp->dwFlags & PSP_HIDEHEADER)) return;
    if (0 != iTitle) {
        psp->pszHeaderTitle = MAKEINTRESOURCE(iTitle);
        psp->dwFlags |= PSP_USEHEADERTITLE;
    }
    if (0 != iSubTitle) {
        psp->pszHeaderSubTitle = MAKEINTRESOURCE(iSubTitle);
        psp->dwFlags |= PSP_USEHEADERSUBTITLE;
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// Set the page's title bar caption
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void SetPageCaption(PROPSHEETPAGE *psp,
                    INT iTitle)
{
    if (0 != iTitle) {
        psp->pszTitle = MAKEINTRESOURCE(iTitle);
        psp->dwFlags |= PSP_USETITLE;
    }
}

// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
// PRShow[Save|Restore]Wizard()
//
//  Pass the HWND of the owning window, and pass the instance handle of
//  the enclosing binary, for the purpose of locating resources
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//INT_PTR PRShowSaveWizard(HWND hwndOwner)
void APIENTRY PRShowSaveWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    PROPSHEETPAGE psp[NUMSAVEPAGES];
    HPROPSHEETPAGE hpsp[NUMSAVEPAGES];
    PROPSHEETHEADER psh;
    INT_PTR iRet;

    if (NULL == hwndOwner) hwndOwner = GetForegroundWindow();
    
    HANDLE hMutex = CreateMutex(NULL,TRUE,TEXT("PRWIZARDMUTEX"));
    if (NULL == hMutex) return;
    if (ERROR_ALREADY_EXISTS == GetLastError()) {
        CloseHandle(hMutex);
        return;
    }
    c_fIsBackup = TRUE;
    
    c_hTitleFont = CreateFontY(TEXT("MS Shell Dlg"),FW_BOLD,12);
#ifdef LOUDLY
    if (NULL == c_hTitleFont) OutputDebugString(L"Title font missing\n");
    if (NULL == hwndOwner) OutputDebugString(L"Owner window handle missing\n");
#endif

    InitPropertyPage( &psp[0], IDD_SWELCOME, SPageProc0, PSP_HIDEHEADER,0);
    InitPropertyPage( &psp[1], IDD_SPAGEXS  , SPageProcX, PSP_DEFAULT   ,0);
    InitPropertyPage( &psp[2], IDD_SPAGE1  , SPageProc1, PSP_DEFAULT   ,0);
    InitPropertyPage( &psp[3], IDD_SPAGE2  , SPageProc2, PSP_DEFAULT, 0);
    InitPropertyPage( &psp[4], IDD_SFINISH , SPageProc3, PSP_HIDEHEADER,0);
    
    SetPageHeaderText(&psp[1], IDS_SPXTITLE,IDS_SPXSUBTITLE);
    SetPageHeaderText(&psp[2], IDS_SP1TITLE,IDS_SP1SUBTITLE);
    SetPageHeaderText(&psp[3], IDS_SP2TITLE,IDS_SP2SUBTITLE);

    for (INT j=0;j<NUMSAVEPAGES;j++)
        hpsp[j] = CreatePropertySheetPage((LPCPROPSHEETPAGE) &psp[j]);
    
    psh.dwSize         = sizeof(PROPSHEETHEADER);
    psh.dwFlags        = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    psh.hwndParent     = hwndOwner;
    psh.pszCaption     = RString(IDS_BACKUPCAPTION);
    psh.nPages         = NUMSAVEPAGES;
    psh.nStartPage     = 0;
    psh.phpage           = (HPROPSHEETPAGE *) &hpsp;
    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader    = MAKEINTRESOURCE(IDB_TITLE);
    psh.hInstance      = g_hInstance;

    // modal property sheet
    SetErrorMode(0);
    iRet = PropertySheet(&psh);
#ifdef LOUDLY
    if (iRet < 0) {
        WCHAR sz[200];
        DWORD dwErr = GetLastError();
        swprintf(sz,L"PropertySheet() failed : GetLastError() returns: %d\n",dwErr);
        OutputDebugString(sz);
    }
#endif
    if (c_hTitleFont) DeleteObject (c_hTitleFont);
    if (hMutex) CloseHandle(hMutex);
    return;
}

//INT_PTR PRShowRestoreWizard(HWND hwndOwner)
void APIENTRY PRShowRestoreWizardW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    PROPSHEETPAGE psp[NUMRESTOREPAGES];
    HPROPSHEETPAGE hpsp[NUMRESTOREPAGES];
    PROPSHEETHEADER psh;
    INT_PTR iRet;
    BOOL fICC;
    INITCOMMONCONTROLSEX stICC;

    OleInitialize(NULL);

    // Initialize common controls in two steps
    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC = ICC_WIN95_CLASSES | ICC_DATE_CLASSES | ICC_USEREX_CLASSES;
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
    if (fICC) OutputDebugString(L"Common control init 2 OK\n");
    else OutputDebugString(L"Common control init 2 FAILED\n");
#endif

    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC =  ICC_WINLOGON_REINIT;
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
    if (fICC) OutputDebugString(L"Common control init 1 OK\n");
    else OutputDebugString(L"Common control init 1 FAILED\n");
#endif
    c_fIsBackup = FALSE;
    GetNames(pszCmdLine);         // If name is null, get current user (debug/test use)

    c_hTitleFont = CreateFontY(TEXT("MS Shell Dlg"),FW_BOLD,12);
#ifdef LOUDLY
    if (NULL == c_hTitleFont) OutputDebugString(L"Title font missing\n");
    if (NULL == hwndOwner) OutputDebugString(L"Owner window handle missing\n");
#endif

    InitPropertyPage( &psp[0], IDD_RWELCOME, RPageProc0,PSP_HIDEHEADER,0);
    InitPropertyPage( &psp[1], IDD_SPAGEXR  , SPageProcX,PSP_DEFAULT   ,0);
    InitPropertyPage( &psp[2], IDD_RPAGE1  , RPageProc1,PSP_DEFAULT   ,0);
    InitPropertyPage( &psp[3], IDD_RFINISH , RPageProc2,PSP_HIDEHEADER,0);
    
    SetPageHeaderText(&psp[1], IDS_RPXTITLE,IDS_RPXSUBTITLE);
    SetPageHeaderText(&psp[2], IDS_RP1TITLE,IDS_RP1SUBTITLE);
    
    for (INT j=0;j<NUMRESTOREPAGES;j++)
        hpsp[j] = CreatePropertySheetPage((LPCPROPSHEETPAGE) &psp[j]);
    
    psh.dwSize         = sizeof(PROPSHEETHEADER);
    psh.dwFlags        = PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    psh.hwndParent     = hwndOwner;
    psh.pszCaption     = RString(IDS_RESTORECAPTION);
    psh.nPages         = NUMRESTOREPAGES;
    psh.nStartPage     = 0;
    psh.phpage         = (HPROPSHEETPAGE *) &hpsp;
    psh.pszbmWatermark  = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader    = MAKEINTRESOURCE(IDB_TITLE);
    psh.hInstance      = g_hInstance;

    iRet = PropertySheet(&psh);
#ifdef LOUDLY
    if (iRet < 0) {
        WCHAR sz[200];
        DWORD dwErr = GetLastError();
        swprintf(sz,L"PropertySheet() returns %x: GetLastError() returns: %d\n", iRet, dwErr);
        OutputDebugString(sz);
    }
#endif
    if (c_hTitleFont) DeleteObject (c_hTitleFont);
    OleUninitialize();
    return;
}

// ==================================
//
// These are the real exports from KEYMGR:

// PRShowSaveWizardExW - call from cpl applet, passing window title as pszCmdLine
// PRShowSaveFromMsginaW - call from MSGINA, passing username as pszCmdLine
// PRShowRestoreWizardExW - call from cpl applet, passing username as pszCmdLine
// PRShowRestoreFromMsginaW - call from MSGINA, passing username as pszCmdLine

// This export was added so that the backup wizard could be called from the system context
// (in which msgina runs).  The username is taken from the UI and passed into the wizard,
// which uses it to create the backup key for that account.
//
// The global username string, c_rgcUser, is normally a null string until it is set by either
// getting the current logged user, or matching the SID found in a backup key.  This api
// prestuffs that value.  When it is found non-null, then GetUsernameW() is not called in 
// SaveInfo() where the backup is made.

//INT_PTR PRShowSaveWizardEx(HWND hwndOwner, TCHAR *pszUser) 
void APIENTRY PRShowSaveWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
#ifdef LOUDLY
    OutputDebugString(L"\n\n\n");
#endif
    BOOL fICC;
    if (0 == CountRemoveableDrives()) 
    {
        RMessageBox(hwndOwner,IDS_MBTNODRIVE,IDS_MBMNODRIVE,MB_ICONHAND);
        return;
    }
    INITCOMMONCONTROLSEX stICC;
    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC = ICC_WIN95_CLASSES | ICC_USEREX_CLASSES;
    OleInitialize(NULL);
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
        if (fICC) OutputDebugString(L"Common control init OK\n");
        else OutputDebugString(L"Common control init FAILED\n");
#endif
    // String passed in for this function is the window title for the user mgr.
    // To get current logged user, call GetNames with NULL arg.
    GetNames(NULL);

    if (pszCmdLine != NULL) {
#ifdef LOUDLY
            OutputDebugString(L"*********");
            OutputDebugString(pszCmdLine);
            OutputDebugString(L"\n");
#endif
            hwndOwner = FindWindow(L"HTML Application Host Window Class",pszCmdLine);
    }
#ifdef LOUDLY
    else OutputDebugString(L"NULL passed in pszCmdLine\n");
#endif
    PRShowSaveWizardW(hwndOwner,NULL,NULL,NULL);
    OleUninitialize();
    return;
}

void APIENTRY PRShowSaveFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    BOOL fICC;
    if (0 == CountRemoveableDrives()) 
    {
        RMessageBox(hwndOwner,IDS_MBTNODRIVE,IDS_MBMNODRIVE,MB_ICONHAND);
        return;
    }
    INITCOMMONCONTROLSEX stICC;
    stICC.dwSize = sizeof(INITCOMMONCONTROLSEX);
    stICC.dwICC = ICC_WINLOGON_REINIT;
    OleInitialize(NULL);
    fICC = InitCommonControlsEx(&stICC);
#ifdef LOUDLY
        if (fICC) OutputDebugString(L"Common control init OK\n");
        else OutputDebugString(L"Common control init FAILED\n");
#endif
    GetNames(pszCmdLine);
    PRShowSaveWizardW(hwndOwner,g_hInstance,NULL,NULL);
    OleUninitialize();
    return;
}

//INT_PTR PRShowRestoreWizardEx(HWND hwndOwner, TCHAR *pszUser) 
void APIENTRY PRShowRestoreWizardExW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    if (NULL == hwndOwner) hwndOwner = GetActiveWindow();
    if (0 == CountRemoveableDrives()) 
    {
        RMessageBox(hwndOwner,IDS_MBTNODRIVE,IDS_MBMNODRIVE,MB_ICONHAND);
        return;
    }
    PRShowRestoreWizardW(hwndOwner,NULL,pszCmdLine,NULL);
    return;
}

void APIENTRY PRShowRestoreFromMsginaW(HWND hwndOwner,HINSTANCE hInstance,LPWSTR pszCmdLine,int nCmdShow)
{
    if (NULL == hwndOwner) hwndOwner = GetActiveWindow();
    if (0 == CountRemoveableDrives()) 
    {
        RMessageBox(hwndOwner,IDS_MBTNODRIVE,IDS_MBMNODRIVE,MB_ICONHAND);
        return;
    }
    PRShowRestoreWizardW(hwndOwner,NULL,pszCmdLine,NULL);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\common\cr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cr.c

Abstract:

    Local Security Authority - Cipher Routines common to Client and Server

    These routines interface the LSA client or server sides with the Cipher
    Routines.  They perform RPC-style memory allocation.

Author:

    Scott Birrell       (ScottBi)     December 13, 1991

Environment:

Revision History:

--*/

#include <lsacomp.h>

VOID
LsapCrFreeMemoryValue(
    IN PVOID MemoryValue
    )

/*++

Routine Description:

    This function frees the memory allocated for an Cipher Value.

Arguments:

    None.

Return Value:

--*/

{
    //
    // The memory is currently a counted string contained in a UNICODE
    // STRING structure in which the buffer follows the structure.  A
    // single MIDL_user_free will therefore do the trick.
    //

    MIDL_user_free(MemoryValue);
}


NTSTATUS
LsapCrEncryptValue(
    IN OPTIONAL PLSAP_CR_CLEAR_VALUE ClearValue,
    IN PLSAP_CR_CIPHER_KEY CipherKey,
    OUT PLSAP_CR_CIPHER_VALUE *CipherValue
    )

/*++

Routine Description:

    This function two-way encrypts a Value with the given Cipher Key
    and allocates memory for the output.  The memory must be freed after
    use by calling LsapCrFreeMemoryValue().

Arguments:

    ClearValue - Pointer to structure referencing value to be encrypted.
        A NULL pointer may be specified.

    CipherKey - Pointer to structure referencing the Cipher Key

    CipherValue - Receives a pointer to a structure referencing the
        encrypted value or NULL.

Return Value:

--*/

{
    NTSTATUS Status;
    LSAP_CR_CIPHER_VALUE TempCipherValue;
    PLSAP_CR_CIPHER_VALUE OutputCipherValue = NULL;
    ULONG CipherValueBufferLength;
    LSAP_CR_CLEAR_VALUE LocalFake = { 0 };

    //
    // If NULL is specified for input, return NULL for output.
    //

    if (!ARGUMENT_PRESENT(ClearValue)) {

        *CipherValue = NULL;
        ClearValue = &LocalFake ;
    }

    //
    // Obtain the length of the encrypted value buffer that will be
    // required by calling the encryption routine in 'query' mode
    // by passing a pointer to a return Cipher Value structure containing
    // a MaximumLength of 0.
    //

    TempCipherValue.MaximumLength = 0;
    TempCipherValue.Length = 0;
    TempCipherValue.Buffer = NULL;

    Status = LsapCrRtlEncryptData(
                 ClearValue,
                 CipherKey,
                 &TempCipherValue
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        goto EncryptValueError;
    }

    //
    // Allocate memory for the output structure followed by buffer.
    //

    CipherValueBufferLength = TempCipherValue.Length;
    Status = STATUS_INSUFFICIENT_RESOURCES;

    OutputCipherValue = MIDL_user_allocate(
                            sizeof (LSAP_CR_CIPHER_VALUE) +
                            CipherValueBufferLength
                            );

    if (OutputCipherValue == NULL) {

        goto EncryptValueError;
    }

    //
    // Initialize Cipher Value structure.  The Buffer pointer is set to
    // to point to the byte following the structure header.
    //

    OutputCipherValue->Buffer = (PCHAR)(OutputCipherValue + 1);
    OutputCipherValue->MaximumLength = CipherValueBufferLength;
    OutputCipherValue->Length = CipherValueBufferLength;

    //
    // Now call the two-way encryption routine.
    //

    Status = LsapCrRtlEncryptData(
                 ClearValue,
                 CipherKey,
                 OutputCipherValue
                 );

    if (NT_SUCCESS(Status)) {

        *CipherValue = OutputCipherValue;
        return(Status);
    }

EncryptValueError:

    //
    // If necessary, free the memory allocated for the output encrypted value.
    //

    if (OutputCipherValue != NULL) {

        MIDL_user_free(OutputCipherValue);
    }

    *CipherValue = NULL;
    return(Status);
}


NTSTATUS
LsapCrDecryptValue(
    IN OPTIONAL PLSAP_CR_CIPHER_VALUE CipherValue,
    IN PLSAP_CR_CIPHER_KEY CipherKey,
    OUT PLSAP_CR_CLEAR_VALUE *ClearValue
    )

/*++

Routine Description:

    This function decrypts a Value that has been two-way Cipher with the
    given Cipher Key and allocates memory for the output.  The memory
    must be freed after use by calling LsapCrFreeMemoryValue();

Arguments:

    CipherValue - Pointer to structure referencing encrypted Value.

    CipherKey - Pointer to structure referencing the Cipher Key

    ClearValue - Receives a pointer to a structure referencing the
        Decrypted Value.

Return Value:

--*/

{
    NTSTATUS Status;
    LSAP_CR_CLEAR_VALUE TempClearValue;
    PLSAP_CR_CLEAR_VALUE OutputClearValue = NULL;
    ULONG ClearValueBufferLength;

    //
    // If NULL is specified for input, return NULL for output.
    //

    if (!ARGUMENT_PRESENT(CipherValue)) {

        *ClearValue = NULL;

    } else {

         if ( CipherValue->MaximumLength < CipherValue->Length ||
              ( CipherValue->Length != 0 && CipherValue->Buffer == NULL ) ) {
             return STATUS_INVALID_PARAMETER;
         }
    }

    //
    // Obtain the length of the decrypted (clear) value buffer that will be
    // required by calling the decryption routine in 'query' mode
    // by passing a pointer to a return Clear Value structure containing
    // a MaximumLength of 0.
    //

    TempClearValue.MaximumLength = 0;
    TempClearValue.Length = 0;
    TempClearValue.Buffer = NULL;

    Status = LsapCrRtlDecryptData(
                 CipherValue,
                 CipherKey,
                 &TempClearValue
                 );

    //
    // Since we supplied a buffer length of 0, we would normally expect
    // to receive STATUS_BUFFER_TOO_SMALL back plus the buffer size required.
    // There is one exceptional case and that is where the original
    // unencrypted data had length 0.  In this case, we expect
    // STATUS_SUCCESS and a length required equal to 0 returned.
    //

    if (Status != STATUS_BUFFER_TOO_SMALL) {

        if (!(Status == STATUS_SUCCESS && TempClearValue.Length == 0)) {
            goto DecryptValueError;
        }
    }

    //
    // Allocate memory for the output structure followed by buffer.
    //

    ClearValueBufferLength = TempClearValue.Length;
    Status = STATUS_INSUFFICIENT_RESOURCES;

    OutputClearValue = MIDL_user_allocate(
                            sizeof (LSAP_CR_CLEAR_VALUE) +
                            ClearValueBufferLength
                            );

    if (OutputClearValue == NULL) {

        goto DecryptValueError;
    }

    //
    // Initialize Clear Value structure.  The Buffer pointer is set to
    // to point to the byte following the structure header.
    //

    OutputClearValue->Buffer = (PCHAR)(OutputClearValue + 1);
    OutputClearValue->MaximumLength = ClearValueBufferLength;
    OutputClearValue->Length = ClearValueBufferLength;

    //
    // Now call the two-way decryption routine.
    //

    Status = LsapCrRtlDecryptData(
                 CipherValue,
                 CipherKey,
                 OutputClearValue
                 );

    if (NT_SUCCESS(Status)) {

        *ClearValue = OutputClearValue;
        return(Status);
    }

DecryptValueError:

    //
    // If necessary, free the memory allocated for the output decrypted value.
    //

    if (OutputClearValue != NULL) {

        MIDL_user_free(OutputClearValue);
    }

    *ClearValue = NULL;
    return(Status);
}


VOID
LsapCrUnicodeToClearValue(
    IN OPTIONAL PUNICODE_STRING UnicodeString,
    OUT PLSAP_CR_CLEAR_VALUE ClearValue
    )

/*++

Routine Description:

    This function converts a Unicode structure to a Clear Value structure.

Arguments:

    UnicodeString - Optional pointer to Unicode string.  If NULL, the
        output Clear Value structure is initialized to have zero
        length and Maximum length, and with a NULL buffer pointer.

    ClearValue - Pointer to Clear Value structure.

Return Value:

    None.

--*/

{

    UNICODE_STRING IntermediateUnicodeString;

    if (ARGUMENT_PRESENT(UnicodeString)) {

        IntermediateUnicodeString = *UnicodeString;

        ClearValue->Length = (ULONG) IntermediateUnicodeString.Length;
        ClearValue->MaximumLength = (ULONG) IntermediateUnicodeString.MaximumLength;
        ClearValue->Buffer = (PUCHAR) IntermediateUnicodeString.Buffer;
        return;
    }

    ClearValue->Length = ClearValue->MaximumLength = 0;
    ClearValue->Buffer = NULL;
}


VOID
LsapCrClearValueToUnicode(
    IN OPTIONAL PLSAP_CR_CLEAR_VALUE ClearValue,
    OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This function converts a Clear Value to a Unicode String.  The Clear
    Value structure must have valid syntax - no checking will be done.


Arguments:

    ClearValue - Optional pointer to Clear Value to be converted.  If
        NULL is specified, the output Unicode String structure will
        be initialized to point to the NULL string.

    UnicodeString - Pointer to target Unicode String structure.

Return Value:

    None.

--*/

{
    LSAP_CR_CLEAR_VALUE IntermediateClearValue;

    if (ARGUMENT_PRESENT(ClearValue)) {

        IntermediateClearValue = *ClearValue;

        UnicodeString->Length = (USHORT) IntermediateClearValue.Length;
        UnicodeString->MaximumLength = (USHORT) IntermediateClearValue.MaximumLength;
        UnicodeString->Buffer = (PWSTR) IntermediateClearValue.Buffer;
        return;
    }

    UnicodeString->Length = UnicodeString->MaximumLength = 0;
    UnicodeString->Buffer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\client\autest1.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    autest1.c

Abstract:

    This module performs a set of authentication package/logon
    process testing.


    TO BUILD:

        nmake UMTYPE=console UMTEST=autest1


Author:

    Jim Kelly  3-Apr-1992.

Revision History:

--*/




#include <nt.h>
#include <ntlsa.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>




///////////////////////////////////////////////////////////////////////
//                                                                   //
// Locally needed data types                                         //
//                                                                   //
///////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////
//                                                                   //
// Local Macros                                                      //
//                                                                   //
///////////////////////////////////////////////////////////////////////










///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////
//                                                                   //
// Internal routine definitions
//                                                                   //
///////////////////////////////////////////////////////////////////////

VOID
main (
    IN int c,
    IN PCHAR v[]
    );



///////////////////////////////////////////////////////////////////////
//                                                                   //
// Routines                                                          //
//                                                                   //
///////////////////////////////////////////////////////////////////////


VOID
main (
    IN int c,
    IN PCHAR v[]
    )
/*++


Routine Description:

    This routine is the main entry routine for this test.

Arguments:

    TBS

Return Value:

    TBS

--*/
{
    NTSTATUS Status;
    STRING LPName;
    HANDLE LsaHandle;
    LSA_OPERATIONAL_MODE SecurityMode;

    RtlInitString( &LPName, "Test");


    DbgPrint("Temporary Restriction:  THIS TEST MUST BE RUN WITH TCB ENABLED\n\n");






    //
    // register as a logon process
    //

    DbgPrint("Registering as logon process . . . . . . . . .");
    Status = LsaRegisterLogonProcess( &LPName, &LsaHandle, &SecurityMode );
    if (NT_SUCCESS(Status)) {

        DbgPrint("Succeeded\n");



        //
        // de-register as a logon process
        //

        DbgPrint("Deregistering as logon process . . . . . . . .");
        Status = LsaDeregisterLogonProcess( LsaHandle );
        if (NT_SUCCESS(Status)) {

            DbgPrint("Succeeded\n");
        } else {
            DbgPrint("*** FAILED ***\n");
        }

    } else {
        DbgPrint("*** FAILED ***\n");
    }

        DBG_UNREFERENCED_PARAMETER(c);
        DBG_UNREFERENCED_PARAMETER(v);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\block.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    block.c

Abstract:

    Block encryption functions implementation :

        RtlEncryptBlock
        RtlDecryptBlock
        RtlEncrypStdBlock


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Scott Field (sfield)    03-Nov-97
        Removed critical section around crypto calls.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>
#include <engine.h>

#include <nturtl.h>

#include <windows.h>

#ifdef WIN32_CHICAGO
#include <assert.h>
#undef ASSERT
#define ASSERT(exp) assert(exp)
#endif // WIN32_CHICAGO

#include <ntddksec.h>

#ifndef KMODE
#ifndef WIN32_CHICAGO

HANDLE g_hKsecDD = NULL;

VOID EncryptMemoryShutdown( VOID );

#endif
#endif


BOOLEAN
Sys003Initialize(
    IN PVOID hmod,
    IN ULONG Reason,
    IN PCONTEXT Context
    )
{
#ifndef KMODE
#ifndef WIN32_CHICAGO
    if( Reason == DLL_PROCESS_DETACH )
    {
        EncryptMemoryShutdown();
    }
#endif
#endif

    return TRUE;

    DBG_UNREFERENCED_PARAMETER(hmod);
    DBG_UNREFERENCED_PARAMETER(Context);
}



NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    )

/*++

Routine Description:

    Takes a block of data and encrypts it with a key producing
    an encrypted block of data.

Arguments:

    ClearBlock - The block of data that is to be encrypted.

    BlockKey - The key to use to encrypt data

    CypherBlock - Encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The data was encrypted successfully. The encrypted
                     data block is in CypherBlock

    STATUS_UNSUCCESSFUL - Something failed. The CypherBlock is undefined.
--*/

{
    unsigned Result;

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)ClearBlock,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
#if DBG
        DbgPrint("EncryptBlock failed\n\r");
#endif
        return(STATUS_UNSUCCESSFUL);
    }
}




NTSTATUS
RtlDecryptBlock(
    IN PCYPHER_BLOCK CypherBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCLEAR_BLOCK ClearBlock
    )
/*++

Routine Description:

    Takes a block of encrypted data and decrypts it with a key producing
    the clear block of data.

Arguments:

    CypherBlock - The block of data to be decrypted

    BlockKey - The key to use to decrypt data

    ClearBlock - The decrpted block of data is returned here


Return Values:

    STATUS_SUCCESS - The data was decrypted successfully. The decrypted
                     data block is in ClearBlock

    STATUS_UNSUCCESSFUL - Something failed. The ClearBlock is undefined.
--*/

{
    unsigned Result;

    Result = DES_ECB_LM(DECR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)CypherBlock,
                        (unsigned char *)ClearBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
#if DBG
        DbgPrint("DecryptBlock failed\n\r");
#endif
        return(STATUS_UNSUCCESSFUL);
    }
}



NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    )

/*++

Routine Description:

    Takes a block key encrypts the standard text block with it.
    The resulting encrypted block is returned.
    This is a One-Way-Function - the key cannot be recovered from the
    encrypted data block.

Arguments:

    BlockKey - The key to use to encrypt the standard text block.

    CypherBlock - The encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The encryption was successful.
                     The result is in CypherBlock

    STATUS_UNSUCCESSFUL - Something failed. The CypherBlock is undefined.
--*/

{
    unsigned Result;
    char StdEncrPwd[] = "KGS!@#$%";

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)StdEncrPwd,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
#if DBG
        DbgPrint("EncryptStd failed\n\r");
#endif
        return(STATUS_UNSUCCESSFUL);
    }
}

#ifndef KMODE
#ifndef WIN32_CHICAGO

BOOLEAN
EncryptMemoryInitialize(
    VOID
    )
{
    UNICODE_STRING DriverName;
    OBJECT_ATTRIBUTES ObjA;
    IO_STATUS_BLOCK IOSB;
    HANDLE hFile;
    NTSTATUS Status;

    RtlInitUnicodeString( &DriverName, DD_KSEC_DEVICE_NAME_U );
    InitializeObjectAttributes(
                &ObjA,
                &DriverName,
                0,
                NULL,
                NULL
                );

    Status = NtOpenFile(
                &hFile,
                SYNCHRONIZE | FILE_READ_DATA,
                &ObjA,
                &IOSB,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                FILE_SYNCHRONOUS_IO_ALERT
                );

    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    if(InterlockedCompareExchangePointer(
                &g_hKsecDD,
                hFile,
                NULL
                ) != NULL)
    {
        NtClose( hFile );
    }

    return TRUE;
}

VOID
EncryptMemoryShutdown(
    VOID
    )
{
    if( g_hKsecDD != NULL )
    {
        NtClose( g_hKsecDD );
        g_hKsecDD = NULL;
    }

}

NTSTATUS
RtlEncryptMemory(
    IN      PVOID Memory,
    IN      ULONG MemorySize,
    IN      ULONG OptionFlags
    )
{
    IO_STATUS_BLOCK IoStatus;
    ULONG IoControlCode;

    if( g_hKsecDD == NULL )
    {
        if(!EncryptMemoryInitialize())
        {
            return STATUS_UNSUCCESSFUL;
        }
    }

    switch( OptionFlags )
    {
        case 0:
        {
            IoControlCode = IOCTL_KSEC_ENCRYPT_MEMORY;
            break;
        }

        case RTL_ENCRYPT_OPTION_CROSS_PROCESS:
        {
            IoControlCode = IOCTL_KSEC_ENCRYPT_MEMORY_CROSS_PROC;
            break;
        }

        case RTL_ENCRYPT_OPTION_SAME_LOGON:
        {
            IoControlCode = IOCTL_KSEC_ENCRYPT_MEMORY_SAME_LOGON;
            break;
        }

        default:
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    return NtDeviceIoControlFile(
                g_hKsecDD,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                IoControlCode,
                Memory,
                MemorySize,          // output buffer size
                Memory,
                MemorySize
                );
}

NTSTATUS
RtlDecryptMemory(
    IN      PVOID Memory,
    IN      ULONG MemorySize,
    IN      ULONG OptionFlags
    )
{
    IO_STATUS_BLOCK IoStatus;
    ULONG IoControlCode;

    if( g_hKsecDD == NULL )
    {
        if(!EncryptMemoryInitialize())
        {
            return STATUS_UNSUCCESSFUL;
        }
    }

    switch( OptionFlags )
    {
        case 0:
        {
            IoControlCode = IOCTL_KSEC_DECRYPT_MEMORY;
            break;
        }

        case RTL_ENCRYPT_OPTION_CROSS_PROCESS:
        {
            IoControlCode = IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC;
            break;
        }

        case RTL_ENCRYPT_OPTION_SAME_LOGON:
        {
            IoControlCode = IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON;
            break;
        }

        default:
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    return NtDeviceIoControlFile(
                g_hKsecDD,
                NULL,
                NULL,
                NULL,
                &IoStatus,
                IoControlCode,
                Memory,
                MemorySize,          // output buffer size
                Memory,
                MemorySize
                );

}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\common\lsaprtl.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaprtl.c

Abstract:

    Local Security Authority - Temporary Rtl Routine Definitions.

    This file contains routines used in the LSA that could be made into Rtl
    routines.  They have been written in general purpose form with this in
    mind - the only exception to thisa is that their names have Lsap prefixes
    to indicate that they are currently used only by the LSA.

Author:

    Scott Birrell       (ScottBi)      April 8, 1992

Environment:

Revision History:

--*/

#include <lsacomp.h>
#include <align.h>


BOOLEAN
LsapRtlPrefixSid(
    IN PSID PrefixSid,
    IN PSID Sid
    )

/*++

Routine Description:

    This function checks if one Sid is the Prefix Sid of another.

Arguments:

    PrefixSid - Pointer to Prefix Sid.

    Sid - Pointer to Sid to be checked.

Return Values:

    BOOLEAN - TRUE if PrefixSid is the Prefix Sid of Sid, else FALSE.

--*/

{
    BOOLEAN BooleanStatus = FALSE;

    if ((*RtlSubAuthorityCountSid(Sid)) > 0) {

        //
        // Decrement the SubAuthorityCount of Sid temporarily.
        //

        (*RtlSubAuthorityCountSid(Sid))--;

        //
        // Compare the Prefix Sid with the modified Sid.
        //

        BooleanStatus = RtlEqualSid( PrefixSid, Sid);

        //
        // Restore the original SubAuthorityCount.
        //

        (*RtlSubAuthorityCountSid(Sid))++;
    }

    return(BooleanStatus);
}


BOOLEAN
LsapRtlPrefixName(
    IN PUNICODE_STRING PrefixName,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This function checks if a Name has the given name as a Prefix

Arguments:

    PrefixName - Pointer to Prefix Name.

    Name - Pointer to Name to be checked.

Return Values:

    BOOLEAN - TRUE if the Name is composite (i.e. contains a "\") and
                   PrefixName is the Prefix part of Name, else FALSE.

--*/

{
    UNICODE_STRING TruncatedName = *Name;

    if ((PrefixName->Length < Name->Length) &&
        Name->Buffer[PrefixName->Length / 2] == L'\\') {

        TruncatedName.Length = PrefixName->Length;

        if (RtlEqualUnicodeString(PrefixName, &TruncatedName, FALSE)) {

            return(TRUE);
        }
    }

    return(FALSE);
}


VOID
LsapRtlSplitNames(
    IN PUNICODE_STRING Names,
    IN ULONG Count,
    IN PUNICODE_STRING Separator,
    OUT PUNICODE_STRING PrefixNames,
    OUT PUNICODE_STRING SuffixNames
    )

/*++

Routine Description:

    This function splits an array of Names into Prefix and Suffix parts
    separated by the given separator.  The input array may contain names of
    the following form:

    <SuffixName>
    <PrefixName> "\" <SuffixName>
    The NULL string

    Note that the output arrays will reference the original name strings.
    No copying is done.

Arguments:

    Names - Pointer to array of Unicode Names.

    Count - Count of Names in Names.

    PrefixNames - Pointer to an array of Count Unicode String structures
        that will be initialized to point to the Prefix portions of the
        Names.

    SuffixNames - Pointer to an array of Count Unicode String structures
        that will be initialized to point to the Suffix portions of the
        Names.

Return Values:

    None.

--*/

{
    ULONG Index;
    LONG SeparatorOffset;
    LONG WideSeparatorOffset;

    //
    // Scan each name, initializing the output Unicode structures.
    //

    for (Index = 0; Index < Count; Index++) {

        PrefixNames[Index] = Names[Index];
        SuffixNames[Index] = Names[Index];

        //
        // Locate the separator "\" if any.
        //

        SeparatorOffset = LsapRtlFindCharacterInUnicodeString(
                              &Names[Index],
                              Separator,
                              FALSE
                              );

        //
        // If there is a separator, make the Prefix Name point to the
        // part of the name before the separator and make the Suffix Name
        // point to the part of the name after the separator.  If there
        // is no separator, set the Prefix Name part to Null.  Rememeber
        // that the Length fields are byte counts, not Wide Character
        // counts.
        //

        if (SeparatorOffset >= 0) {

            WideSeparatorOffset = (SeparatorOffset / sizeof(WCHAR));
            PrefixNames[Index].Length = (USHORT) SeparatorOffset;
            SuffixNames[Index].Buffer += (WideSeparatorOffset + 1);
            SuffixNames[Index].Length -= (USHORT)(SeparatorOffset + sizeof(WCHAR));

        } else {

            WideSeparatorOffset = SeparatorOffset;
            PrefixNames[Index].Length = 0;
        }

        //
        // Set MaximumLengths equal to Lengths and, for safety, clear buffer
        // pointers(s) to NULL in output strings if Length(s) are 0.
        //

        PrefixNames[Index].MaximumLength = PrefixNames[Index].Length;
        SuffixNames[Index].MaximumLength = SuffixNames[Index].Length;

        if (PrefixNames[Index].Length == 0) {

            PrefixNames[Index].Buffer = NULL;
        }

        if (SuffixNames[Index].Length == 0) {

            SuffixNames[Index].Buffer = NULL;
        }
    }
}


LONG
LsapRtlFindCharacterInUnicodeString(
    IN PUNICODE_STRING InputString,
    IN PUNICODE_STRING Character,
    IN BOOLEAN CaseInsensitive
    )

/*++

Routine Description:

    This function returns the byte offset of the first occurrence (if any) of
    a Unicode Character within a Unicode String.

Arguments

    InputString - Pointer to Unicode String to be searched.

    Character - Pointer to Unicode String initialized to character
        to be searched for.

    CaseInsensitive - TRUE if case is to be ignored, else FALSE.
    NOTE - Only FALSE is supported just now.

Return Value:

    LONG - If the character is present within the string, its non-negative
        byte offset is returned.  If the character is not present within
        the string, a negative value is returned.

--*/

{
    BOOLEAN CharacterFound = FALSE;
    ULONG Offset = 0;

    if (!CaseInsensitive) {

        Offset = 0;

        while (Offset < InputString->Length) {

            if (*(Character->Buffer) ==
                InputString->Buffer[Offset / sizeof (WCHAR)]) {

                CharacterFound = TRUE;
                break;
            }

            Offset += 2;
        }

    } else {

        //
        // Case Insensitive is not supported
        //

        CharacterFound = FALSE;
    }

    if (!CharacterFound) {

        Offset = LSA_UNKNOWN_ID;
    }

    return(Offset);
}


VOID
LsapRtlSetSecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    NOTE! THIS ROUTINE IS IDENTICAL WITH SeSetSecurityAccessMask()
    IN \nt\private\ntos\se\semethod.c

    This routine builds an access mask representing the accesses necessary
    to set the object security information specified in the SecurityInformation
    parameter.  While it is not difficult to determine this information,
    the use of a single routine to generate it will ensure minimal impact
    when the security information associated with an object is extended in
    the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        modified.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to modify the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        (*DesiredAccess) |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;
}


VOID
LsapRtlQuerySecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    NOTE! THIS ROUTINE IS IDENTICAL WITH SeQuerySecurityAccessMask()
    IN \nt\private\ntos\se\semethod.c.

    This routine builds an access mask representing the accesses necessary
    to query the object security information specified in the
    SecurityInformation parameter.  While it is not difficult to determine
    this information, the use of a single routine to generate it will ensure
    minimal impact when the security information associated with an object is
    extended in the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        queried.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to query the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION) ||
        (SecurityInformation & DACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= READ_CONTROL;
    }

    if ((SecurityInformation & SACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;

}


NTSTATUS
LsapRtlSidToUnicodeRid(
    IN PSID Sid,
    OUT PUNICODE_STRING UnicodeRid
    )

/*++

Routine Description:

    This function extracts the Relative Id (Rid) from a Sid and
    converts it to a Unicode String.  The Rid is extracted and converted
    to an 8-digit Unicode Integer.

Arguments:

    Sid - Pointer to the Sid to be converted.  It is the caller's
        responsibility to ensure that the Sid has valid syntax.

    UnicodeRid -  Pointer to a Unicode String structure that will receive
        the Rid in Unicode form.  Note that memory for the string buffer
        in this Unicode String will be allocated by this routine if
        successful.  The caller must free this memory after use by calling
        RtlFreeUnicodeString.

Return Value:

    NTSTATUS - Standard Nt Status code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to allocate buffer for Unicode String name.
--*/

{
    NTSTATUS Status;
    ULONG Rid;
    UCHAR SubAuthorityCount;
    UCHAR RidNameBufferAnsi[9];

    ANSI_STRING CharacterSidAnsi;

    //
    // First, verify that the given Sid is valid
    //

    if (!RtlValidSid( Sid )) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Sid is valid.  If however, the SubAuthorityCount is zero,
    // we cannot have a Rid so return error.
    //

    SubAuthorityCount = ((PISID) Sid)->SubAuthorityCount;

    if (SubAuthorityCount == 0) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Sid has at least one subauthority.  Get the lowest subauthority
    // (i.e. the Rid).
    //

    Rid = ((PISID) Sid)->SubAuthority[SubAuthorityCount - 1];

    //
    // Now convert the Rid to an 8-digit numeric character string
    //

    Status = RtlIntegerToChar( Rid, 16, -8, RidNameBufferAnsi );

    //
    // Need to add null terminator to string
    //

    RidNameBufferAnsi[8] = 0;

    //
    // Initialize an ANSI string structure with the converted name.
    //

    RtlInitString( &CharacterSidAnsi, RidNameBufferAnsi );

    //
    // Convert the ANSI string structure to Unicode form
    //

    Status = RtlAnsiStringToUnicodeString(
                 UnicodeRid,
                 &CharacterSidAnsi,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}


NTSTATUS
LsapRtlPrivilegeSetToLuidAndAttributes(
    IN OPTIONAL PPRIVILEGE_SET PrivilegeSet,
    OUT PULONG PrivilegeCount,
    OUT PLUID_AND_ATTRIBUTES *LuidAndAttributes
    )

/*++

Routine Description:

    This function converts a Privilege Set to a Privilege Count and Luid and
    Attributes array.

Arguments:

    PrivilegeSet - Pointer to Privilege Set to be converted.  If NULL or a zero
        length Privilege Set is specified, NULL is returned for the LUID and
        attributes pointer, with a Privilege Count of 0.

    PrivilegeCount - Receives the output Privilege Count

    LuidAndAttributes - Receives pointer to Luid and Attributes array.  If there
        are no privileges, NULL is returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLUID_AND_ATTRIBUTES OutputLuidAndAttributes = NULL;
    ULONG OutputPrivilegeCount = 0;
    ULONG LuidAndAttributesLength;

    if (PrivilegeSet != NULL) {

        OutputPrivilegeCount = PrivilegeSet->PrivilegeCount;

        if (OutputPrivilegeCount > 0) {

            //
            // Allocate space for the output LUID_AND_ATTRIBUTES array.
            //

            LuidAndAttributesLength = sizeof(LUID_AND_ATTRIBUTES) * OutputPrivilegeCount;


            OutputLuidAndAttributes = MIDL_user_allocate( LuidAndAttributesLength );

            if (OutputLuidAndAttributes == NULL) {

                Status = STATUS_NO_MEMORY;
                goto PrivilegeSetToLuidAndAttributesError;
            }

            Status = STATUS_SUCCESS;

            //
            // Copy the LUID and attributes from the input Privilege Set.
            //

            RtlCopyMemory(
                OutputLuidAndAttributes,
                PrivilegeSet->Privilege,
                LuidAndAttributesLength
                );
        }
    }

    //
    // Return LUID and Attributes array or NULL, plus Count.
    //

    *LuidAndAttributes = OutputLuidAndAttributes;
    *PrivilegeCount = OutputPrivilegeCount;

PrivilegeSetToLuidAndAttributesFinish:

    return(Status);

PrivilegeSetToLuidAndAttributesError:

    goto PrivilegeSetToLuidAndAttributesFinish;
}


NTSTATUS
LsapRtlWellKnownPrivilegeCheck(
    IN PVOID ObjectHandle,
    IN BOOLEAN ImpersonateClient,
    IN ULONG PrivilegeId,
    IN OPTIONAL PCLIENT_ID ClientId
    )

/*++

Routine Description:

    This function checks if the given well known privilege is enabled for an
    impersonated client or for the current process.

Arguments:

    ImpersonateClient - If TRUE, impersonate the client.  If FALSE, don't
        impersonate the client (we may already be doing so).

    PrivilegeId -  Specifies the well known Privilege Id

    ClientId - Specifies the client process/thread Id.  If already
        impersonating the client, or impersonation is requested, this
        parameter should be omitted.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and the client
            is either trusted or has the necessary privilege enabled.

--*/

{
    NTSTATUS Status, SecondaryStatus;
    BOOLEAN PrivilegeHeld = FALSE;
    HANDLE ClientThread = NULL, ClientProcess = NULL, ClientToken = NULL;
    OBJECT_ATTRIBUTES NullAttributes;
    PRIVILEGE_SET Privilege;
    BOOLEAN ClientImpersonatedHere = FALSE;
    UNICODE_STRING SubsystemName;

    InitializeObjectAttributes( &NullAttributes, NULL, 0, NULL, NULL );

    //
    // If requested, impersonate the client.
    //

    if (ImpersonateClient) {

        Status = I_RpcMapWin32Status(RpcImpersonateClient( NULL ));

        if ( !NT_SUCCESS(Status) ) {

            goto WellKnownPrivilegeCheckError;
        }

        ClientImpersonatedHere = TRUE;
    }

    //
    // If a client process other than ourself has been specified , open it
    // for query information access.
    //

    if (ARGUMENT_PRESENT(ClientId)) {

        if (ClientId->UniqueProcess != NtCurrentProcess()) {

            Status = NtOpenProcess(
                         &ClientProcess,
                         PROCESS_QUERY_INFORMATION,        // To open primary token
                         &NullAttributes,
                         ClientId
                         );

            if ( !NT_SUCCESS(Status) ) {

                goto WellKnownPrivilegeCheckError;
            }

        } else {

            ClientProcess = NtCurrentProcess();
        }

        if (ClientId->UniqueThread != NtCurrentThread()) {

            Status = NtOpenThread(
                         &ClientThread,
                         THREAD_QUERY_INFORMATION,
                         &NullAttributes,
                         ClientId
                         );

            if ( !NT_SUCCESS(Status) ) {

                goto WellKnownPrivilegeCheckError;
            }

        } else {

            ClientThread = NtCurrentThread();
        }
    }
    else {

        ClientThread = NtCurrentThread();
    }


    //
    // Open the specified or current thread's impersonation token (if any).
    //

    Status = NtOpenThreadToken(
                 ClientThread,
                 TOKEN_QUERY,
                 TRUE,
                 &ClientToken
                 );

    if ( !NT_SUCCESS(Status) ) {

        goto WellKnownPrivilegeCheckError;
    }

    //
    // OK, we have a token open.  Now check for the privilege to execute this
    // service.
    //

    Privilege.PrivilegeCount = 1;
    Privilege.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privilege.Privilege[0].Luid = RtlConvertLongToLuid(PrivilegeId);
    Privilege.Privilege[0].Attributes = 0;

    Status = NtPrivilegeCheck(
                 ClientToken,
                 &Privilege,
                 &PrivilegeHeld
                 );

    if (!NT_SUCCESS(Status)) {

        goto WellKnownPrivilegeCheckError;
    }

    RtlInitUnicodeString( &SubsystemName, L"LSA" );

    (VOID) NtPrivilegeObjectAuditAlarm ( &SubsystemName,
                                         ObjectHandle,
                                         ClientToken,
                                         ACCESS_SYSTEM_SECURITY,
                                         &Privilege,
                                         PrivilegeHeld
                                         );
    if ( !PrivilegeHeld ) {

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto WellKnownPrivilegeCheckError;
    }

WellKnownPrivilegeCheckFinish:

    //
    // If we impersonated the client, revert to ourself.
    //

    if (ClientImpersonatedHere) {

        SecondaryStatus = I_RpcMapWin32Status(RpcRevertToSelf());
    }

    //
    // If necessary, close the client Process.
    //

    if ((ARGUMENT_PRESENT(ClientId)) &&
        (ClientId->UniqueProcess != NtCurrentProcess()) &&
        (ClientProcess != NULL)) {

        SecondaryStatus = NtClose( ClientProcess );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientProcess = NULL;
    }

    //
    // If necessary, close the client token.
    //

    if (ClientToken != NULL) {

        SecondaryStatus = NtClose( ClientToken );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientToken = NULL;
    }

    //
    // If necessary, close the client thread
    //

    if ((ARGUMENT_PRESENT(ClientId)) &&
        (ClientId->UniqueThread != NtCurrentThread()) &&
        (ClientThread != NULL)) {

        SecondaryStatus = NtClose( ClientThread );
        ASSERT(NT_SUCCESS(SecondaryStatus));
        ClientThread = NULL;
    }

    return(Status);

WellKnownPrivilegeCheckError:

    goto WellKnownPrivilegeCheckFinish;
}


NTSTATUS
LsapSplitSid(
    IN PSID AccountSid,
    IN OUT PSID *DomainSid,
    OUT ULONG *Rid
    )

/*++

Routine Description:

    This function splits a sid into its domain sid and rid.  The caller
    can either provide a memory buffer for the returned DomainSid, or
    request that one be allocated.  If the caller provides a buffer, the buffer
    is assumed to be of sufficient size.  If allocated on the caller's behalf,
    the buffer must be freed when no longer required via MIDL_user_free.

Arguments:

    AccountSid - Specifies the Sid to be split.  The Sid is assumed to be
        syntactically valid.  Sids with zero subauthorities cannot be split.

    DomainSid - Pointer to location containing either NULL or a pointer to
        a buffer in which the Domain Sid will be returned.  If NULL is
        specified, memory will be allocated on behalf of the caller.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call successfully.

        STATUS_INVALID_SID - The Sid is has a subauthority count of 0.
--*/

{
    NTSTATUS    NtStatus;
    UCHAR       AccountSubAuthorityCount;
    ULONG       AccountSidLength;

    //
    // Calculate the size of the domain sid
    //

    AccountSubAuthorityCount = *RtlSubAuthorityCountSid(AccountSid);


    if (AccountSubAuthorityCount < 1) {

        NtStatus = STATUS_INVALID_SID;
        goto SplitSidError;
    }

    AccountSidLength = RtlLengthSid(AccountSid);

    //
    // If no buffer is required for the Domain Sid, we have to allocate one.
    //

    if (*DomainSid == NULL) {

        //
        // Allocate space for the domain sid (allocate the same size as the
        // account sid so we can use RtlCopySid)
        //

        *DomainSid = MIDL_user_allocate(AccountSidLength);


        if (*DomainSid == NULL) {

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto SplitSidError;
        }
    }

    //
    // Copy the Account sid into the Domain sid
    //

    RtlMoveMemory(*DomainSid, AccountSid, AccountSidLength);

    //
    // Decrement the domain sid sub-authority count
    //

    (*RtlSubAuthorityCountSid(*DomainSid))--;

    //
    // Copy the rid out of the account sid
    //

    *Rid = *RtlSubAuthoritySid(AccountSid, AccountSubAuthorityCount-1);

    NtStatus = STATUS_SUCCESS;

SplitSidFinish:

    return(NtStatus);

SplitSidError:

    goto SplitSidFinish;
}




ULONG
LsapDsSizeAuthInfo(
    IN PLSAPR_AUTH_INFORMATION AuthInfo,
    IN ULONG Infos
    )
/*++

Routine Description:

    This function returns the size, in bytes, of an authentication information structure

Arguments:

    AuthInfo - AuthenticationInformation to size

    Infos - Number of items in the list

Returns:

    Size, in bytes, of the AuthInfos

--*/
{
    ULONG Len = 0, i;

    if ( AuthInfo == NULL ) {

        return( 0 );
    }

    for ( i = 0 ;  i < Infos; i++ ) {

        //
        // This calculation must match LsapDsMarshalAuthInfo
        //
        Len += sizeof(LARGE_INTEGER) +
               sizeof(ULONG) +
               sizeof(ULONG) +
               ROUND_UP_COUNT(AuthInfo[ i ].AuthInfoLength, ALIGN_DWORD);
    }

    return( Len );
}




VOID
LsapDsMarshalAuthInfo(
    IN PBYTE Buffer,
    IN PLSAPR_AUTH_INFORMATION AuthInfo,
    IN ULONG Infos
    )
/*++

Routine Description:

    This function will marshal an authinfo list into an already allocated buffer

Arguments:

    Buffer - Buffer to marshal into

    AuthInfo - AuthenticationInformation to marshal

    Infos - Number of items in the list

Returns:

    VOID

--*/
{
    ULONG i;

    if ( AuthInfo != NULL )  {

        for (i = 0; i < Infos ; i++ ) {
            ULONG AlignmentBytes;

            RtlCopyMemory( Buffer,  &AuthInfo[i].LastUpdateTime, sizeof( LARGE_INTEGER ) );
            Buffer += sizeof( LARGE_INTEGER );

            *(PULONG)Buffer = AuthInfo[i].AuthType;
            Buffer += sizeof ( ULONG );

            *(PULONG)Buffer = AuthInfo[i].AuthInfoLength;
            Buffer += sizeof ( ULONG );

            RtlCopyMemory( Buffer, AuthInfo[i].AuthInfo, AuthInfo[i].AuthInfoLength );
            Buffer += AuthInfo[i].AuthInfoLength;

            // Zero out the next couple of bytes in the DWORD.
            AlignmentBytes = ROUND_UP_COUNT(AuthInfo[ i ].AuthInfoLength, ALIGN_DWORD) -
                             AuthInfo[ i ].AuthInfoLength;
            RtlZeroMemory( Buffer, AlignmentBytes );
            Buffer += AlignmentBytes;
        }
    }

}

NTSTATUS
LsapDsMarshalAuthInfoHalf(
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfo,
    OUT PULONG Length,
    OUT PBYTE *Buffer
    )
/*++

Routine Description:

    This function will take an AuthInfo half and marshal it into a single self
    relative buffer.

Arguments:

    AuthInfo - AuthenticationInformation to marshal

    Length - Returns the length of the allocated buffer.

    Buffer - Returns an allocated buffer containing the marshalled auth info
        The buffer should be freed using MIDL_user_free.

Returns:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE LocalBuffer, Current;
    ULONG Len, PrevLen;

    if ( AuthInfo == NULL ) {

        *Length = 0;
        *Buffer = NULL;

        return STATUS_SUCCESS;
    }

    try {
        //
        // First, size the entire auth info buffer...
        //
        Len = LsapDsSizeAuthInfo( AuthInfo->AuthenticationInformation, AuthInfo->AuthInfos );
        PrevLen = LsapDsSizeAuthInfo( AuthInfo->PreviousAuthenticationInformation,
                                      AuthInfo->AuthInfos );

        //
        // The format of the buffer we will create is:
        //
        LocalBuffer = MIDL_user_allocate( Len + PrevLen + ( 3 * sizeof( ULONG ) ) );

        if ( LocalBuffer == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            //
            // The format of the buffer is:
            //
            // [Info count][OffsetCurrent][OffsetPrevious] and then some number of the
            // following:
            // [UpdateTime(LargeInteger)][AuthType][AuthInfoLen][data (sizeis(AuthInfoLen) ]
            //

            //
            // Number of items...
            //
            *(PULONG)LocalBuffer = AuthInfo->AuthInfos;
            Current = LocalBuffer + sizeof( ULONG );

            //
            //
            *(PULONG)(Current) = 3 *  sizeof(ULONG);
            *(PULONG)(Current + sizeof(ULONG)) = *(PULONG)Current + Len;
            Current += 2 * sizeof(ULONG);

            LsapDsMarshalAuthInfo( Current,
                                   AuthInfo->AuthenticationInformation,
                                   AuthInfo->AuthInfos );

            Current += Len;

            LsapDsMarshalAuthInfo( Current,
                                   AuthInfo->PreviousAuthenticationInformation,
                                   AuthInfo->AuthInfos );

            Status = STATUS_SUCCESS;

        }


        *Length = Len + PrevLen + ( 3 * sizeof( ULONG ) );
        *Buffer = LocalBuffer;

    } except( EXCEPTION_EXECUTE_HANDLER ) {

        Status = GetExceptionCode();
    }


    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\common\lsarpcmm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsarpcmm.c

Abstract:

    LSA - Common Client/Server RPC Memory Management Routines

Author:

    Scott Birrell       (ScottBi)      April 8, 1992

Environment:

Revision History:

--*/

#include <lsacomp.h>


PVOID
MIDL_user_allocate (
    size_t   NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC server transactions.  The RPC stubs will
    either call MIDL_user_allocate when it needs to un-marshall data into a
    buffer that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.

Return Value:

    none

Note:


--*/

{
    PVOID Buffer = (PVOID) LocalAlloc(LPTR, NumBytes);

    return( Buffer );
}


VOID
MIDL_user_free (
    void    *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.

Note:


--*/

{
    LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\data2.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    data2.c

Abstract:

    Arbitrary length data encryption functions implementation :

        RtlEncryptData2
        RtlDecryptData2


Author:

    Richard Ward    (richardw)  20 Dec 93

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>
#include <engine.h>
#include <rc4.h>



NTSTATUS
RtlEncryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    )

/*++

Routine Description:

    Takes an arbitrary length block of data and encrypts it with a
    data key producing an encrypted block of data.

Arguments:

    pData - The data that will be encrypt, IN PLACE

    pKey - The key to use to encrypt the data

Return Values:

    STATUS_SUCCESS

--*/

{
    struct RC4_KEYSTRUCT    Key;

    if ( pData->Length != 0 ) {
        rc4_key(&Key, pKey->Length, pKey->Buffer);
        rc4(&Key, pData->Length, pData->Buffer);
    }

    return STATUS_SUCCESS;
}



NTSTATUS
RtlDecryptData2(
    IN OUT PCRYPT_BUFFER    pData,
    IN PDATA_KEY            pKey
    )

/*++

Routine Description:

    Takes an arbitrary length block of data and encrypts it with a
    data key producing an encrypted block of data.

Arguments:

    pData - The data that will be encrypt, IN PLACE

    pKey - The key to use to encrypt the data

Return Values:

    STATUS_SUCCESS

--*/

{
    struct RC4_KEYSTRUCT    Key;

    if ( pData->Length != 0 ) {
        rc4_key(&Key, pKey->Length, pKey->Buffer);
        rc4(&Key, pData->Length, pData->Buffer);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\data.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    data.c

Abstract:

    Arbitrary length data encryption functions implementation :

        RtlEncryptData
        RtlDecryptData


Author:

    David Chalmers (Davidc) 12-16-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>
#include <engine.h>

//
// Version number of encrypted data
// Update this number if the method used encrypt the data changes
//
#define DATA_ENCRYPTION_VERSION     1

//
// Private data types
//
typedef struct _CRYPTP_BUFFER {
    ULONG   Length;         // Number of valid bytes in buffer
    ULONG   MaximumLength;  // Number of bytes pointed to by buffer
    PCHAR   Buffer;
    PCHAR   Pointer;        // Points into buffer
} CRYPTP_BUFFER;
typedef CRYPTP_BUFFER *PCRYPTP_BUFFER;

//
// Internal helper macros
#define AdvanceCypherData(p) ((PCYPHER_BLOCK)(((PCRYPTP_BUFFER)p)->Pointer)) ++
#define AdvanceClearData(p)  ((PCLEAR_BLOCK)(((PCRYPTP_BUFFER)p)->Pointer)) ++


//
// Private routines
//

VOID
InitializeBuffer(
    OUT PCRYPTP_BUFFER PrivateBuffer,
    IN PCRYPT_BUFFER PublicBuffer
    )
/*++

Routine Description:

    Internal helper routine

    Copies fields from public buffer into private buffer.
    Sets the Pointer field of the private buffer to the
    base of the buffer.

Arguments:

    PrivateBuffer - out internal buffer we want to represent the public structure.

    PublicBuffer - the buffer the caller passed us

Return Values:

    None
--*/
{
    PrivateBuffer->Length = PublicBuffer->Length;
    PrivateBuffer->MaximumLength = PublicBuffer->MaximumLength;
    PrivateBuffer->Buffer = PublicBuffer->Buffer;
    PrivateBuffer->Pointer = PublicBuffer->Buffer;
}


BOOLEAN
ValidateDataKey(
    IN PCRYPTP_BUFFER DataKey,
    IN PBLOCK_KEY BlockKey
    )
/*++

Routine Description:

    Internal helper routine

    Checks the validity of the data key and constructs a minimum length
    key in the passed blockkey if the datakey is not long enough.

Arguments:

    DataKey - The data key

Return Values:

    TRUE if the key is valid, otherwise FALSE

--*/
{
    if ( ( DataKey->Length == 0 ) ||
         ( DataKey->Buffer == NULL ) ) {

        return(FALSE);
    }

    if (DataKey->Length < BLOCK_KEY_LENGTH) {

        // Make up a minimum length key from the small data key we were
        // given. Store it in the passed blockkey variable and point
        // the datakey buffer at this temporary storage.

        ULONG   DataIndex, BlockIndex;

        DataIndex = 0;
        for (BlockIndex = 0; BlockIndex < BLOCK_KEY_LENGTH; BlockIndex ++) {
            ((PCHAR)BlockKey)[BlockIndex] = DataKey->Buffer[DataIndex];
            DataIndex ++;
            if (DataIndex >= DataKey->Length) {
                DataIndex = 0;
            }
        }

        // Point the buffer at our constructed block key
        DataKey->Buffer = (PCHAR)BlockKey;
        DataKey->Pointer = (PCHAR)BlockKey;
        DataKey->Length = BLOCK_KEY_LENGTH;
        DataKey->MaximumLength = BLOCK_KEY_LENGTH;
    }

    return(TRUE);
}


VOID
AdvanceDataKey(
    IN PCRYPTP_BUFFER DataKey
    )
/*++

Routine Description:

    Internal helper routine

    Moves the data key pointer on to point at the key to use to encrypt
    the next data block. Wraps round at end of key data.

Arguments:

    DataKey - The data key

Return Values:

    STATUS_SUCCESS - No problems

--*/
{
    if (DataKey->Length > BLOCK_KEY_LENGTH) {

        PCHAR   EndPointer;

        // Advance pointer and wrap
        DataKey->Pointer += BLOCK_KEY_LENGTH;
        EndPointer = DataKey->Pointer + BLOCK_KEY_LENGTH;

        if (EndPointer > &(DataKey->Buffer[DataKey->Length])) {

            ULONG_PTR  Overrun;

            Overrun = EndPointer - &(DataKey->Buffer[DataKey->Length]);

            DataKey->Pointer = DataKey->Buffer + (BLOCK_KEY_LENGTH - Overrun);
        }
    }
}


ULONG
CalculateCypherDataLength(
    IN PCRYPTP_BUFFER ClearData
    )
/*++

Routine Description:

    Internal helper routine

    Returns the number of bytes required to encrypt the specified number
    of clear data bytes.

Arguments:

    ClearData - The clear data

Return Values:

    Number of cypher bytes required.
--*/
{
    ULONG   CypherDataLength;
    ULONG   BlockExcess;

    // We always store the length of the clear data as a whole block.
    CypherDataLength = CYPHER_BLOCK_LENGTH + ClearData->Length;

    // Round up to the next block
    BlockExcess = CypherDataLength % CYPHER_BLOCK_LENGTH;
    if (BlockExcess > 0) {
        CypherDataLength += CYPHER_BLOCK_LENGTH - BlockExcess;
    }

    return(CypherDataLength);
}


NTSTATUS
EncryptDataLength(
    IN PCRYPTP_BUFFER Data,
    IN PCRYPTP_BUFFER DataKey,
    OUT PCRYPTP_BUFFER CypherData
    )
/*++

Routine Description:

    Internal helper routine

    Encrypts the clear data length and puts the encrypted value in the
    cypherdatabuffer. Advances the cypherdata buffer and datakey buffer pointers

Arguments:

    Data - The buffer whose length is to be encrypted

    DataKey - key to use to encrypt data

    CypherData - Place to store encrypted data

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;
    CLEAR_BLOCK ClearBlock;

    // Fill the clear block with the data value and a version number
    ((ULONG *)&ClearBlock)[0] = Data->Length;
    ((ULONG *)&ClearBlock)[1] = DATA_ENCRYPTION_VERSION;

    Status = RtlEncryptBlock(&ClearBlock,
                             (PBLOCK_KEY)(DataKey->Pointer),
                             (PCYPHER_BLOCK)(CypherData->Pointer));

    // Advance pointers
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


NTSTATUS
EncryptFullBlock(
    IN OUT PCRYPTP_BUFFER ClearData,
    IN OUT PCRYPTP_BUFFER DataKey,
    IN OUT PCRYPTP_BUFFER CypherData
    )
/*++

Routine Description:

    Internal helper routine

    Encrypts a full block of data from ClearData and puts the encrypted
    data in CypherData.
    Both cleardata, datakey and cypherdata pointers are advanced.

Arguments:

    ClearData - Pointer to the cleardata buffer

    DataKey - key to use to encrypt data

    CypherData - Pointer to cypherdata buffer.

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;

    Status = RtlEncryptBlock((PCLEAR_BLOCK)(ClearData->Pointer),
                              (PBLOCK_KEY)(DataKey->Pointer),
                              (PCYPHER_BLOCK)(CypherData->Pointer));

    // Advance pointers
    AdvanceClearData(ClearData);
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


NTSTATUS
EncryptPartialBlock(
    IN OUT PCRYPTP_BUFFER ClearData,
    IN OUT PCRYPTP_BUFFER DataKey,
    IN OUT PCRYPTP_BUFFER CypherData,
    IN ULONG Remaining
    )
/*++

Routine Description:

    Internal helper routine

    Encrypts a partial block of data from ClearData and puts the full
    encrypted data block in cypherdata.
    Both cleardata, datakey and cypherdata pointers are advanced.

Arguments:

    ClearData - Pointer to the cleardata buffer

    DataKey - key to use to encrypt data

    CypherData - Pointer to cypherdata buffer.

    Remaining - the number of bytes remaining in cleardata buffer

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;
    CLEAR_BLOCK ClearBlockBuffer;
    PCLEAR_BLOCK ClearBlock = &ClearBlockBuffer;

    ASSERTMSG("EncryptPartialBlock called with a block or more", Remaining < CLEAR_BLOCK_LENGTH);

    // Copy the remaining bytes into a clear block buffer
    while (Remaining > 0) {

        *((PCHAR)ClearBlock) ++ = *(ClearData->Pointer) ++;
        Remaining --;
    }

    // Zero pad
    while (ClearBlock < &((&ClearBlockBuffer)[1])) {

        *((PCHAR)ClearBlock) ++ = 0;
    }

    Status = RtlEncryptBlock(&ClearBlockBuffer,
                            (PBLOCK_KEY)(DataKey->Pointer),
                            (PCYPHER_BLOCK)(CypherData->Pointer));

    // Advance pointers
    AdvanceClearData(ClearData);
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


NTSTATUS
DecryptDataLength(
    IN PCRYPTP_BUFFER CypherData,
    IN PCRYPTP_BUFFER DataKey,
    OUT PCRYPTP_BUFFER Data
    )
/*++

Routine Description:

    Internal helper routine

    Decrypts the data length pointed to by the cypherdata buffer and puts the
    decrypted value in the length field of the data structure.
    Advances the cypherdata buffer and datakey buffer pointers

Arguments:

    CypherData - The buffer containing the encrypted length

    DataKey - key to use to decrypt data

    Data - Decrypted length field is stored in the length field of this struct.

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;
    CLEAR_BLOCK ClearBlock;
    ULONG       Version;

    Status = RtlDecryptBlock((PCYPHER_BLOCK)(CypherData->Pointer),
                             (PBLOCK_KEY)(DataKey->Pointer),
                             &ClearBlock);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // Advance pointers
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    // Copy the decrypted length into the data structure.
    Data->Length = ((ULONG *)&ClearBlock)[0];

    // Check the version
    Version = ((ULONG *)&ClearBlock)[1];
    if (Version != DATA_ENCRYPTION_VERSION) {
        return(STATUS_UNKNOWN_REVISION);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
DecryptFullBlock(
    IN OUT PCRYPTP_BUFFER CypherData,
    IN OUT PCRYPTP_BUFFER DataKey,
    IN OUT PCRYPTP_BUFFER ClearData
    )
/*++

Routine Description:

    Internal helper routine

    Decrypts a full block of data from CypherData and puts the encrypted
    data in ClearData.
    Both cleardata, datakey and cypherdata pointers are advanced.

Arguments:

    CypherData - Pointer to cypherdata buffer.

    ClearData - Pointer to the cleardata buffer

    DataKey - key to use to encrypt data

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;

    Status = RtlDecryptBlock((PCYPHER_BLOCK)(CypherData->Pointer),
                              (PBLOCK_KEY)(DataKey->Pointer),
                              (PCLEAR_BLOCK)(ClearData->Pointer));

    // Advance pointers
    AdvanceClearData(ClearData);
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


NTSTATUS
DecryptPartialBlock(
    IN OUT PCRYPTP_BUFFER CypherData,
    IN OUT PCRYPTP_BUFFER DataKey,
    IN OUT PCRYPTP_BUFFER ClearData,
    IN ULONG Remaining
    )
/*++

Routine Description:

    Internal helper routine

    Decrypts a full block of data from CypherData and puts the partial
    decrypted data block in cleardata.
    Both cleardata, datakey and cypherdata pointers are advanced.

Arguments:

    CypherData - Pointer to cypherdata buffer.

    ClearData - Pointer to the cleardata buffer

    DataKey - key to use to encrypt data

    Remaining - the number of bytes remaining in cleardata buffer

Return Values:

    STATUS_SUCCESS - Success.

    STATUS_UNSUCCESSFUL - Something failed.
--*/
{
    NTSTATUS    Status;
    CLEAR_BLOCK ClearBlockBuffer;
    PCLEAR_BLOCK ClearBlock = &ClearBlockBuffer;

    ASSERTMSG("DecryptPartialBlock called with a block or more", Remaining < CLEAR_BLOCK_LENGTH);

    // Decrypt the block into a local clear block
    Status = RtlDecryptBlock((PCYPHER_BLOCK)(CypherData->Pointer),
                             (PBLOCK_KEY)(DataKey->Pointer),
                             &ClearBlockBuffer);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // Copy the decrypted bytes into the cleardata buffer.
    while (Remaining > 0) {

        *(ClearData->Pointer) ++ = *((PCHAR)ClearBlock) ++;
        Remaining --;
    }

    // Advance pointers
    AdvanceClearData(ClearData);
    AdvanceCypherData(CypherData);
    AdvanceDataKey(DataKey);

    return(Status);
}


//
// Public functions
//


NTSTATUS
RtlEncryptData(
    IN PCLEAR_DATA ClearData,
    IN PDATA_KEY DataKey,
    OUT PCYPHER_DATA CypherData
    )

/*++

Routine Description:

    Takes an arbitrary length block of data and encrypts it with a
    data key producing an encrypted block of data.

Arguments:

    ClearData - The data to be encrypted.

    DataKey - The key to use to encrypt the data

    CypherData - Encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The data was encrypted successfully. The encrypted
                     data is in CypherData. The length of the encrypted
                     data is is CypherData->Length.

    STATUS_BUFFER_TOO_SMALL - CypherData.MaximumLength is too small to
                    contain the encrypted data.
                    CypherData->Length contains the number of bytes required.

    STATUS_INVALID_PARAMETER_2 - Block key is invalid

    STATUS_UNSUCCESSFUL - Something failed.
                    The CypherData is undefined.
--*/

{
    NTSTATUS        Status;
    ULONG           CypherDataLength;
    ULONG           Remaining = ClearData->Length;
    CRYPTP_BUFFER   CypherDataBuffer;
    CRYPTP_BUFFER   ClearDataBuffer;
    CRYPTP_BUFFER   DataKeyBuffer;
    BLOCK_KEY       BlockKey; // Only used if datakey less than a block long

    InitializeBuffer(&ClearDataBuffer, (PCRYPT_BUFFER)ClearData);
    InitializeBuffer(&CypherDataBuffer, (PCRYPT_BUFFER)CypherData);
    InitializeBuffer(&DataKeyBuffer, (PCRYPT_BUFFER)DataKey);

    // Check the key is OK
    if (!ValidateDataKey(&DataKeyBuffer, &BlockKey)) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    // Find out how big we need the cypherdata buffer to be
    CypherDataLength = CalculateCypherDataLength(&ClearDataBuffer);

    // Fail if cypher data buffer too small
    if (CypherData->MaximumLength < CypherDataLength) {
        CypherData->Length = CypherDataLength;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Encrypt the clear data length into the start of the cypher data.
    //
    Status = EncryptDataLength(&ClearDataBuffer, &DataKeyBuffer, &CypherDataBuffer);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // Encrypt the clear data a block at a time.
    //
    while (Remaining >= CLEAR_BLOCK_LENGTH) {

        Status = EncryptFullBlock(&ClearDataBuffer, &DataKeyBuffer, &CypherDataBuffer);
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
        Remaining -= CLEAR_BLOCK_LENGTH;
    }

    //
    // Encrypt any partial block that remains
    //
    if (Remaining > 0) {
        Status = EncryptPartialBlock(&ClearDataBuffer, &DataKeyBuffer, &CypherDataBuffer, Remaining);
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    // Return the encrypted data length
    CypherData->Length = CypherDataLength;

    return(STATUS_SUCCESS);
}



NTSTATUS
RtlDecryptData(
    IN PCYPHER_DATA CypherData,
    IN PDATA_KEY DataKey,
    OUT PCLEAR_DATA ClearData
    )
/*++

Routine Description:

    Takes an arbitrary block of encrypted data and decrypts it with a
    key producing the original clear block of data.

Arguments:

    CypherData - The data to be decrypted

    DataKey - The key to use to decrypt data

    ClearData - The decrpted data of data is returned here


Return Values:

    STATUS_SUCCESS - The data was decrypted successfully. The decrypted
                     data is in ClearData.

    STATUS_BUFFER_TOO_SMALL - ClearData->MaximumLength is too small to
                    contain the decrypted data.
                    ClearData->Length contains the number of bytes required.

    STATUS_INVALID_PARAMETER_2 - Block key is invalid

    STATUS_UNSUCCESSFUL - Something failed.
                    The ClearData is undefined.
--*/

{
    NTSTATUS        Status;
    ULONG           Remaining;
    CRYPTP_BUFFER   CypherDataBuffer;
    CRYPTP_BUFFER   ClearDataBuffer;
    CRYPTP_BUFFER   DataKeyBuffer;
    BLOCK_KEY       BlockKey; // Only used if datakey less than a block long

    InitializeBuffer(&ClearDataBuffer, (PCRYPT_BUFFER)ClearData);
    InitializeBuffer(&CypherDataBuffer, (PCRYPT_BUFFER)CypherData);
    InitializeBuffer(&DataKeyBuffer, (PCRYPT_BUFFER)DataKey);

    // Check the key is OK
    if (!ValidateDataKey(&DataKeyBuffer, &BlockKey)) {
        return(STATUS_INVALID_PARAMETER_2);
    }

    //
    // Decrypt the clear data length from the start of the cypher data.
    //
    Status = DecryptDataLength(&CypherDataBuffer, &DataKeyBuffer, &ClearDataBuffer);
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // Fail if clear data buffer too small
    if (ClearData->MaximumLength < ClearDataBuffer.Length) {
        ClearData->Length = ClearDataBuffer.Length;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Decrypt the clear data a block at a time.
    //
    Remaining = ClearDataBuffer.Length;
    while (Remaining >= CLEAR_BLOCK_LENGTH) {

        Status = DecryptFullBlock(&CypherDataBuffer, &DataKeyBuffer, &ClearDataBuffer);
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
        Remaining -= CLEAR_BLOCK_LENGTH;
    }

    //
    // Decrypt any partial block that remains
    //
    if (Remaining > 0) {
        Status = DecryptPartialBlock(&CypherDataBuffer, &DataKeyBuffer, &ClearDataBuffer, Remaining);
        if (!NT_SUCCESS(Status)) {
            return(Status);
        }
    }

    // Return the length of the decrypted data
    ClearData->Length = ClearDataBuffer.Length;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\response.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    response.c

Abstract:

    Contains functions that calculate the correct response to return
    to the server when logging on.

        RtlCalculateLmResponse
        RtlCalculateNtResponse


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>



NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    )

/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return to the server.

Arguments:

    LmChallenge - The challenge sent by the server

    LmOwfPassword - The hashed password.

    LmResponse - The response is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The response
                     is in LmResponse.

    STATUS_UNSUCCESSFUL - Something failed. The LmResponse is undefined.
--*/

{
    NTSTATUS    Status;
    BLOCK_KEY    Key;
    PCHAR       pKey, pData;

    // The first 2 keys we can get at by type-casting

    Status = RtlEncryptBlock(LmChallenge,
                             &(((PBLOCK_KEY)(LmOwfPassword->data))[0]),
                             &(LmResponse->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock(LmChallenge,
                             &(((PBLOCK_KEY)(LmOwfPassword->data))[1]),
                             &(LmResponse->data[1]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // To get the last key we must copy the remainder of the OwfPassword
    // and fill the rest of the key with 0s

    pKey = &(Key.data[0]);
    pData = (PCHAR)&(((PBLOCK_KEY)(LmOwfPassword->data))[2]);

    while (pData < (PCHAR)&(LmOwfPassword->data[2])) {
        *pKey++ = *pData++;
    }

    // Zero extend

    while (pKey < (PCHAR)&((&Key)[1])) {
        *pKey++ = 0;
    }

    // Use the 3rd key

    Status = RtlEncryptBlock(LmChallenge, &Key, &(LmResponse->data[2]));

    return(Status);
}







NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    )
/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return(to the server.

Arguments:

    NtChallenge - The challenge sent by the server

    NtOwfPassword - The hashed password.

    NtResponse - The response is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The response
                     is in NtResponse.

    STATUS_UNSUCCESSFUL - Something failed. The NtResponse is undefined.
--*/

{

    // Use the LM version until we change the definitions of any of
    // these data types

    return(RtlCalculateLmResponse((PLM_CHALLENGE)NtChallenge,
                                  (PLM_OWF_PASSWORD)NtOwfPassword,
                                  (PLM_RESPONSE)NtResponse));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\owf.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    owf.c

Abstract:

    Implentation of the one-way-functions used to implement password hashing.

        RtlCalculateLmOwfPassword
        RtlCalculateNtOwfPassword


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#ifndef KMODE
#define _ADVAPI32_
#endif

#include <nt.h>
#include <ntrtl.h>
#ifndef KMODE
#include <nturtl.h>
#endif
#include <crypt.h>
#include <engine.h>
#ifndef KMODE
#include <windef.h>
#include <winbase.h>
#include <wincrypt.h>
#endif

#ifdef WIN32_CHICAGO
#include <assert.h>
#undef ASSERT
#define ASSERT(exp) assert(exp)
#endif

#ifndef KMODE
#ifndef WIN32_CHICAGO
//
// Globals used for allowing the replacement of the OWF functions
//
HCRYPTPROV KerbGlobalStrToKeyProvider = 0;
BOOLEAN    KerbGlobalAvailableStrToKeyProvider = TRUE;

//+-------------------------------------------------------------------------
//
//  Function:   CheckForOutsideStringToKey
//
//  Synopsis:   Call CryptoAPI to query to see if a CSP is registered
//              of the type PROV_REPLACE_OWF.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns: STATUS_SUCCESS if it succeeds, otherwise STATUS_UNSUCCESSFUL
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
CheckForOutsideStringToKey()
{
    HCRYPTPROV hProv = 0;
    BOOLEAN fRet = FALSE;

    if (!KerbGlobalAvailableStrToKeyProvider)
    {
        goto Cleanup;
    }
        
    //
    // see if there is a replacement provider
    if (0 != KerbGlobalStrToKeyProvider)
    {
        // if there is proceed to use it
        fRet = TRUE;
        goto Cleanup;
    }
    else
    {
        //
        // Try to acquire a context to a CSP which is used for OWF replacement
        //
        if (!CryptAcquireContext(&hProv,
                                 NULL,
                                 NULL,
                                 PROV_REPLACE_OWF,
                                 CRYPT_VERIFYCONTEXT))
        {
            KerbGlobalAvailableStrToKeyProvider = FALSE;
            goto Cleanup;
        }

        //
        // exchange the local and the global in a safe way
        //
        if (0 != InterlockedCompareExchangePointer(
                    (PVOID*)&KerbGlobalStrToKeyProvider,
                    (PVOID)hProv,
                    0))
        {
            CryptReleaseContext(hProv, 0);
        }
        fRet = TRUE;
    }
Cleanup:
    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   UseOutsideStringToKey
//
//  Synopsis:   Calls the CSP to do an outside StringToKey function
//              using the hashing entry points of CryptoAPI.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
UseOutsideStringToKey(
    IN PCHAR pPassword,
    IN USHORT cbPassword,
    IN ULONG ulFlags,
    IN ULONG cbKey,
    OUT PUCHAR pbKey
    )
{
    HCRYPTHASH hHash = 0;
    ULONG cb;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if (!CheckForOutsideStringToKey())
    {
        // STATUS_UNSUCCESSFUL indicates not to fallback to default OWF calculation
        // so we don't want to use that here
        Status = NTE_BAD_PROVIDER;
        goto Cleanup;
    }


    //
    // create the hash
    //
    if (!CryptCreateHash(KerbGlobalStrToKeyProvider,
                         CALG_HASH_REPLACE_OWF,
                         0,
                         0,
                         &hHash))
    {
        goto Cleanup;
    }

    //
    // hash the password
    //
    if (!CryptHashData(hHash,
                       pPassword,
                       (ULONG)cbPassword,
                       ulFlags))
    {
        if (NTE_BAD_DATA == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    //
    // Get the HP_HASHVAL, this is the key
    //
    cb = cbKey;
    if (!CryptGetHashParam(hHash,
                           HP_HASHVAL,
                           pbKey,
                           &cb,
                           0))
    {
        if (NTE_BAD_LEN == GetLastError())
        {
            Status = NTE_BAD_DATA;
        }
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;
Cleanup:
    if (0 != hHash)
    {
        CryptDestroyHash(hHash);
    }
    return Status;
}
#endif
#endif


NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )

/*++

Routine Description:

    Takes the passed LmPassword and performs a one-way-function on it.
    The current implementation does this by using the password as a key
    to encrypt a known block of text.

Arguments:

    LmPassword - The password to perform the one-way-function on.

    LmOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in LmOwfPassword.

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/

{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;
    BLOCK_KEY   Key[2];
    PCHAR       pKey;

#ifndef KMODE
#ifndef WIN32_CHICAGO
    Status = UseOutsideStringToKey(
                    LmPassword,
                    (USHORT)strlen(LmPassword),
                    sizeof(LM_OWF_PASSWORD),
                    CRYPT_OWF_REPL_LM_HASH,
                    (PUCHAR)&(LmOwfPassword->data[0])
                    );

    //
    // the function will return STATUS_UNSUCCESSFUL indicates not to fall
    // back to the typical string to key function.
    // 
    if ((NT_SUCCESS(Status)) || (STATUS_UNSUCCESSFUL == Status))
    {
        return Status;
    }
#endif
#endif

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    // Use the keys to encrypt the standard text

    Status = RtlEncryptStdBlock(&Key[0], &(LmOwfPassword->data[0]));

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptStdBlock(&Key[1], &(LmOwfPassword->data[1]));

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(Status);
}




NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Takes the passed NtPassword and performs a one-way-function on it.
    Uses the RSA MD4 function

Arguments:

    NtPassword - The password to perform the one-way-function on.

    NtOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in NtOwfPassword.
--*/

{
    MD4_CTX     MD4_Context;
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;

#ifndef KMODE
#ifndef WIN32_CHICAGO
    Status = UseOutsideStringToKey(
                    (PCHAR)NtPassword->Buffer,
                    (USHORT)NtPassword->Length,
                    0,
                    sizeof(*NtOwfPassword),
                    (PUCHAR)NtOwfPassword
                    );

    //
    // the function will return STATUS_UNSUCCESSFUL indicates not to fall
    // back to the typical string to key function.
    // 
    if ((NT_SUCCESS(Status)) || (STATUS_UNSUCCESSFUL == Status))
    {
        return Status;
    }
#endif
#endif

    MD4Init(&MD4_Context);

    MD4Update(&MD4_Context, (PCHAR)NtPassword->Buffer, NtPassword->Length);

    MD4Final(&MD4_Context);


    // Copy the digest into our return data area

    ASSERT(sizeof(*NtOwfPassword) == sizeof(MD4_Context.digest));

    RtlMoveMemory((PVOID)NtOwfPassword, (PVOID)MD4_Context.digest,
                  sizeof(*NtOwfPassword));

    return(STATUS_SUCCESS);
}



BOOLEAN
RtlEqualLmOwfPassword(
    IN PLM_OWF_PASSWORD LmOwfPassword1,
    IN PLM_OWF_PASSWORD LmOwfPassword2
    )

/*++

Routine Description:

    Compares two Lanman One-way-function-passwords

Arguments:

    LmOwfPassword1/2 - The one-way-functions to compare

Return Values:

    TRUE if the one-way-functions match, otherwise FALSE

--*/

{
    return((BOOLEAN)(RtlCompareMemory(LmOwfPassword1,
                                      LmOwfPassword2,
                                      LM_OWF_PASSWORD_LENGTH)

                    == LM_OWF_PASSWORD_LENGTH));
}



BOOLEAN
RtlEqualNtOwfPassword(
    IN PNT_OWF_PASSWORD NtOwfPassword1,
    IN PNT_OWF_PASSWORD NtOwfPassword2
    )

/*++

Routine Description:

    Compares two NT One-way-function-passwords

Arguments:

    NtOwfPassword1/2 - The one-way-functions to compare

Return Values:

    TRUE if the one-way-functions match, otherwise FALSE

--*/

{
    return((BOOLEAN)(RtlCompareMemory(NtOwfPassword1,
                                      NtOwfPassword2,
                                      NT_OWF_PASSWORD_LENGTH)

                    == NT_OWF_PASSWORD_LENGTH));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\chicago\makefile.inc ===
$(O)\sys003.lib: $(O)\crypt.lib
    lib -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\rng.c ===
#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>
#include <engine.h>

#include <nturtl.h>

#include <windows.h>
#include <randlib.h>


BOOLEAN
RtlGenRandom(
    OUT PVOID RandomBuffer,
    IN  ULONG RandomBufferLength
    )
{
#ifdef KMODE
    return FALSE;
#else

    return (BOOLEAN)NewGenRandom(
                        NULL,
                        0,
                        (unsigned char*)RandomBuffer,
                        RandomBufferLength
                        );

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\kmode\makefile.inc ===
$(O)\sys003k.lib: $(O)\cryptk.lib
    lib -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\owfcrypt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    owdcrypt.c

Abstract:

    Contains functions that reversibly encrypt OwfPasswords

        RtlEncryptLmOwfPwdWithLmOwfPwd
        RtlDecryptLmOwfPwdWithLmOwfPwd

        RtlEncryptLmOwfPwdWithLmSesKey
        RtlDecryptLmOwfPwdWithLmSesKey

        RtlEncryptLmOwfPwdWithUserKey
        RtlDecryptLmOwfPwdWithUserKey

        RtlEncryptLmOwfPwdWithIndex
        RtlDecryptLmOwfPwdWithIndex

        RtlEncryptNtOwfPwdWithNtOwfPwd
        RtlDecryptNtOwfPwdWithNtOwfPwd

        RtlEncryptNtOwfPwdWithNtSesKey
        RtlDecryptNtOwfPwdWithNtSesKey

        RtlEncryptNtOwfPwdWithUserKey
        RtlDecryptNtOwfPwdWithUserKey

        RtlEncryptNtOwfPwdWithIndex
        RtlDecryptNtOwfPwdWithIndex


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <crypt.h>

#ifdef WIN32_CHICAGO
#include <assert.h>
#undef ASSERT
#define ASSERT(exp) assert(exp)
#endif


NTSTATUS
RtlEncryptLmOwfPwdWithLmOwfPwd(
    IN PLM_OWF_PASSWORD DataLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    )

/*++

Routine Description:

    Encrypts one OwfPassword with another

Arguments:

    DataLmOwfPassword - OwfPassword to be encrypted

    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption

    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedLmOwfPassword is undefined.
--*/

{
    NTSTATUS    Status;

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(DataLmOwfPassword->data[0]),
                             &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[0]),
                             &(EncryptedLmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(DataLmOwfPassword->data[1]),
                             &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[1]),
                             &(EncryptedLmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlDecryptLmOwfPwdWithLmOwfPwd(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_OWF_PASSWORD KeyLmOwfPassword,
    OUT PLM_OWF_PASSWORD DataLmOwfPassword
    )

/*++

Routine Description:

    Decrypts one OwfPassword with another

Arguments:

    EncryptedLmOwfPassword - The ecnrypted OwfPassword to be decrypted

    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption

    DataLmOwfPassword - The decrpted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in DataLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The DataLmOwfPassword is undefined.
--*/

{
    NTSTATUS    Status;

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[0]),
                             &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[0]),
                             (PCLEAR_BLOCK)&(DataLmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[1]),
                             &(((PBLOCK_KEY)(KeyLmOwfPassword->data))[1]),
                             (PCLEAR_BLOCK)&(DataLmOwfPassword->data[1]));

    return(Status);
}




NTSTATUS
RtlEncryptNtOwfPwdWithNtOwfPwd(
    IN PNT_OWF_PASSWORD DataNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    Encrypts one OwfPassword with another

Arguments:

    DataLmOwfPassword - OwfPassword to be encrypted

    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption

    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedLmOwfPassword is undefined.
--*/
{
    return(RtlEncryptLmOwfPwdWithLmOwfPwd(
            (PLM_OWF_PASSWORD)DataNtOwfPassword,
            (PLM_OWF_PASSWORD)KeyNtOwfPassword,
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}


NTSTATUS
RtlDecryptNtOwfPwdWithNtOwfPwd(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_OWF_PASSWORD KeyNtOwfPassword,
    OUT PNT_OWF_PASSWORD DataNtOwfPassword
    )

/*++

Routine Description:

    Decrypts one OwfPassword with another

Arguments:

    EncryptedLmOwfPassword - The ecnrypted OwfPassword to be decrypted

    KeyLmOwfPassword - OwfPassword to be used as a key to the encryption

    DataLmOwfPassword - The decrpted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in DataLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The DataLmOwfPassword is undefined.
--*/

{
    return(RtlDecryptLmOwfPwdWithLmOwfPwd(
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword,
            (PLM_OWF_PASSWORD)KeyNtOwfPassword,
            (PLM_OWF_PASSWORD)DataNtOwfPassword));
}




NTSTATUS
RtlEncryptLmOwfPwdWithLmSesKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PLM_SESSION_KEY  LmSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with a session key

Arguments:

    LmOwfPassword - OwfPassword to be encrypted

    LmSessionKey - key to the encryption

    EncryptedLmOwfPassword - The ecnrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The LMEncryptedLmOwfPassword is undefined.
--*/
{
    NTSTATUS    Status;

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(LmOwfPassword->data[0]),
                             (PBLOCK_KEY)LmSessionKey,
                             &(EncryptedLmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(LmOwfPassword->data[1]),
                             (PBLOCK_KEY)LmSessionKey,
                             &(EncryptedLmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlDecryptLmOwfPwdWithLmSesKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PLM_SESSION_KEY  LmSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )
/*++

Routine Description:

    Decrypts one OwfPassword with a session key

Arguments:

    EncryptedLmOwfPassword - The ecnrypted OwfPassword to be decrypted

    LmSessionKey - key to the encryption

    LmOwfPassword - The decrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in LmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/
{
    NTSTATUS    Status;


    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[0]),
                             (PBLOCK_KEY)LmSessionKey,
                             (PCLEAR_BLOCK)&(LmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[1]),
                             (PBLOCK_KEY)LmSessionKey,
                             (PCLEAR_BLOCK)&(LmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlEncryptNtOwfPwdWithNtSesKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PNT_SESSION_KEY  NtSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with a session key

Arguments:

    NtOwfPassword - OwfPassword to be encrypted

    NtSessionKey - key to the encryption

    EncryptedNtOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedNtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedNtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(LM_OWF_PASSWORD) == sizeof(NT_OWF_PASSWORD));
    ASSERT(sizeof(LM_SESSION_KEY) == sizeof(NT_SESSION_KEY));
    ASSERT(sizeof(ENCRYPTED_LM_OWF_PASSWORD) == sizeof(ENCRYPTED_NT_OWF_PASSWORD));

    return(RtlEncryptLmOwfPwdWithLmSesKey(
            (PLM_OWF_PASSWORD)NtOwfPassword,
            (PLM_SESSION_KEY)NtSessionKey,
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}


NTSTATUS
RtlDecryptNtOwfPwdWithNtSesKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PNT_SESSION_KEY  NtSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    Decrypts one OwfPassword with a session key

Arguments:

    EncryptedNtOwfPassword - The ecnrypted OwfPassword to be decrypted

    NtSessionKey - key to the encryption

    NtOwfPassword - The decrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in NtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The NtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(LM_OWF_PASSWORD) == sizeof(NT_OWF_PASSWORD));
    ASSERT(sizeof(LM_SESSION_KEY) == sizeof(NT_SESSION_KEY));
    ASSERT(sizeof(ENCRYPTED_LM_OWF_PASSWORD) == sizeof(ENCRYPTED_NT_OWF_PASSWORD));

    return(RtlDecryptLmOwfPwdWithLmSesKey(
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword,
            (PLM_SESSION_KEY)NtSessionKey,
            (PLM_OWF_PASSWORD)NtOwfPassword));
}



VOID
KeysFromIndex(
    IN PCRYPT_INDEX Index,
    OUT BLOCK_KEY Key[2])
/*++

Routine Description:

    Helper function - generates 2 keys from an index value

--*/
{
    PCHAR   pKey, pIndex;
    PCHAR   IndexStart = (PCHAR)&(Index[0]);
    PCHAR   IndexEnd =   (PCHAR)&(Index[1]);
    PCHAR   KeyStart = (PCHAR)&(Key[0]);
    PCHAR   KeyEnd   = (PCHAR)&(Key[2]);

    // Calculate the keys by concatenating the index with itself

    pKey = KeyStart;
    pIndex = IndexStart;

    while (pKey < KeyEnd) {

        *pKey++ = *pIndex++;

        if (pIndex == IndexEnd) {

            // Start at beginning of index again
            pIndex = IndexStart;
        }
    }
}



NTSTATUS
RtlEncryptLmOwfPwdWithIndex(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with an index

Arguments:

    LmOwfPassword - OwfPassword to be encrypted

    INDEX - value to be used as encryption key

    EncryptedLmOwfPassword - The ecnrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedLmOwfPassword is undefined.
--*/
{
    NTSTATUS    Status;
    BLOCK_KEY    Key[2];

    // Calculate the keys

    KeysFromIndex(Index, &(Key[0]));

    // Use the keys

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(LmOwfPassword->data[0]),
                             &(Key[0]),
                             &(EncryptedLmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock((PCLEAR_BLOCK)&(LmOwfPassword->data[1]),
                             &(Key[1]),
                             &(EncryptedLmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlDecryptLmOwfPwdWithIndex(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )
/*++

Routine Description:

    Decrypts an OwfPassword with an index

Arguments:

    EncryptedLmOwfPassword - The encrypted OwfPassword to be decrypted

    INDEX - value to be used as decryption key

    LmOwfPassword - Decrypted OwfPassword is returned here


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in LmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/
{
    NTSTATUS    Status;
    BLOCK_KEY    Key[2];

    // Calculate the keys

    KeysFromIndex(Index, &(Key[0]));

    // Use the keys

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[0]),
                             &(Key[0]),
                             (PCLEAR_BLOCK)&(LmOwfPassword->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlDecryptBlock(&(EncryptedLmOwfPassword->data[1]),
                             &(Key[1]),
                             (PCLEAR_BLOCK)&(LmOwfPassword->data[1]));

    return(Status);
}



NTSTATUS
RtlEncryptNtOwfPwdWithIndex(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with an index

Arguments:

    NtOwfPassword - OwfPassword to be encrypted

    Index - value to be used as encryption key

    EncryptedNtOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedNtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedNtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(LM_OWF_PASSWORD) == sizeof(NT_OWF_PASSWORD));
    ASSERT(sizeof(ENCRYPTED_LM_OWF_PASSWORD) == sizeof(ENCRYPTED_NT_OWF_PASSWORD));

    return(RtlEncryptLmOwfPwdWithIndex(
                            (PLM_OWF_PASSWORD)NtOwfPassword,
                            Index,
                            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}



NTSTATUS
RtlDecryptNtOwfPwdWithIndex(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PCRYPT_INDEX Index,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    Decrypts an NtOwfPassword with an index

Arguments:

    EncryptedNtOwfPassword - The encrypted OwfPassword to be decrypted

    Index - value to be used as decryption key

    NtOwfPassword - Decrypted NtOwfPassword is returned here


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in NtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The NtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(LM_OWF_PASSWORD) == sizeof(NT_OWF_PASSWORD));
    ASSERT(sizeof(ENCRYPTED_LM_OWF_PASSWORD) == sizeof(ENCRYPTED_NT_OWF_PASSWORD));

    return(RtlDecryptLmOwfPwdWithIndex(
                            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword,
                            Index,
                            (PLM_OWF_PASSWORD)NtOwfPassword));
}




NTSTATUS
RtlEncryptLmOwfPwdWithUserKey(
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PUSER_SESSION_KEY  UserSessionKey,
    OUT PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with a session key

Arguments:

    LmOwfPassword - OwfPassword to be encrypted

    UserSessionKey - key to the encryption

    EncryptedLmOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedLmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedLmOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(USER_SESSION_KEY) == sizeof(LM_OWF_PASSWORD));

    return(RtlEncryptLmOwfPwdWithLmOwfPwd(LmOwfPassword,
                                          (PLM_OWF_PASSWORD)UserSessionKey,
                                          EncryptedLmOwfPassword));
}



NTSTATUS
RtlDecryptLmOwfPwdWithUserKey(
    IN PENCRYPTED_LM_OWF_PASSWORD EncryptedLmOwfPassword,
    IN PUSER_SESSION_KEY  UserSessionKey,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )
/*++

Routine Description:

    Decrypts one OwfPassword with a session key

Arguments:

    EncryptedLmOwfPassword - The ecnrypted OwfPassword to be decrypted

    UserSessionKey - key to the encryption

    LmOwfPassword - The decrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in LmOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(USER_SESSION_KEY) == sizeof(LM_OWF_PASSWORD));

    return(RtlDecryptLmOwfPwdWithLmOwfPwd(EncryptedLmOwfPassword,
                                          (PLM_OWF_PASSWORD)UserSessionKey,
                                          LmOwfPassword));
}



NTSTATUS
RtlEncryptNtOwfPwdWithUserKey(
    IN PNT_OWF_PASSWORD NtOwfPassword,
    IN PUSER_SESSION_KEY  UserSessionKey,
    OUT PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++

Routine Description:

    Encrypts an OwfPassword with a user session key

Arguments:

    NtOwfPassword - OwfPassword to be encrypted

    UserSessionKey - key to the encryption

    EncryptedNtOwfPassword - The encrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The encrypted
                     OwfPassword is in EncryptedNtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The EncryptedNtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(LM_OWF_PASSWORD));
    ASSERT(sizeof(ENCRYPTED_NT_OWF_PASSWORD) == sizeof(ENCRYPTED_LM_OWF_PASSWORD));

    return(RtlEncryptLmOwfPwdWithUserKey(
            (PLM_OWF_PASSWORD)NtOwfPassword,
            UserSessionKey,
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword));
}



NTSTATUS
RtlDecryptNtOwfPwdWithUserKey(
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword,
    IN PUSER_SESSION_KEY  UserSessionKey,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )
/*++

Routine Description:

    Decrypts one OwfPassword with a user session key

Arguments:

    EncryptedNtOwfPassword - The ecnrypted OwfPassword to be decrypted

    UserSessionKey - key to the encryption

    NtOwfPassword - The decrypted OwfPassword is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The decrypted
                     OwfPassword is in NtOwfPassword

    STATUS_UNSUCCESSFUL - Something failed. The NtOwfPassword is undefined.
--*/
{
    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(LM_OWF_PASSWORD));
    ASSERT(sizeof(ENCRYPTED_NT_OWF_PASSWORD) == sizeof(ENCRYPTED_LM_OWF_PASSWORD));

    return(RtlDecryptLmOwfPwdWithUserKey(
            (PENCRYPTED_LM_OWF_PASSWORD)EncryptedNtOwfPassword,
            UserSessionKey,
            (PLM_OWF_PASSWORD)NtOwfPassword));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\userkey.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    userkey.c

Abstract:

    Implentation of the functions that get and generate user session keys

        RtlCalculateUserSessionKeyLm
        RtlCalculateUserSessionKeyNt
        RtlGetUserSessionKeyClient
        RtlGetUserSessionKeyServer


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddnfs.h>
#include <rpc.h>
#include <rpcndr.h>
#include <crypt.h>
#include <srvfsctl.h>       // Server definitions
#include <status.h>         // Server return codes

#ifdef WIN32_CHICAGO
#include <assert.h>
#undef ASSERT
#define ASSERT(exp) assert(exp)
#endif
//
// Define this if you want to know all about user session keys
//

// #define DEBUG_USER_SESSION_KEYS



#define REDIRECTOR_DEVICENAME L"\\Device\\LanmanRedirector\\"
#define REDIRECTOR_IPC_FILENAME L"\\IPC$"


//
// Define the user session key to be used for local connections
// Make sure the initial data fills the structure completely !
//

USER_SESSION_KEY LocalSessionKey = { 'S', 'y', 's', 't', 'e', 'm', 'L', 'i',
                                     'b', 'r', 'a', 'r', 'y', 'D', 'T', 'C'
                                   };

//
// Define the user session key that represents an error.
// This value will be generated by other parts of the system on failure.
// We will check for it in our query code and return an error if it's found.
//

USER_SESSION_KEY ErrorSessionKey = { 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0
                                   };



NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

    The current implementation takes the one-way-function of the OwfPassword
    and returns this as the key.

Arguments:

    LmResponse - The response sent during session setup.

    LmOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    NTSTATUS Status;
    NT_PASSWORD NtPassword;

    //
    // Make the Owf password look like an NT password
    //

    NtPassword.Buffer = (PWSTR)LmOwfPassword; // We can do this cast because we
                                              // know the OWF routine treats this
                                              // pointer as a byte pointer.
    NtPassword.Length = sizeof(*LmOwfPassword);
    NtPassword.MaximumLength = sizeof(*LmOwfPassword);


    //
    // Calculate the OWF of the OwfPassword
    //

    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(*UserSessionKey));

    Status = RtlCalculateNtOwfPassword( &NtPassword,
                                        (PNT_OWF_PASSWORD)UserSessionKey
                                        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlCalculateUserSessionKeyLm : OWF calculation failed, status = 0x%lx\n", Status));
        return(Status);
    }

    //
    // Check if we've generated the error session key
    //

    if (RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) == sizeof(*UserSessionKey)) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlCalculateSessionKeyLm - generated error session key, modifying it\n"));
#endif
        //
        // Move away from the error session key
        //

        UserSessionKey->data[0].data[0] ++;

        ASSERT(RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) != sizeof(*UserSessionKey));
    }

#ifdef DEBUG_USER_SESSION_KEYS
    KdPrint(("RtlCalculateUserSessionKeyLm : Key = 0x%lx : %lx : %lx : %lx\n",
            ((PULONG)UserSessionKey)[0], ((PULONG)UserSessionKey)[1],
            ((PULONG)UserSessionKey)[2], ((PULONG)UserSessionKey)[3]));
#endif

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(LmResponse);
}



NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

Arguments:

    NtResponse - The response sent during session setup.

    NtOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    // Just call the LM version

    ASSERT(sizeof(NT_RESPONSE) == sizeof(LM_RESPONSE));
    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(LM_OWF_PASSWORD));

    return(RtlCalculateUserSessionKeyLm((PLM_RESPONSE)NtResponse,
                                        (PLM_OWF_PASSWORD)NtOwfPassword,
                                        UserSessionKey));
}


NTSTATUS
RtlGetUserSessionKeyClientBinding(
    IN PVOID RpcBindingHandle,
    OUT HANDLE *RedirHandle,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Returns the user session key associated with an rpc connection.
    This function should be called by the client side of the connection only.

Arguments:

    RpcBindingHandle - The rpc connection we're interested in

    RedirHandle - Returns a handle to the redir.  Since RpcBindingHandles don't represent
        and open connection to the server, we have to ensure the connection stays open
        until the server side has a chance to get this same UserSessionKey.  The only
        way to do that is to keep the connect open.

        Returns NULL if no handle is needed.

        This handle should be closed by calling NtClose.

    UserSessionKey - The user session key is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_LOCAL_USER_SESSION_KEY - An informational status value.
                   - The rpc connection is local, the usersessionkey returned
                   - is constant and not unique to this connection.
                   - There is little to be gained by encrypting data over
                   - this connection

    STATUS_NO_USER_SESSION_KEY - No session key exists for this session.

    ------ these come from parsebinding -------

    RPC_NT_OUT_OF_MEMORY - Insufficent memory is available to allocate
        space for the fields of the string binding.

    RPC_NT_INVALID_STRING_BINDING - The string binding is syntactically
        invalid.

    RPC_NT_INVALID_ARG - The string binding is not specified
        (ie. ARGUMENT_PRESENT(StringBinding) is false).
--*/

{
    NTSTATUS Status, IgnoreStatus;
    WCHAR    *StringBinding;
    WCHAR    *ServerNameZ;
    WCHAR    *BareServerNameZ; // Points to server name minus leading '\'s
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING ServerName;
    UNICODE_STRING RedirDevice;
    UNICODE_STRING IpcFileName;
    UNICODE_STRING ServerIpcFileName;
    USHORT  LengthRequired;
    IO_STATUS_BLOCK IoStatusBlock;
    LMR_REQUEST_PACKET RdrRequestPacket;
    LMR_CONNECTION_INFO_2 ConnectionInfo;


    //
    // Get the string description of the binding from the rpc handle
    //

    *RedirHandle = NULL;
    Status = (NTSTATUS)I_RpcMapWin32Status(
            RpcBindingToStringBindingW(RpcBindingHandle, &StringBinding));
    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlGetUserSessionKeyClient - failed to get stringbinding, Status = 0x%lx\n\r", Status));
        ASSERT(FALSE);
        return(Status);
    }

    //
    // Parse the stringbinding to get the server name
    //

    Status = (NTSTATUS)I_RpcMapWin32Status(RpcStringBindingParseW(
                                StringBinding,
                                NULL,                // object uid
                                NULL,                // protseq !
                                &ServerNameZ,        // network address
                                NULL,                // endpoint
                                NULL                 // network options
                                ));

    //
    // We're finished with the string binding
    //

    IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&StringBinding));
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Check the result of binding parse
    //

    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlGetUserSessionKeyClient - failed to parse stringbinding, status = 0x%lx\n\r", Status));
        ASSERT(FALSE);
        return(Status);
    }

    //
    // Check for a local connection
    //

    if ( (ServerNameZ == NULL) || (ServerNameZ[0] == UNICODE_NULL) ) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlGetUserSessionKeyClient - server name is NULL, returning local key\n"));
#endif
        //
        // Use a constant, default session key
        //

        *UserSessionKey = LocalSessionKey;

        IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&ServerNameZ));
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(STATUS_LOCAL_USER_SESSION_KEY);
    }

    //
    // Strip the leading '\'s from the server name
    //

    BareServerNameZ = ServerNameZ;
    while (*BareServerNameZ == L'\\') {
        BareServerNameZ ++;
    }

    //
    // Set up a counted string for out server name
    //

    RtlInitUnicodeString(&ServerName, BareServerNameZ);


    //
    // Check for the local server name '.'
    //

    if ( (ServerName.Length == sizeof(*ServerName.Buffer)) &&
         (ServerName.Buffer[0] == L'.') ) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlGetUserSessionKeyClient - server name is '.', returning local key\n"));
#endif
        //
        // Use a constant, default session key
        //

        *UserSessionKey = LocalSessionKey;

        IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&ServerNameZ));
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(STATUS_LOCAL_USER_SESSION_KEY);
    }


    //
    // Create a redirector ipc file name for the referenced server
    //

    RtlInitUnicodeString(&RedirDevice, REDIRECTOR_DEVICENAME);
    RtlInitUnicodeString(&IpcFileName, REDIRECTOR_IPC_FILENAME);

    LengthRequired = RedirDevice.Length + ServerName.Length + IpcFileName.Length;


    //
    // Allocate space for the ipc file name we will create
    //

    ServerIpcFileName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, LengthRequired);
    if (ServerIpcFileName.Buffer == NULL) {

        KdPrint(("RtlGetUserSessionKeyClient - failed to allocate space for server name (%d bytes)\n", LengthRequired));

        IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&ServerNameZ));
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    ServerIpcFileName.Length = 0;
    ServerIpcFileName.MaximumLength = LengthRequired;


    //
    // ServerIpcFileName = \Device\LanmanRedirector\ + servername + \ipc$
    //

    RtlCopyUnicodeString(&ServerIpcFileName, &RedirDevice);

    IgnoreStatus = RtlAppendUnicodeStringToString(&ServerIpcFileName, &ServerName);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    IgnoreStatus = RtlAppendUnicodeStringToString(&ServerIpcFileName, &IpcFileName);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Don't need the server name any more
    //

    IgnoreStatus = I_RpcMapWin32Status(RpcStringFreeW(&ServerNameZ));
    ASSERT(NT_SUCCESS(IgnoreStatus));




    //
    // Open up the redirector ipc file
    //

    InitializeObjectAttributes( &Attributes,
                                &ServerIpcFileName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenFile( RedirHandle,
                         FILE_READ_DATA |   // access required to get connection info
                         SYNCHRONIZE,       // access required to wait on object
                         &Attributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ,
                         FILE_CREATE_TREE_CONNECTION );
    //
    // We're finished with the ipc filename
    //

    RtlFreeHeap( RtlProcessHeap(), 0, ServerIpcFileName.Buffer );
    ServerIpcFileName.Buffer = NULL;

    //
    // Check the result of the open
    //

    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlGetUserSessionKeyClient - failed to open redirector, status = 0x%lx\n\r", Status));
        *RedirHandle = NULL;
        return(Status);
    }



    //
    // Get the connection info for this link
    //

    RdrRequestPacket.Version = REQUEST_PACKET_VERSION;
    RdrRequestPacket.Level = 2; // We want the session key.

    Status = NtFsControlFile( *RedirHandle,
                              NULL,                     // Event
                              NULL,                     // APC routine
                              NULL,                     // APC context
                              &IoStatusBlock,
                              FSCTL_LMR_GET_CONNECTION_INFO,
                              &RdrRequestPacket,        // Input buffer
                              sizeof(RdrRequestPacket), // Input buffer length
                              &ConnectionInfo,          // Output buffer
                              sizeof(ConnectionInfo)    // Output buffer length
                              );

    //
    // remove the reference created on the existing connection.
    // this logic assumes the caller of RtlGetUserSessionKeyClientXXX()
    // has already established a connection.
    //

    {
        LMR_REQUEST_PACKET Rrp;            // Redirector request packet
        NTSTATUS           TempStatus;
 
        RtlZeroMemory(&Rrp,sizeof(LMR_REQUEST_PACKET));
        Rrp.Level = USE_FORCE;  // this tells rdr2 to take away the extra reference
                                // to connection strucutre even when files are open.
        Rrp.Version = REQUEST_PACKET_VERSION;
 
        TempStatus = NtFsControlFile(
                            *RedirHandle,                   // handle
                            NULL,                           // no event
                            NULL,                           // no APC routine
                            NULL,                           // no APC context
                            &IoStatusBlock,                 // I/O stat blk (set)
                            FSCTL_LMR_DELETE_CONNECTION,    // func code
                            &Rrp,
                            sizeof(LMR_REQUEST_PACKET),
                            NULL,
                            0
                            );

        //
        // block on the delete if necessary.
        //

        if( TempStatus == STATUS_PENDING )
        {
            NtWaitForSingleObject( *RedirHandle, TRUE, NULL );
        }
    }



    //
    // Check the result of the control file call
    //

    if (!NT_SUCCESS(Status)) {
        IgnoreStatus = NtClose(*RedirHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        *RedirHandle = NULL;
        KdPrint(("RtlGetUserSessionKeyClient - failed to get connection info, status = 0x%lx\n\r", Status));
        ASSERT(FALSE);
        return(Status);
    }

    //
    // Copy the session key into the passed buffer
    //

    *UserSessionKey = *(PUSER_SESSION_KEY)(ConnectionInfo.UserSessionKey);


    //
    // Check for the error session key
    //

    if (RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) == sizeof(*UserSessionKey)) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlGetUserSessionKeyClient - got error session key, returning error\n"));
#endif
        Status = STATUS_NO_USER_SESSION_KEY;
        IgnoreStatus = NtClose(*RedirHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));
        *RedirHandle = NULL;
    }


#ifdef DEBUG_USER_SESSION_KEYS
    KdPrint(("RtlGetUserSessionKeyClient : Key = 0x%lx : %lx : %lx : %lx\n",
            ((PULONG)UserSessionKey)[0], ((PULONG)UserSessionKey)[1],
            ((PULONG)UserSessionKey)[2], ((PULONG)UserSessionKey)[3]));
#endif

    return(Status);
}






NTSTATUS
RtlGetUserSessionKeyClient(
    IN PVOID RpcContextHandle,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Returns the user session key associated with an rpc connection.
    This function should be called by the client side of the connection only.

Arguments:

    RpcContextHandle - The rpc connection we're interested in
        This can also be an RPC binding handle.

    UserSessionKey - The user session key is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_LOCAL_USER_SESSION_KEY - An informational status value.
                   - The rpc connection is local, the usersessionkey returned
                   - is constant and not unique to this connection.
                   - There is little to be gained by encrypting data over
                   - this connection

    STATUS_NO_USER_SESSION_KEY - No session key exists for this session.

    ------ these come from parsebinding -------

    RPC_NT_OUT_OF_MEMORY - Insufficent memory is available to allocate
        space for the fields of the string binding.

    RPC_NT_INVALID_STRING_BINDING - The string binding is syntactically
        invalid.

    RPC_NT_INVALID_ARG - The string binding is not specified
        (ie. ARGUMENT_PRESENT(StringBinding) is false).
--*/

{
    NTSTATUS Status;
    HANDLE RedirHandle = NULL;

    //
    // Call the worker routine.
    //

    Status = RtlGetUserSessionKeyClientBinding(
                NDRCContextBinding((NDR_CCONTEXT)RpcContextHandle),
                &RedirHandle,
                UserSessionKey );

    if ( RedirHandle != NULL ) {
        NtClose( RedirHandle );
    }

    return Status;
}



NTSTATUS
RtlGetUserSessionKeyServer(
    IN PVOID RpcContextHandle OPTIONAL,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Returns the user session key associated with an rpc connection.
    This function should be called by the server side of the connection only.

Arguments:

    RpcBindingHandle - The rpc connection we're interested in
                     - Note this parameter is ignored for now

    UserSessionKey - The user session key is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_LOCAL_USER_SESSION_KEY - An informational status value.
                   - The rpc connection is local, the usersessionkey returned
                   - is constant and not unique to this connection.
                   - There is little to be gained by encrypting data over
                   - this connection

    STATUS_NO_USER_SESSION_KEY - No session key exists for this session.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    HANDLE  TokenHandle;
    TOKEN_STATISTICS TokenInfo;
    ULONG ReturnedLength;
    UNICODE_STRING ServerDevice;
    ANSI_STRING AnsiString;
    OBJECT_ATTRIBUTES Attributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE  ServerHandle;
    RPC_BINDING_HANDLE RpcBindingHandle;
    unsigned int RpcClientLocalFlag;


    //
    // Get the binding handle for this connection
    //

    // LATER RpcBindingHandle = (RPC_BINDING_HANDLE) RpcContextHandle;
    RpcBindingHandle = NULL;


    //
    // If this is a local connection then we can immediately
    // return the local session key.
    //

    Status = I_RpcBindingIsClientLocal(RpcBindingHandle, &RpcClientLocalFlag);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlGetUserSessionKeyServer: RpcBindingIsClientLocal failed, status = 0x%lx\n", Status));
        return(Status);
    }

    if (RpcClientLocalFlag != 0) {
        *UserSessionKey = LocalSessionKey;
#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlGetUserSessionKeyServer: client is local, returning local key\n"));
#endif
        return (STATUS_LOCAL_USER_SESSION_KEY);
    }




    //
    // Get a handle to the client's token
    //

    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_QUERY,
                               TRUE,
                               &TokenHandle);
    //
    // If we couldn't open the thread token because we weren't impersonating
    // then impersonate and try again.
    //

    if (!NT_SUCCESS(Status)) {

        //
        // Check we failed only because we weren't impersonating
        //

        if (Status != STATUS_NO_TOKEN) {
            KdPrint(("RtlGetUserSessionKeyServer - failed to open thread token, status = 0x%lx\n", Status));
            ASSERT(FALSE);
            return(Status);
        }

        //
        // Impersonate the client ourselves
        //

        Status = I_RpcMapWin32Status(RpcImpersonateClient(RpcBindingHandle));
        if (!NT_SUCCESS(Status)) {
            KdPrint(("RtlGetUserSessionKeyServer - RpcImpersonateClient failed, status = 0x%lx\n", Status));
            ASSERT(FALSE);
            return(Status);
        }

        //
        // Try to get a token handle now we're impersonating
        //

        Status = NtOpenThreadToken(NtCurrentThread(),
                                   TOKEN_QUERY,
                                   TRUE,
                                   &TokenHandle);
        if (!NT_SUCCESS(Status)) {

            KdPrint(("RtlGetUserSessionKeyServer - failed to open thread token after impersonating, status = 0x%lx\n", Status));
            ASSERT(FALSE);

            IgnoreStatus = I_RpcMapWin32Status(RpcRevertToSelf());
            ASSERT(NT_SUCCESS(IgnoreStatus));

            return(Status);
        }

        //
        // We've got a token handle, stop impersonating
        //

        Status = I_RpcMapWin32Status(RpcRevertToSelf());

        if (!NT_SUCCESS(Status)) {

            KdPrint(("RtlGetUserSessionKeyServer - RpcRevertToSelf failed, status = 0x%lx\n", Status));
            ASSERT(FALSE);

            IgnoreStatus = NtClose(TokenHandle);
            ASSERT(NT_SUCCESS(IgnoreStatus));

            return(Status);
        }

    }

    //
    // We've now got a token handle, get the authentication id from it.
    //

    Status = NtQueryInformationToken(
                    TokenHandle,
                    TokenStatistics,
                    &TokenInfo,
                    sizeof(TokenInfo),
                    &ReturnedLength
                    );

    //
    // We're done with the token
    //

    IgnoreStatus = NtClose(TokenHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Check result of token query
    //

    if (!NT_SUCCESS(Status)) {

        KdPrint(("RtlGetUserSessionKeyServer - Failed to query token statistics from token, status = 0x%lx\n", Status));
        ASSERT(FALSE);

        return(Status);
    }



    //
    // Open the server device
    //

    RtlInitAnsiString(&AnsiString, SERVER_DEVICE_NAME);

    Status = RtlAnsiStringToUnicodeString(&ServerDevice, &AnsiString, TRUE);
    if (!NT_SUCCESS(Status)) {

        KdPrint(("RtlGetUserSessionKeyServer - RtlAnsiToUnicodeString failed, status = 0x%lx\n", Status));
        ASSERT(FALSE);

        return(Status);
    }

    InitializeObjectAttributes( &Attributes,
                                &ServerDevice,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = NtOpenFile( &ServerHandle,
                         GENERIC_READ | GENERIC_WRITE, // LATER use correct access
                         &Attributes,
                         &IoStatusBlock,
                         FILE_SHARE_READ,
                         0 );

    RtlFreeUnicodeString(&ServerDevice);

    if (!NT_SUCCESS(Status)) {

        //
        // Check for the case when the server driver is not present
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

#ifdef DEBUG_USER_SESSION_KEYS
            KdPrint(("RtlGetUserSessionKeyServer - server driver not present, returning local key\n"));
#endif
            *UserSessionKey = LocalSessionKey;
            Status = STATUS_LOCAL_USER_SESSION_KEY;

        } else {
            KdPrint(("RtlGetUserSessionKeyServer - Failed to open the server, status = 0x%lx\n", Status));
            ASSERT(FALSE);
        }

        return(Status);
    }


    //
    // Get the session key for this client from the server
    //

    Status = NtFsControlFile( ServerHandle,
                              NULL,                 // Event
                              NULL,                 // APC
                              NULL,                 // APC Context
                              &IoStatusBlock,
                              FSCTL_SRV_GET_CHALLENGE,
                              &TokenInfo.AuthenticationId,
                              sizeof(TokenInfo.AuthenticationId),
                              (PVOID)UserSessionKey,
                              sizeof(*UserSessionKey));
    //
    // We're done with the file handle
    //

    IgnoreStatus = NtClose(ServerHandle);
    ASSERT(NT_SUCCESS(IgnoreStatus));



    if (NT_SUCCESS(Status)) {

        //
        // Check for the error session key
        //

        if (RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                           sizeof(*UserSessionKey)) == sizeof(*UserSessionKey)) {

#ifdef DEBUG_USER_SESSION_KEYS
            KdPrint(("RtlGetUserSessionKeyServer - got error session key, returning error\n"));
#endif
            Status = STATUS_NO_USER_SESSION_KEY;
        }

    } else {

        //
        // If the server is not started or the token couldn't be found in the
        // list of server connections, then assume it's a local connection
        //

        if ( (Status == STATUS_SERVER_NOT_STARTED) ||
             (Status == STATUS_NO_TOKEN) ) {

#ifdef DEBUG_USER_SESSION_KEYS
            KdPrint(("RtlGetUserSessionKeyServer - server not started or logon id not found (Status = 0x%lx), returning local key\n", Status));
#endif
            *UserSessionKey = LocalSessionKey;
            Status = STATUS_LOCAL_USER_SESSION_KEY;

        } else {
            KdPrint(("RtlGetUserSessionKeyServer - Failed to query the user session key from the server, status = 0x%lx\n", Status));
            ASSERT(FALSE);
        }
    }


#ifdef DEBUG_USER_SESSION_KEYS
    KdPrint(("RtlGetUserSessionKeyServer : Key = 0x%lx : %lx : %lx : %lx, status = 0x%lx\n",
            ((PULONG)UserSessionKey)[0], ((PULONG)UserSessionKey)[1],
            ((PULONG)UserSessionKey)[2], ((PULONG)UserSessionKey)[3], Status));
#endif


    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\crypt\dll\winnt\makefile.inc ===
$(O)\sys003.lib: $(O)\crypt.lib
    lib -out:$@ $**
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\idl\efsimp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    efsimp.h

Abstract:

    EFS RPC Interfaces, private includes

Author:

    Robert Reichel       (RobertRe)       October 15, 1997

Environment:

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windef.h>
#include <winbase.h>
#include <wincrypt.h>
#include <winefs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\idl\makefile.inc ===
IDL_NAME = lsarpc

CLIENT_ACF = lsacli.acf
SERVER_ACF = $(PROJECT_ROOT)\published\lsa\lsasrv.acf

CLIENT_INC_FILE = $(IDL_NAME)_c.h
SERVER_INC_FILE = $(IDL_NAME).h

CLIENT_TARGETS = \
        $(O)\$(IDL_NAME)_c.c \
        $(O)\$(CLIENT_INC_FILE)

SERVER_TARGETS = \
        $(O)\$(IDL_NAME)_s.c \
        $(O)\$(SERVER_INC_FILE)

EFS_TARGETS = \
        $(O)\efsrpc.h

MIDL_INCS= -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(DS_INC_PATH) -I$(PROJECT_ROOT)\published\lsa
MIDL_OPTIMIZATION_NT5=-Oicf -robust -error all -no_format_opt -protocol all
MIDL_OPTIMIZATION_EFS=-Oicf -robust -error stub_data -protocol all

CLIENT_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames $(MIDL_FLAGS) -out .\$(O) -acf $(CLIENT_ACF) -server none -header $(CLIENT_INC_FILE)
SERVER_FLAGS  = $(MIDL_OPTIMIZATION_NT5) -oldnames $(MIDL_FLAGS) -out .\$(O) -acf $(SERVER_ACF) -client none -header $(SERVER_INC_FILE)
EFS_FLAGS     = $(MIDL_OPTIMIZATION_EFS) -oldnames $(MIDL_FLAGS) -out .\$(O) -char unsigned -header efsrpc.h

EFS_DEFINES   = -DMIDL_PASS $(FLAGS) -DSECURITY_WIN32

CPP = -cpp_cmd "$(MIDL_CPP)"

TARGETS: \
        $(CLIENT_TARGETS) \
        $(SERVER_TARGETS) \
        $(EFS_TARGETS)

$(CLIENT_TARGETS): $(PROJECT_ROOT)\published\lsa\$(IDL_NAME).idl $(CLIENT_ACF)
    $(MIDL) $(CPP) $(CLIENT_FLAGS) $(MIDL_INCS) $(PROJECT_ROOT)\published\lsa\$(IDL_NAME).idl

$(SERVER_TARGETS): $(PROJECT_ROOT)\published\lsa\$(IDL_NAME).idl $(SERVER_ACF)
    $(MIDL) $(CPP) $(SERVER_FLAGS) $(MIDL_INCS) $(PROJECT_ROOT)\published\lsa\$(IDL_NAME).idl

$(EFS_TARGETS): efsrpc.idl
    $(MIDL) $(CPP) $(EFS_FLAGS) $(MIDL_INCS) $(ERRORS) $(EFS_DEFINES) efsrpc.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\inc\aup.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aup.h

Abstract:

    Local Security Authority definitions that are related to AUTHENTICATION
    services and are shared between the LSA server and LSA client stubs

Author:

    Jim Kelly (JimK) 20-Feb-1991

Revision History:

--*/

#ifndef _AUP_
#define _AUP_


#define LSAP_MAX_LOGON_PROC_NAME_LENGTH 127
#define LSAP_MAX_PACKAGE_NAME_LENGTH    127


//
// Used for connecting to the LSA authentiction port.
//

#define LSAP_AU_KERNEL_CLIENT 0x1

typedef struct _LSAP_AU_REGISTER_CONNECT_INFO {
    NTSTATUS CompletionStatus;
    ULONG SecurityMode;
    ULONG LogonProcessNameLength;
    CHAR LogonProcessName[LSAP_MAX_PACKAGE_NAME_LENGTH+1];
} LSAP_AU_REGISTER_CONNECT_INFO, *PLSAP_AU_REGISTER_CONNECT_INFO;

typedef struct _LSAP_AU_REGISTER_CONNECT_INFO_EX {
    NTSTATUS CompletionStatus;
    ULONG Security;
    ULONG LogonProcessNameLength;
    CHAR LogonProcessName[LSAP_MAX_PACKAGE_NAME_LENGTH+1];
    ULONG ClientMode;
} LSAP_AU_REGISTER_CONNECT_INFO_EX, *PLSAP_AU_REGISTER_CONNECT_INFO_EX;

typedef struct _LSAP_AU_REGISTER_CONNECT_RESP {
    NTSTATUS CompletionStatus;
    LSA_OPERATIONAL_MODE SecurityMode;
    ULONG PackageCount;
    UCHAR Reserved[ LSAP_MAX_PACKAGE_NAME_LENGTH + 1 ];
} LSAP_AU_REGISTER_CONNECT_RESP, * PLSAP_AU_REGISTER_CONNECT_RESP;



//
// Conditional type definition for Wow64 environment.  The LPC messages
// are kept "native" size, so pointers are full size.  The WOW environment
// will do the thunking.  LPC messages are defined with types that are
// always the correct size using these "aliases".
//

#ifdef BUILD_WOW64

#if 0
typedef WCHAR __ptr64 * PWSTR_AU ;
typedef VOID __ptr64 * PVOID_AU ;
#else 
typedef ULONGLONG PWSTR_AU ;
typedef ULONGLONG PVOID_AU ;
#endif 

typedef struct _STRING_AU {
    USHORT Length ;
    USHORT MaximumLength ;
    PVOID_AU Buffer ;
} STRING_AU, * PSTRING_AU ;

typedef PVOID_AU   HANDLE_AU ;

#define SecpStringToLpc( L, S ) \
    (L)->Length = (S)->Length ; \
    (L)->MaximumLength = (S)->MaximumLength ; \
    (L)->Buffer = (PVOID_AU) (S)->Buffer ;

#define SecpLpcStringToString( S, L ) \
    (S)->Length = (L)->Length ;  \
    (S)->MaximumLength = (L)->MaximumLength ; \
    (S)->Buffer = (PCHAR) (L)->Buffer ;


#else

typedef PVOID               PVOID_AU ;
typedef PWSTR               PWSTR_AU ;
typedef STRING STRING_AU, *PSTRING_AU ;
typedef HANDLE HANDLE_AU ;

#define SecpStringToLpc( L, S ) \
        *(L) = *(S) ;

#define SecpLpcStringToString( S, L ) \
        *(S) = *(L) ;

#endif 


//
// Message formats used by clients of the local security authority.
// Note that:
//
//      LsaFreeReturnBuffer() does not result in a call to the server.
//
//      LsaRegisterLogonProcess() is handled completely by the
//      LPC port connection, and requires no API number.
//
//      DeRegister Logon Process doesn't have a call-specific structure.
//

typedef enum _LSAP_AU_API_NUMBER {
    LsapAuLookupPackageApi,
    LsapAuLogonUserApi,
    LsapAuCallPackageApi,
    LsapAuDeregisterLogonProcessApi,
    LsapAuMaxApiNumber
} LSAP_AU_API_NUMBER, *PLSAP_AU_API_NUMBER;


//
// Each API results in a data structure containing the parameters
// of that API being transmitted to the LSA server.  This data structure
// (LSAP_API_MESSAGE) has a common header and a body which is dependent
// upon the type of call being made.  The following data structures are
// the call-specific body formats.
//

typedef struct _LSAP_LOOKUP_PACKAGE_ARGS {
    ULONG AuthenticationPackage;       // OUT parameter
    ULONG PackageNameLength;
    CHAR PackageName[LSAP_MAX_PACKAGE_NAME_LENGTH+1];
} LSAP_LOOKUP_PACKAGE_ARGS, *PLSAP_LOOKUP_PACKAGE_ARGS;

typedef struct _LSAP_LOGON_USER_ARGS {
    STRING_AU OriginName;
    SECURITY_LOGON_TYPE LogonType;
    ULONG AuthenticationPackage;
    PVOID_AU AuthenticationInformation;
    ULONG AuthenticationInformationLength;
    ULONG LocalGroupsCount;
    PVOID_AU LocalGroups;
    TOKEN_SOURCE SourceContext;
    NTSTATUS SubStatus;                // OUT parameter
    PVOID_AU ProfileBuffer;            // OUT parameter
    ULONG ProfileBufferLength;         // OUT parameter
    ULONG DummySpacer;                 // Spacer to force LUID to 8 byte alignment
    LUID LogonId;                      // OUT parameter
    HANDLE_AU Token;                   // OUT parameter
    QUOTA_LIMITS Quotas;               // OUT parameter
} LSAP_LOGON_USER_ARGS, *PLSAP_LOGON_USER_ARGS;

typedef struct _LSAP_CALL_PACKAGE_ARGS {
    ULONG AuthenticationPackage;
    PVOID_AU ProtocolSubmitBuffer;
    ULONG SubmitBufferLength;
    NTSTATUS ProtocolStatus;           // OUT parameter
    PVOID_AU ProtocolReturnBuffer;        // OUT parameter
    ULONG ReturnBufferLength;          // OUT parameter
} LSAP_CALL_PACKAGE_ARGS, *PLSAP_CALL_PACKAGE_ARGS;




//
// This is the message that gets sent for every LSA LPC call.
//

typedef struct _LSAP_AU_API_MESSAGE {
    PORT_MESSAGE PortMessage;
    union {
        LSAP_AU_REGISTER_CONNECT_INFO ConnectionRequest;
        struct {
            LSAP_AU_API_NUMBER ApiNumber;
            NTSTATUS ReturnedStatus;
            union {
                LSAP_LOOKUP_PACKAGE_ARGS LookupPackage;
                LSAP_LOGON_USER_ARGS LogonUser;
                LSAP_CALL_PACKAGE_ARGS CallPackage;
            } Arguments;
        };
    };
} LSAP_AU_API_MESSAGE, *PLSAP_AU_API_MESSAGE;






#endif // _AUP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\inc\lsaperf.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       lsaperf.h
//
//  Contents:   Performance Counters for LSA
//
//  Classes:
//
//  Functions:
//
//  History:    10-23-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __LSAPERF_H__
#define __LSAPERF_H__

#define QUEUE_TYPE_GENERAL      0x10000000
#define QUEUE_TYPE_DEDICATED    0x20000000
#define QUEUE_TYPE_DIRECT       0x30000000

typedef struct _LSAP_QUEUE_PERF_DATA {
    LONGLONG    MessageCount ;
    ULONG   QueueType ;
    ULONG   Threads ;
    ULONG   CurrentDepth ;
    ULONG   Shortages ;
} LSAP_QUEUE_PERF_DATA, * PLSAP_QUEUE_PERF_DATA ;

typedef struct _LSAP_PACKAGE_PERF_DATA {
    ULONG   ContextHandles ;
    ULONG   CredentialHandles ;
} LSAP_PACKAGE_PERF_DATA, * PLSAP_PACKAGE_PERF_DATA ;

typedef struct _LSAP_CLIENT_PERF_DATA {
    ULONG   ProcessId ;
    ULONG   ContextHandles ;
    ULONG   CredentialHandles ;
} LSAP_CLIENT_PERF_DATA, * PLSAP_CLIENT_PERF_DATA ;

typedef struct _LSAP_PERFORMANCE_DATA {
    ULONG   TotalWorkerThreads ;
    ULONG   DedicatedWorkerThreads ;
    ULONG   TotalContextHandles ;
    ULONG   TotalCredentialHandles ;
    ULONG   TotalApiCalls ;
    ULONG   OffsetToQueueData ;
    ULONG   CountOfQueueData ;
    ULONG   OffsetToPackageData ;
    ULONG   CountOfPackageData ;
    ULONG   OffsetToClientData ;
    ULONG   CountOfClientData ;
} LSAP_PERFORMANCE_DATA, * PLSAP_PERFORMANCE_DATA ;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\inc\cr.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cr.h

Abstract:

    Local Security Authority - Encryption Routine Definitions

    NOTE:  This file is included via lsacomp.h.  It should
           not be included directly.

Author:

    Scott Birrell       (ScottBi)      December 13, 1991

Environment:

Revision History:

--*/

//
// Max encryption Key Length
//

#define LSAP_CR_MAX_CIPHER_KEY_LENGTH   (0x00000010L)

//
// Cipher Key Structure
//

typedef struct _LSAP_CR_CIPHER_KEY {

    ULONG Length;
    ULONG MaximumLength;
    PUCHAR  Buffer;

} LSAP_CR_CIPHER_KEY, *PLSAP_CR_CIPHER_KEY;


//
// Clear value structure
//

typedef struct _LSAP_CR_CLEAR_VALUE {

    ULONG Length;
    ULONG MaximumLength;
    PUCHAR Buffer;

} LSAP_CR_CLEAR_VALUE, *PLSAP_CR_CLEAR_VALUE;

//
// Two-way encrypted value structure in Self-relative form.  This
// is just like a String.
//

typedef struct _LSAP_CR_CIPHER_VALUE {

    ULONG Length;
    ULONG MaximumLength;
    PUCHAR  Buffer;

} LSAP_CR_CIPHER_VALUE, *PLSAP_CR_CIPHER_VALUE;


NTSTATUS
LsapCrClientGetSessionKey(
    IN LSA_HANDLE ObjectHandle,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    );

NTSTATUS
LsapCrServerGetSessionKey(
    IN LSA_HANDLE ObjectHandle,
    OUT PLSAP_CR_CIPHER_KEY *SessionKey
    );

NTSTATUS
LsapCrEncryptValue(
    IN PLSAP_CR_CLEAR_VALUE ClearValue,
    IN PLSAP_CR_CIPHER_KEY CipherKey,
    OUT PLSAP_CR_CIPHER_VALUE *CipherValue
    );

NTSTATUS
LsapCrDecryptValue(
    IN PLSAP_CR_CIPHER_VALUE CipherValue,
    IN PLSAP_CR_CIPHER_KEY CipherKey,
    OUT PLSAP_CR_CLEAR_VALUE *ClearValue
    );

VOID
LsapCrFreeMemoryValue(
    IN PVOID MemoryValue
    );

VOID
LsapCrUnicodeToClearValue(
    IN PUNICODE_STRING UnicodeString,
    OUT PLSAP_CR_CLEAR_VALUE ClearValue
    );

VOID
LsapCrClearValueToUnicode(
    IN PLSAP_CR_CLEAR_VALUE ClearValue,
    OUT PUNICODE_STRING UnicodeString
    );

#define LsapCrRtlEncryptData(ClearData, CipherKey, CipherData)            \
    (                                                                     \
        RtlEncryptData(                                                   \
            (PCLEAR_DATA) ClearData,                                      \
            (PDATA_KEY) CipherKey,                                        \
            (PCYPHER_DATA) CipherData                                     \
            )                                                             \
    )


#define LsapCrRtlDecryptData(ClearData, CipherKey, CipherData)            \
    (                                                                     \
        RtlDecryptData(                                                   \
            (PCLEAR_DATA) ClearData,                                      \
            (PDATA_KEY) CipherKey,                                        \
            (PCYPHER_DATA) CipherData                                     \
            )                                                             \
    )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\inc\lsacomp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsacomp.h

Abstract:

    Local Security Authority - Main Include File for Client/Server Common
                               Definitions.


    This file contains #includes for each of the files that contain
    private LSA definitions that are common to the client/server side.

Author:

    Scott Birrell       (ScottBi)      February 19, 1992

Environment:

Revision History:

--*/

//
// The following come from \nt\public\sdk\inc
//

#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntregapi.h>
#include <rpc.h>
#include <msaudite.h>

//
// The following come from \nt\public\sdk\inc\crt
//

#include <stdlib.h>

//
// The following come from \nt\private\inc
//

#include <seopaque.h>
#include <ntrmlsa.h>
#include <ntrpcp.h>
#include <crypt.h>
#include <lsarpc.h>

//
// The following come from \nt\private\lsa\inc
//

#include <cr.h>
#include <lsaprtl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\inc\secur32p.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        secur32p.h
//
// Contents:    Private functions between secur32.dll and lsa
//
//
// History:     16 Dec 98  RichardW Created
//
//------------------------------------------------------------------------

#ifndef __SECUR32P_H__
#define __SECUR32P_H__

NTSTATUS
WINAPI
SecCacheSspiPackages(
    VOID
    );


BOOLEAN
WINAPI
SecpTranslateName(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT Desired,
    PWSTR TranslatedName,
    PULONG TranslatedNameSize
    );

BOOLEAN
WINAPI
SecpTranslateNameEx(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT *DesiredSelection,
    ULONG  DesiredCount,
    PWSTR **TranslatedNames
    );

VOID
SecpFreeMemory(
    IN PVOID p
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\inc\rpcutil.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    rpcutil.h

Abstract:

    This file contains prototypes for the bind and unbind functions that
    all net api stub functions will call.  It also includes the allocate
    and free routines used by the MIDL generated RPC stubs.

Author:

    Dan Lafferty danl 06-Feb-1991
    Scott Birrell   (ScottBi)         April 30, 1991 -  LSA Version

[Environment:]

    User Mode - Win32

Revision History:

--*/

#ifndef _RPCUTIL_
#define _RPCUTIL_

#ifndef RPC_NO_WINDOWS_H // Don't let rpc.h include windows.h
#define RPC_NO_WINDOWS_H
#endif // RPC_NO_WINDOWS_H

#include <rpc.h>

//
// Function Prototypes
//

void *
MIDL_user_allocate(
    IN ULONG NumBytes
    );

void
MIDL_user_free(
    IN PVOID MemPointer
    );


RPC_STATUS
LsapBindRpc(
    IN  PLSAPR_SERVER_NAME   ServerName,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

RPC_STATUS
LsapUnbindRpc(
    RPC_BINDING_HANDLE  BindingHandle
    );



#endif // _RPCUTIL_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\inc\lsaprtl.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaprtl.h

Abstract:

    Local Security Authority - Temporary Rtl Routine Definitions.

    This file contains definitions for routines used in the LSA that could
    be made into Rtl routines.  They have been written in general purpose
    form with this in mind - the only exception to thisa is that their names
    have Lsap prefixes to indicate that they are currently used only by the
    LSA.

    Scott Birrell       (ScottBi)      March 26, 1992

Environment:

Revision History:

--*/

// Options for LsapRtlAddPrivileges

#define  RTL_COMBINE_PRIVILEGE_ATTRIBUTES   ((ULONG) 0x00000001L)
#define  RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES ((ULONG) 0x00000002L)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

NTSTATUS
LsapRtlAddPrivileges(
    IN OUT PPRIVILEGE_SET * RunningPrivileges,
    IN OUT PULONG           MaxRunningPrivileges,
    IN PPRIVILEGE_SET       PrivilegesToAdd,
    IN ULONG                Options,
    OUT OPTIONAL BOOLEAN *  Changed
    );

NTSTATUS
LsapRtlRemovePrivileges(
    IN OUT PPRIVILEGE_SET ExistingPrivileges,
    IN PPRIVILEGE_SET PrivilegesToRemove
    );

PLUID_AND_ATTRIBUTES
LsapRtlGetPrivilege(
    IN PLUID_AND_ATTRIBUTES Privilege,
    IN PPRIVILEGE_SET Privileges
    );

NTSTATUS
LsapRtlLookupKnownPrivilegeValue(
    IN PSTRING PrivilegeName,
    OUT PLUID Value
    );

NTSTATUS
LsapRtlValidatePrivilegeSet(
    IN PPRIVILEGE_SET Privileges
    );

BOOLEAN
LsapRtlIsValidPrivilege(
    IN PLUID_AND_ATTRIBUTES Privilege
    );

BOOLEAN
LsapRtlPrefixSid(
    IN PSID PrefixSid,
    IN PSID Sid
    );

BOOLEAN
LsapRtlPrefixName(
    IN PUNICODE_STRING PrefixName,
    IN PUNICODE_STRING Name
    );

LONG
LsapRtlFindCharacterInUnicodeString(
    IN PUNICODE_STRING InputString,
    IN PUNICODE_STRING Character,
    IN BOOLEAN CaseInsensitive
    );

VOID
LsapRtlSplitNames(
    IN PUNICODE_STRING Names,
    IN ULONG Count,
    IN PUNICODE_STRING Separator,
    OUT PUNICODE_STRING PrefixNames,
    OUT PUNICODE_STRING SuffixNames
    );

VOID
LsapRtlSetSecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    );

VOID
LsapRtlQuerySecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PACCESS_MASK DesiredAccess
    );

NTSTATUS
LsapRtlSidToUnicodeRid(
    IN PSID Sid,
    OUT PUNICODE_STRING UnicodeRid
    );

NTSTATUS
LsapRtlPrivilegeSetToLuidAndAttributes(
    IN OPTIONAL PPRIVILEGE_SET PrivilegeSet,
    OUT PULONG PrivilegeCount,
    OUT PLUID_AND_ATTRIBUTES *LuidAndAttributes
    );

NTSTATUS
LsapRtlWellKnownPrivilegeCheck(
    IN PVOID ObjectHandle,
    IN BOOLEAN ImpersonateClient,
    IN ULONG PrivilegeId,
    IN OPTIONAL PCLIENT_ID ClientId
    );

NTSTATUS
LsapSplitSid(
    IN PSID AccountSid,
    IN OUT PSID *DomainSid,
    OUT ULONG *Rid
    );

#define LSAP_ENCRYPTED_AUTH_DATA_FILL 512

//
// This is the individual auth info information stored on, read from, and written to the object
//
typedef struct _LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF {

    ULONG AuthInfos;
    PLSAPR_AUTH_INFORMATION AuthenticationInformation;
    PLSAPR_AUTH_INFORMATION PreviousAuthenticationInformation;

} LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF, *PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF;

#define LsapDsAuthHalfFromAuthInfo( authinf, incoming )                           \
((incoming) == TRUE ?                                                             \
        (PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF) (authinf)   :                        \
        (authinf) == NULL ? NULL :                                                \
        (PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF)((PBYTE) (authinf) +                  \
                                    sizeof(LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF)))

NTSTATUS
LsapDsMarshalAuthInfoHalf(
    IN PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfo,
    OUT PULONG Length,
    OUT PBYTE *Buffer
    );

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\msprivs\makefile.inc ===
mspr_rev.rc : msprivs.rc msprivs2.h res\*


# include a dummy dependency so the makefile.inc file gets included
foo : mspr_rev.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\msprivs\msprivs2.h ===
#ifndef __MSPRIVS2_H_
#define __MSPRIVS2_H_

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    msprivs2.h

Abstract:

    String resource ids for privilege display names.

Author:

    kumarp   08-April-1999

Environment:

Revision History:

--*/

#define IDS_SeCreateTokenPrivilege          00
#define IDS_SeAssignPrimaryTokenPrivilege   01
#define IDS_SeLockMemoryPrivilege           02
#define IDS_SeIncreaseQuotaPrivilege        03
#define IDS_SeMachineAccountPrivilege       04
#define IDS_SeTcbPrivilege                  05
#define IDS_SeSecurityPrivilege             06
#define IDS_SeTakeOwnershipPrivilege        07
#define IDS_SeLoadDriverPrivilege           08
#define IDS_SeSystemProfilePrivilege        09
#define IDS_SeSystemtimePrivilege           10
#define IDS_SeProfileSingleProcessPrivilege 11
#define IDS_SeIncreaseBasePriorityPrivilege 12
#define IDS_SeCreatePagefilePrivilege       13
#define IDS_SeCreatePermanentPrivilege      14
#define IDS_SeBackupPrivilege               15
#define IDS_SeRestorePrivilege              16
#define IDS_SeShutdownPrivilege             17
#define IDS_SeDebugPrivilege                18
#define IDS_SeAuditPrivilege                19
#define IDS_SeSystemEnvironmentPrivilege    20
#define IDS_SeChangeNotifyPrivilege         21
#define IDS_SeRemoteShutdownPrivilege       22
// new in Windows 2000
#define IDS_SeUndockPrivilege               23
#define IDS_SeSyncAgentPrivilege            24
#define IDS_SeEnableDelegationPrivilege     25
// new in Windows 2000 + 1
#define IDS_SeManageVolumePrivilege         26

#endif // __MSPRIVS2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\inc\spmlpc.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPMLPC.H
//
// Contents:    Defines for the LPC to the SPMgr
//
//
// History:     2 Mar 94    MikeSw  Created
//
//------------------------------------------------------------------------

#ifndef __SPMLPC_H__
#define __SPMLPC_H__

//
// Pickup the LSA lpc messages for compatiblity
//
#pragma warning(disable:4200)

#include <efsstruc.h>
#include <aup.h>


#define SPM_PORTNAME    L"\\LsaAuthenticationPort"
#define SPM_EVENTNAME   L"\\SECURITY\\LSA_AUTHENTICATION_INITIALIZED"


#define SPM_AUTH_PKG_FLAG   0x00001000

//
// Buffers that will fit into the message are placed in there and the
// their pointers will be replaced with this value.  Since all buffers and
// strings are sent with their lengths, to unpack the data move pull out the
// buffers in the order they are listed in the API message.
//
// Since all buffers must be passed from VM, any address above 0x80000000
// will not be confused for an address
//

#define SEC_PACKED_BUFFER_VALUE (IntToPtr(0xFFFFFFFF))

//
// Max secbuffers allowed in a SecBufferDesc
//

#define MAX_SECBUFFERS 10

//
// This bit gets set in the SecurityMode word, indicating that the DLL
// is running in the LSA process.  The DLL will turn around and get the
// direct dispatch routine, and avoid the whole LPC issue
//

#define LSA_MODE_SAME_PROCESS                0x00010000

//
// This flag is added to the version information in a SecBufferDesc to
// indicate that the memory is already mapped to the LSA.
//

#define LSA_MEMORY_KERNEL_MAP               0x80000000
#define LSA_SECBUFFER_VERSION_MASK          0x0000FFFF



//
// Conditional type definition for Wow64 environment.  The LPC messages
// are kept "native" size, so pointers are full size.  The WOW environment
// will do the thunking.  LPC messages are defined with types that are
// always the correct size using these "aliases".
//

#ifdef BUILD_WOW64

#pragma message("Building for WOW64")

#define ALIGN_WOW64     __declspec(align(8))

#define POINTER_FORMAT  "%I64X"

#if 0
typedef WCHAR * __ptr64 PWSTR_LPC ;
typedef VOID * __ptr64 PVOID_LPC ;
#else
typedef ULONGLONG PWSTR_LPC ;
typedef ULONGLONG PVOID_LPC ;
typedef ULONGLONG PSID_LPC ;
#endif

typedef struct _SECURITY_STRING_WOW64 {
    USHORT      Length ;
    USHORT      MaximumLength ;
    PWSTR_LPC   Buffer ;
} SECURITY_STRING_WOW64, * PSECURITY_STRING_WOW64 ;

typedef struct _SEC_HANDLE_WOW64 {
    PVOID_LPC dwLower ;
    PVOID_LPC dwUpper ;
} SEC_HANDLE_WOW64, * PSEC_HANDLE_WOW64 ;

typedef struct _SEC_BUFFER_WOW64 {
    unsigned long   cbBuffer ;
    unsigned long   BufferType ;
    PVOID_LPC  pvBuffer ;
} SEC_BUFFER_WOW64, * PSEC_BUFFER_WOW64 ;

typedef struct _SEC_BUFFER_DESC_WOW64 {
    unsigned long   ulVersion ;
    unsigned long   cBuffers ;
    PVOID_LPC  pBuffers ;
} SEC_BUFFER_DESC_WOW64, * PSEC_BUFFER_DESC_WOW64 ;

typedef struct _SECPKG_INFO_WOW64 {
    ULONG        fCapabilities;
    USHORT       wVersion;
    USHORT       wRPCID;
    ULONG        cbMaxToken;
    PWSTR_LPC    Name;
    PWSTR_LPC    Comment;
}
SECPKG_INFO_WOW64, * PSECPKG_INFO_WOW64;

typedef struct _SECPKGCONTEXT_NEGOTIATIONINFOWOW64
{
    PVOID_LPC           pPackageInfo64;
    ULONG               NegotiationState;
}
SECPKGCONTEXT_NEGOTIATIONINFOWOW64, *PSECPKGCONTEXT_NEGOTIATIONINFOWOW64;

typedef struct _SECURITY_USER_DATA_WOW64 {
    SECURITY_STRING_WOW64 UserName;
    SECURITY_STRING_WOW64 LogonDomainName;
    SECURITY_STRING_WOW64 LogonServer;
    PSID_LPC              pSid;
}
SECURITY_USER_DATA_WOW64, * PSECURITY_USER_DATA_WOW64;

typedef SECURITY_STRING_WOW64   SECURITY_STRING_LPC ;
typedef SEC_HANDLE_WOW64    SEC_HANDLE_LPC ;
typedef SEC_BUFFER_DESC_WOW64   SEC_BUFFER_DESC_LPC ;
typedef SEC_BUFFER_WOW64        SEC_BUFFER_LPC ;
typedef PVOID_LPC               LSA_SEC_HANDLE_LPC ;

#define SecpSecurityStringToLpc( L, S ) \
            (L)->Length = (S)->Length ;     \
            (L)->MaximumLength = (S)->MaximumLength ; \
            (L)->Buffer = (PWSTR_LPC) ((S)->Buffer) ;

#define SecpLpcStringToSecurityString( S, L ) \
            (S)->Length = (L)->Length ; \
            (S)->MaximumLength = (L)->MaximumLength ; \
            (S)->Buffer = (PWSTR) ( (L)->Buffer ); \

#define SecpSecBufferToLpc( L, S )\
            (L)->cbBuffer = (S)->cbBuffer ; \
            (L)->BufferType = (S)->BufferType ; \
            (L)->pvBuffer = (PVOID_LPC) (S)->pvBuffer ;

#define SecpLpcBufferToSecBuffer( S, L ) \
            (S)->cbBuffer = (L)->cbBuffer ; \
            (S)->BufferType = (L)->BufferType ; \
            (S)->pvBuffer = (PVOID) (L)->pvBuffer ;

#define SecpSecBufferDescToLpc( L, S )\
            (L)->ulVersion = (S)->ulVersion ; \
            (L)->cBuffers = (S)->cBuffers ; \
            (L)->pBuffers = (PVOID_LPC) (S)->pBuffers ;

#define SecpLpcBufferDescToSecBufferDesc( S, L ) \
            (S)->ulVersion = (L)->ulVersion ; \
            (S)->cBuffers = (L)->cBuffers ; \
            (S)->pBuffers = (PSecBuffer) (L)->pBuffers ;

#define SecpSecPkgInfoToLpc( L, S ) \
            (L)->fCapabilities = (S)->fCapabilities ; \
            (L)->wVersion = (S)->wVersion ; \
            (L)->wRPCID = (S)->wRPCID ; \
            (L)->cbMaxToken = (S)->cbMaxToken ; \
            (L)->Name = (PWSTR_LPC) (S)->Name ; \
            (L)->Comment = (PWSTR_LPC) (S)->Comment ;

#define SecpLpcPkgInfoToSecPkgInfo( S, L ) \
            (S)->fCapabilities = (L)->fCapabilities ; \
            (S)->wVersion = (L)->wVersion ; \
            (S)->wRPCID = (L)->wRPCID ; \
            (S)->cbMaxToken = (L)->cbMaxToken ; \
            (S)->Name = (SEC_WCHAR *) (L)->Name ; \
            (S)->Comment = (SEC_WCHAR *) (L)->Comment ;

#else

#define ALIGN_WOW64     

#define POINTER_FORMAT  "%p"

typedef SECURITY_STRING     SECURITY_STRING_LPC ;
typedef PVOID               PVOID_LPC ;
typedef SecHandle           SEC_HANDLE_LPC ;
typedef SecBufferDesc       SEC_BUFFER_DESC_LPC ;
typedef SecBuffer           SEC_BUFFER_LPC ;
typedef PWSTR               PWSTR_LPC ;
typedef LSA_SEC_HANDLE      LSA_SEC_HANDLE_LPC ;

#define SecpSecurityStringToLpc( L, S ) \
                *(L) = *(S) ;

#define SecpLpcStringToSecurityString( S, L ) \
                *(S) = *(L) ;

#define SecpSecBufferToLpc( L, S ) \
                *(L) = *(S) ;

#define SecpLpcBufferToSecBuffer( S, L ) \
                *(S) = *(L) ;

#define SecpSecBufferDescToLpc( L, S ) \
                *(L) = *(S) ;

#define SecpLpcBufferDescToSecBufferDesc( S, L ) \
                *(S) = *(L) ;
#endif

typedef SEC_HANDLE_LPC  CRED_HANDLE_LPC, * PCRED_HANDLE_LPC ;
typedef SEC_HANDLE_LPC  CONTEXT_HANDLE_LPC, * PCONTEXT_HANDLE_LPC ;
typedef SEC_HANDLE_LPC * PSEC_HANDLE_LPC ;
typedef SEC_BUFFER_LPC  * PSEC_BUFFER_LPC ;

typedef struct _SPMConnectReq {
    ULONG       Flags;
} SPMConnectReq, * PSPMConnectReq;

typedef struct _SPMConnectReply {
    ULONG       cPackages;
    ULONG       dwSessionID;
    PVOID       pvFastDispatch;
} SPMConnectReply, * PSPMConnectReply;

typedef struct _SPMConnect {
    ULONG       dwVersion;
    ULONG       dwMessageType;
    union {
        SPMConnectReq   Request;
        SPMConnectReply Reply;
    } ConnectData;
} SPMConnect, * PSPMConnect;



//
// this structures is used with NtAcceptPort, etc., which puts the data
// following the PORT_MESSAGE structure
//

typedef struct _SPMConnectMessage {
    PORT_MESSAGE        Message;
    SPMConnect          Connect;
} SPMConnectMessage, *PSPMConnectMessage;

#define SPM_MSG_CONNECTREQ      1
#define SPM_MSG_CONNECTREP      2


//
// Connection specific data types
//


//
// The following are message structures for internal routines, such as
// synchronization and state messages
//
#define PACKAGEINFO_THUNKS  16

typedef struct _SEC_PACKAGE_BINDING_INFO_LPC {
    SECURITY_STRING_LPC PackageName;
    SECURITY_STRING_LPC Comment;
    SECURITY_STRING_LPC ModuleName;
    ULONG               PackageIndex;
    ULONG               fCapabilities;
    ULONG               Flags;
    ULONG               RpcId;
    ULONG               Version;
    ULONG               TokenSize;
    ULONG               ContextThunksCount ;
    ULONG               ContextThunks[ PACKAGEINFO_THUNKS ] ;
} SEC_PACKAGE_BINDING_INFO_LPC, * PSEC_PACKAGE_BINDING_INFO_LPC ;

#ifdef BUILD_WOW64

typedef struct _SEC_PACKAGE_BINDING_INFO {
    SECURITY_STRING     PackageName;
    SECURITY_STRING     Comment;
    SECURITY_STRING     ModuleName;
    ULONG               PackageIndex;
    ULONG               fCapabilities;
    ULONG               Flags;
    ULONG               RpcId;
    ULONG               Version;
    ULONG               TokenSize;
    ULONG               ContextThunksCount ;
    ULONG               ContextThunks[ PACKAGEINFO_THUNKS ] ;
} SEC_PACKAGE_BINDING_INFO, * PSEC_PACKAGE_BINDING_INFO ;

#else

typedef SEC_PACKAGE_BINDING_INFO_LPC SEC_PACKAGE_BINDING_INFO ;
typedef SEC_PACKAGE_BINDING_INFO_LPC * PSEC_PACKAGE_BINDING_INFO ;

#endif

#define PACKAGEINFO_BUILTIN 0x00000001
#define PACKAGEINFO_AUTHPKG 0x00000002
#define PACKAGEINFO_SIGNED  0x00000004


typedef struct _SPMGetBindingAPI {
    LSA_SEC_HANDLE_LPC ulPackageId;
    SEC_PACKAGE_BINDING_INFO_LPC BindingInfo;
} SPMGetBindingAPI;


//
// Internal SetSession API.
// not supported in Wow64
//

typedef struct _SPMSetSession {
    ULONG               Request;
    ULONG_PTR           Argument ;
    ULONG_PTR           Response;
    PVOID               ResponsePtr;
    PVOID               Extra ;
} SPMSetSessionAPI;

#define SETSESSION_GET_STATUS       0x00000001
#define SETSESSION_ADD_WORKQUEUE    0x00000002
#define SETSESSION_REMOVE_WORKQUEUE 0x00000003
#define SETSESSION_GET_DISPATCH     0x00000004


typedef struct _SPMFindPackageAPI {
    SECURITY_STRING_LPC ssPackageName;
    LSA_SEC_HANDLE_LPC  ulPackageId;
} SPMFindPackageAPI;


// The following are message structures.  Not surprisingly, they look a
// lot like the API signatures.  Keep that in mind.



// EnumeratePackages API

typedef struct _SPMEnumPackagesAPI {
    ULONG       cPackages;          // OUT
    PSecPkgInfo pPackages;          // OUT
} SPMEnumPackagesAPI;


//
// Credential APIs
//


// AcquireCredentialsHandle API

typedef struct _SPMAcquireCredsAPI {
    SECURITY_STRING_LPC ssPrincipal;       // IN
    SECURITY_STRING_LPC ssSecPackage;      // IN
    ULONG               fCredentialUse;     // IN
    LUID                LogonID;            // IN
    PVOID_LPC           pvAuthData;         // IN
    PVOID_LPC           pvGetKeyFn;         // IN
    PVOID_LPC           ulGetKeyArgument;   // IN
    CRED_HANDLE_LPC     hCredential;        // OUT
    TimeStamp           tsExpiry;           // OUT
    SEC_BUFFER_LPC      AuthData ;          // IN
} SPMAcquireCredsAPI;


// EstablishCredentials API
// not supported in Wow64

typedef struct _SPMEstablishCredsAPI {
    SECURITY_STRING Name;           // IN
    SECURITY_STRING Package;        // IN
    ULONG           cbKey;          // IN
    PUCHAR          pbKey;          // IN
    CredHandle      hCredentials;   // OUT
    TimeStamp       tsExpiry;       // OUT
} SPMEstablishCredsAPI;

// FreeCredentialsHandle API

typedef struct _SPMFreeCredHandleAPI {
    CRED_HANDLE_LPC hCredential;
} SPMFreeCredHandleAPI;


//
// Context APIs
//

// InitializeSecurityContext API

typedef struct _SPMInitSecContextAPI {
    CRED_HANDLE_LPC     hCredential;    // IN
    CONTEXT_HANDLE_LPC  hContext;       // IN
    SECURITY_STRING_LPC ssTarget;       // IN
    ULONG               fContextReq;    // IN
    ULONG               dwReserved1;    // IN
    ULONG               TargetDataRep;  // IN
    SEC_BUFFER_DESC_LPC sbdInput;       // IN
    ULONG               dwReserved2;    // IN
    CONTEXT_HANDLE_LPC  hNewContext;    // OUT
    SEC_BUFFER_DESC_LPC sbdOutput;      // IN OUT
    ULONG               fContextAttr;   // OUT
    TimeStamp           tsExpiry;       // OUT
    BOOLEAN             MappedContext;  // OUT
    SEC_BUFFER_LPC      ContextData;    // OUT
    SEC_BUFFER_LPC      sbData[0];      // IN
} SPMInitContextAPI;



// AcceptSecurityContext API

typedef struct _SPMAcceptContextAPI {
    CRED_HANDLE_LPC     hCredential;    // IN
    CONTEXT_HANDLE_LPC  hContext;       // IN
    SEC_BUFFER_DESC_LPC sbdInput;       // IN
    ULONG               fContextReq;    // IN
    ULONG               TargetDataRep;  // IN
    CONTEXT_HANDLE_LPC  hNewContext;    // OUT
    SEC_BUFFER_DESC_LPC sbdOutput;      // IN OUT
    ULONG               fContextAttr;   // OUT
    TimeStamp           tsExpiry;       // OUT
    BOOLEAN             MappedContext;  // OUT
    SEC_BUFFER_LPC      ContextData;    // OUT
    SEC_BUFFER_LPC      sbData[0];      // IN OUT
} SPMAcceptContextAPI;

//
// ApplyControlToken API
//

typedef struct _SPMApplyTokenAPI {
    CONTEXT_HANDLE_LPC  hContext ;
    SEC_BUFFER_DESC_LPC sbdInput ;
    SEC_BUFFER_LPC      sbInputBuffer[ MAX_SECBUFFERS ];
} SPMApplyTokenAPI;

// DeleteContext API

typedef struct _SPMDeleteContextAPI {
    CONTEXT_HANDLE_LPC  hContext;           // IN - Context to delete
} SPMDeleteContextAPI;



//
// Miscelanneous, extension APIs
//


// QueryPackage API

typedef struct _SPMQueryPackageAPI {
    SECURITY_STRING_LPC ssPackageName;
    PSecPkgInfo         pPackageInfo;
} SPMQueryPackageAPI;



// GetSecurityUserInfo
// not supported in Wow64

typedef struct _SPMGetUserInfoAPI {
    LUID                LogonId;        // IN
    ULONG               fFlags;         // IN
    PSecurityUserData   pUserInfo;      // OUT
} SPMGetUserInfoAPI;


//
// Credentials APIs.  Not used.
//

typedef struct _SPMGetCredsAPI {
    CredHandle      hCredentials;       // IN
    SecBuffer       Credentials;        // OUT
} SPMGetCredsAPI;

typedef struct _SPMSaveCredsAPI {
    CredHandle      hCredentials;       // IN
    SecBuffer       Credentials;        // IN
} SPMSaveCredsAPI;

typedef struct _SPMDeleteCredsAPI {
    CredHandle      hCredentials;       // IN
    SecBuffer       Key;                // IN
} SPMDeleteCredsAPI;


typedef struct _SPMQueryCredAttributesAPI {
    CRED_HANDLE_LPC hCredentials;
    ULONG           ulAttribute;
    PVOID_LPC       pBuffer;
    ULONG           Allocs ;
    PVOID_LPC       Buffers[1];
} SPMQueryCredAttributesAPI;


typedef struct _SPMAddPackageAPI {
    SECURITY_STRING_LPC Package;
    ULONG               OptionsFlags;
} SPMAddPackageAPI ;

typedef struct _SPMDeletePackageAPI {
    SECURITY_STRING_LPC Package;
} SPMDeletePackageAPI ;

typedef struct _SPMQueryContextAttrAPI {
    CONTEXT_HANDLE_LPC hContext ;
    ULONG              ulAttribute ;
    PVOID_LPC          pBuffer ;
    ULONG              Allocs ;
    PVOID_LPC          Buffers[1];
} SPMQueryContextAttrAPI ;

typedef struct _SPMSetContextAttrAPI {
    CONTEXT_HANDLE_LPC hContext ;
    ULONG              ulAttribute ;
    PVOID_LPC          pBuffer ;
    ULONG              cbBuffer;
} SPMSetContextAttrAPI ;


//
// Kernel mode EFS API.  None of these are Wow64
//

typedef struct _SPMEfsGenerateKeyAPI {
    PVOID           EfsStream;
    PVOID           DirectoryEfsStream;
    ULONG           DirectoryEfsStreamLength;
    PVOID           Fek;
    ULONG           BufferLength;
    PVOID           BufferBase;
} SPMEfsGenerateKeyAPI;

typedef struct _SPMEfsGenerateDirEfsAPI {
    PVOID       DirectoryEfsStream;
    ULONG       DirectoryEfsStreamLength;
    PVOID       EfsStream;
    PVOID       BufferBase;
    ULONG       BufferLength;
} SPMEfsGenerateDirEfsAPI;

typedef struct _SPMEfsDecryptFekAPI {
    PVOID       Fek;
    PVOID       EfsStream;
    ULONG       EfsStreamLength;
    ULONG       OpenType;
    PVOID       NewEfs;
    PVOID       BufferBase;
    ULONG       BufferLength;
} SPMEfsDecryptFekAPI;

typedef struct  _SPMEfsGenerateSessionKeyAPI {
    PVOID       InitDataExg;
} SPMEfsGenerateSessionKeyAPI;



//
// Usermode policy change notifications
//
typedef struct _SPMLsaPolicyChangeNotifyAPI {
    ULONG Options;
    BOOLEAN Register;
    HANDLE EventHandle;
    POLICY_NOTIFICATION_INFORMATION_CLASS NotifyInfoClass;
} SPMLsaPolicyChangeNotifyAPI;


typedef struct _SPMCallbackAPI {
    ULONG           Type;
    PVOID_LPC       CallbackFunction;
    PVOID_LPC       Argument1;
    PVOID_LPC       Argument2;
    SEC_BUFFER_LPC  Input ;
    SEC_BUFFER_LPC  Output ;
} SPMCallbackAPI ;

#define SPM_CALLBACK_INTERNAL   0x00000001  // Handled by the security DLL
#define SPM_CALLBACK_GETKEY     0x00000002  // Getkey function being called
#define SPM_CALLBACK_PACKAGE    0x00000003  // Package function
#define SPM_CALLBACK_EXPORT     0x00000004  // Ptr to string

//
// Fast name lookup
//

typedef struct _SPMGetUserNameXAPI {
    ULONG               Options ;
    SECURITY_STRING_LPC Name;
} SPMGetUserNameXAPI ;

#define SPM_NAME_OPTION_MASK        0xFFFF0000

#define SPM_NAME_OPTION_NT4_ONLY    0x00010000  // GetUserNameX only, not Ex
#define SPM_NAME_OPTION_FLUSH       0x00020000

//
// AddCredential API.
//

typedef struct _SPMAddCredential {
    CRED_HANDLE_LPC     hCredentials ;
    SECURITY_STRING_LPC ssPrincipal;       // IN
    SECURITY_STRING_LPC ssSecPackage;      // IN
    ULONG               fCredentialUse;     // IN
    LUID                LogonID;            // IN
    PVOID_LPC           pvAuthData;         // IN
    PVOID_LPC           pvGetKeyFn;         // IN
    PVOID_LPC           ulGetKeyArgument;   // IN
    TimeStamp           tsExpiry;           // OUT
} SPMAddCredentialAPI ;

typedef struct _SPMEnumLogonSession {
    PVOID_LPC       LogonSessionList ;      // OUT
    ULONG           LogonSessionCount ;     // OUT
} SPMEnumLogonSessionAPI ;

typedef struct _SPMGetLogonSessionData {
    LUID        LogonId ;                       // IN
    PVOID_LPC   LogonSessionInfo ;              // OUT
} SPMGetLogonSessionDataAPI ;

//
// Internal codes:
//

#define SPM_CALLBACK_ADDRESS_CHECK  1       // Setting up shared buffer
#define SPM_CALLBACK_SHUTDOWN       2       // Inproc shutdown notification


//
// SID translation APIs (for kmode callers, primarily)
//

typedef struct _SPMLookupAccountSidX {
    PVOID_LPC           Sid;        // IN
    SECURITY_STRING_LPC Name ;      // OUT
    SECURITY_STRING_LPC Domain ;    // OUT
    SID_NAME_USE NameUse ;          // OUT
} SPMLookupAccountSidXAPI ;

typedef struct _SPMLookupAccountNameX {
    SECURITY_STRING_LPC Name ;      // IN
    SECURITY_STRING_LPC Domain ;    // OUT
    PVOID_LPC           Sid ;       // OUT
    SID_NAME_USE        NameUse ;   // OUT
} SPMLookupAccountNameXAPI ;


// this is the wrapper for all messages.

typedef union {
    SPMGetBindingAPI            GetBinding;
    SPMSetSessionAPI            SetSession;
    SPMFindPackageAPI           FindPackage;
    SPMEnumPackagesAPI          EnumPackages;
    SPMAcquireCredsAPI          AcquireCreds;
    SPMEstablishCredsAPI        EstablishCreds;
    SPMFreeCredHandleAPI        FreeCredHandle;
    SPMInitContextAPI           InitContext;
    SPMAcceptContextAPI         AcceptContext;
    SPMApplyTokenAPI            ApplyToken;
    SPMDeleteContextAPI         DeleteContext;
    SPMQueryPackageAPI          QueryPackage;
    SPMGetUserInfoAPI           GetUserInfo;
    SPMGetCredsAPI              GetCreds;
    SPMSaveCredsAPI             SaveCreds;
    SPMDeleteCredsAPI           DeleteCreds;
    SPMQueryCredAttributesAPI   QueryCredAttributes;
    SPMAddPackageAPI            AddPackage;
    SPMDeletePackageAPI         DeletePackage ;
    SPMEfsGenerateKeyAPI        EfsGenerateKey;
    SPMEfsGenerateDirEfsAPI     EfsGenerateDirEfs;
    SPMEfsDecryptFekAPI         EfsDecryptFek;
    SPMEfsGenerateSessionKeyAPI EfsGenerateSessionKey;
    SPMQueryContextAttrAPI      QueryContextAttr ;
    SPMCallbackAPI              Callback ;
    SPMLsaPolicyChangeNotifyAPI LsaPolicyChangeNotify;
    SPMGetUserNameXAPI          GetUserNameX ;
    SPMAddCredentialAPI         AddCredential ;
    SPMEnumLogonSessionAPI      EnumLogonSession ;
    SPMGetLogonSessionDataAPI   GetLogonSessionData ;
    SPMSetContextAttrAPI        SetContextAttr ;
    SPMLookupAccountSidXAPI     LookupAccountSidX ;
    SPMLookupAccountNameXAPI    LookupAccountNameX ;
} SPM_API;

//
// This extends the range of LSA functions with the SPM functions
//

typedef enum _SPM_API_NUMBER {
    SPMAPI_GetBinding = (LsapAuMaxApiNumber + 1),
    SPMAPI_SetSession,
    SPMAPI_FindPackage,
    SPMAPI_EnumPackages,
    SPMAPI_AcquireCreds,
    SPMAPI_EstablishCreds,
    SPMAPI_FreeCredHandle,
    SPMAPI_InitContext,
    SPMAPI_AcceptContext,
    SPMAPI_ApplyToken,
    SPMAPI_DeleteContext,
    SPMAPI_QueryPackage,
    SPMAPI_GetUserInfo,
    SPMAPI_GetCreds,
    SPMAPI_SaveCreds,
    SPMAPI_DeleteCreds,
    SPMAPI_QueryCredAttributes,
    SPMAPI_AddPackage,
    SPMAPI_DeletePackage,
    SPMAPI_EfsGenerateKey,
    SPMAPI_EfsGenerateDirEfs,
    SPMAPI_EfsDecryptFek,
    SPMAPI_EfsGenerateSessionKey,
    SPMAPI_Callback,
    SPMAPI_QueryContextAttr,
    SPMAPI_LsaPolicyChangeNotify,
    SPMAPI_GetUserNameX,
    SPMAPI_AddCredential,
    SPMAPI_EnumLogonSession,
    SPMAPI_GetLogonSessionData,
    SPMAPI_SetContextAttr,
    SPMAPI_LookupAccountNameX,
    SPMAPI_LookupAccountSidX,
    SPMAPI_MaxApiNumber
} SPM_API_NUMBER, *PSPM_API_NUMBER;

//
// These are the valid flags to set in the fAPI field
//

#define SPMAPI_FLAG_ERROR_RET   0x0001  // Indicates an error return
#define SPMAPI_FLAG_MEMORY      0x0002  // Memory was allocated in client
#define SPMAPI_FLAG_PREPACK     0x0004  // Data packed in bData field
#define SPMAPI_FLAG_GETSTATE    0x0008  // driver should call GetState

#define SPMAPI_FLAG_ANSI_CALL   0x0010  // Called via ANSI stub
#define SPMAPI_FLAG_HANDLE_CHG  0x0020  // A handle was changed
#define SPMAPI_FLAG_CALLBACK    0x0040  // Callback to calling process
#define SPMAPI_FLAG_ALLOCS      0x0080  // VM Allocs were placed in prepack
#define SPMAPI_FLAG_EXEC_NOW    0x0100  // Execute in LPC thread
#define SPMAPI_FLAG_WIN32_ERROR 0x0200  // Status is a win32 error
#define SPMAPI_FLAG_KMAP_MEM    0x0400  // Call contains buffers in the kmap

//
// These are the state flags (currently unused in client)
//

#define SPMSTATE_PRIVACY_OK     0x00000010  // Privacy support is enabled
#define SPMSTATE_OLDLSA_OK      0x00000020  // Old LSA packages present
#define SPMSTATE_FAKE_MSV       0x00000040  // Faked MSV1_0 package
#define SPMSTATE_SAME_PROC      0x00000080  // Security DLL is operating in LSA process
#define SPMSTATE_DISABLE_POPUPS 0x00000100  // Disable popups

//
// Compatibility flag mask:
//

#define SPMSTATE_LSAMODE_MASK   0x0000000F  // Gets LSA_MODE bits for compat.

//
// This structure contains all the information needed for SPM api's
//

typedef struct _SPMLPCAPI {
    USHORT          fAPI ;
    USHORT          VMOffset ;
    PVOID_LPC       ContextPointer ;
    SPM_API         API;
} SPMLPCAPI, * PSPMLPCAPI;

//
// This union contains all the info for LSA api's
//

typedef union {
    LSAP_LOOKUP_PACKAGE_ARGS LookupPackage;
    LSAP_LOGON_USER_ARGS LogonUser;
    LSAP_CALL_PACKAGE_ARGS CallPackage;
} LSA_API;


//
// This union contains both SPM and LSA api's
//

typedef union _SPM_LSA_ARGUMENTS {
    LSA_API LsaArguments;
    SPMLPCAPI SpmArguments;
} SPM_LSA_ARGUMENTS, *PSPM_LSA_ARGUMENTS;

//
// For performance, some APIs will attempt to pack small parameters in the
// message being sent to the SPM, rather than have the SPM read it out of
// their memory.  So, this value defines how much data can be stuck in the
// message.
//
// Two items are defined here.  One, CBAPIHDR, is the size of everything
// in the message except the packed data.  The other, CBPREPACK, is the
// left over space.  I subtract 4 at the end to avoid potential boundary
// problems with an LPC message.
//

#define CBAPIHDR    (sizeof(PORT_MESSAGE) + sizeof(ULONG) + sizeof(HRESULT) + \
                    sizeof(SPM_LSA_ARGUMENTS))

#define CBPREPACK   (PORT_MAXIMUM_MESSAGE_LENGTH - CBAPIHDR - sizeof( PVOID_LPC ))

#define NUM_SECBUFFERS  ( CBPREPACK / sizeof(SecBuffer) )

//
// This structure is sent over during an API call rather than a connect
// message
//

typedef struct _SPM_API_MESSAGE {
    SPM_API_NUMBER      dwAPI;
    HRESULT             scRet;
    SPM_LSA_ARGUMENTS   Args;
    UCHAR               bData[CBPREPACK];
} SPM_API_MESSAGE, *PSPM_API_MESSAGE;

#define SecBaseMessageSize( Api ) \
    ( sizeof( SPM_API_NUMBER ) + sizeof( HRESULT ) + \
      ( sizeof( SPM_LSA_ARGUMENTS ) - sizeof( SPM_API ) + \
      sizeof( SPM##Api##API ) ) )


//
// This is the actual message sent over LPC - it contains both the
// connection request information and the api message
//


typedef struct _SPM_LPC_MESSAGE {
    PORT_MESSAGE    pmMessage;
    union {
        LSAP_AU_REGISTER_CONNECT_INFO ConnectionRequest;
        SPM_API_MESSAGE ApiMessage;
    };
} SPM_LPC_MESSAGE, *PSPM_LPC_MESSAGE;


//
// Macros to help prepare LPC messages
//

#ifdef SECURITY_USERMODE
#define PREPARE_MESSAGE_EX( Message, Api, Flags, Context ) \
    RtlZeroMemory( &Message, sizeof( SPM_LSA_ARGUMENTS ) + sizeof( PORT_MESSAGE )  ); \
    (Message).pmMessage.u1.s1.DataLength =  \
            ( sizeof( SPM_API_NUMBER ) + sizeof( HRESULT ) + \
              ( sizeof( SPM_LSA_ARGUMENTS ) - sizeof( SPM_API ) + \
                sizeof( SPM##Api##API ) ) ); \
    (Message).pmMessage.u1.s1.TotalLength = (Message).pmMessage.u1.s1.DataLength + \
               sizeof( PORT_MESSAGE ); \
    (Message).pmMessage.u2.ZeroInit = 0L; \
    (Message).ApiMessage.scRet = 0L; \
    (Message).ApiMessage.dwAPI = SPMAPI_##Api ; \
    (Message).ApiMessage.Args.SpmArguments.fAPI = (USHORT)(Flags); \
    (Message).ApiMessage.Args.SpmArguments.ContextPointer = Context ;
#else
#define PREPARE_MESSAGE_EX( Message, Api, Flags, Context ) \
    RtlZeroMemory( &Message, sizeof( SPM_LSA_ARGUMENTS ) + sizeof( PORT_MESSAGE )  ); \
    (Message).pmMessage.u1.s1.DataLength =  \
            ( sizeof( SPM_API_NUMBER ) + sizeof( HRESULT ) + \
              ( sizeof( SPM_LSA_ARGUMENTS ) - sizeof( SPM_API ) + \
                sizeof( SPM##Api##API ) ) );  \
    (Message).pmMessage.u1.s1.TotalLength = (Message).pmMessage.u1.s1.DataLength + \
               sizeof( PORT_MESSAGE ); \
    (Message).pmMessage.u2.ZeroInit = 0L; \
    (Message).ApiMessage.scRet = 0L; \
    (Message).ApiMessage.dwAPI = SPMAPI_##Api ; \
    (Message).ApiMessage.Args.SpmArguments.fAPI = (USHORT)(Flags); \
    (Message).ApiMessage.Args.SpmArguments.ContextPointer = Context ; \
    (Message).pmMessage.u2.s2.Type |= LPC_KERNELMODE_MESSAGE; 
#endif

#define PREPARE_MESSAGE(Message, Api) PREPARE_MESSAGE_EX( Message, Api, 0, 0 )

#define LPC_MESSAGE_ARGS( Message, Api )\
    ( & (Message).ApiMessage.Args.SpmArguments.API.Api )

#define LPC_MESSAGE_ARGSP( Message, Api )\
    ( & (Message)->ApiMessage.Args.SpmArguments.API.Api )
    
#define DECLARE_ARGS( Args, Message, Api )\
    SPM##Api##API * Args = & (Message).ApiMessage.Args.SpmArguments.API.Api
    
#define DECLARE_ARGSP( Args, Message, Api)\
    SPM##Api##API * Args = & (Message)->ApiMessage.Args.SpmArguments.API.Api
    
#define PREPACK_START   FIELD_OFFSET( SPM_LPC_MESSAGE, ApiMessage.bData )

#define LPC_DATA_LENGTH( Length )\
            (USHORT) ((PREPACK_START) + Length - sizeof( PORT_MESSAGE ) )
            
#define LPC_TOTAL_LENGTH( Length )\
            (USHORT) ((PREPACK_START) + Length )

//
// Prototype for the direct dispatch function:
//

typedef NTSTATUS (SEC_ENTRY LSA_DISPATCH_FN)(
    PSPM_LPC_MESSAGE );

typedef LSA_DISPATCH_FN * PLSA_DISPATCH_FN;


//
// structs used to manage memory shared between the LSA and KSEC driver
//

#define LSA_MAX_KMAP_SIZE   65535


//
// This structure describes a chunk of pool that has been copied into
// a kmap buffer.  The original pool address and the location in the 
// kmap are here, as is the size of the chunk.  On IA64, this ends up
// with a wasted 32bit padding area
//
typedef struct _KSEC_LSA_POOL_MAP {
    PVOID_LPC   Pool ;                  // Region of pool
    USHORT      Offset ;                // Offset into kmap
    USHORT      Size ;                  // size of chunk
} KSEC_LSA_POOL_MAP, PKSEC_LSA_POOL_MAP ;

#define KSEC_LSA_MAX_MAPS   4

typedef struct _KSEC_LSA_MEMORY_HEADER {
    ULONG   Size ;          // Size of the reserved region
    ULONG   Commit ;        // Size of the committed space
    ULONG   Consumed ;      // Amount consumed
    USHORT  Preserve ;      // Size of the area to keep for ksec
    USHORT  MapCount ;      // number of entries in array
    KSEC_LSA_POOL_MAP   PoolMap[ KSEC_LSA_MAX_MAPS ];
} KSEC_LSA_MEMORY_HEADER, * PKSEC_LSA_MEMORY_HEADER ;

//
// This buffer type is used to indicate the header in the
// message from the driver to the LSA.  It is ignored if
// the call did not originate from kernel mode
//

#define SECBUFFER_KMAP_HEADER   0x00008001

#pragma warning(default:4200)

#endif // __SPMLPC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        Credapi.C
//
// Contents:    Credential API stubs for LPC
//
//
// History:
//
//------------------------------------------------------------------------

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, SecpAcquireCredentialsHandle)
#pragma alloc_text(PAGE, SecpFreeCredentialsHandle)
#pragma alloc_text(PAGE, SecpAddCredentials )
#pragma alloc_text(PAGE, SecpQueryCredentialsAttributes)
#endif




//+-------------------------------------------------------------------------
//
//  Function:   SecpAcquireCredentialsHandle
//
//  Synopsis:   LPC client stub for AcquireCredentialsHandle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
SecpAcquireCredentialsHandle(   
    PVOID_LPC           Context,
    PSECURITY_STRING    pssPrincipalName,
    PSECURITY_STRING    pssPackageName,
    ULONG               fCredentialUse,
    PLUID               pLogonID,
    PVOID               pvAuthData,
    SEC_GET_KEY_FN      pvGetKeyFn,
    PVOID               ulGetKeyArgument,
    PCRED_HANDLE_LPC    phCredentials,
    PTimeStamp          ptsExpiry, OPTIONAL
    PULONG              Flags)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, AcquireCreds );
    ULONG           cbPrepackAvail = CBPREPACK;
    PUCHAR          Where;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"Entered AcquireCredHandle\n"));


    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    PREPARE_MESSAGE_EX(ApiBuffer, AcquireCreds, *Flags, Context );

    Where = ApiBuffer.ApiMessage.bData;

    if (pssPrincipalName)
    {
        DebugLog((DEB_TRACE_CALL,"    Principal = %wZ \n", pssPrincipalName));
        
        SecpSecurityStringToLpc( (&Args->ssPrincipal), pssPrincipalName );
        // Args->ssPrincipal     = *pssPrincipalName;

        if ((pssPrincipalName->Length > 0) &&
            (pssPrincipalName->Length <= cbPrepackAvail))
        {
            Args->ssPrincipal.Buffer =  (PWSTR_LPC) ((LONG_PTR) Where - (LONG_PTR) &ApiBuffer) ;

            RtlCopyMemory(
                    Where,
                    pssPrincipalName->Buffer,
                    pssPrincipalName->Length );

            Where += pssPrincipalName->Length;

            cbPrepackAvail -= pssPrincipalName->Length;
        }

    } 
    else
    {
        Args->ssPrincipal.Buffer        = 0;
        Args->ssPrincipal.MaximumLength = 0;
        Args->ssPrincipal.Length        = 0;

    }

    SecpSecurityStringToLpc( &Args->ssSecPackage, pssPackageName );

    if (pssPackageName->Length <= cbPrepackAvail)
    {
        Args->ssSecPackage.Buffer =  (PWSTR_LPC) ((LONG_PTR) Where - (LONG_PTR) &ApiBuffer );

        RtlCopyMemory(
                Where,
                pssPackageName->Buffer,
                pssPackageName->Length);

        Where += pssPackageName->Length;

        cbPrepackAvail -= pssPackageName->Length;
    }

    DebugLog((DEB_TRACE_CALL,"    PackageName = %wZ  \n", pssPackageName));

    Args->fCredentialUse   = fCredentialUse;
    if (pLogonID)
    {
        Args->LogonID      = *pLogonID;
        DebugLog((DEB_TRACE_CALL,"    LogonID = %x : %x\n", pLogonID->HighPart, pLogonID->LowPart));

    } else
    {
        Args->LogonID.HighPart = 0;
        Args->LogonID.LowPart  = 0;
    }

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer) ;

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    Args->pvAuthData = (PVOID_LPC) pvAuthData;
    Args->pvGetKeyFn = (PVOID_LPC) pvGetKeyFn;
    Args->ulGetKeyArgument = (PVOID_LPC) ulGetKeyArgument;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    DebugLog((DEB_TRACE,"AcquireCreds API Ret = %x\n", ApiBuffer.ApiMessage.scRet));


    *phCredentials = Args->hCredential;

    if (ARGUMENT_PRESENT(ptsExpiry))
    {
        *ptsExpiry = Args->tsExpiry;
    }

    DebugLog((DEB_TRACE_CALL,"    hCredentials = " POINTER_FORMAT " : " POINTER_FORMAT "\n", phCredentials->dwUpper, phCredentials->dwLower));

    FreeClient(pClient);

    *Flags = ApiBuffer.ApiMessage.Args.SpmArguments.fAPI ;

    return( scRet );
}


SECURITY_STATUS SEC_ENTRY
SecpAddCredentials(
    PVOID_LPC Context,
    PCRED_HANDLE_LPC phCredentials,
    PSECURITY_STRING pPrincipalName,
    PSECURITY_STRING pPackageName,
    ULONG fCredentialUse,
    PVOID pvAuthData,
    SEC_GET_KEY_FN pvGetKeyFn,
    PVOID pvGetKeyArg,
    PTimeStamp Expiry,
    PULONG Flags
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, AddCredential );
    ULONG           cbPrepackAvail = CBPREPACK;
    PUCHAR          Where;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"Entered AddCredential\n"));

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    PREPARE_MESSAGE_EX(ApiBuffer, AddCredential, *Flags, Context );

    Where = ApiBuffer.ApiMessage.bData;

    if (pPrincipalName)
    {
        DebugLog((DEB_TRACE_CALL,"    Principal = %wZ \n", pPrincipalName));

        SecpSecurityStringToLpc( &Args->ssPrincipal, pPrincipalName );

        if ((pPrincipalName->Length > 0) &&
            (pPrincipalName->Length <= cbPrepackAvail))
        {
            Args->ssPrincipal.Buffer = (PWSTR_LPC) (Where - (PUCHAR) &ApiBuffer );
            RtlCopyMemory(
                Where,
                pPrincipalName->Buffer,
                pPrincipalName->Length);

            Where += pPrincipalName->Length;

            cbPrepackAvail -= pPrincipalName->Length;
        }

    } 
    else
    {
        Args->ssPrincipal.Buffer        = 0;
        Args->ssPrincipal.MaximumLength = 0;
        Args->ssPrincipal.Length        = 0;

    }

    SecpSecurityStringToLpc( &Args->ssSecPackage, pPackageName );

    if (pPackageName->Length <= cbPrepackAvail)
    {
        Args->ssSecPackage.Buffer = (PWSTR_LPC) (Where - (PUCHAR) &ApiBuffer );

        RtlCopyMemory(
                Where,
                pPackageName->Buffer,
                pPackageName->Length);

        Where += pPackageName->Length;

        cbPrepackAvail -= pPackageName->Length;
    }

    DebugLog((DEB_TRACE_CALL,"    PackageName = %wZ  \n", pPackageName));

    Args->hCredentials = *phCredentials ;
    Args->fCredentialUse   = fCredentialUse;

    Args->pvAuthData = (PVOID_LPC) pvAuthData;
    Args->pvGetKeyFn = (PVOID_LPC) pvGetKeyFn;
    Args->ulGetKeyArgument = (PVOID_LPC) pvGetKeyArg ;

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer) ;

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    //
    // Call to the LSA
    //

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"AddCredentials API Ret = %x\n", ApiBuffer.ApiMessage.scRet));

    if (ARGUMENT_PRESENT(Expiry))
    {
        *Expiry = Args->tsExpiry;
    }

    FreeClient(pClient);

    *Flags = ApiBuffer.ApiMessage.Args.SpmArguments.fAPI ;

    return(ApiBuffer.ApiMessage.scRet);

}




//+-------------------------------------------------------------------------
//
//  Function:   SecpFreeCredentialsHandle
//
//  Synopsis:   LPC client stub for FreeCredentialsHandle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SecpFreeCredentialsHandle(
    ULONG            fFree,
    PCRED_HANDLE_LPC phCredential)
{
    SECURITY_STATUS scRet;
    PClient         pClient;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    DECLARE_ARGS( Args, ApiBuffer, FreeCredHandle );

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"Entered FreeCredentialHandle\n"));

    scRet = IsOkayToExec(&pClient);

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    PREPARE_MESSAGE(ApiBuffer, FreeCredHandle);

    Args->hCredential = *phCredential;

    if (fFree & SECP_DELETE_NO_BLOCK)
    {
        ApiBuffer.ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_EXEC_NOW;
    }

    DebugLog(( DEB_TRACE, "  hCredentials  " POINTER_FORMAT " : " POINTER_FORMAT "\n",
                        phCredential->dwUpper, phCredential->dwLower ));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    if (NT_SUCCESS(scRet))
    {
        scRet           = ApiBuffer.ApiMessage.scRet;
    }
    FreeClient(pClient);
    return(scRet);
}





//+-------------------------------------------------------------------------
//
//  Function:   SecpQueryCredentialsAttributes
//
//  Synopsis:   Client LPC stub for SecpQueryCredentialsAttributes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
SecpQueryCredentialsAttributes(
    PCRED_HANDLE_LPC phCredentials,
    ULONG ulAttribute,
    PVOID pBuffer,
    LONG Flags,
    PULONG Allocs,
    PVOID * Buffers
    )
{
    SECURITY_STATUS scRet;
    PClient         pClient;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    DECLARE_ARGS( Args, ApiBuffer, QueryCredAttributes );
    ULONG i ;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"Entered QueryCredentialsAttributes\n"));

    scRet = IsOkayToExec(&pClient);

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    PREPARE_MESSAGE_EX(ApiBuffer, QueryCredAttributes, Flags, NULL );

    Args->hCredentials = *phCredentials;
    Args->ulAttribute = ulAttribute;
    Args->pBuffer = (PVOID_LPC) pBuffer;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( ApiBuffer.ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ALLOCS )
        {
            *Allocs = Args->Allocs ;

            for ( i = 0 ; i < Args->Allocs ; i++ )
            {
                *Buffers++ = (PVOID) Args->Buffers[ i ];
            }

        }
        else
        {
            *Allocs = 0 ;
        }
    }

    FreeClient(pClient);

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\netclient\credapi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credapi.c

Abstract:

    This module contains routines common between the netapi32.dll and LSA server side of
        the credential manager.

Author:

    Cliff Van Dyke (CliffV)    Oct 30, 2000

Revision History:

--*/

#ifndef LSA_SERVER_COMPILED
#include <lsacomp.h>
#include <lmcons.h>
#include "credp.h"
#include <windns.h>
#include <netlibnt.h>
#include <names.h>
#endif // LSA_SERVER_COMPILED

//
// Macros
//

#define CredpIsDomainCredential( _Type ) ( \
    (_Type) == CRED_TYPE_DOMAIN_PASSWORD || \
    (_Type) == CRED_TYPE_DOMAIN_CERTIFICATE || \
    (_Type) == CRED_TYPE_DOMAIN_VISIBLE_PASSWORD )


BOOLEAN
CredpValidateDnsString(
    IN OUT LPWSTR String OPTIONAL,
    IN BOOLEAN NullOk,
    IN DNS_NAME_FORMAT DnsNameFormat,
    OUT PULONG StringSize
    )

/*++

Routine Description:

    This routine validates a passed in string.  The string must be a valid DNS name.
    Any trailing . is truncated.

Arguments:

    String - String to validate
        Any trailing . is truncated.
        This field is only modified if the routine returns TRUE.

    NullOk - if TRUE, a NULL string or zero length string is OK.

    DnsNameFormat - Expected format of the name.

    StringSize - Returns the length of the string (in bytes) including the
        trailing zero character.
        This field is only updated if the routine returns TRUE.

Return Values:

    TRUE - String is valid.

    FALSE - String is not valid.

--*/

{
    ULONG TempStringLen;

    if ( String == NULL ) {
        if ( !NullOk ) {
            return FALSE;
        }

        *StringSize = 0;
        return TRUE;
    }

    TempStringLen = wcslen( String );

    if ( TempStringLen == 0 ) {
        if ( !NullOk ) {
            return FALSE;
        }
    } else {
        //
        // Remove the trailing .
        //
        if ( String[TempStringLen-1] == L'.' ) {

            TempStringLen -= 1;

            //
            // Ensure the string isn't empty now.
            //

            if ( TempStringLen == 0 ) {
                if ( !NullOk ) {
                    return FALSE;
                }

            //
            // Ensure there aren't multiple trailing .'s
            //
            } else {
                if ( String[TempStringLen-1] == L'.' ) {
                    return FALSE;
                }
            }
        }

        //
        // Have DNS finish the validation
        //

        if ( TempStringLen != 0 ) {
            DWORD WinStatus;

            WinStatus = DnsValidateName_W( String, DnsNameFormat );

            if ( WinStatus != NO_ERROR &&
                 WinStatus != DNS_ERROR_NON_RFC_NAME ) {

                //
                // The RFC says hostnames cannot have numeric leftmost labels.
                //  However, Win 2K servers have such hostnames.
                //  So, allow them here forever more.
                //

                if ( DnsNameFormat == DnsNameHostnameFull &&
                     WinStatus == DNS_ERROR_NUMERIC_NAME ) {

                    /* Drop through */

                } else {
                    return FALSE;
                }

            }
        }
    }

    if ( TempStringLen > DNS_MAX_NAME_LENGTH ) {
        return FALSE;
    }

    String[TempStringLen] = L'\0';
    *StringSize = (TempStringLen + 1) * sizeof(WCHAR);
    return TRUE;
}


BOOLEAN
CredpValidateString(
    IN LPWSTR String OPTIONAL,
    IN ULONG MaximumLength,
    IN BOOLEAN NullOk,
    OUT PULONG StringSize
    )

/*++

Routine Description:

    This routine validates a passed in string.

Arguments:

    String - String to validate

    MaximumLength - Maximum length of the string (in characters).

    NullOk - if TRUE, a NULL string or zero length string is OK.

    StringSize - Returns the length of the string (in bytes) including the
        trailing zero character.

Return Values:

    TRUE - String is valid.

    FALSE - String is not valid.

--*/

{
    ULONG TempStringLen;

    if ( String == NULL ) {
        if ( !NullOk ) {
            return FALSE;
        }

        *StringSize = 0;
        return TRUE;
    }

    TempStringLen = wcslen( String );

    if ( TempStringLen == 0 ) {
        if ( !NullOk ) {
            return FALSE;
        }

        *StringSize = 0;
        return TRUE;
    }

    if ( TempStringLen > MaximumLength ) {
        return FALSE;
    }

    *StringSize = (TempStringLen + 1) * sizeof(WCHAR);
    return TRUE;
}

NTSTATUS
CredpValidateUserName(
    IN LPWSTR UserName,
    IN ULONG Type,
    OUT LPWSTR *CanonicalUserName
    )

/*++

Routine Description:

    This routine validates a passed in user name.

    For a password credential, a user name must have one of the following two syntaxes:

            <DomainName>\<UserName>
            <UserName>@<DnsDomainName>

        The name is considered to have the first syntax if the string contains an \.
        A string containing a @ is ambiguous since <UserName> may contain an @.

        For the second syntax, the last @ in the string is used since <UserName> may
        contain an @ but <DnsDomainName> cannot.

    For a certificate credential, the user name must be a marshalled cert reference

Arguments:

    UserName - Name of user to validate.

    Type - Specifies the Type of the credential.
        One of the CRED_TYPE_* values should be specified.

    CanonicalUserName - Returns a pointer to a buffer containing the user name in canonical form.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_ACCOUNT_NAME - The user name is not valid.

--*/

{
    NTSTATUS Status;

    LPWSTR SlashPointer;
    LPWSTR AtPointer;
    LPWSTR LocalUserName = NULL;
    ULONG UserNameSize;
    ULONG LocalStringSize;

    //
    // Check the string length
    //

    if ( !CredpValidateString( UserName,
                               CRED_MAX_USERNAME_LENGTH,
                               FALSE,
                               &UserNameSize ) ) {

        Status = STATUS_INVALID_ACCOUNT_NAME;
        goto Cleanup;
    }

    //
    // Grab a local writable copy of the string.
    //

    LocalUserName = (LPWSTR) LocalAlloc( 0, UserNameSize );

    if ( LocalUserName == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( LocalUserName, UserName, UserNameSize );

    //
    // Domain credentials need further validation.
    //

    if ( CredpIsDomainCredential( Type ) ) {

        //
        // Cert credentials have a marshalled cert reference as the UserName
        //

        if ( Type == CRED_TYPE_DOMAIN_CERTIFICATE ) {
            DWORD WinStatus;
            CRED_MARSHAL_TYPE CredType;
            PVOID UnmarshalledUsername;


            if ( !CredUnmarshalCredentialW( LocalUserName, &CredType, &UnmarshalledUsername ) ) {

                WinStatus = GetLastError();

                if ( WinStatus == ERROR_INVALID_PARAMETER ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                } else {
                    Status = NetpApiStatusToNtStatus(WinStatus);
                }

                goto Cleanup;
            }

            CredFree( UnmarshalledUsername );

            if ( CredType != CertCredential ) {
                Status = STATUS_INVALID_ACCOUNT_NAME;
                goto Cleanup;
            }

        //
        // Password credentials have UPN or domain\account user names
        //

        } else {

            //
            // Classify the input account name.
            //
            // The name is considered to be <DomainName>\<UserName> if the string
            // contains an \.
            //

            SlashPointer = wcsrchr( LocalUserName, L'\\' );

            if ( SlashPointer != NULL ) {
                LPWSTR LocalUserNameEnd;
                LPWSTR AfterSlashPointer;

                //
                // Skip the backslash
                //

                *SlashPointer = L'\0';
                AfterSlashPointer = SlashPointer + 1;

                //
                // Ensure the string to the left of the \ is a valid domain name
                //
                // (Do DNS name first to allow the name to be canonicalized.)

                LocalStringSize = (ULONG)(SlashPointer-LocalUserName+1)*sizeof(WCHAR);
                if ( !CredpValidateDnsString( LocalUserName, FALSE, DnsNameDomain, &LocalStringSize ) &&
                     !NetpIsDomainNameValid( LocalUserName ) ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }

                //
                // Ensure the string to the right of the \ is a valid user name
                //

                if ( !NetpIsUserNameValid( AfterSlashPointer )) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }

                //
                // If the dns domain name was canonicalized,
                //  rebuild the complete user name.
                //

                *SlashPointer = '\\';

                LocalUserNameEnd = &LocalUserName[LocalStringSize/sizeof(WCHAR) - 1];

                if ( SlashPointer != LocalUserNameEnd ) {
                    RtlMoveMemory( LocalUserNameEnd,
                                   SlashPointer,
                                   (wcslen(SlashPointer) + 1) * sizeof(WCHAR) );
                }

            //
            // Otherwise the name must be a UPN
            //

            } else {

                //
                // A UPN has the syntax <AccountName>@<DnsDomainName>.
                // If there are multiple @ signs,
                //  use the last one since an AccountName can have an @ in it.
                //
                //

                AtPointer = wcsrchr( LocalUserName, L'@' );
                if ( AtPointer == NULL ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }


                //
                // The string to the left of the @ can really have any syntax.
                //  But must be non-null.
                //

                if ( AtPointer == LocalUserName ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }



                //
                // Ensure the string to the right of the @ is a DNS domain name
                //

                AtPointer ++;
                if ( !CredpValidateDnsString( AtPointer, FALSE, DnsNameDomain, &LocalStringSize ) ) {
                    Status = STATUS_INVALID_ACCOUNT_NAME;
                    goto Cleanup;
                }

            }

        }
    }

    Status = STATUS_SUCCESS;

    //
    // Copy parameters back to the caller
    //

    *CanonicalUserName = LocalUserName;
    LocalUserName = NULL;


    //
    // Cleanup
    //
Cleanup:
    if ( LocalUserName != NULL ) {
        MIDL_user_free( LocalUserName );
    }

    return Status;

}

NTSTATUS
NET_API_FUNCTION
CredpValidateTargetName(
    IN OUT LPWSTR TargetName,
    IN ULONG Type,
    IN TARGET_NAME_TYPE TargetNameType,
    IN LPWSTR *UserNamePointer OPTIONAL,
    IN LPDWORD PersistPointer OPTIONAL,
    OUT PULONG TargetNameSize,
    OUT PWILDCARD_TYPE WildcardTypePointer OPTIONAL,
    OUT PUNICODE_STRING NonWildcardedTargetName OPTIONAL
    )

/*++

Routine Description:

    This routine validates a passed in TargetName and TargetType for a credential.

Arguments:

    TargetName - TargetName to validate
        The returned buffer is a canonicalized form of the target name.

    Type - Specifies the Type of the credential.
        One of the CRED_TYPE_* values should be specified.

    TargetNameType - Specifies whether the TargetName needs to match UsernameTarget Syntax

    UserNamePointer - Points to the address of a string which is the user name on the credential.
        If NULL, the UserName is unknown.
        If not NULL, the user name is used for UsernameTarget target name validation.

    PersistPointer - Points to a DWORD describing the persistence of the credential named by TargetName.
        If NULL, the peristence is unknown.
        If not NULL, the persistence will be checked to ensure it is valid for TargetName.

    TargetNameSize - Returns the length of the TargetName (in bytes) including the
        trailing zero character.

    WildcardType - If specified, returns the type of the wildcard specified in TargetName

    NonWildcardedTargetName - If specified, returns the non-wildcarded form of TargetName.
        The caller must free NonWildcardedTargetName->Buffer using MIDL_user_free.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARAMETER - The TargetName or Type are invalid.

        STATUS_INVALID_ACCOUNT_NAME - The user name is not valid.

--*/

{
    NTSTATUS Status;
    ULONG MaxStringLength;
    LPWSTR AllocatedTargetName = NULL;
    ULONG TempTargetNameSize;
    BOOLEAN TargetNameIsUserName = FALSE;
    WILDCARD_TYPE WildcardType;

    LPWSTR CanonicalUserName = NULL;
    LPWSTR TnAsCanonicalUserName = NULL;

    LPWSTR RealTargetName = TargetName;  // TargetName sans wildcard chars
    ULONG RealTargetNameLength;

    //
    // Initialization
    //

    if ( NonWildcardedTargetName != NULL ) {
        RtlInitUnicodeString( NonWildcardedTargetName, NULL );
    }

    //
    // Validate the type
    //

    if ( Type == CRED_TYPE_GENERIC ) {

        MaxStringLength = CRED_MAX_GENERIC_TARGET_NAME_LENGTH;

        //
        // Don't allow generic UsernameTarget credentials
        //

        if ( TargetNameType == IsUsernameTarget ) {
#ifdef LSA_SERVER_COMPILED
            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateTargetName: Generic creds cannot be UsernameTarget: %ld.\n",
                       Type ));
#endif // LSA_SERVER_COMPILED
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // We really know this isn't a UsernameTarget credential
        //

        TargetNameType = IsNotUsernameTarget;

    } else if ( CredpIsDomainCredential( Type ) ) {

        MaxStringLength = CRED_MAX_DOMAIN_TARGET_NAME_LENGTH;
        ASSERT( CRED_MAX_DOMAIN_TARGET_NAME_LENGTH == DNS_MAX_NAME_LENGTH + 1 + 1 + NNLEN );

    } else {
#ifdef LSA_SERVER_COMPILED
        DebugLog(( DEB_TRACE_CRED,
                   "CredpValidateTargetName: %ws: Invalid Type: %ld.\n",
                   TargetName,
                   Type ));
#endif // LSA_SERVER_COMPILED
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If this might be a "UsernameTarget" credential,
    //  check if the credential looks like a user name.
    //

    if ( TargetNameType == IsUsernameTarget ||
         TargetNameType == MightBeUsernameTarget ) {

        //
        // Also allow target names that are valid user names
        //  (Don't canonicalize.  We don't have an opportunity to canonicalize short names.)
        //

        Status = CredpValidateUserName( TargetName, Type, &TnAsCanonicalUserName );

        if ( NT_SUCCESS(Status) ) {

            //
            // If we don't know the user name,
            //  accept this as valid syntax.
            //

            if ( UserNamePointer == NULL ) {

                MaxStringLength = CRED_MAX_USERNAME_LENGTH;
                TargetNameIsUserName = TRUE;

            //
            // If we know the user name,
            //  it must match for this syntax to be valid.
            //

            } else {

                UNICODE_STRING UserNameString;
                UNICODE_STRING TargetNameString;

                //
                // Validate the user name before touching it.
                //

                Status = CredpValidateUserName( *UserNamePointer,
                                                Type,
                                                &CanonicalUserName );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

                RtlInitUnicodeString( &UserNameString, CanonicalUserName );
                RtlInitUnicodeString( &TargetNameString, TnAsCanonicalUserName );

                //
                // The target name might be identical to the UserName.
                //
                // Such credentials are the "UsernameTarget" credentials.
                //

                if ( UserNameString.Length != 0 &&
                     RtlEqualUnicodeString( &TargetNameString,
                                            &UserNameString,
                                            TRUE ) ) {

                    MaxStringLength = CRED_MAX_USERNAME_LENGTH;
                    TargetNameIsUserName = TRUE;

                }

            }


        }


        //
        // If the caller was sure this is a UsernameTarget credential,
        //  make sure it really was.
        //

        if ( TargetNameType == IsUsernameTarget && !TargetNameIsUserName ) {
#ifdef LSA_SERVER_COMPILED
            DebugLog(( DEB_TRACE_CRED,
                       "CredpValidateTargetName: %ws: Is 'UsernameTarget' and target name doesn't match user name: %ld.\n",
                       TargetName,
                       Type ));
#endif // LSA_SERVER_COMPILED
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

    }

    //
    // Validate the string
    //

    if ( !CredpValidateString( TargetName,
                               MaxStringLength,
                               FALSE,   // NULL not OK
                               TargetNameSize ) ) {


#ifdef LSA_SERVER_COMPILED
        DebugLog(( DEB_TRACE_CRED,
                   "CredpValidateTargetName: Invalid TargetName buffer.\n" ));
#endif // LSA_SERVER_COMPILED
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // For generic credentials,
    //  that's all the validation needed.
    //

    WildcardType = WcServerName;
    if ( Type == CRED_TYPE_GENERIC ) {
        /* Do nothing here */

    //
    // For domain credentials,
    //   classify the target name.
    //

    } else {



        //
        // The target name might be a user name.
        //  (If we're not sure, let the other types take precedence.)
        //

        RealTargetName = TargetName;
        RealTargetNameLength = (*TargetNameSize-sizeof(WCHAR))/sizeof(WCHAR);

        if ( TargetNameType == IsUsernameTarget && TargetNameIsUserName ) {
            WildcardType = WcUserName;
            wcscpy( TargetName, TnAsCanonicalUserName );
            *TargetNameSize = (wcslen( TargetName ) + 1) * sizeof(WCHAR);


        //
        // The target name might be of the form <Domain>\*
        //

        } else if ( RealTargetNameLength > 2 &&
             RealTargetName[RealTargetNameLength-1] == L'*' &&
             RealTargetName[RealTargetNameLength-2] == L'\\' ) {

            //
            // Allocate a buffer for the target name so we don't have to modify the
            //  callers buffer.
            //

            WildcardType = WcDomainWildcard;

            AllocatedTargetName = (LPWSTR) MIDL_user_allocate( *TargetNameSize );

            if ( AllocatedTargetName == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlCopyMemory( AllocatedTargetName, RealTargetName, *TargetNameSize );
            RealTargetName = AllocatedTargetName;
            RealTargetNameLength -= 2;
            RealTargetName[RealTargetNameLength] = '\0';

            //
            // The domain itself might be a netbios or DNS domain
            //
            // Do DNS test first.  That allows the validate routine to truncate
            //

            TempTargetNameSize = ((RealTargetNameLength+1)*sizeof(WCHAR));
            if ( !CredpValidateDnsString(
                            RealTargetName,
                            FALSE,
                            DnsNameDomain,
                            &TempTargetNameSize ) &&
                 !NetpIsDomainNameValid( RealTargetName ) ) {

                Status = STATUS_INVALID_PARAMETER;
#ifdef LSA_SERVER_COMPILED
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateTargetName: %ws: TargetName for domain wildcard must netbios or dns domain.\n",
                           TargetName ));
#endif // LSA_SERVER_COMPILED
                goto Cleanup;
            }

            //
            // If Dns truncated,
            //  put the canonical name back in the callers buffer.
            //

            RealTargetNameLength = (TempTargetNameSize-sizeof(WCHAR))/sizeof(WCHAR);
            RealTargetName[RealTargetNameLength] = '\0';

            if ( *TargetNameSize+(2*sizeof(WCHAR)) != TempTargetNameSize ) {
                RtlCopyMemory( TargetName,
                               RealTargetName,
                               TempTargetNameSize );
                TargetName[RealTargetNameLength] = '\\';
                TargetName[RealTargetNameLength+1] = '*';
                TargetName[RealTargetNameLength+2] = '\0';
                *TargetNameSize = (wcslen( TargetName ) + 1) * sizeof(WCHAR);
            }

        //
        // Handle the universal wildcard
        //
        } else if ( RealTargetNameLength == 1 &&
                    RealTargetName[0] == L'*' ) {

            WildcardType = WcUniversalWildcard;


        //
        // Handle server wildcards
        //
        } else if ( CredpValidateDnsString(
                        TargetName,
                        FALSE,
                        DnsNameWildcard,
                        TargetNameSize )) {

            WildcardType = WcServerWildcard;
            RealTargetName += 1;
            RealTargetNameLength -= 1;

        //
        // Handle the universal session wildcard
        //

        } else if ( RealTargetNameLength == CRED_SESSION_WILDCARD_NAME_LENGTH &&
                    _wcsicmp( RealTargetName, CRED_SESSION_WILDCARD_NAME_W ) == 0 ) {

            WildcardType = WcUniversalSessionWildcard;

            //
            // This target name requires session persistence.
            //

            if ( PersistPointer != NULL &&
                 *PersistPointer != CRED_PERSIST_SESSION ) {

                Status = STATUS_INVALID_PARAMETER;
#ifdef LSA_SERVER_COMPILED
                DebugLog(( DEB_TRACE_CRED,
                           "ValidateTargetName: %ws: TargetName requires session persistence %ld.\n",
                           TargetName,
                           *PersistPointer ));
#endif // LSA_SERVER_COMPILED
                goto Cleanup;
            }


        //
        //  The target name might be a non-wildcard netbios name.
        //  The target name might be a non-wildcard dns name.
        //
        // Do DNS test first.  That allows the validate routine to truncate
        //  the trailing .
        //
        //

        } else if ( CredpValidateDnsString(
                            TargetName,
                            FALSE,
                            DnsNameHostnameFull,
                            TargetNameSize ) ||
                    NetpIsDomainNameValid( TargetName ) ) {

            WildcardType = WcServerName;

        //
        // This target name might be a DFS share name
        //
        // The format is <DfsRoot>\<DfsShare>
        //

        } else {
            LPWSTR SlashPtr;
            ULONG SavedTargetNameSize;


            //
            // A DFS Share has a slash in it
            //

            SlashPtr = wcschr( TargetName, L'\\' );

            if ( SlashPtr != NULL ) {


                //
                // A DFS share has a share name with the right syntax
                //

                if ( NetpIsShareNameValid( SlashPtr+1 ) ) {


                    //
                    // Allocate a copy of the data for the RealTargetName
                    //

                    AllocatedTargetName = (LPWSTR) MIDL_user_allocate( *TargetNameSize );

                    if ( AllocatedTargetName == NULL ) {
                        Status = STATUS_NO_MEMORY;
                        goto Cleanup;
                    }

                    RtlCopyMemory( AllocatedTargetName, RealTargetName, *TargetNameSize );
                    RealTargetName = AllocatedTargetName;
                    RealTargetNameLength = (ULONG)(SlashPtr-TargetName);
                    RealTargetName[RealTargetNameLength] = '\0';

                    //
                    // The domain itself might be a netbios or DNS domain
                    //
                    // Do DNS test first.  That allows the validate routine to truncate
                    //

                    TempTargetNameSize = ((RealTargetNameLength+1)*sizeof(WCHAR));
                    SavedTargetNameSize = TempTargetNameSize;
                    if ( CredpValidateDnsString(
                                    RealTargetName,
                                    FALSE,
                                    DnsNameDomain,
                                    &TempTargetNameSize ) ||
                         NetpIsDomainNameValid( RealTargetName ) ) {

                        //
                        // If Dns truncated,
                        //  put the canonical name back in the callers buffer.
                        //

                        RealTargetNameLength = (TempTargetNameSize-sizeof(WCHAR))/sizeof(WCHAR);
                        RealTargetName[RealTargetNameLength] = '\0';

                        if ( SavedTargetNameSize != TempTargetNameSize ) {
                            ULONG DfsShareSize;

                            DfsShareSize = *TargetNameSize - (SlashPtr-TargetName)*sizeof(WCHAR);

                            // Copy <DfsRoot>
                            RtlCopyMemory( TargetName,
                                           RealTargetName,
                                           RealTargetNameLength*sizeof(WCHAR) );

                            // Copy \<DfsShare><\0>
                            RtlMoveMemory( &TargetName[RealTargetNameLength],
                                           SlashPtr,
                                           DfsShareSize );

                            *TargetNameSize = RealTargetNameLength*sizeof(WCHAR) + DfsShareSize;

                        }

                        WildcardType = WcDfsShareName;
                    }

                }
            }

            //
            // At this point,
            //  if the syntax isn't DFS SHARE,
            // Then it must be one of the other syntaxes.
            //

            if ( WildcardType != WcDfsShareName ) {

                //
                // The target name might have defaulted to be a user name.
                //

                if ( TargetNameIsUserName ) {
                    WildcardType = WcUserName;
                    wcscpy( TargetName, TnAsCanonicalUserName );
                    *TargetNameSize = (wcslen( TargetName ) + 1) * sizeof(WCHAR);

                //
                // Everything else is invalid
                //

                } else {
                    Status = STATUS_INVALID_PARAMETER;
#ifdef LSA_SERVER_COMPILED
                    DebugLog(( DEB_TRACE_CRED,
                               "ValidateTargetName: %ws: TargetName syntax invalid.\n",
                               TargetName ));
#endif // LSA_SERVER_COMPILED
                    goto Cleanup;
                }

            }

        }

    }

    //
    // On success, copy the parameters back to the caller.
    //

    if ( WildcardTypePointer != NULL ) {
        *WildcardTypePointer = WildcardType;
    }

    if ( NonWildcardedTargetName != NULL ) {

        ULONG BufferSize = (wcslen(RealTargetName) + 1) * sizeof(WCHAR);

        NonWildcardedTargetName->Buffer = (LPWSTR) MIDL_user_allocate( BufferSize );

        if ( NonWildcardedTargetName->Buffer == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( NonWildcardedTargetName->Buffer, RealTargetName, BufferSize );
        NonWildcardedTargetName->MaximumLength = (USHORT)BufferSize;
        NonWildcardedTargetName->Length = (USHORT)(BufferSize - sizeof(WCHAR));
    }



    Status = STATUS_SUCCESS;

Cleanup:

    if ( AllocatedTargetName != NULL ) {
        MIDL_user_free( AllocatedTargetName );
    }

    if ( CanonicalUserName != NULL ) {
        MIDL_user_free( CanonicalUserName );
    }

    if ( TnAsCanonicalUserName != NULL ) {
        MIDL_user_free( TnAsCanonicalUserName );
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\ctxtapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        ctxtapi.cxx
//
// Contents:    Context API stubs for LPC
//
//
// History:     31 May 92   RichardW    Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>
}


#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, SecpInitializeSecurityContext)
#pragma alloc_text(PAGE, SecpAcceptSecurityContext)
#pragma alloc_text(PAGE, SecpDeleteSecurityContext)
#pragma alloc_text(PAGE, SecpApplyControlToken)
#pragma alloc_text(PAGE, SecpQueryContextAttributes)
#endif // ALLOC_PRAGMA


#if DBG
ULONG   cBigCalls = 0;  // Number of potential memory copy calls
ULONG   cPrePacks = 0;  // Number saved with PrePacks
#endif

static CONTEXT_HANDLE_LPC NullContext = {0,0};



//+---------------------------------------------------------------------------
//
//  Function:   SecpInitializeSecurityContext
//
//  Synopsis:   client LPC stub for init security context
//
//  Arguments:  [phCredentials]  -- Credential to use
//              [phContext]      -- Existing context (if any)
//              [pucsTarget]     --
//              [fContextReq]    --
//              [dwReserved1]    --
//              [cbInputToken]   --
//              [pbInputToken]   --
//              [dwReserved2]    --
//              [phNewContext]   --
//              [pcbOutputToken] --
//              [pbOutputToken]  --
//              [pfContextAttr]  --
//              [ptsExpiry]      --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-25-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
SecpInitializeSecurityContext(
    PVOID_LPC           ContextPointer,
    PCRED_HANDLE_LPC    phCredentials,
    PCONTEXT_HANDLE_LPC phContext,
    PSECURITY_STRING    pssTarget,
    ULONG               fContextReq,
    ULONG               dwReserved1,
    ULONG               TargetDataRep,
    PSecBufferDesc      pInput,
    ULONG               dwReserved2,
    PCONTEXT_HANDLE_LPC phNewContext,
    PSecBufferDesc      pOutput,
    ULONG *             pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBOOLEAN            MappedContext,
    PSecBuffer          ContextData,
    ULONG *             Flags )
{

    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE       ApiBuffer;
    PClient         pClient;
    PVOID           pBuffer = NULL;
    DECLARE_ARGS( Args, ApiBuffer, InitContext );
    PSEC_BUFFER_LPC pInputBuffers;
    PSEC_BUFFER_LPC pOutputBuffers = NULL;
    ULONG BuffersAvailable = NUM_SECBUFFERS ;
    ULONG BuffersConsumed = 0 ;

    SEC_PAGED_CODE();

    if (!phCredentials)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if (ARGUMENT_PRESENT(pInput) && (pInput->cBuffers > MAX_SECBUFFERS) ||
        ARGUMENT_PRESENT(pOutput) && (pOutput->cBuffers > MAX_SECBUFFERS))
    {
        DebugLog((DEB_ERROR,"Too many secbuffers passed in : %d or %d (max %d)\n",
                pInput->cBuffers,pOutput->cBuffers, MAX_SECBUFFERS ));

        return( SEC_E_INVALID_TOKEN );
    }


    //
    // pssTarget can not be NULL, since we dereference it
    //

    ASSERT(pssTarget);

    //
    //  Locate the client tracking record, or create one if it can't be found
    //


    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    //
    // Initialize the message
    //

    PREPARE_MESSAGE_EX(ApiBuffer, InitContext, *Flags, ContextPointer );

    DebugLog((DEB_TRACE,"InitializeContext\n"));

    DebugLog((DEB_TRACE_CALL,"    Target = %wZ  \n", pssTarget));

    Args->hCredential   = *phCredentials;
    if (phContext)
    {
        Args->hContext  = *phContext;
    }
    else
    {
        Args->hContext = NullContext;
    }

    DebugLog((DEB_TRACE_CALL,"    Ctxt In = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
                Args->hContext.dwUpper, Args->hContext.dwLower));

    SecpSecurityStringToLpc( &Args->ssTarget, pssTarget );

    Args->fContextReq   = fContextReq;
    Args->dwReserved1   = dwReserved1;
    Args->TargetDataRep = TargetDataRep;
    pInputBuffers = Args->sbData;

    if (ARGUMENT_PRESENT(pInput))
    {
        SecpSecBufferDescToLpc( &Args->sbdInput, pInput );

#ifndef BUILD_WOW64

        if ( pInput->cBuffers < BuffersAvailable )
        {

            Args->sbdInput.pBuffers = (PSecBuffer) ((LONG_PTR) pInputBuffers - (LONG_PTR) Args);

            RtlCopyMemory(  Args->sbData,
                            pInput->pBuffers,
                            sizeof(SecBuffer) * pInput->cBuffers);

            BuffersAvailable -= pInput->cBuffers ;
            BuffersConsumed += pInput->cBuffers ;

        }
#else
        if ( pInput->cBuffers < BuffersAvailable )
        {
            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowInput ;

            Data = (PSEC_BUFFER_LPC) ((LONG_PTR) pInputBuffers - (LONG_PTR) Args);

            Args->sbdInput.pBuffers = (PVOID_LPC) Data ;
            Data = (PSEC_BUFFER_LPC) pInputBuffers ;
            NarrowInput = pInput->pBuffers ;

            for ( i = 0 ; i < pInput->cBuffers ; i++ )
            {
                SecpSecBufferToLpc( Data, NarrowInput );
                Data++ ;
                NarrowInput++;
            }

            BuffersAvailable -= pInput->cBuffers ;
            BuffersConsumed += pInput->cBuffers ;
        }
#endif

    }
    else
    {
        RtlZeroMemory(
            &Args->sbdInput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }


    Args->dwReserved2   = dwReserved2;

    if (ARGUMENT_PRESENT(pOutput))
    {
        SecpSecBufferDescToLpc( &Args->sbdOutput, pOutput );


#ifndef BUILD_WOW64
        if ( pOutput->cBuffers < BuffersAvailable )
        {
            pOutputBuffers = pInputBuffers + BuffersConsumed;

            Args->sbdOutput.pBuffers = (PSecBuffer) ((LONG_PTR) pOutputBuffers - (LONG_PTR) Args);
            RtlCopyMemory(  pOutputBuffers,
                            pOutput->pBuffers,
                            sizeof(SecBuffer) * pOutput->cBuffers);

            BuffersAvailable -= pOutput->cBuffers ;
            BuffersConsumed += pOutput->cBuffers ;
        }

        //
        // if the client asked the security layer to allocate
        // the memory, and we have a valid number of output
        // buffers available, reset them all to NULL so that
        // it's easier to keep track of them.
        //

        if ( ( fContextReq & ISC_REQ_ALLOCATE_MEMORY ) &&
             ( pOutputBuffers != NULL ) )
        {
            ULONG i;
            for (i = 0; i < pOutput->cBuffers ; i++ )
            {
                pOutputBuffers[i].pvBuffer = NULL;
            }
        }
#else
        if ( pOutput->cBuffers < BuffersAvailable )
        {
            PSEC_BUFFER_LPC Data ;
            ULONG i ;
            PSecBuffer NarrowOutput ;


            pOutputBuffers = pInputBuffers + BuffersConsumed;

            Data = (PSEC_BUFFER_LPC) ((LONG_PTR) pOutputBuffers - (LONG_PTR) Args );
            Args->sbdOutput.pBuffers = (PVOID_LPC) Data ;

            Data = (PSEC_BUFFER_LPC) (pOutputBuffers);
            NarrowOutput = pOutput->pBuffers ;


            for ( i = 0 ; i < pOutput->cBuffers ; i++ )
            {
                if ( (fContextReq & ISC_REQ_ALLOCATE_MEMORY ) != 0 )
                {
                    NarrowOutput->pvBuffer = NULL ;
                }

                SecpSecBufferToLpc( Data, NarrowOutput );

                Data++;
                NarrowOutput++;


            }

            BuffersAvailable -= pOutput->cBuffers ;
            BuffersConsumed += pOutput->cBuffers ;
        }
#endif


    }
    else
    {
        RtlZeroMemory(
            &Args->sbdOutput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }


    Args->ContextData.pvBuffer = NULL;
    Args->ContextData.cbBuffer = 0;
    Args->ContextData.BufferType = 0;
    Args->MappedContext = FALSE;

    if ( BuffersConsumed > 0 )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = 
            LPC_TOTAL_LENGTH( BuffersConsumed  * sizeof( SEC_BUFFER_LPC ) );

        ApiBuffer.pmMessage.u1.s1.DataLength = 
            LPC_DATA_LENGTH( BuffersConsumed * sizeof( SEC_BUFFER_LPC ) );

        
    }



    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);


    if (!NT_SUCCESS(scRet))
    {
        goto InitExitPoint;
    }

    DebugLog((DEB_TRACE,"    scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    //
    // If the API failed, then don't bother with the memory copies and that
    // that stuff.  In fact, if there was a memory problem, then we should
    // definitely get out now.
    //

    //
    // Either way we want to copy this - it will have updated size
    // information
    //

    if (ARGUMENT_PRESENT(pOutput))
    {
        if ( (ULONG_PTR) Args->sbdOutput.pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
        {
#ifndef BUILD_WOW64
            RtlCopyMemory(  pOutput->pBuffers,
                            pOutputBuffers,
                            sizeof(SecBuffer) * Args->sbdOutput.cBuffers );
#else
            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowOutput ;

            Data = pOutputBuffers ;
            NarrowOutput = pOutput->pBuffers ;
            for (i = 0 ; i < Args->sbdOutput.cBuffers ; i++ )
            {
                SecpLpcBufferToSecBuffer( NarrowOutput, Data );
                NarrowOutput++ ;
                Data ++;
            }
#endif
        }

    }

    if (!NT_SUCCESS(ApiBuffer.ApiMessage.scRet))
    {
        DebugLog((DEB_TRACE,"Failed, exiting\n"));
        goto InitExitPoint;
    }

    //
    // If this was an Init call, handle the return values
    //

    *phNewContext   = Args->hNewContext;
    *pfContextAttr  = Args->fContextAttr;

    SecpLpcBufferToSecBuffer( ContextData, &Args->ContextData );

    *MappedContext  = Args->MappedContext;

    if (ARGUMENT_PRESENT(ptsExpiry))
    {
        *ptsExpiry = Args->tsExpiry;
    }


    DebugLog((DEB_TRACE_CALL,"    Ctxt Out = " POINTER_FORMAT ":" POINTER_FORMAT "\n",
              phNewContext->dwUpper, phNewContext->dwLower));



    //
    // Likewise, for the stream protocols, update the input
    // buffer types for EXTRA and MISSING:
    //

    if ( ARGUMENT_PRESENT( pInput ) )
    {
        if ( (ULONG_PTR) Args->sbdInput.pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
        {
#ifndef BUILD_WOW64
            RtlCopyMemory( pInput->pBuffers,
                           pInputBuffers,
                           sizeof( SecBuffer ) * Args->sbdInput.cBuffers );
#else

            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowInput ;

            Data = pInputBuffers ;
            NarrowInput = pInput->pBuffers ;
            for (i = 0 ; i < Args->sbdInput.cBuffers ; i++ )
            {
                SecpLpcBufferToSecBuffer( NarrowInput, Data );
                NarrowInput++ ;
                Data ++;
            }
#endif
        }
    }


InitExitPoint:

    *Flags = ApiBuffer.ApiMessage.Args.SpmArguments.fAPI ;

    FreeClient(pClient);

    return( ApiBuffer.ApiMessage.scRet );


}


//+-------------------------------------------------------------------------
//
//  Function:   SecpAcceptSecurityContext()
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
SecpAcceptSecurityContext(
    PVOID_LPC           ContextPointer,
    PCRED_HANDLE_LPC    phCredentials,
    PCONTEXT_HANDLE_LPC phContext,
    PSecBufferDesc      pInput,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCONTEXT_HANDLE_LPC phNewContext,
    PSecBufferDesc      pOutput,
    ULONG *             pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBOOLEAN            MappedContext,
    PSecBuffer          ContextData,
    ULONG *             Flags )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, AcceptContext );
    PSEC_BUFFER_LPC pInputBuffers;
    PSEC_BUFFER_LPC pOutputBuffers = NULL;
    ULONG   i;
    ULONG BuffersAvailable = NUM_SECBUFFERS ;
    ULONG BuffersConsumed = 0 ;

    SEC_PAGED_CODE();

    if (!phCredentials)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if (ARGUMENT_PRESENT(pInput) && (pInput->cBuffers > MAX_SECBUFFERS) ||
        ARGUMENT_PRESENT(pOutput) && (pOutput->cBuffers > MAX_SECBUFFERS))
    {
        DebugLog((DEB_ERROR,"Too many secbuffers passed in : %d or %d\n",
                pInput->cBuffers,pOutput->cBuffers));
        return(SEC_E_INVALID_TOKEN);
    }



    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"AcceptSecurityContext\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, AcceptContext, *Flags, ContextPointer );


    Args->hCredential   = *phCredentials;
    if (phContext)
    {
        Args->hContext  = *phContext;
    }
    else
    {
        Args->hContext = NullContext;
    }

    Args->fContextReq   = fContextReq;
    Args->TargetDataRep = TargetDataRep;

    DebugLog((DEB_TRACE_CALL,"    Ctxt In = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
              Args->hContext.dwUpper, Args->hContext.dwLower));

    pInputBuffers = Args->sbData;

    if (ARGUMENT_PRESENT(pInput))
    {
        SecpSecBufferDescToLpc( &Args->sbdInput, pInput );

#ifndef BUILD_WOW64

        if ( pInput->cBuffers < BuffersAvailable )
        {

            Args->sbdInput.pBuffers = (PSecBuffer) ((LONG_PTR) pInputBuffers - (LONG_PTR) Args);

            RtlCopyMemory(  Args->sbData,
                            pInput->pBuffers,
                            sizeof(SecBuffer) * pInput->cBuffers);

            BuffersAvailable -= pInput->cBuffers ;
            BuffersConsumed += pInput->cBuffers ;

        }
#else
        if ( pInput->cBuffers < BuffersAvailable )
        {
            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowInput ;

            Data = (PSEC_BUFFER_LPC) ((LONG_PTR) pInputBuffers - (LONG_PTR) Args);

            Args->sbdInput.pBuffers = (PVOID_LPC) Data ;

            Data = (PSEC_BUFFER_LPC) pInputBuffers ;

            NarrowInput = pInput->pBuffers ;

            for ( i = 0 ; i < pInput->cBuffers ; i++ )
            {
                SecpSecBufferToLpc( Data, NarrowInput );
                Data++ ;
                NarrowInput++;
            }

            BuffersAvailable -= pInput->cBuffers ;
            BuffersConsumed += pInput->cBuffers ;
        }
#endif

    }
    else
    {
        RtlZeroMemory(
            &Args->sbdInput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }

    if (ARGUMENT_PRESENT(pOutput))
    {
        SecpSecBufferDescToLpc( &Args->sbdOutput, pOutput );


#ifndef BUILD_WOW64
        if ( pOutput->cBuffers < BuffersAvailable )
        {
            pOutputBuffers = pInputBuffers + BuffersConsumed;

            Args->sbdOutput.pBuffers = (PSecBuffer) ((LONG_PTR) pOutputBuffers - (LONG_PTR) Args);
            RtlCopyMemory(  pOutputBuffers,
                            pOutput->pBuffers,
                            sizeof(SecBuffer) * pOutput->cBuffers);

            BuffersAvailable -= pOutput->cBuffers ;
            BuffersConsumed += pOutput->cBuffers ;
        }

        //
        // if the client asked the security layer to allocate
        // the memory, and we have a valid number of output
        // buffers available, reset them all to NULL so that
        // it's easier to keep track of them.
        //

        if ( ( fContextReq & ISC_REQ_ALLOCATE_MEMORY ) &&
             ( pOutputBuffers != NULL ) )
        {
            ULONG i;
            for (i = 0; i < pOutput->cBuffers ; i++ )
            {
                pOutputBuffers[i].pvBuffer = NULL;
            }
        }
#else
        if ( pOutput->cBuffers < BuffersAvailable )
        {
            PSEC_BUFFER_LPC Data ;
            ULONG i ;
            PSecBuffer NarrowOutput ;


            pOutputBuffers = pInputBuffers + BuffersConsumed ;

            Data = (PSEC_BUFFER_LPC) ((LONG_PTR) pOutputBuffers - (LONG_PTR) Args );
            Args->sbdOutput.pBuffers = (PVOID_LPC) Data ;

            Data = (PSEC_BUFFER_LPC) pOutputBuffers ;

            NarrowOutput = pOutput->pBuffers ;

            for ( i = 0 ; i < pOutput->cBuffers ; i++ )
            {
                if ( (fContextReq & ISC_REQ_ALLOCATE_MEMORY ) != 0 )
                {
                    NarrowOutput->pvBuffer = NULL ;
                }

                SecpSecBufferToLpc( Data, NarrowOutput );
                Data++;
                NarrowOutput++;


            }

            BuffersAvailable -= pOutput->cBuffers ;
            BuffersConsumed += pOutput->cBuffers ;
        }
#endif


    }
    else
    {
        RtlZeroMemory(
            &Args->sbdOutput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }


    if ( BuffersConsumed > 0 )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //
        ApiBuffer.pmMessage.u1.s1.TotalLength = 
            LPC_TOTAL_LENGTH( BuffersConsumed  * sizeof( SEC_BUFFER_LPC ) );

        ApiBuffer.pmMessage.u1.s1.DataLength = 
            LPC_DATA_LENGTH( BuffersConsumed * sizeof( SEC_BUFFER_LPC ) );

        
    }

    Args->ContextData.pvBuffer = NULL;
    Args->ContextData.cbBuffer = 0;
    Args->ContextData.BufferType = 0;
    Args->MappedContext = FALSE;


    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"    scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (!NT_SUCCESS(scRet))
    {
        goto AcceptExitPoint;
    }

    //
    // Either way we want to copy this - it will have updated size
    // information
    //

    if (ARGUMENT_PRESENT(pOutput))
    {
        if ( (ULONG_PTR) Args->sbdOutput.pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
        {
#ifndef BUILD_WOW64
            RtlCopyMemory(  pOutput->pBuffers,
                            pOutputBuffers,
                            sizeof(SecBuffer) * Args->sbdOutput.cBuffers );
#else
            ULONG i ;
            PSEC_BUFFER_LPC Data ;
            PSecBuffer NarrowOutput ;

            Data = pOutputBuffers ;
            NarrowOutput = pOutput->pBuffers ;
            for (i = 0 ; i < Args->sbdOutput.cBuffers ; i++ )
            {
                SecpLpcBufferToSecBuffer( NarrowOutput, Data );
                NarrowOutput++ ;
                Data ++;
            }
#endif
        }
    }

    *pfContextAttr = Args->fContextAttr;

    if ((!NT_SUCCESS(ApiBuffer.ApiMessage.scRet)) &&
        ((Args->fContextAttr & ASC_RET_EXTENDED_ERROR) == 0 ) )
    {
        DebugLog((DEB_TRACE,"Accept FAILED, exiting now\n"));
        goto AcceptExitPoint;
    }

    *phNewContext   = Args->hNewContext;
    SecpLpcBufferToSecBuffer( ContextData, &Args->ContextData );
    *MappedContext  = Args->MappedContext;
    if (ARGUMENT_PRESENT(ptsExpiry))
    {
        *ptsExpiry = Args->tsExpiry;
    }


    DebugLog((DEB_TRACE_CALL,"    Ctxt Out = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
              phNewContext->dwUpper, phNewContext->dwLower));


    if ( (ULONG_PTR) Args->sbdInput.pBuffers < PORT_MAXIMUM_MESSAGE_LENGTH )
    {
        for ( i = 0 ; i < Args->sbdInput.cBuffers ; i++ )
        {
            if ( ((Args->sbData[i].BufferType == SECBUFFER_EXTRA ) ||
                 (Args->sbData[i].BufferType == SECBUFFER_MISSING ) )
#if DBG
                 && (pInput->pBuffers[i].BufferType == SECBUFFER_EMPTY )
#endif
                 )
            {
                SecpLpcBufferToSecBuffer( &pInput->pBuffers[i], &Args->sbData[i] );

                DebugLog(( DEB_TRACE_CALL, "    InputBuffer %d Changed from Empty to %d, @" POINTER_FORMAT " %d bytes\n",
                                i, pInput->pBuffers[i].BufferType,
                                pInput->pBuffers[i].pvBuffer,
                                pInput->pBuffers[i].cbBuffer ));
            }
        }
    }


AcceptExitPoint:

    FreeClient(pClient);

    *Flags = ApiBuffer.ApiMessage.Args.SpmArguments.fAPI ;

    return(ApiBuffer.ApiMessage.scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   SecpDeleteSecurityContext
//
//  Synopsis:   LPC client stub for DeleteSecurityContext
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SecpDeleteSecurityContext(
    ULONG fDelete,
    PCONTEXT_HANDLE_LPC phContext)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, DeleteContext );

    SEC_PAGED_CODE();



    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"DeleteSecurityContext\n"));

    PREPARE_MESSAGE(ApiBuffer, DeleteContext);


    Args->hContext    = *phContext;

    if (fDelete & SECP_DELETE_NO_BLOCK)
    {
        ApiBuffer.ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_EXEC_NOW;
    }

    DebugLog((DEB_TRACE_CALL,"    Context = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
                    phContext->dwUpper, phContext->dwLower));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"Delete.ApiMessage.scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (scRet == STATUS_SUCCESS)
    {
        scRet = ApiBuffer.ApiMessage.scRet;

    }

    FreeClient(pClient);
    return(scRet);

}


//+-------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
SecpApplyControlToken(
    PCONTEXT_HANDLE_LPC phContext,
    PSecBufferDesc      pInput)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, ApplyToken );
    ULONG i;

    SEC_PAGED_CODE();


    if (pInput->cBuffers > MAX_SECBUFFERS)
    {
        DebugLog((DEB_ERROR,"Too many secbuffers passed in : %d\n",
                pInput->cBuffers));
        return(SEC_E_INVALID_TOKEN);
    }

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"ApplyControlToken\n"));

    PREPARE_MESSAGE(ApiBuffer, ApplyToken);

    Args->hContext    = *phContext;

    if (ARGUMENT_PRESENT(pInput))
    {
        SecpSecBufferDescToLpc( &Args->sbdInput, pInput );

        for ( i = 0 ; i < pInput->cBuffers ; i++ )
        {
            SecpSecBufferToLpc( &Args->sbInputBuffer[ i ],
                                &pInput->pBuffers[ i ] );
        }

    }
    else
    {
        RtlZeroMemory(
            &Args->sbdInput,
            sizeof( SEC_BUFFER_DESC_LPC )
            );
    }


    DebugLog((DEB_TRACE_CALL,"    Context = " POINTER_FORMAT " : " POINTER_FORMAT "\n",
              phContext->dwUpper, phContext->dwLower));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"ApplyToken scRet = %x\n", ApiBuffer.ApiMessage.scRet));


    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);
    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpQueryContextAttributes
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [pBuffer]     --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SecpQueryContextAttributes(
    PVOID_LPC   ContextPointer,
    PCONTEXT_HANDLE_LPC phContext,
    ULONG       ulAttribute,
    PVOID       pBuffer,
    PULONG      Allocs,
    PVOID *     Buffers,
    PULONG      Flags
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, QueryContextAttr );
    ULONG i;

    SEC_PAGED_CODE();

    *Allocs = 0;

    scRet = IsOkayToExec(&pClient);

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"QueryContextAttributes\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, QueryContextAttr, *Flags, ContextPointer);

    Args->hContext    = *phContext;
    Args->ulAttribute = ulAttribute ;
    Args->pBuffer     = (PVOID_LPC) pBuffer ;


    DebugLog((DEB_TRACE_CALL,"    Context = " POINTER_FORMAT ":" POINTER_FORMAT "\n",
              phContext->dwUpper, phContext->dwLower));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"QueryContextAttributes scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( ApiBuffer.ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_ALLOCS )
        {
            *Allocs = Args->Allocs ;

            for ( i = 0 ; i < Args->Allocs ; i++ )
            {
                *Buffers++ = (PVOID) Args->Buffers[ i ];
            }

        }
        else
        {
            *Allocs = 0 ;
        }
    }

    FreeClient(pClient);
    return(scRet);

}



//+---------------------------------------------------------------------------
//
//  Function:   SecpSetContextAttributes
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [pBuffer]     --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-20-00   CliffV   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SecpSetContextAttributes(
    PCONTEXT_HANDLE_LPC phContext,
    ULONG       ulAttribute,
    PVOID       pBuffer,
    ULONG cbBuffer
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, SetContextAttr );
    ULONG i;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"SetContextAttributes\n"));

    PREPARE_MESSAGE(ApiBuffer, SetContextAttr);

    Args->hContext    = *phContext;
    Args->ulAttribute = ulAttribute ;
    Args->pBuffer     = (PVOID_LPC) pBuffer ;
    Args->cbBuffer    = cbBuffer ;


    DebugLog((DEB_TRACE_CALL,"    Context = " POINTER_FORMAT ":" POINTER_FORMAT "\n",
              phContext->dwUpper, phContext->dwLower));

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"SetContextAttributes scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    FreeClient(pClient);
    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\austub.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    austub.c

Abstract:

    Local Security Authority AUTHENTICATION service client stubs.

Author:

    Jim Kelly (JimK) 20-Feb-1991

Environment:   Kernel or User Modes

Revision History:

--*/

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>
#include <zwapi.h>
}

#ifdef KERNEL_MODE
//
// Unfortunately the security header files are just not at all constructed
// in a manner compatible with kernelmode. For some reason they are totally
// reliant on usermode header definitions. Just assume the text and const
// pragma's will work. If they don't work on an architecture, they can be
// fixed.
//
#pragma alloc_text(PAGE,LsaFreeReturnBuffer)
#pragma alloc_text(PAGE,LsaRegisterLogonProcess)
#pragma alloc_text(PAGE,LsaConnectUntrusted)
#pragma alloc_text(PAGE,LsaLookupAuthenticationPackage)
#pragma alloc_text(PAGE,LsaLogonUser)
#pragma alloc_text(PAGE,LsaCallAuthenticationPackage)
#pragma alloc_text(PAGE,LsaDeregisterLogonProcess)
#pragma const_seg("PAGECONST")

#define SecpLsaDispatchFn  NULL

#else

extern PLSA_DISPATCH_FN    SecpLsaDispatchFn ;

#endif


const WCHAR LsapEvent[] = L"\\SECURITY\\LSA_AUTHENTICATION_INITIALIZED";
const WCHAR LsapPort[] = L"\\LsaAuthenticationPort";


NTSTATUS
LsaFreeReturnBuffer (
    IN PVOID Buffer
    )


/*++

Routine Description:

    Some of the LSA authentication services allocate memory buffers to
    hold returned information.  This service is used to free those buffers
    when no longer needed.

Arguments:

    Buffer - Supplies a pointer to the return buffer to be freed.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    Others - returned by NtFreeVirtualMemory().

--*/

{

    NTSTATUS Status;
    ULONG_PTR Length;

    SEC_PAGED_CODE();

    Length = 0;
    Status = ZwFreeVirtualMemory(
                 NtCurrentProcess(),
                 &Buffer,
                 &Length,
                 MEM_RELEASE
                 );

    return Status;
}


NTSTATUS
LsaRegisterLogonProcess(
    IN PSTRING LogonProcessName,
    OUT PHANDLE LsaHandle,
    OUT PLSA_OPERATIONAL_MODE SecurityMode
    )

/*++

Routine Description:

    This service connects to the LSA server and verifies that the caller
    is a legitimate logon process. this is done by ensuring the caller has
    the SeTcbPrivilege privilege. It also opens the caller's process for
    PROCESS_DUP_HANDLE access in anticipation of future LSA authentication
    calls.

Arguments:

    LogonProcessName  - Provides a name string that identifies the logon
        process.  This should be a printable name suitable for display to
        administrators.  For example, "User32LogonProces" might be used
        for the windows logon process name.  No check is made to determine
        whether the name is already in use.  This name must NOT be longer
        than 127 bytes long.

    LsaHandle - Receives a handle which must be provided in future
        authenticaiton services.

    SecurityMode - The security mode the system is running under.  This
        value typically influences the logon user interface.  For example,
        a system running with password control will prompt for username
        and passwords before bringing up the UI shell.  One running without
        password control would typically automatically bring up the UI shell
        at system initialization.

Return Value:

    STATUS_SUCCESS - The call completed successfully.

    STATUS_PRIVILEGE_NOT_HELD  - Indicates the caller does not have the
        privilege necessary to act as a logon process.  The SeTcbPrivilege
        privilege is needed.


    STATUS_NAME_TOO_LONG - The logon process name provided is too long.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    UNICODE_STRING PortName, EventName;
    LSAP_AU_REGISTER_CONNECT_INFO ConnectInfo;
    ULONG ConnectInfoLength;
    ALIGN_WOW64 SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE EventHandle;

    SEC_PAGED_CODE();

    //
    // Validate input parameters
    //

    if (LogonProcessName->Length > LSAP_MAX_LOGON_PROC_NAME_LENGTH) {
        return STATUS_NAME_TOO_LONG;
    }


    //
    // Wait for LSA to initialize...
    //


    RtlInitUnicodeString( &EventName, LsapEvent );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = NtWaitForSingleObject( EventHandle, TRUE, NULL);
    IgnoreStatus = NtClose( EventHandle );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.Length = sizeof( DynamicQos );
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = FALSE;




    //
    // Set up the connection information to contain the logon process
    // name.
    //

    ConnectInfoLength = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    strncpy(
        ConnectInfo.LogonProcessName,
        LogonProcessName->Buffer,
        LogonProcessName->Length
        );
    ConnectInfo.LogonProcessNameLength = LogonProcessName->Length;
    ConnectInfo.LogonProcessName[ConnectInfo.LogonProcessNameLength] = '\0';


    //
    // Connect to the LSA server
    //

    RtlInitUnicodeString(&PortName,LsapPort);
    Status = ZwConnectPort(
                 LsaHandle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 &ConnectInfo,
                 &ConnectInfoLength
                 );
    if ( !NT_SUCCESS(Status) ) {
        //DbgPrint("LSA AU: Logon Process Register failed %lx\n",Status);
        return Status;
    }

    if ( !NT_SUCCESS(ConnectInfo.CompletionStatus) ) {
        //DbgPrint("LSA AU: Logon Process Register rejected %lx\n",ConnectInfo.CompletionStatus);
        ;
    }

    (*SecurityMode) = ConnectInfo.SecurityMode;

    return ConnectInfo.CompletionStatus;

}


NTSTATUS
LsaConnectUntrusted(
    OUT PHANDLE LsaHandle
    )

/*++

Routine Description:

    This service connects to the LSA server and sets up an untrusted
    connection.  It does not check anything about the caller.

Arguments:


    LsaHandle - Receives a handle which must be provided in future
        authenticaiton services.


Return Value:

    STATUS_SUCCESS - The call completed successfully.

--*/

{
    NTSTATUS Status, IgnoreStatus;
    UNICODE_STRING PortName, EventName;
    LSAP_AU_REGISTER_CONNECT_INFO ConnectInfo;
    ULONG ConnectInfoLength;
    ALIGN_WOW64 SECURITY_QUALITY_OF_SERVICE DynamicQos;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE EventHandle;

    SEC_PAGED_CODE();


    //
    // Wait for LSA to initialize...
    //


    RtlInitUnicodeString( &EventName, LsapEvent );
    InitializeObjectAttributes(
        &ObjectAttributes,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &ObjectAttributes );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = NtWaitForSingleObject( EventHandle, TRUE, NULL);
    IgnoreStatus = NtClose( EventHandle );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = FALSE;




    //
    // Set up the connection information to contain the logon process
    // name.
    //

    ConnectInfoLength = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    RtlZeroMemory(
        &ConnectInfo,
        ConnectInfoLength
        );


    //
    // Connect to the LSA server
    //

    RtlInitUnicodeString(&PortName,LsapPort);
    Status = ZwConnectPort(
                 LsaHandle,
                 &PortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 &ConnectInfo,
                 &ConnectInfoLength
                 );
    if ( !NT_SUCCESS(Status) ) {
        //DbgPrint("LSA AU: Logon Process Register failed %lx\n",Status);
        return Status;
    }

    if ( !NT_SUCCESS(ConnectInfo.CompletionStatus) ) {
        //DbgPrint("LSA AU: Logon Process Register rejected %lx\n",ConnectInfo.CompletionStatus);
        ;
    }

    return ConnectInfo.CompletionStatus;

}


NTSTATUS
LsaLookupAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN PSTRING PackageName,
    OUT PULONG AuthenticationPackage
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    PackageName - Supplies a string which identifies the
        Authentication Package.  "MSV1.0" is the standard NT
        authentication package name.  The package name must not
        exceed 127 bytes in length.

    AuthenticationPackage - Receives an ID used to reference the
        authentication package in subsequent authentication services.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

    STATUS_NAME_TOO_LONG - The authentication package name provided is too
        long.



Routine Description:

    This service is used to obtain the ID of an authentication package.
    This ID may then be used in subsequent authentication services.


--*/

{

    NTSTATUS Status;
    ALIGN_WOW64 LSAP_AU_API_MESSAGE Message;
    PLSAP_LOOKUP_PACKAGE_ARGS Arguments;

    SEC_PAGED_CODE();

    //
    // Validate input parameters
    //

    if (PackageName->Length > LSAP_MAX_PACKAGE_NAME_LENGTH) {
        return STATUS_NAME_TOO_LONG;
    }



    Arguments = &Message.Arguments.LookupPackage;

    //
    // Set arguments
    //

    strncpy(Arguments->PackageName, PackageName->Buffer, PackageName->Length);
    Arguments->PackageNameLength = PackageName->Length;
    Arguments->PackageName[Arguments->PackageNameLength] = '\0';



    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuLookupPackageApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    if( SecpLsaDispatchFn == NULL )
    {
        Status = ZwRequestWaitReplyPort(
                LsaHandle,
                (PPORT_MESSAGE) &Message,
                (PPORT_MESSAGE) &Message
                );
    } else {
        Status = SecpLsaDispatchFn( (PSPM_LPC_MESSAGE)&Message );
    }

    //
    // Return the authentication package ID.
    // If the call failed for any reason, this will be garbage,
    // but who cares.
    //

    (*AuthenticationPackage) = Arguments->AuthenticationPackage;


    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
        if ( !NT_SUCCESS(Status) ) {
            //DbgPrint("LSA AU: Package Lookup Failed %lx\n",Status);
            ;
        }
    } else {
#if DBG
        DbgPrint("LSA AU: Package Lookup NtRequestWaitReply Failed %lx\n",Status);
#else
        ;
#endif
    }

    return Status;
}


NTSTATUS
LsaLogonUser (
    IN HANDLE LsaHandle,
    IN PSTRING OriginName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG AuthenticationPackage,
    IN PVOID AuthenticationInformation,
    IN ULONG AuthenticationInformationLength,
    IN PTOKEN_GROUPS LocalGroups OPTIONAL,
    IN PTOKEN_SOURCE SourceContext,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PHANDLE Token,
    OUT PQUOTA_LIMITS Quotas,
    OUT PNTSTATUS SubStatus
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    OriginName - Supplies a string which identifies the origin of the
        logon attempt.  For example, "TTY1" specify terminal 1, or
        "LAN Manager - remote node JAZZ" might indicate a network
        logon attempt via LAN Manager from a remote node called
        "JAZZ".

    LogonType - Identifies the type of logon being attempted.  If the
        type is Interactive or Batch then a PrimaryToken will be
        generated to represent this new user.  If the type is Network
        then an impersonation token will be generated.

    AuthenticationPackage - Supplies the ID of the authentication
        package to use for the logon attempt.  The standard
        authentication package name for NT is called "MSV1.0".

    AuthenticationInformation - Supplies the authentication
        information specific to the authentication package.  It is
        expected to include identification and authentication
        information such as user name and password.

    AuthenticationInformationLength - Indicates the length of the
        authentication information buffer.

    LocalGroups - Optionally supplies a list of additional group
        identifiers to add to the authenticated user's token.  The
        WORLD group will always be included in the token.  A group
        identifying the logon type (INTERACTIVE, NETWORK, BATCH) will
        also automatically be included in the token.

    SourceContext - Supplies information identifying the source
        component (e.g., session manager) and context that may be
        useful to that component.  This information will be included
        in the token and may later be retrieved.

    ProfileBuffer - Receives a pointer to any returned profile and
        accounting information about the logged on user's account.
        This information is authentication package specific and
        provides such information as the logon shell, home directory
        and so forth.  For an authentication package value of
        "MSV1.0", a MSV1_0_PROFILE_DATA data structure is returned.

        This buffer is allocated by this service and must be freed
        using LsaFreeReturnBuffer() when no longer needed.

    ProfileBufferLength - Receives the length (in bytes) of the
        returned profile buffer.

    LogonId - Points to a buffer which receives a LUID that uniquely
        identifies this logon session.  This LUID was assigned by the
        domain controller which authenticated the logon information.

    Token - Receives a handle to the new token created for this
        authentication.

    Quotas - When a primary token is returned, this parameter will be
        filled in with process quota limits that are to be assigned
        to the newly logged on user's initial process.

    SubStatus - If the logon failed due to account restrictions, this
        out parameter will receive an indication as to why the logon
        failed.  This value will only be set to a meaningful value if
        the user has a legitimate account, but may not currently
        logon for some reason.  The substatus values for
        authentication package "MSV1.0" are:

            STATUS_INVALID_LOGON_HOURS

            STATUS_INVALID_WORKSTATION

            STATUS_PASSWORD_EXPIRED

            STATUS_ACCOUNT_DISABLED

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  Indicates the caller does not have
        enough quota to allocate the profile data being returned by
        the authentication package.

    STATUS_NO_LOGON_SERVERS - Indicates that no domain controllers
        are currently able to service the authentication request.

    STATUS_LOGON_FAILURE - Indicates the logon attempt failed.  No
        indication as to the reason for failure is given, but typical
        reasons include mispelled usernames, mispelled passwords.

    STATUS_ACCOUNT_RESTRICTION - Indicates the user account and
        password were legitimate, but that the user account has some
        restriction preventing successful logon at this time.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

    STATUS_BAD_VALIDATION_CLASS - The authentication information
        provided is not a validation class known to the specified
        authentication package.

Routine Description:

    This routine is used to authenticate a user logon attempt.  This is
    used only for user's initial logon, necessary to gain access to NT
    OS/2.  Subsequent (supplementary) authentication requests must be done
    using LsaCallAuthenticationPackage().  This service will cause a logon
    session to be created to represent the new logon.  It will also return
    a token representing the newly logged on user.

--*/

{

    NTSTATUS Status;
    ALIGN_WOW64 LSAP_AU_API_MESSAGE Message;
    PLSAP_LOGON_USER_ARGS Arguments;

    SEC_PAGED_CODE();


    Arguments = &Message.Arguments.LogonUser;

    //
    // Set arguments
    //

    Arguments->AuthenticationPackage      = AuthenticationPackage;
    Arguments->AuthenticationInformation  = (PVOID_AU) AuthenticationInformation;
    Arguments->AuthenticationInformationLength = AuthenticationInformationLength;

    SecpStringToLpc( &Arguments->OriginName, OriginName );

    Arguments->LogonType                  = LogonType;
    Arguments->SourceContext              = (*SourceContext);

    Arguments->LocalGroups                = (PVOID_AU) LocalGroups;
    if ( ARGUMENT_PRESENT(LocalGroups) ) {
        Arguments->LocalGroupsCount       = LocalGroups->GroupCount;
    } else {
        Arguments->LocalGroupsCount       = 0;
    }


    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuLogonUserApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    if( SecpLsaDispatchFn == NULL )
    {
        Status = ZwRequestWaitReplyPort(
                LsaHandle,
                (PPORT_MESSAGE) &Message,
                (PPORT_MESSAGE) &Message
                );
    } else {
        Status = SecpLsaDispatchFn( (PSPM_LPC_MESSAGE)&Message );
    }

    //
    // We may be returning bogus return values here, but it doesn't
    // matter.  They will just be ignored if an error occured.
    //

    (*SubStatus)           = Arguments->SubStatus;

    if ( NT_SUCCESS( Status ) )
    {
        Status = Message.ReturnedStatus ;

        // Don't not clear the ProfileBuffer even in case of error, cause
        // subauth packages need the ProfileBuffer.
        *ProfileBuffer = (PVOID) Arguments->ProfileBuffer ;
        *ProfileBufferLength = Arguments->ProfileBufferLength ;

        if ( NT_SUCCESS( Status ) )
        {
            *LogonId = Arguments->LogonId ;
            *Token = (HANDLE) Arguments->Token ;
            *Quotas = Arguments->Quotas ;
        } else {
            *Token = NULL;
        }

    } else {

        *ProfileBuffer = NULL ;
        *Token = NULL ;
    }

    return Status;


}


NTSTATUS
LsaCallAuthenticationPackage (
    IN HANDLE LsaHandle,
    IN ULONG AuthenticationPackage,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer OPTIONAL,
    OUT PULONG ReturnBufferLength OPTIONAL,
    OUT PNTSTATUS ProtocolStatus OPTIONAL
    )

/*++

Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.

    AuthenticationPackage - Supplies the ID of the authentication
        package to use for the logon attempt.  The standard
        authentication package name for NT is called "MSV1.0".

    ProtocolSubmitBuffer - Supplies a protocol message specific to
        the authentication package.

    SubmitBufferLength - Indicates the length of the submitted
        protocol message buffer.

    ProtocolReturnBuffer - Receives a pointer to a returned protocol
        message whose format and semantics are specific to the
        authentication package.

        This buffer is allocated by this service and must be freed
        using LsaFreeReturnBuffer() when no longer needed.

    ReturnBufferLength - Receives the length (in bytes) of the
        returned profile buffer.

    ProtocolStatus - Assuming the services completion is
        STATUS_SUCCESS, this parameter will receive completion status
        returned by the specified authentication package.  The list
        of status values that may be returned are authentication
        package specific.

Return Status:

    STATUS_SUCCESS - The call was made to the authentication package.
        The ProtocolStatus parameter must be checked to see what the
        completion status from the authentication package is.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the call could
        not be completed because the client does not have sufficient
        quota to allocate the return buffer.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.

Routine Description:

    This routine is used when a logon process needs to communicate with an
    authentication package.  There are several reasons why a logon process
    may want to do this.  Some examples are:

     o  To implement multi-message authentication protocols (such as
        the LAN Manager Challenge-response protocol.

     o  To notify the authentication package of interesting state
        change information, such as LAN Manager notifying the MSV1.0
        package that a previously unreachable domain controller is
        now reachable.  In this example, the authentication package
        would re-logon any users logged on to that domain controller.


--*/

{

    NTSTATUS Status;
    ALIGN_WOW64 LSAP_AU_API_MESSAGE Message;
    PLSAP_CALL_PACKAGE_ARGS Arguments;


    SEC_PAGED_CODE();

    Arguments = &Message.Arguments.CallPackage;

    //
    // Set arguments
    //

    Arguments->AuthenticationPackage = AuthenticationPackage;
    Arguments->ProtocolSubmitBuffer  = (PVOID_AU) ProtocolSubmitBuffer;
    Arguments->SubmitBufferLength    = SubmitBufferLength;



    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuCallPackageApi;
    Message.PortMessage.u1.s1.DataLength = sizeof(*Arguments) + 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    if( SecpLsaDispatchFn == NULL )
    {
        Status = ZwRequestWaitReplyPort(
                LsaHandle,
                (PPORT_MESSAGE) &Message,
                (PPORT_MESSAGE) &Message
                );
    } else {
        Status = SecpLsaDispatchFn( (PSPM_LPC_MESSAGE)&Message );
    }

    //
    // We may be returning bogus return values here, but it doesn't
    // matter.  They will just be ignored if an error occured.
    //

    if ( ProtocolReturnBuffer )
    {
        (*ProtocolReturnBuffer) = (PVOID) Arguments->ProtocolReturnBuffer;
    }

    if ( ReturnBufferLength )
    {
        (*ReturnBufferLength)   = Arguments->ReturnBufferLength;
    }

    if ( ProtocolStatus )
    {
        (*ProtocolStatus)       = Arguments->ProtocolStatus;
    }


    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
#if DBG
        if ( !NT_SUCCESS(Status) ) {
            DbgPrint("LSA AU: Call Package Failed %lx\n",Status);
        }
    } else {
        DbgPrint("LSA AU: Call Package Failed %lx\n",Status);
#endif //DBG
    }



    return Status;

}


NTSTATUS
LsaDeregisterLogonProcess (
    IN HANDLE LsaHandle
    )

/*++

    This function deletes the caller's logon process context.


                        ---  WARNING  ---

        Logon Processes are part of the Trusted Computer Base, and,
        as such, are expected to be debugged to a high degree.  If
        a logon process deregisters, we will believe it.  This
        allows us to re-use the old Logon Process context value.
        If the Logon process accidently uses its context value
        after freeing it, strange things may happen.  LIkewise,
        if a client calls to release a context that has already
        been released, then LSA may grind to a halt.



Arguments:

    LsaHandle - Supplies a handle obtained in a previous call to
        LsaRegisterLogonProcess.


Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.


--*/

{

    NTSTATUS Status;
    ALIGN_WOW64 LSAP_AU_API_MESSAGE Message;

    SEC_PAGED_CODE();

    //
    // Call the Local Security Authority Server.
    //

    Message.ApiNumber = LsapAuDeregisterLogonProcessApi;
    Message.PortMessage.u1.s1.DataLength = 8;
    Message.PortMessage.u1.s1.TotalLength = sizeof(Message);
    Message.PortMessage.u2.ZeroInit = 0L;

    if( SecpLsaDispatchFn == NULL )
    {
        Status = ZwRequestWaitReplyPort(
                LsaHandle,
                (PPORT_MESSAGE) &Message,
                (PPORT_MESSAGE) &Message
                );
    } else {
        Status = SecpLsaDispatchFn( (PSPM_LPC_MESSAGE)&Message );
    }



    if ( NT_SUCCESS(Status) ) {
        Status = Message.ReturnedStatus;
        if ( NT_SUCCESS(Status) ) {

            NTSTATUS TempStatus;
            TempStatus = ZwClose(LsaHandle);
            ASSERT(NT_SUCCESS(TempStatus));
        }
#if DBG
        else {
            if ( Status != SEC_E_SECPKG_NOT_FOUND )
            {
                DbgPrint("LSA AU: DeRregisterLogonProcess Failed 0x%lx\n",Status);
            }
        }
    } else {
        DbgPrint("LSA AU: NtRequestWaitReply Failed 0x%lx\n",Status);
#endif
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\efsp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       efsp.cxx
//
//  Contents:   Stub routines for EFS clients.  Kernel mode
//              and usermode stubs are all in this file.
//
//  Classes:
//
//  Functions:
//
//  History:    3-4-94      RobertRe      Created
//
//----------------------------------------------------------------------------


#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <efsstruc.h>
#include <lpcefs.h>
#include "spmlpcp.h"
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, EfspGenerateKey)
#endif

extern "C"
NTSTATUS
SEC_ENTRY
EfspGenerateKey(
   PEFS_DATA_STREAM_HEADER * EfsStream,
   PEFS_DATA_STREAM_HEADER   DirectoryEfsStream,
   ULONG                     DirectoryEfsStreamLength,
   PEFS_KEY *                Fek,
   PVOID *                   BufferBase,
   PULONG                    BufferLength
   )
/*++

Routine Description:

    Private stub called by the EFS driver to do the work of the
    EfsGenerateKey server call.  The caller is in ksecdd.sys.

Arguments:

   EfsStream - Returns a pointer to an EFS_DATA_STREAM_HEADER.

   DirectoryEfsStream - The EFS stream from the containing directory.
        If present, may be used to calculate the EFS stream for the
        current file.

   DirectoryEfsStreamLength - The lenght in bytes of the passed
        EFS stream.

   Fek - Returns a pointer to a structure of type PEFS_KEY

   BufferBase -

   BufferLength -



Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EfsGenerateKey );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EfsGenerateKey\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, EfsGenerateKey, 0, 0 );

    Args->EfsStream = NULL;
    Args->Fek       = NULL;
    Args->BufferBase = NULL;
    Args->BufferLength = 0;
    Args->DirectoryEfsStream = DirectoryEfsStream;
    Args->DirectoryEfsStreamLength = DirectoryEfsStreamLength;

    scRet = (NTSTATUS)CallSPM(pClient,
                                &ApiBuffer,
                                &ApiBuffer);

    DebugLog((DEB_TRACE,"EfsGenerateKey scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS( scRet )) {
            *Fek = (PEFS_KEY)(Args->Fek);
            *EfsStream = (PEFS_DATA_STREAM_HEADER)(Args->EfsStream);
            *BufferBase = Args->BufferBase;
            *BufferLength = Args->BufferLength;

        }
    }

    FreeClient(pClient);

    return scRet;
}


extern "C"
NTSTATUS
SEC_ENTRY
EfspGenerateDirEfs(
    PEFS_DATA_STREAM_HEADER   DirectoryEfsStream,
    ULONG                     DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * EfsStream,
    PVOID *                   BufferBase,
    PULONG                    BufferLength
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EfsGenerateDirEfs );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EfsGenerateKey\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, EfsGenerateDirEfs, 0, 0 );

    Args->DirectoryEfsStream = DirectoryEfsStream;
    Args->DirectoryEfsStreamLength = DirectoryEfsStreamLength;
    Args->EfsStream = NULL;
    Args->BufferBase = NULL;
    Args->BufferLength = 0;

    scRet = (NTSTATUS)CallSPM(pClient,
                               &ApiBuffer,
                               &ApiBuffer);

    DebugLog((DEB_TRACE,"EfspGenerateDirEfs scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS( scRet )) {

            *EfsStream = (PEFS_DATA_STREAM_HEADER)(Args->EfsStream);
            *BufferBase = Args->BufferBase;
            *BufferLength = Args->BufferLength;
        }
    }

    FreeClient(pClient);

    return scRet;
}

extern "C"
NTSTATUS
SEC_ENTRY
EfspDecryptFek(
    PEFS_KEY *                Fek,
    PEFS_DATA_STREAM_HEADER   EfsStream,
    ULONG                     EfsStreamLength,
    ULONG                     OpenType,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID *                   BufferBase,
    PULONG                    BufferLength
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EfsDecryptFek );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EfsGenerateKey\n"));

    PREPARE_MESSAGE_EX(ApiBuffer, EfsDecryptFek, 0, 0);

    Args->Fek       = NULL;
    Args->BufferBase = NULL;
    Args->BufferLength = 0;
    Args->EfsStream = EfsStream;
    Args->OpenType = OpenType;
    Args->NewEfs = NULL;
    Args->EfsStreamLength = EfsStreamLength;

    scRet = (NTSTATUS)CallSPM(pClient,
                                &ApiBuffer,
                                &ApiBuffer);

    DebugLog((DEB_TRACE,"EfsGenerateKey scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS( scRet )) {

            *Fek = (PEFS_KEY)(Args->Fek);
            *NewEfs = (PEFS_DATA_STREAM_HEADER)(Args->NewEfs);
            *BufferBase = Args->BufferBase;
            *BufferLength = Args->BufferLength;
        }
    }

    FreeClient(pClient);

    return scRet;
}



extern "C"
NTSTATUS
SEC_ENTRY
EfspGenerateSessionKey(
    PEFS_INIT_DATAEXG  InitData
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EfsGenerateSessionKey );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EfsGenerateSessionKey\n"));

    PREPARE_MESSAGE(ApiBuffer, EfsGenerateSessionKey);

    Args->InitDataExg = NULL;

    scRet = (NTSTATUS)CallSPM(pClient,
                                &ApiBuffer,
                                &ApiBuffer);

    DebugLog((DEB_TRACE,"EfsGenerateKey scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS( scRet )) {

            RtlCopyMemory( InitData, &Args->InitDataExg, sizeof( EFS_INIT_DATAEXG ) );
        }
    }

    FreeClient(pClient);

    return scRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\misc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       misc.cxx
//
//  Contents:   Miscellaneous functions for security clients
//
//  Classes:
//
//  Functions:
//
//  History:    3-4-94      MikeSw      Created
//
//----------------------------------------------------------------------------


#include "secpch2.hxx"
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
#include <align.h>
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, SecpGetUserInfo)
#pragma alloc_text(PAGE, SecpEnumeratePackages)
#pragma alloc_text(PAGE, SecpQueryPackageInfo)
#pragma alloc_text(PAGE, SecpGetUserName)
#pragma alloc_text(PAGE, SecpGetLogonSessionData)
#pragma alloc_text(PAGE, SecpEnumLogonSession)
#pragma alloc_text(PAGE, SecpLookupAccountSid)
#pragma alloc_text(PAGE, SecpLookupAccountName)
#pragma alloc_text(PAGE, CredMarshalTargetInfo)
#endif

//
// Same as the SecPkgInfoW structure from SSPI, but with wide pointers:
//

typedef struct _SECPKG_INFO_LPC {
    unsigned long fCapabilities;        // Capability bitmask
    unsigned short wVersion;            // Version of driver
    unsigned short wRPCID;              // ID for RPC Runtime
    unsigned long cbMaxToken;           // Size of authentication token (max)
    PWSTR_LPC Name ;
    PWSTR_LPC Comment ;
} SECPKG_INFO_LPC, * PSECPKG_INFO_LPC ;

//
// Same as the SECURITY_LOGON_SESSION_DATA from secint.h, but with wide pointers
//
typedef struct _SECURITY_LOGON_SESSION_DATA_LPC {
    ULONG           Size ;
    LUID            LogonId ;
    SECURITY_STRING_LPC UserName ;
    SECURITY_STRING_LPC LogonDomain ;
    SECURITY_STRING_LPC AuthenticationPackage ;
    ULONG           LogonType ;
    ULONG           Session ;
    PVOID           Sid ;
    LARGE_INTEGER   LogonTime ;
} SECURITY_LOGON_SESSION_DATA_LPC, * PSECURITY_LOGON_SESSION_DATA_LPC ;

//+---------------------------------------------------------------------------
//
//  Function:   SecpGetUserInfo
//
//  Synopsis:   Get the SecurityUserData of the logon session passed in
//
//  Effects:    allocates memory to store SecurityUserData
//
//  Arguments:  (none)
//
//  Returns:    status
//
//  History:    8-03-93 MikeSw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS NTAPI
SecpGetUserInfo(IN         PLUID                   pLogonId,
                IN         ULONG                   fFlags,
                IN OUT     PSecurityUserData *     ppUserInfo)
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    DECLARE_ARGS( Args, ApiBuffer, GetUserInfo );
    PClient         pClient;
    static LUID lFake = {0,0};

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"GetUserInfo\n"));

    PREPARE_MESSAGE(ApiBuffer, GetUserInfo);

    if (pLogonId)
    {
        Args->LogonId = *pLogonId;
    }
    else
    {
        Args->LogonId = lFake;
    }

    Args->fFlags = fFlags;
    Args->pUserInfo = NULL;


    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"GetUserInfo scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
        if (NT_SUCCESS(scRet))
        {
            *ppUserInfo = Args->pUserInfo;

#if BUILD_WOW64

            //
            // This works only because we're shortening the larger data.  Don't
            // try these conversions in the opposite direction.
            //

            PSECURITY_USER_DATA_WOW64 pUserInfo64 = (PSECURITY_USER_DATA_WOW64) *ppUserInfo;

            SecpLpcStringToSecurityString(&(*ppUserInfo)->UserName, &pUserInfo64->UserName);
            SecpLpcStringToSecurityString(&(*ppUserInfo)->LogonDomainName, &pUserInfo64->LogonDomainName);
            SecpLpcStringToSecurityString(&(*ppUserInfo)->LogonServer, &pUserInfo64->LogonServer);

            (*ppUserInfo)->pSid = (PSID) pUserInfo64->pSid;

#endif

        }
    }

    FreeClient(pClient);
    return(ApiBuffer.ApiMessage.scRet);
}



//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackages
//
//  Synopsis:   Get the SecurityUserData of the logon session passed in
//
//  Effects:    allocates memory to store SecurityUserData
//
//  Arguments:  (none)
//
//  Returns:    status
//
//  History:    8-03-93 MikeSw   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

NTSTATUS NTAPI
SecpEnumeratePackages(  IN         PULONG               pcPackages,
                        IN OUT     PSecPkgInfo *        ppPackageInfo)
{

    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EnumPackages );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EnumeratePackages\n"));

    PREPARE_MESSAGE(ApiBuffer, EnumPackages);

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"Enumerate scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = ApiBuffer.ApiMessage.scRet ;
    }

    if (NT_SUCCESS(scRet))
    {

#ifdef BUILD_WOW64

        //
        // Need to in-place fixup the enumerated packages
        //
        // This works because we are shrinking the size of the data
        // do not try this if it is going to expand!
        //

        SECPKG_INFO_LPC LocalStore ;
        PSECPKG_INFO_LPC LpcForm ;
        PSecPkgInfoW FinalForm ;
        ULONG i ;

        LpcForm = (PSECPKG_INFO_LPC) Args->pPackages ;
        FinalForm = (PSecPkgInfoW) Args->pPackages ;


        for ( i = 0 ; i < Args->cPackages ; i++ )
        {
            LocalStore = *LpcForm ;

            LpcForm++ ;

            FinalForm->fCapabilities = LocalStore.fCapabilities ;
            FinalForm->wVersion = LocalStore.wVersion ;
            FinalForm->wRPCID = LocalStore.wRPCID ;
            FinalForm->cbMaxToken = LocalStore.cbMaxToken ;
            FinalForm->Name = (PWSTR) LocalStore.Name ;
            FinalForm->Comment = (PWSTR) LocalStore.Comment ;
        }


#endif
        *ppPackageInfo = Args->pPackages;
        *pcPackages = Args->cPackages;
    }

    FreeClient(pClient);
    return(ApiBuffer.ApiMessage.scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   SecpQueryPackageInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SecpQueryPackageInfo(   PSECURITY_STRING        pssPackageName,
                        PSecPkgInfo *           ppPackageInfo)
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, QueryPackage );
    ULONG cbPrepackAvail = CBPREPACK;
    PUCHAR Where;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"QueryPackageInfo\n"));

    PREPARE_MESSAGE(ApiBuffer, QueryPackage);
    Where = ApiBuffer.ApiMessage.bData;

    SecpSecurityStringToLpc( &Args->ssPackageName, pssPackageName );
    if (pssPackageName->Length <= cbPrepackAvail)
    {
        Args->ssPackageName.Buffer =  (PWSTR_LPC) ((PUCHAR) Where - (PUCHAR) &ApiBuffer);
        RtlCopyMemory(
            Where,
            pssPackageName->Buffer,
            pssPackageName->Length);

        Where += pssPackageName->Length;
        cbPrepackAvail -= pssPackageName->Length;
    }

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) ( Where - (PUCHAR) &ApiBuffer );

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"QueryPackageInfo scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if (NT_SUCCESS(scRet))
        {
#ifdef BUILD_WOW64

        //
        // Need to in-place fixup the enumerated packages
        //
        // This works because we are shrinking the size of the data
        // do not try this if it is going to expand!
        //

            SECPKG_INFO_LPC LocalStore ;
            PSECPKG_INFO_LPC LpcForm ;
            PSecPkgInfoW FinalForm ;
            ULONG i ;

            LpcForm = (PSECPKG_INFO_LPC) Args->pPackageInfo ;
            FinalForm = (PSecPkgInfoW) Args->pPackageInfo ;

            LocalStore = *LpcForm ;


            FinalForm->fCapabilities = LocalStore.fCapabilities ;
            FinalForm->wVersion = LocalStore.wVersion ;
            FinalForm->wRPCID = LocalStore.wRPCID ;
            FinalForm->cbMaxToken = LocalStore.cbMaxToken ;
            FinalForm->Name = (PWSTR) LocalStore.Name ;
            FinalForm->Comment = (PWSTR) LocalStore.Comment ;


#endif


            *ppPackageInfo = Args->pPackageInfo;
        }
    }

    FreeClient(pClient);
    return(ApiBuffer.ApiMessage.scRet);

}


NTSTATUS
NTAPI
SecpGetUserName(
    ULONG Options,
    PUNICODE_STRING Name
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, GetUserNameX );


    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"GetUserName\n"));

    PREPARE_MESSAGE(ApiBuffer, GetUserNameX );

    Args->Options = Options ;

    SecpSecurityStringToLpc( &Args->Name, Name );

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"GetUserName scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        if ( ApiBuffer.ApiMessage.Args.SpmArguments.fAPI & SPMAPI_FLAG_WIN32_ERROR )
        {
#ifndef SECURITY_KERNEL
            SetLastError( scRet );
#endif
            scRet = STATUS_UNSUCCESSFUL ;
        }

        Name->Length = Args->Name.Length ;

        if (NT_SUCCESS(scRet))
        {
            if ( Args->Name.Buffer == (PWSTR_LPC)
                 ((LONG_PTR) ApiBuffer.ApiMessage.bData - (LONG_PTR) Args) )
            {
                //
                // Response was sent in the data area:
                //

                RtlCopyMemory(
                    Name->Buffer,
                    ApiBuffer.ApiMessage.bData,
                    Args->Name.Length
                    );
            }
        }
    }

    FreeClient(pClient);

    return scRet ;
}

NTSTATUS
NTAPI
SecpEnumLogonSession(
    PULONG LogonSessionCount,
    PLUID * LogonSessionList
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, EnumLogonSession );


    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"EnumLogonSession\n"));

    PREPARE_MESSAGE(ApiBuffer, EnumLogonSession );

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"EnumLogonSession scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;

        *LogonSessionCount = Args->LogonSessionCount ;
        *LogonSessionList = (PLUID) Args->LogonSessionList ;

    }

    FreeClient(pClient);

    return scRet ;
}


NTSTATUS
NTAPI
SecpGetLogonSessionData(
    IN PLUID LogonId,
    OUT PVOID * LogonSessionData
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, GetLogonSessionData );


    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"GetLogonSessionData\n"));

    PREPARE_MESSAGE(ApiBuffer, GetLogonSessionData );

    Args->LogonId = *LogonId ;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"GetLogonSessionData scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
#ifdef BUILD_WOW64
        SECURITY_LOGON_SESSION_DATA_LPC LocalStore ;
        PSECURITY_LOGON_SESSION_DATA_LPC LpcForm ;
        PSECURITY_LOGON_SESSION_DATA FinalForm ;

        LpcForm = (PSECURITY_LOGON_SESSION_DATA_LPC) Args->LogonSessionInfo ;
        LocalStore = *LpcForm ;

        FinalForm = (PSECURITY_LOGON_SESSION_DATA) Args->LogonSessionInfo ;

        FinalForm->Size = sizeof( SECURITY_LOGON_SESSION_DATA );
        FinalForm->LogonId = LocalStore.LogonId ;
        SecpLpcStringToSecurityString( &FinalForm->UserName, &LocalStore.UserName );
        SecpLpcStringToSecurityString( &FinalForm->LogonDomain, &LocalStore.LogonDomain );
        SecpLpcStringToSecurityString( &FinalForm->AuthenticationPackage, &LocalStore.AuthenticationPackage );
        FinalForm->LogonType = LocalStore.LogonType ;
        FinalForm->Session = LocalStore.Session ;
        FinalForm->Sid = (PSID) LocalStore.Sid ;
        FinalForm->LogonTime = LocalStore.LogonTime ;
#endif

        *LogonSessionData = (PVOID) Args->LogonSessionInfo ;

        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);

    return scRet ;
}

SECURITY_STATUS
SecpLookupAccountName(
    IN PSECURITY_STRING Name,
    OUT PSECURITY_STRING ReferencedDomain,
    OUT PULONG RequiredDomainSize,
    IN OUT PULONG SidSize,
    OUT PSID Sid,
    OUT PSID_NAME_USE NameUse
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, LookupAccountNameX );
    ULONG Size ;
    PSID LocalSid ;
    UNICODE_STRING String ;


    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"LookupAccountName\n"));


    if ( Name->Length > CBPREPACK )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    PREPARE_MESSAGE(ApiBuffer, LookupAccountNameX );

    Args->Name.Length = Name->Length ;
    Args->Name.MaximumLength = Args->Name.Length ;
    Args->Name.Buffer = (PWSTR_LPC) (ULONG_PTR)PREPACK_START ;

    RtlCopyMemory(
        ApiBuffer.ApiMessage.bData,
        Name->Buffer,
        Name->Length );

    scRet = CallSPM( pClient,
                     &ApiBuffer,
                     &ApiBuffer );

    if ( NT_SUCCESS( scRet ) )
    {
        //
        //  Call succeeded
        //

        scRet = ApiBuffer.ApiMessage.scRet ;

        if ( NT_SUCCESS( scRet ) )
        {
            *NameUse = Args->NameUse ;

            LocalSid = (PUCHAR) &ApiBuffer + (ULONG_PTR) Args->Sid  ;

            Size = RtlLengthSid( LocalSid );

            if ( Size < *SidSize )
            {
                RtlCopySid( *SidSize, Sid, LocalSid );
            }

            *SidSize = Size ;

            if ( ReferencedDomain != NULL )
            {
                if ( Args->Domain.Length )
                {
                    if ( Args->Domain.Length <= ReferencedDomain->MaximumLength )
                    {
                        String.Buffer = (PWSTR) ((PUCHAR) &ApiBuffer + (ULONG_PTR) Args->Domain.Buffer) ;
                        String.Length = Args->Domain.Length ;
                        String.MaximumLength = Args->Domain.MaximumLength ;

                        RtlCopyUnicodeString(
                            ReferencedDomain,
                            &String );

                    }
                    else
                    {
                        scRet = STATUS_BUFFER_TOO_SMALL ;
                        *RequiredDomainSize = Args->Domain.Length ;
                        ReferencedDomain->Length = 0 ;
                    }
                }
                else
                {
                    ReferencedDomain->Length = 0 ;
                }
            }


        }
    }

    return scRet ;

}

SECURITY_STATUS
SecpLookupAccountSid(
    IN PSID Sid,
    OUT PSECURITY_STRING Name,
    OUT PULONG RequiredNameSize,
    OUT PSECURITY_STRING ReferencedDomain,
    OUT PULONG RequiredDomainSize,
    OUT PSID_NAME_USE NameUse
    )
{
    NTSTATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    DECLARE_ARGS( Args, ApiBuffer, LookupAccountSidX );
    PClient         pClient;
    UNICODE_STRING String ;


    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"LookupAccountSid\n"));


    if ( RtlLengthSid( Sid ) > CBPREPACK )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    PREPARE_MESSAGE(ApiBuffer, LookupAccountSidX );

    Args->Sid = (PVOID_LPC) (ULONG_PTR) PREPACK_START ;

    RtlCopyMemory(
        ApiBuffer.ApiMessage.bData,
        Sid,
        RtlLengthSid( Sid ) );

    scRet = CallSPM( pClient,
                     &ApiBuffer,
                     &ApiBuffer );

    if ( NT_SUCCESS( scRet ) )
    {
        //
        //  Call succeeded
        //

        scRet = ApiBuffer.ApiMessage.scRet ;

        if ( NT_SUCCESS( scRet ) )
        {
            *NameUse = Args->NameUse ;

            if ( Name != NULL )
            {
                if ( Args->Name.Length )
                {
                    if ( Args->Name.Length <= Name->MaximumLength )
                    {
                        String.Buffer = (PWSTR) ((PUCHAR) &ApiBuffer + (ULONG_PTR) Args->Name.Buffer );
                        String.Length = Args->Name.Length ;
                        String.MaximumLength = Args->Name.MaximumLength ;

                        RtlCopyUnicodeString(
                            Name,
                            &String );

                    }
                    else
                    {
                        scRet = STATUS_BUFFER_TOO_SMALL ;
                        *RequiredNameSize = Args->Name.Length ;
                        Name->Length = 0 ;

                    }
                }
                else
                {
                    Name->Length = 0 ;
                }
            }
            else
            {
                *RequiredNameSize = Args->Name.Length ;
            }

            if ( ReferencedDomain != NULL )
            {
                if ( Args->Domain.Length )
                {
                    if ( Args->Domain.Length <= ReferencedDomain->MaximumLength )
                    {
                        String.Buffer = (PWSTR) ((PUCHAR) &ApiBuffer + (ULONG_PTR) Args->Domain.Buffer );
                        String.Length = Args->Domain.Length ;
                        String.MaximumLength = Args->Domain.MaximumLength ;

                        RtlCopyUnicodeString(
                            ReferencedDomain,
                            &String );

                    }
                    else
                    {
                        scRet = STATUS_BUFFER_TOO_SMALL ;
                        *RequiredDomainSize = Args->Domain.Length ;
                        ReferencedDomain->Length = 0 ;
                    }
                }
                else
                {
                    ReferencedDomain->Length = 0 ;
                }
            }
            else
            {
                *RequiredDomainSize = Args->Domain.Length ;
            }


        }
    }

    return scRet ;

}

//
// Structure describing the marshaled target info
//

typedef struct _CRED_MARSHALED_TI {
    ULONG MagicConstant;
#define CRED_MARSHALED_TI_CONSTANT 0x91856535
    ULONG Flags;
    ULONG CredTypeCount;
    USHORT TargetNameSize;
    USHORT NetbiosServerNameSize;
    USHORT DnsServerNameSize;
    USHORT NetbiosDomainNameSize;
    USHORT DnsDomainNameSize;
    USHORT DnsTreeNameSize;
    USHORT PackageNameSize;
} CRED_MARSHALED_TI, *PCRED_MARSHALED_TI;



NTSTATUS
CredMarshalTargetInfo (
    IN PCREDENTIAL_TARGET_INFORMATIONW InTargetInfo,
    OUT PUSHORT *Buffer,
    OUT PULONG BufferSize
    )

/*++

Routine Description:

    Marshals a TargetInformation structure into an opaque blob suitable for passing to
    another process.

    The blob can be unmarshaled via CredUnmarshalTargetInfo.

Arguments:

    InTargetInfo - Input TargetInfo

    Buffer - Returns a marshaled form of TargetInfo.
        Buffer will contain no pointers.
        For the kernel version of this routine,
            Buffer must be freed using ExFreePool (PagedPool).
        For the secur32.dll version of thie routine,
            Buffer must be freed using LocalFree.

    BufferSize - Returns the size (in bytes) of the returned Buffer


Return Values:

    Status of the operation:

        STATUS_SUCCESS: Buffer was properly returned
        STATUS_INSUFFICIENT_RESOURCES: Buffer could not be allocated

--*/

{
    NTSTATUS Status;

    PCRED_MARSHALED_TI OutTargetInfo = NULL;
    ULONG Size;

    UNICODE_STRING TargetName;
    UNICODE_STRING NetbiosServerName;
    UNICODE_STRING DnsServerName;
    UNICODE_STRING NetbiosDomainName;
    UNICODE_STRING DnsDomainName;
    UNICODE_STRING DnsTreeName;
    UNICODE_STRING PackageName;

    PUCHAR Where;
    PUCHAR OldWhere;

    SEC_PAGED_CODE();

    //
    // Compute the size of the strings
    //

    RtlInitUnicodeString( &TargetName, InTargetInfo->TargetName );
    RtlInitUnicodeString( &NetbiosServerName, InTargetInfo->NetbiosServerName );
    RtlInitUnicodeString( &DnsServerName, InTargetInfo->DnsServerName );
    RtlInitUnicodeString( &NetbiosDomainName, InTargetInfo->NetbiosDomainName );
    RtlInitUnicodeString( &DnsDomainName, InTargetInfo->DnsDomainName );
    RtlInitUnicodeString( &DnsTreeName, InTargetInfo->DnsTreeName );
    RtlInitUnicodeString( &PackageName, InTargetInfo->PackageName );


    //
    // Allocate a buffer for the resultant target info blob
    //

    Size = sizeof(CRED_MARSHALED_TI) +
                TargetName.MaximumLength +
                NetbiosServerName.MaximumLength +
                DnsServerName.MaximumLength +
                NetbiosDomainName.MaximumLength +
                DnsDomainName.MaximumLength +
                DnsTreeName.MaximumLength +
                PackageName.MaximumLength +
                InTargetInfo->CredTypeCount * sizeof(ULONG);

    Size = ROUND_UP_COUNT( Size, ALIGN_WORST ) +
                sizeof(ULONG);

    OutTargetInfo = (PCRED_MARSHALED_TI)
#ifdef SECURITY_KERNEL
        ExAllocatePoolWithTag( PagedPool, Size, 'ITeS' );
#else // SECURITY_KERNEL
        LocalAlloc( 0, Size );
#endif // SECURITY_KERNEL

    if ( OutTargetInfo == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    *BufferSize = Size;
    Where = (PUCHAR)(OutTargetInfo + 1);


    //
    // Copy the fixed size data
    //

    OutTargetInfo->Flags = InTargetInfo->Flags;
    OutTargetInfo->MagicConstant = CRED_MARSHALED_TI_CONSTANT;


    //
    // Copy the ULONG aligned data
    //

    OutTargetInfo->CredTypeCount = InTargetInfo->CredTypeCount;
    if ( InTargetInfo->CredTypeCount != 0 ) {
        RtlCopyMemory( Where, InTargetInfo->CredTypes, InTargetInfo->CredTypeCount * sizeof(ULONG) );
        Where += InTargetInfo->CredTypeCount * sizeof(ULONG);
    }


    //
    // Convert the USHORT aligned data
    //

    OutTargetInfo->TargetNameSize = TargetName.MaximumLength;
    if ( TargetName.MaximumLength != 0 ) {
        RtlCopyMemory( Where, TargetName.Buffer, TargetName.MaximumLength );
        Where += TargetName.MaximumLength;
    }

    OutTargetInfo->NetbiosServerNameSize = NetbiosServerName.MaximumLength;
    if ( NetbiosServerName.MaximumLength != 0 ) {
        RtlCopyMemory( Where, NetbiosServerName.Buffer, NetbiosServerName.MaximumLength );
        Where += NetbiosServerName.MaximumLength;
    }

    OutTargetInfo->DnsServerNameSize = DnsServerName.MaximumLength;
    if ( DnsServerName.MaximumLength != 0 ) {
        RtlCopyMemory( Where, DnsServerName.Buffer, DnsServerName.MaximumLength );
        Where += DnsServerName.MaximumLength;
    }

    OutTargetInfo->NetbiosDomainNameSize = NetbiosDomainName.MaximumLength;
    if ( NetbiosDomainName.MaximumLength != 0 ) {
        RtlCopyMemory( Where, NetbiosDomainName.Buffer, NetbiosDomainName.MaximumLength );
        Where += NetbiosDomainName.MaximumLength;
    }

    OutTargetInfo->DnsDomainNameSize = DnsDomainName.MaximumLength;
    if ( DnsDomainName.MaximumLength != 0 ) {
        RtlCopyMemory( Where, DnsDomainName.Buffer, DnsDomainName.MaximumLength );
        Where += DnsDomainName.MaximumLength;
    }

    OutTargetInfo->DnsTreeNameSize = DnsTreeName.MaximumLength;
    if ( DnsTreeName.MaximumLength != 0 ) {
        RtlCopyMemory( Where, DnsTreeName.Buffer, DnsTreeName.MaximumLength );
        Where += DnsTreeName.MaximumLength;
    }

    OutTargetInfo->PackageNameSize = PackageName.MaximumLength;
    if ( PackageName.MaximumLength != 0 ) {
        RtlCopyMemory( Where, PackageName.Buffer, PackageName.MaximumLength );
        Where += PackageName.MaximumLength;
    }

    //
    // Put the size of the blob at the end of the blob
    //

    OldWhere = Where;
    Where = (PUCHAR) ROUND_UP_POINTER( OldWhere, ALIGN_WORST );
    RtlZeroMemory( OldWhere, Where-OldWhere );

    *((PULONG)Where) = Size;
    Where += sizeof(ULONG);



    ASSERT( (ULONG)(Where - ((PUCHAR)OutTargetInfo)) == Size );

    Status = STATUS_SUCCESS;
Cleanup:

    //
    // Be tidy
    //
    if ( Status == STATUS_SUCCESS ) {
        *BufferSize = Size;
        *Buffer = (PUSHORT) OutTargetInfo;
    } else {
        if ( OutTargetInfo != NULL ) {
#ifdef SECURITY_KERNEL
            ExFreePool( OutTargetInfo );
#else // SECURITY_KERNEL
            LocalFree( OutTargetInfo );
#endif // SECURITY_KERNEL
        }
    }

    return Status;

}


#ifndef SECURITY_KERNEL // we don't need a kernel version yet
NTSTATUS
CredUnmarshalTargetInfo (
    IN PUSHORT Buffer,
    IN ULONG BufferSize,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *RetTargetInfo OPTIONAL
    )

/*++

Routine Description:

    Converts a marshaled TargetInfo blob into a TargetInformation structure.

Arguments:

    Buffer - Specifies a marshaled TargetInfo blob built by CredMarshalTargetInfo.

    BufferSize - Returns the size (in bytes) of the returned Buffer

    RetTargetInfo - Returns an allocated buffer containing the unmarshaled data.
        If not specified, Buffer is simply checked to ensure it is a valid opaque blob.
        For the kernel version of this routine,
            Buffer must be freed using ExFreePool (PagedPool).
        For the secur32.dll version of thie routine,
            Buffer must be freed using LocalFree.


Return Values:

    Status of the operation:

        STATUS_SUCCESS: OutTargetInfo was properly returned
        STATUS_INSUFFICIENT_RESOURCES: OutTargetInfo could not be allocated
        STATUS_INVALID_PARAMETER: Buffer is not a valid opaque blob

--*/

{
    NTSTATUS Status;

    CRED_MARSHALED_TI TargetInfo;
    PCREDENTIAL_TARGET_INFORMATIONW OutTargetInfo = NULL;
    ULONG ActualSize;

    PUCHAR InWhere;

    SEC_PAGED_CODE();


    //
    // Ensure the buffer contains the entire blob structure
    //

    if ( BufferSize < sizeof(TargetInfo) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Grab an aligned copy of the blob structure
    //

    RtlCopyMemory ( &TargetInfo, Buffer, sizeof(TargetInfo) );
    InWhere = ((PUCHAR)Buffer) + sizeof(TargetInfo);

    //
    // Ensure the magic number is present
    //

    if ( TargetInfo.MagicConstant != CRED_MARSHALED_TI_CONSTANT ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // If the caller doesn't need the target info returned,
    //  just check the sizes
    //
#define CHECK_SIZE( _Size ) \
    if ( InWhere + (_Size) < InWhere || \
         InWhere + (_Size) > ((PUCHAR)Buffer) + BufferSize ) { \
        Status = STATUS_INVALID_PARAMETER; \
        goto Cleanup; \
    }

    if ( !ARGUMENT_PRESENT(RetTargetInfo) ) {


        //
        // Check the ULONG aligned data
        //

        CHECK_SIZE( TargetInfo.CredTypeCount * sizeof(ULONG) );
        InWhere += TargetInfo.CredTypeCount * sizeof(ULONG);

        //
        // Check the USHORT aligned data
        //

        CHECK_SIZE( TargetInfo.TargetNameSize );
        InWhere += TargetInfo.TargetNameSize;

        CHECK_SIZE( TargetInfo.NetbiosServerNameSize );
        InWhere += TargetInfo.NetbiosServerNameSize;

        CHECK_SIZE( TargetInfo.DnsServerNameSize );
        InWhere += TargetInfo.DnsServerNameSize;

        CHECK_SIZE( TargetInfo.NetbiosDomainNameSize );
        InWhere += TargetInfo.NetbiosDomainNameSize;

        CHECK_SIZE( TargetInfo.DnsDomainNameSize );
        InWhere += TargetInfo.DnsDomainNameSize;

        CHECK_SIZE( TargetInfo.DnsTreeNameSize );
        InWhere += TargetInfo.DnsTreeNameSize;

        CHECK_SIZE( TargetInfo.PackageNameSize );
        InWhere += TargetInfo.PackageNameSize;

    //
    // If the caller does need the target info returned,
    //  allocate and copy the data.
    //

    } else {
        ULONG Size;
        PUCHAR Where;
        PUCHAR OldWhere;


        //
        // Allocate a buffer for the resultant target info
        //

        Size = sizeof(CREDENTIAL_TARGET_INFORMATIONW) +
                    TargetInfo.TargetNameSize +
                    TargetInfo.NetbiosServerNameSize +
                    TargetInfo.DnsServerNameSize +
                    TargetInfo.NetbiosDomainNameSize +
                    TargetInfo.DnsDomainNameSize +
                    TargetInfo.DnsTreeNameSize +
                    TargetInfo.PackageNameSize +
                    TargetInfo.CredTypeCount * sizeof(ULONG);

        OutTargetInfo = (PCREDENTIAL_TARGET_INFORMATIONW)
#ifdef SECURITY_KERNEL
            ExAllocatePoolWithTag( PagedPool, Size, 'ITeS' )
#else // SECURITY_KERNEL
            LocalAlloc( 0, Size );
#endif // SECURITY_KERNEL

        if ( OutTargetInfo == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Where = (PUCHAR)(OutTargetInfo + 1);


        //
        // Copy the fixed size data
        //

        OutTargetInfo->Flags = TargetInfo.Flags;


        //
        // Copy the ULONG aligned data
        //

        OutTargetInfo->CredTypeCount = TargetInfo.CredTypeCount;
        if ( TargetInfo.CredTypeCount != 0 ) {

            CHECK_SIZE( TargetInfo.CredTypeCount * sizeof(ULONG) );

            OutTargetInfo->CredTypes = (LPDWORD)Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.CredTypeCount * sizeof(ULONG) );

            Where += TargetInfo.CredTypeCount * sizeof(ULONG);
            InWhere += TargetInfo.CredTypeCount * sizeof(ULONG);
        } else {
            OutTargetInfo->CredTypes = NULL;
        }


        //
        // Convert the USHORT aligned data
        //

        if ( TargetInfo.TargetNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.TargetNameSize );

            OutTargetInfo->TargetName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.TargetNameSize );
            Where += TargetInfo.TargetNameSize;
            InWhere += TargetInfo.TargetNameSize;
        } else {
            OutTargetInfo->TargetName = NULL;
        }

        if ( TargetInfo.NetbiosServerNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.NetbiosServerNameSize );

            OutTargetInfo->NetbiosServerName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.NetbiosServerNameSize );
            Where += TargetInfo.NetbiosServerNameSize;
            InWhere += TargetInfo.NetbiosServerNameSize;
        } else {
            OutTargetInfo->NetbiosServerName = NULL;
        }

        if ( TargetInfo.DnsServerNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.DnsServerNameSize );

            OutTargetInfo->DnsServerName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.DnsServerNameSize );
            Where += TargetInfo.DnsServerNameSize;
            InWhere += TargetInfo.DnsServerNameSize;
        } else {
            OutTargetInfo->DnsServerName = NULL;
        }

        if ( TargetInfo.NetbiosDomainNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.NetbiosDomainNameSize );

            OutTargetInfo->NetbiosDomainName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.NetbiosDomainNameSize );
            Where += TargetInfo.NetbiosDomainNameSize;
            InWhere += TargetInfo.NetbiosDomainNameSize;
        } else {
            OutTargetInfo->NetbiosDomainName = NULL;
        }

        if ( TargetInfo.DnsDomainNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.DnsDomainNameSize );

            OutTargetInfo->DnsDomainName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.DnsDomainNameSize );
            Where += TargetInfo.DnsDomainNameSize;
            InWhere += TargetInfo.DnsDomainNameSize;
        } else {
            OutTargetInfo->DnsDomainName = NULL;
        }

        if ( TargetInfo.DnsTreeNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.DnsTreeNameSize );

            OutTargetInfo->DnsTreeName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.DnsTreeNameSize );
            Where += TargetInfo.DnsTreeNameSize;
            InWhere += TargetInfo.DnsTreeNameSize;
        } else {
            OutTargetInfo->DnsTreeName = NULL;
        }

        if ( TargetInfo.PackageNameSize != 0 ) {

            CHECK_SIZE( TargetInfo.PackageNameSize );

            OutTargetInfo->PackageName = (LPWSTR) Where;

            RtlCopyMemory( Where, InWhere, TargetInfo.PackageNameSize );
            Where += TargetInfo.PackageNameSize;
            InWhere += TargetInfo.PackageNameSize;
        } else {
            OutTargetInfo->PackageName = NULL;
        }

    }

    //
    // Check the size field at the end of the blob
    //

    CHECK_SIZE( sizeof(ULONG) );    // ensure there are atleast 4 bytes left

    InWhere = ((PUCHAR)Buffer) + BufferSize - sizeof(ULONG);    // grab the very last 4 bytes

    CHECK_SIZE( sizeof(ULONG) );

    RtlCopyMemory( &ActualSize, InWhere, sizeof(ULONG));

    if ( BufferSize != ActualSize ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    Status = STATUS_SUCCESS;
Cleanup:

    //
    // Be tidy
    //
    if ( Status != STATUS_SUCCESS ) {
        if ( OutTargetInfo != NULL ) {
#ifdef SECURITY_KERNEL
            ExFreePool( OutTargetInfo );
#else // SECURITY_KERNEL
            LocalFree( OutTargetInfo );
#endif // SECURITY_KERNEL
        }
        OutTargetInfo = NULL;
    }

    //
    // Return the buffer to the caller
    //
    if ( ARGUMENT_PRESENT(RetTargetInfo) ) {
        *RetTargetInfo = OutTargetInfo;
    }

    return Status;

}
#endif // SECURITY_KERNEL // we don't need a kernel version yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\lsap.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lsap.cxx

Abstract:

    Stub routines for Lsa lpc

Author:

    Mac McLain          (MacM)       Dec 7, 1997

Environment:

    User Mode

Revision History:

--*/

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapPolicyChangeNotify
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
SECURITY_STATUS
SEC_ENTRY
LsapPolicyChangeNotify( IN ULONG Options,
                        IN BOOLEAN Register,
                        IN HANDLE EventHandle,
                        IN POLICY_NOTIFICATION_INFORMATION_CLASS NotifyInfoClass )
{

    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, LsaPolicyChangeNotify );

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"PolicyChangeNotify\n"));

    PREPARE_MESSAGE(ApiBuffer, LsaPolicyChangeNotify);


    Args->Options = Options;
    Args->Register = Register;
    Args->EventHandle = EventHandle;
    Args->NotifyInfoClass = NotifyInfoClass;

    scRet = CallSPM( pClient,
                     &ApiBuffer,
                     &ApiBuffer );

    DebugLog((DEB_TRACE,"PolicyChangeNotify scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\spmlpc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        spmlpc.cxx
//
// Contents:    lpc code for client->spmgr communication
//
//
// History:     3-4-94      MikeSw      Created
//
//------------------------------------------------------------------------


#include "secpch2.hxx"

extern "C"
{
#include <zwapi.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>


SECURITY_STATUS
LpcConnect( PWSTR       pszPortName,
            PVOID       pConnect,
            PULONG      pcbConnect,
            HANDLE *    phPort);
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, CreateConnection)
#pragma alloc_text(PAGE, CallSPM)
#pragma alloc_text(PAGE, LpcConnect)
#endif


PLSA_DISPATCH_FN    SecpLsaDispatchFn ;
LSA_DISPATCH_FN     SecpLsaCallback ;

#ifdef SECURITY_USERMODE

extern BOOL LsaPackageShutdown ;

NTSTATUS
NTAPI
SecpDllCallback(
    ULONG_PTR RequestType,
    ULONG_PTR Parameter,
    PSecBuffer InputBuffer,
    PSecBuffer OutputBuffer
    )
{
    DebugLog(( DEB_TRACE, "Internal Callback, request = %d\n", RequestType ));

    if ( RequestType == SPM_CALLBACK_SHUTDOWN )
    {
        LsaPackageShutdown = TRUE ;
    }

    return STATUS_NOT_IMPLEMENTED ;
}

NTSTATUS
SecpHandleCallback(
    PClient     pClient,
    PSPM_LPC_MESSAGE    pCallback
    )
{
    SPMCallbackAPI *    Args ;
    NTSTATUS Status  = STATUS_SUCCESS;
    SecBuffer Input ;
    SecBuffer Output ;

    while ( TRUE )
    {

        Args = LPC_MESSAGE_ARGSP( pCallback, Callback );

        SecpLpcBufferToSecBuffer( &Input, &Args->Input );
        SecpLpcBufferToSecBuffer( &Output, &Args->Output );

        switch ( Args->Type )
        {
            case SPM_CALLBACK_INTERNAL:
                Status = SecpDllCallback( (ULONG_PTR) Args->Argument1,
                                          (ULONG_PTR) Args->Argument2,
                                          &Input,
                                          &Output );
                break;

            case SPM_CALLBACK_GETKEY:
                Status = STATUS_NOT_IMPLEMENTED ;
                break;

            case SPM_CALLBACK_PACKAGE:


                Status = LsaCallbackHandler( (ULONG_PTR) Args->CallbackFunction,
                                             (ULONG_PTR) Args->Argument1,
                                             (ULONG_PTR) Args->Argument2,
                                             &Input,
                                             &Output );


                break;

            case SPM_CALLBACK_EXPORT:
                Status = STATUS_NOT_IMPLEMENTED ;
                break;

        }

        SecpSecBufferToLpc( &Args->Output, &Output );

        //
        // Now, post it back to the LSA, and wait for a reply to the
        // original request:
        //

        pCallback->ApiMessage.scRet = Status ;

        if ( pClient )
        {

            Status = ZwReplyWaitReplyPort(  pClient->hPort,
                                            (PPORT_MESSAGE) pCallback );

            if ( pCallback->pmMessage.u2.s2.Type == LPC_REPLY )
            {
                break;
            }
        }
        else
        {
            break;
        }
    }
    return Status ;

}


NTSTATUS
SecpLsaCallback(
    PSPM_LPC_MESSAGE    pCallback
    )
{
    return SecpHandleCallback( NULL, pCallback );

}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   CallSPM
//
//  Synopsis:   Calls the SPM, handles LPC errors
//
//  Effects:
//
//  Arguments:  pConn           -- Connection to use
//              pSendBuffer     -- Send buffer to send up
//              pReceiveBuffer  -- Received data from SPM
//
//  Requires:
//
//  Returns:
//
//  Notes:      In the future, we can add retry and error handling,
//              but right now we just panic if something fails.
//
//--------------------------------------------------------------------------
SECURITY_STATUS
CallSPM(PClient         pClient,
        PSPM_LPC_MESSAGE      pSendBuffer,
        PSPM_LPC_MESSAGE      pReceiveBuffer)

{
    SECURITY_STATUS     scRet;
    int                 retry = 0;

    SEC_PAGED_CODE();


    if ( SecpLsaDispatchFn == NULL )
    {
        scRet = ZwRequestWaitReplyPort( pClient->hPort,
                                        (PPORT_MESSAGE) pSendBuffer,
                                        (PPORT_MESSAGE) pReceiveBuffer);

        if (!NT_SUCCESS(scRet))
        {
            // If the call failed, shout to everyone, kill the connection,
            // and stuff NO_SPM into the API return code

            DebugLog((DEB_ERROR,"Error %x in LPC to LSA\n", scRet));
            DebugLog((DEB_ERROR,"Breaking connection for process %x\n", pClient->ProcessId));
            scRet = SEC_E_INTERNAL_ERROR;
            pReceiveBuffer->ApiMessage.scRet = scRet;
            pReceiveBuffer->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;
        }

#ifdef SECURITY_USERMODE
        if ( pReceiveBuffer->pmMessage.u2.s2.Type == LPC_REQUEST )
        {
            //
            // The LSA has issued a callback.  Punt up to the callback handler
            //

            scRet = SecpHandleCallback( pClient,
                                        pReceiveBuffer);
        }
#endif

    }
    else
    {
        if ( pSendBuffer != pReceiveBuffer )
        {
            RtlCopyMemory( pReceiveBuffer,
                           pSendBuffer,
                           sizeof( SPM_LPC_MESSAGE ) );
        }
        scRet = SecpLsaDispatchFn( pReceiveBuffer );
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateConnection()
//
//  Synopsis:   Creates a connection record to the SPM
//
//  Effects:    Creates an LPC port in the context of the calling FSP
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    phConnect   - handle to a connection
//
//              STATUS_INSUFFICIENT_RESOURCES   - out of connection records
//              SEC_E_NO_SPM                    - Cannot connect to SPM
//
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CreateConnection(
    PSTR     LogonProcessName,
    ULONG    ClientMode,
    HANDLE * phConnect,
    ULONG *  PackageCount,
    ULONG *  OperationalMode
    )
{
    SECURITY_STATUS scRet;
    HANDLE          hPort;
    LSAP_AU_REGISTER_CONNECT_INFO_EX ConnectMessage;
    ULONG           cbConnect = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    PLSAP_AU_REGISTER_CONNECT_RESP Resp;
    OBJECT_ATTRIBUTES           PortObjAttr;
    UNICODE_STRING              ucsPortName;
    SECURITY_QUALITY_OF_SERVICE sQOS;
    ULONG                       cbMaxMessage;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"KSec:  CreateConnection\n" ));


    //
    // Zero this buffer to create an untrusted connection.
    //

    RtlZeroMemory(
        &ConnectMessage,
        sizeof(ConnectMessage)
        );

    if ( LogonProcessName )
    {
        ConnectMessage.LogonProcessNameLength = strlen( LogonProcessName );
        if ( ConnectMessage.LogonProcessNameLength >
                LSAP_MAX_LOGON_PROC_NAME_LENGTH )
        {
            ConnectMessage.LogonProcessNameLength = LSAP_MAX_LOGON_PROC_NAME_LENGTH ;
        }

        strncpy( ConnectMessage.LogonProcessName,
                 LogonProcessName,
                 ConnectMessage.LogonProcessNameLength );

        ConnectMessage.ClientMode = ClientMode;
        cbConnect = sizeof(LSAP_AU_REGISTER_CONNECT_INFO_EX);
    }


    RtlInitUnicodeString( &ucsPortName, SPM_PORTNAME );

    InitializeObjectAttributes(&PortObjAttr, &ucsPortName, 0, NULL, NULL);

    sQOS.Length = sizeof( sQOS );
    sQOS.ImpersonationLevel = SecurityImpersonation;
    sQOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sQOS.EffectiveOnly = FALSE;

    scRet = ZwConnectPort(  phConnect,
                            &ucsPortName,
                            &sQOS,
                            NULL,
                            NULL,
                            &cbMaxMessage,
                            &ConnectMessage,
                            &cbConnect );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"KSec: LpcConnect to SPM Failed, %x \n",
                    scRet));

        scRet = SEC_E_INTERNAL_ERROR;
        goto Create_SafeExit;

    }

    Resp = (PLSAP_AU_REGISTER_CONNECT_RESP) &ConnectMessage ;

    if ( PackageCount )
    {
        *PackageCount = Resp->PackageCount;
    }

    if ( OperationalMode )
    {
        *OperationalMode = Resp->SecurityMode ;
    }

    DebugLog((DEB_TRACE,"KSec:  Connected process to SPMgr\n"));


    // Safe, clean exit point:

Create_SafeExit:

    // return the set status code

    return(scRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\spmlpcp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        spmlpcp.h
//
// Contents:    private prototypes for security lpc functions
//
//
// History:     3-77-94     MikeSw      Created
//
//------------------------------------------------------------------------


#ifndef ALLOC_PRAGMA

#define SEC_PAGED_CODE()

#else

#define SEC_PAGED_CODE() PAGED_CODE()

#endif // ALLOC_PRAGMA

SECURITY_STATUS
CallSPM(PClient             pClient,
        PSPM_LPC_MESSAGE    pSendBuffer,
        PSPM_LPC_MESSAGE    pReceiveBuffer);

LSA_DISPATCH_FN SecpLsaCallback ;

NTSTATUS
LsaCallbackHandler(
    ULONG_PTR   Function,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    PSecBuffer Input,
    PSecBuffer Output
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\suppcred.cxx ===
//+-----------------------------------------------------------------------
//
// File:        suppcred.cxx
//
// Contents:    Supplemental Credentials API wrapper to the SPMgr
//
//
// History:     28 Nov 93,  MikeSw      Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, SecpSaveCredentials)
#pragma alloc_text(PAGE, SecpGetCredentials)
#pragma alloc_text(PAGE, SecpDeleteCredentials)
#endif


//+-------------------------------------------------------------------------
//
//  Function:   SaveCredentials
//
//  Synopsis:   Saves supplemental credentials for a credential handle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
SecpSaveCredentials(PCredHandle         pCredHandle,
                    PSecBuffer          pCredentials)
{
    return SEC_E_NOT_SUPPORTED ;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetCredentials
//
//  Synopsis:   Gets supplemental credentials for a credential handle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
SecpGetCredentials( PCredHandle         pCredHandle,
                    PSecBuffer          pCredentials)
{
    return SEC_E_NOT_SUPPORTED ;
}

//+-------------------------------------------------------------------------
//
//  Function:   DeleteCredentials
//
//  Synopsis:   Deletes supplemental credentials for a credential handle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



SECURITY_STATUS SEC_ENTRY
SecpDeleteCredentials(  PCredHandle         pCredHandle,
                        PSecBuffer          pKey)
{
    return SEC_E_NOT_SUPPORTED ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\util.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       util.cxx
//
//  Contents:   Miscellaneous functions for security clients
//
//  Classes:
//
//  Functions:
//
//  History:    3-4-94      MikeSw      Created
//
//----------------------------------------------------------------------------

#include "secpch2.hxx"

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "spmlpcp.h"
}

#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, SecpGetBinding)
#pragma alloc_text(PAGE, SecpFindPackage)
#endif


//+-------------------------------------------------------------------------
//
//  Function:   SecpGetBinding
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
SECURITY_STATUS SEC_ENTRY
SecpGetBinding( ULONG_PTR                   ulPackageId,
                PSEC_PACKAGE_BINDING_INFO   pBindingInfo)
{

    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, GetBinding );
    ULONG i ;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }


    PREPARE_MESSAGE(ApiBuffer, GetBinding);

    DebugLog((DEB_TRACE,"GetBinding(%x)\n", ulPackageId));

    Args->ulPackageId = (LSA_SEC_HANDLE_LPC) ulPackageId;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"GetBinding scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
        if (NT_SUCCESS(scRet))
        {
#ifdef BUILD_WOW64
            //
            // Copy "by hand," fixing up the pointers:
            //
            SecpLpcStringToSecurityString( &pBindingInfo->PackageName,
                                           &Args->BindingInfo.PackageName );

            SecpLpcStringToSecurityString( &pBindingInfo->Comment,
                                           &Args->BindingInfo.Comment );

            SecpLpcStringToSecurityString( &pBindingInfo->ModuleName,
                                           &Args->BindingInfo.ModuleName );

            pBindingInfo->PackageIndex = Args->BindingInfo.PackageIndex ;
            pBindingInfo->fCapabilities = Args->BindingInfo.fCapabilities ;
            pBindingInfo->Flags = Args->BindingInfo.Flags ;
            pBindingInfo->RpcId = Args->BindingInfo.RpcId ;
            pBindingInfo->Version = Args->BindingInfo.Version ;
            pBindingInfo->TokenSize = Args->BindingInfo.TokenSize ;
            pBindingInfo->ContextThunksCount = Args->BindingInfo.ContextThunksCount ;

            for ( i = 0 ; i < pBindingInfo->ContextThunksCount ; i++ )
            {
                pBindingInfo->ContextThunks[ i ] = Args->BindingInfo.ContextThunks[ i ] ;
            }
#else 
            *pBindingInfo = Args->BindingInfo;
#endif 
        }
    }

    FreeClient(pClient);
    return(scRet);

}

//+-------------------------------------------------------------------------
//
//  Function:   SecpFindPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
SECURITY_STATUS SEC_ENTRY
SecpFindPackage(    PSECURITY_STRING        pssPackageName,
                    PULONG_PTR              pulPackageId)
{

    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, FindPackage );
    ULONG cbPrepackAvail = CBPREPACK;
    PUCHAR Where;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"FindPackage\n"));

    PREPARE_MESSAGE(ApiBuffer, FindPackage);

    Where = ApiBuffer.ApiMessage.bData;

    SecpSecurityStringToLpc( &Args->ssPackageName, pssPackageName );

    if (pssPackageName->Length <= cbPrepackAvail)
    {
        Args->ssPackageName.Buffer =  (PWSTR_LPC) ((PUCHAR) Where - (PUCHAR) &ApiBuffer);

        RtlCopyMemory(Where,pssPackageName->Buffer,pssPackageName->Length);

        Where += pssPackageName->Length;

        cbPrepackAvail -= pssPackageName->Length;
    }

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer );

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"FindPackage scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
        if (NT_SUCCESS(scRet))
        {
            *pulPackageId = (ULONG_PTR) Args->ulPackageId;
        }
    }

    FreeClient(pClient);
    return(scRet);
}

extern "C"
SECURITY_STATUS
SEC_ENTRY
SecpAddPackage(
    PUNICODE_STRING Package,
    PSECURITY_PACKAGE_OPTIONS Options)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, AddPackage );
    ULONG cbPrepackAvail = CBPREPACK;
    PUCHAR Where;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"AddPackage\n"));

    PREPARE_MESSAGE(ApiBuffer, AddPackage);

    Where = ApiBuffer.ApiMessage.bData;

    SecpSecurityStringToLpc( &Args->Package, Package );

    if ( Package->Length <= cbPrepackAvail )
    {
        Args->Package.Buffer = (PWSTR_LPC) ((PUCHAR) Where - (PUCHAR) &ApiBuffer);
        RtlCopyMemory(  Where,
                        Package->Buffer,
                        Package->Length );

        Where += Package->Length ;
        cbPrepackAvail -= Package->Length ;
    }

    Args->OptionsFlags = Options->Flags ;


    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer) ;

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"AddPackage scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);

    return(scRet);

}

extern "C"
SECURITY_STATUS
SEC_ENTRY
SecpDeletePackage(
    PUNICODE_STRING Package)
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, DeletePackage );
    ULONG cbPrepackAvail = CBPREPACK;
    PUCHAR Where;

    SEC_PAGED_CODE();

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"DeletePackage\n"));

    PREPARE_MESSAGE(ApiBuffer, DeletePackage);

    Where = ApiBuffer.ApiMessage.bData;

    SecpSecurityStringToLpc( &Args->Package, Package );
    if ( Package->Length <= cbPrepackAvail )
    {
        Args->Package.Buffer = (PWSTR_LPC) ((PUCHAR) Where - (PUCHAR) &ApiBuffer);
        RtlCopyMemory(  Where,
                        Package->Buffer,
                        Package->Length );

        Where += Package->Length ;
        cbPrepackAvail -= Package->Length ;
    }

    if ( cbPrepackAvail != CBPREPACK )
    {
        //
        // We have consumed some of the bData space:  Adjust 
        // our length accordingly
        //

        ApiBuffer.pmMessage.u1.s1.TotalLength = (CSHORT) (Where - (PUCHAR) &ApiBuffer) ;

        ApiBuffer.pmMessage.u1.s1.DataLength = 
                ApiBuffer.pmMessage.u1.s1.TotalLength - sizeof( PORT_MESSAGE );


        
    }

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"DeletePackage scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    FreeClient(pClient);

    return(scRet);

}

extern "C"
SECURITY_STATUS
SEC_ENTRY
SecpSetSession(
    ULONG   Request,
    ULONG_PTR Argument,
    PULONG_PTR  Response,
    PVOID * ResponsePtr
    )
{
    SECURITY_STATUS scRet;
    ALIGN_WOW64 SPM_LPC_MESSAGE ApiBuffer;
    PClient         pClient;
    DECLARE_ARGS( Args, ApiBuffer, SetSession );

    SEC_PAGED_CODE();

#ifdef BUILD_WOW64

    return SEC_E_UNSUPPORTED_FUNCTION ;

#else 

    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }

    DebugLog((DEB_TRACE,"SetSession\n"));

    PREPARE_MESSAGE(ApiBuffer, SetSession);

    Args->Request = Request ;
    Args->Argument = Argument ;
    Args->Response = 0 ;
    Args->ResponsePtr = 0 ;

    scRet = CallSPM(pClient,
                    &ApiBuffer,
                    &ApiBuffer);

    DebugLog((DEB_TRACE,"SetSession scRet = %x\n", ApiBuffer.ApiMessage.scRet));

    if (NT_SUCCESS(scRet))
    {
        scRet = ApiBuffer.ApiMessage.scRet;
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( Response )
        {
            *Response = Args->Response ;
        }

        if ( ResponsePtr )
        {
            *ResponsePtr = Args->ResponsePtr ;
        }
    }

    FreeClient(pClient);

    return scRet ;
#endif 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:   Debug headers for the security dll
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

#ifdef DBG

#ifndef __DEBUG_H__
#define __DEBUG_H__


void    SetDebugInfo(void);

#define DEB_TRACE_OLDLSA    0x100
#define DEB_TRACE_PACKAGE   0x00000010
#define DEB_TRACE_GETUSER       0x00080000

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debug support for the security client dll
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
extern "C"
{
#include <dsysdbg.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"

}

DEFINE_DEBUG2(Sec);

#if DBG     // NOTE:  This file does not get compiled in retail builds


void
KsecDebugOut(unsigned long  Mask,
            const char *    Format,
            ...)
{
    ULONG  Thread;
    ULONG  Process;
    va_list     ArgList;
    char        szOutString[256];

    if (SecInfoLevel & Mask)
    {
        Thread = GetCurrentThreadId();
        Process = GetCurrentProcessId();

        va_start(ArgList, Format);
        DbgPrint("%#x.%#x> KSec:  ", Process, Thread);
        if (_vsnprintf(szOutString, sizeof(szOutString),Format, ArgList) < 0)
        {
                //
                // Less than zero indicates that the string could not be
                // fitted into the buffer.  Output a special message indicating
                // that:
                //

                DbgPrint("Error printing message\n");

        }
        else
        {
            DbgPrint(szOutString);
        }
    }
}

#if 1

DEBUG_KEY   SecDebugKeys[]  = { {DEB_ERROR,         "Error"},
                                {DEB_WARN,          "Warn"},
                                {DEB_TRACE,         "Trace"},
                                {DEB_TRACE_LSA,     "Lsa"},
                                {DEB_TRACE_CALL,    "Call"},
                                {DEB_TRACE_GETUSER, "GetUser"},
                                {0, NULL}
                              };



VOID
SecInitializeDebug(VOID)
{
    // SecInitDebugEx(DSYSDBG_OPEN_ONLY, SecDebugKeys);
    SecInitDebugEx(0, SecDebugKeys);
}

VOID
SecUninitDebug( VOID )
{
    SecUnloadDebug();
}

#endif
#endif // NOTE:  This file does not get compiled in retail builds!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\newstubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       newstubs.cxx
//
//  Contents:   Stubs from ntlmssp
//
//  History:    9-06-96   RichardW   Stolen from ntlmssp
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}
SecurityFunctionTableW SecTableW = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                    EnumerateSecurityPackagesW,
                                    QueryCredentialsAttributesW,
                                    AcquireCredentialsHandleW,
                                    FreeCredentialsHandle,
                                    NULL,
                                    InitializeSecurityContextW,
                                    AcceptSecurityContext,
                                    CompleteAuthToken,
                                    DeleteSecurityContext,
                                    ApplyControlToken,
                                    QueryContextAttributesW,
                                    ImpersonateSecurityContext,
                                    RevertSecurityContext,
                                    MakeSignature,
                                    VerifySignature,
                                    FreeContextBuffer,
                                    QuerySecurityPackageInfoW,
                                    EncryptMessage,
                                    DecryptMessage,
                                    ExportSecurityContext,
                                    ImportSecurityContextW,
                                    AddCredentialsW,
                                    NULL,
                                    QuerySecurityContextToken,
                                    EncryptMessage,
                                    DecryptMessage,
                                    SetContextAttributesW
                                   };


SecurityFunctionTableA   SecTableA = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                    EnumerateSecurityPackagesA,
                                    QueryCredentialsAttributesA,
                                    AcquireCredentialsHandleA,
                                    FreeCredentialsHandle,
                                    NULL,
                                    InitializeSecurityContextA,
                                    AcceptSecurityContext,
                                    CompleteAuthToken,
                                    DeleteSecurityContext,
                                    ApplyControlToken,
                                    QueryContextAttributesA,
                                    ImpersonateSecurityContext,
                                    RevertSecurityContext,
                                    MakeSignature,
                                    VerifySignature,
                                    FreeContextBuffer,
                                    QuerySecurityPackageInfoA,
                                    EncryptMessage,
                                    DecryptMessage,
                                    ExportSecurityContext,
                                    ImportSecurityContextA,
                                    AddCredentialsA,
                                    NULL,
                                    QuerySecurityContextToken,
                                    EncryptMessage,
                                    DecryptMessage,
                                    SetContextAttributesA
                                   };

#ifndef SetCurrentPackage
#define SetCurrentPackage( p )  TlsSetValue( SecTlsPackage, p )
#define GetCurrentPackage( )    TlsGetValue( SecTlsPackage )
#endif

SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleCommon(
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry,          // (out) Lifetime (optional)
    BOOLEAN                     fUnicode            // (in) Unicode caller?
    );

SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextCommon(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry,          // (out) Life span (OPT)
    BOOLEAN                     fUnicode            // (in) Unicode caller?
    );

//+---------------------------------------------------------------------------
//
//  Function:   SecpValidateHandle
//
//  Synopsis:   Validates a handle, determining effective handle and package
//
//  Arguments:  [pHandle]    -- Handle from user
//              [pEffective] -- Effective handle
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecpValidateHandle(
    BOOL        Context,
    PSecHandle  pHandle,
    PSecHandle  pEffective)
{
    PDLL_SECURITY_PACKAGE   Package;

    __try
    {

        if ( (pHandle->dwLower == 0 ) ||
             (pHandle->dwLower == (INT_PTR)-1) )
        {
            Package = NULL ;
        }
        else if ( pHandle->dwLower == (ULONG_PTR) GetCurrentThread() )
        {
            Package = (PDLL_SECURITY_PACKAGE) TlsGetValue( SecTlsPackage );
        }
        else
        {
            Package = (PDLL_SECURITY_PACKAGE) pHandle->dwLower ;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        Package = NULL ;
    }

    if ( Package )
    {


        if ( Package->fState & (DLL_SECPKG_SAVE_LOWER | DLL_SECPKG_CRED_LOWER) )
        {
            if ( Context )
            {
                if ( Package->fState & DLL_SECPKG_SAVE_LOWER )
                {
                    pEffective->dwLower = Package->OriginalLowerCtxt ;
                }
                else
                {
                    pEffective->dwLower = pHandle->dwLower ;
                }
            }
            else
            {
                if ( Package->fState & DLL_SECPKG_CRED_LOWER )
                {
                    pEffective->dwLower = Package->OriginalLowerCred ;
                }
                else
                {
                    pEffective->dwLower = pHandle->dwLower ;
                }
            }
        }
        else
        {
            pEffective->dwLower = pHandle->dwLower ;
        }

        pEffective->dwUpper = pHandle->dwUpper ;
    }

    return( Package );

}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleW
//
//  Synopsis:   Stub for AcquireCredentialsHandle
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [pvGetKeyArgument] --
//              [phCredential]     --
//              [ptsExpiry]        --
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleW(
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    return AcquireCredentialsHandleCommon(
            pszPrincipal,       // Name of principal
            pszPackageName,     // Name of package
            fCredentialUse,     // Flags indicating use
            pvLogonId,          // Pointer to logon ID
            pAuthData,          // Package specific data
            pGetKeyFn,          // Pointer to GetKey() func
            pvGetKeyArgument,   // Value to pass to GetKey()
            phCredential,       // (out) Cred Handle
            ptsExpiry,          // (out) Lifetime (optional)
            TRUE                // Unicode caller
            );

}

//+---------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleA
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [pvGetKeyArgument] --
//              [phCredential]     --
//              [ptsExpiry]        --
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleA(
    LPSTR                       pszPrincipal,       // Name of principal
    LPSTR                       pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    return AcquireCredentialsHandleCommon(
            (LPWSTR)pszPrincipal,       // Name of principal
            (LPWSTR)pszPackageName,     // Name of package
            fCredentialUse,     // Flags indicating use
            pvLogonId,          // Pointer to logon ID
            pAuthData,          // Package specific data
            pGetKeyFn,          // Pointer to GetKey() func
            pvGetKeyArgument,   // Value to pass to GetKey()
            phCredential,       // (out) Cred Handle
            ptsExpiry,          // (out) Lifetime (optional)
            FALSE               // NOT Unicode caller
            );
}

SECURITY_STATUS
SEC_ENTRY
AcquireCredentialsHandleCommon(
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry,          // (out) Lifetime (optional)
    BOOLEAN                     fUnicode            // (in) Unicode caller?
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PDLL_SECURITY_PACKAGE pPackage;
    CredHandle  TempCreds;

    if (!pszPackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    TempCreds.dwLower = (UINT_PTR) -1;

    if( fUnicode )
    {
        pPackage = SecLocatePackageW( pszPackageName );

        if ( pPackage == NULL )
        {
            return( SEC_E_SECPKG_NOT_FOUND );
        }

        DebugLog(( DEB_TRACE, "AcquireCredentialHandleW( ..., %ws, %d, ...)\n",
                        pPackage->PackageName.Buffer, fCredentialUse ));

        SetCurrentPackage(  pPackage );

        scRet = pPackage->pftTableW->AcquireCredentialsHandleW(
                    pszPrincipal,
                    pszPackageName,
                    fCredentialUse,
                    pvLogonId,
                    pAuthData,
                    pGetKeyFn,
                    pvGetKeyArgument,
                    &TempCreds,
                    ptsExpiry);
    } else {

        pPackage = SecLocatePackageA( (LPSTR)pszPackageName );

        if ( pPackage == NULL )
        {
            return( SEC_E_SECPKG_NOT_FOUND );
        }

        DebugLog(( DEB_TRACE, "AcquireCredentialHandleA( ..., %s, %d, ...)\n",
                        (LPSTR)pPackage->PackageName.Buffer, fCredentialUse ));

        SetCurrentPackage(  pPackage );

        scRet = pPackage->pftTableA->AcquireCredentialsHandleA(
                    (LPSTR)pszPrincipal,
                    (LPSTR)pszPackageName,
                    fCredentialUse,
                    pvLogonId,
                    pAuthData,
                    pGetKeyFn,
                    pvGetKeyArgument,
                    &TempCreds,
                    ptsExpiry);
    }


    if ( scRet == SEC_E_OK )
    {
        if ( TempCreds.dwLower == (UINT_PTR) -1 )
        {
            //
            // Some packages are nice, and actually leave this
            // untouched.  Set the original lower appropriately.
            //

            TempCreds.dwLower = (ULONG_PTR) pPackage ;

        }
        //
        // If the dwLower has been changed, then we need to store it away in the
        // package record, for a level of indirection.
        //
Retry_CredLowerTest:

        if ( pPackage->fState & DLL_SECPKG_CRED_LOWER )
        {
            //
            // Package has already been detected with a mapped handle value,
            // so, make sure they're the same,
            //

            if ( pPackage->OriginalLowerCred != TempCreds.dwLower )
            {
                DebugLog(( DEB_ERROR, "Security Package %ws is manipulating dwLower value inappropriately\n\treturned %p when %p expected.",
                        pPackage->PackageName.Buffer, TempCreds.dwLower, pPackage->OriginalLowerCred ));
            }
        }
        else
        {
            //
            // Package has not been tagged yet.  Time to do the dance
            //

            WriteLockPackageList();

            //
            // Test again.  If another thread is (has) updated, we should treat that as
            // authoritative.
            //

            if ( pPackage->fState & DLL_SECPKG_CRED_LOWER )
            {
                //
                // Another thread has fixed this up.  Release the lock, and jump back up
                // to retry the operation.
                //

                UnlockPackageList();

                goto Retry_CredLowerTest ;
            }

            //
            // Ok, we're the first.  Stick what the package wants as a dwLower into the
            // package record, and set the flag
            //

            pPackage->OriginalLowerCred = TempCreds.dwLower ;

            pPackage->fState |= DLL_SECPKG_CRED_LOWER ;

            UnlockPackageList();

        }

        phCredential->dwLower = (ULONG_PTR) pPackage ;
        phCredential->dwUpper = TempCreds.dwUpper ;
    }

    DebugLog(( DEB_TRACE, "AcquireCredentialsHandleCommon returns %x, handle is %p : %p\n",
                    scRet, phCredential->dwUpper, phCredential->dwLower ));

    return( scRet );

}

//+---------------------------------------------------------------------------
//
//  Function:   AddCredentialsW
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [phCredential]     --
//              [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [ptsExpiry]        --
//
//  History:    9-11-99   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AddCredentialsW(
    PCredHandle                 phCredentials,
    LPWSTR                      pszPrincipal,       // Name of principal
    LPWSTR                      pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PDLL_SECURITY_PACKAGE pPackage;

    if (!pszPackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    pPackage = SecLocatePackageW( pszPackageName );

    if ( pPackage == NULL )
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if ( pPackage->pftTableW->AddCredentialsW == NULL )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    DebugLog(( DEB_TRACE, "AddCredentialsW( ..., %ws, %d, ...)\n",
                    pPackage->PackageName.Buffer, fCredentialUse ));

    SetCurrentPackage(  pPackage );

    scRet = pPackage->pftTableW->AddCredentialsW(
                phCredentials,
                pszPrincipal,
                pszPackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                ptsExpiry);

    DebugLog(( DEB_TRACE, "AddCredentialsA returns %x, handle is %p : %p\n",
                    scRet ));

    return( scRet );

}


//+---------------------------------------------------------------------------
//
//  Function:   AddCredentialsA
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [phCredential]     --
//              [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [ptsExpiry]        --
//
//  History:    9-11-99   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AddCredentialsA(
    PCredHandle                 phCredentials,
    LPSTR                       pszPrincipal,       // Name of principal
    LPSTR                       pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    PDLL_SECURITY_PACKAGE pPackage;

    if (!pszPackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    pPackage = SecLocatePackageA( pszPackageName );

    if ( pPackage == NULL )
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if ( pPackage->pftTableA->AddCredentialsA == NULL )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    DebugLog(( DEB_TRACE, "AddCredentialsA( ..., %ws, %d, ...)\n",
                    pPackage->PackageName.Buffer, fCredentialUse ));

    SetCurrentPackage(  pPackage );

    scRet = pPackage->pftTableA->AddCredentialsA(
                phCredentials,
                pszPrincipal,
                pszPackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                ptsExpiry);

    DebugLog(( DEB_TRACE, "AddCredentialsA returns %x, handle is %p : %p\n",
                    scRet ));

    return( scRet );

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandle
//
//  Synopsis:   Stub for FreeCredentialsHandle
//
//  Arguments:  [phCredential] -- Credential to release
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
FreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
{
    CredHandle TempCredHandle;
    PDLL_SECURITY_PACKAGE Package;
    SECURITY_STATUS scRet ;

    Package = SecpValidateHandle( FALSE, phCredential, &TempCredHandle );

    if ( Package )
    {

        SetCurrentPackage( Package );

        scRet = Package->pftTable->FreeCredentialHandle( &TempCredHandle );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return( scRet );

}



//+---------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextW
//
//  Synopsis:   InitializeSecurityContext stub
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [Reserved]      --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [Reserved]      --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return InitializeSecurityContextCommon(
            phCredential,       // Cred to base context
            phContext,          // Existing context (OPT)
            pszTargetName,      // Name of target
            fContextReq,        // Context Requirements
            Reserved1,          // Reserved, MBZ
            TargetDataRep,      // Data rep of target
            pInput,             // Input Buffers
            Reserved2,          // Reserved, MBZ
            phNewContext,       // (out) New Context handle
            pOutput,            // (inout) Output Buffers
            pfContextAttr,      // (out) Context attrs
            ptsExpiry,          // (out) Life span (OPT)
            TRUE                // Unicode caller
            );
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextA
//
//  Synopsis:   ANSI stub
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPSTR                       pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{

    return InitializeSecurityContextCommon(
            phCredential,       // Cred to base context
            phContext,          // Existing context (OPT)
            (LPWSTR)pszTargetName,      // Name of target
            fContextReq,        // Context Requirements
            Reserved1,          // Reserved, MBZ
            TargetDataRep,      // Data rep of target
            pInput,             // Input Buffers
            Reserved2,          // Reserved, MBZ
            phNewContext,       // (out) New Context handle
            pOutput,            // (inout) Output Buffers
            pfContextAttr,      // (out) Context attrs
            ptsExpiry,          // (out) Life span (OPT)
            FALSE               // NOT Unicode
            );

}

SECURITY_STATUS
SEC_ENTRY
InitializeSecurityContextCommon(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry,          // (out) Life span (OPT)
    BOOLEAN                     fUnicode            // (in) Unicode caller?
    )
{
    SECURITY_STATUS scRet = SEC_E_OK;
    CredHandle TempCredHandle ;
    CtxtHandle TempCtxtHandle ;
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_SECURITY_PACKAGE CredPackage ;
    PDLL_SECURITY_PACKAGE EndPackage ;
    PCredHandle EffectiveCreds;
    PCtxtHandle EffectiveCtxt;
    CtxtHandle ResultCtxt;
    ULONG_PTR ContextFix;

    //
    // They need to provide at least one of these two
    //

    if( fUnicode )
    {
        DebugLog(( DEB_TRACE, "InitializeSecurityContextW( %p, %p, %ws, ... )\n",
                                phCredential, phContext, (pszTargetName ? pszTargetName : L"<null>" ) ));
    } else {
        DebugLog(( DEB_TRACE, "InitializeSecurityContextA( %p, %p, %s, ... )\n",
                                phCredential, phContext, ((LPSTR)pszTargetName ? (LPSTR)pszTargetName : "<null>" ) ));
    }

    if (!phCredential && !phContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    //
    // Need to determine which package to use.  Try the context handle first,
    // in case the context is actually present, and from a package other than
    // the credential (basically, the negotiator).
    //

    Package = NULL ;
    ResultCtxt.dwLower = (UINT_PTR) -1;
    if (phNewContext)
    {
        ResultCtxt.dwUpper = phNewContext->dwUpper;
    }

    if ( phContext )
    {
        //
        // Context is valid:
        //

        Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

        if ( !Package )
        {
            return( SEC_E_INVALID_HANDLE );
        }

        EffectiveCtxt = &TempCtxtHandle ;
    }
    else
    {
        EffectiveCtxt = NULL ;
    }

    //
    // Now do the creds:
    //

    if ( phCredential )
    {

        CredPackage = SecpValidateHandle( FALSE, phCredential, &TempCredHandle );

        if ( !CredPackage )
        {
            return( SEC_E_INVALID_HANDLE );
        }

        if ( !Package )
        {
            Package = CredPackage ;
        }

        EffectiveCreds = &TempCredHandle ;

    }
    else
    {
        EffectiveCreds = NULL ;
    }

    SetCurrentPackage( Package );

    if( fUnicode )
    {
        scRet = Package->pftTableW->InitializeSecurityContextW(
                        EffectiveCreds,
                        EffectiveCtxt,
                        pszTargetName,
                        fContextReq,
                        Reserved1,
                        TargetDataRep,
                        pInput,
                        Reserved2,
                        &ResultCtxt,
                        pOutput,
                        pfContextAttr,
                        ptsExpiry);
    } else {
        scRet = Package->pftTableA->InitializeSecurityContextA(
                        EffectiveCreds,
                        EffectiveCtxt,
                        (LPSTR)pszTargetName,
                        fContextReq,
                        Reserved1,
                        TargetDataRep,
                        pInput,
                        Reserved2,
                        &ResultCtxt,
                        pOutput,
                        pfContextAttr,
                        ptsExpiry);
    }


    if ( NT_SUCCESS( scRet ) )
    {

        if ( ResultCtxt.dwLower != (UINT_PTR) -1 )
        {
            if ( Package->TypeMask & SECPKG_TYPE_NEW )
            {
                EndPackage = SecLocatePackageById( ResultCtxt.dwLower );
            }
            else
            {
                EndPackage = SecLocatePackageByOriginalLower( TRUE, Package, ResultCtxt.dwLower );

            }

            if (EndPackage == NULL)
            {
                //
                // This should only happen in an out-of-memory case
                //

                if ( Package->OriginalLowerCtxt == 0 )
                {
                    EndPackage = Package ;
                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }

            }
            //
            // If the dwLower has been changed, then we need to store it away in the
            // package record, for a level of indirection.
            //
Retry_CtxtLowerTest:

            if ( EndPackage->fState & DLL_SECPKG_SAVE_LOWER )
            {
                //
                // Package has already been detected with a mapped handle value,
                // so, make sure they're the same,
                //

                if ( EndPackage->OriginalLowerCtxt != ResultCtxt.dwLower )
                {
                    DebugLog(( DEB_ERROR, "Security Package %ws is manipulating dwLower value inappropriately\n\treturned %p when %p expected.\n",
                            EndPackage->PackageName.Buffer, ResultCtxt.dwLower, EndPackage->OriginalLowerCtxt ));
                }
            }
            else
            {
                //
                // Package has not been tagged yet.  Time to do the dance
                //

                WriteLockPackageList();

                //
                // Test again.  If another thread is (has) updated, we should treat that as
                // authoritative.
                //

                if ( EndPackage->fState & DLL_SECPKG_SAVE_LOWER )
                {
                    //
                    // Another thread has fixed this up.  Release the lock, and jump back up
                    // to retry the operation.
                    //

                    UnlockPackageList();

                    goto Retry_CtxtLowerTest ;
                }

                //
                // Ok, we're the first.  Stick what the package wants as a dwLower into the
                // package record, and set the flag
                //

                EndPackage->OriginalLowerCtxt = ResultCtxt.dwLower ;

                EndPackage->fState |= DLL_SECPKG_SAVE_LOWER ;

                UnlockPackageList();

            }

            Package = EndPackage ;

        }

        if ( phNewContext )
        {
            phNewContext->dwUpper = ResultCtxt.dwUpper;
            phNewContext->dwLower = (ULONG_PTR) Package ;
        }
    }
    else if ( ( Package->TypeMask & SECPKG_TYPE_OLD ) != 0 )
    {
        if ( phNewContext )
        {
            if ( ( ResultCtxt.dwLower == (UINT_PTR) -1 ) ||
                 ( ResultCtxt.dwLower == Package->OriginalLowerCtxt ) )
            {
                ResultCtxt.dwLower = (ULONG_PTR) Package ;
            }

            *phNewContext = ResultCtxt ;
        }

    }

Cleanup:

    DebugLog(( DEB_TRACE, "InitializeSecurityContextW returns status %x\n", scRet ));

    return( scRet );
}


//+---------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:   AcceptSecurityContext stub
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pInput]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{

    SECURITY_STATUS scRet = SEC_E_OK;
    CredHandle TempCredHandle ;
    CtxtHandle TempCtxtHandle ;
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_SECURITY_PACKAGE CredPackage ;
    PDLL_SECURITY_PACKAGE EndPackage ;
    PCredHandle EffectiveCreds;
    PCtxtHandle EffectiveCtxt;
    CtxtHandle ResultCtxt;
    ULONG_PTR ContextFix;

    //
    // They need to provide at least one of these two
    //

    if (!phCredential && !phContext)
    {
        return( SEC_E_INVALID_HANDLE );
    }

    //
    // Need to determine which package to use.  Try the context handle first,
    // in case the context is actually present, and from a package other than
    // the credential (basically, the negotiator).
    //

    Package = NULL ;
    ResultCtxt.dwLower = (UINT_PTR) -1 ;
    if (phNewContext)
    {
        ResultCtxt.dwUpper = phNewContext->dwUpper;
    }

    if ( phContext )
    {
        //
        // Context is valid:
        //

        Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

        if ( !Package )
        {
            return( SEC_E_INVALID_HANDLE );
        }

        EffectiveCtxt = &TempCtxtHandle ;
    }
    else
    {
        EffectiveCtxt = NULL ;
    }

    //
    // Now do the creds:
    //

    if ( phCredential )
    {

        CredPackage = SecpValidateHandle( FALSE, phCredential, &TempCredHandle );

        if ( !CredPackage )
        {
            return( SEC_E_INVALID_HANDLE );
        }

        if ( !Package )
        {
            Package = CredPackage ;
        }

        EffectiveCreds = &TempCredHandle ;

    }
    else
    {
        EffectiveCreds = NULL ;
    }

    DebugLog(( DEB_TRACE, "AcceptSecurityContext( [%ws] %x : %x, %x : %x, ...)\n",
            Package->PackageName.Buffer,
            EffectiveCreds ? EffectiveCreds->dwUpper : 0 ,
            EffectiveCreds ? EffectiveCreds->dwLower : 0 ,
            EffectiveCtxt ? EffectiveCtxt->dwUpper : 0 ,
            EffectiveCtxt ? EffectiveCtxt->dwLower : 0  ));

    SetCurrentPackage( Package );

    scRet = Package->pftTable->AcceptSecurityContext(
                EffectiveCreds,
                EffectiveCtxt,
                pInput,
                fContextReq,
                TargetDataRep,
                &ResultCtxt,
                pOutput,
                pfContextAttr,
                ptsExpiry);

    if ( NT_SUCCESS( scRet ) )
    {
        if ( ResultCtxt.dwLower != (UINT_PTR) -1 )
        {
            if ( Package->TypeMask & SECPKG_TYPE_NEW )
            {
                EndPackage = SecLocatePackageById( ResultCtxt.dwLower );
            }
            else
            {
                EndPackage = SecLocatePackageByOriginalLower( TRUE, Package, ResultCtxt.dwLower );


            }
            if (EndPackage == NULL)
            {
                //
                // This should only happen in an out-of-memory case
                //

                if ( Package->OriginalLowerCtxt == 0 )
                {
                    EndPackage = Package ;
                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                    goto Cleanup;
                }
            }

            //
            // If the dwLower has been changed, then we need to store it away in the
            // package record, for a level of indirection.
            //
Retry_CtxtLowerTest:

            if ( EndPackage->fState & DLL_SECPKG_SAVE_LOWER )
            {
                //
                // Package has already been detected with a mapped handle value,
                // so, make sure they're the same,
                //

                if ( EndPackage->OriginalLowerCtxt != ResultCtxt.dwLower )
                {
                    DebugLog(( DEB_ERROR, "Security Package %ws is manipulating dwLower value inappropriately\n\treturned %p when %p expected.\n",
                            EndPackage->PackageName.Buffer, ResultCtxt.dwLower, EndPackage->OriginalLowerCtxt ));
                }
            }
            else
            {
                //
                // Package has not been tagged yet.  Time to do the dance
                //

                WriteLockPackageList();

                //
                // Test again.  If another thread is (has) updated, we should treat that as
                // authoritative.
                //

                if ( EndPackage->fState & DLL_SECPKG_SAVE_LOWER )
                {
                    //
                    // Another thread has fixed this up.  Release the lock, and jump back up
                    // to retry the operation.
                    //

                    UnlockPackageList();

                    goto Retry_CtxtLowerTest ;
                }

                //
                // Ok, we're the first.  Stick what the package wants as a dwLower into the
                // package record, and set the flag
                //

                EndPackage->OriginalLowerCtxt = ResultCtxt.dwLower ;

                EndPackage->fState |= DLL_SECPKG_SAVE_LOWER ;

                UnlockPackageList();

            }

            Package = EndPackage ;
        }

        if ( phNewContext )
        {
            phNewContext->dwLower = (ULONG_PTR) Package ;
            phNewContext->dwUpper = ResultCtxt.dwUpper;
        }

    }

Cleanup:
    if( phNewContext )
    {
        DebugLog(( DEB_TRACE, "AcceptSecurityContext returns %x, handle %x : %x\n",
                scRet, phNewContext->dwUpper, phNewContext->dwLower ));
    }

    return( scRet );

}





//+---------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:   DeleteSecurityContext stub
//
//  Arguments:  [delete] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    )
{
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;
    SECURITY_STATUS scRet ;

    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        SetCurrentPackage( Package );

        scRet = Package->pftTable->DeleteSecurityContext( &TempCtxtHandle );

        if ( Package->fState & DLL_SECPKG_SASL_PROFILE )
        {
            SaslDeleteSecurityContext( &TempCtxtHandle );
        }

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return( scRet );



}



//+-------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    SECURITY_STATUS     scRet = SEC_E_OK;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package ;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTable->ApplyControlToken(
                                            &TempCtxtHandle,
                                            pInput );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);


}




//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesW
//
//  Synopsis:   EnumerateSecurityPackages stub
//
//  Arguments:  [pcPackages] --
//              [info]       --
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
EnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    )
{
    PDLL_SECURITY_PACKAGE   Package;

    Package = SecLocatePackageById( 0 );

    if (SecEnumeratePackagesW( pcPackages, ppPackageInfo ))
    {
        return( SEC_E_OK );
    }
    return( SEC_E_INSUFFICIENT_MEMORY );


}
//+---------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesA
//
//  Synopsis:   Ansi stub
//
//  Arguments:  [pcPackages] --
//              [info]       --
//
//  History:    9-11-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
EnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *      ppPackageInfo       // Receives array of info
    )
{
    PDLL_SECURITY_PACKAGE   Package;

    Package = SecLocatePackageById( 0 );

    if (SecEnumeratePackagesA( pcPackages, ppPackageInfo ))
    {
        return( SEC_E_OK );
    }

    return( SEC_E_INSUFFICIENT_MEMORY );


}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pszPackageName] --
//              [info]           --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QuerySecurityPackageInfoW(
    LPWSTR                      pszPackageName,     // Name of package
    PSecPkgInfoW SEC_FAR *      pPackageInfo        // Receives package info
    )
{
    SECURITY_STATUS scRet;
    PDLL_SECURITY_PACKAGE Package;

    Package = SecLocatePackageW( pszPackageName );

    scRet = SecCopyPackageInfoToUserW( Package, pPackageInfo );

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pszPackageName] --
//              [info]           --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QuerySecurityPackageInfoA(
    LPSTR                       pszPackageName,     // Name of package
    PSecPkgInfoA SEC_FAR *      pPackageInfo        // Receives package info
    )
{
    SECURITY_STATUS scRet;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecLocatePackageA( pszPackageName );

    return SecCopyPackageInfoToUserA( Package, pPackageInfo );
}



//+-------------------------------------------------------------------------
//
//  Function:   CompleteAuthToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pInput              // Token to complete
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTable->CompleteAuthToken(
                                            &TempCtxtHandle,
                                            pInput );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTable->ImpersonateSecurityContext(
                                            &TempCtxtHandle );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   QuerySecurityContextToken
//
//  Synopsis:   Stub for QuerySecurityContextToken
//
//  Arguments:  [phContext]   --
//              [TokenHandle] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle                 phContext,
    VOID * *                    TokenHandle
    )
{

    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        if ( Package->pftTable->QuerySecurityContextToken )
        {
            SetCurrentPackage( NULL );

            scRet = Package->pftTable->QuerySecurityContextToken(
                                                        &TempCtxtHandle,
                                                        TokenHandle );

        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION ;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);
}



SECURITY_STATUS
SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTable->RevertSecurityContext(
                                            &TempCtxtHandle );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesW
//
//  Synopsis:   QueryContextAttributesW stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTableW->QueryContextAttributesW(
                                            &TempCtxtHandle,
                                            ulAttribute,
                                            pBuffer );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesA
//
//  Synopsis:   ANSI stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        scRet = Package->pftTableA->QueryContextAttributesA(
                                            &TempCtxtHandle,
                                            ulAttribute,
                                            pBuffer );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SetContextAttributesW
//
//  Synopsis:   SetContextAttributesW stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SetContextAttributesW(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        if ( Package->pftTableW->dwVersion >= SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2 &&
             Package->pftTableW->SetContextAttributesW != NULL ) {

            SetCurrentPackage( Package );

            scRet = Package->pftTableW->SetContextAttributesW(
                                            &TempCtxtHandle,
                                            ulAttribute,
                                            pBuffer,
                                            cbBuffer );
        } else {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SetContextAttributesA
//
//  Synopsis:   ANSI stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SetContextAttributesA(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        if ( Package->pftTableA->dwVersion >= SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2 &&
             Package->pftTableA->SetContextAttributesA != NULL ) {

            SetCurrentPackage( Package );

            scRet = Package->pftTableA->SetContextAttributesA(
                                            &TempCtxtHandle,
                                            ulAttribute,
                                            pBuffer,
                                            cbBuffer );
        } else {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   QueryCredentialsAttributes
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
QueryCredentialsAttributesW(
    PCredHandle                 phCredentials,      // Credentials to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCredHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( FALSE, phCredentials, &TempCredHandle );

    if ( Package )
    {
        if ( Package->pftTableW->QueryCredentialsAttributesW )
        {

            SetCurrentPackage( Package );

            scRet = Package->pftTableW->QueryCredentialsAttributesW(
                                            &TempCredHandle,
                                            ulAttribute,
                                            pBuffer );

        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION ;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

SECURITY_STATUS
SEC_ENTRY
QueryCredentialsAttributesA(
    PCredHandle                 phCredentials,      // Credentials to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCredHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( FALSE, phCredentials, &TempCredHandle );

    if ( Package )
    {
        if ( Package->pftTableA->QueryCredentialsAttributesA )
        {

            SetCurrentPackage( Package );

            scRet = Package->pftTableA->QueryCredentialsAttributesA(
                                            &TempCredHandle,
                                            ulAttribute,
                                            pBuffer );

        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION ;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+-------------------------------------------------------------------------
//
//  Function:   MakeSignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
MakeSignature(  PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        SetCurrentPackage( Package );

        scRet = Package->pftTable->MakeSignature(
                                            &TempCtxtHandle,
                                            fQOP,
                                            pMessage,
                                            MessageSeqNo );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);


}



//+-------------------------------------------------------------------------
//
//  Function:   VerifySignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to verify
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                ULONG *         pfQOP)
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {

        SetCurrentPackage( Package );

        scRet = Package->pftTable->VerifySignature(
                                            &TempCtxtHandle,
                                            pMessage,
                                            MessageSeqNo,
                                            pfQOP );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SealMessage
//
//  Synopsis:   Seals a message
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SECURITY_STATUS
SEC_ENTRY
EncryptMessage( PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;
    SEAL_MESSAGE_FN SealMessageFn;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        SealMessageFn = (SEAL_MESSAGE_FN) Package->pftTable->Reserved3 ;

        scRet = (SealMessageFn)(
                                 &TempCtxtHandle,
                                 fQOP,
                                 pMessage,
                                 MessageSeqNo );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);



}

//+---------------------------------------------------------------------------
//
//  Function:   UnsealMessage
//
//  Synopsis:   Unseal a private message
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to unseal
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
DecryptMessage( PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                ULONG *             pfQOP)
{
    SECURITY_STATUS scRet;
    CtxtHandle TempCtxtHandle;
    PDLL_SECURITY_PACKAGE Package;
    UNSEAL_MESSAGE_FN UnsealMessageFunc;


    Package = SecpValidateHandle( TRUE, phContext, &TempCtxtHandle );

    if ( Package )
    {
        SetCurrentPackage( Package );

        UnsealMessageFunc = (UNSEAL_MESSAGE_FN) Package->pftTable->Reserved4 ;

        scRet = (UnsealMessageFunc)(
                                     &TempCtxtHandle,
                                     pMessage,
                                     MessageSeqNo,
                                     pfQOP );

    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   InitSecurityInterfaceA
//
//  Synopsis:   Retrieves the ANSI interface table
//
//  Arguments:  (none)
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSecurityFunctionTableA
SEC_ENTRY
InitSecurityInterfaceA(
    VOID )
{
    DebugLog((DEB_TRACE, "Doing it the hard way:  @%x\n", &SecTableA));

    return( &SecTableA );
}

//+-------------------------------------------------------------------------
//
//  Function:   InitSecurityInterface
//
//  Synopsis:   returns function table of all the security function
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

PSecurityFunctionTableW
SEC_ENTRY
InitSecurityInterfaceW(void)
{
    DebugLog((DEB_TRACE, "Doing it the hard way:  @%x\n", &SecTableW));

    return( &SecTableW );
}


//+-------------------------------------------------------------------------
//
//  Function:   ExportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ExportSecurityContext(
    IN PCtxtHandle ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer MarshalledContext,
    OUT PHANDLE TokenHandle
    )
{
    PDLL_SECURITY_PACKAGE Package;
    CtxtHandle TempContextHandle;
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;

    Package = SecpValidateHandle(
                TRUE,
                ContextHandle,
                &TempContextHandle
                );
    if (Package != NULL)
    {
        if (Package->pftTable->ExportSecurityContext != NULL)
        {
            SetCurrentPackage(Package);

            SecStatus = Package->pftTable->ExportSecurityContext(
                            &TempContextHandle,
                            Flags,
                            MarshalledContext,
                            TokenHandle
                            );

        }
        else
        {
            SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }
    else
    {
        SecStatus = SEC_E_INVALID_HANDLE;
    }
    return(SecStatus);
}


//+-------------------------------------------------------------------------
//
//  Function:   ImportSecurityContextW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ImportSecurityContextW(
    IN LPWSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PDLL_SECURITY_PACKAGE Package;
    CtxtHandle TempContextHandle = {-1,-1};
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;

    if (!PackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    Package = SecLocatePackageW( PackageName );

    if ( Package == NULL )
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if (Package->pftTableW->ImportSecurityContextW != NULL)
    {
        SetCurrentPackage(Package);

        SecStatus = Package->pftTable->ImportSecurityContextW(
                        PackageName,
                        MarshalledContext,
                        TokenHandle,
                        &TempContextHandle
                        );

    }
    else
    {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
    }

    if (NT_SUCCESS(SecStatus))
    {
        ContextHandle->dwUpper = TempContextHandle.dwUpper;
        ContextHandle->dwLower = (ULONG_PTR) Package;


    }
    return(SecStatus);
}


//+-------------------------------------------------------------------------
//
//  Function:   ImportSecurityContextA
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ImportSecurityContextA(
    IN LPSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PDLL_SECURITY_PACKAGE Package;
    CtxtHandle TempContextHandle = {-1,-1};
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;

    if (!PackageName)
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    Package = SecLocatePackageA( PackageName );

    if ( Package == NULL )
    {
        return( SEC_E_SECPKG_NOT_FOUND );
    }

    if (Package->pftTableA->ImportSecurityContextA != NULL)
    {
        SetCurrentPackage(Package);

        SecStatus = Package->pftTableA->ImportSecurityContextA(
                        PackageName,
                        MarshalledContext,
                        TokenHandle,
                        &TempContextHandle
                        );

    }
    else
    {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
    }

    if (NT_SUCCESS(SecStatus))
    {
        ContextHandle->dwUpper = TempContextHandle.dwUpper;
        ContextHandle->dwLower = (ULONG_PTR) Package;
    }
    return(SecStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\negstubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       negstubs.cxx
//
//  Contents:   Stubs to the negotiate package
//
//  Classes:
//
//  Functions:
//
//  History:    8-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

SpInstanceInitFn                NegInstanceInit;
SpInitUserModeContextFn         NegInitUserModeContext;
SpMakeSignatureFn               NegMakeSignature;
SpVerifySignatureFn             NegVerifySignature;
SpSealMessageFn                 NegSealMessage;
SpUnsealMessageFn               NegUnsealMessage;
SpGetContextTokenFn             NegGetContextToken;
SpQueryContextAttributesFn      NegQueryContextAttributes;
SpDeleteContextFn               NegDeleteUserModeContext;
SpCompleteAuthTokenFn           NegCompleteAuthToken;
SpFormatCredentialsFn           NegFormatCredentials;
SpMarshallSupplementalCredsFn   NegMarshallSupplementalCreds;
SpExportSecurityContextFn       NegExportSecurityContext;
SpImportSecurityContextFn       NegImportSecurityContext;

SECPKG_USER_FUNCTION_TABLE NegTable =
    {
     NegInstanceInit,
     NegInitUserModeContext,
     NegMakeSignature,
     NegVerifySignature,
     NegSealMessage,
     NegUnsealMessage,
     NegGetContextToken,
     NegQueryContextAttributes,
     NegCompleteAuthToken,
     NegDeleteUserModeContext,
     NegFormatCredentials,
     NegMarshallSupplementalCreds,
     NegExportSecurityContext,
     NegImportSecurityContext

    } ;

#define NegGenerateLsaHandle( PackageHandle, NewHandle ) \
            ((PSecHandle) NewHandle)->dwUpper = PackageHandle ; \
            ((PSecHandle) NewHandle)->dwLower = ((PDLL_SECURITY_PACKAGE) GetCurrentPackage())->OriginalLowerCtxt ;


NTSTATUS
SEC_ENTRY
NegUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables)
{
    PSECPKG_USER_FUNCTION_TABLE Table ;

    if (LsaVersion < SECPKG_INTERFACE_VERSION)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION ;

    *UserFunctionTable = &NegTable ;
    *pcTables = 1;

    return STATUS_SUCCESS ;

}


NTSTATUS NTAPI
NegInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    return STATUS_SUCCESS ;
}


NTSTATUS NTAPI
NegDeleteUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    return STATUS_SUCCESS ;
}


NTSTATUS NTAPI
NegInitUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    return STATUS_SUCCESS ;
}


NTSTATUS NTAPI
NegExportSecurityContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    OUT PHANDLE TokenHandle
    )
{
    return SEC_E_INVALID_HANDLE ;
}

NTSTATUS
NTAPI
NegImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN HANDLE Token,
    OUT PLSA_SEC_HANDLE ContextHandle
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}

NTSTATUS NTAPI
NegGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    SEC_HANDLE_LPC hContext ;
    NTSTATUS Status ;
    ULONG Allocs = 0 ;
    PVOID Buffers[ 2 ] = { 0 };
    ULONG Flags = 0;
#ifdef BUILD_WOW64
    CtxtHandle Temp ;
#endif 

    switch ( ContextAttribute )
    {
        case SECPKG_ATTR_NEGOTIATION_INFO:
        {

#ifdef BUILD_WOW64

            //
            // Server side of this call copies over an entire new Buffer -- make sure
            // there's enough space for it.
            //

            SECPKGCONTEXT_NEGOTIATIONINFOWOW64  NegoInfo64;
            PSECPKG_INFO_WOW64                  pPackageInfo64;
            PSecPkgContext_NegotiationInfo      NegoInfo = (PSecPkgContext_NegotiationInfo) Buffer;

            Buffer = &NegoInfo64;

            NegGenerateLsaHandle( ContextHandle, &Temp );
            SecpReferenceHandleMap( 
                    (PSECWOW_HANDLE_MAP) Temp.dwUpper, 
                    &hContext );
#else
            NegGenerateLsaHandle( ContextHandle, &hContext );
#endif 
            Status = SecpQueryContextAttributes(
                        NULL,
                        &hContext,
                        SECPKG_ATTR_NEGOTIATION_INFO,
                        Buffer,
                        &Allocs,
                        Buffers,
                        &Flags );

#ifdef BUILD_WOW64

            pPackageInfo64 = (PSECPKG_INFO_WOW64) (ULONG) NegoInfo64.pPackageInfo64;

            NegoInfo->PackageInfo      = (PSecPkgInfoW) pPackageInfo64;
            NegoInfo->NegotiationState = NegoInfo64.NegotiationState;

            SecpLpcPkgInfoToSecPkgInfo(NegoInfo->PackageInfo, pPackageInfo64);
            Buffer = NegoInfo;

            SecpDerefHandleMap( 
                    (PSECWOW_HANDLE_MAP) Temp.dwUpper );
#endif 

            if ( NT_SUCCESS( Status ) )
            {
                ULONG i ;

                for ( i = 0 ; i < Allocs ; i++ )
                {
                    SecpAddVM( Buffers[ i ] );
                }

            }

            return Status ;
        }

        default:
            return SEC_E_UNSUPPORTED_FUNCTION ;

    }
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


NTSTATUS NTAPI
NegCompleteAuthToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
NegFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
NegMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    return(STATUS_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\lsastubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       lsastubs.cxx
//
//  Contents:   Stubs to the pseudo-sspi dll that talks to the LSA
//
//  Classes:
//
//  Functions:
//
//  History:    8-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <credp.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
#include <stddef.h>
}

SECURITY_STATUS SEC_ENTRY
LsaAcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
LsaAcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
LsaAddCredentialsW(
    PCredHandle hCredentials,
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
LsaAddCredentialsA(
    PCredHandle hCredentials,
    SEC_CHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_CHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
LsaFreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    );


SECURITY_STATUS SEC_ENTRY
LsaInitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
LsaInitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
LsaInitializeSecurityContextCommon(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry,          // (out) Life span (OPT)
    BOOLEAN                     fUnicode            // (in) Unicode call?
    );


SECURITY_STATUS SEC_ENTRY
LsaAcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );


SECURITY_STATUS SEC_ENTRY
LsaDeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    );



SECURITY_STATUS SEC_ENTRY
LsaApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    );


SECURITY_STATUS SEC_ENTRY
LsaEnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    );

SECURITY_STATUS SEC_ENTRY
LsaEnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *      ppPackageInfo       // Receives array of info
    );


SECURITY_STATUS SEC_ENTRY
LsaQuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoW *              ppPackageInfo       // Receives package info
    );

SECURITY_STATUS SEC_ENTRY
LsaQuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoA *              ppPackageInfo       // Receives package info
    );


SECURITY_STATUS SEC_ENTRY
LsaFreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    );


SECURITY_STATUS SEC_ENTRY
LsaQueryCredentialsAttributesW(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    );

SECURITY_STATUS SEC_ENTRY
LsaQueryCredentialsAttributesA(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    );


SECURITY_STATUS SEC_ENTRY
LsaCompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    );


SECURITY_STATUS SEC_ENTRY
LsaImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    );


SECURITY_STATUS SEC_ENTRY
LsaRevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    );


SECURITY_STATUS SEC_ENTRY
LsaQueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );

SECURITY_STATUS SEC_ENTRY
LsaQueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );

SECURITY_STATUS SEC_ENTRY
LsaSetContextAttributesW(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    );

SECURITY_STATUS SEC_ENTRY
LsaSetContextAttributesA(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    );


SECURITY_STATUS SEC_ENTRY
LsaMakeSignature(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );

SECURITY_STATUS SEC_ENTRY
LsaVerifySignature(
    PCtxtHandle     phContext,
    PSecBufferDesc  pMessage,
    ULONG           MessageSeqNo,
    DWORD *         pfQOP
    );


SECURITY_STATUS SEC_ENTRY
LsaSealMessage(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );


SECURITY_STATUS SEC_ENTRY
LsaUnsealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo,
    DWORD *             pfQOP
    );


SECURITY_STATUS
SEC_ENTRY
LsaQuerySecurityContextToken(
    PCtxtHandle                 phContext,
    PHANDLE                     TokenHandle
    );


SECURITY_STATUS
SEC_ENTRY
LsaExportContext(
    IN PCtxtHandle ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer MarshalledContext,
    OUT PHANDLE TokenHandle
    );

SECURITY_STATUS
SEC_ENTRY
LsaImportContextW(
    IN LPWSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    );

SECURITY_STATUS
SEC_ENTRY
LsaImportContextA(
    IN LPSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    );

static LUID            lFake = {0, 0};
static SECURITY_STRING sFake = {0, 0, NULL};
static SecBufferDesc EmptyBuffer;
BOOL LsaPackageShutdown ;

SecurityFunctionTableW LsaFunctionTable = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2,
    LsaEnumerateSecurityPackagesW,
    LsaQueryCredentialsAttributesW,
    LsaAcquireCredentialsHandleW,
    LsaFreeCredentialsHandle,
    NULL,
    LsaInitializeSecurityContextW,
    LsaAcceptSecurityContext,
    LsaCompleteAuthToken,
    LsaDeleteSecurityContext,
    LsaApplyControlToken,
    LsaQueryContextAttributesW,
    LsaImpersonateSecurityContext,
    LsaRevertSecurityContext,
    LsaMakeSignature,
    LsaVerifySignature,
    FreeContextBuffer,
    LsaQuerySecurityPackageInfoW,
    LsaSealMessage,
    LsaUnsealMessage,
    LsaExportContext,
    LsaImportContextW,
    LsaAddCredentialsW,
    NULL,
    LsaQuerySecurityContextToken,
    LsaSealMessage,
    LsaUnsealMessage,
    LsaSetContextAttributesW
    };

SecurityFunctionTableA LsaFunctionTableA = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION_2,
    NULL,                                       // NOTE: NEVER CALLED
    LsaQueryCredentialsAttributesA,
    LsaAcquireCredentialsHandleA,
    LsaFreeCredentialsHandle,
    NULL,
    LsaInitializeSecurityContextA,
    LsaAcceptSecurityContext,
    LsaCompleteAuthToken,
    LsaDeleteSecurityContext,
    LsaApplyControlToken,
    LsaQueryContextAttributesA,
    LsaImpersonateSecurityContext,
    LsaRevertSecurityContext,
    LsaMakeSignature,
    LsaVerifySignature,
    FreeContextBuffer,
    NULL,                                       // NOTE: NEVER CALLED
    LsaSealMessage,
    LsaUnsealMessage,
    LsaExportContext,
    LsaImportContextA,
    LsaAddCredentialsA,
    NULL,
    LsaQuerySecurityContextToken,
    LsaSealMessage,
    LsaUnsealMessage,
    LsaSetContextAttributesA
    };


//+---------------------------------------------------------------------------
//
//  Function:   LsapConvertUnicodeString
//
//  Synopsis:   Converts a Unicode string to an ANSI string for the stubs
//
//  Arguments:  [String] --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PSTR
LsapConvertUnicodeString(
    PUNICODE_STRING String)
{
    ANSI_STRING s;
    NTSTATUS Status;

    s.MaximumLength = String->MaximumLength ;

    s.Buffer = (PSTR) SecClientAllocate( s.MaximumLength );

    if ( s.Buffer )
    {
        s.Length = 0;

        Status = RtlUnicodeStringToAnsiString( &s, String, FALSE );

        if ( NT_SUCCESS( Status ) )
        {
            return( s.Buffer );
        }

        SecClientFree( s.Buffer );

    }

    return( NULL );
}


//+-------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaAcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *          pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *          pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STRING Principal;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet = S_OK;
    ULONG Flags ;
    SEC_HANDLE_LPC LocalCredHandle ;
#ifdef BUILD_WOW64
    PSECWOW_HANDLE_MAP MappedCredHandle ;
#endif

    if (!pszPackageName)
    {
        scRet = (HRESULT_FROM_NT(STATUS_INVALID_PARAMETER));
        goto Cleanup;
    }

    RtlInitUnicodeString(&PackageName, pszPackageName);
    if (!pszPrincipal || !(*pszPrincipal))
    {
        Principal = sFake;
    } else
    {
        RtlInitUnicodeString(&Principal, pszPrincipal);
    }

    Flags = 0;

    scRet = SecpAcquireCredentialsHandle(
                NULL,
                &Principal,
                &PackageName,
                fCredentialUse,
                (pvLogonId ? (PLUID) pvLogonId : &lFake),
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                &LocalCredHandle,
                ptsExpiry,
                &Flags );


    if NT_SUCCESS( scRet )
    {

#ifdef BUILD_WOW64
        if ( !SecpAddHandleMap(
                    &LocalCredHandle,
                    &MappedCredHandle ) )
        {
            SecpFreeCredentialsHandle( 0, &LocalCredHandle );
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
        }
        else
        {
            phCredential->dwUpper = (ULONG) MappedCredHandle ;
        }
#else

        *phCredential = LocalCredHandle ;

#endif

    }


    SecStoreReturnCode(scRet);

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}

//+---------------------------------------------------------------------------
//
//  Function:   LsaAcquireCredentialsHandleA
//
//  Synopsis:   ANSI stub for AcquireCredentialsHandle
//
//  Arguments:  [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pvLogonId]        --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [pvGetKeyArgument] --
//              [phCredential]     --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaAcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *          pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *          pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STRING Principal;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet = S_OK;
    ULONG Flags;
    SEC_HANDLE_LPC LocalCredHandle ;
#ifdef BUILD_WOW64
    PSECWOW_HANDLE_MAP MappedCredHandle ;
#endif

    if (!pszPackageName)
    {
        scRet = ( HRESULT_FROM_NT(STATUS_INVALID_PARAMETER) );
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz( &PackageName, pszPackageName ))
    {
        scRet = ( SEC_E_INSUFFICIENT_MEMORY );
        goto Cleanup;
    }

    if (!pszPrincipal || !(*pszPrincipal))
    {
        Principal = sFake;
    }
    else
    {
        if (!RtlCreateUnicodeStringFromAsciiz(&Principal, pszPrincipal) )
        {
            RtlFreeUnicodeString( &PackageName );

            scRet = (SEC_E_INSUFFICIENT_MEMORY) ;

            goto Cleanup;
        }
    }

    Flags = SPMAPI_FLAG_ANSI_CALL ;

    scRet = SecpAcquireCredentialsHandle(
                NULL,
                &Principal,
                &PackageName,
                fCredentialUse,
                (pvLogonId ? (PLUID) pvLogonId : &lFake),
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                &LocalCredHandle,
                ptsExpiry,
                &Flags );

    RtlFreeUnicodeString( &PackageName );

    if ( Principal.Buffer )
    {
        RtlFreeUnicodeString( &Principal );
    }

    if NT_SUCCESS( scRet )
    {

#ifdef BUILD_WOW64
        if ( !SecpAddHandleMap(
                    &LocalCredHandle,
                    &MappedCredHandle ) )
        {
            SecpFreeCredentialsHandle( 0, &LocalCredHandle );
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
        }
        else
        {
            phCredential->dwUpper = (ULONG) MappedCredHandle ;
        }
#else

        *phCredential = LocalCredHandle ;

#endif

    }

    SecStoreReturnCode(scRet);

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}


//+---------------------------------------------------------------------------
//
//  Function:   LsaAddCredentialsW
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [phCredential]     --
//              [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [ptsExpiry]        --
//
//  History:    9-11-99   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
LsaAddCredentialsW(
    PCredHandle hCredentials,
    SEC_WCHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_WCHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    SECURITY_STRING Principal;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet = S_OK;
    SEC_HANDLE_LPC LocalHandle ;
    ULONG Flags ;

    if (!pszPackage)
    {
        scRet = (HRESULT_FROM_NT(STATUS_INVALID_PARAMETER));
        goto Cleanup;
    }

    RtlInitUnicodeString(&PackageName, pszPackage);
    if (!pszPrincipal || !(*pszPrincipal))
    {
        Principal = sFake;
    }
    else
    {
        RtlInitUnicodeString(&Principal, pszPrincipal);
    }

    Flags = 0;

#ifdef BUILD_WOW64

    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) hCredentials->dwUpper,
            &LocalHandle
            );
#else
    LocalHandle = *hCredentials ;
#endif


    scRet = SecpAddCredentials(
                NULL,
                &LocalHandle,
                &Principal,
                &PackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                ptsExpiry,
                &Flags );

    SecStoreReturnCode(scRet);

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) hCredentials->dwUpper );
#endif

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}



//+---------------------------------------------------------------------------
//
//  Function:   LsaAddCredentialsA
//
//  Synopsis:   Stub for acquire credentials handle
//
//  Arguments:  [phCredential]     --
//              [pszPrincipal]     --
//              [pszPackageName]   --
//              [fCredentialUse]   --
//              [pAuthData]        --
//              [pGetKeyFn]        --
//              [GetKey]           --
//              [pvGetKeyArgument] --
//              [ptsExpiry]        --
//
//  History:    9-11-99   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
LsaAddCredentialsA(
    PCredHandle hCredentials,
    SEC_CHAR SEC_FAR * pszPrincipal,   // Name of principal
    SEC_CHAR SEC_FAR * pszPackage,     // Name of package
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    )
{
    SECURITY_STRING Principal;
    SECURITY_STRING PackageName;
    SECURITY_STATUS scRet = S_OK;
    SEC_HANDLE_LPC LocalHandle ;
    ULONG Flags;

    if (!pszPackage)
    {
        scRet = ( HRESULT_FROM_NT(STATUS_INVALID_PARAMETER) );
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz( &PackageName, pszPackage ))
    {
        scRet = ( SEC_E_INSUFFICIENT_MEMORY );
        goto Cleanup;
    }

    if (!pszPrincipal || !(*pszPrincipal))
    {
        Principal = sFake;
    }
    else
    {
        if (!RtlCreateUnicodeStringFromAsciiz(&Principal, pszPrincipal) )
        {
            RtlFreeUnicodeString( &PackageName );

            scRet = (SEC_E_INSUFFICIENT_MEMORY) ;

            goto Cleanup;
        }
    }

    Flags = SPMAPI_FLAG_ANSI_CALL ;

#ifdef BUILD_WOW64

    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) hCredentials->dwUpper,
            &LocalHandle
            );
#else
    LocalHandle = *hCredentials ;
#endif

    scRet = SecpAddCredentials(
                NULL,
                &LocalHandle,
                &Principal,
                &PackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                ptsExpiry,
                &Flags );

    RtlFreeUnicodeString( &PackageName );

    if ( Principal.Buffer )
    {
        RtlFreeUnicodeString( &Principal );
    }

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) hCredentials->dwUpper );
#endif

    SecStoreReturnCode(scRet);

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));


}



//+-------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaFreeCredentialsHandle(
    PCredHandle                 phCredential        // Handle to free
    )
{
    SECURITY_STATUS scRet;
    SEC_HANDLE_LPC LocalHandle ;


#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
            &LocalHandle
            );
#else

    LocalHandle = *phCredential ;

#endif

    scRet = SecpFreeCredentialsHandle(0, &LocalHandle);

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );

    SecpDeleteHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
#endif

    SecStoreReturnCode(scRet);

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaQueryCredentialsAttributesW
//
//  Synopsis:   Stub to LSA for querycredentialsattributes
//
//  Effects:
//
//  Arguments:  [phCredential] --
//              [ulAttribute]  --
//              [pBuffer]      --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaQueryCredentialsAttributesW(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer)
{
    SECURITY_STATUS scRet ;
    PSecPkgCredentials_Names CredNames;
    PVOID Buffers[ 8 ];
    ULONG Allocs ;
    SEC_HANDLE_LPC LocalHandle ;

    Allocs = 0 ;

#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
            &LocalHandle
            );
#else
    LocalHandle = *phCredential ;
#endif

    scRet = SecpQueryCredentialsAttributes(
                    &LocalHandle,
                    ulAttribute,
                    pBuffer,
                    0,
                    &Allocs,
                    Buffers );

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
#endif

    if ( NT_SUCCESS( scRet ) )
    {
        ULONG i ;

        for ( i = 0 ; i < Allocs ; i++ )
        {
            SecpAddVM( Buffers[ i ] );
        }
    }
    else
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaQueryCredentialsAttributesA
//
//  Synopsis:   ANSI stub for QueryCredentialsAttributes
//
//  Arguments:  [phCredential] --
//              [ulAttribute]  --
//              [pBuffer]      --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaQueryCredentialsAttributesA(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer)
{
    SECURITY_STATUS scRet ;
    PSecPkgCredentials_NamesW CredNamesW;
    PSTR Str;
    UNICODE_STRING Name;
    PVOID Buffers[ 8 ];
    ULONG Allocs ;
    ULONG i ;
    SEC_HANDLE_LPC LocalHandle ;

    Allocs = 0 ;

#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
            &LocalHandle
            );

#else
    LocalHandle = *phCredential ;
#endif

    scRet = SecpQueryCredentialsAttributes(
                    &LocalHandle,
                    ulAttribute,
                    pBuffer,
                    SPMAPI_FLAG_ANSI_CALL,
                    &Allocs,
                    Buffers );
#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
#endif


    if ( NT_SUCCESS( scRet ) )
    {
        switch ( ulAttribute )
        {
            case SECPKG_CRED_ATTR_NAMES:

                CredNamesW = (PSecPkgCredentials_NamesW) pBuffer ;

                RtlInitUnicodeString( &Name, CredNamesW->sUserName );

                Str = LsapConvertUnicodeString( &Name );

                if ( Str )
                {
                    CredNamesW->sUserName = (PWSTR) Str ;
                }
                else
                {
                    CredNamesW->sUserName = NULL ;

                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }

                LsaFreeReturnBuffer( CredNamesW->sUserName );

                break;

            default:

                for ( i = 0 ; i < Allocs ; i++ )
                {
                    SecpAddVM( Buffers[ i ] );
                }

                break;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


//+-------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaInitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return LsaInitializeSecurityContextCommon(
                    phCredential,       // Cred to base context
                    phContext,          // Existing context (OPT)
                    pszTargetName,      // Name of target
                    fContextReq,        // Context Requirements
                    Reserved1,          // Reserved, MBZ
                    TargetDataRep,      // Data rep of target
                    pInput,             // Input Buffers
                    Reserved2,          // Reserved, MBZ
                    phNewContext,       // (out) New Context handle
                    pOutput,            // (inout) Output Buffers
                    pfContextAttr,      // (out) Context attrs
                    ptsExpiry,          // (out) Life span (OPT)
                    TRUE                // Unicode caller
                    );
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaInitializeSecurityContextA
//
//  Synopsis:   ANSI stub for InitializeSecurityContext
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    9-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaInitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    return LsaInitializeSecurityContextCommon(
                    phCredential,       // Cred to base context
                    phContext,          // Existing context (OPT)
                    (SEC_WCHAR SEC_FAR *)pszTargetName,
                    fContextReq,        // Context Requirements
                    Reserved1,          // Reserved, MBZ
                    TargetDataRep,      // Data rep of target
                    pInput,             // Input Buffers
                    Reserved2,          // Reserved, MBZ
                    phNewContext,       // (out) New Context handle
                    pOutput,            // (inout) Output Buffers
                    pfContextAttr,      // (out) Context attrs
                    ptsExpiry,          // (out) Life span (OPT)
                    FALSE               // NOT Unicode
                    );

}

SECURITY_STATUS SEC_ENTRY
LsaInitializeSecurityContextCommon(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry,          // (out) Life span (OPT)
    BOOLEAN                     fUnicode            // (in) Unicode call?
    )
{
    SECURITY_STATUS scRet = S_OK;
    SECURITY_STRING Target;
    CredHandle hCredential;
    SecBuffer ContextData = {0,0,NULL};
    BOOLEAN MappedContext = FALSE;
    CtxtHandle NullContext = {0,0};
    DWORD   i;
    ULONG Flags;
    SEC_HANDLE_LPC LocalCred = { 0 };
    SEC_HANDLE_LPC LocalContext = { 0 };
    SEC_HANDLE_LPC LocalNewContext = { 0 } ;
#ifdef BUILD_WOW64
    PSECWOW_HANDLE_MAP HandleMap = NULL;
    BOOL DerefCred = FALSE ;
    BOOL DerefContext = FALSE ;
#endif

    //
    // They need to provide at least one of these two
    //

    if (!phCredential && !phContext)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }


    //
    // Check for valid sizes, pointers, etc.:
    //

    if (!ARGUMENT_PRESENT(phContext))
    {
        phContext = &NullContext;
    }
    else
    {
#ifdef BUILD_WOW64
        SecpReferenceHandleMap(
                (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                &LocalContext );

        DerefContext = TRUE ;
#else
        LocalContext = *phContext ;
#endif
    }

    if (!ARGUMENT_PRESENT(pInput))
    {
        pInput = &EmptyBuffer;
    }

    if (!ARGUMENT_PRESENT(pOutput))
    {
        pOutput = &EmptyBuffer;
    }



    if (!ARGUMENT_PRESENT(phCredential))
    {
        //
        // Since the package is keyed off the upper part, we need to set
        // it.
        //

        hCredential.dwLower = phContext->dwLower;
        hCredential.dwUpper = 0;
        phCredential = &hCredential;

        LocalCred.dwLower = phContext->dwLower ;

    }
    else
    {
#ifdef BUILD_WOW64

        SecpReferenceHandleMap(
                (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
                &LocalCred
                );

        DerefCred = TRUE ;
#else
        LocalCred = *phCredential ;
#endif
    }

    if( !fUnicode )
    {
        if ( !RtlCreateUnicodeStringFromAsciiz(
                    &Target,
                    (SEC_CHAR SEC_FAR *)pszTargetName
                    ))
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;

            goto Cleanup;
        }

        Flags = SPMAPI_FLAG_ANSI_CALL ;
    } else {
        RtlInitUnicodeString( &Target, pszTargetName );
        Flags = 0;
    }

    scRet = SecpInitializeSecurityContext(
                    NULL,
                    &LocalCred,
                    &LocalContext,
                    &Target,
                    fContextReq,
                    Reserved1,
                    TargetDataRep,
                    pInput,
                    Reserved2,
                    &LocalNewContext,
                    pOutput,
                    pfContextAttr,
                    ptsExpiry,
                    &MappedContext,
                    &ContextData,
                    &Flags );

    if( !fUnicode )
    {
        RtlFreeUnicodeString( &Target );
    }

#ifdef BUILD_WOW64
    if ( DerefCred )
    {
        SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
    }


    if ( DerefContext )
    {
        if ( (Flags & SPMAPI_FLAG_HANDLE_CHG ) != 0 )
        {
            SecpDeleteHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
        }

        SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( !(RtlEqualMemory( &LocalNewContext,
                               &LocalContext,
                               sizeof( SEC_HANDLE_LPC ) ) ) )
        {
            if ( SecpAddHandleMap( &LocalNewContext,
                                    &HandleMap ) )
            {
                phNewContext->dwLower = (LSA_SEC_HANDLE) LocalNewContext.dwLower ;
                phNewContext->dwUpper = (LSA_SEC_HANDLE) HandleMap ;

            }
            else
            {
                //
                // BUGBUG - not sure.  Need to clean out the
                // context data with a fake SECWOW_HANDLE_MAP
                //
                scRet = SEC_E_INSUFFICIENT_MEMORY ;

            }
        }
        else
        {
            *phNewContext = *phContext ;
            HandleMap = (PSECWOW_HANDLE_MAP) phContext->dwUpper ;
        }
    }
#else
    *phNewContext = LocalNewContext ;
#endif
    if (NT_SUCCESS(scRet) && MappedContext)
    {
        PDLL_SECURITY_PACKAGE   pspPackage ;
        PCtxtHandle     ContextHandle;
        SECURITY_STATUS SecondaryStatus;

        if ( (phContext != &NullContext) &&
             ((Flags & SPMAPI_FLAG_HANDLE_CHG) == 0) )
        {
            ContextHandle = phContext;
        }
        else
        {
            ContextHandle = phNewContext;
        }

#ifdef BUILD_WOW64
        ContextHandle->dwUpper = (LSA_SEC_HANDLE) HandleMap ;
        ContextHandle->dwLower = (LSA_SEC_HANDLE) LocalNewContext.dwLower ;
#else
        *ContextHandle = LocalNewContext ;
#endif
        pspPackage = SecLocatePackageById( ContextHandle->dwLower );
        if ((pspPackage != NULL)  && (pspPackage->pftUTable != NULL))
        {
            SecpAddVM( ContextData.pvBuffer );

            SecondaryStatus = pspPackage->pftUTable->InitUserModeContext(
                                ContextHandle->dwUpper,
                                &ContextData
                                );
            if (!NT_SUCCESS(SecondaryStatus))
            {
                scRet = SecondaryStatus;

                //
                // If the client didn't already have a handle to the context,
                // delete it now
                //

                if (phContext == NULL)
                {
                    (VOID) LsaDeleteSecurityContext( ContextHandle );
                }
            }

        }
        else
        {

            scRet = SEC_E_INVALID_HANDLE;
        }


    }

    if ( !NT_ERROR( scRet ) )
    {
        if ( (*pfContextAttr & ISC_RET_ALLOCATED_MEMORY ) && pOutput )
        {
            for ( i = 0 ; i < pOutput->cBuffers ; i++ )
            {
                if ( pOutput->pBuffers[i].BufferType == SECBUFFER_TOKEN )
                {
                    SecpAddVM( pOutput->pBuffers[i].pvBuffer );
                }
            }

        }
    }

Cleanup:
    SecStoreReturnCode(scRet);

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}



//+-------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaAcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet = S_OK;
    SecBufferDesc EmptyBuffer;
    CredHandle hCredential;
    SecBuffer ContextData = {0,0,NULL};
    BOOLEAN MappedContext = FALSE;
    CtxtHandle NullContext = {0,0};
    ULONG i;
    ULONG Flags;
    SEC_HANDLE_LPC LocalCred = { 0 };
    SEC_HANDLE_LPC LocalContext = { 0 };
    SEC_HANDLE_LPC LocalNewContext = { 0 } ;
#ifdef BUILD_WOW64
    PSECWOW_HANDLE_MAP HandleMap = NULL;
    BOOL DerefCred = FALSE ;
    BOOL DerefContext = FALSE ;
#endif
    //
    // They need to provide at least one of these two
    //

    if (!ARGUMENT_PRESENT(phCredential) && !ARGUMENT_PRESENT(phContext))
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    //
    // No user mode caller of sspi should be using this flag
    //
    if ( fContextReq & ASC_REQ_ALLOW_NULL_SESSION)
    {
        scRet = SEC_E_NOT_SUPPORTED;
        goto Cleanup;
    }

    if (!ARGUMENT_PRESENT(pInput))
    {
        pInput = &EmptyBuffer;
        RtlZeroMemory(pInput,sizeof(SecBufferDesc));
    }
    if (!ARGUMENT_PRESENT(pOutput))
    {
        pOutput = &EmptyBuffer;
        RtlZeroMemory(pOutput,sizeof(SecBufferDesc));
    }

    if (!ARGUMENT_PRESENT(phContext))
    {
        phContext = &NullContext;
    }
    else
    {
#ifdef BUILD_WOW64
        SecpReferenceHandleMap(
                (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                &LocalContext );

        DerefContext = TRUE ;
#else
        LocalContext = *phContext ;
#endif
    }

    if (!ARGUMENT_PRESENT(phCredential))
    {

        //
        // Since the package is keyed off the upper part, we need to set
        // it.
        //

        hCredential.dwLower = phContext->dwLower;
        hCredential.dwUpper = 0;
        phCredential = &hCredential;

        LocalCred.dwLower = LocalContext.dwLower ;
    }
    else
    {
#ifdef BUILD_WOW64
        SecpReferenceHandleMap(
                (PSECWOW_HANDLE_MAP) phCredential->dwUpper,
                &LocalCred
                );

        DerefCred = TRUE ;
#else
        LocalCred = *phCredential ;
#endif
    }



    Flags = 0;

    scRet = SecpAcceptSecurityContext(
                NULL,
                &LocalCred,
                &LocalContext,
                pInput,
                fContextReq,
                TargetDataRep,
                &LocalNewContext,
                pOutput,
                pfContextAttr,
                ptsExpiry,
                &MappedContext,
                &ContextData,
                &Flags );

#ifdef BUILD_WOW64

    if ( DerefCred )
    {
        SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phCredential->dwUpper );
    }


    if ( DerefContext )
    {
        if ( (Flags & SPMAPI_FLAG_HANDLE_CHG ) != 0 )
        {
            SecpDeleteHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
        }
        SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
    }

    if ( NT_SUCCESS( scRet ) )
    {
        if ( !(RtlEqualMemory( &LocalNewContext,
                               &LocalContext,
                               sizeof( SEC_HANDLE_LPC ) ) ) )
        {
            if ( SecpAddHandleMap( &LocalNewContext,
                                    &HandleMap ) )
            {
                phNewContext->dwLower = (LSA_SEC_HANDLE) LocalNewContext.dwLower ;
                phNewContext->dwUpper = (LSA_SEC_HANDLE) HandleMap ;
            }
            else
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;

            }
        }
        else
        {
            *phNewContext = *phContext ;
            HandleMap = (PSECWOW_HANDLE_MAP) phContext->dwUpper ;
        }
    }
#else
    *phNewContext = LocalNewContext ;
#endif

    if (NT_SUCCESS(scRet) && MappedContext)
    {
        PDLL_SECURITY_PACKAGE pspPackage;
        PCtxtHandle     ContextHandle;
        SECURITY_STATUS SecondaryStatus;

        if ( (phContext != &NullContext) &&
             ((Flags & SPMAPI_FLAG_HANDLE_CHG) == 0) )
        {
            ContextHandle = phContext;
        }
        else
        {
            ContextHandle = phNewContext;
        }

#ifdef BUILD_WOW64
        ContextHandle->dwUpper = (LSA_SEC_HANDLE) HandleMap ;
        ContextHandle->dwLower = (LSA_SEC_HANDLE) LocalNewContext.dwLower ;
#else
        *ContextHandle = LocalNewContext ;
#endif

        pspPackage = SecLocatePackageById( ContextHandle->dwLower );

        if ((pspPackage != NULL)  && (pspPackage->pftUTable != NULL))
        {
            SecpAddVM( ContextData.pvBuffer );

            SecondaryStatus = pspPackage->pftUTable->InitUserModeContext(
                                ContextHandle->dwUpper,
                                &ContextData
                                );
            if (!NT_SUCCESS( SecondaryStatus ))
            {

                scRet = SecondaryStatus;

                //
                // Patch up handle so DeleteSecurityContext works right
                //

                ContextHandle->dwLower = (ULONG_PTR) pspPackage ;

                (VOID) DeleteSecurityContext( ContextHandle );
            }

        }
        else
        {

            scRet = SEC_E_INVALID_HANDLE;
        }

    }

    if ( !NT_ERROR( scRet ) )
    {
        if ( (*pfContextAttr & ASC_RET_ALLOCATED_MEMORY ) && pOutput )
        {
            for ( i = 0 ; i < pOutput->cBuffers ; i++ )
            {
                if ( pOutput->pBuffers[i].BufferType == SECBUFFER_TOKEN )
                {
                    SecpAddVM( pOutput->pBuffers[i].pvBuffer );
                }
            }

        }
    }

Cleanup:
    SecStoreReturnCode(scRet);

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}






//+-------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaDeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    )
{
    SECURITY_STATUS     scRet = S_OK;
    SEC_HANDLE_LPC LocalHandle ;

    // For now, just delete the LSA context:

    if (!phContext)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        scRet = SEC_E_SECPKG_NOT_FOUND ;
        goto Cleanup ;
    }

    // If the package returned SEC_I_NO_LSA_CONTEXT, do not call
    // SecpDeleteSecurityContext and return Success. This happens when this
    // context is imported and therefore no LSA counterpart exists.

    if (DeleteUserModeContext(phContext) == SEC_I_NO_LSA_CONTEXT)
    {
        scRet = (S_OK);
        goto Cleanup;
    }

#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
            &LocalHandle
            );
#else
    LocalHandle = *phContext ;
#endif

    scRet = SecpDeleteSecurityContext(
                0,      // block while deleting
                &LocalHandle
                );

#ifdef BUILD_WOW64

    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );

    SecpDeleteHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );

#endif


Cleanup:
    SecStoreReturnCode(scRet);

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}



//+-------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    SECURITY_STATUS     scRet = S_OK;
    SEC_HANDLE_LPC  LocalHandle ;


    if (!phContext)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
            &LocalHandle
            );
#else

    LocalHandle = *phContext ;

#endif


    if (SUCCEEDED(scRet))
    {
        scRet = SecpApplyControlToken(  &LocalHandle,
                                        pInput);
    }

#ifdef BUILD_WOW64

    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );

#endif

Cleanup:
    SecStoreReturnCode(scRet);

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));


}


//+-------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaEnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    )
{
    SECURITY_STATUS scRet = S_OK;

    scRet = SecpEnumeratePackages(pcPackages,ppPackageInfo);

    if ( NT_SUCCESS( scRet ) )
    {
        SecpAddVM( *ppPackageInfo );
    }

    SecStoreReturnCode(scRet);

    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaQuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfo *               ppPackageInfo       // Receives package info
    )
{
    SECURITY_STATUS scRet = S_OK;
    SECURITY_STRING ssPackage;

    RtlInitUnicodeString(&ssPackage,pszPackageName);

    scRet = SecpQueryPackageInfo(&ssPackage,ppPackageInfo);

    if ( NT_SUCCESS( scRet ) )
    {
        SecpAddVM( *ppPackageInfo );
    }
    SecStoreReturnCode(scRet);

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}






//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaFreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    if ( SecpFreeVM( pvContextBuffer ) )
    {
        DebugLog(( DEB_TRACE, "Freeing VM %p\n", pvContextBuffer ));

        LsaFreeReturnBuffer( pvContextBuffer );
    }
    else
    {
        LocalFree( pvContextBuffer );
    }

    return( SEC_E_OK );
}




//+-------------------------------------------------------------------------
//
//  Function:   CompleteAuthToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaCompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (pPackage == NULL)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->CompleteAuthToken != NULL))
    {
        scRet = pPackage->pftUTable->CompleteAuthToken(
                                phContext->dwUpper,
                                pToken);
    }
    else
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION;
    }
Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;
    HANDLE          hToken;


    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    if (pPackage->pftUTable == NULL)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }

    scRet = pPackage->pftUTable->GetContextToken(phContext->dwUpper, &hToken);

    if (FAILED(scRet))
    {
        goto Cleanup;
    }

    DebugLog((DEB_TRACE, "Impersonating %ws[%p]\n",
                    pPackage->PackageName.Buffer, phContext->dwUpper));

    scRet = NtSetInformationThread( NtCurrentThread(),
                                    ThreadImpersonationToken,
                                    (PVOID) &hToken,
                                    sizeof(hToken) );

    if (FAILED(scRet))
    {
        DebugLog((DEB_ERROR, "Failed to impersonate handle %p, return %x\n",
                    hToken, scRet));
    }


Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   RevertSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaRevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{

    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;
    HANDLE          hToken = NULL;

#if DBG
    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
        return(SEC_E_INVALID_HANDLE);
#endif

    scRet = NtSetInformationThread( NtCurrentThread(),
                                    ThreadImpersonationToken,
                                    (PVOID) &hToken,
                                    sizeof(hToken) );

    if (FAILED(scRet))
    {
        DebugLog((DEB_ERROR, "Failed to revert handle %p, return %x\n",
                    hToken, scRet));
    }

    return(scRet);
}

//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityContextToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaQuerySecurityContextToken(
    PCtxtHandle                 phContext,
    PHANDLE                     TokenHandle
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;
    HANDLE          hToken = NULL ;


    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->GetContextToken != NULL))
    {
        scRet = pPackage->pftUTable->GetContextToken( phContext->dwUpper,
                                                      &hToken);
    }
    else
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION;
    }

    if (NT_SUCCESS(scRet))
    {
        if (hToken != NULL)
        {
            //
            // Duplicate the token so the caller may hold onto it after
            // deleting the context
            //

            scRet = NtDuplicateObject(
                        NtCurrentProcess(),
                        hToken,
                        NtCurrentProcess(),
                        TokenHandle,
                        0,                  // desired access
                        0,                  // handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
        }
        else
        {
            scRet = SEC_E_NO_IMPERSONATION;
        }
    }

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+---------------------------------------------------------------------------
//
//  Function:   QueryContextAttributesW
//
//  Synopsis:   Get context attributes
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    8-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaQueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    PDLL_LSA_PACKAGE_INFO   LsaInfo ;
    SECURITY_STATUS scRet = SEC_E_OK;
    PSecPkgContext_NegotiationInfoW pNegInfo ;
    ULONG                   i ;
    BOOL                    Thunked = FALSE ;
    ULONG Allocs ;
    PVOID Buffers[ 8 ];
    SEC_HANDLE_LPC LocalHandle ;
    ULONG Flags = 0;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    LsaInfo = pPackage->LsaInfo ;

    if ( LsaInfo->ContextThunkCount )
    {

        Allocs = 0 ;

        //
        // This package wants some of the context attr calls to be thunked to
        // the LSA.  help them out:
        //

        if ( LsaInfo->ContextThunks[ 0 ] == SECPKG_ATTR_THUNK_ALL )
        {

            Allocs = 8 ;
#ifdef BUILD_WOW64
            //
            // If this points to bogus data, we're ok.  The LSA will
            // reject it.
            //

            SecpReferenceHandleMap(
                    (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                    &LocalHandle
                    );
#else
            LocalHandle = *phContext ;
#endif

            scRet = SecpQueryContextAttributes( 
                        NULL,
                        &LocalHandle,
                        ulAttribute,
                        pBuffer,
                        &Allocs,
                        Buffers,
                        &Flags );

#ifdef BUILD_WOW64
            SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif
            Thunked = TRUE ;
        }
        else
        {
            for ( i = 0 ; i < LsaInfo->ContextThunkCount ; i++)
            {
                if ( LsaInfo->ContextThunks[ i ] == ulAttribute )
                {
                    Allocs = 8 ;
#ifdef BUILD_WOW64
                    //
                    // If this points to bogus data, we're ok.  The LSA will
                    // reject it.
                    //

                    SecpReferenceHandleMap(
                            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                            &LocalHandle
                            );
#else
                    LocalHandle = *phContext ;
#endif

                    scRet = SecpQueryContextAttributes(
                                NULL,
                                &LocalHandle,
                                ulAttribute,
                                pBuffer,
                                &Allocs,
                                Buffers,
                                &Flags );

#ifdef BUILD_WOW64
                    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif
                    Thunked = TRUE ;
                    break;
                }
            }
        }

        //
        // If the package allocated memory in our address space,
        // add it to the VM list so it can be freed correctly.
        //

        for ( i = 0 ; i < Allocs ; i++ )
        {
            SecpAddVM( Buffers[ i ] );
        }

    }
    if ( !Thunked )
    {

        if ((pPackage->pftUTable != NULL) &&
            (pPackage->pftUTable->QueryContextAttributes != NULL))
        {
            scRet = pPackage->pftUTable->QueryContextAttributes(
                        phContext->dwUpper,
                        ulAttribute,
                        pBuffer);
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }

        if ( ( scRet == SEC_E_INVALID_HANDLE ) ||
             ( scRet == STATUS_INVALID_HANDLE ) )
        {
            if ( ( ulAttribute == SECPKG_ATTR_PACKAGE_INFO ) ||
                 ( ulAttribute == SECPKG_ATTR_NEGOTIATION_INFO ) )
            {
                //
                // These attributes are really about the handle
                //

                pNegInfo = (PSecPkgContext_NegotiationInfoW) pBuffer ;

                if ( ulAttribute == SECPKG_ATTR_NEGOTIATION_INFO )
                {
                    pNegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
                }

                scRet = SecCopyPackageInfoToUserW( pPackage, &pNegInfo->PackageInfo );

            }
        }
    }

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaQueryContextAttributesA
//
//  Synopsis:   ANSI stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaQueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    PDLL_SECURITY_PACKAGE   pPackage;
    PDLL_LSA_PACKAGE_INFO   LsaInfo ;
    SECURITY_STATUS         scRet = SEC_E_OK;
    DWORD WinStatus;
    PSTR                    AnsiString;
    UNICODE_STRING          String;
    SecPkgContext_NamesW *  Names;
    SecPkgContext_NativeNamesW * NativeNames;
    SecPkgContext_KeyInfoW *KeyInfo;
    PSecPkgContext_PackageInfoW PackageInfoW;
    PSecPkgContext_NegotiationInfoA pNegInfo ;
    PSecPkgContext_CredentialNameW CredName;
    ULONG                   PackageInfoSize;
    PSecPkgInfoA            PackageInfoA;
    PSTR                    PackageName = NULL;
    PSTR                    PackageComment = NULL;
    ULONG                   i ;
    BOOL                    Thunked = FALSE ;
    BOOL                    Converted = FALSE ;
    ULONG Allocs ;
    PVOID Buffers[ 8 ];
    SEC_HANDLE_LPC LocalHandle ;
    ULONG Flags = 0;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    LsaInfo = pPackage->LsaInfo ;

    if ( LsaInfo->ContextThunkCount )
    {

        Allocs = 0 ;

        //
        // This package wants some of the context attr calls to be thunked to
        // the LSA.  help them out:
        //

        if ( LsaInfo->ContextThunks[ 0 ] == SECPKG_ATTR_THUNK_ALL )
        {
            Allocs = 8 ;

#ifdef BUILD_WOW64
            //
            // If this points to bogus data, we're ok.  The LSA will
            // reject it.
            //

            SecpReferenceHandleMap(
                    (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                    &LocalHandle
                    );
#else
            LocalHandle = *phContext ;
#endif

            scRet = SecpQueryContextAttributes( 
                        NULL,
                        &LocalHandle,
                        ulAttribute,
                        pBuffer,
                        &Allocs,
                        Buffers,
                        &Flags );

#ifdef BUILD_WOW64
            SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif
            Thunked = TRUE ;
        }
        else
        {
            for ( i = 0 ; i < LsaInfo->ContextThunkCount ; i++)
            {
                if ( LsaInfo->ContextThunks[ i ] == ulAttribute )
                {
                    Allocs = 8 ;

#ifdef BUILD_WOW64
                    //
                    // If this points to bogus data, we're ok.  The LSA will
                    // reject it.
                    //

                    SecpReferenceHandleMap(
                            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
                            &LocalHandle
                            );
#else
                    LocalHandle = *phContext ;
#endif

                    scRet = SecpQueryContextAttributes(
                                NULL,
                                &LocalHandle,
                                ulAttribute,
                                pBuffer,
                                &Allocs,
                                Buffers,
                                &Flags );

#ifdef BUILD_WOW64
                    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif
                    Thunked = TRUE ;
                    break;
                }
            }
        }

        //
        // If the package allocated memory in our address space,
        // add it to the VM list so it can be freed correctly.
        //

        for ( i = 0 ; i < Allocs ; i++ )
        {
            SecpAddVM( Buffers[ i ] );
        }

    }

    if ( !Thunked )
    {

        if ((pPackage->pftUTable != NULL) &&
            (pPackage->pftUTable->QueryContextAttributes != NULL))
        {
            scRet = pPackage->pftUTable->QueryContextAttributes(
                        phContext->dwUpper,
                        ulAttribute,
                        pBuffer);
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }

        if ( ( scRet == SEC_E_INVALID_HANDLE ) ||
             ( scRet == STATUS_INVALID_HANDLE ) )
        {
            if ( ( ulAttribute == SECPKG_ATTR_PACKAGE_INFO ) ||
                 ( ulAttribute == SECPKG_ATTR_NEGOTIATION_INFO ) )
            {
                //
                // These attributes are really about the handle
                //

                pNegInfo = (PSecPkgContext_NegotiationInfoA) pBuffer ;

                if ( ulAttribute == SECPKG_ATTR_NEGOTIATION_INFO )
                {
                    pNegInfo->NegotiationState = SECPKG_NEGOTIATION_COMPLETE ;
                }

                scRet = SecCopyPackageInfoToUserA( pPackage, &pNegInfo->PackageInfo );

                Converted = TRUE ;

            }
        }
    }
    if ( NT_SUCCESS( scRet ) &&
         ( Converted == FALSE ) )
    {
        //
        // Must convert individual context attributes to ANSI.
        //

        switch ( ulAttribute )
        {
            case SECPKG_ATTR_SIZES:
            case SECPKG_ATTR_LIFESPAN:
            case SECPKG_ATTR_DCE_INFO:
            case SECPKG_ATTR_STREAM_SIZES:
            case SECPKG_ATTR_PASSWORD_EXPIRY:
            case SECPKG_ATTR_SESSION_KEY:
            default:
                break;

            case SECPKG_ATTR_NAMES:
            case SECPKG_ATTR_AUTHORITY:
            case SECPKG_ATTR_PROTO_INFO:

                //
                // All these have the string pointer as their first member,
                // making this easy.
                //

                Names = (PSecPkgContext_NamesW) pBuffer ;

                RtlInitUnicodeString( &String, Names->sUserName );

                AnsiString = LsapConvertUnicodeString( &String );

                SecClientFree( Names->sUserName );

                Names->sUserName = (PWSTR) AnsiString ;

                if ( !AnsiString )
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }

                break;


            case SECPKG_ATTR_KEY_INFO:

                KeyInfo = (PSecPkgContext_KeyInfoW) pBuffer ;

                RtlInitUnicodeString( &String, KeyInfo->sSignatureAlgorithmName );

                AnsiString = LsapConvertUnicodeString( &String );

                SecClientFree( KeyInfo->sSignatureAlgorithmName );

                KeyInfo->sSignatureAlgorithmName = (PWSTR) AnsiString ;

                if ( AnsiString )
                {
                    RtlInitUnicodeString( &String, KeyInfo->sEncryptAlgorithmName );

                    AnsiString = LsapConvertUnicodeString( &String );

                    SecClientFree( KeyInfo->sEncryptAlgorithmName );

                    KeyInfo->sEncryptAlgorithmName = (PWSTR) AnsiString ;

                    if ( !AnsiString )
                    {
                        SecClientFree( KeyInfo->sSignatureAlgorithmName );

                        scRet = SEC_E_INSUFFICIENT_MEMORY ;
                    }
                }
                else
                {
                    SecClientFree( KeyInfo->sEncryptAlgorithmName );

                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }
                break;

            case SECPKG_ATTR_PACKAGE_INFO:
            case SECPKG_ATTR_NEGOTIATION_INFO:
                //
                // Convert the SecPkgInfoW to a SecPkgInfoA structure
                //
                PackageInfoW = (PSecPkgContext_PackageInfoW) pBuffer;
                RtlInitUnicodeString(
                    &String,
                    PackageInfoW->PackageInfo->Name
                    );
                PackageName = LsapConvertUnicodeString(
                                    &String
                                    );
                if (PackageName != NULL)
                {
                    RtlInitUnicodeString(
                        &String,
                        PackageInfoW->PackageInfo->Comment
                        );

                    PackageComment = LsapConvertUnicodeString(
                                        &String
                                        );

                    if (PackageComment != NULL)
                    {
                        PackageInfoSize = sizeof(SecPkgInfoA) +
                                            2 * sizeof(CHAR) +
                                            lstrlenA(PackageName) +     // null terminators
                                            lstrlenA(PackageComment);
                        PackageInfoA = (PSecPkgInfoA) SecClientAllocate(PackageInfoSize);
                        if (PackageInfoA != NULL)
                        {
                            *PackageInfoA = *(PSecPkgInfoA) PackageInfoW->PackageInfo;
                            AnsiString = (PSTR) (PackageInfoA + 1);
                            PackageInfoA->Name = AnsiString;
                            lstrcpyA(
                                AnsiString,
                                PackageName
                                );
                            AnsiString += lstrlenA(PackageName) + 1;
                            PackageInfoA->Comment = AnsiString;
                            lstrcpyA(
                                AnsiString,
                                PackageComment
                                );
                            SecClientFree(PackageInfoW->PackageInfo);
                            PackageInfoW->PackageInfo = (PSecPkgInfoW) PackageInfoA;

                        }
                        SecClientFree(PackageComment);
                    }
                    else
                    {
                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                    }
                    SecClientFree(PackageName);
                }
                else
                {
                     scRet = SEC_E_INSUFFICIENT_MEMORY;
                }

                break;
            case SECPKG_ATTR_NATIVE_NAMES:

                //
                // All these have the string pointer as their first member,
                // making this easy.
                //

                NativeNames = (PSecPkgContext_NativeNamesW) pBuffer ;

                RtlInitUnicodeString( &String, NativeNames->sClientName );

                AnsiString = LsapConvertUnicodeString( &String );

                SecClientFree( NativeNames->sClientName );

                NativeNames->sClientName = (PWSTR) AnsiString ;

                if ( !AnsiString )
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }

                RtlInitUnicodeString( &String, NativeNames->sServerName );

                AnsiString = LsapConvertUnicodeString( &String );

                SecClientFree( NativeNames->sServerName );

                NativeNames->sServerName = (PWSTR) AnsiString ;

                if ( !AnsiString )
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY ;
                }

                break;

        case SECPKG_ATTR_CREDENTIAL_NAME:

            CredName = (PSecPkgContext_CredentialNameW)pBuffer ;

            RtlInitUnicodeString( &String, CredName->sCredentialName );

            AnsiString = LsapConvertUnicodeString( &String );

            SecClientFree( CredName->sCredentialName );

            CredName->sCredentialName = (PWSTR) AnsiString ;

            if ( !AnsiString )
            {
                scRet = SEC_E_INSUFFICIENT_MEMORY ;
            }

            break;


        }
    }

Cleanup:

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+---------------------------------------------------------------------------
//
//  Function:   SetContextAttributesW
//
//  Synopsis:   Set context attributes
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    4-20-00   CliffV   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaSetContextAttributesW(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    PDLL_SECURITY_PACKAGE pPackage;
    SECURITY_STATUS scRet = SEC_E_OK;
    ULONG i;
    SEC_HANDLE_LPC LocalHandle ;
    PSecPkgContext_CredentialNameW CredentialNameInfo = (PSecPkgContext_CredentialNameW)pBuffer;
    ULONG CredentialNameSize;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }
    //
    // Must convert individual context attributes to ANSI.
    //
    switch ( ulAttribute ) {
    case SECPKG_ATTR_USE_VALIDATED:
        if ( cbBuffer < sizeof(DWORD) ) {
            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        break;
    case SECPKG_ATTR_CREDENTIAL_NAME:
        if ( cbBuffer < sizeof(SecPkgContext_CredentialNameW) ) {
            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
        CredentialNameSize = (wcslen(CredentialNameInfo->sCredentialName) + 1) * sizeof(WCHAR);
        if ( (LPBYTE)(CredentialNameInfo->sCredentialName) < (LPBYTE)(CredentialNameInfo+1) ||
             CredentialNameSize > cbBuffer ||
             (LPBYTE)(CredentialNameInfo->sCredentialName) > (LPBYTE)(pBuffer) + cbBuffer - CredentialNameSize ) {

            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        break;
    }


#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
            &LocalHandle
            );
#else
    LocalHandle = *phContext ;
#endif

    scRet = SecpSetContextAttributes( &LocalHandle,
                                      ulAttribute,
                                      pBuffer,
                                      cbBuffer );

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif

Cleanup:
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaSetContextAttributesA
//
//  Synopsis:   ANSI stub
//
//  Arguments:  [phContext]   --
//              [ulAttribute] --
//              [attributes]  --
//
//  History:    4-20-00   CliffV   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaSetContextAttributesA(
    PCtxtHandle                 phContext,          // Context to Set
    unsigned long               ulAttribute,        // Attribute to Set
    void SEC_FAR *              pBuffer,            // Buffer for attributes
    unsigned long               cbBuffer            // Size (in bytes) of pBuffer
    )
{
    PDLL_SECURITY_PACKAGE   pPackage;
    SECURITY_STATUS         scRet = SEC_E_OK;
    PSTR                    AnsiString;
    UNICODE_STRING          String;
    ULONG                   PackageInfoSize;
    PSecPkgInfoA            PackageInfoA;
    PSTR                    PackageName = NULL;
    PSTR                    PackageComment = NULL;
    ULONG                   i ;
    SEC_HANDLE_LPC LocalHandle ;
    PVOID AllocatedBuffer = NULL;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = (SEC_E_INVALID_HANDLE);
        goto Cleanup;
    }

    //
    // Must convert individual context attributes to ANSI.
    //
    switch ( ulAttribute ) {
    case SECPKG_ATTR_USE_VALIDATED:
        if ( cbBuffer < sizeof(DWORD) ) {
            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        break;
    case SECPKG_ATTR_CREDENTIAL_NAME: {
        NTSTATUS Status;
        STRING AnsiString;
        UNICODE_STRING UnicodeString;
        ULONG CredentialNameSize;
        ULONG Size;
        PSecPkgContext_CredentialNameA ACredName;
        PSecPkgContext_CredentialNameW WCredName;

        //
        // Validate the caller's buffer
        //
        ACredName = (PSecPkgContext_CredentialNameA)pBuffer;

        if ( cbBuffer < sizeof(SecPkgContext_CredentialNameA) ) {
            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
        CredentialNameSize = strlen(ACredName->sCredentialName) + 1;
        if ( (LPBYTE)(ACredName->sCredentialName) < (LPBYTE)(ACredName+1) ||
             CredentialNameSize > cbBuffer ||
             (LPBYTE)(ACredName->sCredentialName) > (LPBYTE)(pBuffer) + cbBuffer - CredentialNameSize ) {

            scRet = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }

        //
        // Allocate a buffer containing the UNICODE version of the structure
        //

        RtlInitString( &AnsiString, ACredName->sCredentialName );
        UnicodeString.MaximumLength = (USHORT)RtlAnsiStringToUnicodeSize( &AnsiString );

        Size = sizeof(SecPkgContext_CredentialNameW) +
               UnicodeString.MaximumLength;

        AllocatedBuffer = LocalAlloc( 0, Size );

        if ( AllocatedBuffer == NULL ) {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
            goto Cleanup;
        }

        WCredName = (PSecPkgContext_CredentialNameW) AllocatedBuffer;
        pBuffer = WCredName;
        cbBuffer = Size;

        //
        // Fill in the UNICODE version of the structure
        //

        WCredName->CredentialType = ACredName->CredentialType;
        WCredName->sCredentialName = (LPWSTR)(WCredName+1);

        UnicodeString.Length = 0;
        UnicodeString.Buffer = WCredName->sCredentialName;

        Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );

        if ( !NT_SUCCESS(Status) ) {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
            goto Cleanup;
        }

        }
        break;
    }


    //
    // Call the LSA to set the information there.
    //


#ifdef BUILD_WOW64
    //
    // If this points to bogus data, we're ok.  The LSA will
    // reject it.
    //

    SecpReferenceHandleMap(
            (PSECWOW_HANDLE_MAP) phContext->dwUpper,
            &LocalHandle
            );
#else
    LocalHandle = *phContext ;
#endif

    scRet = SecpSetContextAttributes( &LocalHandle,
                                       ulAttribute,
                                       pBuffer,
                                       cbBuffer );

#ifdef BUILD_WOW64
    SecpDerefHandleMap( (PSECWOW_HANDLE_MAP) phContext->dwUpper );
#endif

Cleanup:
    if ( AllocatedBuffer != NULL ) {
        LocalFree( AllocatedBuffer );
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   MakeSignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaMakeSignature(  PCtxtHandle         phContext,
                DWORD               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    PDLL_SECURITY_PACKAGE             pPackage;
    SECURITY_STATUS         scRet;


    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );
    if (!pPackage)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->MakeSignature != NULL))
        {
            scRet = pPackage->pftUTable->MakeSignature(
                                phContext->dwUpper,
                                fQOP,
                                pMessage,
                                MessageSeqNo );
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }



    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}



//+-------------------------------------------------------------------------
//
//  Function:   VerifySignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to verify
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
LsaVerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                DWORD *         pfQOP)
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;


    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->VerifySignature != NULL))
        {
            scRet = pPackage->pftUTable->VerifySignature(
                                    phContext->dwUpper,
                                    pMessage,
                                    MessageSeqNo,
                                    pfQOP );
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }


    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));


}

//+---------------------------------------------------------------------------
//
//  Function:   SealMessage
//
//  Synopsis:   Seals a message
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaSealMessage(    PCtxtHandle         phContext,
                DWORD               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    PDLL_SECURITY_PACKAGE             pPackage;
    SECURITY_STATUS         scRet;


/*
    //
    // First, check if the LSA said that privacy of messages is okay.
    //
    if ((lsState.fState & SPMSTATE_PRIVACY_OK) == 0)
    {
        scRet = (SEC_E_UNSUPPORTED_FUNCTION);
        goto Cleanup;
    }
*/

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ( ( pPackage->fState & DLL_SECPKG_NO_CRYPT ) != 0 )
        {
            return SecpFailedSealFunction(
                            phContext,
                            fQOP,
                            pMessage,
                            MessageSeqNo );
        }

        if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->SealMessage != NULL))
        {
            scRet = pPackage->pftUTable->SealMessage(
                                    phContext->dwUpper,
                                    fQOP,
                                    pMessage,
                                    MessageSeqNo );
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }


/* strict warn
Cleanup:
*/

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}

//+---------------------------------------------------------------------------
//
//  Function:   UnsealMessage
//
//  Synopsis:   Unseal a private message
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to unseal
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaUnsealMessage(  PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                DWORD *             pfQOP)
{
    PDLL_SECURITY_PACKAGE     pPackage;

    SECURITY_STATUS scRet;

/*
    //
    // First, check if the LSA said that privacy of messages is okay.
    //

    if ((lsState.fState & SPMSTATE_PRIVACY_OK) == 0)
    {
        scRet = (SEC_E_UNSUPPORTED_FUNCTION);
        goto Cleanup;
    }
*/

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ( ( pPackage->fState & DLL_SECPKG_NO_CRYPT ) != 0 )
        {
            return SecpFailedUnsealFunction(
                        phContext,
                        pMessage,
                        MessageSeqNo,
                        pfQOP );
        }
        if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->UnsealMessage != NULL))
        {
            scRet = pPackage->pftUTable->UnsealMessage(
                                phContext->dwUpper,
                                pMessage,
                                MessageSeqNo,
                                pfQOP );
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

/* strict warn
Cleanup:
*/
    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));


}




//+-------------------------------------------------------------------------
//
//  Function:   DeleteUsermodeContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
LsaDeleteUserModeContext(
    PCtxtHandle                 phContext           // Contxt to delete
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet = SEC_E_OK;

    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if ((pPackage->pftUTable != NULL) && (pPackage->pftUTable->DeleteUserModeContext != NULL))
    {
        scRet = pPackage->pftUTable->DeleteUserModeContext(
                    phContext->dwUpper);
    }

    return(scRet);
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaBootPackage
//
//  Synopsis:   Boots (instance-inits) a security package
//
//  Arguments:  [Package] --
//
//  History:    9-15-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SEC_ENTRY
LsaBootPackage(
    PDLL_SECURITY_PACKAGE Package)
{
    SECURITY_STATUS scRet ;
    PVOID ignored;

    SetCurrentPackage( Package );

    __try
    {
        scRet = Package->pftUTable->InstanceInit(
                                SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                & SecpFTable,
                                & ignored );


    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        scRet = GetExceptionCode();
    }

    SetCurrentPackage( NULL );

    return( NT_SUCCESS( scRet ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaUnloadPackage
//
//  Synopsis:   Called when a package is unloaded
//
//  Arguments:  (none)
//
//  History:    9-15-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SEC_ENTRY
LsaUnloadPackage(
    VOID )
{

}


//+-------------------------------------------------------------------------
//
//  Function:   SecInitUserModeContext
//
//  Synopsis:   Passes the context data to the user-mode portion of a package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SecInitUserModeContext(
    IN PCtxtHandle ContextHandle,
    IN PSecBuffer ContextData
    )
{
    SECURITY_STATUS Status = SEC_E_OK;
    PDLL_SECURITY_PACKAGE pspPackage;

    pspPackage = SecLocatePackageById( ContextHandle->dwLower );


    if ( !pspPackage )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    if ((pspPackage->pftUTable != NULL) && (pspPackage->pftUTable->InitUserModeContext != NULL))
    {
        SecpAddVM( ContextData->pvBuffer );

        Status = pspPackage->pftUTable->InitUserModeContext(
                    ContextHandle->dwUpper,
                        ContextData
                        );

    }
    else
    {
        Status = SEC_E_INVALID_HANDLE;
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   SecDeleteUserModeContext
//
//  Synopsis:   Frees up a context in the user-mode portion of a package.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SecDeleteUserModeContext(
    IN PCtxtHandle ContextHandle
    )
{
    return(LsaDeleteUserModeContext(ContextHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   LsaCallbackHandler
//
//  Synopsis:   handles LSA specific callbacks
//
//  Arguments:  [Function] --
//              [Arg1]     --
//              [Arg2]     --
//              [Input]    --
//              [Output]   --
//
//  History:    11-12-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
extern "C"
NTSTATUS
LsaCallbackHandler(
    ULONG_PTR   Function,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    PSecBuffer Input,
    PSecBuffer Output
    )
{
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_LSA_CALLBACK   Callback ;
    PLIST_ENTRY Scan ;

    Package = (PDLL_SECURITY_PACKAGE) GetCurrentPackage();

    if ( !Package )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    Scan = Package->LsaInfo->Callbacks.Flink ;

    Callback = NULL ;

    while ( Scan != &Package->LsaInfo->Callbacks )
    {
        Callback = (PDLL_LSA_CALLBACK) Scan ;

        if ( Callback->CallbackId == Function )
        {
            break;
        }

        Callback = NULL ;

        Scan = Scan->Flink ;
    }

    if ( Callback )
    {
        return Callback->Callback( Arg1, Arg2, Input, Output );
    }

    return STATUS_ENTRYPOINT_NOT_FOUND ;

}

//+---------------------------------------------------------------------------
//
//  Function:   LsaExportContext
//
//  Synopsis:   Exports
//
//  Arguments:
//
//  History:    18-08-97        MikeSw          Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaExportContext(
    IN PCtxtHandle ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer MarshalledContext,
    OUT PHANDLE TokenHandle
    )
{
    PDLL_SECURITY_PACKAGE  Package;

    SECURITY_STATUS scRet;


    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    Package = SecLocatePackageById( ContextHandle->dwLower );

    if (!Package)
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    else
    {
        if ((Package->pftUTable != NULL) && (Package->pftUTable->ExportContext != NULL))
        {
            scRet = Package->pftUTable->ExportContext(
                                    ContextHandle->dwUpper,
                                    Flags,
                                    MarshalledContext,
                                    TokenHandle
                                    );
            if (NT_SUCCESS(scRet) && ((Flags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0))
            {
                LsaDeleteSecurityContext(ContextHandle);
            }
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));


}

//+---------------------------------------------------------------------------
//
//  Function:   LsaImportContextW
//
//  Synopsis:   Imports a context from another process
//
//  Arguments:
//
//  History:    18-08-97        MikeSw          Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaImportContextW(
    IN LPWSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PDLL_SECURITY_PACKAGE  Package;

    SECURITY_STATUS scRet;


    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    Package = SecLocatePackageW(PackageName );

    if (!Package)
    {
        scRet = SEC_E_SECPKG_NOT_FOUND;
    }
    else
    {
        if ((Package->pftUTable != NULL) && (Package->pftUTable->ImportContext != NULL))
        {
            scRet = Package->pftUTable->ImportContext(
                                    MarshalledContext,
                                    TokenHandle,
                                    &ContextHandle->dwUpper
                                    );
            if (NT_SUCCESS(scRet))
            {
                ContextHandle->dwLower = Package->PackageId;
            }
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));

}

//+---------------------------------------------------------------------------
//
//  Function:   LsaImportContextA
//
//  Synopsis:   Imports a context from another process
//
//  Arguments:
//
//  History:    18-08-97        MikeSw          Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaImportContextA(
    IN LPSTR PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PDLL_SECURITY_PACKAGE  Package;

    SECURITY_STATUS scRet;


    if ( LsaPackageShutdown )
    {
        SetLastError( ERROR_SHUTDOWN_IN_PROGRESS );
        return SEC_E_SECPKG_NOT_FOUND ;
    }

    Package = SecLocatePackageA(PackageName );

    if (!Package)
    {
        scRet = SEC_E_SECPKG_NOT_FOUND;
    }
    else
    {
        if ((Package->pftUTable != NULL) && (Package->pftUTable->ImportContext != NULL))
        {
            scRet = Package->pftUTable->ImportContext(
                                    MarshalledContext,
                                    TokenHandle,
                                    &ContextHandle->dwUpper
                                    );
            if (NT_SUCCESS(scRet))
            {
                ContextHandle->dwLower = Package->PackageId;
            }
        }
        else
        {
            scRet = SEC_E_UNSUPPORTED_FUNCTION;
        }
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        SetLastError(RtlNtStatusToDosError(scRet));
    }
    return (SspNtStatusToSecStatus(scRet, SEC_E_INTERNAL_ERROR));
}


NTSTATUS
LsaRegisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    )
/*++

Routine Description:

    This routine is the user mode stub routine for the LsaRegisterPolicyChangeNotification
    API.

Arguments:

    InformationClass -- Information class to remove the notification for

    EventHandle -- Event handle to register

Return Value:

    STATUS_SUCCESS on success, error otherwise.

--*/
{
    NTSTATUS Status;

    Status = IsOkayToExec( NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Status = LsapPolicyChangeNotify( 0,
                                     TRUE,
                                     NotificationEventHandle,
                                     InformationClass );
    return( Status );
}


NTSTATUS
LsaUnregisterPolicyChangeNotification(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    IN HANDLE  NotificationEventHandle
    )
/*++

Routine Description:

    This routine is the user mode stub routine for the LsaUnregisterPolicyChangeNotification
    API.

Arguments:

    InformationClass -- Information class to remove the notification for

    EventHandle -- Event handle to unregister

Return Value:

    STATUS_SUCCESS on success, error otherwise.

--*/
{
    NTSTATUS Status;

    Status = IsOkayToExec( NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }
    Status = LsapPolicyChangeNotify( 0,
                                     FALSE,
                                     NotificationEventHandle,
                                     InformationClass );
    return( Status );
}


SECURITY_STATUS
SEC_ENTRY
LsaEnumerateLogonSessions(
    OUT PULONG LogonSessionCount,
    OUT PLUID * LogonSessionList
    )
{
    NTSTATUS Status ;

    Status = IsOkayToExec( NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }
    return SecpEnumLogonSession(
                LogonSessionCount,
                LogonSessionList
                );
}


SECURITY_STATUS
SEC_ENTRY
LsaGetLogonSessionData(
    IN PLUID LogonId,
    OUT PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
    )
{
    PVOID Data ;
    NTSTATUS Status ;

    Status = IsOkayToExec( NULL );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    if ( !LogonId )
    {
        return STATUS_INVALID_PARAMETER;
    }

    Status = SecpGetLogonSessionData(
                LogonId,
                (PVOID*) &Data );

    if ( NT_SUCCESS( Status ) )
    {
        *ppLogonSessionData = (PSECURITY_LOGON_SESSION_DATA) Data ;
    }

    return Status ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\makefile.inc ===
#
# build a private secur32.lib that contains undocumented and
# private functions
#

$(O)\secur32p.def: secur32.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) /DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $@
    

$(O)\secur32p.lib: $(O)\secur32p.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\secur32p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(PROJECT_LIB_PATH)\secur32p.lib : $(O)\secur32p.lib
    $(PUBLISH_CMD) {$?=$@}
    

#
# Build public secur32.lib 
#

$(O)\secur32.def: secur32.src
    @echo Creating $@ from $**
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS) $** > $@


$(O)\secur32.lib : $(O)\secur32.def $(LIBRARY_OBJS)
   -lib -out:$@ @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\secur32.def
$(LIBRARY_OBJS)
<<NOKEEP

$(SDK_LIB_PATH)\secur32.lib : $(O)\secur32.lib
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\extapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        extapi.cxx
//
// Contents:    user-mode stubs for security extension APIs
//
//
// History:     3-5-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
extern "C"
{
#include <secpri.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}









//+-------------------------------------------------------------------------
//
//  Function:   GetSecurityUserInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
GetSecurityUserInfo(    PLUID                   pLogonId,
                        ULONG                   fFlags,
                        PSecurityUserData *     ppUserInfo)
{
    return(SecpGetUserInfo(pLogonId,fFlags,ppUserInfo));
}



//+-------------------------------------------------------------------------
//
//  Function:   SaveCredentials
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS NTAPI
SaveCredentials (
    PCredHandle     pCredHandle,
    unsigned long   cbCredentials,
    unsigned char * pbCredentials
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


//+-------------------------------------------------------------------------
//
//  Function:   GetCredentials
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------




SECURITY_STATUS NTAPI
GetCredentials (
    PCredHandle      pCredHandle,
    unsigned long *  pcbCredentials,
    unsigned char *  pbCredentials
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteCredentials
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------




SECURITY_STATUS NTAPI
DeleteCredentials (
    PCredHandle      pCredHandle,
    unsigned long    cbKey,
    unsigned char *  pbKey
    )
{
    return SEC_E_UNSUPPORTED_FUNCTION ;
}





//+---------------------------------------------------------------------------
//
//  Function:   SecGetLastError
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    10-25-94   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


extern "C"
SECURITY_STATUS NTAPI
SecGetLastError(VOID)
{
    if (!(DllState & DLLSTATE_NO_TLS))
    {
        return((SECURITY_STATUS)((ULONG_PTR)TlsGetValue(SecTlsEntry)));
    }
    else
    {
        return(SEC_E_INTERNAL_ERROR);
    }
}



//
// If the key is present in the registry, allow the encryption.
// NB do not modify this table without clearance from LCA.  Check
// the 'xport' alias for details.
//

typedef struct _MAGIC_PATH {
    WORD    Language ;
    ULONG   CountryCode ;
    PWSTR   Path ;
} MAGIC_PATH ;

static MAGIC_PATH  MagicPath[] = {
        { MAKELANGID( LANG_FRENCH, SUBLANG_FRENCH), CTRY_FRANCE, L"Software\\Microsoft\\Cryptography\\Defaults\\EnableFlag" }

        };



//+---------------------------------------------------------------------------
//
//  Function:   SecGetLocaleSpecificEncryption
//
//  Synopsis:   Does locale-specifc (aka "the French check") detection for
//              whether a particular country allows encryption at all.
//
//  Arguments:  [Permitted] -- Receives TRUE (permitted) or FALSE
//
//  History:    5-05-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
extern "C"
BOOLEAN
SEC_ENTRY
SecGetLocaleSpecificEncryptionRules(
    BOOLEAN * Permitted
    )
{
    LCID DefaultLcid;
    WCHAR CountryCode[10];
    ULONG CountryValue;
    WORD StandardFrench = MAKELANGID( LANG_FRENCH, SUBLANG_FRENCH );
    HKEY Key ;
    int i ;
    int err ;

    DefaultLcid = GetSystemDefaultLCID();

    if ( !GetLocaleInfo( DefaultLcid, LOCALE_ICOUNTRY, CountryCode, 10 ) )
    {
        *Permitted = FALSE ;
        return FALSE ;
    }

    CountryValue = (ULONG) wcstol( CountryCode, NULL, 10 );

    *Permitted = TRUE ;

    for ( i = 0 ; i < sizeof( MagicPath ) / sizeof( MAGIC_PATH ) ; i++ )
    {
        if ( ( MagicPath[i].Language == LANGIDFROMLCID( DefaultLcid ) ) &&
             ( MagicPath[i].CountryCode == CountryValue ) )
        {
            *Permitted = FALSE ;

            //
            // If the key is present in the registry, allow the encryption.
            // NB do not modify this table without clearance from LCA.  Check
            // the 'xport' alias for details.
            //

            err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                MagicPath[i].Path,
                                0,
                                KEY_READ,
                                &Key );

            if ( err == 0 )
            {
                *Permitted = TRUE ;
                RegCloseKey( Key );
                break;
            }
        }
    }

    return TRUE ;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\secdll.h ===
//+-----------------------------------------------------------------------
//
// File:        SECDLL.H
//
// Contents:    Security DLL private defines
//
//
// History:     11 Mar 92   RichardW    Recreated
//
//------------------------------------------------------------------------

#ifndef __SECDLL_H__
#define __SECDLL_H__

#include <spseal.h> // prototypes for seal & unseal
#include <secur32p.h>

#include "debug.h"

#define SECPKG_TYPE_OLD     0x00000001  // Old, SSPI style
#define SECPKG_TYPE_NEW     0x00000002  // New, LSA style
#define SECPKG_TYPE_BUILTIN 0x00000004  // Internal psuedo
#define SECPKG_TYPE_ANY     0x00000008  // Any (for searching)

#define SECPKG_TYPE_ANSI    0x00000010  // Ansi (narrow)
#define SECPKG_TYPE_WIDE    0x00000020  // Unicode (wide)

typedef enum _SECPKG_TYPE {
    SecPkgOld,                  // Old, indeterminate (not yet loaded)
    SecPkgOldA,                 // Old style DLL only, ANSI entry points only
    SecPkgOldW,                 // Old style, Unicode entry points only
    SecPkgOldAW,                // Old style, both flavors
    SecPkgNew,                  // New, info from the LSA
    SecPkgNewAW,                // Ansi support
    SecPkgBuiltin,              // Builtin pseudo package
    SecPkgAny,                  // Any type (for searches)
    SecPkgAnsi,                 // Any ansi type (for searches)
    SecPkgWide                  // Any wide type (for searches)
} SECPKG_TYPE, *PSECPKG_TYPE ;

struct _DLL_BINDING;
struct _DLL_SECURITY_PACKAGE;

typedef void (SEC_ENTRY * EXIT_SECURITY_INTERFACE) (void);
typedef BOOL (SEC_ENTRY * LOAD_SECURITY_INTERFACE) (struct _DLL_SECURITY_PACKAGE * Package);

typedef struct _DLL_LSA_CALLBACK {
    LIST_ENTRY                  List ;
    ULONG                       CallbackId ;
    PLSA_CALLBACK_FUNCTION      Callback ;
} DLL_LSA_CALLBACK, * PDLL_LSA_CALLBACK ;

typedef struct _DLL_LSA_PACKAGE_INFO {
    ULONG                       ContextThunkCount ;
    PULONG                      ContextThunks ;
    LIST_ENTRY                  Callbacks ;
} DLL_LSA_PACKAGE_INFO, * PDLL_LSA_PACKAGE_INFO ;

typedef struct _DLL_SECURITY_PACKAGE {
    LIST_ENTRY                  List;               // List Control
    ULONG                       TypeMask ;
    ULONG_PTR                   PackageId;          // ID
    ULONG                       PackageIndex;       // Index for the package
    ULONG                       fState;             // State
    ULONG_PTR                   OriginalLowerCtxt;  // Original Lower context handle
    ULONG_PTR                   OriginalLowerCred;  // Original lower cred handle
    struct _DLL_BINDING *       pBinding;           // Link to DLL binding
    struct _DLL_SECURITY_PACKAGE * pRoot ;          // "First" Package of a DLL
    struct _DLL_SECURITY_PACKAGE * pPeer ;          // "Peer" package list
    ULONG                       fCapabilities;      // Package Info:
    WORD                        Version;            // Version
    WORD                        RpcId;              // RPC ID
    ULONG                       TokenSize;          // Initial Token Size
    SECURITY_STRING             PackageName;        // Name (U)
    SECURITY_STRING             Comment;            // Comment (U)

    LPSTR                       PackageNameA;       // Only if ANSI supported:
    DWORD                       AnsiNameSize;
    LPSTR                       CommentA;
    DWORD                       AnsiCommentSize;

    PSecurityFunctionTableA     pftTableA;          // Table for ansi-specific calls
    PSecurityFunctionTableW     pftTableW;          // Table for unicode-specific calls
    PSecurityFunctionTableW     pftTable;           // Table for non-specific calls
    PSECPKG_USER_FUNCTION_TABLE pftUTable;          // Table for user-mode stubs
    LOAD_SECURITY_INTERFACE     pfLoadPackage;      // Hook called at package init
    EXIT_SECURITY_INTERFACE     pfUnloadPackage;    // Hook called at package close

    PDLL_LSA_PACKAGE_INFO       LsaInfo ;           // Extra LSA info

} DLL_SECURITY_PACKAGE, * PDLL_SECURITY_PACKAGE ;

typedef struct _DLL_BINDING {
    SECPKG_TYPE     Type;               // Type of DLL loaded
    DWORD           Flags;              // Flags about the DLL
    HMODULE         hInstance;          // Instance Handle
    SECURITY_STRING Filename;           // Full path name
    DWORD           RefCount;           // Reference Count
    DWORD           PackageCount;       // Number of Packages in DLL
    ULONG           DllIndex;           // Index
    PSECPKG_USER_FUNCTION_TABLE Table;  // DLL-wide interface pointer
} DLL_BINDING, * PDLL_BINDING;

typedef struct _SASL_PROFILE {
    LIST_ENTRY              List ;
    PDLL_SECURITY_PACKAGE   Package ;
    SECURITY_STRING         ProfileName ;
} SASL_PROFILE, * PSASL_PROFILE ;

#define DLL_SECPKG_SAVE_LOWER   0x00000001      // Save the lower handle val
#define DLL_SECPKG_FREE_TABLE   0x00000002      // The tables are re-allocated
#define DLL_SECPKG_DELAY_LOAD   0x00000004      // The package is delay loaded
#define DLL_SECPKG_SASL_PROFILE 0x00000008      // The package has a SASL profile
#define DLL_SECPKG_CRED_LOWER   0x00000010      // Uses different values for context and cred
#define DLL_SECPKG_NO_CRYPT     0x00000020      // Fail crypto

#define DLL_BINDING_SIG_CHECK   0x00000001      // Signature has been checked
#define DLL_BINDING_DELAY_LOAD  0x00000002      // Delay load this DLL
#define DLL_BINDING_FREE_TABLE  0x00000004      // Free tables


#define DLLSTATE_DEFERRED   0x80000000
#define DLLSTATE_INITIALIZE 0x40000000
#define DLLSTATE_NO_TLS     0x20000000



#if DBG

void SecInitializeDebug(void);
void SecUninitDebug(void);

#define DebugStmt(x)    x

#else

#define DebugStmt(x)

#endif



// Private prototypes

SECURITY_STATUS SEC_ENTRY
DeleteUserModeContext(
    PCtxtHandle                 phContext           // Contxt to delete
    );

SECURITY_STATUS       LoadParameters(void);

SECURITY_STATUS IsSPMgrReady(void);

SECURITY_STATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    );

VOID * SEC_ENTRY
SecClientAllocate(ULONG cbMemory);

void SEC_ENTRY
SecClientFree(PVOID pvMemory);

BOOL
SecpAddVM(
    PVOID   pvAddr);

BOOL
SecpFreeVM(
    PVOID   pvAddr );

PDLL_SECURITY_PACKAGE
SecLocatePackageA(
    LPSTR   pszPackageName );

PDLL_SECURITY_PACKAGE
SecLocatePackageW(
    LPWSTR  pszPackageName );

PDLL_SECURITY_PACKAGE
SecLocatePackageById(
    ULONG_PTR Id );

PDLL_SECURITY_PACKAGE
SecLocatePackageByOriginalLower(
    BOOL Context,
    PDLL_SECURITY_PACKAGE OriginalPackage,
    ULONG_PTR    OriginalLower );

PSASL_PROFILE
SecLocateSaslProfileA(
    LPSTR ProfileName
    );

PSASL_PROFILE
SecLocateSaslProfileW(
    LPWSTR ProfileName
    );

SECURITY_STATUS
SecCopyPackageInfoToUserA(
    PDLL_SECURITY_PACKAGE Package,
    PSecPkgInfoA * pPackageInfo
    );

SECURITY_STATUS
SecCopyPackageInfoToUserW(
    PDLL_SECURITY_PACKAGE  Package,
    PSecPkgInfoW SEC_FAR * pPackageInfo
    );

SECURITY_STATUS
SecEnumerateSaslProfilesW(
    OUT LPWSTR * ProfileList,
    OUT ULONG * ProfileCount
    );

SECURITY_STATUS
SecEnumerateSaslProfilesA(
    OUT LPSTR * ProfileList,
    OUT ULONG * ProfileCount
    );

BOOL
SecInitializePackageControl(
    HINSTANCE);

VOID
SecUnloadPackages(
    BOOLEAN ProcessTerminate );

VOID
SecpFreePackages(
    IN PLIST_ENTRY pSecPackageList,
    IN BOOL fUnload
    );

VOID
SecpFreePackage(
    IN PDLL_SECURITY_PACKAGE pPackage,
    IN BOOL fUnload
    );

BOOL
SecEnumeratePackagesW(
    PULONG  PackageCount,
    PSecPkgInfoW *  Packages);

BOOL
SecEnumeratePackagesA(
    PULONG          PackageCount,
    PSecPkgInfoA *  Packages);

VOID
SecSetPackageFlag(
    PDLL_SECURITY_PACKAGE Package,
    ULONG   Flag);

VOID
SecClearPackageFlag(
    PDLL_SECURITY_PACKAGE Package,
    ULONG FLag);

BOOL
SEC_ENTRY
LsaBootPackage(
    PDLL_SECURITY_PACKAGE Package);

VOID
SEC_ENTRY
LsaUnloadPackage(
    VOID );

SECURITY_STATUS
SEC_ENTRY
SecpFailedSealFunction(
    PCtxtHandle         phContext,
    ULONG               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo);

SECURITY_STATUS
SEC_ENTRY
SecpFailedUnsealFunction(
    PCtxtHandle phHandle,
    PSecBufferDesc pMessage,
    ULONG MessageSeqNo,
    ULONG * pfQOP);

VOID
SaslDeleteSecurityContext(
    PCtxtHandle phContext
    );

//
// Global variables
//

extern DWORD                DllState;
extern RTL_CRITICAL_SECTION csSecurity;
extern PClient              SecDllClient;
extern DWORD                SecTlsEntry;
extern DWORD                SecTlsPackage;
extern ULONG                SecLsaPackageCount;
extern SecurityFunctionTableW   LsaFunctionTable;
extern SecurityFunctionTableA   LsaFunctionTableA;
extern SECPKG_DLL_FUNCTIONS SecpFTable;
extern LIST_ENTRY SaslContextList ;
extern CRITICAL_SECTION SaslLock ;

extern RTL_RESOURCE SecPackageListLock ;

#define ReadLockPackageList()   RtlAcquireResourceShared(&SecPackageListLock,TRUE)
#define WriteLockPackageList()  RtlAcquireResourceExclusive(&SecPackageListLock,TRUE)
#define UnlockPackageList()     RtlReleaseResource(&SecPackageListLock)


#ifdef BUILD_WOW64

//
// Additional WOW64 defines
//


typedef struct _SECWOW_HANDLE_MAP {
    LIST_ENTRY  List ;
    SEC_HANDLE_LPC  Handle ;
    ULONG HandleCount ;
    ULONG RefCount ;
} SECWOW_HANDLE_MAP, * PSECWOW_HANDLE_MAP ;

BOOL
SecpInitHandleMap(
    VOID
    );

BOOL
SecpFreeHandleMap(
    VOID
    );

BOOL
SecpAddHandleMap(
    IN PSEC_HANDLE_LPC LsaHandle,
    OUT PSECWOW_HANDLE_MAP * LocalHandle
    );

VOID
SecpDeleteHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap
    );

VOID
SecpDerefHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap
    );

VOID
SecpReferenceHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap,
    OUT PSEC_HANDLE_LPC LsaHandle
    );
#endif 

//
// Process wide synchronization
//
// NOTE:  UPDATE THE MACRO if the name of the critical section changes
//

#if DBG

void    GetProcessLock();
void    FreeProcessLock();

#else

#define GetProcessLock()    (void) RtlEnterCriticalSection(&csSecurity)
#define FreeProcessLock()   (void) RtlLeaveCriticalSection(&csSecurity)

#endif

#define SetCurrentPackage( p )  TlsSetValue( SecTlsPackage, p )
#define GetCurrentPackage( )    TlsGetValue( SecTlsPackage )


//
// Handle storing a return code
//

#define SecStoreReturnCode(/* SECURITY_STATUS */ x)      \
    if (!(DllState & DLLSTATE_NO_TLS))                   \
    {                                                    \
        TlsSetValue(SecTlsEntry, (PVOID) LongToPtr(x));  \
    }




#endif // __SECDLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\package.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        Package.c
//
// Contents:    Package management routines for the security DLL
//
//
// History:     12 Mar 92,  RichardW    Created
//              17 Aug 92,  RichardW    Rearranged, commented, etc.
//              08 Mar 94,  MikeSw      Moved to C++
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <crypt.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

#define NAME_NAME           TEXT("Name")
#define COMMENT_NAME        TEXT("Comment")
#define CAPABILITIES_NAME   TEXT("Capabilities")
#define RPCID_NAME          TEXT("RpcId")
#define TIME_NAME           TEXT("Time")
#define TYPE_NAME           TEXT("Type")
#define VERSION_NAME        TEXT("Version")
#define TOKENSIZE_NAME      TEXT("TokenSize")

NTSTATUS
NTAPI
LsaRegisterCallback(
    ULONG   CallbackId,
    PLSA_CALLBACK_FUNCTION Callback
    );

NTSTATUS
SEC_ENTRY
NegUserModeInitialize(
    IN ULONG,
    OUT PULONG,
    OUT PSECPKG_USER_FUNCTION_TABLE *,
    OUT PULONG );

RTL_RESOURCE    SecPackageListLock;

PDLL_BINDING *  SecPackageDllList;
ULONG           SecPackageDllCount;
ULONG           SecPackageDllTotal;

LIST_ENTRY      SecPackageControlList;
LIST_ENTRY      SecSaslProfileList ;

BOOL            SecPackageLsaLoaded;
BOOL            SecPackageSspiLoaded;
ULONG           SecLsaPackageCount;
ULONG           SecSspiPackageCount;
ULONG           SecSaslProfileCount;

#define SSPI_PACKAGE_OFFSET         0x00010000
#define INITIAL_PACKAGE_DLL_SIZE    4


SECPKG_DLL_FUNCTIONS SecpFTable = {
    (PLSA_ALLOCATE_LSA_HEAP) SecClientAllocate,
    (PLSA_FREE_LSA_HEAP) SecClientFree,
    LsaRegisterCallback

};

static PWSTR SecpAllowedDlls[] = { L"SCHANNEL.DLL",
                                       L"MSNSSPC.DLL"
                                     };

DLL_BINDING SecpBuiltinBinding;

VOID
SecpLoadLsaPackages(
    VOID);

VOID
SecpLoadSspiPackages(
    VOID );

VOID
SecpLoadSaslProfiles(
    VOID
    );

BOOL
SecSnapDelayLoadDll(
    PDLL_SECURITY_PACKAGE Package
    );

BOOL
SecpSnapPackage(
    PDLL_SECURITY_PACKAGE Package);

BOOL
SecpLoadSspiDll(
    PDLL_BINDING Dll
    );

BOOL
SecpBindSspiDll(
    IN PDLL_BINDING Binding,
    OUT PSecurityFunctionTableA * pTableA,
    OUT PSecurityFunctionTableW * pTableW,
    OUT PBOOL FixedUp
    );

BOOL
SecpSnapDll(
    IN PDLL_BINDING Binding,
    OUT PLIST_ENTRY PackageList,
    OUT PULONG PackageCount
    );


//+---------------------------------------------------------------------------
//
//  Function:   SecpDuplicateString
//
//  Synopsis:   Duplicates a unicode string
//
//  Arguments:  [New]      --
//              [Original] --
//
//  History:    8-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpDuplicateString(
    PUNICODE_STRING New,
    PUNICODE_STRING Original)
{
    New->Buffer = (PWSTR) LocalAlloc( LMEM_FIXED, Original->Length + sizeof(WCHAR) );

    if ( New->Buffer )
    {
        New->MaximumLength = Original->Length + sizeof( WCHAR );

        New->Length = Original->Length;

        CopyMemory( New->Buffer, Original->Buffer, Original->MaximumLength );

        return( TRUE );

    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpAddDllPackage
//
//  Synopsis:   Adds a "user" mode package to the list, at the end
//
//  Arguments:  [pPackage] --
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecpAddDllPackage(
    PDLL_SECURITY_PACKAGE pPackage)
{
    PDLL_SECURITY_PACKAGE *   pList;

    //
    // Grab exclusive access to the list:
    //

    WriteLockPackageList();

    //
    // Add to the tail.  Hopefully, the one first referenced will be at the
    // front, and incidental packages will end up at the end.
    //


    InsertTailList( &SecPackageControlList,
                    &pPackage->List );

    pPackage->pBinding->RefCount++;

    UnlockPackageList();

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpRemovePackage
//
//  Synopsis:   Removes a package from the list, returning the control
//              structure for deref and freeing.
//
//  Arguments:  [PackageId] --
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecpRemovePackage(
    ULONG_PTR PackageId)
{
    PDLL_SECURITY_PACKAGE   Kill = NULL;
    PLIST_ENTRY Scan;

    WriteLockPackageList();

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Kill = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Kill->PackageId == PackageId )
        {
            break;
        }

        Scan = Scan->Flink ;

        Kill = NULL;
    }


    if ( Kill )
    {
        RemoveEntryList( &Kill->List );

    }

    UnlockPackageList();

    return( Kill );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpAddDll
//
//  Synopsis:   Add a DLL Binding to the list
//
//  Arguments:  [pBinding] -- binding to add
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpAddDll(
    PDLL_BINDING    pBinding)
{
    PDLL_BINDING *  pList;
    ULONG           DllId;

    DebugLog((DEB_TRACE, "Adding binding for %ws\n", pBinding->Filename.Buffer ));

    WriteLockPackageList();

    if ( SecPackageDllCount == SecPackageDllTotal )
    {
        pList = (PDLL_BINDING *) LocalAlloc( LMEM_FIXED, sizeof(PDLL_BINDING) *
                                (SecPackageDllTotal + INITIAL_PACKAGE_DLL_SIZE));
        if (!pList)
        {
            UnlockPackageList();
            return( FALSE );
        }

        CopyMemory( pList,
                    SecPackageDllList,
                    sizeof( PDLL_BINDING ) * SecPackageDllTotal );

        SecPackageDllTotal += INITIAL_PACKAGE_DLL_SIZE;

        LocalFree( SecPackageDllList );

        SecPackageDllList = pList;
    }

    pBinding->DllIndex = SecPackageDllCount;
    SecPackageDllList[ SecPackageDllCount++ ] = pBinding;

    UnlockPackageList();

    return( TRUE );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpRemoveDll
//
//  Synopsis:   Remove a DLL binding from the list
//
//  Arguments:  [pBinding] --
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecpRemoveDll(
    PDLL_BINDING    pBinding)
{
    ULONG i;

    WriteLockPackageList();

    if (SecPackageDllList[SecPackageDllCount - 1] == pBinding )
    {
        SecPackageDllCount --;

        SecPackageDllList[ SecPackageDllCount ] = NULL;
    }
    else
    {

        for (i = 0; i < SecPackageDllCount ; i++ )
        {
            if (SecPackageDllList[ i ] == pBinding)
            {
                SecPackageDllList[ i ] = NULL;
                break;
            }
        }
    }

    UnlockPackageList();

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFindDll
//
//  Synopsis:   Returns the binding for a DLL
//
//  Arguments:  [DllName] -- Path to search for
//
//  History:    8-06-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_BINDING
SecpFindDll(
    PUNICODE_STRING DllName)
{
    ULONG i;
    PDLL_BINDING Binding;

    ReadLockPackageList();

    for ( i = 0 ; i < SecPackageDllCount ; i++ )
    {
        if (RtlEqualUnicodeString(  DllName,
                                    &SecPackageDllList[i]->Filename,
                                    TRUE ) )
        {
            break;
        }
    }

    if ( i < SecPackageDllCount )
    {
        Binding = SecPackageDllList[ i ];
    }
    else
    {
        Binding = NULL ;
    }

    UnlockPackageList();

    return( Binding );

}



//+---------------------------------------------------------------------------
//
//  Function:   SecInitializePackageControl
//
//  Synopsis:   Initializes package control structures
//
//  Arguments:  (none)
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecInitializePackageControl(
    HINSTANCE   Instance)
{
    NTSTATUS Status;

    __try
    {
        RtlInitializeResource( &SecPackageListLock );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return( FALSE );
    }

    WriteLockPackageList();

    InitializeListHead( &SecPackageControlList );

    //
    // SASL Init
    //

    InitializeListHead( &SecSaslProfileList );

    InitializeListHead( &SaslContextList );

    Status = RtlInitializeCriticalSection( &SaslLock );

    if (!NT_SUCCESS(Status))
    {
        UnlockPackageList();
        RtlDeleteResource( &SecPackageListLock );

        return( FALSE );
    }

    SecPackageLsaLoaded = FALSE ;

    SecPackageSspiLoaded = FALSE ;

    SecpBuiltinBinding.Type = SecPkgBuiltin ;
    SecpBuiltinBinding.RefCount = 1;
    SecpBuiltinBinding.hInstance = Instance;

    SecPackageDllList = (PDLL_BINDING *) LocalAlloc( LMEM_FIXED, sizeof(PDLL_BINDING) *
                            INITIAL_PACKAGE_DLL_SIZE );

    if (SecPackageDllList)
    {
        SecPackageDllCount = 0;
        SecPackageDllTotal = INITIAL_PACKAGE_DLL_SIZE;

        UnlockPackageList();

        return( TRUE );

    }

    UnlockPackageList();
    RtlDeleteCriticalSection( &SaslLock );
    RtlDeleteResource( &SecPackageListLock );

    return( FALSE );
}


VOID
SecpDerefDll(
    PDLL_BINDING    Dll
    )
{
    Dll->RefCount-- ;

    if ( Dll->RefCount == 0 )
    {
        LocalFree( Dll->Filename.Buffer );

        FreeLibrary( Dll->hInstance );

#if DBG
        ZeroMemory( Dll, sizeof( DLL_BINDING ) );
#endif
        LocalFree( Dll );
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFreePackage
//
//  Synopsis:   Frees the resources allocated for a security package
//
//  Arguments:  pPackage     -- pointer to security package
//              fUnload      -- if TRUE, unload the package as well
//
//  History:    05-June-1999 kumarp
//
VOID
SecpFreePackage(
    IN PDLL_SECURITY_PACKAGE pPackage,
    IN BOOL fUnload
    )
{
    if ( fUnload && pPackage->pfUnloadPackage )
    {
        pPackage->pfUnloadPackage();
    }

    LocalFree( pPackage->PackageName.Buffer );
    LocalFree( pPackage->Comment.Buffer );
    LocalFree( pPackage->PackageNameA );
    LocalFree( pPackage->CommentA );

    if ( pPackage->pBinding )
    {
        SecpDerefDll( pPackage->pBinding );
    }

#if DBG
    ZeroMemory( pPackage, sizeof( DLL_SECURITY_PACKAGE ) );
#endif

    LocalFree( pPackage );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFreePackages
//
//  Synopsis:   Frees the resources allocated for security packages
//
//  Arguments:  pSecPackageList -- pointer to security package list
//              fUnload         -- if TRUE, unload each package as well
//
//  History:    05-June-1999 kumarp
//
VOID
SecpFreePackages(
    IN PLIST_ENTRY pSecPackageList,
    IN BOOL fUnload
    )
{
    PDLL_SECURITY_PACKAGE pPackage;

    while ( !IsListEmpty( pSecPackageList ) )
    {
        pPackage = (PDLL_SECURITY_PACKAGE) RemoveHeadList( pSecPackageList );

        SecpFreePackage( pPackage, fUnload );
    }
}

VOID
SecpDeletePackage(
    PDLL_SECURITY_PACKAGE   Package
    )
{
    SecpFreePackage( Package, TRUE );
}

VOID
SecUnloadPackages(
    BOOLEAN ProcessTerminate
    )
{
    if( !ProcessTerminate )
    {
        WriteLockPackageList();
    }

    SecpFreePackages( &SecPackageControlList, TRUE );

    if( !ProcessTerminate )
    {
        UnlockPackageList();
    }

    LocalFree( SecPackageDllList );

    RtlDeleteResource( &SecPackageListLock );
    RtlDeleteCriticalSection( &SaslLock );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpScanPackageList
//
//  Synopsis:   Scans the list
//
//  Arguments:  [PackageName] -- Name (optional)
//              [PackageId]   -- Id, or -1
//
//  History:    8-19-96   RichardW   Created
//
//  Notes:      Assumes the list is locked
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecpScanPackageList(
    ULONG TypeMask,
    PUNICODE_STRING PackageName OPTIONAL,
    ULONG_PTR PackageId)
{
    PLIST_ENTRY Scan;
    PDLL_SECURITY_PACKAGE Package;

    Package = NULL ;

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        DebugLog(( DEB_TRACE_PACKAGE, "Compare package %ws\n", Package->PackageName.Buffer ));

        if ( PackageName )
        {
            if ( RtlEqualUnicodeString( &Package->PackageName, PackageName, TRUE ) )
            {
                if ( TypeMask == SECPKG_TYPE_ANY )
                {
                    break;
                }
                if ( (Package->TypeMask & TypeMask) == TypeMask )
                {
                    break;
                }
            }
        }
        else
        {
            if ( Package->PackageId == PackageId )
            {
                if ( TypeMask == SECPKG_TYPE_ANY )
                {
                    break;
                }
                if ( (Package->TypeMask & TypeMask) == TypeMask )
                {
                    break;
                }
            }
        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }


    return( Package );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecLocatePackageByOriginalId
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [OriginalId] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    10-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecLocatePackageByOriginalLower(
    BOOL Context,
    PDLL_SECURITY_PACKAGE OriginalPackage,
    ULONG_PTR   OriginalLower)
{
    PDLL_SECURITY_PACKAGE Package;
    BOOL Hit ;

    ReadLockPackageList();

    Package = OriginalPackage->pRoot ;

    while ( Package )
    {
        DebugLog(( DEB_TRACE_PACKAGE, "Compare package %ws (%p)\n",
                Package->PackageName.Buffer,
                Package->OriginalLowerCtxt ));

        if ( Context )
        {
            Hit = (Package->OriginalLowerCtxt == OriginalLower );
        }
        else
        {
            Hit = ( Package->OriginalLowerCred == OriginalLower );
        }

        if ( ( Hit ) &&
             (Package->pBinding->DllIndex == OriginalPackage->pBinding->DllIndex) )
        {
            if ( ( Package->TypeMask & SECPKG_TYPE_NEW ) == 0 )
            {
                break;
            }
        }

        Package = Package->pPeer ;
    }

    UnlockPackageList();

    return( Package );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpLocatePackage
//
//  Synopsis:   Common package locating loop
//
//  Arguments:  [PackageName] -- Name (or NULL)
//              [PackageId]   -- Id (or -1)
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecpLocatePackage(
    ULONG TypeMask,
    PUNICODE_STRING PackageName OPTIONAL,
    ULONG_PTR PackageId
    )
{
    PDLL_SECURITY_PACKAGE Package;

    Package = NULL ;

    //
    // Search in several stages.  First, see if it is there.  This is the
    // most common case.
    //

    ReadLockPackageList();

    Package = SecpScanPackageList( TypeMask, PackageName, PackageId );

    //
    // Found it.  We're done.
    //

    if ( Package )
    {

        UnlockPackageList();

        return( Package );

    }


    //
    // Well, no luck that time.  See if the guy passed in something bogus:
    //

    if ( SecPackageLsaLoaded && SecPackageSspiLoaded )
    {
        //
        // The full list is present, and the name was not found.  We're done.
        //

        UnlockPackageList();

        return( NULL );
    }

    //
    // Bummer, have to load the missing packages:
    //

    UnlockPackageList();

    WriteLockPackageList();

    SecpLoadLsaPackages();

    SecpLoadSspiPackages();

    SecpLoadSaslProfiles();

    UnlockPackageList();

    //
    // Try the search again:
    //

    ReadLockPackageList();

    Package = SecpScanPackageList( TypeMask, PackageName, PackageId );

    UnlockPackageList();

    //
    // Succeed or fail, tell them what we've got:
    //

    return( Package );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecLocatePackageW
//
//  Synopsis:   Wide stub to locate a package
//
//  Arguments:  [Package] -- Package name, wide
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecLocatePackageW(
    LPWSTR  pszPackage
    )
{
    UNICODE_STRING  PackageName;
    PDLL_SECURITY_PACKAGE   Package;
    BOOL Success;

    RtlInitUnicodeString( &PackageName, pszPackage );

    Package = SecpLocatePackage( SECPKG_TYPE_WIDE, &PackageName, (ULONG) -1 );

    if ( Package )
    {
        //
        // If everything is set, return it.  Otherwise, snap the package
        //

        if ( ( Package->fState & DLL_SECPKG_DELAY_LOAD ) == 0  )
        {
            return( Package );
        }

        WriteLockPackageList();

        Success = SecpSnapPackage( Package );

        UnlockPackageList();

        if ( Success )
        {
            return( Package );
        }

    }

    return( NULL );
}


//+---------------------------------------------------------------------------
//
//  Function:   SecLocatePackageA
//
//  Synopsis:   ANSI Stub to locate a package
//
//  Arguments:  [Package] -- ASCIIZ Package name,
//
//  History:    8-02-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecLocatePackageA(
    LPSTR   Package
    )
{
    UNICODE_STRING PackageName;
    NTSTATUS Status;
    PDLL_SECURITY_PACKAGE SecurityPackage;
    BOOL Success ;

    if (RtlCreateUnicodeStringFromAsciiz(
                    &PackageName,
                    Package ))
    {
        SecurityPackage = SecpLocatePackage( SECPKG_TYPE_ANSI, &PackageName, (ULONG) -1 );

        RtlFreeUnicodeString( &PackageName );

    }
    else
    {
        SecurityPackage = NULL ;
    }

    if ( SecurityPackage )
    {
        if ( ( SecurityPackage->fState & DLL_SECPKG_DELAY_LOAD ) == 0 )
        {
            return( SecurityPackage );
        }

        WriteLockPackageList();

        Success = SecpSnapPackage( SecurityPackage );

        UnlockPackageList();

        if ( Success )
        {
            return( SecurityPackage );
        }

        SecurityPackage = NULL ;

    }

    return( SecurityPackage );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecLocatePackageById
//
//  Synopsis:   Locates a package by ID
//
//  Arguments:  [PackageId] --
//
//  History:    8-06-96   RichardW   Created
//
//  Notes:      Also loads and snaps a DLL, due to the nature of where
//              this is called from.
//
//----------------------------------------------------------------------------
PDLL_SECURITY_PACKAGE
SecLocatePackageById(
    ULONG_PTR  PackageId )
{
    PDLL_SECURITY_PACKAGE   Package;
    BOOL    Success;

    Package = SecpLocatePackage( SECPKG_TYPE_ANY, NULL, PackageId );

    if ( !Package )
    {
        return( NULL );
    }

    if ( ( Package->fState & DLL_SECPKG_DELAY_LOAD ) == 0  )
    {
        return( Package );
    }

    WriteLockPackageList();

    Success = SecpSnapPackage( Package );

    UnlockPackageList();

    if ( Success )
    {
        return( Package );
    }

    return( NULL );
}

PSASL_PROFILE
SecpScanProfileList(
    PUNICODE_STRING ProfileName
    )
{
    PSASL_PROFILE Profile = NULL ;
    PLIST_ENTRY Scan ;

    ReadLockPackageList();

    Scan = SecSaslProfileList.Flink ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        if ( RtlEqualUnicodeString( ProfileName,
                                    &Profile->ProfileName,
                                    TRUE ) )
        {
            break;
        }

        Scan = Scan->Flink ;
        Profile = NULL ;
    }

    UnlockPackageList();

    return Profile ;

}


PSASL_PROFILE
SecLocateSaslProfileA(
    LPSTR ProfileName
    )
{
    UNICODE_STRING ProfileNameU;
    NTSTATUS Status;
    BOOL Success ;
    PSASL_PROFILE Profile ;

    if ( RtlCreateUnicodeStringFromAsciiz(
                    &ProfileNameU,
                    ProfileName ) )
    {

        Profile = SecpScanProfileList( &ProfileNameU );

        RtlFreeUnicodeString( &ProfileNameU );

    }
    else
    {
        Profile = NULL ;
    }

    return Profile ;
}

PSASL_PROFILE
SecLocateSaslProfileW(
    LPWSTR ProfileName
    )
{
    UNICODE_STRING ProfileNameU ;

    RtlInitUnicodeString(&ProfileNameU, ProfileName );

    return SecpScanProfileList( &ProfileNameU );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpSnapNewDll
//
//  Synopsis:   Snaps and loads the function table for a new package DLL
//
//  Arguments:  [Package] -- package control
//
//  History:    8-15-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpSnapNewDll(
    PDLL_SECURITY_PACKAGE   Package)
{
    PDLL_BINDING    Binding;
    SpUserModeInitializeFn  Func;
    ULONG   PackageVersion;
    NTSTATUS Status;
    PVOID Ignored;

    DebugLog((DEB_TRACE, "Snapping new-style package %d, %ws\n",
                Package->PackageId, Package->pBinding->Filename.Buffer ));

    Binding = Package->pBinding;

    if ( Binding == &SecpBuiltinBinding )
    {
        Func = NegUserModeInitialize ;
    }
    else
    {
        Func = (SpUserModeInitializeFn) GetProcAddress(
                                            Binding->hInstance,
                                            SECPKG_USERMODEINIT_NAME );

    }


    if ( !Func )
    {
        FreeLibrary( Binding->hInstance );

        Binding->hInstance = NULL ;

        return( FALSE );

    }

    __try
    {
        Status = (Func)(SECPKG_INTERFACE_VERSION,
                        &PackageVersion,
                        &Binding->Table,
                        &Binding->PackageCount );

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) )
    {
        FreeLibrary( Binding->hInstance );

        Binding->hInstance = NULL ;

        return( FALSE );
    }

    //
    // Done, the binding table is now in the DLL record:
    //

    Package->pftUTable = &Binding->Table[ Package->PackageIndex ];
    Package->pftTableW = &LsaFunctionTable ;
    Package->pftTableA = &LsaFunctionTableA ;
    Package->pftTable = &LsaFunctionTable ;
    Package->pfLoadPackage = LsaBootPackage ;
    Package->pfUnloadPackage = LsaUnloadPackage ;

    Package->fState &= ~(DLL_SECPKG_DELAY_LOAD) ;


    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpSnapPackage
//
//  Synopsis:   Loads and snaps entry points for new packages
//
//  Arguments:  [Package] --
//
//  History:    8-15-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpSnapPackage(
    PDLL_SECURITY_PACKAGE   Package)
{
    PDLL_BINDING    Binding ;

    DebugLog((DEB_TRACE, "Snapping DLL for package %#x, %ws\n",
                    Package->PackageId, Package->pBinding->Filename.Buffer ));

    if ( Package->TypeMask & SECPKG_TYPE_OLD )
    {
        //
        // Old package that has been delay loaded.
        //

        return SecSnapDelayLoadDll( Package );

    }

    Binding = Package->pBinding ;

    if ( Binding->hInstance )
    {
        if ( Package->TypeMask & SECPKG_TYPE_NEW )
        {
            Package->pftUTable = &Binding->Table[ Package->PackageIndex ];
            Package->pftTableW = &LsaFunctionTable ;
            Package->pftTableA = &LsaFunctionTableA ;
            Package->pftTable = &LsaFunctionTable ;

            return TRUE ;
        }
        else
        {
            return FALSE ;
        }

    }

    Binding->hInstance = LoadLibraryW( Binding->Filename.Buffer );

    if ( Binding->hInstance )
    {
        Binding->Type = SecPkgNewAW ;

        if ( Package->TypeMask & SECPKG_TYPE_NEW )
        {
            if ( !SecpSnapNewDll( Package ) )
            {
                return FALSE ;
            }
        }
        else
        {
            Binding->hInstance = NULL ;
            return FALSE ;
        }

        if ( Package->pfLoadPackage )
        {
            if ( Package->pfLoadPackage( Package ) )
            {
                return( TRUE );
            }
        }

    }

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpLoadLsaPackages
//
//  Synopsis:   Gets the list of LSA mode packages
//
//  Arguments:  (none)
//
//
//  History:    8-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecpLoadLsaPackages(
    VOID)
{
    DWORD   i;
    PDLL_SECURITY_PACKAGE   Package;
    PDLL_LSA_PACKAGE_INFO   LsaInfo ;
    PDLL_BINDING    Binding;
    PDLL_BINDING    ExistingBinding;
    SECURITY_STATUS Status;
    SECURITY_STRING Dll;
    SECURITY_STRING Comment;
    SECURITY_STRING Local ;
    SEC_PACKAGE_BINDING_INFO Info;
    ANSI_STRING AnsiString = { 0 };

    //
    // Make sure we have a connection to the LSA
    //

    if( IsOkayToExec(NULL) != SEC_E_OK )
    {
        return;
    }

    //
    // At this point, we have a count of the LSA packages:
    //

    for ( i = 0 ; i < SecLsaPackageCount ; i++ )
    {
        Package = (PDLL_SECURITY_PACKAGE) LocalAlloc( LMEM_FIXED,
                                            sizeof( DLL_SECURITY_PACKAGE ) +
                                            sizeof( DLL_LSA_PACKAGE_INFO ) );

        Binding = (PDLL_BINDING) LocalAlloc( LMEM_FIXED, sizeof( DLL_BINDING ) );

        if ( (Binding) && (Package) )
        {

            //
            // Get the binding info from the LSA
            //

            LsaInfo = (PDLL_LSA_PACKAGE_INFO) (Package + 1);



            Status = SecpGetBinding(i,
                                    &Info );

            if ( NT_SUCCESS( Status ) )
            {
                //
                // Clean up
                //

                ZeroMemory( Package, sizeof( DLL_SECURITY_PACKAGE ) +
                                     sizeof( DLL_LSA_PACKAGE_INFO ) );

                //
                // Copy names around
                //

                DebugLog((DEB_TRACE_PACKAGE, "Got binding info for %d : %ws\n", i, Info.PackageName.Buffer ));

                //
                // initialize the easy parts:
                //

                SecpLpcStringToSecurityString( &Local, &Info.PackageName );

                if ( !SecpDuplicateString( &Package->PackageName, &Local ) )
                {
                    Status = SEC_E_INSUFFICIENT_MEMORY ;
                }
                else
                {
                    Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                                            &Package->PackageName,
                                                            TRUE );

                }


                if ( NT_SUCCESS( Status ) )
                {
                    Package->PackageNameA = AnsiString.Buffer ;
                    Package->AnsiNameSize = AnsiString.Length + 1 ;

                    SecpLpcStringToSecurityString( &Local, &Info.Comment );

                    if ( !SecpDuplicateString( &Package->Comment, &Local ) )
                    {
                        Status = SEC_E_INSUFFICIENT_MEMORY ;
                    }
                    else
                    {

                        Status = RtlUnicodeStringToAnsiString(  &AnsiString,
                                                                &Package->Comment,
                                                                TRUE );
                    }

                    if ( NT_SUCCESS( Status ) )
                    {
                        Package->CommentA = AnsiString.Buffer ;
                        Package->AnsiCommentSize = AnsiString.Length + 1;
                    }
                }


                if ( !NT_SUCCESS( Status ) )
                {
                    //
                    // Clean up and bail out:
                    //

                    if ( Package->CommentA )
                    {
                        RtlFreeHeap( RtlProcessHeap(), 0, Package->CommentA );
                    }

                    if ( Package->Comment.Buffer )
                    {
                        LocalFree( Package->Comment.Buffer );
                    }

                    if ( Package->PackageNameA )
                    {
                        RtlFreeHeap( RtlProcessHeap(), 0, Package->PackageNameA );
                    }

                    if ( Package->PackageName.Buffer )
                    {
                        LocalFree( Package->PackageName.Buffer );
                    }

                    LocalFree( Package );
                    LocalFree( Binding );

                    continue;
                }


                Package->TypeMask = SECPKG_TYPE_NEW |
                                SECPKG_TYPE_ANSI |
                                SECPKG_TYPE_WIDE ;

                Package->fState |= DLL_SECPKG_DELAY_LOAD ;
                if ( ( Info.Flags & PACKAGEINFO_SIGNED ) == 0 )
                {
                    Package->fState |= DLL_SECPKG_NO_CRYPT ;
                }
                Package->PackageIndex = Info.PackageIndex ;
                Package->fCapabilities = Info.fCapabilities ;
                Package->Version = (WORD) Info.Version ;
                Package->RpcId = (WORD) Info.RpcId ;
                Package->TokenSize = Info.TokenSize ;
                Package->LsaInfo = LsaInfo ;

                InitializeListHead( &LsaInfo->Callbacks );

                if ( Info.ContextThunksCount )
                {
                    LsaInfo->ContextThunkCount = Info.ContextThunksCount ;
                    LsaInfo->ContextThunks = (PULONG) LocalAlloc( LMEM_FIXED,
                                                LsaInfo->ContextThunkCount *
                                                    sizeof(DWORD) );
                    if ( LsaInfo->ContextThunks )
                    {
                        CopyMemory( LsaInfo->ContextThunks,
                                    Info.ContextThunks,
                                    Info.ContextThunksCount * sizeof(DWORD) );
                    }
                    else
                    {
                        LsaInfo->ContextThunkCount = 0 ;
                    }
                }

                if ( Info.Flags & PACKAGEINFO_BUILTIN )
                {
                    Binding = &SecpBuiltinBinding ;
                }
                else
                {
                    //
                    // If the package index is non-zero, then it is one of n
                    // packages contained in the DLL.  Snap it.
                    //
                    // Note:  This relies on the fact that the zero package
                    // would already have been found and loaded, and the
                    // fact that the LSA gave them to us in this order is relied
                    // upon.
                    //

                    if ( Package->PackageIndex != 0 )
                    {

                        SecpLpcStringToSecurityString( &Local, &Info.ModuleName );

                        ExistingBinding = SecpFindDll( &Local );

                        if ( ExistingBinding )
                        {
                            LocalFree( Binding );

                            Binding = ExistingBinding ;
                        }

                        else
                        {
                            ZeroMemory( Binding, sizeof( DLL_BINDING) );
                        }

                    }
                    else
                    {

                        ZeroMemory( Binding, sizeof( DLL_BINDING ) );

                    }

                    //
                    // If the file name isn't there already (new binding)
                    // copy it in as well.
                    //

                    if ( Binding->Filename.Buffer == NULL )
                    {
                        Binding->Type = SecPkgNewAW;

                        if ( Info.Flags & PACKAGEINFO_SIGNED )
                        {
                            Binding->Flags |= DLL_BINDING_SIG_CHECK ;
                        }

                        SecpLpcStringToSecurityString( &Local, &Info.ModuleName );

                        SecpDuplicateString( &Binding->Filename, &Local );

                        //
                        // Add the DLL binding to the list (defer the load)
                        //

                        SecpAddDll( Binding );
                    }
                }

                //
                // Set package Ids and such
                //

                Package->PackageId = i;

                Package->pBinding = Binding;

                //
                // Add the package to the list (defer the load)
                //

                SecpAddDllPackage( Package );

                //
                // Clean up:
                //

                LsaFreeReturnBuffer( Info.PackageName.Buffer );


                //
                // Snap the builtin package(s) immediately
                //

                if ( Info.Flags & PACKAGEINFO_BUILTIN )
                {
                    SecpSnapNewDll( Package );
                }


            }
            else
            {
                //
                // Call to LSA failed:
                //

                if ( Package )
                {
                    LocalFree( Package );
                }

                if ( Binding )
                {
                    LocalFree( Binding );
                }

            }

        }   //  if binding and package test
        else
        {
            if ( Package )
            {
                LocalFree( Package );
            }

            if ( Binding )
            {
                LocalFree( Binding );
            }

        }


    }   // for loop

    SecPackageLsaLoaded = TRUE ;

}


//+-------------------------------------------------------------------------
//
//  Function:   LocalWcsTok
//
//  Synopsis:   takes a pointer to a string, returns a pointer to the next
//              token in the string and sets StringStart to point to the
//              end of the string.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
LPWSTR
LocalWcsTok(
    LPWSTR String,
    LPWSTR Token,
    LPWSTR * NextStringStart
    )
{
    ULONG Index;
    ULONG Tokens;
    LPWSTR StartString;
    LPWSTR EndString;
    BOOLEAN Found;

    if (String == NULL)
    {
        *NextStringStart = NULL;
        return(NULL);
    }
    Tokens = wcslen(Token);

    //
    // Find the beginning of the string.
    //

    StartString = (LPTSTR) String;
    while (*StartString != L'\0')
    {
        Found = FALSE;
        for (Index = 0; Index < Tokens;  Index++)
        {
            if (*StartString == Token[Index])
            {
                StartString++;
                Found = TRUE;
                break;
            }
        }
        if (!Found)
        {
            break;
        }
    }

    //
    // There are no more tokens in this string.
    //

    if (*StartString == L'\0')
    {
        *NextStringStart = NULL;
        return(NULL);
    }

    EndString = StartString + 1;
    while (*EndString != L'\0')
    {
        for (Index = 0; Index < Tokens;  Index++)
        {
            if (*EndString == Token[Index])
            {
                *EndString = L'\0';
                *NextStringStart = EndString+1;
                return(StartString);
            }
        }
        EndString++;
    }
    *NextStringStart = NULL;
    return(StartString);

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpReadPackageList
//
//  Synopsis:   Reads the SSPI package list from the registry, and returns it
//              as separate strings, and a count
//
//  Arguments:  [pPackageCount] -- Number of SSPI DLLs
//              [pPackageArray] -- Names of DLLs
//
//  History:    8-19-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SecpReadPackageList(
    PULONG      pPackageCount,
    LPWSTR * *  pPackageArray,
    PVOID *     BasePointer,
    LPFILETIME  LastChange
    )
{
    HKEY RootKey = NULL;
    ULONG Error;
    ULONG Type;
    LPWSTR Packages = NULL;
    ULONG PackageSize = 0;
    LPWSTR PackageCopy = NULL;
    ULONG PackageCount = 0;
    LPWSTR PackageName;
    LPWSTR * PackageArray = NULL;
    ULONG Index;
    SECURITY_STATUS Status;
    LPWSTR TempString;

    //
    // Try to open the key.  If it isn't there, that's o.k.
    //

    *pPackageCount = 0;
    *pPackageArray = NULL;

    Error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\SecurityProviders"),
                0,
                KEY_READ,
                &RootKey );


    if (Error != 0)
    {
        return( SEC_E_OK );
    }

    if ( LastChange )
    {
        RegQueryInfoKey( RootKey,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         NULL,
                         LastChange );
    }

    //
    // Try to read the value.  If the value is not there, that is
    // o.k.
    //

    Error = RegQueryValueEx(
                RootKey,
                L"SecurityProviders",
                NULL,
                &Type,
                (PUCHAR) Packages,
                &PackageSize
                );

    if ((Error == ERROR_FILE_NOT_FOUND) ||
        (Type != REG_SZ))
    {
        RegCloseKey(RootKey);

        return( SEC_E_OK );
    }
    else if (Error != 0)
    {
        RegCloseKey(RootKey);
        return(SEC_E_CANNOT_INSTALL);
    }

    if (PackageSize <= sizeof(UNICODE_NULL))
    {
        RegCloseKey(RootKey);

        return( SEC_E_OK );
    }

    Packages = (LPWSTR) LocalAlloc(0,2 * PackageSize);
    if (Packages == NULL)
    {
        RegCloseKey(RootKey);

        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    PackageCopy = (LPWSTR) ((PBYTE) Packages + PackageSize);

    Error = RegQueryValueEx(
                RootKey,
                L"SecurityProviders",
                NULL,
                &Type,
                (PUCHAR) Packages,
                &PackageSize
                );

    RegCloseKey(RootKey);

    if (Error != 0)
    {
        LocalFree(Packages);
        return(SEC_E_CANNOT_INSTALL);
    }

    RtlCopyMemory(
        PackageCopy,
        Packages,
        PackageSize
        );


    //
    // Pull the package names out of the string to count the number
    //

    PackageName = LocalWcsTok(PackageCopy,L" ,", &TempString);
    while (PackageName != NULL)
    {
        PackageCount++;
        PackageName = LocalWcsTok(TempString, L" ,", &TempString);
    }

    //
    // Now make an array of the package dll names.
    //


    PackageArray = (LPWSTR *) LocalAlloc(0,PackageCount * sizeof(LPWSTR));
    if (PackageArray == NULL)
    {
        LocalFree(Packages);
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    PackageName = LocalWcsTok(Packages,L" ,",&TempString);
    Index = 0;
    while (PackageName != NULL)
    {
        PackageArray[Index++] = PackageName;
        PackageName = LocalWcsTok(TempString, L" ,",&TempString);
    }

    *pPackageCount = PackageCount;
    *pPackageArray = PackageArray;
    *BasePointer = Packages ;

    return( SEC_E_OK );

}


//+---------------------------------------------------------------------------
//
//  Function:   SecpLoadSspiPackages
//
//  Synopsis:   Loads the set of SSPI packages
//
//  Arguments:  (none)
//
//  History:    8-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecpLoadSspiPackages(
    VOID )
{
    PVOID BasePointer ;
    PWSTR * DllNames;
    ULONG   DllCount;
    ULONG   i;
    ULONG   j;
    SECURITY_STATUS Status;
    PDLL_BINDING    Binding;
    WCHAR   DllPath[ MAX_PATH ];
    PWSTR   Path;
    DWORD   PathLen;
    UNICODE_STRING Maybe;
    UNICODE_STRING Allowed;

    Status = SecpReadPackageList(
                &DllCount,
                &DllNames,
                &BasePointer,
                NULL );

    if ( NT_ERROR( Status ) )
    {
        return;
    }

    if ( DllCount == 0 )
    {
        return ;
    }

    for ( i = 0 ; i < DllCount ; i++ )
    {
        PathLen = SearchPath(NULL,
                        DllNames[i],
                        NULL,
                        MAX_PATH,
                        DllPath,
                        &Path );
        if ( PathLen )
        {
            RtlInitUnicodeString( &Maybe, DllPath );

            if ( SecpFindDll( &Maybe ) )
            {
                continue;
            }

            Binding = (PDLL_BINDING) LocalAlloc( LMEM_FIXED, sizeof( DLL_BINDING ) );

            if ( Binding )
            {

                ZeroMemory( Binding, sizeof( DLL_BINDING ) );

                Binding->Type = SecPkgOld;

                Binding->Filename.Buffer = (PWSTR) LocalAlloc( LMEM_FIXED,
                                (PathLen + 1) * sizeof(WCHAR) );

                if ( Binding->Filename.Buffer )
                {
                    Binding->Filename.MaximumLength = (USHORT)((PathLen + 1) * sizeof(WCHAR));
                    Binding->Filename.Length = Binding->Filename.MaximumLength - 2;

                    CopyMemory( Binding->Filename.Buffer,
                                DllPath,
                                Binding->Filename.MaximumLength );

                } else {
                    LocalFree( Binding );
                    continue;
                }

                SecpAddDll( Binding );

                RtlInitUnicodeString( &Maybe, DllNames[i] );
                for ( j = 0 ; j < sizeof(SecpAllowedDlls) / sizeof(PWSTR) ; j++ )
                {
                    RtlInitUnicodeString( &Allowed, SecpAllowedDlls[j] );

                    if ( RtlEqualUnicodeString( &Maybe, &Allowed, TRUE ) == 1)
                    {
                        Binding->Flags |= DLL_BINDING_SIG_CHECK;
                        break;
                    }
                }

            }
        }
    }

    //
    // Enumerate through DLLs, snapping their packages:
    //

    for ( i = 0 ; i < SecPackageDllCount ; i++ )
    {
        Binding = SecPackageDllList[ i ];

        if ( Binding->Type == SecPkgOld )
        {
            SecpLoadSspiDll( Binding );
        }

    }

    SecPackageSspiLoaded = TRUE ;

    LocalFree( BasePointer );
    LocalFree( DllNames );

}

BOOL
SecSnapDelayLoadDll(
    PDLL_SECURITY_PACKAGE Package
    )
{
    PSecurityFunctionTableA TableA ;
    PSecurityFunctionTableW TableW ;
    BOOL FixedUp ;

    if ( SecpBindSspiDll( Package->pBinding,
                          &TableA,
                          &TableW,
                          &FixedUp ) )
    {

        Package->pftTableW = TableW;
        Package->pftTable = TableW;
        Package->pftTableA = TableA ;

        //
        // ensure that we delay load the package only once
        //
        Package->fState    &= ~DLL_SECPKG_DELAY_LOAD;

        return TRUE ;
    }

    return FALSE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpRefDllFromCache
//
//  Synopsis:   Checks the registry to see if this DLL should be defer-loaded,
//              and returns true if so.  A DLL_SECURITY_PACKAGE structure is
//              created
//
//  Effects:
//
//  Arguments:  [Binding] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    10-24-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpRefDllFromCache(
    PDLL_BINDING Binding
    )
{
    HKEY LsaKey ;
    HKEY PackageKey ;
    int err ;
    PWSTR FileName ;
    DWORD Type ;
    DWORD Size ;
    DWORD Temp ;
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_SECURITY_PACKAGE Search ;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Lsa\\SspiCache"),
                        0,
                        KEY_READ,
                        &LsaKey );

    if ( err )
    {
        return FALSE ;
    }

    FileName = &Binding->Filename.Buffer[ Binding->Filename.Length / 2 ];

    while ( (FileName != Binding->Filename.Buffer) &&
            (*FileName != TEXT('\\') ) )
    {
        FileName-- ;
    }

    FileName++ ;

    err = RegOpenKeyEx( LsaKey,
                        FileName,
                        0,
                        KEY_READ,
                        &PackageKey );


    if ( err )
    {
        RegCloseKey( LsaKey );

        return FALSE ;
    }

    Package = (PDLL_SECURITY_PACKAGE) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                          sizeof( DLL_SECURITY_PACKAGE ) );

    if ( !Package )
    {
        RegCloseKey( LsaKey );

        RegCloseKey( PackageKey );

        return FALSE ;
    }


    Size = 0 ;

    err = RegQueryValueEx( PackageKey,
                           NAME_NAME,
                           0,
                           &Type,
                           NULL,
                           &Size );

    if ( ( err ) || ( Type != REG_SZ ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        NAME_NAME ));
        goto BadCacheEntry ;
    }

    Package->PackageName.Buffer = (PWSTR) LocalAlloc( LMEM_FIXED, Size );

    if ( Package->PackageName.Buffer )
    {
        err = RegQueryValueEx( PackageKey,
                               NAME_NAME,
                               0,
                               &Type,
                               (PUCHAR) Package->PackageName.Buffer,
                               &Size );

        if ( err || ( Type != REG_SZ ) )
        {
            DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        NAME_NAME ));
            goto BadCacheEntry ;
        }

        Package->PackageName.MaximumLength = (WORD) Size ;
        Package->PackageName.Length = (WORD) Size - sizeof( WCHAR );

    }
    else
    {
        DebugLog(( DEB_ERROR, "Out of memory allocating %x\n", Size ));
        goto OutOfMemory ;
    }

    Size = 0 ;

    err = RegQueryValueEx( PackageKey,
                           COMMENT_NAME,
                           0,
                           &Type,
                           NULL,
                           &Size );

    if ( ( err ) || ( Type != REG_SZ ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        COMMENT_NAME ));
        goto BadCacheEntry ;
    }

    Package->Comment.Buffer = (PWSTR) LocalAlloc( LMEM_FIXED, Size );

    if ( Package->Comment.Buffer)
    {
        err = RegQueryValueEx( PackageKey,
                               COMMENT_NAME,
                               0,
                               &Type,
                               (PUCHAR) Package->Comment.Buffer,
                               &Size );

        if ( err || ( Type != REG_SZ ) )
        {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        COMMENT_NAME ));
            goto BadCacheEntry ;
        }

        Package->Comment.MaximumLength = (WORD) Size ;
        Package->Comment.Length = (WORD) Size - sizeof( WCHAR );


    }
    else
    {
        DebugLog(( DEB_ERROR, "Out of memory allocating %x\n", Size ));
        goto OutOfMemory ;
    }

    //
    // Easy stuff now:
    //

    Size = sizeof( Temp );

    err = RegQueryValueEx( PackageKey,
                           CAPABILITIES_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        CAPABILITIES_NAME ));
        goto BadCacheEntry ;
    }

    Package->fCapabilities = Temp ;

    err = RegQueryValueEx( PackageKey,
                           RPCID_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        RPCID_NAME ));
        goto BadCacheEntry ;
    }

    Package->RpcId = (WORD) Temp ;

    err = RegQueryValueEx( PackageKey,
                           VERSION_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        VERSION_NAME ));
        goto BadCacheEntry ;
    }

    Package->Version = (WORD) Temp ;

    err = RegQueryValueEx( PackageKey,
                           TYPE_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {
        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        TYPE_NAME ));
        goto BadCacheEntry ;
    }

    Package->TypeMask = Temp ;

    err = RegQueryValueEx( PackageKey,
                           TOKENSIZE_NAME,
                           0,
                           &Type,
                           (PUCHAR) &Temp,
                           &Size );

    if ( err || ( Type != REG_DWORD ) )
    {

        DebugLog(( DEB_ERROR, "Bad cache entry %ws:%ws\n", FileName,
                        TOKENSIZE_NAME ));
        goto BadCacheEntry ;
    }

    Package->TokenSize = Temp ;

    //
    // Okay, we have read all the info back out of the registry cache.
    // we now will add the package to the list, and return done.
    //

    Package->pBinding = Binding ;
    Package->fState = DLL_SECPKG_DELAY_LOAD ;
    Binding->Flags |= DLL_BINDING_DELAY_LOAD ;
    Package->PackageId = (SecSspiPackageCount++) + SSPI_PACKAGE_OFFSET ;
    Package->PackageIndex = 0;
    Package->pRoot = Package ;
    Package->pPeer = NULL ;


    if ( Package->TypeMask & SECPKG_TYPE_ANSI )
    {
        Package->AnsiNameSize = RtlUnicodeStringToAnsiSize( &Package->PackageName ) + 1;

        Package->PackageNameA = (LPSTR) LocalAlloc( LMEM_FIXED,
                        Package->AnsiNameSize );
        if ( Package->PackageNameA )
        {
            ANSI_STRING String ;

            String.Length = 0 ;
            String.Buffer = Package->PackageNameA ;
            String.MaximumLength = (WORD) Package->AnsiNameSize ;

            RtlUnicodeStringToAnsiString(
                    &String,
                    &Package->PackageName,
                    FALSE );

        }

        Package->AnsiCommentSize = RtlUnicodeStringToAnsiSize( &Package->Comment ) + 1;

        Package->CommentA = (LPSTR) LocalAlloc( LMEM_FIXED,
                        Package->AnsiCommentSize );
        if ( Package->CommentA )
        {
            ANSI_STRING String ;

            String.Length = 0 ;
            String.Buffer = Package->CommentA ;
            String.MaximumLength = (WORD) Package->AnsiCommentSize ;

            RtlUnicodeStringToAnsiString(
                    &String,
                    &Package->Comment,
                    FALSE );

        }

        DebugLog((DEB_TRACE_PACKAGE, "Added ANSI entrypoints for %ws\n",
                        Package->PackageName.Buffer ));

    }

    WriteLockPackageList();

    Search = SecpScanPackageList( SECPKG_TYPE_ANY,
                                  &Package->PackageName,
                                  -1 );

    if ( !Search )
    {
        SecpAddDllPackage( Package );
    }
    else
    {
        DebugLog(( DEB_TRACE, "Duplicate package, %ws\n", Package->PackageName.Buffer ));
        SecpDeletePackage( Package );
    }

    UnlockPackageList();

    RegCloseKey(LsaKey);
    RegCloseKey(PackageKey);
    return TRUE ;


BadCacheEntry:

    RegDeleteKey( LsaKey, FileName );


OutOfMemory:

    RegCloseKey( LsaKey );

    RegCloseKey( PackageKey );

    SecpDeletePackage( Package );

    return FALSE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpLoadSspiDll
//
//  Synopsis:   Loads a DLL, and pulls all the packages out of it.
//
//  Effects:
//
//  Arguments:  [Binding] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-06-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpLoadSspiDll(
    PDLL_BINDING Binding
    )
{
    LIST_ENTRY DllPackageList ;
    ULONG DllPackageCount ;
    PDLL_SECURITY_PACKAGE Package ;
    PDLL_SECURITY_PACKAGE Search ;
    PLIST_ENTRY Pop ;


    DebugLog(( DEB_TRACE, "Loading SSPI DLL %ws\n", Binding->Filename.Buffer ));

    //
    // This function is called on a lazy snap as well as the up-front
    // snap.  This flag is set if the DLL was marked as DELAY the first time
    // through.  Therefore, if it is not set, see if we're supposed to delay
    // load it.  If it is set, then we now really need it.
    //

    if ( (Binding->Flags & DLL_BINDING_DELAY_LOAD) == 0  )
    {
        if ( SecpRefDllFromCache( Binding ) )
        {
            DebugLog(( DEB_TRACE, "Deferring SSPI DLL %ws\n", Binding->Filename.Buffer ));
            return TRUE ;
        }
    }
    else
    {
        Binding->Flags &= ~(DLL_BINDING_DELAY_LOAD) ;
    }

    if ( SecpSnapDll( Binding, &DllPackageList, &DllPackageCount ) )
    {
        //
        // The DLL has been snapped, and the individual packages are
        // in the list, ready to be added.
        //

        while ( !IsListEmpty( &DllPackageList ) )
        {
            Pop = RemoveHeadList( &DllPackageList );

            Package = CONTAINING_RECORD( Pop, DLL_SECURITY_PACKAGE, List );

            WriteLockPackageList();

            Search = SecpScanPackageList( SECPKG_TYPE_ANY,
                                          &Package->PackageName,
                                          -1 );

            if ( !Search )
            {
                SecpAddDllPackage( Package );
            }
            else
            {
                DebugLog(( DEB_TRACE, "Duplicate package, %ws\n", Package->PackageName.Buffer ));
                SecpDeletePackage( Package );
            }

            UnlockPackageList();
        }

        return TRUE ;

    }

    return FALSE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpBindSspiDll
//
//  Synopsis:   Load the DLL, get out the dispatch tables.  Note if they were
//              fixed up due to a seal/unseal issue.
//
//  Arguments:  [Binding] --
//              [pTableA] --
//              [pTableW] --
//              [FixedUp] --
//
//  History:    12-22-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpBindSspiDll(
    IN PDLL_BINDING Binding,
    OUT PSecurityFunctionTableA * pTableA,
    OUT PSecurityFunctionTableW * pTableW,
    OUT PBOOL FixedUp
    )
{
    HINSTANCE  hPackage;
    INIT_SECURITY_INTERFACE_W   InitW;
    INIT_SECURITY_INTERFACE_A   InitA;
    PSecurityFunctionTableA     TableA;
    PSecurityFunctionTableW     TableW;
    PSecurityFunctionTableA     FixupA = NULL ;
    PSecurityFunctionTableW     FixupW = NULL ;

    if ( RtlCheckSignatureInFile( Binding->Filename.Buffer ) )
    {
        Binding->Flags |= DLL_BINDING_SIG_CHECK ;
    }

    hPackage = LoadLibraryW( Binding->Filename.Buffer );
    if (!hPackage)
    {
        return( FALSE );
    }

    *FixedUp = FALSE ;

    Binding->hInstance = hPackage ;

    InitW = (INIT_SECURITY_INTERFACE_W)
            GetProcAddress(hPackage,"InitSecurityInterfaceW");

    InitA = (INIT_SECURITY_INTERFACE_A)
            GetProcAddress(hPackage,"InitSecurityInterfaceA");

    if ( ( InitW == NULL ) && ( InitA == NULL ) )
    {
        FreeLibrary( hPackage );

        return( FALSE );
    }

    if ( ( InitW == InitSecurityInterfaceW ) ||
         ( InitA == InitSecurityInterfaceA ) )
    {
        FreeLibrary( hPackage );

        return FALSE ;
    }

    if ( ( InitW ) && ( ! InitA ) )
    {
        Binding->Type = SecPkgOldW;
    }
    else
    {
        if ( ( InitW ) && ( InitA ) )
        {
            Binding->Type = SecPkgOldAW;
        }
        else
        {
            Binding->Type = SecPkgOldA;
        }
    }

    if ( InitA )
    {
        __try
        {
            TableA = InitA();
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            TableA = NULL ;
        }
    }
    else
    {
        TableA = NULL ;
    }

    if ( InitW )
    {
        __try
        {
            TableW = InitW();
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            TableW = NULL ;
        }
    }
    else
    {
        TableW = NULL ;
    }

    if ( ( ( InitW ) && ( TableW == NULL ) ) ||
         ( ( InitA ) && ( TableA == NULL ) ) )
    {
        FreeLibrary( hPackage );

        return( FALSE );
    }

    //
    // Security Fixups:
    //
    if ( TableW )
    {
        if ( (TableW->Reserved3) || (TableW->EncryptMessage) ||
             (TableW->Reserved4) || (TableW->DecryptMessage) )
        {
            if ( (Binding->Flags & DLL_BINDING_SIG_CHECK ) == 0 )
            {
                FixupW = (PSecurityFunctionTableW)
                                LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                            sizeof( SecurityFunctionTableW) );

                if ( FixupW )
                {
                    CopyMemory( FixupW, TableW, sizeof( SecurityFunctionTableW ) );

                    FixupW->Reserved3 = SecpFailedSealFunction ;
                    FixupW->EncryptMessage = SecpFailedSealFunction ;
                    FixupW->Reserved4 = SecpFailedUnsealFunction ;
                    FixupW->DecryptMessage = SecpFailedUnsealFunction ;

                    Binding->Flags |= DLL_BINDING_FREE_TABLE ;

                    TableW = FixupW ;

                    *FixedUp = TRUE ;
                }
                else
                {
                    FreeLibrary( hPackage );

                    return( FALSE );
                }
            }
        }
    }

    if ( TableA )
    {
        if ( (TableA->Reserved3) || (TableA->EncryptMessage) ||
             (TableA->Reserved4) || (TableA->DecryptMessage) )
        {
            if ( (Binding->Flags & DLL_BINDING_SIG_CHECK ) == 0 )
            {
                FixupA = (PSecurityFunctionTableA)
                                LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                            sizeof( SecurityFunctionTableA) );

                if ( FixupA )
                {
                    CopyMemory( FixupA, TableA, sizeof( SecurityFunctionTableA ) );

                    FixupA->Reserved3 = SecpFailedSealFunction ;
                    FixupA->EncryptMessage = SecpFailedSealFunction ;
                    FixupA->Reserved4 = SecpFailedUnsealFunction ;
                    FixupA->DecryptMessage = SecpFailedUnsealFunction ;

                    TableA = FixupA;

                    Binding->Flags |= DLL_BINDING_FREE_TABLE ;

                    *FixedUp = TRUE ;
                }
                else
                {
                    FreeLibrary( hPackage );

                    if ( FixupW )
                    {
                        LocalFree( FixupW );
                    }

                    return( FALSE );
                }
            }
        }
    }

    *pTableW = TableW ;
    *pTableA = TableA ;

    return TRUE ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpSnapDll
//
//  Synopsis:   Snap a DLL, reading the set of packages it contains
//
//  Arguments:  [Binding] --
//
//  History:    8-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecpSnapDll(
    IN PDLL_BINDING Binding,
    OUT PLIST_ENTRY PackageList,
    OUT PULONG PackageCount
    )
{

    PLIST_ENTRY Scan ;
    PDLL_SECURITY_PACKAGE Package = NULL;
    PDLL_SECURITY_PACKAGE RootPackage;
    PDLL_SECURITY_PACKAGE LastPackage;
    PSecurityFunctionTableA     TableA=NULL;
    PSecurityFunctionTableW     TableW=NULL;
    DWORD                       cPackages = 0 ;
    PSecPkgInfoA                PackageInfoA = NULL ;
    PSecPkgInfoW                PackageInfoW = NULL ;
    SECURITY_STATUS             scRet=SEC_E_OK;
    SECURITY_STRING             PackageName;
    SECURITY_STRING             String;
    DWORD                       i;
    BOOL                        FixedUp=FALSE;

    DebugLog((DEB_TRACE, "Snapping Packages from DLL %ws\n", Binding->Filename.Buffer ));

    InitializeListHead( PackageList );
    *PackageCount = 0 ;

    if ( ! SecpBindSspiDll( Binding, &TableA, &TableW, &FixedUp ) )
    {
        scRet = SEC_E_SECPKG_NOT_FOUND;
        goto Cleanup;
    }

    if ( TableW )
    {
        __try
        {
            scRet = TableW->EnumerateSecurityPackagesW( &cPackages,
                                                        &PackageInfoW );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            scRet = SEC_E_INVALID_HANDLE ;
        }

        RootPackage = NULL ;
        LastPackage = NULL ;
        if ( NT_SUCCESS( scRet ) )
        {
            for ( i = 0 ; i < cPackages ; i++ )
            {
                Package = (PDLL_SECURITY_PACKAGE) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                            sizeof( DLL_SECURITY_PACKAGE ) );

                if ( Package )
                {
                    Package->TypeMask = SECPKG_TYPE_OLD | SECPKG_TYPE_WIDE ;

                    Package->fCapabilities = PackageInfoW[i].fCapabilities ;
                    Package->pftTableW = TableW;
                    Package->pftTable = TableW;
                    Package->PackageId = (SecSspiPackageCount++) + SSPI_PACKAGE_OFFSET ;
                    Package->PackageIndex = i ;
                    if ( i == 0 )
                    {
                        RootPackage = Package ;
                    }
                    Package->pRoot = RootPackage ;
                    if ( LastPackage )
                    {
                        LastPackage->pPeer = Package ;
                    }
                    LastPackage = Package ;


                    RtlInitUnicodeString( &String, PackageInfoW[ i ].Name );

                    SecpDuplicateString( &Package->PackageName, &String );

                    Package->PackageNameA = NULL ;

                    RtlInitUnicodeString( &String, PackageInfoW[ i ].Comment );

                    SecpDuplicateString( &Package->Comment, &String );

                    Package->Version = PackageInfoW[ i ].wVersion ;
                    Package->RpcId = PackageInfoW[ i ].wRPCID ;
                    Package->TokenSize = PackageInfoW[ i ].cbMaxToken ;

                    Package->pBinding = Binding ;

                    if ( RootPackage )
                    {
                        Package->pBinding->RefCount++;
                    }

                    (*PackageCount)++ ;

                    DebugLog((DEB_TRACE_PACKAGE, "Snapped wide package %ws\n", Package->PackageName.Buffer ));

                    InsertTailList( PackageList, &Package->List );

                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                    break;
                }
            }
        }
        else
        {
            goto Cleanup;
        }

    }

    if ( TableA && NT_SUCCESS(scRet))
    {
        __try
        {
            scRet = TableA->EnumerateSecurityPackagesA( &cPackages,
                                                        &PackageInfoA );
        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            scRet = SEC_E_INVALID_HANDLE ;
        }

        if ( NT_SUCCESS( scRet ) )
        {
            RootPackage = NULL ;
            LastPackage = NULL ;

            for ( i = 0 ; i < cPackages ; i++ )
            {
                if ( RtlCreateUnicodeStringFromAsciiz( &PackageName,
                                                  PackageInfoA[i].Name ) )
                {
                    Scan = PackageList->Flink ;

                    while ( Scan != PackageList )
                    {
                        Package = CONTAINING_RECORD( Scan, DLL_SECURITY_PACKAGE, List );

                        if ( RtlCompareUnicodeString( &PackageName,
                                                      &Package->PackageName,
                                                      TRUE ) == 0 )
                        {
                            break;
                        }

                        Package = NULL ;

                        Scan = Scan->Flink ;

                    }

                    if ( Package )
                    {
                        Package->TypeMask |= SECPKG_TYPE_ANSI ;

                        Package->pftTableA = TableA;
                        RtlFreeUnicodeString( &PackageName );

                        Package->AnsiNameSize = strlen( PackageInfoA[i].Name ) + 1;

                        Package->PackageNameA = (LPSTR) LocalAlloc( LMEM_FIXED,
                                        Package->AnsiNameSize );
                        if ( Package->PackageNameA )
                        {
                            CopyMemory( Package->PackageNameA,
                                        PackageInfoA[i].Name,
                                        Package->AnsiNameSize );

                        }

                        Package->AnsiCommentSize = strlen( PackageInfoA[ i ].Comment ) + 1;

                        Package->CommentA = (LPSTR) LocalAlloc( LMEM_FIXED,
                                            Package->AnsiCommentSize );

                        if ( Package->CommentA )
                        {
                            CopyMemory( Package->CommentA,
                                        PackageInfoA[i].Comment,
                                        Package->AnsiCommentSize );
                        }

                        DebugLog((DEB_TRACE_PACKAGE, "Added ANSI entrypoints for %s\n",
                                        PackageInfoA[i].Name ));

                        continue;
                    }
                }

                Package = (PDLL_SECURITY_PACKAGE) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                            sizeof( DLL_SECURITY_PACKAGE ) );

                if ( Package )
                {
                    Package->TypeMask = SECPKG_TYPE_OLD | SECPKG_TYPE_ANSI ;
                    Package->fCapabilities = PackageInfoA[i].fCapabilities ;
                    Package->pftTableA = TableA;
                    Package->pftTable = (PSecurityFunctionTableW) TableA;
                    Package->PackageId = (SecSspiPackageCount++) + SSPI_PACKAGE_OFFSET ;
                    Package->PackageIndex = i ;

                    if ( i == 0 )
                    {
                        RootPackage = Package ;
                    }
                    Package->pRoot = RootPackage ;
                    if ( LastPackage )
                    {
                        LastPackage->pPeer = Package ;
                    }
                    LastPackage = Package ;

                    Package->PackageName = PackageName ;

                    Package->AnsiNameSize = strlen( PackageInfoA[i].Name ) + 1;

                    Package->PackageNameA = (LPSTR) LocalAlloc( LMEM_FIXED,
                                    Package->AnsiNameSize );
                    if ( Package->PackageNameA )
                    {
                        CopyMemory( Package->PackageNameA,
                                    PackageInfoA[i].Name,
                                    Package->AnsiNameSize );

                    }
                    else
                    {
                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                        break;
                    }

                    Package->AnsiCommentSize = strlen( PackageInfoA[ i ].Comment ) + 1;

                    Package->CommentA = (LPSTR) LocalAlloc( LMEM_FIXED,
                                        Package->AnsiCommentSize );

                    if ( Package->CommentA )
                    {
                        CopyMemory( Package->CommentA,
                                    PackageInfoA[i].Comment,
                                    Package->AnsiCommentSize );
                    }
                    else
                    {
                        scRet = SEC_E_INSUFFICIENT_MEMORY;
                        break;
                    }

                    Package->pBinding = Binding ;

                    (*PackageCount)++ ;

                    DebugLog((DEB_TRACE_PACKAGE, "Snapped ansi package %ws\n", Package->PackageName.Buffer ));

                    InsertTailList( PackageList, &Package->List );

                }
                else
                {
                    scRet = SEC_E_INSUFFICIENT_MEMORY;
                    break;
                }
            }

        }

    }

Cleanup:

    if ( !NT_SUCCESS(scRet) )
    {
        //
        // do cleanup on error
        //

        SecpFreePackages(PackageList, FALSE);

        if (FixedUp)
        {
            LocalFree( TableA );
            LocalFree( TableW );
        }
    }

    return NT_SUCCESS(scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   SecEnumeratePackagesA
//
//  Synopsis:   Worker for EnumerateSecurityPackages.
//
//  Arguments:  [PackageCount] --
//              [Packages]     --
//
//  History:    8-21-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecEnumeratePackagesA(
    PULONG          PackageCount,
    PSecPkgInfoA *  Packages)
{
    PLIST_ENTRY Scan;
    PDLL_SECURITY_PACKAGE   Package;
    ULONG                   Count;
    ULONG                   StringSize;
    PSecPkgInfoA    Info;
    LPSTR   String;

    Count = 0;

    StringSize = 0;

    *PackageCount = 0 ;

    *Packages = NULL ;

    ReadLockPackageList();

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Package->TypeMask & SECPKG_TYPE_ANSI )
        {
            Count++;

            StringSize += Package->AnsiNameSize +
                          Package->AnsiCommentSize ;

        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }

    Info = (PSecPkgInfoA) LocalAlloc( LMEM_FIXED, Count * sizeof( SecPkgInfoA ) +
                                                    StringSize );

    if ( !Info )
    {
        UnlockPackageList();

        return( FALSE );
    }

    String = (LPSTR) &Info[ Count ];

    Count = 0;

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Package->TypeMask & SECPKG_TYPE_ANSI )
        {
            Info[ Count ].fCapabilities = Package->fCapabilities ;
            Info[ Count ].wVersion = Package->Version ;
            Info[ Count ].wRPCID = Package->RpcId ;
            Info[ Count ].cbMaxToken = Package->TokenSize ;
            Info[ Count ].Name = String ;

            CopyMemory( String,
                        Package->PackageNameA,
                        Package->AnsiNameSize);

            String += Package->AnsiNameSize;

            Info[ Count ].Comment = String ;

            CopyMemory( String,
                        Package->CommentA,
                        Package->AnsiCommentSize);

            String += Package->AnsiCommentSize ;

            Count++;


        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }

    UnlockPackageList();

    *PackageCount = Count ;
    *Packages = Info ;

    return( TRUE );

}
//+---------------------------------------------------------------------------
//
//  Function:   SecEnumeratePackagesW
//
//  Synopsis:   Worker for EnumerateSecurityPackages
//
//  Arguments:  [PackageCount] --
//              [Packages]     --
//
//  History:    8-21-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SecEnumeratePackagesW(
    PULONG  PackageCount,
    PSecPkgInfoW *  Packages)
{
    PLIST_ENTRY Scan;
    PDLL_SECURITY_PACKAGE   Package;
    ULONG                   Count;
    ULONG                   StringSize;
    PSecPkgInfoW    Info;
    PWSTR   String;

    Count = 0;

    StringSize = 0;

    *PackageCount = 0 ;

    *Packages = NULL ;

    ReadLockPackageList();

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Package->TypeMask & SECPKG_TYPE_WIDE )
        {
            Count++;

            StringSize += Package->PackageName.Length + sizeof(WCHAR) +
                          Package->Comment.Length + sizeof(WCHAR) ;

        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }

    Info = (PSecPkgInfoW) LocalAlloc( LMEM_FIXED, Count * sizeof( SecPkgInfoW ) +
                                                    StringSize );

    if ( !Info )
    {
        UnlockPackageList();

        return( FALSE );
    }

    String = (PWSTR) &Info[ Count ];

    Count = 0;

    Scan = SecPackageControlList.Flink;

    while ( Scan != &SecPackageControlList )
    {
        Package = (PDLL_SECURITY_PACKAGE) Scan;

        if ( Package->TypeMask & SECPKG_TYPE_WIDE )
        {
            Info[ Count ].fCapabilities = Package->fCapabilities ;
            Info[ Count ].wVersion = Package->Version ;
            Info[ Count ].wRPCID = Package->RpcId ;
            Info[ Count ].cbMaxToken = Package->TokenSize ;
            Info[ Count ].Name = String ;

            CopyMemory( String,
                        Package->PackageName.Buffer,
                        Package->PackageName.Length );

            String += Package->PackageName.Length / sizeof(WCHAR);

            *String ++ = L'\0';

            Info[ Count ].Comment = String ;

            CopyMemory( String,
                        Package->Comment.Buffer,
                        Package->Comment.Length );

            String += Package->Comment.Length / sizeof(WCHAR) ;

            *String++ = L'\0';

            Count++;


        }

        Scan = Scan->Flink ;

        Package = NULL ;
    }

    UnlockPackageList();

    *PackageCount = Count ;
    *Packages = Info ;

    return( TRUE );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecSetPackageFlag
//
//  Synopsis:   Sets a package flag
//
//  Arguments:  [Package] --
//              [Flag]    --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecSetPackageFlag(
    PDLL_SECURITY_PACKAGE   Package,
    ULONG Flag)
{
    //
    // this optimization relies on the fact that SecClearPackageFlag is unused.
    //

    if( (Package->fState & Flag) == Flag )
    {
        return;
    }

    WriteLockPackageList();

    Package->fState |= Flag ;

    UnlockPackageList();
}


//+---------------------------------------------------------------------------
//
//  Function:   SecClearPackageFlag
//
//  Synopsis:   Clears a package flag
//
//  Arguments:  [Package] --
//              [Flag]    --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SecClearPackageFlag(
    PDLL_SECURITY_PACKAGE Package,
    ULONG Flag)
{
    //
    // SetPackageFlag assumes this function remains un-used.  assert on that.
    //

    ASSERT( TRUE == FALSE );

    WriteLockPackageList();

    Package->fState &= ~(Flag);

    UnlockPackageList();
}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFailedSealFunction
//
//  Synopsis:   Stuck into the seal slot for packages that aren't allowed to
//              seal messages.
//
//  Arguments:  [phContext]    --
//              [fQOP]         --
//              [pMessage]     --
//              [MessageSeqNo] --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SecpFailedSealFunction(
    PCtxtHandle         phContext,
    ULONG               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo)
{
    return( SEC_E_UNSUPPORTED_FUNCTION );

}

//+---------------------------------------------------------------------------
//
//  Function:   SecpFailedUnsealFunction
//
//  Synopsis:   Stuck into the unseal slot for packages that aren't allowed
//              to unseal messages.
//
//  Arguments:  [phHandle]     --
//              [pMessage]     --
//              [MessageSeqNo] --
//              [pfQOP]        --
//
//  History:    9-12-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SecpFailedUnsealFunction(
    PCtxtHandle phHandle,
    PSecBufferDesc pMessage,
    ULONG MessageSeqNo,
    ULONG * pfQOP)
{
    return( SEC_E_UNSUPPORTED_FUNCTION );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsaRegisterCallback
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [CallbackId] --
//              [Callback]   --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    4-25-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
LsaRegisterCallback(
    ULONG   CallbackId,
    PLSA_CALLBACK_FUNCTION Callback
    )
{
    PDLL_LSA_CALLBACK pCallback ;
    PDLL_SECURITY_PACKAGE Package ;

    Package = (PDLL_SECURITY_PACKAGE) GetCurrentPackage();

    if ( !Package )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    pCallback = (PDLL_LSA_CALLBACK) LocalAlloc( LMEM_FIXED,
                        sizeof( DLL_LSA_CALLBACK ) );

    if ( !pCallback )
    {
        return STATUS_NO_MEMORY ;
    }

    pCallback->CallbackId = CallbackId ;
    pCallback->Callback = Callback ;

    WriteLockPackageList();

    InsertTailList( &Package->LsaInfo->Callbacks, &pCallback->List );

    UnlockPackageList();

    return STATUS_SUCCESS ;
}

extern "C"
NTSTATUS
WINAPI
SecCacheSspiPackages(
    VOID
    )
{
    PWSTR * DllNames;
    ULONG   DllCount;
    LARGE_INTEGER CacheTime ;
    LARGE_INTEGER ListTime ;
    LARGE_INTEGER DllTime ;
    LARGE_INTEGER CacheDllTime ;
    DWORD Type ;
    DWORD Size ;
    ULONG   i;
    ULONG   j;
    SECURITY_STATUS Status;
    PDLL_BINDING    Binding;
    WCHAR   DllPath[ MAX_PATH ];
    PWSTR   Path;
    DWORD   PathLen;
    UNICODE_STRING Maybe;
    UNICODE_STRING Allowed;
    PDLL_SECURITY_PACKAGE Package ;
    PLIST_ENTRY Scan ;
    LIST_ENTRY PackageList ;
    ULONG PackageCount ;
    HKEY LsaKey ;
    HKEY hKey ;
    int err ;
    DWORD Disp ;
    BOOL SnapDll ;
    HANDLE hDllFile ;
    DWORD Temp ;
    PVOID BasePointer ;


    err = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT( "System\\CurrentControlSet\\Control\\Lsa\\SspiCache" ),
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_READ | KEY_WRITE,
                NULL,
                &LsaKey,
                &Disp );

    if ( err )
    {
        return NtCurrentTeb()->LastStatusValue ;
    }

    if ( Disp == REG_OPENED_EXISTING_KEY )
    {
        Size = sizeof( CacheTime );

        err = RegQueryValueEx( LsaKey,
                         TIME_NAME,
                         0,
                         &Type,
                         (PUCHAR) &CacheTime,
                         &Size );

        if ( (err) || ( Type != REG_BINARY ) )
        {
            CacheTime.QuadPart = 0 ;
        }

    }
    else
    {
        CacheTime.QuadPart = 0 ;
    }


    Status = SecpReadPackageList(
                &DllCount,
                &DllNames,
                &BasePointer,
                (LPFILETIME) &ListTime );

    if ( NT_ERROR( Status ) )
    {
        RegCloseKey( LsaKey );

        return Status;
    }

    //
    // Caching trick:  If the cache time is greater than the
    // list time (meaning the cache was updated later than
    // the list of security packages), merely check the DLL
    // time stamps.  If the cache is out of date, or the file
    // info is out of date, snap and check the DLL.
    //

    for ( i = 0 ; i < DllCount ; i++ )
    {
        PathLen = SearchPath(NULL,
                        DllNames[i],
                        NULL,
                        MAX_PATH,
                        DllPath,
                        &Path );
        if ( PathLen )
        {
            Binding = (PDLL_BINDING) LocalAlloc( LMEM_FIXED, sizeof( DLL_BINDING ) );

            if ( Binding )
            {

                ZeroMemory( Binding, sizeof( DLL_BINDING ) );

                Binding->Type = SecPkgOld;
                Binding->RefCount = 1;

                Binding->Filename.Buffer = (PWSTR) LocalAlloc( LMEM_FIXED,
                                (PathLen + 1) * sizeof(WCHAR) );

                if ( Binding->Filename.Buffer )
                {
                    Binding->Filename.MaximumLength = (USHORT)((PathLen + 1) * sizeof(WCHAR));
                    Binding->Filename.Length = Binding->Filename.MaximumLength - 2;

                    CopyMemory( Binding->Filename.Buffer,
                                DllPath,
                                Binding->Filename.MaximumLength );

                }

                SnapDll = FALSE ;

                err = RegCreateKeyEx(
                            LsaKey,
                            DllNames[i],
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE | KEY_READ,
                            NULL,
                            &hKey,
                            &Disp );

                if ( err )
                {
                    //
                    // bust out.  Note:  if the path in the registry is not
                    // just a file name, this will fail.  Thus, any absolute
                    // security package path will not be cached.
                    //

                    SecpDerefDll( Binding );

                    continue;
                }


                if ( CacheTime.QuadPart > ListTime.QuadPart )
                {
                    //
                    // Check the time in the cache.
                    //

                    CacheDllTime.QuadPart = 0 ;

                    Size = sizeof( CacheDllTime );

                    err = RegQueryValueEx( hKey,
                                           TIME_NAME,
                                           NULL,
                                           &Type,
                                           (PUCHAR) &CacheDllTime,
                                           &Size );

                    //
                    // If this can't be found (key just created, e.g.)
                    // CacheDllTime will be 0, still less than the file time
                    // on the DLL itself.
                    //

                    hDllFile = CreateFile( Binding->Filename.Buffer,
                                           GENERIC_READ,
                                           FILE_SHARE_READ | FILE_SHARE_DELETE,
                                           NULL,
                                           OPEN_EXISTING,
                                           FILE_ATTRIBUTE_NORMAL,
                                           NULL );

                    if ( hDllFile == INVALID_HANDLE_VALUE )
                    {
                        SecpDerefDll( Binding );

                        continue;
                    }

                    GetFileTime( hDllFile, NULL, NULL, (LPFILETIME) &DllTime );

                    CloseHandle( hDllFile );

                    if ( CacheDllTime.QuadPart < DllTime.QuadPart )
                    {
                        SnapDll = TRUE ;
                    }

                }
                else
                {
                    SnapDll = TRUE ;
                }

                if ( SnapDll )
                {
                    if ( !SecpSnapDll( Binding, &PackageList, &PackageCount ) )
                    {
                        RegCloseKey( hKey );

                        RegDeleteKey( LsaKey,
                                      DllNames[i] );

                        continue;

                    }

                    //
                    // if there's only one package, we're set!
                    //

                    if ( PackageCount == 1 )
                    {
                        //
                        // Update the cache entry:
                        //

                        Scan = RemoveHeadList( &PackageList );

                        Package = CONTAINING_RECORD( Scan, DLL_SECURITY_PACKAGE, List );

                        RegSetValueEx(
                                hKey,
                                NAME_NAME,
                                0,
                                REG_SZ,
                                (PUCHAR) Package->PackageName.Buffer,
                                Package->PackageName.Length + 2 );

                        RegSetValueEx(
                                hKey,
                                COMMENT_NAME,
                                0,
                                REG_SZ,
                                (PUCHAR) Package->Comment.Buffer,
                                Package->Comment.Length + 2 );

                        RegSetValueEx(
                                hKey,
                                CAPABILITIES_NAME,
                                0,
                                REG_DWORD,
                                (PUCHAR) &Package->fCapabilities,
                                sizeof(DWORD) );

                        Temp = (DWORD) Package->RpcId ;

                        RegSetValueEx(
                                hKey,
                                RPCID_NAME,
                                0,
                                REG_DWORD,
                                (PUCHAR) &Temp,
                                sizeof( DWORD ) );

                        Temp = (DWORD) Package->Version ;

                        RegSetValueEx(
                                hKey,
                                VERSION_NAME,
                                0,
                                REG_DWORD,
                                (PUCHAR) &Temp,
                                sizeof( DWORD ) );


                        Temp = (DWORD) Package->TokenSize ;

                        RegSetValueEx(
                                hKey,
                                TOKENSIZE_NAME,
                                0,
                                REG_DWORD,
                                (PUCHAR) &Temp,
                                sizeof( DWORD ) );


                        hDllFile = CreateFile( Binding->Filename.Buffer,
                                                GENERIC_READ,
                                                FILE_SHARE_READ | FILE_SHARE_DELETE,
                                                NULL,
                                                OPEN_EXISTING,
                                                FILE_ATTRIBUTE_NORMAL,
                                                NULL );

                        if ( hDllFile == INVALID_HANDLE_VALUE )
                        {
                            SecpDerefDll( Binding );

                            continue;
                        }

                        GetFileTime( hDllFile, NULL, NULL, (LPFILETIME) &DllTime );

                        CloseHandle( hDllFile );

                        RegSetValueEx( hKey,
                                       TIME_NAME,
                                       0,
                                       REG_BINARY,
                                       (PUCHAR) &DllTime,
                                       sizeof( LARGE_INTEGER ) );

                        Temp = Package->TypeMask ;

                        RegSetValueEx( hKey,
                                       TYPE_NAME,
                                       0,
                                       REG_DWORD,
                                       (PUCHAR) &Temp,
                                       sizeof( DWORD ) );

                        SecpDeletePackage( Package );

                        RegCloseKey( hKey );

                        GetSystemTimeAsFileTime( (LPFILETIME) &CacheTime );

                        RegSetValueEx( LsaKey,
                                       TIME_NAME,
                                       0,
                                       REG_BINARY,
                                       (PUCHAR) &CacheTime,
                                       sizeof( CacheTime ) );
                    }

                    while ( !IsListEmpty( &PackageList ) )
                    {
                        Scan = RemoveHeadList( &PackageList );

                        Package = CONTAINING_RECORD( Scan, DLL_SECURITY_PACKAGE, List );

                        SecpDeletePackage( Package );
                    }


                }

                // SecpDerefDll( Binding );

            }
        }
    }

    RegCloseKey( LsaKey );

    LocalFree( BasePointer );
    LocalFree( DllNames );

    return STATUS_SUCCESS ;
}

VOID
SecpLoadSaslProfiles(
    VOID
    )
{
    HKEY Key ;
    int err ;
    PWSTR EnumBuf;
    PWSTR ValueBuf ;
    DWORD index ;
    DWORD Type ;
    DWORD Size ;
    DWORD NameSize;
    PDLL_SECURITY_PACKAGE Package ;
    SASL_PROFILE * Profile ;
    UNICODE_STRING PackageName ;


    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SaslProfiles"),
                0,
                KEY_READ,
                &Key );

    if ( err == 0 )
    {

        EnumBuf = (PWSTR) RtlAllocateHeap( RtlProcessHeap(), 0, MAX_PATH * 2 * sizeof( WCHAR ));

        if ( EnumBuf )
        {
            ValueBuf = EnumBuf + MAX_PATH ;

            index = 0 ;

            do
            {
                NameSize = MAX_PATH ;
                Size = MAX_PATH * sizeof(WCHAR) ;

                err = RegEnumValue(
                            Key,
                            index,
                            EnumBuf,
                            &NameSize,
                            NULL,
                            &Type,
                            (PBYTE) ValueBuf,
                            &Size );

                if ( err == 0 )
                {
                    if ( Type == REG_SZ )
                    {
                        RtlInitUnicodeString( &PackageName, ValueBuf );

                        Package = SecpScanPackageList(
                                        SECPKG_TYPE_ANY,
                                        &PackageName,
                                        0 );

                        if ( Package )
                        {
                            //
                            // We found a package for the profile
                            // listed.  Create a SASL profile and
                            // link the two:
                            //

                            Size = (wcslen( EnumBuf ) + 1 ) * sizeof(WCHAR);

                            Profile = (PSASL_PROFILE) LocalAlloc( 0, sizeof( SASL_PROFILE ) + Size );

                            if ( Profile )
                            {
                                Profile->Package = Package ;
                                Profile->ProfileName.Buffer = (PWSTR) (Profile + 1);
                                Profile->ProfileName.MaximumLength = (USHORT) Size ;
                                Profile->ProfileName.Length = (USHORT) (Size - sizeof(WCHAR) );
                                RtlCopyMemory(
                                    Profile->ProfileName.Buffer,
                                    EnumBuf,
                                    Size );
                                InsertTailList( &SecSaslProfileList, &Profile->List );
                                Package->fState |= DLL_SECPKG_SASL_PROFILE ;

                                SecSaslProfileCount++ ;
                            }
                        }

                    }
                }

                index++ ;

            } while ( err == 0 );

            RtlFreeHeap( RtlProcessHeap(), 0, EnumBuf );

        }

        RegCloseKey( Key );
    }
}

SECURITY_STATUS
SecEnumerateSaslProfilesA(
    OUT LPSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{
    PLIST_ENTRY Scan ;
    PSASL_PROFILE Profile ;
    ULONG Size ;
    LPSTR Base ;
    LPSTR Current ;
    STRING String ;

    *ProfileCount = SecSaslProfileCount ;

    ReadLockPackageList();

    Scan = SecSaslProfileList.Flink ;
    Size = 0 ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        Size += (ULONG)RtlUnicodeStringToAnsiSize( &Profile->ProfileName ) + 1;

        Scan = Scan->Flink ;

    }

    Size ++ ;

    Base = (LPSTR) LocalAlloc( LMEM_FIXED, Size );

    if ( !Base )
    {
        UnlockPackageList();

        return SEC_E_INSUFFICIENT_MEMORY ;

    }

    Current = Base ;

    Scan = SecSaslProfileList.Flink ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        String.Buffer = Current ;
        String.MaximumLength = min((USHORT) Size, MAXSHORT) ;
        String.Length = 0 ;

        RtlUnicodeStringToAnsiString(
            &String,
            &Profile->ProfileName,
            FALSE );

        Scan = Scan->Flink ;

        Size -= String.Length + 1;

        Current += String.Length ;

        *Current++ = '\0';

    }

    *Current++ = '\0' ;

    UnlockPackageList();

    *ProfileList = Base ;

    return STATUS_SUCCESS ;

}


SECURITY_STATUS
SecEnumerateSaslProfilesW(
    OUT LPWSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{
    PLIST_ENTRY Scan ;
    PSASL_PROFILE Profile ;
    ULONG Size ;
    LPWSTR Base ;
    LPWSTR Current ;

    *ProfileCount = SecSaslProfileCount ;

    ReadLockPackageList();

    Scan = SecSaslProfileList.Flink ;
    Size = 0 ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        Size += Profile->ProfileName.Length + 2 ;

        Scan = Scan->Flink ;

    }

    Size += sizeof(WCHAR) ;

    Base = (LPWSTR) LocalAlloc( LMEM_FIXED, Size );

    if ( !Base )
    {
        UnlockPackageList();

        return SEC_E_INSUFFICIENT_MEMORY ;

    }

    Current = Base ;

    Scan = SecSaslProfileList.Flink ;

    while ( Scan != &SecSaslProfileList )
    {
        Profile = CONTAINING_RECORD( Scan, SASL_PROFILE, List );

        CopyMemory(
            Current,
            Profile->ProfileName.Buffer,
            Profile->ProfileName.Length );

        Scan = Scan->Flink ;

        Current += Profile->ProfileName.Length / sizeof(WCHAR) ;

        *Current++ = L'\0';

    }

    *Current++ = L'\0' ;

    UnlockPackageList();

    *ProfileList = Base ;

    return STATUS_SUCCESS ;
}

SECURITY_STATUS
SecCopyPackageInfoToUserW(
    PDLL_SECURITY_PACKAGE  Package,
    PSecPkgInfoW SEC_FAR * pPackageInfo
    )
{
    SECURITY_STATUS scRet ;
    PSecPkgInfoW pInfo ;
    ULONG Size ;
    PWSTR String ;

    if ( Package )
    {
        Size = sizeof( SecPkgInfoW ) +
                    Package->PackageName.Length + sizeof(WCHAR) +
                          Package->Comment.Length + sizeof(WCHAR) ;

        pInfo = (PSecPkgInfoW) SecClientAllocate( Size );

        if ( pInfo )
        {
            String = (PWSTR) (pInfo + 1) ;


            pInfo->fCapabilities = Package->fCapabilities ;
            pInfo->wVersion = Package->Version ;
            pInfo->wRPCID = Package->RpcId ;
            pInfo->cbMaxToken = Package->TokenSize ;
            pInfo->Name = String ;

            CopyMemory( String,
                        Package->PackageName.Buffer,
                        Package->PackageName.Length );

            String += Package->PackageName.Length / sizeof(WCHAR);

            *String ++ = L'\0';

            pInfo->Comment = String ;

            CopyMemory( String,
                        Package->Comment.Buffer,
                        Package->Comment.Length );

            String += Package->Comment.Length / sizeof(WCHAR) ;

            *String++ = L'\0';

            scRet = SEC_E_OK ;
        }
        else
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
        }

        *pPackageInfo = pInfo ;

    }
    else
    {
        scRet = SEC_E_SECPKG_NOT_FOUND ;
    }

    return(scRet);

}

SECURITY_STATUS
SecCopyPackageInfoToUserA(
    PDLL_SECURITY_PACKAGE Package,
    PSecPkgInfoA * pPackageInfo
    )
{
    SECURITY_STATUS scRet;
    PSecPkgInfoA pInfo ;
    ULONG Size ;
    PSTR String ;

    if ( Package )
    {
        Size = sizeof( SecPkgInfo ) +
                          Package->AnsiNameSize +
                          Package->AnsiCommentSize ;

        pInfo = (PSecPkgInfoA) SecClientAllocate( Size );

        if ( pInfo )
        {
            String = (PSTR) (pInfo + 1) ;


            pInfo->fCapabilities = Package->fCapabilities ;
            pInfo->wVersion = Package->Version ;
            pInfo->wRPCID = Package->RpcId ;
            pInfo->cbMaxToken = Package->TokenSize ;
            pInfo->Name = String ;

            CopyMemory( String,
                        Package->PackageNameA,
                        Package->AnsiNameSize);

            String += Package->AnsiNameSize;

            pInfo->Comment = String ;

            CopyMemory( String,
                        Package->CommentA,
                        Package->AnsiCommentSize);

            scRet = SEC_E_OK ;
        }
        else
        {
            scRet = SEC_E_INSUFFICIENT_MEMORY ;
        }

        *pPackageInfo = pInfo ;

    }
    else
    {
        scRet = SEC_E_SECPKG_NOT_FOUND ;
    }

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\sasl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       newstubs.cxx
//
//  Contents:   Stubs from ntlmssp
//
//  History:    9-06-96   RichardW   Stolen from ntlmssp
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <kerberos.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include <ntlsa.h>
#include "secdll.h"
}

CRITICAL_SECTION SaslLock ;
LIST_ENTRY SaslContextList ;
PNEGOTIATE_PACKAGE_PREFIXES SaslPrefixes ;
PNEGOTIATE_PACKAGE_PREFIX SaslPrefixList ;

typedef enum _SASL_STATE {
    SaslGss,                // Passthrough to packages
    SaslPause,              // Client-side: wait for cookie from server
                            // Server-side: wait for empty response from client
    SaslCookie,             // Server-side: issued cookie to client
    SaslComplete            // Done
} SASL_STATE ;

#define SASL_NO_SECURITY    0x01
#define SASL_INTEGRITY      0x02
#define SASL_PRIVACY        0x04

#define CLIENT_INTEGRITY    ( ISC_RET_REPLAY_DETECT | \
                              ISC_RET_SEQUENCE_DETECT | \
                              ISC_RET_INTEGRITY )

#define CLIENT_REQ_INTEGRITY (ISC_REQ_REPLAY_DETECT | \
                              ISC_REQ_SEQUENCE_DETECT | \
                              ISC_REQ_INTEGRITY )

#define SERVER_INTEGRITY    ( ASC_RET_REPLAY_DETECT | \
                              ASC_RET_SEQUENCE_DETECT | \
                              ASC_RET_INTEGRITY )

#define SERVER_REQ_INTEGRITY (ASC_REQ_REPLAY_DETECT | \
                              ASC_REQ_SEQUENCE_DETECT | \
                              ASC_REQ_INTEGRITY )


typedef struct _SASL_CONTEXT {

    LIST_ENTRY  List ;              // List control
    CtxtHandle  ContextHandle ;     // Context handle from real package
    TimeStamp   Expiry ;            // Context Expiration
    SASL_STATE  State ;             // Current SASL state
    DWORD       ContextReq ;        // Context Request from caller
    DWORD       ContextAttr ;       // Context Attributes available
    DWORD       SendBufferSize ;    // Max Buffer Size
    DWORD       RecvBufferSize ;    // "
    PUCHAR      AuthzString ;       // Authorization string
    DWORD       AuthzStringLength ; // Length

} SASL_CONTEXT, * PSASL_CONTEXT ;

ULONG SaslGlobalSendSize = 16384 ;  // Allow defaults to be set process wide
ULONG SaslGlobalRecvSize = 16384 ;



PSecBuffer
SaslLocateBuffer(
    PSecBufferDesc  Desc,
    ULONG           Type
    )
{
    ULONG i ;

    for ( i = 0 ; i < Desc->cBuffers ; i++ )
    {
        if ( (Desc->pBuffers[i].BufferType & ~(SECBUFFER_ATTRMASK)) == Type )
        {
            return &Desc->pBuffers[i] ;
        }
    }

    return NULL ;
}


PSASL_CONTEXT
SaslCreateContext(
    PCtxtHandle ContextHandle
    )
{
    PSASL_CONTEXT Context ;

    Context = (PSASL_CONTEXT) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof( SASL_CONTEXT ) );

    if ( Context )
    {
        Context->ContextHandle = *ContextHandle ;
        Context->State = SaslGss ;
        Context->RecvBufferSize = SaslGlobalRecvSize ;
        Context->SendBufferSize = SaslGlobalSendSize ;

        RtlEnterCriticalSection( &SaslLock );

        InsertHeadList( &SaslContextList, &Context->List );

        RtlLeaveCriticalSection( &SaslLock );
    }

    return Context ;
}

PSASL_CONTEXT
SaslFindContext(
    PCtxtHandle ContextHandle,
    BOOL Remove
    )
{
    PLIST_ENTRY Scan ;
    PSASL_CONTEXT Context = NULL ;

    RtlEnterCriticalSection( &SaslLock );

    Scan = SaslContextList.Flink ;

    while ( Scan != &SaslContextList )
    {
        Context = CONTAINING_RECORD( Scan, SASL_CONTEXT, List );

        if ( (Context->ContextHandle.dwUpper == ContextHandle->dwUpper) &&
             (Context->ContextHandle.dwLower == ContextHandle->dwLower ) )
        {
            break;
        }

        Context = NULL ;

        Scan = Scan->Flink ;
    }

    if ( Remove && ( Context != NULL ) )
    {
        RemoveEntryList( &Context->List );

        Context->List.Flink = NULL ;
        Context->List.Blink = NULL ;
    }

    RtlLeaveCriticalSection( &SaslLock );

    return Context ;
}

VOID
SaslDeleteContext(
    PSASL_CONTEXT Context
    )
{
    if ( Context->List.Flink )
    {
        RtlEnterCriticalSection( &SaslLock );

        RemoveEntryList( &Context->List );

        RtlLeaveCriticalSection( &SaslLock );
    }

    if ( Context->AuthzString )
    {
        LocalFree( Context->AuthzString );
    }

    LocalFree( Context );

}

SECURITY_STATUS
SaslGetContextOption(
    PCtxtHandle ContextHandle,
    ULONG Option,
    PVOID Value,
    ULONG Size,
    PULONG Needed OPTIONAL
    )
{
    PSASL_CONTEXT Context ;
    PULONG Data ;
    ULONG DataSize ;
    SECURITY_STATUS Status = STATUS_SUCCESS ;

    Context = SaslFindContext( ContextHandle, FALSE );

    if ( Context == NULL )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    switch ( Option )
    {
        case SASL_OPTION_SEND_SIZE:
            if ( Size < sizeof( ULONG ) )
            {
                Status = SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                *Data = Context->SendBufferSize ;
            }
            DataSize = sizeof( ULONG ) ;
            break;

        case SASL_OPTION_RECV_SIZE:
            if ( Size < sizeof( ULONG ) )
            {
                Status =  SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                *Data = Context->RecvBufferSize ;
            }
            DataSize = sizeof( ULONG ) ;
            break;

        case SASL_OPTION_AUTHZ_STRING:
            if ( Size < Context->AuthzStringLength )
            {
                Status = SEC_E_BUFFER_TOO_SMALL ;

            }
            else 
            {
                RtlCopyMemory(
                    Value,
                    Context->AuthzString,
                    Context->AuthzStringLength );

            }
            DataSize = Context->AuthzStringLength ;
            break;

        default:
            DataSize = 0 ;
            Status = SEC_E_UNSUPPORTED_FUNCTION ;

    }

    if ( Needed )
    {
        *Needed = DataSize ;
    }

    return Status ;
}

SECURITY_STATUS
SaslSetContextOption(
    PCtxtHandle ContextHandle,
    ULONG Option,
    PVOID Value,
    ULONG Size
    )
{
    PSASL_CONTEXT Context ;
    PULONG Data ;
    SECURITY_STATUS Status = STATUS_SUCCESS ;

    Context = SaslFindContext( ContextHandle, FALSE );

    if ( ( Context == NULL ) &&
         ( ( Option != SASL_OPTION_RECV_SIZE ) &&
           ( Option != SASL_OPTION_SEND_SIZE ) ) )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    switch ( Option )
    {
        case SASL_OPTION_SEND_SIZE:
            if ( Size < sizeof( ULONG ) )
            {
                Status = SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                if ( Context )
                {
                    Context->SendBufferSize = *Data ;
                }
                else
                {
                    SaslGlobalSendSize = *Data ;
                }
            }
            break;

        case SASL_OPTION_RECV_SIZE:
            if ( Size < sizeof( ULONG ) )
            {
                Status =  SEC_E_BUFFER_TOO_SMALL ;
            }
            else 
            {
                Data = (PULONG) Value ;
                if ( Context )
                {
                    Context->RecvBufferSize = *Data ;
                }
                else 
                {
                    SaslGlobalRecvSize = *Data ;
                }
            }
            break;

        case SASL_OPTION_AUTHZ_STRING:

            Context->AuthzString = (PUCHAR) LocalAlloc( LMEM_FIXED, Size );

            if ( Context->AuthzString )
            {
                Context->AuthzStringLength = Size ;
                RtlCopyMemory(
                        Context->AuthzString,
                        Value,
                        Size );

            }
            else 
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;

            }
            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;

    }

    return Status ;
}



SECURITY_STATUS
SaslBuildCookie(
    PSecBufferDesc  Output,
    PSASL_CONTEXT   Context,
    UCHAR           SaslFlags
    )
{
    SECURITY_STATUS Status ;
    SecBuffer   WrapBuffer[ 3 ];
    SecBufferDesc   Wrap ;
    SecPkgContext_Sizes Sizes ;
    UCHAR lBuffer[ 128 ];
    PUCHAR Buffer ;
    ULONG TotalSize ;
    PUCHAR SaslMessage ;
    PUCHAR OutputMessage = NULL ;
    PSecBuffer OutputBuffer ;

    Status = QueryContextAttributesW(
                &Context->ContextHandle,
                SECPKG_ATTR_SIZES,
                &Sizes );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    //
    // The total size of the message is trailer + block size +
    // SASL component, which is spec'd to be 4 bytes + any authz string
    //

    TotalSize = Sizes.cbBlockSize + Sizes.cbSecurityTrailer + 
                    4 + Context->AuthzStringLength;

    if ( TotalSize < sizeof( lBuffer ) )
    {
        Buffer = lBuffer ;
    }
    else
    {
        Buffer = (PUCHAR) LocalAlloc( LMEM_FIXED, TotalSize );
    }

    if ( !Buffer )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    //
    // Construct the message:
    //

    Wrap.cBuffers = 3 ;
    Wrap.pBuffers = WrapBuffer ;
    Wrap.ulVersion = SECBUFFER_VERSION ;

    WrapBuffer[ 0 ].BufferType = SECBUFFER_TOKEN ;
    WrapBuffer[ 0 ].cbBuffer = Sizes.cbSecurityTrailer ;
    WrapBuffer[ 0 ].pvBuffer = Buffer ;

    WrapBuffer[ 1 ].BufferType = SECBUFFER_DATA ;
    WrapBuffer[ 1 ].cbBuffer = 4 + Context->AuthzStringLength ;
    WrapBuffer[ 1 ].pvBuffer = Buffer + Sizes.cbSecurityTrailer ;

    WrapBuffer[ 2 ].BufferType = SECBUFFER_PADDING ;
    WrapBuffer[ 2 ].cbBuffer = Sizes.cbBlockSize ;
    WrapBuffer[ 2 ].pvBuffer = Buffer + (Sizes.cbSecurityTrailer + 
                                         4 + Context->AuthzStringLength);

    //
    // Fill in our portion:
    //

    SaslMessage = (PUCHAR) WrapBuffer[ 1 ].pvBuffer ;


    //
    // Next three bytes are network byte order for the max
    // receive buffer supported by the server:
    //

    SaslMessage[ 0 ] = SaslFlags ;
    SaslMessage[ 1 ] = (UCHAR) ((Context->RecvBufferSize >> 16) & 0xFF) ;
    SaslMessage[ 2 ] = (UCHAR) ((Context->RecvBufferSize >> 8 ) & 0xFF) ;
    SaslMessage[ 3 ] = (UCHAR) ((Context->RecvBufferSize      ) & 0xFF) ;

    if ( Context->AuthzStringLength )
    {
        RtlCopyMemory( SaslMessage + 4,
                       Context->AuthzString,
                       Context->AuthzStringLength );
    }

    //
    // Wrap up the message:
    //

    Status = EncryptMessage(
                &Context->ContextHandle,
                KERB_WRAP_NO_ENCRYPT,
                &Wrap,
                0 );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // Now copy the cookie back out to the caller:
        //

        OutputBuffer = SaslLocateBuffer(
                            Output,
                            SECBUFFER_TOKEN );

        if ( OutputBuffer )
        {
            if ( Context->ContextReq & ASC_REQ_ALLOCATE_MEMORY )
            {
                //
                // Allocate our own memory:
                //

                OutputMessage = (PUCHAR) SecpFTable.AllocateHeap( TotalSize );
                if ( OutputMessage )
                {
                    OutputBuffer->pvBuffer = OutputMessage ;
                }
                else
                {
                    Status = SEC_E_INSUFFICIENT_MEMORY ;
                }

            }
            else
            {
                OutputMessage = (PUCHAR) OutputBuffer->pvBuffer ;
                if ( OutputBuffer->cbBuffer < TotalSize )
                {
                    Status = SEC_E_INSUFFICIENT_MEMORY ;
                }
            }
        }
        else 
        {
            Status = SEC_E_INVALID_TOKEN ;
        }


        if ( NT_SUCCESS( Status ) )
        {
            RtlCopyMemory(
                OutputMessage,
                WrapBuffer[0].pvBuffer,
                WrapBuffer[0].cbBuffer );

            OutputMessage += WrapBuffer[0].cbBuffer ;

            RtlCopyMemory(
                OutputMessage,
                WrapBuffer[1].pvBuffer,
                WrapBuffer[1].cbBuffer );

            OutputMessage += WrapBuffer[1].cbBuffer ;

            RtlCopyMemory(
                OutputMessage,
                WrapBuffer[2].pvBuffer,
                WrapBuffer[2].cbBuffer );

            OutputBuffer->cbBuffer = WrapBuffer[ 0 ].cbBuffer +
                                     WrapBuffer[ 1 ].cbBuffer +
                                     WrapBuffer[ 2 ].cbBuffer ;

        }



    }

    if ( Buffer != lBuffer )
    {
        LocalFree( Buffer );
    }

    return Status ;


}

SECURITY_STATUS
SaslBuildServerCookie(
    PSecBufferDesc  Output,
    PSASL_CONTEXT Context
    )
{
    UCHAR SaslMessage ;

    SaslMessage = SASL_NO_SECURITY ;

    if ( Context->ContextAttr & SERVER_INTEGRITY )
    {
        SaslMessage |= SASL_INTEGRITY ;
    }

    if ( Context->ContextAttr & ASC_RET_CONFIDENTIALITY )
    {
        SaslMessage |= SASL_PRIVACY ;
    }


    return SaslBuildCookie( Output,
                            Context,
                            SaslMessage );

}

SECURITY_STATUS
SaslCrackCookie(
    PSecBufferDesc Input,
    PSASL_CONTEXT Context,
    PUCHAR SaslFlags
    )
{
    SECURITY_STATUS Status ;
    SecBufferDesc   Unwrap ;
    SecBuffer       UnwrapBuffer[ 2 ];
    PSecBuffer      InToken ;
    ULONG           QoP ;
    PUCHAR          SaslMessage ;

    InToken = SaslLocateBuffer(
                    Input,
                    SECBUFFER_TOKEN );

    if ( !InToken )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    Unwrap.cBuffers = 2 ;
    Unwrap.pBuffers = UnwrapBuffer ;
    Unwrap.ulVersion = SECBUFFER_VERSION ;

    UnwrapBuffer[ 0 ].BufferType = SECBUFFER_STREAM ;
    UnwrapBuffer[ 0 ].cbBuffer = InToken->cbBuffer ;
    UnwrapBuffer[ 0 ].pvBuffer = InToken->pvBuffer ;

    UnwrapBuffer[ 1 ].BufferType = SECBUFFER_DATA ;
    UnwrapBuffer[ 1 ].cbBuffer = 0 ;
    UnwrapBuffer[ 1 ].pvBuffer = NULL ;

    Status = DecryptMessage(
                &Context->ContextHandle,
                &Unwrap,
                0,
                &QoP );

    if ( !NT_SUCCESS( Status ) )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    SaslMessage = (PUCHAR) UnwrapBuffer[ 1 ].pvBuffer ;

    //
    // Ok, now that we have the server's capabilities,
    // match against what we wanted:
    //


    *SaslFlags = SaslMessage[ 0 ] ;

    Context->SendBufferSize = (SaslMessage[3]      ) +
                              (SaslMessage[2] << 8 ) +
                              (SaslMessage[1] << 16) ;

    if ( UnwrapBuffer[ 1 ].cbBuffer > 4 )
    {
        Context->AuthzStringLength = UnwrapBuffer[ 1 ].cbBuffer - 4 ;
        Context->AuthzString = (PUCHAR) LocalAlloc( 
                                    LMEM_FIXED,
                                    Context->AuthzStringLength );

        if ( Context->AuthzString )
        {
            RtlCopyMemory(
                Context->AuthzString,
                SaslMessage + 4,
                Context->AuthzStringLength );
        }

    }

    return SEC_E_OK ;

}

SECURITY_STATUS
SaslCrackServerCookie(
    PSecBufferDesc  Input,
    PSecBufferDesc  Output,
    PSASL_CONTEXT   Context
    )
{
    UCHAR SaslFlags ;
    UCHAR ResponseSaslFlags ;
    SECURITY_STATUS Status ;
    ULONG           Attributes ;

    Status = SaslCrackCookie(
                    Input,
                    Context,
                    &SaslFlags );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Attributes = 0 ;
    ResponseSaslFlags = 0 ;

    if ( SaslFlags & SASL_INTEGRITY )
    {
        //
        // Server can do integrity, can we, and did we want to
        // in the first place?
        //

        if ( ( Context->ContextAttr & CLIENT_INTEGRITY ) &&
             ( Context->ContextReq & CLIENT_REQ_INTEGRITY ) )
        {
            Attributes |= (Context->ContextAttr & CLIENT_INTEGRITY) ;
            ResponseSaslFlags |= SASL_INTEGRITY ;

        }

    }


    if ( SaslFlags & SASL_PRIVACY )
    {
        //
        // Server can do privacy, can we, and did we want to?
        //

        if ( ( Context->ContextAttr & ISC_RET_CONFIDENTIALITY ) &&
             ( Context->ContextReq & ISC_REQ_CONFIDENTIALITY ) )
        {
            Attributes |= ISC_RET_CONFIDENTIALITY ;
            ResponseSaslFlags |= SASL_PRIVACY ;

        }
    }

    if ( ResponseSaslFlags == 0 )
    {
        ResponseSaslFlags |= SASL_NO_SECURITY ;
    }

    //
    // Ok, now, mask out the original bits, and turn on only the ones
    // we have in common for the server:
    //

    Context->ContextAttr &= ~(CLIENT_INTEGRITY | ISC_RET_CONFIDENTIALITY);

    Context->ContextAttr |= Attributes ;
    //
    // Now, build the reply cookie to the server
    //

    return SaslBuildCookie(
                Output,
                Context,
                ResponseSaslFlags );

}

SECURITY_STATUS
SaslCrackClientCookie(
    PSecBufferDesc  Input,
    PSASL_CONTEXT   Context
    )
{
    SECURITY_STATUS Status ;
    UCHAR SaslFlags ;
    ULONG Attributes ;

    Status = SaslCrackCookie(
                    Input,
                    Context,
                    &SaslFlags );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Attributes = 0 ;

    if ( SaslFlags & SASL_INTEGRITY )
    {
        //
        // Server can do integrity, can we, and did we want to
        // in the first place?
        //

        if ( ( Context->ContextAttr & SERVER_INTEGRITY ) &&
             ( Context->ContextReq & SERVER_REQ_INTEGRITY ) )
        {
            Attributes |= (Context->ContextAttr & SERVER_INTEGRITY) ;

        }

    }


    if ( SaslFlags & SASL_PRIVACY )
    {
        //
        // Server can do privacy, can we, and did we want to?
        //

        if ( ( Context->ContextAttr & ASC_RET_CONFIDENTIALITY ) &&
             ( Context->ContextReq & ASC_REQ_CONFIDENTIALITY ) )
        {
            Attributes |= ASC_RET_CONFIDENTIALITY ;

        }
    }

    //
    // Ok, now, mask out the original bits, and turn on only the ones
    // we have in common for the server:
    //

    Context->ContextAttr &= ~(SERVER_INTEGRITY | ISC_RET_CONFIDENTIALITY);

    Context->ContextAttr |= Attributes ;

    return SEC_E_OK ;
}


VOID
SaslDeleteSecurityContext(
    PCtxtHandle phContext
    )
{
    PSASL_CONTEXT Context ;

    Context = SaslFindContext( phContext, TRUE );

    if ( Context )
    {
        SaslDeleteContext( Context );
    }

}



SECURITY_STATUS
SaslEnumerateProfilesA(
    OUT LPSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{

    return SecEnumerateSaslProfilesA( ProfileList, ProfileCount );
}

SECURITY_STATUS
SaslEnumerateProfilesW(
    OUT LPWSTR * ProfileList,
    OUT ULONG * ProfileCount
    )
{
    return SecEnumerateSaslProfilesW( ProfileList, ProfileCount );

}

SECURITY_STATUS
SaslGetProfilePackageA(
    IN LPSTR ProfileName,
    OUT PSecPkgInfoA * PackageInfo
    )
{
    PSASL_PROFILE Profile ;

    Profile = SecLocateSaslProfileA( ProfileName );

    if ( Profile )
    {
        return SecCopyPackageInfoToUserA( Profile->Package, PackageInfo );
    }
    return SEC_E_SECPKG_NOT_FOUND ;

}

SECURITY_STATUS
SaslGetProfilePackageW(
    IN LPWSTR ProfileName,
    OUT PSecPkgInfoW * PackageInfo
    )
{
    PSASL_PROFILE Profile ;

    Profile = SecLocateSaslProfileW( ProfileName );

    if ( Profile )
    {
        return SecCopyPackageInfoToUserW( Profile->Package, PackageInfo );
    }

    return SEC_E_SECPKG_NOT_FOUND ;

}



//+---------------------------------------------------------------------------
//
//  Function:   SaslInitializeSecurityContextW
//
//  Synopsis:   SaslInitializeSecurityContext stub
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pszTargetName] --
//              [fContextReq]   --
//              [Reserved1]     --
//              [Reserved]      --
//              [TargetDataRep] --
//              [pInput]        --
//              [Reserved2]     --
//              [Reserved]      --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    12-2-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SaslInitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPWSTR                      pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS Status ;
    PSASL_CONTEXT Context = NULL ;

    if ( ( phContext != NULL ) &&
         ( phContext->dwLower != 0 ) )
    {
        Context = SaslFindContext( phContext, FALSE );

        if ( !Context )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        if ( Context->State == SaslPause )
        {
            //
            // If we're at the Pause state, that means we're waiting for a
            // GSS_wrap'd cookie from the server.
            //

            Status = SaslCrackServerCookie(
                        pInput,
                        pOutput,
                        Context );

            if ( NT_SUCCESS( Status ) )
            {
                *pfContextAttr = Context->ContextAttr ;

                *ptsExpiry = Context->Expiry ;

                return Status ;
            }
        }
    }

    Status = InitializeSecurityContextW(
                phCredential,
                phContext,
                pszTargetName,
                fContextReq |
                    ISC_REQ_CONFIDENTIALITY | ISC_REQ_INTEGRITY,
                Reserved1,
                TargetDataRep,
                pInput,
                Reserved2,
                phNewContext,
                pOutput,
                pfContextAttr,
                ptsExpiry );

    if ( NT_SUCCESS( Status ) )
    {
        if ( !Context )
        {
            Context = SaslCreateContext( phNewContext );

            if ( Context )
            {
                Context->ContextReq = fContextReq ;
            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;

                DeleteSecurityContext( phNewContext );
            }

        }
        else
        {
            Context->ContextHandle = *phNewContext ;
        }

        if ( Status == SEC_E_OK )
        {
            Context->State = SaslPause ;

            Context->ContextAttr = *pfContextAttr ;

            Context->Expiry = *ptsExpiry ;

            Status = SEC_I_CONTINUE_NEEDED ;

        }
    }
    else
    {
        if ( Context )
        {
            SaslDeleteContext( Context );
        }
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaslInitializeSecurityContextA
//
//  Synopsis:   ANSI stub
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SaslInitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    LPSTR                       pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS Status ;
    PSASL_CONTEXT Context = NULL ;

    if ( ( phContext != NULL ) &&
         ( phContext->dwLower != 0 ) )
    {
        Context = SaslFindContext( phContext, FALSE );

        if ( !Context )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        if ( Context->State == SaslPause )
        {
            //
            // If we're at the Pause state, that means we're waiting for a
            // GSS_wrap'd cookie from the server.
            //

            Status = SaslCrackServerCookie(
                        pInput,
                        pOutput,
                        Context );

            if ( NT_SUCCESS( Status ) )
            {
                *pfContextAttr = Context->ContextAttr ;

                *ptsExpiry = Context->Expiry ;

                return Status ;
            }
        }
    }

    Status = InitializeSecurityContextA(
                phCredential,
                phContext,
                pszTargetName,
                fContextReq |
                    ISC_REQ_CONFIDENTIALITY | ISC_REQ_INTEGRITY,
                Reserved1,
                TargetDataRep,
                pInput,
                Reserved2,
                phNewContext,
                pOutput,
                pfContextAttr,
                ptsExpiry );

    if ( NT_SUCCESS( Status ) )
    {
        if ( !Context )
        {
            Context = SaslCreateContext( phNewContext );

            if ( Context )
            {
                Context->ContextReq = fContextReq ;
            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;

                DeleteSecurityContext( phNewContext );
            }

        }
        else
        {
            Context->ContextHandle = *phNewContext ;
        }

        if ( Status == SEC_E_OK )
        {
            Context->State = SaslPause ;

            Context->ContextAttr = *pfContextAttr ;

            Context->Expiry = *ptsExpiry ;

            Status = SEC_I_CONTINUE_NEEDED ;

        }
    }
    else
    {
        if ( Context )
        {
            SaslDeleteContext( Context );
        }
    }

    return Status ;

}



//+---------------------------------------------------------------------------
//
//  Function:   SaslAcceptSecurityContext
//
//  Synopsis:   SaslAcceptSecurityContext stub
//
//  Arguments:  [phCredential]  --
//              [phContext]     --
//              [pInput]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [phNewContext]  --
//              [pOutput]       --
//              [pfContextAttr] --
//
//  History:    12-2-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SaslAcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS Status ;
    PSASL_CONTEXT Context = NULL ;
    PSecBuffer Blob ;

    if ( ( phContext != NULL ) &&
         ( phContext->dwLower != 0 ) )
    {
        Context = SaslFindContext( phContext, FALSE );

        if ( !Context )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        if ( Context->State == SaslPause )
        {
            //
            //  Generate the cookie for the client:
            //

            Status = SaslBuildServerCookie( pOutput, Context );

            if ( NT_SUCCESS( Status ) )
            {
                Context->State = SaslCookie ;

                return SEC_I_CONTINUE_NEEDED ;
            }

            return Status ;

        }

        if ( Context->State == SaslCookie )
        {
            //
            // This should be the response from the client:
            //

            Status = SaslCrackClientCookie(
                        pInput,
                        Context );

            *pfContextAttr = Context->ContextAttr ;
            *ptsExpiry = Context->Expiry ;

            return Status ;
        }
    }

    Status = AcceptSecurityContext(
                phCredential,
                phContext,
                pInput,
                fContextReq |
                    ASC_REQ_CONFIDENTIALITY |
                    ASC_REQ_INTEGRITY,
                TargetDataRep,
                phNewContext,
                pOutput,
                pfContextAttr,
                ptsExpiry );

    if ( NT_SUCCESS( Status ) )
    {
        if ( !Context )
        {
            Context = SaslCreateContext( phNewContext );

            if ( Context )
            {
                Context->ContextReq = fContextReq ;
            }
            else
            {
                DeleteSecurityContext( phNewContext );

                Status = SEC_E_INSUFFICIENT_MEMORY ;
            }

        }
        else
        {
            Context->ContextHandle = *phNewContext ;
        }

        if ( Status == SEC_E_OK )
        {
            Context->ContextAttr = *pfContextAttr ;
            Context->Expiry = *ptsExpiry ;

            Status = SEC_I_CONTINUE_NEEDED ;

            //
            // if there is no output token, then we launch into the make-the-
            // cookie path.  Otherwise, we need to pause for a round trip.
            //

            Blob = SaslLocateBuffer( pOutput, SECBUFFER_TOKEN );

            if ( Blob )
            {
                //
                // Already a token.  Switch to pause:
                //

                Context->State = SaslPause ;
            }
            else
            {
                Context->State = SaslCookie ;

                Status = SaslBuildServerCookie( pOutput, Context );

                if ( NT_SUCCESS( Status ) )
                {
                    Status = SEC_I_CONTINUE_NEEDED ;
                }
            }


        }
    }
    else
    {
        if ( Context )
        {
            SaslDeleteContext( Context );
        }
    }

    return Status ;

}

VOID
SaslDeletePackagePrefixes(
    VOID
    )
{
    return ;
}

SECURITY_STATUS
SaslLoadPackagePrefixes(
    VOID
    )
{
    SECURITY_STATUS Status ;
    SECURITY_STATUS SubStatus ;
    PDLL_SECURITY_PACKAGE Package ;
    PNEGOTIATE_PACKAGE_PREFIXES Prefixes = NULL ;
    PNEGOTIATE_PACKAGE_PREFIX PrefixList ;
    PNEGOTIATE_PACKAGE_PREFIXES DllCopy ;
    NEGOTIATE_PACKAGE_PREFIXES LocalPrefix ;
    HANDLE LsaHandle ;
    STRING LocalName = { 0 };
    LSA_OPERATIONAL_MODE Mode ;
    ULONG PrefixLen = 0 ;
    ULONG i ;

    RtlEnterCriticalSection( &SaslLock );

    if ( SaslPrefixes )
    {
        RtlLeaveCriticalSection( &SaslLock );

        return STATUS_SUCCESS ;
    }

    Package = SecLocatePackageW( NEGOSSP_NAME );

    if ( !Package )
    {
        RtlLeaveCriticalSection( &SaslLock );

        return SEC_E_SECPKG_NOT_FOUND ;
    }

    LocalPrefix.MessageType = NegEnumPackagePrefixes ;
    LocalPrefix.Offset = 0 ;
    LocalPrefix.PrefixCount = 0 ;

    Status = LsaConnectUntrusted(
                &LsaHandle );

    if ( NT_SUCCESS( Status ) )
    {
        Status = LsaCallAuthenticationPackage(
                        LsaHandle,
                        (ULONG) Package->PackageId,
                        &LocalPrefix,
                        sizeof( LocalPrefix ),
                        (PVOID *) &Prefixes,
                        &PrefixLen,
                        &SubStatus );

        LsaDeregisterLogonProcess( LsaHandle );
    }

    if ( !NT_SUCCESS( Status ) )
    {

        RtlLeaveCriticalSection( &SaslLock );

        return SEC_E_SECPKG_NOT_FOUND ;
    }

    DllCopy = (PNEGOTIATE_PACKAGE_PREFIXES) LocalAlloc( LMEM_FIXED, PrefixLen );

    if ( !DllCopy )
    {
        LsaFreeReturnBuffer( Prefixes );

        RtlLeaveCriticalSection( &SaslLock );

        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    RtlCopyMemory(
        DllCopy,
        Prefixes,
        PrefixLen );

    LsaFreeReturnBuffer( Prefixes );

    //
    // Now, fix them up:
    //

    PrefixList = (PNEGOTIATE_PACKAGE_PREFIX) ((PUCHAR) DllCopy + DllCopy->Offset );

    for ( i = 0 ; i < DllCopy->PrefixCount ; i++ )
    {
        Package = SecLocatePackageById( PrefixList[ i ].PackageId );

        if ( !Package )
        {
            break;
        }

        Status = SecCopyPackageInfoToUserA( Package, (PSecPkgInfoA *) &PrefixList[ i ].PackageDataA );

        if ( NT_SUCCESS( Status ) )
        {
            Status = SecCopyPackageInfoToUserW( Package, (PSecPkgInfoW *) &PrefixList[ i ].PackageDataW );

        }

        if ( !NT_SUCCESS( Status ) )
        {
            Package = NULL ;
            break;
        }

    }


    //
    // Now, update the globals and we're done:
    //

    SaslPrefixList = PrefixList ;
    SaslPrefixes = DllCopy ;

    if ( Package == NULL )
    {
        //
        // Error path out of the loop.  Destroy and bail
        //

        SaslDeletePackagePrefixes();

    }

    RtlLeaveCriticalSection( &SaslLock );

    return STATUS_SUCCESS ;


}

int
Sasl_der_read_length(
     unsigned char **buf,
     int *bufsize
     )
{
   unsigned char sf;
   int ret;

   if (*bufsize < 1)
      return(-1);
   sf = *(*buf)++;
   (*bufsize)--;
   if (sf & 0x80) {
      if ((sf &= 0x7f) > ((*bufsize)-1))
         return(-1);
      if (sf > sizeof(int))
          return (-1);
      ret = 0;
      for (; sf; sf--) {
         ret = (ret<<8) + (*(*buf)++);
         (*bufsize)--;
      }
   } else {
      ret = sf;
   }

   return(ret);
}

SECURITY_STATUS
SaslIdentifyPackageHelper(
    PSecBufferDesc  pInput,
    PNEGOTIATE_PACKAGE_PREFIX * pPrefix
    )
{
    SECURITY_STATUS Status ;
    ULONG i ;
    PSecBuffer Token = NULL ;
    PUCHAR Buffer ;
    int Size ;
    int OidSize ;

    if ( !SaslPrefixes )
    {
        Status = SaslLoadPackagePrefixes();

        if ( !NT_SUCCESS( Status ) )
        {
            return Status ;
        }
    }

    for ( i = 0 ; i < pInput->cBuffers ; i++ )
    {
        if ( (pInput->pBuffers[ i ].BufferType & (~(SECBUFFER_ATTRMASK)) ) == SECBUFFER_TOKEN )
        {
            Token = &pInput->pBuffers[ i ];
            break;
        }
    }

    if ( !Token )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    //
    // Special case checks:

    Size = (int) Token->cbBuffer ;
    Buffer = (PUCHAR) Token->pvBuffer ;

    if ( Size == 0 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    Size-- ;
    if ( (*Buffer != 0x60) &&
         (*Buffer != 0xA0) )
    {
        //
        // Not a valid SASL buffer
        //

        return SEC_E_INVALID_TOKEN ;
    }

    if ( *Buffer == 0xa0 )
    {
        *pPrefix = &SaslPrefixList[ 0 ];

        return STATUS_SUCCESS ;
    }

    Buffer++ ;

    OidSize = Sasl_der_read_length( &Buffer, &Size );

    if (OidSize < 0)
    {
        return SEC_E_INVALID_TOKEN ;
    }

    if ( *Buffer != 0x06 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    OidSize = (int) Buffer[ 1 ] + 2;

    for ( i = 0 ; i < SaslPrefixes->PrefixCount ; i++ )
    {
        if ( (OidSize < (int)SaslPrefixList[ i ].PrefixLen ) ||
             (SaslPrefixList[ i ].PrefixLen == 0 ) )
        {
            continue;
        }

        if ( RtlEqualMemory( Buffer,
                             SaslPrefixList[ i ].Prefix,
                             SaslPrefixList[ i ].PrefixLen )  )
        {
            break;
        }
    }

    if ( i != SaslPrefixes->PrefixCount )
    {
        *pPrefix = &SaslPrefixList[ i ] ;
        Status = STATUS_SUCCESS ;
    }
    else
    {
        *pPrefix = NULL ;
        Status = SEC_E_INVALID_TOKEN ;
    }

    return Status ;

}


SECURITY_STATUS
SaslIdentifyPackageA(
    PSecBufferDesc  pInput,
    PSecPkgInfoA *   pPackage
    )
{
    SECURITY_STATUS Status ;
    PNEGOTIATE_PACKAGE_PREFIX Prefix = NULL ;

    Status = SaslIdentifyPackageHelper( pInput, &Prefix );

    if ( NT_SUCCESS( Status ) )
    {
        *pPackage = (PSecPkgInfoA) Prefix->PackageDataA ;
    }

    return Status ;
}

SECURITY_STATUS
SaslIdentifyPackageW(
    PSecBufferDesc  pInput,
    PSecPkgInfoW *   pPackage
    )
{
    SECURITY_STATUS Status ;
    PNEGOTIATE_PACKAGE_PREFIX Prefix = NULL ;

    Status = SaslIdentifyPackageHelper( pInput, &Prefix );

    if ( NT_SUCCESS( Status ) )
    {
        *pPackage = (PSecPkgInfoW) Prefix->PackageDataW ;
    }

    return Status ;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\tcache.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       tcache.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define SECURITY_WIN32
#include <security.h>

UCHAR Buffer[ 1024 ];

NTSTATUS
SecCacheSspiPackages(
    VOID
    );

void _CRTAPI1 main (int argc, char *argv[])
{
    Buffer[0] = 0 ;

    SecCacheSspiPackages();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\stubs.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        stubs.cxx
//
// Contents:    user-mode stubs for security API
//
//
// History:     3/5/94      MikeSw      Created
//
//------------------------------------------------------------------------
#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}


static LUID            lFake = {0, 0};
static SECURITY_STRING sFake = {0, 0, NULL};
static SecBufferDesc EmptyBuffer;

//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    if ( SecpFreeVM( pvContextBuffer ) )
    {
        DebugLog(( DEB_TRACE, "Freeing VM %x\n", pvContextBuffer ));

        LsaFreeReturnBuffer( pvContextBuffer );
    }
    else
    {
        LocalFree( pvContextBuffer );
    }

    return( SEC_E_OK );
}




SECURITY_STATUS
SEC_ENTRY
AddSecurityPackageW(
    LPWSTR          pszPackageName,
    PSECURITY_PACKAGE_OPTIONS pOptions
    )
{
    SECURITY_PACKAGE_OPTIONS    Options;
    UNICODE_STRING Package;

    if ( pOptions == NULL )
    {
        pOptions = &Options;
        Options.Size = sizeof( Options );
        Options.Flags = 0;

    }

    RtlInitUnicodeString( &Package, pszPackageName );

    return( SecpAddPackage( &Package, pOptions ) );

}


SECURITY_STATUS
SEC_ENTRY
AddSecurityPackageA(
    LPSTR          pszPackageName,
    PSECURITY_PACKAGE_OPTIONS pOptions
    )
{
    SECURITY_PACKAGE_OPTIONS    Options;
    UNICODE_STRING Package;
    SECURITY_STATUS scRet ;

    if ( pOptions == NULL )
    {
        pOptions = &Options;
        Options.Size = sizeof( Options );
        Options.Flags = 0;

    }

    if ( RtlCreateUnicodeStringFromAsciiz( &Package, pszPackageName ) )
    {
        scRet = SecpAddPackage( &Package, pOptions );

        RtlFreeUnicodeString( &Package );
    }
    else 
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY ;
    }

    return( scRet );

}

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityPackageW(
    LPWSTR  pszPackageName
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

SECURITY_STATUS
SEC_ENTRY
DeleteSecurityPackageA(
    LPSTR   pszPackageName
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\stubsa.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       stubsa.cxx
//
//  Contents:   ANSI stubs for security functions
//
//  History:    8-05-96   RichardW   Created
//
//----------------------------------------------------------------------------


#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

SecurityFunctionTableA   SecTableA = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                    EnumerateSecurityPackagesA,
                                    NULL, // LogonUser,
                                    AcquireCredentialsHandleA,
                                    FreeCredentialsHandle,
                                    NULL, // QueryCredentialAttributes,
                                    InitializeSecurityContextA,
                                    AcceptSecurityContext,
                                    CompleteAuthToken,
                                    DeleteSecurityContext,
                                    ApplyControlToken,
                                    QueryContextAttributesA,
                                    ImpersonateSecurityContext,
                                    RevertSecurityContext,
                                    MakeSignature,
                                    VerifySignature,
                                    FreeContextBuffer,
                                    QuerySecurityPackageInfoA,
                                    SealMessage,
                                    UnsealMessage,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL
                                   };




PSecurityFunctionTableA
SEC_ENTRY
InitSecurityInterfaceA(
    VOID )
{
    DebugLog((DEB_TRACE, "Doing it the hard way:  @%x\n", &SecTableA));
    return(&SecTableA);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\txlate.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       txlate.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-17-97   RichardW   Created
//
//----------------------------------------------------------------------------


#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>

#include <windows.h>

#define SECURITY_WIN32
#include <security.h>

CHAR ReturnBuffer[ MAX_PATH ];
ULONG BufferSize ;

VOID
TranslateLoop(
    PSTR Name
    )
{
    EXTENDED_NAME_FORMAT DesiredFormat ;

    for ( DesiredFormat = NameFullyQualifiedDN ;
          DesiredFormat < NameServicePrincipal + 1 ;
          DesiredFormat ++ )
    {
        BufferSize = MAX_PATH ;

        if ( TranslateName( Name, NameUnknown, DesiredFormat,
                            ReturnBuffer, & BufferSize ) )
        {
            printf("%d:  %s\n", DesiredFormat, ReturnBuffer );
        }
        else
        {
            printf("%d: failed, %d\n", DesiredFormat, GetLastError() );
        }
    }
}

VOID
ImpersonatePid(
    char * szPid
    )
{
    HANDLE hProcess ;
    HANDLE hToken ;
    DWORD pid ;
    SECURITY_IMPERSONATION_LEVEL Level ;
    PSTR PidString ;
    PSTR LevelString ;
    HANDLE DupToken ;

    PidString = szPid ;

    LevelString = strchr( szPid, '.' );

    if ( LevelString )
    {
        *LevelString++ = '\0';
        Level = atoi( LevelString );
    }
    else 
    {
        Level = SecurityImpersonation ;
    }
    pid = atoi( PidString );

    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION,
                            FALSE,
                            pid );

    if ( hProcess )
    {
        if ( !OpenProcessToken( hProcess,
                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                                &hToken ) )
        {
            printf("FAILED to open process token, %d\n", GetLastError() );
            return ;
        }

        if ( !DuplicateTokenEx( hToken,
                                TOKEN_QUERY | TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                                NULL,
                                Level,
                                TokenImpersonation,
                                &DupToken ) )
        {
            printf("FAILED to dup token, %d\n", GetLastError());
            return;

        }

        ImpersonateLoggedOnUser( DupToken );
    }
    else
    {
        printf("FAILED to open process %d, %d\n", pid, GetLastError() );
    }

}

VOID
GetUserLoop(
    VOID
    )
{
    EXTENDED_NAME_FORMAT DesiredFormat ;

    for ( DesiredFormat = NameFullyQualifiedDN ;
          DesiredFormat < NameServicePrincipal + 1 ;
          DesiredFormat ++ )
    {
        BufferSize = MAX_PATH ;

        if ( GetUserNameEx( DesiredFormat,
                            ReturnBuffer, & BufferSize ) )
        {
            printf("%d:  %s\n", DesiredFormat, ReturnBuffer );
        }
        else
        {
            printf("%d: failed, %d\n", DesiredFormat, GetLastError() );
        }
    }

}

VOID
GetComputerLoop(
    VOID
    )
{
    EXTENDED_NAME_FORMAT DesiredFormat ;

    for ( DesiredFormat = NameFullyQualifiedDN ;
          DesiredFormat < NameServicePrincipal + 1 ;
          DesiredFormat ++ )
    {
        BufferSize = MAX_PATH ;

        if ( GetComputerObjectName( DesiredFormat,
                            ReturnBuffer, & BufferSize ) )
        {
            printf("%d:  %s\n", DesiredFormat, ReturnBuffer );
        }
        else
        {
            printf("%d: failed, %d\n", DesiredFormat, GetLastError() );
        }
    }

}

void __cdecl main (int argc, char *argv[])
{
    if ( argc > 1 )
    {
        if ( *argv[1] == '-' )
        {
            if ( *(argv[1]+1) == 'p')
            {
                ImpersonatePid( argv[2] );
                GetUserLoop();
            }
            else if ( *(argv[1]+1) == 'c')
            {
                GetComputerLoop();
            }
        }
        else
        {
            TranslateLoop( argv[1] );
        }
    }
    else
    {
        GetUserLoop();
    }

    return ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\support.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        support.cxx
//
// Contents:    support routines for security dll
//
//
// History:     3-7-94      Created     MikeSw
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

int     ProcAttach(HINSTANCE, LPVOID);
int     ProcDetach(HANDLE, LPVOID);

typedef struct _VMLIST {
    struct _VMLIST *    Next;
    PVOID               Vaddr;
} VMLIST, * PVMLIST ;



//
// Global Variables:
//

DWORD                DllState;
RTL_CRITICAL_SECTION csSecurity;
PClient              SecDllClient;
DWORD                SecTlsEntry;
DWORD                SecTlsPackage ;

#define VMLIST_MAX_FREE_SIZE    16

RTL_CRITICAL_SECTION SecVMListLock;
PVMLIST              SecVMList;
PVMLIST              SecVMFreeList;
ULONG                SecVMFreeListSize;

#if DBG
ULONG                SecVMListSize ;

DWORD                   LockOwningThread;
#endif

//
// How we know that we are connected to the SPM:
// 1)   DllState & DLLSTATE_DEFERRED == 0.  This means we are ready to go,
//      and is a very fast check
//
// 2)   In the event that DllState still indicates that we aren't connected,
//      another thread may have initiated the connection already.  So, if we
//      see that we're still deferred, *then* we grab the process lock, and
//      check SecDllClient.
//



WCHAR       szLsaEvent[] = SPM_EVENTNAME;



BOOL WINAPI DllMain(
    HINSTANCE       hInstance,
    DWORD           dwReason,
    LPVOID          lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls ( hInstance );
            return ( ProcAttach(hInstance, lpReserved) );
        case DLL_PROCESS_DETACH:
            return( ProcDetach(hInstance, lpReserved) );
        default:
            return(TRUE);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeClient
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
FreeClient(PClient pClient)
{
    // nothing
}


///////////////////////////////////////////////////////////////////////////
//
// VMLIST routines
//
//  Because the LSA will allocate client memory in VM chunks, and SSPI DLLs
//  will allocate in Heap chunks, we have this lookaside to handle the list
//  of VM chunks that we check against.
//
///////////////////////////////////////////////////////////////////////////

BOOL
SecpInitVMList(
    VOID )
{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSection( &SecVMListLock );

    if ( NT_SUCCESS( Status ) )
    {
        SecVMList = NULL ;

        SecVMFreeList = NULL ;

        SecVMFreeListSize = 0;

#if DBG
        SecVMListSize = 0 ;
#endif

        return( TRUE );

    }

    return( FALSE );

}

BOOL
SecpAddVM(
    PVOID   pvAddr)
{
    PVMLIST List;

    if(pvAddr == NULL)
    {
        return TRUE;
    }

    RtlEnterCriticalSection( &SecVMListLock );

    List = SecVMFreeList ;

    if ( List )
    {
        SecVMFreeList = List->Next ;

        SecVMFreeListSize --;

    }
    else
    {
        List = (PVMLIST) RtlAllocateHeap( RtlProcessHeap(), 0, sizeof( VMLIST ) );
    }

    if ( List )
    {
        List->Vaddr = pvAddr ;

        List->Next = SecVMList ;

        SecVMList = List;

#if DBG
        SecVMListSize ++ ;
#endif

        RtlLeaveCriticalSection( &SecVMListLock );

        return( TRUE );
    }

    RtlLeaveCriticalSection( &SecVMListLock );

    return( FALSE );


}

BOOL
SecpFreeVM(
    PVOID   pvAddr )
{
    PVMLIST Search;
    PVMLIST Trail;

    Trail = NULL ;

    RtlEnterCriticalSection( &SecVMListLock );

    Search = SecVMList ;

    while ( Search )
    {
        if ( Search->Vaddr == pvAddr )
        {

#if DBG
            SecVMListSize -- ;
#endif

            if ( Trail )
            {
                Trail->Next = Search->Next ;
            }
            else
            {
                SecVMList = Search->Next ;
            }

            if ( SecVMFreeListSize < VMLIST_MAX_FREE_SIZE )
            {
                Search->Next = SecVMFreeList ;

                SecVMFreeList = Search ;

                SecVMFreeListSize ++ ;

            }
            else
            {
                RtlLeaveCriticalSection( &SecVMListLock );
                RtlFreeHeap( RtlProcessHeap(), 0, Search );
                return TRUE;
            }

            RtlLeaveCriticalSection( &SecVMListLock );

            return( TRUE );
        }

        Trail = Search;

        Search = Search->Next ;
    }

    RtlLeaveCriticalSection( &SecVMListLock );

    return( FALSE );
}

VOID
SecpUnloadVMList(
    VOID
    )
{
    PVMLIST Search;
    PVOID Free ;

    RtlEnterCriticalSection( &SecVMListLock );

    Search = SecVMList ;

    while ( Search )
    {
        NtFreeVirtualMemory( NtCurrentProcess(),
                             &Search->Vaddr,
                             0,
                             MEM_RELEASE );

        Free = Search ;

        Search = Search->Next ;

        RtlFreeHeap( RtlProcessHeap(), 0, Free );
    }

    RtlLeaveCriticalSection( &SecVMListLock );

    RtlDeleteCriticalSection( &SecVMListLock );

}



//+-------------------------------------------------------------------------
//
//  Function:   SecClientAllocate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID * SEC_ENTRY
SecClientAllocate(ULONG cbMemory)
{

    return( LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, cbMemory ) );
}



//+-------------------------------------------------------------------------
//
//  Function:   SecClientFree
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void SEC_ENTRY
SecClientFree(PVOID pvMemory)
{
    FreeContextBuffer(pvMemory);
}







#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   GetProcessLock
//
//  Synopsis:   Debug only wrapper for critical section
//
//  Arguments:  (none)
//
//  History:    9-10-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
GetProcessLock(void)
{
    NTSTATUS    Status;

    Status = RtlEnterCriticalSection(&csSecurity);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Could not get process-wide lock:  %x\n", Status));
    }

    LockOwningThread = GetCurrentThreadId();

}

//+---------------------------------------------------------------------------
//
//  Function:   FreeProcessLock
//
//  Synopsis:   Debug only wrapper for critical section
//
//  History:    9-10-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
FreeProcessLock(void)
{
    NTSTATUS    Status;

    LockOwningThread = 0;

    Status = RtlLeaveCriticalSection(&csSecurity);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Could not free process-wide lock: %x\n", Status));
    }
}

#endif // DBG

//+-------------------------------------------------------------------------
//
//  Function:   IsSPMgrReady()
//
//  Synopsis:   Internal function to determine the state of the link
//              to the SPM.  Called by all APIs before they attempt
//              to execute.
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    TRUE or FALSE
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
IsSPMgrReady(
    VOID )
{
    OBJECT_ATTRIBUTES           EventObjAttr;
    NTSTATUS                    status;
    UNICODE_STRING              EventName;
    EVENT_BASIC_INFORMATION     EventStatus;
    HANDLE                      hEvent;

    RtlInitUnicodeString(&EventName, szLsaEvent);
    InitializeObjectAttributes(&EventObjAttr, &EventName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenEvent(&hEvent, EVENT_QUERY_STATE, &EventObjAttr);

    if (!NT_SUCCESS(status))
    {
        DebugLog((DEB_ERROR, "Could not open security event %ws, %x\n",
                    EventName.Buffer, status));

        return( status );
    }

    status = NtQueryEvent(  hEvent,
                            EventBasicInformation,
                            &EventStatus,
                            sizeof(EventStatus),
                            NULL);

    if (!NT_SUCCESS(status))
    {
        DebugLog((DEB_ERROR, "Failed NtQueryEvent on %ws, %x\n", EventName.Buffer, status));
        return( status );
    }

    (void) NtClose(hEvent);

    return( EventStatus.EventState == 0 ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS );
}



//+-------------------------------------------------------------------------
//
//  Function:   InitState
//
//  Synopsis:   Performs the process bind to the SPM, allows SPM to open the
//              process, all sorts of things
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT
InitState(void)
{
    SECURITY_STATUS scRet;
    Client          TempClient;
    ULONG SecurityMode;

    GetProcessLock();

    //
    // If SecDllClient is non-null, then another thread has been here and
    // has initialized the connection.
    //

    if (SecDllClient)
    {
        FreeProcessLock();
        return(S_OK);
    }


    DebugLog(( DEB_TRACE, "Connecting to LSA\n" ));

    scRet = CreateConnection(NULL,      // no client name
                             0,         // no mode flags
                             &TempClient.hPort,
                             &SecLsaPackageCount,
                             &SecurityMode );

    if (scRet != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR, "Error 0x%08x getting LSA state\n", scRet));

        FreeProcessLock();

        return(scRet);
    }

    SecDllClient = (PClient) LocalAlloc(0,sizeof(Client));
    if (!SecDllClient)
    {
        FreeProcessLock();
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    *SecDllClient = TempClient;

    if ( SecurityMode & LSA_MODE_SAME_PROCESS )
    {
        SecpSetSession( SETSESSION_GET_DISPATCH,
                        (ULONG_PTR) SecpLsaCallback,
                        (PULONG_PTR) &SecpLsaDispatchFn,
                        NULL );
    }

    DllState = DLLSTATE_INITIALIZE;

    DebugLog((DEB_TRACE, "Security DLL initialized\n"));

    FreeProcessLock();

    return(S_OK);

}





//+-------------------------------------------------------------------------
//
//  Function:   IsOkayToExec
//
//  Synopsis:   Determines if it is okay to make a call to the SPM
//
//  Effects:    Binds if necessary to the SPM
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      uses IsSPMgrReady and InitState
//
// How we know that we are connected to the SPM:
// 1)   DllState & DLLSTATE_INITIALIZE != 0.  This means we are ready to go,
//      and is a very fast check
//
// 2)   In the event that DllState still indicates that we aren't connected,
//      another thread may have initiated the connection already.  So, if we
//      see that we're still deferred, *then* we grab the process lock, and
//      check SecDllClient.
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
IsOkayToExec(PClient * ppClient)
{
    SECURITY_STATUS scRet;
    HANDLE RealToken = NULL ;
    HANDLE Null = NULL ;


    //
    // Fast check.  If this bit has been reset, then we know everything is
    // ok.
    //

    if ((DllState & DLLSTATE_INITIALIZE) != 0)
    {

        if (ppClient)
        {
            *ppClient = SecDllClient;
        }
        return(S_OK);
    }

    //
    // Nope.  See if the (expletive deleted) thing is even running.
    //

    scRet = IsSPMgrReady();

    if ( !NT_SUCCESS( scRet ) )
    {
        if ( scRet != STATUS_BAD_IMPERSONATION_LEVEL )
        {
            return scRet ;
        }

        //
        // We appear to be running with an identify or anonymous level
        // token while trying to make this initial connection.  Try to
        // suspend the impersonation for the duration.
        //

        scRet = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_READ,
                    TRUE,
                    &RealToken );
        if ( !NT_SUCCESS( scRet ) )
        {
            return scRet ;
        }

        //
        // We've got it, stop impersonating now, and try the connection.
        //

        scRet = NtSetInformationThread(
                    NtCurrentThread(),
                    ThreadImpersonationToken,
                    &Null,
                    sizeof( HANDLE ) );

        if ( !NT_SUCCESS( scRet ) )
        {
            NtClose( RealToken );
            return scRet ;
        }

    }

    //
    // It is running.  Initialize state, make the connection. InitState is
    // MT-Safe, and will make exactly one connection.
    //

    scRet = InitState();

    if ( RealToken )
    {
        NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &RealToken,
            sizeof( HANDLE ) );

        NtClose( RealToken );
    }

    if (FAILED(scRet))
    {
        return(scRet);
    }

    if (ppClient)
    {
        *ppClient = SecDllClient;
    }

    return(S_OK);
}




//+-------------------------------------------------------------------------
//
//  Function:   ProcAttach
//
//  Synopsis:   Handles when a process loads the DLL
//
//  Effects:    Bind process to SPM if it is running, or marks the
//              state as a deferred connection.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
int ProcAttach(
    HINSTANCE       hInstance,
    LPVOID          lpReserved)
{

    NTSTATUS    scRet;

#if DBG

    SecInitializeDebug();

#endif

    DllState = DLLSTATE_DEFERRED;
    SecDllClient = NULL;
    SecTlsEntry = TlsAlloc();
    SecTlsPackage = TlsAlloc();
    if (SecTlsEntry == 0xFFFFFFFF)
    {
        DllState |= DLLSTATE_NO_TLS;
    }

    scRet = RtlInitializeCriticalSection(&csSecurity);

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR, "Could not initialize critsec, %x\n", scRet));
        return(FALSE);
    }

    SecpInitVMList();

#if BUILD_WOW64
    if ( !SecpInitHandleMap())
    {
        RtlDeleteCriticalSection( &csSecurity );
        return FALSE ;
    }
#endif

    if ( SecInitializePackageControl( hInstance ))
    {
        return( TRUE );
    }


#if BUILD_WOW64
    SecpFreeHandleMap();
#endif

    RtlDeleteCriticalSection( &csSecurity );

    return( FALSE );


}


//+-------------------------------------------------------------------------
//
//  Function:   ProcDetach
//
//  Synopsis:   Handles a process detach of the security DLL
//
//  Effects:    Unbinds the connection to the SPM.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
int ProcDetach(
    HANDLE          hInstance,
    LPVOID          lpReserved)
{
    ULONG i;
    BOOLEAN ProcessTerminate = (lpReserved != NULL);

    //
    // if process termination caused ProcDetach, just return now to
    // avoid deadlocks in the various locks.
    //

    if (!(DllState & DLLSTATE_NO_TLS))
    {
        TlsFree(SecTlsEntry);
        TlsFree(SecTlsPackage);
    }

    SecUnloadPackages(ProcessTerminate);

    RtlDeleteCriticalSection(&csSecurity);

    //
    // Clean up memory turds
    //

    SecpUnloadVMList();

#if BUILD_WOW64
    SecpFreeHandleMap();
#endif

    if (SecDllClient)
    {
        NtClose(SecDllClient->hPort);
        LocalFree(SecDllClient);
    }

    DebugLog((DEB_TRACE, "Security DLL unbinding\n"));

#if DBG

    SecUninitDebug();

#endif
    return(1);
}

//
// HACK HACK HACK on xp sp1, we can not have STATUS_USER2USER_REQUIRED in ntstatus.mc!
//

//
// MessageId: STATUS_USER2USER_REQUIRED
//
// MessageText:
//
//  Kerberos sub-protocol User2User is required.
//
#define STATUS_USER2USER_REQUIRED        ((NTSTATUS)0xC0000408L)

//+-------------------------------------------------------------------------
//
//  Function:   SspNtStatusToSecStatus
//
//  Synopsis:   Convert an NtStatus code to the corresponding Security status
//              code. For particular errors that are required to be returned
//              as is (for setup code) don't map the errors.
//
//  Effects:
//
//
//  Arguments:  NtStatus - NT status to convert
//
//  Requires:
//
//  Returns:    Returns security status code.
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SspNtStatusToSecStatus(
    IN NTSTATUS NtStatus,
    IN SECURITY_STATUS DefaultStatus
    )
{

    SECURITY_STATUS SecStatus;

    //
    // Check for security status and let them through
    //

    if  (HRESULT_FACILITY(NtStatus) == FACILITY_SECURITY )
    {
        return (NtStatus);
    }

    switch(NtStatus){

    case STATUS_SUCCESS:
        SecStatus = SEC_E_OK;
        break;

    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        break;

    case STATUS_NETLOGON_NOT_STARTED:
    case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
    case STATUS_NO_LOGON_SERVERS:
    case STATUS_NO_SUCH_DOMAIN:
    case STATUS_BAD_NETWORK_PATH:
    case STATUS_TRUST_FAILURE:
    case STATUS_TRUSTED_RELATIONSHIP_FAILURE:
    case STATUS_NETWORK_UNREACHABLE:

        SecStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
        break;

    case STATUS_NO_SUCH_LOGON_SESSION:
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        break;

    case STATUS_INVALID_PARAMETER:
    case STATUS_PARTIAL_COPY:
        SecStatus = SEC_E_INVALID_TOKEN;
        break;

    case STATUS_PRIVILEGE_NOT_HELD:
        SecStatus = SEC_E_NOT_OWNER;
        break;

    case STATUS_INVALID_HANDLE:
        SecStatus = SEC_E_INVALID_HANDLE;
        break;

    case STATUS_BUFFER_TOO_SMALL:
        SecStatus = SEC_E_BUFFER_TOO_SMALL;
        break;

    case STATUS_NOT_SUPPORTED:
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        break;

    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_NO_TRUST_SAM_ACCOUNT:
        SecStatus = SEC_E_TARGET_UNKNOWN;
        break;

    // See bug 75803 .
    case STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
    case STATUS_NOLOGON_SERVER_TRUST_ACCOUNT:
    case STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT:
    case STATUS_TRUSTED_DOMAIN_FAILURE:
        SecStatus = NtStatus;
        break;

    case STATUS_LOGON_FAILURE:
    case STATUS_NO_SUCH_USER:
    case STATUS_ACCOUNT_DISABLED:
    case STATUS_ACCOUNT_RESTRICTION:
    case STATUS_ACCOUNT_LOCKED_OUT:
    case STATUS_WRONG_PASSWORD:
    case STATUS_ACCOUNT_EXPIRED:
    case STATUS_PASSWORD_EXPIRED:
    case STATUS_PASSWORD_MUST_CHANGE:
    case STATUS_LOGON_TYPE_NOT_GRANTED:
    case STATUS_USER2USER_REQUIRED:
        SecStatus = SEC_E_LOGON_DENIED;
        break;

    case STATUS_NAME_TOO_LONG:
    case STATUS_ILL_FORMED_PASSWORD:

        SecStatus = SEC_E_INVALID_TOKEN;
        break;

    case STATUS_TIME_DIFFERENCE_AT_DC:
        SecStatus = SEC_E_TIME_SKEW;
        break;

    case STATUS_SHUTDOWN_IN_PROGRESS:
        SecStatus = SEC_E_SHUTDOWN_IN_PROGRESS;
        break;

    case STATUS_INTERNAL_ERROR:
        SecStatus = SEC_E_INTERNAL_ERROR;
        ASSERT(FALSE);
        break;

    default:

        if ( DefaultStatus != 0 ) {
            SecStatus = DefaultStatus;
        } else {
            DebugLog((DEB_ERROR, "SECUR32: Unable to map error code 0x%x, returning SEC_E_INTERNAL_ERROR\n",NtStatus));
            SecStatus = SEC_E_INTERNAL_ERROR;
            ASSERT(FALSE);
        }
        break;
    }

    return(SecStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\userstub.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        userstub.cxx
//
// Contents:    stubs for user-mode security APIs
//
//
// History:     3-7-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteUsermodeContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
DeleteUserModeContext(
    PCtxtHandle                 phContext           // Contxt to delete
    )
{
    PDLL_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;

    pPackage = SecLocatePackageById( phContext->dwLower );

    if (!pPackage)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if (pPackage->pftUTable != NULL)
    {

        scRet = pPackage->pftUTable->DeleteUserModeContext(
                                phContext->dwUpper);

    }
    else
    {
        scRet = SEC_E_OK;
    }
    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   FormatCredentials
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
FormatCredentials(
    LPWSTR          pszPackageName,
    ULONG           cbCredentials,
    PUCHAR          pbCredentials,
    PULONG          pcbFormattedCreds,
    PUCHAR *        pbFormattedCreds)
{
    PDLL_SECURITY_PACKAGE pPackage;
    HRESULT scRet;
    SecBuffer InputCredentials;
    SecBuffer OutputCredentials;

    InputCredentials.pvBuffer = pbCredentials;
    InputCredentials.cbBuffer = cbCredentials;
    InputCredentials.BufferType = 0;



    if (FAILED(IsOkayToExec(NULL)))
    {
        return(SEC_E_INTERNAL_ERROR);
    }

    pPackage = SecLocatePackageW( pszPackageName );
    if (!pPackage)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }



    scRet = pPackage->pftUTable->FormatCredentials(
                &InputCredentials,
                &OutputCredentials);

    if (NT_SUCCESS(scRet))
    {
        *pcbFormattedCreds = OutputCredentials.cbBuffer;
        *pbFormattedCreds = (PBYTE) OutputCredentials.pvBuffer;
    }


    return(scRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\dll\xlate.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       xlate.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-02-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"

#include <ntdsapi.h>
#include <lm.h>
#include <dsgetdc.h>
#include <dsgetdcp.h>

}
#if DBG
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


typedef LONG (WINAPI * I_RPCMAPWIN32STATUS)(
    IN ULONG Win32Status
    );


NTSTATUS DsNameErrorMap[] = {   STATUS_SUCCESS,
                                STATUS_NO_SUCH_USER,
                                STATUS_NO_SUCH_USER,
                                STATUS_NONE_MAPPED,
                                STATUS_NONE_MAPPED,
                                STATUS_SOME_NOT_MAPPED,
                                STATUS_SOME_NOT_MAPPED
                            };

#define SecpMapDsNameError( x )    ((x < sizeof( DsNameErrorMap ) / sizeof( NTSTATUS ) ) ? \
                                     DsNameErrorMap[ x ] : STATUS_UNSUCCESSFUL )

#define SecpSetLastNTError( x ) SetLastError( RtlNtStatusToDosError( x ) )


//+---------------------------------------------------------------------------
//
//  Function:   SecpTranslateName
//
//  Synopsis:   Private helper to do the translation
//
//  Arguments:  [Domain]             --
//              [Name]               --
//              [Supplied]           --
//              [Desired]            --
//              [TranslatedName]     --
//              [TranslatedNameSize] --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
WINAPI
SecpTranslateName(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT Desired,
    PWSTR TranslatedName,
    PULONG TranslatedNameSize
    )
{
    DWORD NetStatus ;
    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL ;
    HANDLE DcHandle ;
    ULONG RetryLimit ;
    PDS_NAME_RESULTW Results ;
    NTSTATUS Status = STATUS_CANT_ACCESS_DOMAIN_INFO ;
    ULONG LengthRequired ;
    BOOL bRet = FALSE ;
    BOOL UseNetStatus = TRUE ;
    BOOL fForcedLocal = FALSE ;
    PWSTR lpDcName;
    NT_PRODUCT_TYPE pt;

    I_RPCMAPWIN32STATUS pI_RpcMapWin32Status ;

    //
    // Note:  Status is initialized to can't access domain info because if there
    // is a series of network problems after finding a DC, we bail out of the loop
    // after some retries, and Status would be uninitialized.
    //

    pI_RpcMapWin32Status = (I_RPCMAPWIN32STATUS) GetProcAddress( GetModuleHandle(L"rpcrt4.dll"),
                                                                 "I_RpcMapWin32Status" );

    //
    // Note:  The following implementation uses DsGetDcName rather than
    // DsGetDcNameWithAccount as the latter is rather expensive. However,
    // it is possible that the DC retuned by the former doesn't have the
    // account due to replication latency.  In this case we should retry
    // to discover a DC that has the account by calling DsGetDcNameWithAccount.
    // We should be careful, though, to avoid unjustified use of this expensive
    // API. The current routine is called from 2 places. One is TraslateName
    // which is a public API which anyone can call and pass anything as the
    // account name.  We should avoid with account discoveries for this caller.
    // The other caller is GetComputerObject which passes the machine account
    // name that is guaranteed to be meaningful. For this caller, we should
    // retry DsGetDcNameWithAccount if the DC returned by DsGetDcName doesn't
    // have the machine account as indicated by the name crack failure below
    // (see SecpTranslateNameEx).
    //

    NetStatus = DsGetDcName( NULL,
                             Domain ? Domain : L"",
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED |
                                DS_RETURN_DNS_NAME,
                             &DcInfo );

    //
    // Handle the case where this DC was just promoted and we're being called
    // before it's ready to advertise itself on the network as such.
    //

    if ((NetStatus == ERROR_NO_SUCH_DOMAIN)
         &&
        RtlGetNtProductType(&pt)
         &&
        (pt == NtProductLanManNt))
    {
        NTSTATUS Status;
        LSA_HANDLE LsaHandle = NULL;
        LSA_OBJECT_ATTRIBUTES LsaAttributes = {0};
        PPOLICY_DNS_DOMAIN_INFO pDnsInfo = NULL;

        Status = LsaOpenPolicy(
                     NULL,
                     &LsaAttributes,
                     POLICY_VIEW_LOCAL_INFORMATION,
                     &LsaHandle);

        if ( NT_SUCCESS( Status ))
        {
            Status = LsaQueryInformationPolicy(
                         LsaHandle,
                         PolicyDnsDomainInformation,
                         (PVOID *) &pDnsInfo);

            if ( NT_SUCCESS( Status ))
            {
                UNICODE_STRING DomainString;

                RtlInitUnicodeString(&DomainString, Domain);

                if (RtlEqualUnicodeString(&pDnsInfo->Name, &DomainString, TRUE)
                     ||
                    RtlEqualUnicodeString(&pDnsInfo->DnsDomainName, &DomainString, TRUE))
                {
                    //
                    // This machine is a non-advertising DC that
                    // can service the request.  Tweak things so
                    // we can try the bind below.
                    //

                    fForcedLocal = TRUE;
                    NetStatus    = NERR_Success;
                }

                LsaFreeMemory(pDnsInfo);
            }

            LsaClose( LsaHandle );
        }
    }

    if ( NetStatus != NERR_Success )
    {
        //
        // No DS DC available, therefore no name translation:
        //

        SecpSetLastNTError( STATUS_UNSUCCESSFUL );

        SetLastError( NetStatus );

#if DBG
        // FarzanaR special
        //
        //

        if ( NetStatus == ERROR_NO_SUCH_DOMAIN )
        {
            SYSTEMTIME Time ;

            GetLocalTime( &Time );

            DebugLog(( DEB_ERROR, "Failed to find any DC for domain %ws\n",
                       Domain ));

            DebugLog(( DEB_ERROR, "Time:  %02d:%02d:%02d, %d/%d\n",
                       Time.wHour, Time.wMinute, Time.wSecond,
                       Time.wMonth, Time.wDay ));


        }
#endif

        return FALSE ;
    }

    //
    // Okay, we have a DC that has a DS running on it.  Try to translate
    // the name:
    //

    if (fForcedLocal)
    {
        //
        // Don't retry with forced rediscovery if the bind fails since
        // we already know we won't find a DC even if we do that.
        //

        RetryLimit = 0;
        lpDcName   = L"Localhost";
    }
    else
    {
        RetryLimit = 2;
        lpDcName   = DcInfo->DomainControllerName;
    }

    while ( RetryLimit-- )
    {
        DebugLog((DEB_TRACE_GETUSER, "Trying to bind to %ws\n", lpDcName));

        while ( *lpDcName == L'\\' )
        {
            lpDcName ++ ;
        }

        NetStatus = DsBind( lpDcName,
                            NULL,
                            &DcHandle );

        if ( NetStatus != 0 )
        {
           DebugLog((DEB_ERROR,
                     "DsBind returned 0x%lx, dc = %ws. %ws, line %d.\n",
                     NetStatus,
                     lpDcName,
                     THIS_FILE,
                     __LINE__));
        }

        //
        // We are done with the DC info, and makes the retry case easier:
        //

        if ( NetStatus != 0 )
        {
            //
            // Error mapping tricks.  Some win32 errors have
            // this format.
            //

            if ( NetStatus <= 0x80000000 )
            {
                Status = NtCurrentTeb()->LastStatusValue ;

                if ( pI_RpcMapWin32Status )
                {
                    Status = pI_RpcMapWin32Status( NetStatus );

                    if ( NT_SUCCESS( Status ) )
                    {
                        //
                        // Didn't map.  Treat as a win32 error
                        //

                        UseNetStatus = TRUE ;

                        Status = STATUS_UNSUCCESSFUL ;
                    }
                }

            }
            else
            {
                UseNetStatus = TRUE ;

                Status = STATUS_UNSUCCESSFUL ;
            }


            DebugLog(( DEB_ERROR, "DsBind to %ws failed, %x (%d)\n",
                       lpDcName,
                       NetStatus,
                       UseNetStatus ));
        }

        if (!fForcedLocal)
        {
            NetApiBufferFree( DcInfo );
            DcInfo = NULL;
        }

RetryBind:

        if ( NetStatus != 0 )
        {
            if ( RetryLimit == 0 )
            {
                bRet = FALSE ;

                break;
            }

            NetStatus = DsGetDcName( NULL,
                                     Domain ? Domain : L"",
                                     NULL,
                                     NULL,
                                     DS_DIRECTORY_SERVICE_REQUIRED |
                                         DS_RETURN_DNS_NAME |
                                         DS_FORCE_REDISCOVERY,
                                     &DcInfo );

            if ( NetStatus != 0 )
            {
                //
                // No DS DC available, therefore no name translation:
                //

                SecpSetLastNTError( STATUS_UNSUCCESSFUL );


        #if DBG
                // FarzanaR special
                //
                //

                if ( NetStatus == ERROR_NO_SUCH_DOMAIN )
                {
                    SYSTEMTIME Time ;

                    GetLocalTime( &Time );

                    DebugLog(( DEB_ERROR, "Failed to find any DC for domain %ws\n",
                               Domain ));

                    DebugLog(( DEB_ERROR, "Time:  %02d:%02d:%02d, %d/%d\n",
                               Time.wHour, Time.wMinute, Time.wSecond,
                               Time.wMonth, Time.wDay ));


                }
        #endif


                bRet = FALSE ;

                DebugLog((DEB_ERROR, "DsGetDcName returned 0x%lx, flags = 0x%lx. %ws, line %d\n", NetStatus, DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY, THIS_FILE, __LINE__));
                break;
            }

            lpDcName = DcInfo->DomainControllerName;
            continue;
        }

        //
        // Got a connection.  Crack the name:
        //

        NetStatus = DsCrackNames(DcHandle,
                                 DS_NAME_NO_FLAGS,
                                 (DS_NAME_FORMAT) Supplied,
                                 (DS_NAME_FORMAT) Desired,
                                 1,
                                 &Name,
                                 &Results );

        //
        // Now, see what happened:
        //

        if ( NetStatus == 0 )
        {
            //
            // So far, so good.  See if the name got xlated:
            //

            if ( Results->cItems >= 1 )
            {
                if ( Results->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY )
                {
                    bRet = SecpTranslateName(
                                Results->rItems[0].pDomain,
                                Name,
                                Supplied,
                                Desired,
                                TranslatedName,
                                TranslatedNameSize );

                    UseNetStatus = TRUE ;

                    NetStatus = GetLastError();
                    Status    = NtCurrentTeb()->LastStatusValue ;

                    DebugLog((DEB_ERROR,
                              "SecpTranslateName (recursive) returned %d (0x%lx). %ws, line %d\n",
                              NetStatus,
                              Status,
                              THIS_FILE,
                              __LINE__));
                }
                else
                {

                    Status = SecpMapDsNameError( Results->rItems[0].status );

                    if ( NT_SUCCESS( Status ) )
                    {
                        //
                        // Mapped the name
                        //

                        LengthRequired = wcslen( Results->rItems[0].pName ) + 1;

                        if ( TranslatedName == NULL )
                        {
                            *TranslatedNameSize = LengthRequired ;
                            bRet = TRUE;
                        }
                        else
                        {
                            if ( LengthRequired <= *TranslatedNameSize )
                            {
                                RtlCopyMemory( TranslatedName,
                                               Results->rItems[0].pName,
                                               LengthRequired * sizeof( WCHAR ) );

                                bRet = TRUE ;
                            }
                            else
                            {
                                Status = STATUS_BUFFER_TOO_SMALL ;

                                UseNetStatus = FALSE ;

                                bRet = FALSE ;
                            }

                            *TranslatedNameSize = LengthRequired ;
                        }
                    }
                    else
                    {
                        SecpSetLastNTError( Status );

                        UseNetStatus = FALSE ;

                        bRet = FALSE ;

                        DebugLog((DEB_ERROR,
                                  "SecpMapDsNameError returned 0x%lx. %ws, line %d\n",
                                  Status,
                                  THIS_FILE,
                                  __LINE__));
                    }
                }
            }
            else
            {
                DebugLog((DEB_ERROR, "CrackName did not return useful stuff. %ws, line %d\n", THIS_FILE, __LINE__));
            }

            DsFreeNameResult( Results );

            //
            // We are done with the connection
            //

            (VOID) DsUnBind( &DcHandle );


            //
            // Get out of retry loop
            //

            break;
        }
        else
        {
            //
            // Could have disappeared.  Retry the call (maybe)
            //

            Status = NtCurrentTeb()->LastStatusValue ;

            if ( pI_RpcMapWin32Status )
            {
                Status = pI_RpcMapWin32Status( NetStatus );

                if ( NT_SUCCESS( Status ) )
                {
                    //
                    // Didn't map.  Treat as a win32 error
                    //

                    UseNetStatus = TRUE ;

                    Status = STATUS_UNSUCCESSFUL ;
                }

            }

            DebugLog((DEB_ERROR, "DsCrackNames returned 0x%lx, retry-ing. %ws, line %d\n", NetStatus, THIS_FILE, __LINE__));
            (VOID) DsUnBind( &DcHandle );

            goto RetryBind;
        }

    }

    if ( !bRet )
    {
        DebugLog((DEB_ERROR, "Return from SecpTranslateName 0x%lx. %ws, line %d\n", Status, THIS_FILE, __LINE__));

        if ( UseNetStatus ||
             NT_SUCCESS( Status )  )
        {
            SecpSetLastNTError( STATUS_UNSUCCESSFUL );
            SetLastError( NetStatus );
        }
        else
        {
            SecpSetLastNTError( Status ) ;
        }
    }

    return (bRet != 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetFullMachineName
//
//  Synopsis:   Private worker to get the domain\computer$ name
//
//  Arguments:  [Machine] --
//              [Domain]  --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
GetFullMachineName(
    PUNICODE_STRING Machine,
    PUNICODE_STRING Domain
    )
{
    WCHAR Buffer[ CNLEN + 2 ];
    NTSTATUS Status, IgnoreStatus ;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;
    BOOL    PrimaryDomainPresent = FALSE;
    ULONG Size ;

    //
    // Set up the Security Quality Of Service
    //

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes to open the Lsa policy object
    //

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0L,
                               (HANDLE)NULL,
                               NULL);
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    //
    // Open the local LSA policy object
    //

    Status = LsaOpenPolicy( NULL,
                            &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaHandle
                          );
    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    //
    // Get the primary domain info
    //
    Status = LsaQueryInformationPolicy(LsaHandle,
                                       PolicyDnsDomainInformation,
                                       (PVOID *)&DnsDomainInfo);
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Failed to query primary domain from Lsa, Status = 0x%lx\n", Status));

        IgnoreStatus = LsaClose(LsaHandle);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        return( Status );
    }

    if ( DnsDomainInfo->Sid == NULL )
    {
        //
        // We're standalone.
        //

        LsaFreeMemory( DnsDomainInfo );

        LsaClose( LsaHandle );

        return STATUS_CANT_ACCESS_DOMAIN_INFO ;
    }

    //
    // Ok, we're part of a domain.  Use the flat name of the domain:
    //

    Domain->Buffer = (PWSTR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                 DnsDomainInfo->Name.MaximumLength );

    if ( Domain->Buffer )
    {
        Domain->MaximumLength = DnsDomainInfo->Name.MaximumLength ;

        RtlCopyUnicodeString( Domain, &DnsDomainInfo->Name );
    }
    else
    {
        Status = STATUS_NO_MEMORY ;
    }

    LsaFreeMemory( DnsDomainInfo );

    LsaClose( LsaHandle );

    if ( !NT_SUCCESS( Status ) )
    {
        return Status ;
    }

    Size = sizeof( Buffer ) / sizeof( WCHAR ) ;

    if ( !GetComputerName( Buffer, &Size ) )
    {
        LocalFree( Domain->Buffer );

        return STATUS_NO_MEMORY ;
    }

    Buffer[ Size ] = TEXT( '$' );
    Buffer[ Size + 1 ] = TEXT('\0');

    if ( !RtlCreateUnicodeString( Machine, Buffer ) )
    {
        LocalFree( Domain->Buffer );

        return STATUS_NO_MEMORY ;
    }

    return STATUS_SUCCESS ;

}

BOOL
SEC_ENTRY
GetUserNameOldW(
    LPWSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    NTSTATUS Status ;
    UNICODE_STRING String ;

    String.MaximumLength = (USHORT)(*nSize * sizeof(WCHAR));
    String.Buffer = lpNameBuffer ;

    Status = SecpGetUserName(
                    (ULONG) NameSamCompatible |
                        SPM_NAME_OPTION_NT4_ONLY,
                    &String );

    if ( NT_SUCCESS( Status ) )
    {
        *nSize = String.Length / sizeof(WCHAR) ;
        lpNameBuffer[ *nSize ] = L'\0';
    }
    else
    {
        if ( Status == STATUS_BUFFER_OVERFLOW )
        {
            *nSize = String.Length / sizeof(WCHAR) + 1;
        }

        SecpSetLastNTError( Status );
    }

    return NT_SUCCESS( Status );

}

//+---------------------------------------------------------------------------
//
//  Function:   GetUserNameExW
//
//  Synopsis:   Public:  Get Current Username in different formats
//
//  Arguments:  [NameFormat]   --
//              [lpNameBuffer] --
//              [nSize]        --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
GetUserNameExW (
    EXTENDED_NAME_FORMAT  NameFormat,
    LPWSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    NTSTATUS Status ;
    UNICODE_STRING String ;

    String.MaximumLength = (USHORT)(*nSize * sizeof(WCHAR));
    String.Buffer = lpNameBuffer ;

    Status = SecpGetUserName(
                    NameFormat,
                    &String );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // For reasons unclear, some APIs return the length needed as including
        // the trailing NULL for failure only.  Others return it for both
        // success and failure.  GetUserName() is one such API (unlike, say,
        // GetComputerName).  So, if the flag is set saying "this is old GetUserName
        // calling", adjust the return size appropriately.  Note:  do *not* try
        // to make one or the other APIs behave consistently.  Apps will cache
        // based on this length, and they break if the length isn't correct.
        //

        if ( (DWORD) NameFormat & SPM_NAME_OPTION_NT4_ONLY )
        {
            *nSize = String.Length / sizeof(WCHAR) + 1;

            //
            // Ensure we don't overflow the buffer
            //

            if (String.Length < String.MaximumLength)
            {
                lpNameBuffer[ *nSize - 1 ] = L'\0';
            }
            else
            {
                Status = STATUS_BUFFER_TOO_SMALL;
                SecpSetLastNTError(Status);
            }
        }
        else
        {
            *nSize = String.Length / sizeof(WCHAR) ;

            //
            // Ensure we don't overflow the buffer
            //

            if (String.Length < String.MaximumLength)
            {
                lpNameBuffer[ *nSize ] = L'\0';
            }
            else
            {
                *nSize += 1;
                Status = STATUS_BUFFER_OVERFLOW;
                SecpSetLastNTError(Status);
            }
        }
    }
    else
    {
        if ( Status == STATUS_BUFFER_OVERFLOW )
        {
            *nSize = String.Length / sizeof(WCHAR) + 1;

            //
            // Another GetUserName oddity.  The API, while not spec'd as such,
            // must return ERROR_INSUFFICIENT_BUFFER, otherwise some code, like
            // MPR, breaks.  Translate the status appropriately.
            //
            if ( (DWORD) NameFormat & SPM_NAME_OPTION_NT4_ONLY )
            {
                Status = STATUS_BUFFER_TOO_SMALL ;
            }
        }

        if ( Status != STATUS_UNSUCCESSFUL )
        {
            SecpSetLastNTError( Status );
        }
    }

    return NT_SUCCESS( Status );
}



//+---------------------------------------------------------------------------
//
//  Function:   GetComputerObjectNameW
//
//  Synopsis:   Public:  Get computer name in different formats
//
//  Arguments:  [NameFormat]   --
//              [lpNameBuffer] --
//              [nSize]        --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
GetComputerObjectNameW (
    EXTENDED_NAME_FORMAT  NameFormat,
    LPWSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    UNICODE_STRING UserName ;
    UNICODE_STRING DomainName ;
    NTSTATUS Status ;
    BOOL bRet ;
    WCHAR LocalName[ 64 ];
    PWSTR Local ;

    //
    // Get the user name from the LSA
    //

    if ( NameFormat == NameUnknown )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE ;
    }

    Status = GetFullMachineName( &UserName, &DomainName );

    if (!NT_SUCCESS(Status)) {
        SecpSetLastNTError( Status );
        return( FALSE );
    }

    if ( NameFormat != NameSamCompatible )
    {
        //
        // They want something that is not the default sam name.  Find
        // the DC for their domain, and do the lookup there:
        //
        if ( ((UserName.Length + DomainName.Length + 4) / sizeof(WCHAR) )
                    < 64 )
        {
            Local = LocalName ;

            RtlCopyMemory( Local,
                           DomainName.Buffer,
                           DomainName.Length );

            Local += DomainName.Length / sizeof(WCHAR) ;

            *Local++ = L'\\';

            RtlCopyMemory( Local,
                           UserName.Buffer,
                           UserName.Length + 2 );


        }

        bRet = SecpTranslateName( DomainName.Buffer,
                                  LocalName,
                                  NameSamCompatible,
                                  NameFormat,
                                  lpNameBuffer,
                                  nSize );

    }
    else
    {
        if ( ((UserName.Length + DomainName.Length + 4) / sizeof(WCHAR) )
                    <= *nSize )
        {
            RtlCopyMemory( lpNameBuffer,
                           DomainName.Buffer,
                           DomainName.Length );

            lpNameBuffer += DomainName.Length / sizeof(WCHAR) ;

            *lpNameBuffer++ = L'\\';

            RtlCopyMemory( lpNameBuffer,
                           UserName.Buffer,
                           UserName.Length + 2 );

            bRet = TRUE ;

        }
        else
        {

            SecpSetLastNTError( STATUS_BUFFER_TOO_SMALL );

            bRet = FALSE ;
        }

        *nSize = (UserName.Length + DomainName.Length + 4) / sizeof(WCHAR) ;
    }

    RtlFreeUnicodeString( &UserName );
    LocalFree( DomainName.Buffer );

    return ( bRet != 0 );

}

//+---------------------------------------------------------------------------
//
//  Function:   TranslateNameW
//
//  Synopsis:   Public:  Translate a name
//
//  Arguments:  [lpAccountName]     --
//              [AccountNameFormat] --
//              [DesiredNameFormat] --
//              [lpTranslatedName]  --
//              [nSize]             --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
TranslateNameW (
    LPCWSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPWSTR lpTranslatedName,
    LPDWORD nSize
    )
{
    if ( DesiredNameFormat == NameUnknown )
    {
        SetLastError( ERROR_INVALID_PARAMETER );

        return FALSE ;
    }

    return ( SecpTranslateName( NULL,
                                lpAccountName,
                                AccountNameFormat,
                                DesiredNameFormat,
                                lpTranslatedName,
                                nSize ) != 0 );
}


//+---------------------------------------------------------------------------
//
//  Function:   GetUserNameExA
//
//  Synopsis:   Public:  ANSI entrypoint
//
//  Arguments:  [NameFormat]   --
//              [lpNameBuffer] --
//              [nSize]        --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
GetUserNameExA (
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPWSTR UnicodeBuffer;

    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = (PWSTR) RtlAllocateHeap(RtlProcessHeap(), 0, *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Set up an ANSI_STRING that points to the user's buffer
    //

    AnsiString.MaximumLength = (USHORT) *nSize;
    AnsiString.Length = 0;
    AnsiString.Buffer = lpNameBuffer;


    //
    // Let the unicode version do the work:
    //

    if (!GetUserNameExW( NameFormat, UnicodeBuffer, nSize )) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        
        //
        // In the MBCS case, the count of characters isn't the same as the
        // count of bytes -- return a worst-case size.
        //

        *nSize *= sizeof(WCHAR);

        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);
    RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

    *nSize = AnsiString.Length + 1;
    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(TRUE);


}

//+---------------------------------------------------------------------------
//
//  Function:   GetComputerObjectNameExA
//
//  Synopsis:   Public:  ANSI entrypoint
//
//  Arguments:  [NameFormat]   --
//              [lpNameBuffer] --
//              [nSize]        --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
GetComputerObjectNameA (
    EXTENDED_NAME_FORMAT  NameFormat,
    LPSTR lpNameBuffer,
    LPDWORD nSize
    )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    LPWSTR UnicodeBuffer;

    //
    // Work buffer needs to be twice the size of the user's buffer
    //

    UnicodeBuffer = (PWSTR) RtlAllocateHeap(RtlProcessHeap(), 0, *nSize * sizeof(WCHAR));
    if (!UnicodeBuffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    //
    // Set up an ANSI_STRING that points to the user's buffer
    //

    AnsiString.MaximumLength = (USHORT) *nSize;
    AnsiString.Length = 0;
    AnsiString.Buffer = lpNameBuffer;


    //
    // Let the unicode version do the work:
    //

    if (!GetComputerObjectNameW( NameFormat, UnicodeBuffer, nSize )) {
        RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);
    RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);

    *nSize = AnsiString.Length + 1;
    RtlFreeHeap(RtlProcessHeap(), 0, UnicodeBuffer);
    return(TRUE);


}


//+---------------------------------------------------------------------------
//
//  Function:   TranslateNameA
//
//  Synopsis:   Public:  ANSI entrypoint
//
//  Arguments:  [lpAccountName]     --
//              [AccountNameFormat] --
//              [DesiredNameFormat] --
//              [lpTranslatedName]  --
//              [nSize]             --
//
//  History:    1-14-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOLEAN
SEC_ENTRY
TranslateNameA (
    LPCSTR lpAccountName,
    EXTENDED_NAME_FORMAT AccountNameFormat,
    EXTENDED_NAME_FORMAT DesiredNameFormat,
    LPSTR lpTranslatedName,
    LPDWORD nSize
    )
{
    ANSI_STRING AnsiString ;
    UNICODE_STRING UnicodeString ;
    NTSTATUS Status ;
    UNICODE_STRING ReturnString ;
    PWSTR UnicodeBuffer ;
    BOOLEAN bRet ;

    RtlInitAnsiString( &AnsiString, lpAccountName );

    Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                           &AnsiString,
                                           TRUE);

    if ( !NT_SUCCESS(Status) )
    {
        SecpSetLastNTError(Status);

        return FALSE;
    }

    UnicodeBuffer = (PWSTR) RtlAllocateHeap( RtlProcessHeap(),
                                     0,
                                     *nSize * sizeof( WCHAR ) );

    if ( !UnicodeBuffer )
    {
        RtlFreeUnicodeString( &UnicodeString );

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );

        return FALSE ;
    }


    AnsiString.MaximumLength = (USHORT) *nSize ;
    AnsiString.Length = 0 ;
    AnsiString.Buffer = lpTranslatedName ;

    bRet = TranslateNameW( UnicodeString.Buffer,
                         AccountNameFormat,
                         DesiredNameFormat,
                         UnicodeBuffer,
                         nSize );

    RtlFreeUnicodeString( &UnicodeString );

    if ( bRet )
    {
        RtlInitUnicodeString( &UnicodeString,
                              UnicodeBuffer );

        RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );

        *nSize = AnsiString.Length + 1;


    }

    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );

    return bRet ;

}

VOID
SecpFreeMemory(
    PVOID p
    )
{
    LocalFree( p );
}

BOOLEAN
WINAPI
SecpTranslateNameExWorker(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT *DesiredSelection,
    ULONG  DesiredCount,
    PWSTR **TranslatedNames,
    BOOL DoDiscoveryWithAccount,
    PBOOL NoSuchUser
    )
/*++

    DoDiscoveryWithAccount -- If TRUE, the (expensive) DC discovery with
        account will be attempted. Otherwise, the plain discovery w/o
        account will be attempted. The caller should specify FALSE on
        the first attempt to call this routine to minimize the performance
        hit. If this routine fails because the discovered DC doesn't have
        the specified account (as indicated by the NoSuchUser parameter),
        the caller should repeate the call passing TRUE for this parameter.

    NoSuchUser -- If this routine fails, this parameter will indicate
        whether the failure was due to the lack of the account on the
        discovered DC. This parameter is ignored if the routine succeeds.

--*/
{
    DWORD NetStatus ;
    PDOMAIN_CONTROLLER_INFOW DcInfo  = NULL;
    HANDLE DcHandle ;
    ULONG RetryLimit ;
    PDS_NAME_RESULTW Results ;
    NTSTATUS Status = STATUS_CANT_ACCESS_DOMAIN_INFO ;
    ULONG LengthRequired ;
    BOOL bRet = FALSE ;
    BOOL UseNetStatus = TRUE ;
    BOOL LocalNoSuchUser = FALSE ;
    PWSTR Scan = (PWSTR) Name ;
    PWSTR Dollar ;
    ULONG Bits = 0 ;
    ULONG i;

    I_RPCMAPWIN32STATUS pI_RpcMapWin32Status ;

    //
    // Note:  Status is initialized to can't access domain info because if there
    // is a series of network problems after finding a DC, we bail out of the loop
    // after some retries, and Status would be uninitialized.
    //

    pI_RpcMapWin32Status = (I_RPCMAPWIN32STATUS) GetProcAddress( GetModuleHandle(L"rpcrt4.dll"),
                                                                 "I_RpcMapWin32Status" );

    //
    // This is the only kind this function handles with respect
    // to error codes from CrackNames
    //
    ASSERT( Supplied == NameSamCompatible );

    //
    //  Prepare the out parameter
    //
    ASSERT( TranslatedNames );
    (*TranslatedNames) = (PWSTR*) LocalAlloc( LMEM_ZEROINIT, DesiredCount*sizeof(WCHAR*) );
    if ( !(*TranslatedNames) )
    {

        SecpSetLastNTError( STATUS_NO_MEMORY );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }


    //
    // Discover the DC as directed by the caller
    //

    if ( DoDiscoveryWithAccount ) {

        Scan = wcschr( Name, L'\\' );
        if ( Scan )
        {
            Scan++ ;
        }
        else
        {
            Scan = (PWSTR) Name ;
        }

        Bits = UF_NORMAL_ACCOUNT ;

        Dollar = wcschr( Scan, L'$' );

        if ( Dollar )
        {
            Bits |= UF_MACHINE_ACCOUNT_MASK ;
        }

        NetStatus = DsGetDcNameWithAccountW(
                                NULL,
                                Scan,
                                Bits,
                                Domain ? Domain : L"",
                                NULL,
                                NULL,
                                DS_DIRECTORY_SERVICE_REQUIRED |
                                    DS_RETURN_DNS_NAME |
                                    DS_IS_FLAT_NAME,
                                &DcInfo );
    } else {

        NetStatus = DsGetDcNameW( NULL,
                                  Domain ? Domain : L"",
                                  NULL,
                                  NULL,
                                  DS_DIRECTORY_SERVICE_REQUIRED |
                                    DS_RETURN_DNS_NAME |
                                    DS_IS_FLAT_NAME,
                                  &DcInfo );
    }

    if ( NetStatus != 0 )
    {
        //
        // No DS DC available, therefore no name translation:
        //

        SecpSetLastNTError( STATUS_UNSUCCESSFUL );

        SetLastError( NetStatus );

        bRet = FALSE;

        goto Exit;

    }

    DebugLog((DEB_TRACE_GETUSER, "Trying to bind to %ws\n", DcInfo->DomainControllerName));
    while ( *DcInfo->DomainControllerName == L'\\' )
    {
        DcInfo->DomainControllerName ++ ;
    }

    NetStatus = DsBind( DcInfo->DomainControllerName,
                         NULL,
                         &DcHandle );

    if ( NetStatus != 0 )
    {
        //
        // Error mapping tricks.  Some win32 errors have
        // this format.
        //

        if ( NetStatus <= 0x80000000 )
        {
            Status = NtCurrentTeb()->LastStatusValue ;

            if ( pI_RpcMapWin32Status )
            {
                Status = pI_RpcMapWin32Status( NetStatus );

                if ( NT_SUCCESS( Status ) )
                {
                    //
                    // Didn't map.  Treat as a win32 error
                    //

                    UseNetStatus = TRUE ;

                    Status = STATUS_UNSUCCESSFUL ;
                }
            }

        }
        else
        {
            UseNetStatus = TRUE ;

            Status = STATUS_UNSUCCESSFUL ;
        }


        DebugLog(( DEB_ERROR, "DsBind to %ws failed, %x (%d)\n",
                   DcInfo->DomainControllerName,
                   NetStatus,
                   UseNetStatus ));

        bRet = FALSE;

        goto Exit;

    }

    //
    // Got a connection.  Crack the names:
    //

    Status = STATUS_SUCCESS;
    for ( i = 0; (i < DesiredCount) && NT_SUCCESS(Status); i++ )
    {

        NetStatus = DsCrackNames(DcHandle,
                                  DS_NAME_NO_FLAGS,
                                  (DS_NAME_FORMAT) Supplied,
                                  (DS_NAME_FORMAT) DesiredSelection[i],
                                  1,
                                  &Name,
                                  &Results );

        //
        // Now, see what happened:
        //

        if ( NetStatus == 0 )
        {
            //
            // So far, so good.  See if the name got xlated:
            //
            if ( Results->cItems >= 1 )
            {
                Status = SecpMapDsNameError( Results->rItems[0].status );

                if ( NT_SUCCESS( Status ) )
                {
                    //
                    // Mapped the name
                    //

                    LengthRequired = wcslen( Results->rItems[0].pName ) + 1;

                    (*TranslatedNames)[i] = (PWSTR) LocalAlloc( LMEM_ZEROINIT, LengthRequired*sizeof(WCHAR) );
                    if ( (*TranslatedNames)[i] ) {

                        RtlCopyMemory( (*TranslatedNames)[i],
                                       Results->rItems[0].pName,
                                       LengthRequired * sizeof( WCHAR ) );

                    } else {

                        Status = STATUS_NO_MEMORY;
                    }
                }

                //
                // If there is no such user on the DC,
                //  tell the caller to retry to find a
                //  DC that has the user account
                //
                else if ( Status == STATUS_NO_SUCH_USER )
                {
                    LocalNoSuchUser = TRUE;
                }
            }
            else
            {
                DebugLog((DEB_ERROR, "CrackName did not return useful stuff. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_CANT_ACCESS_DOMAIN_INFO;
            }

            DsFreeNameResult( Results );

        } else {

            Status = STATUS_UNSUCCESSFUL;
            UseNetStatus = TRUE;
        }

    }

    if ( NT_SUCCESS( Status ) )
    {
        bRet = TRUE;
    }

    //
    // We are done with the connection
    //

    (VOID) DsUnBind( &DcHandle );

Exit:

    if ( DcInfo )
    {
        NetApiBufferFree( DcInfo );
    }

    if ( !bRet )
    {
        //
        // Free out parameters
        //
        for ( i = 0; i < DesiredCount; i++ )
        {
            if ( (*TranslatedNames)[i] ) LocalFree( (*TranslatedNames)[i] );
        }

        LocalFree( (*TranslatedNames) );
        *TranslatedNames = NULL;

        if ( UseNetStatus ||
             NT_SUCCESS( Status )  )
        {
            NtCurrentTeb()->LastStatusValue = STATUS_UNSUCCESSFUL;
            SetLastError( NetStatus );
        }
        else
        {
            NtCurrentTeb()->LastStatusValue = Status;
            SetLastError( RtlNtStatusToDosError(Status) );
        }

        //
        // Tell the caller whether we failed
        //  because the DC didn't have the account
        //
        *NoSuchUser = LocalNoSuchUser;
    }

    return (bRet != 0);

}

BOOLEAN
WINAPI
SecpTranslateNameEx(
    PWSTR Domain,
    LPCWSTR Name,
    EXTENDED_NAME_FORMAT Supplied,
    EXTENDED_NAME_FORMAT *DesiredSelection,
    ULONG  DesiredCount,
    PWSTR **TranslatedNames
    )
{
    BOOLEAN Result;
    BOOL NoSuchUser = FALSE;

    //
    // First try to discover a DC without specifying
    // the account as discoveries with account are
    // too expensive performance-wise. If it turns
    // out that the discovered DC doesn't have the
    // account, we will retry the discovery specifying
    // the account name next.
    //

    Result = SecpTranslateNameExWorker(
                         Domain,
                         Name,
                         Supplied,
                         DesiredSelection,
                         DesiredCount,
                         TranslatedNames,
                         FALSE,  // discovery w/o account
                         &NoSuchUser );

    if ( !Result && NoSuchUser ) {
        Result = SecpTranslateNameExWorker(
                         Domain,
                         Name,
                         Supplied,
                         DesiredSelection,
                         DesiredCount,
                         TranslatedNames,
                         TRUE,  // discovery w/ account
                         &NoSuchUser );
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\context.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.cxx
//
//  Contents:   Context List functions
//
//  Classes:
//
//  Functions:
//
//  History:    4-29-98   RichardW   Created
//
//----------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "context.h"

VOID
KSecInsertListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry
    );

NTSTATUS
KSecReferenceListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry,
    ULONG Signature,
    BOOLEAN RemoveNoRef
    );

VOID
KSecDereferenceListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry,
    BOOLEAN * Delete OPTIONAL
    );
}

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag( a, b, CONTEXT_TAG )
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag( a, b, CONTEXT_TAG )
#endif

#if DBG
#define KsecDebugValidateList( List, Entry )   KsecpValidateList( List, Entry )
#else
#define KsecDebugValidateList( List, Entry )
#endif


#pragma alloc_text(PAGEMSG, KSecCreateContextList)
#pragma alloc_text(PAGEMSG, KSecInsertListEntry)
#pragma alloc_text(PAGEMSG, KSecReferenceListEntry)
#pragma alloc_text(PAGEMSG, KSecDereferenceListEntry)

#pragma alloc_text(PAGE, KSecInsertListEntryPaged)
#pragma alloc_text(PAGE, KSecReferenceListEntryPaged)
#pragma alloc_text(PAGE, KSecDereferenceListEntryPaged)


//+---------------------------------------------------------------------------
//
//  Function:   KSecCreateContextList
//
//  Synopsis:   Creates a context list to be managed by the core ksec driver
//              on behalf of the packages.
//
//  Arguments:  [Type] -- indicates either paged or nonpaged
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
SEC_ENTRY
KSecCreateContextList(
    KSEC_CONTEXT_TYPE Type
    )
{
    PKSEC_CONTEXT_LIST ContextList ;

    ContextList = (PKSEC_CONTEXT_LIST) ExAllocatePool( NonPagedPool, sizeof( KSEC_CONTEXT_LIST ) );

    if ( ContextList )
    {
        ContextList->Type = Type ;

        InitializeListHead( &ContextList->List );

        ContextList->Count = 0 ;

        if ( Type == KSecPaged )
        {
            ExInitializeResourceLite( &ContextList->Lock.Paged );
        }
        else
        {
            KeInitializeSpinLock( &ContextList->Lock.NonPaged );
        }

    }

    return ContextList ;
}
//+---------------------------------------------------------------------------
//
//  Function:   KsecpValidateList
//
//  Synopsis:   Debug function to validate a list
//
//  Arguments:  [List]  --
//              [Entry] --
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#if DBG
VOID
KsecpValidateList(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry
    )
{
    ULONG Entries = 0;
    PLIST_ENTRY ListEntry;
    BOOLEAN FoundEntry ;

    if ( Entry )
    {
        FoundEntry = FALSE ;
        if ( List != (PKSEC_CONTEXT_LIST) Entry->OwningList )
        {
            DbgPrint( "KSEC: Supplied context and list do not match\n" );
            DbgBreakPoint();

        }
    }
    else
    {
        FoundEntry = TRUE ;
    }

    for (ListEntry = List->List.Flink ;
         ListEntry != &List->List ;
         ListEntry = ListEntry->Flink )
    {
        if ( ++Entries > List->Count ) {
            DbgPrint( "KSEC: Context List corrupt\n ");
            DbgBreakPoint();
            break;
        }
        if ( Entry == CONTAINING_RECORD( ListEntry, KSEC_LIST_ENTRY, List ) )
        {
            FoundEntry = TRUE ;
        }
    }

    if ( !FoundEntry )
    {
        DbgPrint( "KSEC: Context List did not contain expected entry %x\n", Entry );
        DbgBreakPoint();
    }

}

#endif

//+---------------------------------------------------------------------------
//
//  Function:   KSecInsertListEntryPaged
//
//  Synopsis:   paged (passive level) function for inserting into the context
//              list
//
//  Arguments:  [List]  -- List returned in KSecCreateContextList
//              [Entry] -- Entry to insert
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
KSecInsertListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry
    )
{
    PAGED_CODE();

    ASSERT( List->Type == KSecPaged );

    Entry->RefCount++ ;
    Entry->OwningList = List ;

    //
    // NTBUG 409213: use Enter and LeaveCriticalRegion around resource hold.
    // addresses case where caller hasn't disabled APCs (eg: serrdr).
    //

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( &List->Lock.Paged, TRUE );


    KsecDebugValidateList( List, NULL );

    InsertHeadList( &List->List, &Entry->List );
    List->Count++ ;

    KsecDebugValidateList( List, Entry );

    ExReleaseResourceLite( &List->Lock.Paged );
    KeLeaveCriticalRegion();
}

//+---------------------------------------------------------------------------
//
//  Function:   KSecInsertListEntry
//
//  Synopsis:   non paged (DPC level) function for inserting into the list
//
//  Arguments:  [hList] -- List to insert into
//              [Entry] -- Entry to insert
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SEC_ENTRY
KSecInsertListEntry(
    PVOID hList,
    PKSEC_LIST_ENTRY Entry
    )
{
    KIRQL OldIrql ;
    PKSEC_CONTEXT_LIST List = (PKSEC_CONTEXT_LIST) hList ;

    if ( List->Type == KSecPaged )
    {
        KSecInsertListEntryPaged( List, Entry );
        return ;
    }

    ASSERT( List->Type == KSecNonPaged );

    Entry->RefCount++ ;
    Entry->OwningList = List ;

    KeAcquireSpinLock( &List->Lock.NonPaged, &OldIrql );

    KsecDebugValidateList( List, NULL );

    InsertHeadList( &List->List, &Entry->List );
    List->Count++ ;

    KsecDebugValidateList( List, Entry );

    KeReleaseSpinLock( &List->Lock.NonPaged, OldIrql );

}


//+---------------------------------------------------------------------------
//
//  Function:   KSecReferenceListEntryPaged
//
//  Synopsis:   paged (passive level) function to reference a list entry
//
//  Arguments:  [List]        -- List that the context belongs to
//              [Entry]       -- Context entry to reference
//              [Signature]   -- Signature to check
//              [RemoveNoRef] -- If true, removes the entry from the list
//                               without referencing it.
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
KSecReferenceListEntryPaged(
    PKSEC_CONTEXT_LIST List,
    PKSEC_LIST_ENTRY Entry,
    IN ULONG Signature,
    IN BOOLEAN RemoveNoRef
    )
{
    PAGED_CODE();

    ASSERT( List->Type == KSecPaged );

    if ( ((PUCHAR) Entry) < ((PUCHAR) MM_USER_PROBE_ADDRESS) )
    {
        return STATUS_INVALID_HANDLE ;
    }

    if ( Entry->Signature != Signature )
    {
#if DBG
        DbgPrint( "KSEC: Signature trashed (%x != expected %x)\n",
                        Entry->Signature, Signature );
#endif
        return STATUS_INVALID_HANDLE ;
    }

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( &List->Lock.Paged, TRUE );

    if ( Entry->Signature != Signature )
    {
        ExReleaseResourceLite( &List->Lock.Paged );
        KeLeaveCriticalRegion();
#if DBG
        DbgPrint( "KSEC: Signature trashed, probably multi-free race condition (%x != expected %x)\n",
                        Entry->Signature, Signature );
#endif
        return STATUS_INVALID_HANDLE ;
    }

    KsecDebugValidateList( List, Entry );

    if ( !RemoveNoRef )
    {
        Entry->RefCount++ ;
    }
    else
    {
        RemoveEntryList( &Entry->List );

        List->Count-- ;

#if DBG
        if ( List->Count == 0 )
        {
            if ( !IsListEmpty( &List->List ) )
            {
                DbgPrint( "KSEC:  Context List corrupted\n" );
                DbgBreakPoint();
            }
        }
#endif

        Entry->List.Flink = Entry->List.Blink = NULL ;
        Entry->Signature &= 0x00FFFFFF ;
        Entry->Signature |= 0x78000000 ;        // Convert signature to a little 'x'

    }

    if ( RemoveNoRef )
    {
        KsecDebugValidateList( List, NULL );
    }
    else
    {
        KsecDebugValidateList( List, Entry );
    }

    ExReleaseResourceLite( &List->Lock.Paged );
    KeLeaveCriticalRegion();

    return STATUS_SUCCESS ;
}

//+---------------------------------------------------------------------------
//
//  Function:   KSecReferenceListEntry
//
//  Synopsis:   non paged (DPC level) function to dereference an entry
//
//  Arguments:  [Entry]       -- Entry to dereference
//              [Signature]   -- Signature to check for
//              [RemoveNoRef] -- Remove flag
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
KSecReferenceListEntry(
    IN PKSEC_LIST_ENTRY Entry,
    IN ULONG Signature,
    IN BOOLEAN RemoveNoRef
    )
{
    KIRQL OldIrql ;


    PKSEC_CONTEXT_LIST List ;

    //
    // may still be in user mode (not mapped yet)
    //

    if ( (ULONG_PTR) Entry < (ULONG_PTR) (MM_USER_PROBE_ADDRESS) )
    {
        return STATUS_INVALID_HANDLE ;
    }

    List = (PKSEC_CONTEXT_LIST) Entry->OwningList ;

    if ( List->Type == KSecPaged )
    {
        return KSecReferenceListEntryPaged( List, Entry, Signature, RemoveNoRef );
    }

    ASSERT( List->Type == KSecNonPaged );

    if ( ((PUCHAR) Entry) < ((PUCHAR) MM_USER_PROBE_ADDRESS) )
    {
        return STATUS_INVALID_HANDLE ;
    }

    if ( Entry->Signature != Signature )
    {
#if DBG
        DbgPrint( "KSEC: Signature trashed (%x != expected %x)\n",
                        Entry->Signature, Signature );
#endif
        return STATUS_INVALID_HANDLE ;
    }

    KeAcquireSpinLock( &List->Lock.NonPaged, &OldIrql );

    KsecDebugValidateList( List, Entry );

    if ( !RemoveNoRef )
    {
        Entry->RefCount++ ;
    }
    else
    {
        RemoveEntryList( &Entry->List );

        Entry->List.Flink = Entry->List.Blink = NULL ;
        Entry->Signature &= 0x00FFFFFF ;
        Entry->Signature |= 0x78000000 ;        // Convert signature to a big X
    }

    if ( RemoveNoRef )
    {
        KsecDebugValidateList( List, NULL );
    }
    else
    {
        KsecDebugValidateList( List, Entry );
    }

    KeReleaseSpinLock( &List->Lock.NonPaged, OldIrql );

    return STATUS_SUCCESS ;
}

//+---------------------------------------------------------------------------
//
//  Function:   KSecDereferenceListEntryPaged
//
//  Synopsis:   paged (passive level) function to dereference an entry
//
//  Arguments:  [List]   -- List for the entry
//              [Entry]  -- Entry
//              [Delete] -- Set to true if the entry should be deleted
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
KSecDereferenceListEntryPaged(
    IN PKSEC_CONTEXT_LIST List,
    IN PKSEC_LIST_ENTRY Entry,
    OUT BOOLEAN * Delete OPTIONAL
    )
{
    BOOLEAN ShouldDelete = FALSE ;

    PAGED_CODE();

    ASSERT( List->Type == KSecPaged );

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite( &List->Lock.Paged, TRUE );

#if DBG
    if ( Entry->List.Flink )
    {
        KsecDebugValidateList( List, Entry );
    }
    else
    {
        KsecDebugValidateList( List, NULL );
    }
#endif

    Entry->RefCount-- ;

    if ( Entry->RefCount == 0 )
    {
        ShouldDelete = TRUE ;
    }

#if DBG
    if ( Entry->List.Flink )
    {
        KsecDebugValidateList( List, Entry );
    }
    else
    {
        KsecDebugValidateList( List, NULL );
    }
#endif

    ExReleaseResourceLite( &List->Lock.Paged );
    KeLeaveCriticalRegion();

    if ( Delete )
    {
        *Delete = ShouldDelete ;
    }

}

//+---------------------------------------------------------------------------
//
//  Function:   KSecDereferenceListEntry
//
//  Synopsis:   non-paged (DPC level) function to dereference a list entry
//
//  Arguments:  [Entry]  -- Entry to dereference
//              [Delete] -- Returned flag if entry should be deleted
//
//  History:    7-19-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
KSecDereferenceListEntry(
    IN PKSEC_LIST_ENTRY Entry,
    OUT BOOLEAN * Delete OPTIONAL
    )
{
    KIRQL OldIrql ;
    BOOLEAN ShouldDelete = FALSE ;
    PKSEC_CONTEXT_LIST List;

    List = (PKSEC_CONTEXT_LIST) Entry->OwningList ;

    if ( List->Type == KSecPaged )
    {
        KSecDereferenceListEntryPaged( List, Entry, Delete );
        return ;
    }

    ASSERT( List->Type == KSecNonPaged );

    KeAcquireSpinLock( &List->Lock.NonPaged, &OldIrql );

#if DBG
    if ( Entry->List.Flink )
    {
        KsecDebugValidateList( List, Entry );
    }
    else
    {
        KsecDebugValidateList( List, NULL );
    }
#endif

    Entry->RefCount-- ;

    if ( Entry->RefCount == 0 )
    {
        ShouldDelete = TRUE ;
    }

#if DBG
    if ( Entry->List.Flink )
    {
        KsecDebugValidateList( List, Entry );
    }
    else
    {
        KsecDebugValidateList( List, NULL );
    }
#endif

    KeReleaseSpinLock( &List->Lock.NonPaged, OldIrql );

    if ( Delete )
    {
        *Delete = ShouldDelete ;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\connmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        connmgr.h
//
// Contents:    Connection Manager code for KSecDD
//
//
// History:     3 Jun 92    RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __CONNMGR_H__
#define __CONNMGR_H__


BOOLEAN         InitConnMgr(void);
NTSTATUS        CreateClient(BOOLEAN, PClient *);
NTSTATUS        LocateClient(PClient *);
VOID    FreeClient( PClient );

extern  ULONG   KsecConnected ;
extern  KSPIN_LOCK ConnectSpinLock ;

#endif // __CONNMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\connmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        connmgr.c
//
// Contents:    Connection Manager code for KSecDD
//
//
// History:     3 Jun 92    RichardW    Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <zwapi.h>

#include "ksecdd.h"
#include "connmgr.h"


FAST_MUTEX  KsecConnectionMutex ;

BOOLEAN             fInitialized = 0;
PSTR                LogonProcessString = "KSecDD";
ULONG               KsecConnected = 0;

BOOLEAN
InitConnMgr(void);

SECURITY_STATUS
OpenSyncEvent(  HANDLE  *   phEvent);

} // extern "C"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, InitConnMgr)
#endif

//+-------------------------------------------------------------------------
//
//  Function:   InitConnMgr
//
//  Synopsis:   Initializes all this stuff
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
InitConnMgr(void)
{

    ExInitializeFastMutex( &KsecConnectionMutex );
    
    fInitialized = TRUE;

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Function:   OpenSyncEvent()
//
//  Synopsis:   Opens the sync event in the context of the calling FSP
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
OpenSyncEvent(  HANDLE  *   phEvent)
{
    OBJECT_ATTRIBUTES   EventObjAttr;
    UNICODE_STRING EventName;

    PAGED_CODE();

    RtlInitUnicodeString(
        &EventName,
        SPM_EVENTNAME);

    InitializeObjectAttributes(
        &EventObjAttr, 
        &EventName,
        OBJ_CASE_INSENSITIVE, 
        NULL, 
        NULL);

    return(ZwOpenEvent(phEvent, EVENT_ALL_ACCESS, &EventObjAttr));

}


//+-------------------------------------------------------------------------
//
//  Function:   CreateClient
//
//  Synopsis:   Creates a client representing this caller.  Establishes
//              a connection with the SPM.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
CreateClient(
    BOOLEAN     ConnectAsKsec,
    PClient *   ppClient)
{
    NTSTATUS    scRet;
    KIRQL       OldIrql;
    HANDLE      hEvent;
    LSA_OPERATIONAL_MODE LsaMode;
    STRING      LogonProcessName;
    ULONG   PackageCount;
    HANDLE hIgnored ;

    if ( PsGetProcessId( PsGetCurrentProcess() ) !=
         PsGetThreadProcessId( PsGetCurrentThread() ) )
    {
        return STATUS_ACCESS_DENIED ;
    }

    if ( PsGetProcessSecurityPort( PsGetCurrentProcess() ) == ((PVOID) 1) )
    {
        return STATUS_PROCESS_IS_TERMINATING ;
    }


    scRet = OpenSyncEvent(&hEvent);

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"KSec:  Failed to open event, %x\n", scRet));
        scRet = SEC_E_INTERNAL_ERROR;
        goto Cleanup;
    }


    //
    // Okay, now wait to make sure the LSA has started:
    //

    scRet = NtWaitForSingleObject(hEvent, TRUE, NULL);

    if (!NT_SUCCESS(scRet))
    {
        scRet = SEC_E_INTERNAL_ERROR;

        goto Cleanup;
    }

    (void) NtClose(hEvent);


    scRet = CreateConnection( (ConnectAsKsec ? LogonProcessString : NULL),
                              LSAP_AU_KERNEL_CLIENT,
                              &hIgnored,
                              &PackageCount,
                              &LsaMode );



    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"KSec: Connection failed, postponing\n"));
        scRet = SEC_E_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // This is atomic, and the queries are always safe, anyway.
    //

    KsecConnected = 1;

    InitializePackages( PackageCount );

    return(STATUS_SUCCESS);

Cleanup:
    return(scRet);

}

//+-------------------------------------------------------------------------
//
//  Function:   LocateClient
//
//  Synopsis:   Locates a client record based on current process Id
//
//  Effects:    Grabs ConnectSpinLock for duration of search.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LocateClient(   PClient *   ppClient)
{
    PEPROCESS pCurrent;
    PVOID Port ;

    *ppClient = NULL;

    ExAcquireFastMutex( &KsecConnectionMutex );

    pCurrent = PsGetCurrentProcess();

    Port = PsGetProcessSecurityPort( pCurrent );

    ExReleaseFastMutex( &KsecConnectionMutex );


    if ( ( Port != NULL ) && 
         ( Port != (PVOID) 1 ) )
    {
        return STATUS_SUCCESS ;
    }
    else 
    {
        return STATUS_OBJECT_NAME_NOT_FOUND ;
    }

}


VOID
FreeClient(
    PClient ignored
    )
{
    return ;

    UNREFERENCED_PARAMETER( ignored );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\context.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4-29-98   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __CONTEXT_H__
#define __CONTEXT_H__

#define CONTEXT_TAG 'LCeS'

typedef struct _KSEC_CONTEXT_LIST {
    KSEC_CONTEXT_TYPE Type ;                // Type (Paged or NonPaged)
    LIST_ENTRY List ;                       // List of context records
    ULONG Count ;                           // Count of context records
    union {
        ERESOURCE   Paged ;                 // Lock used when paged
        KSPIN_LOCK  NonPaged ;              // Lock used when non-paged
    } Lock ;
} KSEC_CONTEXT_LIST, * PKSEC_CONTEXT_LIST ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\defer.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       defer.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-23-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <ntifs.h>

#define SECURITY_KERNEL
#define SECURITY_PACKAGE
#include <secpkg.h>
#include <winerror.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"

#define KSEC_DEFERRED_TAG   'DceS'

typedef struct _KSecDeferredCall {
    WORK_QUEUE_ITEM Item;
    SecHandle       Handle;
    ULONG           Tag;
    ULONG           CallCode;
} KSecDeferredCall , * PKSecDeferredCall;


VOID
SecpDeferredCloseCall(
    PVOID       pvParameter)
{
    PKSecDeferredCall   pCall;
    BOOLEAN             Attached;
    KAPC_STATE          ApcState ;

    pCall = (PKSecDeferredCall) pvParameter;

    if (pCall->Tag != KSEC_DEFERRED_TAG)
    {
        ExFreePool(pCall);
        return;
    }

    KeStackAttachProcess( 
        KsecLsaProcess,
        &ApcState );


    if (pCall->CallCode == SPMAPI_DeleteContext)
    {
        DeleteSecurityContextInternal( FALSE, &pCall->Handle);
    }
    else if (pCall->CallCode == SPMAPI_FreeCredHandle)
    {
        FreeCredentialsHandleInternal( &pCall->Handle );
    }
    else 
    {
        NOTHING ;

    }

    KeUnstackDetachProcess( &ApcState );

    ExFreePool(pCall);

}



SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextDefer(
    PCtxtHandle     phContext)
{

    PKSecDeferredCall   pCall;


    pCall = (PKSecDeferredCall) ExAllocatePool( NonPagedPool,
                                                sizeof(KSecDeferredCall) );

    if (!pCall)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    ExInitializeWorkItem(
        &pCall->Item, 
        SecpDeferredCloseCall, 
        pCall );

    pCall->Tag = KSEC_DEFERRED_TAG;

    pCall->Handle = *phContext;

    pCall->CallCode = SPMAPI_DeleteContext;

    ExQueueWorkItem((PWORK_QUEUE_ITEM) pCall, DelayedWorkQueue);

    return(SEC_E_OK);

}


SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandleDefer(
    PCredHandle     phCredential)
{

    PKSecDeferredCall   pCall;


    pCall = (PKSecDeferredCall) ExAllocatePool( NonPagedPool,
                                                sizeof(KSecDeferredCall) );

    if (!pCall)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    ExInitializeWorkItem(&pCall->Item, SecpDeferredCloseCall, pCall);

    pCall->Tag = KSEC_DEFERRED_TAG;

    pCall->Handle = *phCredential;

    pCall->CallCode = SPMAPI_FreeCredHandle;

    ExQueueWorkItem((PWORK_QUEUE_ITEM) pCall, DelayedWorkQueue);

    return(SEC_E_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\encmem.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    encmem.cxx

Abstract:

    This module contains the support code for memory encryption/decryption.

Author:

    Scott Field (SField) 09-October-2000

Revision History:

--*/

#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>

#include "ksecdd.h"

#include "randlib.h"

}

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, KsecEncryptMemory )
#pragma alloc_text( PAGE, KsecEncryptMemoryInitialize )
#pragma alloc_text( PAGE, KsecEncryptMemoryShutdown )
#endif 

//
// note: g_DESXKey defaults to non-paged .bss/.data section.  by design!
//

DESXTable g_DESXKey;
unsigned __int64 RandomSalt;
BOOLEAN InitializedMemory;

NTSTATUS
NTAPI
KsecEncryptMemory(
    IN PVOID pMemory,
    IN ULONG cbMemory,
    IN int Operation,
    IN ULONG Option
    )
{
    PUCHAR pbIn;
    ULONG BlockCount;
    unsigned __int64 feedback;

    PAGED_CODE();

    if( (cbMemory & (DESX_BLOCKLEN-1)) != 0 )
    {
        return STATUS_INVALID_PARAMETER;
    }

    if( !InitializedMemory )
    {
        NTSTATUS Status = KsecEncryptMemoryInitialize();

        if(!NT_SUCCESS(Status))
        {
            return Status;
        }
    }

    switch (Option)
    {
        case (0):
        {
            //
            // IV is the process creation time.
            // This will prevent memory from being decryptable across processes.
            //

            feedback = (unsigned __int64)PsGetProcessCreateTimeQuadPart( PsGetCurrentProcess() );
            break;
        }

        case (RTL_ENCRYPT_OPTION_CROSS_PROCESS):
        {
            feedback = RandomSalt;
            break;
        }
        case (RTL_ENCRYPT_OPTION_SAME_LOGON):
        {
            SECURITY_SUBJECT_CONTEXT SubjectContext;
            unsigned __int64 LogonId;
            NTSTATUS Status;

            SeCaptureSubjectContext( &SubjectContext );
            SeLockSubjectContext( &SubjectContext );

//
//      Return the effective token from a SecurityContext
//

#define EffectiveToken( SubjectSecurityContext ) (                           \
                (SubjectSecurityContext)->ClientToken ?                      \
                (SubjectSecurityContext)->ClientToken :                      \
                (SubjectSecurityContext)->PrimaryToken                       \
                )

            Status = SeQueryAuthenticationIdToken(
                                    EffectiveToken(&SubjectContext),
                                    (LUID*)&LogonId
                                    );

            SeUnlockSubjectContext( &SubjectContext );
            SeReleaseSubjectContext( &SubjectContext );

            if( !NT_SUCCESS(Status) )
            {
                return Status;
            }

            feedback = RandomSalt;
            feedback ^= LogonId;
            break;
        }

        default:
        {
            return STATUS_INVALID_PARAMETER;
        }
    }

    BlockCount = cbMemory / DESX_BLOCKLEN;
    pbIn = (PUCHAR)pMemory;

    while( BlockCount-- )
    {
        CBC(
            desx,                       // desx is the cipher routine
            DESX_BLOCKLEN,
            pbIn,                       // result buffer.
            pbIn,                       // input buffer.
            &g_DESXKey,
            Operation,
            (unsigned char*)&feedback
            );

        pbIn += DESX_BLOCKLEN;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
NTAPI
KsecEncryptMemoryInitialize(
    VOID
    )
{
    UCHAR Key[ DESX_KEYSIZE ];
    unsigned __int64 Salt;

    PAGED_CODE();

    if(!NewGenRandom( NULL, NULL, Key, sizeof(Key) ))
    {
        return STATUS_UNSUCCESSFUL;
    }

    if(!NewGenRandom( NULL, NULL, (unsigned char*)&Salt, sizeof(Salt) ))
    {
        return STATUS_UNSUCCESSFUL;
    }

    ExAcquireFastMutex( &KsecConnectionMutex );

    if( !InitializedMemory )
    {
        desxkey( &g_DESXKey, Key );
        RtlCopyMemory( &RandomSalt, &Salt, sizeof(RandomSalt) );
        InitializedMemory = TRUE;
    }

    ExReleaseFastMutex( &KsecConnectionMutex );

    RtlZeroMemory( Key, sizeof(Key) );

    return STATUS_SUCCESS;
}

VOID
KsecEncryptMemoryShutdown(
    VOID
    )
{
    PAGED_CODE();

    RtlZeroMemory( &g_DESXKey, sizeof(g_DESXKey) );
    InitializedMemory = FALSE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\efs.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        efs.cxx
//
// Contents:    kernel mode EFS API, called by efs.sys
//
//
// History:     3/5/94      RobertRe      Created
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include <efsstruc.h>
#include <lpcefs.h>
#include "ksecdd.h"
#include "connmgr.h"

SECURITY_STATUS
MapContext( PCtxtHandle     pctxtHandle);
}



extern "C"
NTSTATUS
EfsGenerateKey(
    PEFS_KEY  * Fek,
    PEFS_DATA_STREAM_HEADER * EfsStream,
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    ULONG DirectoryEfsStreamLength,
    PVOID * BufferBase,
    PULONG BufferLength
    )

/*++

Routine Description:

    This routine generates an FEK and an EFS stream in
    response to a call from the driver.

Arguments:

    Fek -

    EfsStream -

    DirectoryEfsStream -

    DirectoryEfsStreamLength -

    BufferBase -

    BufferLength -


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    NTSTATUS Status;

    Status = EfspGenerateKey(
               EfsStream,
               DirectoryEfsStream,
               DirectoryEfsStreamLength,
               Fek,
               BufferBase,
               BufferLength
               );

    return( Status );
}

extern "C"
NTSTATUS
GenerateDirEfs(
    PEFS_DATA_STREAM_HEADER DirectoryEfsStream,
    ULONG DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID * BufferBase,
    PULONG BufferLength
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    NTSTATUS Status;

    Status = EfspGenerateDirEfs(
                 DirectoryEfsStream,
                 DirectoryEfsStreamLength,
                 NewEfs,
                 BufferBase,
                 BufferLength);

    return( Status );
}




NTSTATUS
EfsDecryptFek(
    IN OUT PEFS_KEY * Fek,
    IN PEFS_DATA_STREAM_HEADER CurrentEfs,
    ULONG EfsStreamLength,
    IN ULONG OpenType,                      //Normal, Recovery or Backup
    OUT PEFS_DATA_STREAM_HEADER *NewEfs,     //In case the DDF, DRF are changed
    PVOID * BufferBase,
    PULONG BufferLength
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    NTSTATUS Status;

    //
    //  Do not touch anything in CurrentEfs. We are not in LSA process and CurrentEfs is in LSA.
    //

    Status = EfspDecryptFek(
                Fek,
                CurrentEfs,
                EfsStreamLength,
                OpenType,
                NewEfs,
                BufferBase,
                BufferLength
                );

    return( Status );
}


extern "C"
NTSTATUS
GenerateSessionKey(
    OUT PEFS_INIT_DATAEXG InitDataExg
    )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/
{
    NTSTATUS Status;

    Status = EfspGenerateSessionKey(
               InitDataExg
               );

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\extapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        extapi.cxx
//
// Contents:    user-mode stubs for security extension APIs
//
//
// History:     3-5-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
}





HRESULT SEC_ENTRY
GetSecurityUserInfo(    PLUID                   pLogonId,
                        ULONG                   fFlags,
                        PSecurityUserData *     ppUserInfo)
{
    return(SecpGetUserInfo(pLogonId,fFlags,ppUserInfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\ksecdd.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KSECDD.H
//
// Contents:    Structures and defines for the security device driver
//
//
// History:     19 May 92,  RichardW    Created
//
//------------------------------------------------------------------------

#ifndef __KSECDD_H__
#define __KSECDD_H__


//#include <ntosp.h>


#if ( _X86_ )
#undef MM_USER_PROBE_ADDRESS

extern ULONG KsecUserProbeAddress ;

#define MM_USER_PROBE_ADDRESS KsecUserProbeAddress

#endif

#include <spseal.h>     // prototypes for seal & unseal
#include <lpcapi.h>

#include <des.h>
#include <modes.h>

typedef struct _SEC_BUILTIN_KPACKAGE {
    PSECPKG_KERNEL_FUNCTION_TABLE   Table;
    PUNICODE_STRING Name;
    ULONG_PTR PackageId;
} SEC_BUILTIN_KPACKAGE, * PSEC_BUILTIN_KPACKAGE;

extern SEC_BUILTIN_KPACKAGE    KsecBuiltinPackages[];

extern PEPROCESS KsecLsaProcess ;
extern HANDLE KsecLsaProcessHandle ;

extern KEVENT KsecConnectEvent ;

// Prototypes:

NTSTATUS
LpcConnect( PWSTR           pszPortName,
            PVOID           pConnect,
            PULONG          cbConnect,
            HANDLE *        phPort);


NTSTATUS
LpcClose(   HANDLE      hPort);


NTSTATUS
CreateSyncEvent(
    VOID
    );

NTSTATUS
OpenSyncEvent(
    HANDLE *  phEvent
    );

SECURITY_STATUS SEC_ENTRY
DeleteUserModeContext(
    IN PCtxtHandle phContext,           // Contxt to delete
    OUT PCtxtHandle phLsaContext
    );

SECURITY_STATUS SEC_ENTRY
InitUserModeContext(
    IN PCtxtHandle                 phContext,      // Contxt to init
    IN PSecBuffer                  pContextBuffer,
    OUT PCtxtHandle                phNewContext
    );

SECURITY_STATUS SEC_ENTRY
MapKernelContextHandle(
    IN PCtxtHandle phContext,           // Contxt to map
    OUT PCtxtHandle phLsaContext
    );


SECURITY_STATUS
InitializePackages(
    ULONG PackageCount );


//
// Lsa memory handling routines:
//

//
// Structure defining a memory chunk available for ksec to use
// in handling a request from kernel mode
//
typedef struct _KSEC_LSA_MEMORY {
    LIST_ENTRY  List ;
    PVOID       Region ;            // Region in memory
    SIZE_T      Size ;              // Size of region (never exceeds 64K)
    SIZE_T      Commit ;
} KSEC_LSA_MEMORY, * PKSEC_LSA_MEMORY ;

#define KsecLsaMemoryToContext( p ) \
        ( ( (PKSEC_LSA_MEMORY) p)->Region)

#define KsecIsBlockInLsa( LsaMem, Block ) \
    ( ((LsaMem != NULL ) && (Block != NULL )) ? (((ULONG_PTR) (LsaMem->Region) ^ (ULONG_PTR) Block ) < (ULONG_PTR) LsaMem->Commit) : FALSE )
    

#define SECBUFFER_TYPE( x ) \
    ( (x) & (~ SECBUFFER_ATTRMASK ) )

NTSTATUS
KsecInitLsaMemory(
    VOID
    );

PKSEC_LSA_MEMORY
KsecAllocLsaMemory(
    SIZE_T   Size
    );

VOID
KsecFreeLsaMemory(
    PKSEC_LSA_MEMORY LsaMemory
    );

NTSTATUS
KsecCopyPoolToLsa(
    PKSEC_LSA_MEMORY LsaMemory,
    SIZE_T LsaOffset,
    PVOID Pool,
    SIZE_T PoolSize
    );

NTSTATUS
KsecCopyLsaToPool(
    PVOID Pool,
    PKSEC_LSA_MEMORY LsaMemory,
    PVOID LsaBuffer,
    SIZE_T Size
    );


NTSTATUS
KsecSerializeAuthData(
    PSECURITY_STRING Package,
    PVOID AuthData,
    PULONG SerializedSize,
    PVOID * SerializedData
    );

SECURITY_STATUS
KsecQueryContextAttributes(
    IN PCtxtHandle  phContext,
    IN ULONG        Attribute,
    IN OUT PVOID    Buffer,
    IN PVOID        Extra,
    IN ULONG        ExtraLength
    );

#ifdef KSEC_LEAK_TRACKING

VOID
UninitializePackages(
    VOID );

#endif  // KSEC_LEAK_TRACKING


void SEC_ENTRY
SecFree(PVOID pvMemory);




//
//  Global Locks
//

extern FAST_MUTEX KsecPackageLock;
extern FAST_MUTEX KsecPageModeMutex ;
extern FAST_MUTEX KsecConnectionMutex ;

#define KSecLockPackageList()   (ExAcquireFastMutex( &KsecPackageLock ))
#define KSecUnlockPackageList() (ExReleaseFastMutex( &KsecPackageLock ))

//
// Macro to map package index to table
//

#define KsecPackageIndex(_x_) (_x_)

// Global Variables:
extern  KSPIN_LOCK  ConnectSpinLock;

ULONG
KsecInitializePackageList(
    VOID );

VOID * SEC_ENTRY
SecAllocate(ULONG cbMemory);

VOID
SecFree(
    IN PVOID Base
    );


#ifndef _NTIFS_
#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a, b, 'cesK')
#define ExAllocatePoolWithQuota(a,b)    ExAllocatePoolWithQuotaTag(a, b, 'cesK')
#endif
#endif 

#if DBG
#define DebugStmt(x) x
#else
#define DebugStmt(x)
#endif



SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextDefer(
    PCtxtHandle     phContext);


SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandleDefer(
    PCredHandle     phCredential);

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextInternal(
    BOOLEAN     DeletePrivateContext,
    PCtxtHandle                 phContext          // Context to delete
    );

SECURITY_STATUS 
SEC_ENTRY
FreeCredentialsHandleInternal(
    PCredHandle                 phCredential        // Handle to free
    );

NTSTATUS
NTAPI
KsecEncryptMemoryInitialize(
    VOID
    );

VOID
KsecEncryptMemoryShutdown(
    VOID
    );

NTSTATUS
NTAPI
KsecEncryptMemory(
    IN PVOID pMemory,
    IN ULONG cbMemory,
    IN int Operation,
    IN ULONG Option
    );



#endif // __KSECDD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\lsamem.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 2000
//
// File:        lsamem.cxx
//
// Contents:    Shared memory between ksec and lsa
//
//
// History:     7-19-00     Richardw    Created
//
//------------------------------------------------------------------------


#include "secpch2.hxx"

extern "C"
{
#include <zwapi.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>
#include "ksecdd.h"

}


//
// At this time, it is unlikely that we'd have more than one
// of these, but in the event that it becomes a high-demand
// list, having it in a structure should make it easier to 
// make per-processor.  
//

typedef struct _KSEC_LSA_MEMORY_CONTROL {
    LIST_ENTRY  List ;
    ULONG       Count ;
    ULONG       Present ;
    ULONG       HighWater ;
//    KEVENT      Block ;
    FAST_MUTEX  Lock ;
} KSEC_LSA_MEMORY_CONTROL, * PKSEC_LSA_MEMORY_CONTROL ;

#define KSEC_MAX_LSA_MEMORY_BLOCKS  1024

PKSEC_LSA_MEMORY_CONTROL LsaMemoryControl ;

NTSTATUS
KsecInitLsaMemory(
    VOID
    )
{
    NTSTATUS Status ;

    LsaMemoryControl = (PKSEC_LSA_MEMORY_CONTROL) ExAllocatePool( 
                            NonPagedPool, 
                            sizeof( KSEC_LSA_MEMORY_CONTROL ) );

    if ( !LsaMemoryControl )
    {
        return STATUS_NO_MEMORY ;
    }

    InitializeListHead( &LsaMemoryControl->List );
    Status = ExInitializeFastMutex( &LsaMemoryControl->Lock );

    if ( !NT_SUCCESS( Status ) )
    {
        ExFreePool( LsaMemoryControl );
        return Status ;
    }

    // KeInitializeEvent( &LsaMemoryControl->Block );
    LsaMemoryControl->Count = 0 ;
    LsaMemoryControl->HighWater = 0 ;
    LsaMemoryControl->Present = 0 ;

    return STATUS_SUCCESS ;


}


VOID
KsecpFreeLsaMemory(
    PKSEC_LSA_MEMORY LsaMemory,
    BOOLEAN Force
    )
{
    SIZE_T Size = 0 ;

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &LsaMemoryControl->Lock );

    if ( LsaMemoryControl->Present * 2 > LsaMemoryControl->Count )
    {
        //
        // If the present count is half of the total count, dump 
        // this entry.
        //

        Force = TRUE ;
        
    }

    if ( !Force )
    {
        LsaMemoryControl->Present ++ ;
        InsertHeadList( &LsaMemoryControl->List, &LsaMemory->List );
    }
    else 
    {
        LsaMemoryControl->Count -- ;
    }

    ExReleaseFastMutex( &LsaMemoryControl->Lock );
    KeLeaveCriticalRegion();

    if ( Force )
    {
        ZwFreeVirtualMemory(
            KsecLsaProcessHandle,
            &LsaMemory->Region,
            &Size,
            MEM_RELEASE );

        ExFreePool( LsaMemory );
        
    }


}

PKSEC_LSA_MEMORY
KsecAllocLsaMemory(
    SIZE_T   Size
    )
{
    PKSEC_LSA_MEMORY LsaMemory = NULL ;
    PKSEC_LSA_MEMORY_HEADER Header ;
    PLIST_ENTRY Scan ;
    SIZE_T NewSize ;
    SIZE_T Reservation ;
    NTSTATUS Status ;
    KAPC_STATE ApcState ;

    if ( Size < 8192 )
    {
        Size = 8192 ;
    }

    if ( Size > 64 * 1024 )
    {
        return NULL ;
        
    }

    ASSERT( LsaMemoryControl );

    KeEnterCriticalRegion();
    ExAcquireFastMutex( &LsaMemoryControl->Lock );

    Scan = LsaMemoryControl->List.Flink ;

    while ( Scan != &LsaMemoryControl->List )
    {
        LsaMemory = CONTAINING_RECORD( Scan, KSEC_LSA_MEMORY, List );

        if ( LsaMemory->Commit >= Size )
        {
            RemoveEntryList( &LsaMemory->List );
            LsaMemoryControl->Present-- ;
            break;
        }

        LsaMemory = NULL ;

        Scan = Scan->Flink;

    }

    if ( LsaMemory == NULL )
    {
        if ( !IsListEmpty( &LsaMemoryControl->List ) )
        {
            Scan = RemoveHeadList( &LsaMemoryControl->List );
            LsaMemoryControl->Present-- ;
            LsaMemory = CONTAINING_RECORD( Scan, KSEC_LSA_MEMORY, List );
        }
    }


    if ( LsaMemory == NULL )
    {
        //
        // Still nothing there.  See if it is OK for us to allocate
        // another one.  

        if ( LsaMemoryControl->Count < KSEC_MAX_LSA_MEMORY_BLOCKS )
        {
            LsaMemory = (PKSEC_LSA_MEMORY) ExAllocatePool( PagedPool, 
                                    sizeof( KSEC_LSA_MEMORY ) );

            if ( LsaMemory )
            {
                LsaMemory->Commit = 0 ;
                LsaMemory->Size = 0 ;
                LsaMemory->Region = 0 ;

                LsaMemoryControl->Count ++ ;

                if ( LsaMemoryControl->Count > LsaMemoryControl->HighWater )
                {
                    LsaMemoryControl->HighWater = LsaMemoryControl->Count ;
                }
            }
        }
        else
        {
            //
            // In the future, we can use that block event in the
            // control structure to wait for to be returned to the
            // list.  However, the likelyhood of having all the 
            // requests outstanding is pretty slim.  We'll probably
            // get normal memory failures long before that.
            //

            NOTHING ;
        }


    }

    ExReleaseFastMutex( &LsaMemoryControl->Lock );
    KeLeaveCriticalRegion();

    if ( LsaMemory )
    {
        if ( LsaMemory->Commit < Size )
        {
            NewSize = Size ;

            if ( LsaMemory->Size < Size )
            {

                //
                // Need to make our reservation:
                //

                Reservation = 64 * 1024 ;  // 64K

                Status = ZwAllocateVirtualMemory(
                                KsecLsaProcessHandle,
                                &LsaMemory->Region,
                                0,
                                &Reservation,
                                MEM_RESERVE,
                                PAGE_NOACCESS );

                if ( NT_SUCCESS( Status ) )
                {
                    LsaMemory->Size = Reservation ;
                }

            }

            Status = ZwAllocateVirtualMemory(
                            KsecLsaProcessHandle,
                            &LsaMemory->Region,
                            0,
                            &NewSize,
                            MEM_COMMIT,
                            PAGE_READWRITE );

            if ( NT_SUCCESS( Status ) )
            {
                LsaMemory->Commit = NewSize ;
            }
            else
            {
                if ( LsaMemory->Region )
                {
                    KsecpFreeLsaMemory( LsaMemory, TRUE );
                }
                else
                {
                    ExFreePool( LsaMemory );
                }

                LsaMemory = NULL ;

            }
        }

        if ( LsaMemory )
        {
            //
            // Initialize the memory block for the LSA:
            //

            ASSERT( LsaMemory->Region != NULL );

            Header = (PKSEC_LSA_MEMORY_HEADER) LsaMemory->Region ;


            KeStackAttachProcess(
                (PRKPROCESS) KsecLsaProcess,
                &ApcState );

            __try {

                //
                // Initialize the structure in the LSA space.  This
                // protects the driver from bugs in the LSA process
                // stomping on the fields.  
                //

                Header->Commit = (ULONG) LsaMemory->Commit ;
                Header->Consumed = sizeof( KSEC_LSA_MEMORY_HEADER );
                Header->Preserve = (USHORT) Header->Consumed ;
                Header->Size = (ULONG) LsaMemory->Size ;
                Header->MapCount = 0 ;

                Status = STATUS_SUCCESS ;

            } 
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
                //
                // An exception here indicates that the memory in user
                // mode is bad.  
                //

                Status = GetExceptionCode();

            }

            KeUnstackDetachProcess( &ApcState );

            if ( !NT_SUCCESS( Status ) )
            {
                KsecpFreeLsaMemory( LsaMemory, TRUE );

                LsaMemory = NULL ;
                
            }

            
        }

    }

    return LsaMemory ;

}


VOID
KsecFreeLsaMemory(
    PKSEC_LSA_MEMORY LsaMemory
    )
{
    if ( !LsaMemory )
    {
        DebugLog((DEB_TRACE, " KsecFreeLsaMemory called with NULL\n" ));
        return;
    }

    KsecpFreeLsaMemory( LsaMemory, FALSE );

}


NTSTATUS
KsecCopyPoolToLsa(
    PKSEC_LSA_MEMORY LsaMemory,
    SIZE_T LsaOffset,
    PVOID Pool,
    SIZE_T PoolSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS ;
    KAPC_STATE ApcState ;
    PKSEC_LSA_MEMORY_HEADER Header ;

    ASSERT( LsaOffset < LsaMemory->Commit );
    ASSERT( LsaOffset < LsaMemory->Size );
    ASSERT( PoolSize < LsaMemory->Commit );

    KeStackAttachProcess(
        (PRKPROCESS) KsecLsaProcess,
        &ApcState );

    __try {

        RtlCopyMemory(
            (PUCHAR) LsaMemory->Region + LsaOffset,
            Pool,
            PoolSize );

        Header = (PKSEC_LSA_MEMORY_HEADER) LsaMemory->Region ;
        if ( Header->MapCount < KSEC_LSA_MAX_MAPS )
        {
            Header->PoolMap[ Header->MapCount ].Offset = (USHORT) LsaOffset;
            Header->PoolMap[ Header->MapCount ].Size = (USHORT) PoolSize ;
            Header->PoolMap[ Header->MapCount ].Pool = Pool ;
            Header->MapCount++ ;
            
        }

    } 
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // An exception here indicates that the memory in user
        // mode is bad.  
        //

        Status = GetExceptionCode();

    }

    KeUnstackDetachProcess( &ApcState );


    return Status ;

}

NTSTATUS
KsecCopyLsaToPool(
    PVOID Pool,
    PKSEC_LSA_MEMORY LsaMemory,
    PVOID LsaBuffer,
    SIZE_T Size
    )
{

    NTSTATUS Status = STATUS_SUCCESS ;
    KAPC_STATE ApcState ;
    ULONG LsaOffset ;
    PUCHAR Scratch ;

    LsaOffset = (ULONG) ((PUCHAR) LsaBuffer - (PUCHAR) LsaMemory->Region) ;

    ASSERT( LsaOffset < LsaMemory->Commit );
    ASSERT( LsaOffset < LsaMemory->Size );
    ASSERT( Size < LsaMemory->Commit );

    KeStackAttachProcess(
        (PRKPROCESS) KsecLsaProcess,
        &ApcState );

    __try {

        RtlCopyMemory(
            Pool,
            LsaBuffer,
            Size );

    } 
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        // An exception here indicates that the memory in user
        // mode is bad.  
        //

        Status = GetExceptionCode();

    }

    KeUnstackDetachProcess( &ApcState );

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\ksecdd.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        KSecDD.C
//
// Contents:    Base level stuff for the device driver
//
//
// History:     19 May 92,  RichardW    Blatently stolen from DarrylH
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop
#include <ntddksec.h>

extern "C"
{
#include <spmlpc.h>
#include <ntverp.h>

#include "ksecdd.h"

#include "connmgr.h"

#include "randlib.h"

//
// Define the local routines used by this driver module.
//


NTSTATUS
KsecDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
KsecQueryFileInformation(
    OUT PVOID Buffer,
    IN OUT PULONG Length,
    IN FILE_INFORMATION_CLASS InformationClass
    );

NTSTATUS
KsecQueryVolumeInformation(
    OUT PVOID Buffer,
    IN OUT PULONG Length,
    IN FS_INFORMATION_CLASS InformationClass
    );

NTSTATUS
KsecDeviceControl(
    IN      PVOID   InputBuffer,
    IN      ULONG   InputLength,
        OUT PVOID   OutputBuffer,
    IN  OUT PULONG  OutputLength,
    IN      ULONG   IoControlCode
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath);

#ifdef KSEC_LEAK_TRACKING

VOID
KsecUnload(
    IN PDRIVER_OBJECT   DriverObject
    );

#endif  // KSEC_LEAK_TRACKING

} // extern "C"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, KsecQueryVolumeInformation)
#pragma alloc_text(PAGE, KsecDispatch)
#pragma alloc_text(PAGE, KsecQueryFileInformation)
#pragma alloc_text(PAGE, KsecDeviceControl)

#ifdef KSEC_LEAK_TRACKING
#pragma alloc_text(PAGE, KsecUnload)
#endif

#endif


BOOLEAN FoundLsa = FALSE ;
ULONG KsecUserProbeAddress ;
PEPROCESS KsecLsaProcess ;
HANDLE KsecLsaProcessHandle ;

#ifdef KSEC_LEAK_TRACKING
PDEVICE_OBJECT gDeviceObject = NULL;
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the synchronous NULL device driver.
    This routine creates the device object for the NullS device and performs
    all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING nameString;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS Status;

    //
    // Create the device object.
    //

    RtlInitUnicodeString( &nameString,
                          DD_KSEC_DEVICE_NAME_U );

    Status = IoCreateDevice( DriverObject,
                             0L,
                             &nameString,
                             FILE_DEVICE_KSEC,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &deviceObject );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }

#ifdef KSEC_LEAK_TRACKING

    DriverObject->DriverUnload = KsecUnload;
    //
    // Save device object away for unload
    //
    gDeviceObject = deviceObject;

#endif  // KSEC_LEAK_TRACKING
    //
    // Setting the following flag changes the timing of how many I/O's per
    // second can be accomplished by going through the NULL device driver
    // from being simply getting in and out of the driver, to getting in and
    // out with the overhead of building an MDL, probing and locking buffers,
    // unlocking the pages, and deallocating the MDL.  This flag should only
    // be set for performance testing.
    //

//  deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the driver object with this device driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_READ]   = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_WRITE]  = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]  = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION] = KsecDispatch;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = KsecDispatch ;



    if (!InitConnMgr())
    {
        DebugLog((DEB_ERROR,"Failed to initialize\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Create the resource protecting the list of packages
    //

    Status = ExInitializeFastMutex( &KsecPackageLock );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR,"Failed to initialize package lock: 0x%x\n",Status));
        return(Status);
    }

    Status = ExInitializeFastMutex( &KsecPageModeMutex );

    if ( !NT_SUCCESS( Status ))
    {
        return Status ;
    }

    KeInitializeEvent( 
        &KsecConnectEvent, 
        NotificationEvent, 
        FALSE );


#if ( _X86_ )
    KsecUserProbeAddress = *((PULONG) MmUserProbeAddress);
#endif

    InitializeRNG( NULL );

    DebugLog((DEB_TRACE,"Security device driver loaded\n"));
    return STATUS_SUCCESS;
}


NTSTATUS
KsecDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the main dispatch routine for the synchronous NULL device
    driver.  It accepts an I/O Request Packet, performs the request, and then
    returns with the appropriate status.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
//    KIRQL oldIrql;
    PVOID buffer;
    ULONG length;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( DeviceObject );

    //
    // Get a pointer to the current stack location in the IRP.  This is where
    // the function codes and parameters are stored.
    //

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Case on the function that is being performed by the requestor.  If the
    // operation is a valid one for this device, then make it look like it was
    // successfully completed, where possible.
    //

    switch (irpSp->MajorFunction) {

        //
        // For both create/open and close operations, simply set the information
        // field of the I/O status block and complete the request.
        //

        case IRP_MJ_CREATE:
        case IRP_MJ_CLOSE:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0L;
            break;

        //
        // For read operations, set the information field of the I/O status
        // block, set an end-of-file status, and complete the request.
        //

        case IRP_MJ_READ:
            Irp->IoStatus.Status = STATUS_END_OF_FILE;
            Irp->IoStatus.Information = 0L;
            break;

        //
        // For write operations, set the information field of the I/O status
        // block to the number of bytes which were supposed to have been written
        // to the file and complete the request.
        //

        case IRP_MJ_WRITE:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = irpSp->Parameters.Write.Length;
            break;

        case IRP_MJ_DEVICE_CONTROL:
            buffer = Irp->AssociatedIrp.SystemBuffer;
            length = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            Irp->IoStatus.Status = KsecDeviceControl(
                                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer,
                                        irpSp->Parameters.DeviceIoControl.InputBufferLength,
                                        buffer,
                                        &length,
                                        irpSp->Parameters.DeviceIoControl.IoControlCode
                                        );

            Irp->IoStatus.Information = length;
            break;


        case IRP_MJ_QUERY_INFORMATION:
            buffer = Irp->AssociatedIrp.SystemBuffer;
            length = irpSp->Parameters.QueryFile.Length;
            Irp->IoStatus.Status = KsecQueryFileInformation( buffer,
                                                            &length,
                                                            irpSp->Parameters.QueryFile.FileInformationClass );
            Irp->IoStatus.Information = length;
            break;

        case IRP_MJ_QUERY_VOLUME_INFORMATION:
            buffer = Irp->AssociatedIrp.SystemBuffer;
            length = irpSp->Parameters.QueryVolume.Length;
            Irp->IoStatus.Status = KsecQueryVolumeInformation( buffer,
                                                              &length,
                                                              irpSp->Parameters.QueryVolume.FsInformationClass );
            Irp->IoStatus.Information = length;
            break;
    }

    //
    // Copy the final status into the return status, complete the request and
    // get out of here.
    //

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, 0 );
    return status;
}

NTSTATUS
KsecQueryFileInformation(
    OUT PVOID Buffer,
    IN PULONG Length,
    IN FILE_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine queries information about the opened file and returns the
    information in the specified buffer provided that the buffer is large
    enough and the specified type of information about the file is supported
    by this device driver.

    Information about files supported by this driver are:

        o   FileStandardInformation

Arguments:

    Buffer - Supplies a pointer to the buffer in which to return the
        information.

    Length - Supplies the length of the buffer on input and the length of
        the data actually written on output.

    InformationClass - Supplies the information class that is being queried.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    PFILE_STANDARD_INFORMATION standardBuffer;

    PAGED_CODE();
    //
    // Switch on the type of information that the caller would like to query
    // about the file.
    //

    switch (InformationClass) {

        case FileStandardInformation:

            //
            // Return the standard information about the file.
            //

            standardBuffer = (PFILE_STANDARD_INFORMATION) Buffer;
            *Length = (ULONG) sizeof( FILE_STANDARD_INFORMATION );
            standardBuffer->NumberOfLinks = 1;
            standardBuffer->DeletePending = FALSE;
            standardBuffer->AllocationSize.LowPart = 0;
            standardBuffer->AllocationSize.HighPart = 0;
            standardBuffer->Directory = FALSE;
            standardBuffer->EndOfFile.LowPart = 0;
            standardBuffer->EndOfFile.HighPart = 0;
            break;

        default:

            //
            // An invalid (or unsupported) information class has been queried
            // for the file.  Return the appropriate status.
            //

            return STATUS_INVALID_INFO_CLASS;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
KsecQueryVolumeInformation(
    OUT PVOID Buffer,
    IN PULONG Length,
    IN FS_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine queries information about the opened volume and returns the
    information in the specified buffer.

    Information about volumes supported by this driver are:

        o   FileFsDeviceInformation

Arguments:

    Buffer - Supplies a pointer to the buffer in which to return the
        information.

    Length - Supplies the length of the buffer on input and the length of
        the data actually written on output.

    InformationClass - Supplies the information class that is being queried.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    PFILE_FS_DEVICE_INFORMATION deviceBuffer;


    PAGED_CODE();
    //
    // Switch on the type of information that the caller would like to query
    // about the volume.
    //

    switch (InformationClass) {

        case FileFsDeviceInformation:

            //
            // Return the device information about the volume.
            //

            deviceBuffer = (PFILE_FS_DEVICE_INFORMATION) Buffer;
            *Length = sizeof( FILE_FS_DEVICE_INFORMATION );
            deviceBuffer->DeviceType = FILE_DEVICE_NULL;
            break;

        default:

            //
            // An invalid (or unsupported) information class has been queried
            // for the volume.  Return the appropriate status.
            //

            return STATUS_INVALID_INFO_CLASS;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
KsecDeviceControl(
    IN      PVOID   InputBuffer,
    IN      ULONG   InputLength,
        OUT PVOID   OutputBuffer,
    IN  OUT PULONG  OutputLength,
    IN      ULONG   IoControlCode
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    //
    // Switch on the type of information that the caller would like to query
    // about the volume.
    //

    switch (IoControlCode)
    {

        case IOCTL_KSEC_CONNECT_LSA:
        {

            if ( KsecLsaProcess == NULL )
            {
                (VOID) InitSecurityInterface();
                *OutputLength = 0;
                KsecLsaProcess = PsGetCurrentProcess() ;

                ObReferenceObject( KsecLsaProcess );

                Status = ObOpenObjectByPointer(
                            KsecLsaProcess,
                            OBJ_KERNEL_HANDLE,
                            NULL,
                            PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION |
                                PROCESS_VM_READ | PROCESS_VM_WRITE,
                            NULL,
                            KernelMode,
                            &KsecLsaProcessHandle );

                if ( NT_SUCCESS( Status ) )
                {
                    Status = KsecInitLsaMemory();
                }

                return Status ;
            }

            break;
        }

        //
        // kernel mode encapsulated RNG.
        //

        case IOCTL_KSEC_RNG:
        {
            if( OutputBuffer == NULL || OutputLength == NULL )
                return STATUS_INVALID_PARAMETER;

            if( InputLength < *OutputLength ) {
                memset(
                        (unsigned char*)OutputBuffer + InputLength,
                        0,
                        *OutputLength - InputLength
                        );
            }

            if(NewGenRandom( NULL, NULL, (unsigned char *)OutputBuffer, *OutputLength ))
                return STATUS_SUCCESS;

            break;
        }

        case IOCTL_KSEC_RNG_REKEY:
        {
            RNG_CONTEXT RNGContext;

            if( OutputBuffer == NULL || OutputLength == NULL )
                return STATUS_INVALID_PARAMETER;

            if( InputLength < *OutputLength ) {
                memset(
                        (unsigned char*)OutputBuffer + InputLength,
                        0,
                        *OutputLength - InputLength
                        );
            }

            memset( &RNGContext, 0, sizeof(RNGContext) );

            RNGContext.cbSize = sizeof(RNGContext);
            RNGContext.Flags |= RNG_FLAG_REKEY_ONLY;

            if(NewGenRandomEx( &RNGContext, (unsigned char *)OutputBuffer, *OutputLength ))
                return STATUS_SUCCESS;

            break;
        }

        case IOCTL_KSEC_ENCRYPT_MEMORY:
        case IOCTL_KSEC_DECRYPT_MEMORY:
        case IOCTL_KSEC_ENCRYPT_MEMORY_CROSS_PROC:
        case IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC:
        case IOCTL_KSEC_ENCRYPT_MEMORY_SAME_LOGON:
        case IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON:
        {
            ULONG Option = 0;
            int Operation = ENCRYPT;

            if( OutputBuffer == NULL || OutputLength == NULL )
            {
                return STATUS_INVALID_PARAMETER;
            }

            if( InputLength < *OutputLength ) {
                memset(
                        (unsigned char*)OutputBuffer + InputLength,
                        0,
                        *OutputLength - InputLength
                        );
            }

            if( IoControlCode == IOCTL_KSEC_ENCRYPT_MEMORY_CROSS_PROC ||
                IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC )
            {
                Option = RTL_ENCRYPT_OPTION_CROSS_PROCESS;
            }

            if( IoControlCode == IOCTL_KSEC_ENCRYPT_MEMORY_SAME_LOGON ||
                IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON )
            {
                Option = RTL_ENCRYPT_OPTION_SAME_LOGON;
            }

            if( IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY ||
                IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY_CROSS_PROC ||
                IoControlCode == IOCTL_KSEC_DECRYPT_MEMORY_SAME_LOGON )
            {
                Operation = DECRYPT;
            }

            Status = KsecEncryptMemory(
                                OutputBuffer,
                                *OutputLength,
                                Operation,
                                Option
                                );
            if( NT_SUCCESS(Status) )
            {
                return Status;
            }

            break;
        }

        default:
        {
            //
            // An invalid (or unsupported) IoControlCode was specified.
            //

            DebugLog(( DEB_ERROR, "Invalid Ioctl supplied: %x\n", IoControlCode));

            break;
        }
    }

    if( OutputLength )
        *OutputLength = 0;

    return Status;
}

#if DBG
ULONG KsecInfoLevel;
//ULONG KsecInfoLevel = DEB_TRACE | DEB_ERROR |DEB_WARN | DEB_TRACE_CALL;

void
KsecDebugOut(unsigned long  Mask,
            const char *    Format,
            ...)
{
    PETHREAD    pThread;
    PEPROCESS   pProcess;
    va_list     ArgList;
    char        szOutString[256];

    if (KsecInfoLevel & Mask)
    {
        pThread = PsGetCurrentThread();
        pProcess = PsGetCurrentProcess();

        va_start(ArgList, Format);
        DbgPrint("%#x.%#x> KSec:  ", pProcess, pThread);
        if (_vsnprintf(szOutString, sizeof(szOutString),Format, ArgList) < 0)
        {
                //
                // Less than zero indicates that the string could not be
                // fitted into the buffer.  Output a special message indicating
                // that:
                //

                DbgPrint("Error printing message\n");

        }
        else
        {
            DbgPrint(szOutString);
        }
    }
}
#endif


#ifdef KSEC_LEAK_TRACKING

VOID
KsecUnload(
    IN PDRIVER_OBJECT   DriverObject
    )
/*++

Routine Description:

    Driver unload routine for ksecdd.sys

Arguments:

    DriverObject - This driver's driver objects

Return Value:

    None

--*/
{
    ShutdownRNG (NULL);
    KsecEncryptMemoryShutdown();
    UninitializePackages ();
    IoDeleteDevice (gDeviceObject);
    gDeviceObject = NULL;
    return;
}

#endif  // KSEC_LEAK_TRACKING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\stubs.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        stubs.cxx
//
// Contents:    user-mode stubs for security API
//
//
// History:     3/5/94      MikeSw      Created
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <align.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "connmgr.h"

SECURITY_STATUS
MapContext( PCtxtHandle     pctxtHandle);


SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextInternal(
    BOOLEAN     DeletePrivateContext,
    PCtxtHandle phContext          
    );



SECURITY_STATUS
KsecCaptureBufferDesc(
    PKSEC_LSA_MEMORY *LsaMemoryBlock,
    PBOOLEAN        Mapped,
    PUNICODE_STRING Target,
    PSecBufferDesc  InputBuffers,
    PSecBufferDesc  LocalBuffers,
    PUNICODE_STRING NewTarget
    );

SECURITY_STATUS
KsecUncaptureBufferDesc(
    PKSEC_LSA_MEMORY LsaMemory,
    BOOLEAN AllocMem,
    PSecBufferDesc CapturedBuffers,
    PSecBufferDesc SuppliedBuffers,
    PSecBuffer ContextData OPTIONAL
    );

}


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AcquireCredentialsHandle)
#pragma alloc_text(PAGE, AddCredentials)
#pragma alloc_text(PAGE, FreeCredentialsHandle)
#pragma alloc_text(PAGE, QueryCredentialsAttributes)
#pragma alloc_text(PAGE, InitializeSecurityContext)
#pragma alloc_text(PAGE, AcceptSecurityContext)
#pragma alloc_text(PAGE, DeleteSecurityContextInternal)
#pragma alloc_text(PAGE, DeleteSecurityContext)
#pragma alloc_text(PAGE, ApplyControlToken)
#pragma alloc_text(PAGE, EnumerateSecurityPackages)
#pragma alloc_text(PAGE, QuerySecurityPackageInfo)
#pragma alloc_text(PAGE, FreeContextBuffer)
#pragma alloc_text(PAGE, LsaGetLogonSessionData)
#pragma alloc_text(PAGE, LsaEnumerateLogonSessions)
#pragma alloc_text(PAGE, KsecCaptureBufferDesc)
#pragma alloc_text(PAGE, KsecUncaptureBufferDesc)
#endif

static LUID            lFake = {0, 0};
static SECURITY_STRING sFake = {0, 0, NULL};

//+-------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandle(
    PSECURITY_STRING            pssPrincipal,       // Name of principal
    PSECURITY_STRING            pssPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pvAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet;
    SECURITY_STRING Principal;
    TimeStamp   OptionalTimeStamp;
    ULONG Flags ;
    PKSEC_LSA_MEMORY LsaMemory = NULL;
    ULONG AuthSize ;
    PVOID AuthData = NULL ;
    PVOID AuthDataParameter ;
    NTSTATUS Status ;

    PAGED_CODE();


    if (!pssPackageName)
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if (!pssPrincipal)
    {
        Principal = sFake;
    }

    Flags = 0;

    AuthDataParameter = pvAuthData ;

    if ( (ULONG_PTR) pvAuthData > MM_USER_PROBE_ADDRESS )
    {
        //
        // Got some data.  Let's copy it into a kmap buffer.
        // First, have the package serialize it:
        //

        Status = KsecSerializeAuthData(
                    pssPackageName,
                    pvAuthData,
                    &AuthSize,
                    &AuthData );

        if ( NT_SUCCESS( Status ) )
        {
            LsaMemory = KsecAllocLsaMemory( AuthSize );

            if ( LsaMemory )
            {
                Status = KsecCopyPoolToLsa(
                                LsaMemory,
                                sizeof( KSEC_LSA_MEMORY_HEADER ),
                                AuthData,
                                AuthSize );

                if ( NT_SUCCESS( Status ) )
                {
                    AuthDataParameter = (PUCHAR) LsaMemory->Region + sizeof( KSEC_LSA_MEMORY_HEADER );
                    Flags |= SPMAPI_FLAG_KMAP_MEM ;
                    
                }

                
            }
            
        }
        
        
    }

    scRet = SecpAcquireCredentialsHandle(
                (LsaMemory ? KsecLsaMemoryToContext( LsaMemory ) : NULL),
                (pssPrincipal ? pssPrincipal : &Principal),
                pssPackageName,
                fCredentialUse,
                (pvLogonId ? (PLUID) pvLogonId : &lFake),
                AuthDataParameter,
                pGetKeyFn,
                pvGetKeyArgument,
                phCredential,
                (ptsExpiry ? ptsExpiry : &OptionalTimeStamp),
                &Flags );

    if ( ( AuthData != NULL ) &&
         ( AuthData != pvAuthData ) )
    {
        ExFreePool( AuthData );
        
    }

    if ( LsaMemory )
    {
        KsecFreeLsaMemory( LsaMemory );
        
    }

    return(scRet);

}


//+---------------------------------------------------------------------------
//
//  Function:   AddCredentialsW
//
//  Synopsis:   
//
//  Arguments:  [phCredential]     -- 
//              [pssPrincipal]     -- 
//              [pssPackageName]   -- 
//              [fCredentialUse]   -- 
//              [pAuthData]        -- 
//              [pGetKeyFn]        -- 
//              [GetKey]           -- 
//              [pvGetKeyArgument] -- 
//              [GetKey]           -- 
//              [out]              -- 
//              [optional]         -- 
//              [optional]         -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
AddCredentialsW(
    PCredHandle                 phCredential,
    PSECURITY_STRING            pssPrincipal,       // Name of principal
    PSECURITY_STRING            pssPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet;
    SECURITY_STRING Principal;
    TimeStamp   OptionalTimeStamp;
    ULONG Flags ;

    PAGED_CODE();


    if (!pssPackageName)
    {
        return(STATUS_INVALID_PARAMETER);
    }
    if (!pssPrincipal)
    {
        Principal = sFake;
    }

    Flags = 0;

    scRet = SecpAddCredentials(
                NULL,
                phCredential,
                (pssPrincipal ? pssPrincipal : &Principal),
                pssPackageName,
                fCredentialUse,
                pAuthData,
                pGetKeyFn,
                pvGetKeyArgument,
                (ptsExpiry ? ptsExpiry : &OptionalTimeStamp),
                &Flags );

    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandleInternal
//
//  Synopsis:   Guts of freeing a handle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS 
SEC_ENTRY
FreeCredentialsHandleInternal(
    PCredHandle                 phCredential        // Handle to free
    )
{
    NTSTATUS Status ;

    PAGED_CODE();

    Status = SecpFreeCredentialsHandle(SECP_DELETE_NO_BLOCK, phCredential);

    return Status ;

}



//+-------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandle
//
//  Synopsis:   Public interface.  If the process is terminating, the 
//              handle will be stuck on a defered workitem list.
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
FreeCredentialsHandle( 
    PCredHandle     phCredential
    )
{
    NTSTATUS Status ;

    PAGED_CODE();

    Status = FreeCredentialsHandleInternal( phCredential );

    if ( Status == STATUS_PROCESS_IS_TERMINATING )
    {
        Status = FreeCredentialsHandleDefer( phCredential );
    }

    return Status ;

}


//+-------------------------------------------------------------------------
//
//  Function:   QueryCredentialsAttributes
//
//  Synopsis:   queries attributes for a credentials handle
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
QueryCredentialsAttributes(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    )
{
    SECURITY_STATUS Status ;
    ULONG Allocs ;
    PVOID Buffers[ 8 ];

    PAGED_CODE();

    Allocs = 0;

    Status = SecpQueryCredentialsAttributes(
                            phCredential,
                            ulAttribute,
                            pBuffer,
                            0,
                            &Allocs,
                            Buffers );

    return( Status );
}

//+---------------------------------------------------------------------------
//
//  Function:   KsecCaptureBufferDesc
//
//  Synopsis:   Captures information about pool paramters into an LSA memory 
//              block
//
//  Arguments:  [LsaMemoryBlock] -- 
//              [Mapped]         -- 
//              [Target]         -- 
//              [InputBuffers]   -- 
//              [LocalBuffers]   -- 
//              [NewTarget]      -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

SECURITY_STATUS
KsecCaptureBufferDesc(
    OUT PKSEC_LSA_MEMORY *LsaMemoryBlock,
    OUT PBOOLEAN        Mapped,
    IN OPTIONAL PUNICODE_STRING Target,
    IN OPTIONAL PSecBufferDesc  InputBuffers,
    IN OPTIONAL PSecBufferDesc  LocalBuffers,
    IN OPTIONAL PUNICODE_STRING NewTarget
    )
{

    ULONG i ;
    SIZE_T TotalSize ;
    SIZE_T CopyCount ;
    PKSEC_LSA_MEMORY LsaMemory ;
    SIZE_T Offset ;
    KSEC_LSA_MEMORY_HEADER Header ;
    NTSTATUS Status = STATUS_SUCCESS ;
    
    PAGED_CODE();

    *Mapped = FALSE ;

    TotalSize = 0 ;


    if ( InputBuffers )
    {
        if ( InputBuffers->cBuffers > LocalBuffers->cBuffers )
        {
            return STATUS_INVALID_PARAMETER ;
        }

        for ( i = 0 ; i < InputBuffers->cBuffers ; i++ )
        {
            if ( ((ULONG_PTR) InputBuffers->pBuffers[ i ].pvBuffer > MM_USER_PROBE_ADDRESS ) &&
                ( InputBuffers->pBuffers[ i ].cbBuffer > 0 ))
            {
                //
                // Caller has supplied a buffer out of pool.  Add this to our
                // total required size
                //

                TotalSize += ROUND_UP_COUNT( InputBuffers->pBuffers[ i ].cbBuffer, ALIGN_LPVOID );

            }

        }
        
    }

    if ( Target )
    {
        if ( (ULONG_PTR) Target->Buffer > MM_USER_PROBE_ADDRESS )
        {
            TotalSize += ROUND_UP_COUNT( (Target->Length + sizeof( WCHAR )), ALIGN_LPVOID );
        }
        
    }


    if ( TotalSize )
    {
        //
        // Cool - we've got a chunk of data in pool, and we need to copy
        // it up to the LSA.  
        //

        if ( InputBuffers )
        {
            TotalSize += sizeof( SecBuffer ) * InputBuffers->cBuffers ;
        }

        TotalSize += sizeof( KSEC_LSA_MEMORY_HEADER );

        LsaMemory = KsecAllocLsaMemory( TotalSize );

        if ( !LsaMemory )
        {
            return STATUS_NO_MEMORY ;
        }

        //
        // Assemble the buffer
        //

        Offset = 0 ;

        Offset += sizeof( KSEC_LSA_MEMORY_HEADER );

        if ( InputBuffers )
        {
            Offset += sizeof( SecBuffer ) * InputBuffers->cBuffers ;

            for ( i = 0 ; i < InputBuffers->cBuffers ; i++ )
            {
                LocalBuffers->pBuffers[ i ] = InputBuffers->pBuffers[ i ];

                if ( ( (ULONG_PTR) InputBuffers->pBuffers[ i ].pvBuffer > MM_USER_PROBE_ADDRESS ) &&
                    ( InputBuffers->pBuffers[ i ].cbBuffer > 0 ) )
                {

                    LocalBuffers->pBuffers[ i ].BufferType |= SECBUFFER_KERNEL_MAP ;
                    LocalBuffers->pBuffers[ i ].pvBuffer = (PUCHAR) LsaMemory->Region + Offset ;

                    Status = KsecCopyPoolToLsa(
                                    LsaMemory,
                                    Offset,
                                    InputBuffers->pBuffers[ i ].pvBuffer,
                                    InputBuffers->pBuffers[ i ].cbBuffer );

                    Offset += ROUND_UP_COUNT( InputBuffers->pBuffers[ i ].cbBuffer, ALIGN_LPVOID );

                    if ( !NT_SUCCESS( Status ) )
                    {
                        break;

                    }
                    
                }

            }
            
            LocalBuffers->cBuffers = InputBuffers->cBuffers ;

        }

        if ( NT_SUCCESS( Status ) )
        {
            if ( Target )
            {

                if ( (ULONG_PTR) Target->Buffer > MM_USER_PROBE_ADDRESS )
                {
                    Status = KsecCopyPoolToLsa(
                                LsaMemory,
                                Offset,
                                Target->Buffer,
                                Target->Length );

                    if ( NT_SUCCESS( Status ) )
                    {
                        NewTarget->Buffer = (PWSTR) ((PUCHAR) LsaMemory->Region + Offset);
                        NewTarget->Length = Target->Length ;
                        NewTarget->MaximumLength = NewTarget->Length + sizeof( WCHAR ) ;

                    }

                    Offset += ROUND_UP_COUNT( (Target->Length + sizeof( WCHAR )), ALIGN_LPVOID );

                }
                
            }
            
        }

        if ( !NT_SUCCESS( Status ) )
        {
            KsecFreeLsaMemory( LsaMemory );
            return Status ;
            
        }

        *Mapped = TRUE ;
        *LsaMemoryBlock = LsaMemory ;

            
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   KsecUncaptureBufferDesc
//
//  Synopsis:   Copies information back out of the LSA block into various pool
//              descriptors
//
//  Arguments:  [LsaMemory]       -- 
//              [AllocMem]        -- 
//              [CapturedBuffers] -- 
//              [SuppliedBuffers] -- 
//              [OPTIONAL]        -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

SECURITY_STATUS
KsecUncaptureBufferDesc(
    PKSEC_LSA_MEMORY LsaMemory,
    BOOLEAN AllocMem,
    PSecBufferDesc CapturedBuffers,
    PSecBufferDesc SuppliedBuffers,
    PSecBuffer ContextData OPTIONAL
    )
{

    ULONG i ;
    PVOID p ;
    NTSTATUS Status = STATUS_SUCCESS ;

    for ( i = 0 ; i < CapturedBuffers->cBuffers ; i++ )
    {
        if ( ( CapturedBuffers->pBuffers[ i ].pvBuffer == SuppliedBuffers->pBuffers[ i ].pvBuffer ) ||
             ( !KsecIsBlockInLsa( LsaMemory, CapturedBuffers->pBuffers[ i ].pvBuffer ) ) )
        {
            //
            // Same buffer?  Not in the LSA block?  Skip it - this was done by the LSA
            //
            SuppliedBuffers->pBuffers[ i ] = CapturedBuffers->pBuffers[ i ];


            continue;
            
        }

        if ( ( CapturedBuffers->pBuffers[ i ].BufferType & ~SECBUFFER_ATTRMASK ) == SECBUFFER_TOKEN )
        {
            if ( AllocMem )
            {
                p = ExAllocatePool( 
                        PagedPool, 
                        CapturedBuffers->pBuffers[ i ].cbBuffer );

                if ( p )
                {
                    SuppliedBuffers->pBuffers[ i ].pvBuffer = p ;
                    SuppliedBuffers->pBuffers[ i ].cbBuffer =
                            CapturedBuffers->pBuffers[ i ].cbBuffer ;

                    
                }
                else
                {

                    Status = STATUS_NO_MEMORY ;
                    break;
                }
                
            }
            else
            {

                if ( SuppliedBuffers->pBuffers[ i ].cbBuffer <
                        CapturedBuffers->pBuffers[ i ].cbBuffer )
                {
                    DebugLog(( DEB_ERROR, "Error:  supplied buffer smaller than capture\n" ));
                    Status = STATUS_BUFFER_TOO_SMALL ;
                    break;
                    
                }
            }

            //
            // Safe to copy now
            //

            Status = KsecCopyLsaToPool(
                        SuppliedBuffers->pBuffers[ i ].pvBuffer,
                        LsaMemory,
                        CapturedBuffers->pBuffers[ i ].pvBuffer,
                        CapturedBuffers->pBuffers[ i ].cbBuffer );

            SuppliedBuffers->pBuffers[ i ].cbBuffer = CapturedBuffers->pBuffers[ i ].cbBuffer ;
            SuppliedBuffers->pBuffers[ i ].BufferType = CapturedBuffers->pBuffers[ i ].BufferType ;
            
        }
        
    }

    if ( NT_SUCCESS( Status ) )
    {
        if ( ContextData )
        {
            if ( KsecIsBlockInLsa( LsaMemory, ContextData->pvBuffer ) )
            {
                p = ExAllocatePool(
                        PagedPool,
                        ContextData->cbBuffer );

                if ( p )
                {
                    Status = KsecCopyLsaToPool(
                                p,
                                LsaMemory,
                                ContextData->pvBuffer,
                                ContextData->cbBuffer );


                }
                else 
                {
                    Status = STATUS_NO_MEMORY ;
                }

                if ( NT_SUCCESS( Status ))
                {
                    ContextData->pvBuffer = p ;
                }

            }

        }
        
    }

    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Failure path cleanup
        //
        if ( AllocMem )
        {
            for ( i = 0 ; i < CapturedBuffers->cBuffers ; i++ )
            {

                if ( ( SuppliedBuffers->pBuffers[ i ].BufferType & ~SECBUFFER_ATTRMASK ) == SECBUFFER_TOKEN )
                {
                    if ( SuppliedBuffers->pBuffers[ i ].pvBuffer )
                    {
                        ExFreePool( SuppliedBuffers->pBuffers[ i ].pvBuffer );
                        SuppliedBuffers->pBuffers[ i ].pvBuffer = NULL ;
                        
                    }


                }
                
            }

            
        }
        
    }


    return Status ;
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSECURITY_STRING            pssTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet;
    NTSTATUS Status ;
    BOOLEAN MappedContext = FALSE;
    SecBuffer ContextData = {0,0,NULL};
    CtxtHandle TempInputContext = {0,0};
    CtxtHandle TempOutputContext = {0, 0};
    CtxtHandle ContextHandle = {0,0};
    CredHandle CredentialHandle = {0,0};
    ULONG Flags;

    SecBuffer LocalBuffers[ 8 ];
    SecBufferDesc LocalDesc ;
    SecBuffer LocalOutBuffers[ 8 ];
    SecBufferDesc LocalOutDesc ;
    BOOLEAN Mapped = FALSE;
    PSecBufferDesc InputBuffers ;
    SECURITY_STRING LocalTarget ;
    PKSEC_LSA_MEMORY LsaMemory = NULL ;

    PAGED_CODE();


    // Check for valid sizes, pointers, etc.:

    //
    // Onw of the two of these is required
    //

    if (!ARGUMENT_PRESENT(phContext) && !ARGUMENT_PRESENT(phCredential))
    {
        scRet = SEC_E_INVALID_HANDLE ;
        goto Cleanup ;
    }

    if (ARGUMENT_PRESENT(phCredential))
    {
        CredentialHandle = *phCredential;
    }

    TempOutputContext = *phNewContext ;

    if (ARGUMENT_PRESENT(phContext))
    {

        //
        // Map the handle from kernel mode into LSA mode
        //

        TempInputContext = *phContext;

        scRet = MapKernelContextHandle(
                    phContext,
                    &ContextHandle
                    );

        if (!NT_SUCCESS(scRet))
        {
            return(scRet);
        }
        if (!ARGUMENT_PRESENT(phCredential))
        {
            CredentialHandle.dwLower = ContextHandle.dwLower;
        }
    }

    if (!pssTargetName)
    {
        pssTargetName = &sFake;
    }

    LocalTarget = *pssTargetName ;

    LocalDesc.pBuffers = LocalBuffers ;
    LocalDesc.cBuffers = 8 ;
    LocalDesc.ulVersion = SECBUFFER_VERSION ;

    LocalOutDesc.pBuffers = LocalOutBuffers ;
    LocalOutDesc.cBuffers = pOutput->cBuffers ;
    LocalOutDesc.ulVersion = SECBUFFER_VERSION ;

    RtlCopyMemory(
        LocalOutBuffers,
        pOutput->pBuffers,
        pOutput->cBuffers * sizeof( SecBuffer ) );

    InputBuffers = pInput ;

    scRet = KsecCaptureBufferDesc(
                &LsaMemory,
                &Mapped,
                pssTargetName,
                pInput,
                &LocalDesc,
                &LocalTarget );

    if ( !NT_SUCCESS( scRet ) )
    {
        return scRet ;
    }

    if ( Mapped && ( pInput != NULL ) )
    {
        InputBuffers = &LocalDesc ;
    }

    if ( !LsaMemory )
    {
        //
        // Allocate one, so that the LSA can return any data to us
        // in the region
        //

        LsaMemory = KsecAllocLsaMemory( 3 * 1024 );

        if ( !LsaMemory )
        {
            return STATUS_NO_MEMORY;
        }
    }

    Flags = 0;

    if ( Mapped )
    {
        Flags |= SPMAPI_FLAG_KMAP_MEM ;
    }

    scRet = SecpInitializeSecurityContext(
                    KsecLsaMemoryToContext(LsaMemory),
                    &CredentialHandle,
                    &ContextHandle,
                    &LocalTarget,
                    fContextReq,
                    Reserved1,
                    TargetDataRep,
                    InputBuffers,
                    Reserved2,
                    phNewContext,
                    &LocalOutDesc,
                    pfContextAttr,
                    ptsExpiry,
                    &MappedContext,
                    &ContextData,
                    &Flags );

    if ( NT_SUCCESS( scRet ) )
    {
        Status = KsecUncaptureBufferDesc(
                    LsaMemory,
                    ((*pfContextAttr & ISC_RET_ALLOCATED_MEMORY) != 0),
                    &LocalOutDesc,
                    pOutput,
                    ( MappedContext ? &ContextData : NULL ) );

        if ( !NT_SUCCESS( Status ) )
        {
            scRet = Status ;
        }
    }

    if (NT_SUCCESS(scRet))
    {

#if DBG
        if ( phNewContext->dwLower < 3 )
        {
            ULONG i ;
            NTSTATUS CheckStatus ;

            for ( i = 0 ; i < pOutput->cBuffers ; i++ )
            {
                if ( (pOutput->pBuffers[i].BufferType & SECBUFFER_ATTRMASK ) == SECBUFFER_TOKEN)
                {
                    CheckStatus = KSecValidateBuffer(
                                        (PUCHAR) pOutput->pBuffers[i].pvBuffer,
                                        pOutput->pBuffers[i].cbBuffer );

                    if ( !NT_SUCCESS( CheckStatus ) )
                    {
                        DbgBreakPoint();
                    }
                }
            }
        }
#endif
        if ( MappedContext )
        {
            SECURITY_STATUS SecStatus;

            if ( ( phNewContext->dwUpper != 0 ) && 
                 ( phNewContext->dwLower != 0 ) )
            {
                SecStatus = InitUserModeContext(
                                    phNewContext,
                                    &ContextData,
                                    phNewContext
                                    );
            }
            else 
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY ;
            }

            if (!NT_SUCCESS(SecStatus))
            {

                //
                // If this was a first call, reset the output context
                //

                if (!ARGUMENT_PRESENT(phContext))
                {
                    DeleteSecurityContext(phNewContext);

                    *phNewContext = TempOutputContext ;

                }

                scRet = SecStatus;
            }
        }
        else
        {
            //
            // Make sure to map the output handle also
            //

            if (ARGUMENT_PRESENT(phContext) && (phNewContext->dwUpper == ContextHandle.dwUpper) )
            {
                *phNewContext = TempInputContext;
            }
        }
    }

    if ( LsaMemory )
    {
        KsecFreeLsaMemory( LsaMemory );
    }

Cleanup:

#if DBG
    if ( scRet == SEC_E_INVALID_HANDLE )
    {
        DebugLog(( DEB_WARN, "Invalid handle passed to InitializeSecurityContext\n" ));
    }
#endif
    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   AcceptSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
AcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet;
    NTSTATUS Status ;
    BOOLEAN MappedContext = FALSE;;
    SecBuffer ContextData = {0,0,NULL};
    CtxtHandle TempInputContext = {0,0};
    CtxtHandle TempOutputContext = {0,0};
    CtxtHandle ContextHandle = {0,0};
    CredHandle CredentialHandle = {0,0};
    ULONG Flags;
    ULONG i ;
    SecBuffer LocalBuffers[ 8 ];
    SecBufferDesc LocalDesc ;
    SecBuffer LocalOutBuffers[ 8 ];
    SecBufferDesc LocalOutDesc ;
    BOOLEAN Mapped = FALSE;
    PSecBufferDesc InputBuffers ;
    SECURITY_STRING LocalTarget ;
    PKSEC_LSA_MEMORY LsaMemory = NULL ;

    PAGED_CODE();

    //
    // Onw of the two of these is required
    //

    if (!ARGUMENT_PRESENT(phContext) && !ARGUMENT_PRESENT(phCredential))
    {
        scRet = SEC_E_INVALID_HANDLE ;
        goto Cleanup ;
    }

    if (ARGUMENT_PRESENT(phCredential))
    {
        CredentialHandle = *phCredential;
    }

    TempOutputContext = *phNewContext ;

    if (ARGUMENT_PRESENT(phContext))
    {

        //
        // Map the handle from kernel mode into LSA mode
        //

        TempInputContext = *phContext;

        scRet = MapKernelContextHandle(
                    phContext,
                    &ContextHandle
                    );

        if (!NT_SUCCESS(scRet))
        {
            return(scRet);
        }

        if (!ARGUMENT_PRESENT(phCredential))
        {
            CredentialHandle.dwLower = ContextHandle.dwLower;
        }
    }


    LocalDesc.pBuffers = LocalBuffers ;
    LocalDesc.cBuffers = 8 ;
    LocalDesc.ulVersion = SECBUFFER_VERSION ;

    LocalOutDesc.pBuffers = LocalOutBuffers ;
    LocalOutDesc.cBuffers = pOutput->cBuffers ;
    LocalOutDesc.ulVersion = SECBUFFER_VERSION ;

    RtlCopyMemory(
        LocalOutBuffers,
        pOutput->pBuffers,
        pOutput->cBuffers * sizeof( SecBuffer ) );


#if DBG
    if ( (fContextReq & ASC_REQ_ALLOCATE_MEMORY) == 0 )
    {
        for (i = 0 ; i < pOutput->cBuffers ; i++ )
        {

            if ( SECBUFFER_TYPE( pOutput->pBuffers[ i ].BufferType ) == SECBUFFER_TOKEN )
            {
                ASSERT( pOutput->pBuffers[ i ].cbBuffer > 0 );
                
            }

        }
        
    }
#endif 

    InputBuffers = pInput ;

    scRet = KsecCaptureBufferDesc(
                &LsaMemory,
                &Mapped,
                NULL,
                pInput,
                &LocalDesc,
                NULL );

    if ( !NT_SUCCESS( scRet ) )
    {
        return scRet ;
    }

    if ( Mapped && ( pInput != NULL ) )
    {
        InputBuffers = &LocalDesc ;
    }

    if ( !LsaMemory )
    {
        //
        // Allocate one, so that the LSA can return any data to us
        // in the region
        //

        LsaMemory = KsecAllocLsaMemory( 3 * 1024 );

        if ( !LsaMemory )
        {
            return STATUS_NO_MEMORY;
        }
    }

    Flags = 0;

    if ( Mapped )
    {
        Flags |= SPMAPI_FLAG_KMAP_MEM ;
    }

    scRet = SecpAcceptSecurityContext(
                KsecLsaMemoryToContext(LsaMemory),
                &CredentialHandle,
                &ContextHandle,
                InputBuffers,
                fContextReq,
                TargetDataRep,
                phNewContext,
                &LocalOutDesc,
                pfContextAttr,
                ptsExpiry,
                &MappedContext,
                &ContextData,
                &Flags );

    if ( NT_SUCCESS( scRet ) )
    {
        Status = KsecUncaptureBufferDesc(
                    LsaMemory,
                    ((*pfContextAttr & ISC_RET_ALLOCATED_MEMORY) != 0),
                    &LocalOutDesc,
                    pOutput,
                    ( MappedContext ? &ContextData : NULL ) );

        if ( !NT_SUCCESS( Status ) )
        {
            scRet = Status ;
            
        }
        
    }

    if (NT_SUCCESS(scRet))
    {
        if (MappedContext)
        {
            SECURITY_STATUS SecStatus;

            //
            // Successful return means that the context is complete.  Map the
            // context into the user space:
            //

            if ( ( phNewContext->dwUpper != 0 ) && 
                 ( phNewContext->dwLower != 0 ) )
            {
                SecStatus = InitUserModeContext(
                                    phNewContext,
                                    &ContextData,
                                    phNewContext
                                    );
            }
            else 
            {
                SecStatus = SEC_E_INSUFFICIENT_MEMORY ;
            }

            if (!NT_SUCCESS(SecStatus))
            {
                //
                // If this was a first call, restore the context
                //
                if (!ARGUMENT_PRESENT(phContext))
                {
                    DeleteSecurityContext(phNewContext);

                    *phNewContext = TempOutputContext ;
                }

                scRet = SecStatus;
            }
        }
        else
        {
            //
            // Make sure to map the output handle also
            //

            if (ARGUMENT_PRESENT(phContext) && (phNewContext->dwUpper == ContextHandle.dwUpper))
            {
                *phNewContext = TempInputContext;
            }
        }

    }

    if ( LsaMemory )
    {
        KsecFreeLsaMemory( LsaMemory );
    }

Cleanup:

#if DBG
    if ( scRet == SEC_E_INVALID_HANDLE )
    {
        DebugLog(( DEB_WARN, "Invalid handle passed to AcceptSecurityContext\n" ));
    }
#endif
    return(scRet);

}






//+-------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContextInternal
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextInternal(
    BOOLEAN     DeletePrivateContext,
    PCtxtHandle                 phContext          // Context to delete
    )
{
    SECURITY_STATUS     scRet;
    CtxtHandle LsaContext = { 0 };

    PAGED_CODE();

    if ( DeletePrivateContext )
    {
        scRet = DeleteUserModeContext(
                    phContext,
                    &LsaContext
                    );
    }
    else 
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION ;
    }


    // Don't expect all packages to implement the functions to be called in
    // the caller's process.

    if (!NT_SUCCESS(scRet))
    {
        LsaContext = *phContext;
    }

    // Furthermore, if the package returned SEC_I_NO_LSA_CONTEXT, do not call
    // SecpDeleteSecurityContext and return Success. This happens when this
    // context is imported and therefore no LSA counterpart exists.

    if (scRet == SEC_I_NO_LSA_CONTEXT)
    {
        return STATUS_SUCCESS;
    }

    //
    // Now delete the LSA context. This must be done second so we don't
    // reuse the LSA context before the kernel context is deleted. If
    // the lsa context value is zero, then there is no lsa context so
    // don't bother deleting it.
    //

    if (NT_SUCCESS(scRet) && (LsaContext.dwUpper != 0))
    {
        scRet = SecpDeleteSecurityContext(
                    SECP_DELETE_NO_BLOCK,
                    &LsaContext );

    }

#if DBG
    if ( scRet == SEC_E_INVALID_HANDLE )
    {
        DebugLog(( DEB_WARN, "Invalid handle passed to DeleteSecurityContext\n" ));
    }
#endif

    return(scRet);

}



//+-------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
DeleteSecurityContext(
    PCtxtHandle phContext
    )
{
    NTSTATUS Status ;

    Status = DeleteSecurityContextInternal(
                    TRUE,
                    phContext
                    );

    if ( Status == STATUS_PROCESS_IS_TERMINATING )
    {

        Status = DeleteSecurityContextDefer( phContext );

    }

    return Status ;
}


//+-------------------------------------------------------------------------
//
//  Function:   ApplyControlToken
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
ApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    )
{
    SECURITY_STATUS     scRet;

    PAGED_CODE();

    if (!phContext)
    {
        return(SEC_E_INVALID_HANDLE);
    }



    scRet = SecpApplyControlToken(  phContext,
                                    pInput);

    return(scRet);


}




//+-------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackage
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackages(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfo SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    PAGED_CODE();

    return(SecpEnumeratePackages(pcPackages,ppPackageInfo));
}



//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfo
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfo(
    PSECURITY_STRING PackageName,     // Name of package
    PSecPkgInfo * ppPackageInfo       // Receives package info
    )
{
    PAGED_CODE();

    return(SecpQueryPackageInfo(PackageName,ppPackageInfo));

}






//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{

    PAGED_CODE();

    SecFree( pvContextBuffer );

    return STATUS_SUCCESS;

}

//+---------------------------------------------------------------------------
//
//  Function:   LsaEnumerateLogonSessions
//
//  Synopsis:   
//
//  Arguments:  [LogonSessionCount] -- 
//              [LogonSessionList]  -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaEnumerateLogonSessions(
    OUT PULONG LogonSessionCount,
    OUT PLUID * LogonSessionList
    )
{
    PAGED_CODE();

    return SecpEnumLogonSession(
                LogonSessionCount,
                LogonSessionList
                );
}


//+---------------------------------------------------------------------------
//
//  Function:   LsaGetLogonSessionData
//
//  Synopsis:   
//
//  Arguments:  [LogonId]            -- 
//              [ppLogonSessionData] -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
LsaGetLogonSessionData(
    IN PLUID LogonId,
    OUT PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
    )
{
    PVOID Data ;
    NTSTATUS Status ;

    PAGED_CODE();

    Status = SecpGetLogonSessionData(
                LogonId,
                &Data );

    if ( NT_SUCCESS( Status ) )
    {
        *ppLogonSessionData = (PSECURITY_LOGON_SESSION_DATA) Data ;
    }

    return Status ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\spmlpc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        spmlpc.cxx
//
// Contents:    lpc code for client->spmgr communication
//
//
// History:     3-4-94      MikeSw      Created
//
//------------------------------------------------------------------------


#include "secpch2.hxx"

extern "C"
{
#include <zwapi.h>
#include <spmlpc.h>
#include <lpcapi.h>
#include <spmlpcp.h>
#include "ksecdd.h"

}


#if defined(ALLOC_PRAGMA) && defined(SECURITY_KERNEL)
#pragma alloc_text(PAGE, CreateConnection)
#pragma alloc_text(PAGE, CallSPM)
#pragma alloc_text(PAGE, LpcConnect)
#endif

ULONG KSecLsaBp;

//+-------------------------------------------------------------------------
//
//  Function:   CallSPM
//
//  Synopsis:   Calls the SPM, handles LPC errors
//
//  Effects:
//
//  Arguments:  pConn           -- Connection to use
//              pSendBuffer     -- Send buffer to send up
//              pReceiveBuffer  -- Received data from SPM
//
//  Requires:
//
//  Returns:
//
//  Notes:      In the future, we can add retry and error handling,
//              but right now we just panic if something fails.
//
//--------------------------------------------------------------------------
SECURITY_STATUS
CallSPM(
        PClient         pClient,
        PSPM_LPC_MESSAGE      pSendBuffer,
        PSPM_LPC_MESSAGE      pReceiveBuffer)

{
    SECURITY_STATUS     scRet;
    int                 retry = 0;
    PEPROCESS           Process ;
    PPORT_MESSAGE       Send ;
    PPORT_MESSAGE       Receive ;
    PVOID               SecurityPort ;
    LONG                Flag ;

    SEC_PAGED_CODE();


    //
    // How this works:  The SecurityPort pointer is carried around
    // in the EPROCESS object, and is cleaned up when the process
    // terminates (there are no more threads).  The Process will have
    // a null value for this field in one of two cases.  First, the 
    // process hasn't connected to the LSA yet, this should be handled by
    // the call to IsOkayToExec() made by the stub first.  Second
    // is the case when the process has terminated, but kernel callers 
    // have kept a reference to it.  In that case, the ps stuff will 
    // reset the pointer to 1.
    //

    Process = PsGetCurrentProcess();

    SecurityPort = PsGetProcessSecurityPort( Process );

    if ( SecurityPort == (PVOID) 1 )
    {
        //
        // this process has terminated.  Do not attempt to re-establish the
        // connection.
        //

        return STATUS_PROCESS_IS_TERMINATING ;
    }

    if ( KSecLsaBp )
    {
        KSecLsaBp = 0 ;
        pSendBuffer->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET ;
        
    }

    Send = (PPORT_MESSAGE) pSendBuffer ;
    Receive = (PPORT_MESSAGE) pReceiveBuffer ;

    do
    {
        scRet = LpcRequestWaitReplyPort(
                    SecurityPort,
                    Send,
                    Receive );

        if (!NT_SUCCESS(scRet))
        {
            // If the call failed, shout to everyone, kill the connection,
            // and stuff NO_SPM into the API return code

            DebugLog((DEB_ERROR,"Error %x in LPC to LSA\n", scRet));
            DebugLog((DEB_ERROR,"Breaking connection for process %x\n", PsGetCurrentProcess()));

            scRet = SEC_E_INTERNAL_ERROR;

            pReceiveBuffer->ApiMessage.scRet = scRet;
            pReceiveBuffer->ApiMessage.Args.SpmArguments.fAPI |= SPMAPI_FLAG_ERROR_RET;

            break;
        }
        if ( Receive->u2.s2.Type == LPC_REQUEST )
        {
            //
            // Note:  we may need to support callbacks to kernel mode in the 
            // future.  We will need to think very carefully about how to do
            // that, since it is essentially a quick trip into kernel mode.
            //

#if DBG
            DbgPrint( "KSEC: Callback not allowed\n" );
#endif 
            Send = Receive ;

            pReceiveBuffer->ApiMessage.scRet = SEC_E_NOT_SUPPORTED ;

        }
        else 
        {
            break;
        }


    } while ( TRUE  );


    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateConnection()
//
//  Synopsis:   Creates a connection record to the SPM
//
//  Effects:    Creates an LPC port in the context of the calling FSP
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    phConnect   - handle to a connection
//
//              STATUS_INSUFFICIENT_RESOURCES   - out of connection records
//              SEC_E_NO_SPM                    - Cannot connect to SPM
//
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
CreateConnection(
    PSTR     LogonProcessName,
    ULONG    ClientMode,
    HANDLE * phConnect,
    ULONG *  PackageCount,
    ULONG *  OperationalMode
    )
{
    SECURITY_STATUS scRet;
    NTSTATUS Status ;
    HANDLE          hPort;
    LSAP_AU_REGISTER_CONNECT_INFO_EX ConnectMessage;
    ULONG           cbConnect = sizeof(LSAP_AU_REGISTER_CONNECT_INFO);
    PLSAP_AU_REGISTER_CONNECT_RESP Resp;
    OBJECT_ATTRIBUTES           PortObjAttr;
    UNICODE_STRING              ucsPortName;
    SECURITY_QUALITY_OF_SERVICE sQOS;
    ULONG                       cbMaxMessage;
    PVOID Port ;

    SEC_PAGED_CODE();

    DebugLog((DEB_TRACE,"KSec:  CreateConnection\n" ));


    //
    // Zero this buffer to create an untrusted connection.
    //

    RtlZeroMemory(
        &ConnectMessage,
        sizeof(ConnectMessage)
        );

    if ( LogonProcessName )
    {
        ConnectMessage.LogonProcessNameLength = strlen( LogonProcessName );
        if ( ConnectMessage.LogonProcessNameLength >
                LSAP_MAX_LOGON_PROC_NAME_LENGTH )
        {
            ConnectMessage.LogonProcessNameLength = LSAP_MAX_LOGON_PROC_NAME_LENGTH ;
        }

        strncpy( ConnectMessage.LogonProcessName,
                 LogonProcessName,
                 ConnectMessage.LogonProcessNameLength );

        ConnectMessage.ClientMode = ClientMode;
        cbConnect = sizeof(LSAP_AU_REGISTER_CONNECT_INFO_EX);
    }


    RtlInitUnicodeString( &ucsPortName, SPM_PORTNAME );

    InitializeObjectAttributes(
        &PortObjAttr, 
        &ucsPortName, 
        OBJ_KERNEL_HANDLE, 
        NULL, 
        NULL);

    sQOS.ImpersonationLevel = SecurityImpersonation;
    sQOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    sQOS.EffectiveOnly = FALSE;

    scRet = ZwConnectPort(  phConnect,
                            &ucsPortName,
                            &sQOS,
                            NULL,
                            NULL,
                            &cbMaxMessage,
                            &ConnectMessage,
                            &cbConnect );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"KSec: LpcConnect to SPM Failed, %x \n",
                    scRet));

        scRet = SEC_E_INTERNAL_ERROR;
        goto Create_SafeExit;

    }

    Resp = (PLSAP_AU_REGISTER_CONNECT_RESP) &ConnectMessage ;

    if ( PackageCount )
    {
        *PackageCount = Resp->PackageCount;
    }

    if ( OperationalMode )
    {
        *OperationalMode = Resp->SecurityMode ;
    }

    DebugLog((DEB_TRACE,"KSec:  Connected process to SPMgr\n"));

    Status = ObReferenceObjectByHandle(
                *phConnect,
                PORT_ALL_ACCESS,
                NULL,
                KernelMode,
                &Port,
                NULL );

    //
    // We have a pointer to the port.  Set that as the process's security port,
    // and close the handle.  The ref keeps the port alive
    //

    ExAcquireFastMutex( &KsecConnectionMutex );

    if ( PsGetProcessSecurityPort( PsGetCurrentProcess() ) == NULL )
    {
        Status = PsSetProcessSecurityPort( PsGetCurrentProcess(), Port );
    }
    else 
    {
        Status = STATUS_OBJECT_NAME_COLLISION ;
    }

    ExReleaseFastMutex( &KsecConnectionMutex );

    if ( !NT_SUCCESS( Status ) )
    {
        //
        // Some other thread from this process already set the port.  Close this
        // reference
        //

        ObDereferenceObject( Port );

        if ( Status == STATUS_OBJECT_NAME_COLLISION )
        {
            Status = STATUS_OBJECT_NAME_EXISTS ;
        }

    }


    ZwClose( *phConnect );

    *phConnect = NULL ;


    // Safe, clean exit point:

Create_SafeExit:

    // return the set status code

    return( scRet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\negapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        krnlapi.cxx
//
// Contents:    Kernel-mode APIs to the NTLM package
//
//
// History:     07-Sep-1996   Created         ChandanS
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop
//
// Make these extern "C" to allow them to be pageable.
//

extern "C"
{
#include "spmlpc.h"
#include "ksecdd.h"
KspInitPackageFn       NegInitKernelPackage;
KspDeleteContextFn     NegDeleteKernelContext;
KspInitContextFn       NegInitKernelContext;
KspMapHandleFn         NegMapKernelHandle;
KspMakeSignatureFn     NegMakeSignature;
KspVerifySignatureFn   NegVerifySignature;
KspSealMessageFn       NegSealMessage;
KspUnsealMessageFn     NegUnsealMessage;
KspGetTokenFn          NegGetContextToken;
KspQueryAttributesFn   NegQueryContextAttributes;
KspCompleteTokenFn     NegCompleteToken;
KspSetPagingModeFn     NegSetPagingMode;
SpExportSecurityContextFn   NegExportContext;
SpImportSecurityContextFn   NegImportContext;
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NegInitKernelPackage)
#pragma alloc_text(PAGE, NegDeleteKernelContext)
#pragma alloc_text(PAGE, NegInitKernelContext)
#pragma alloc_text(PAGE, NegMapKernelHandle)
#pragma alloc_text(PAGEMSG, NegMakeSignature)
#pragma alloc_text(PAGEMSG, NegVerifySignature)
#pragma alloc_text(PAGEMSG, NegSealMessage)
#pragma alloc_text(PAGEMSG, NegUnsealMessage)
#pragma alloc_text(PAGEMSG, NegGetContextToken)
#pragma alloc_text(PAGEMSG, NegQueryContextAttributes)
#pragma alloc_text(PAGE, NegCompleteToken)
#pragma alloc_text(PAGE, NegExportContext)
#pragma alloc_text(PAGE, NegImportContext)
#endif

SECPKG_KERNEL_FUNCTION_TABLE NegFunctionTable = {
    NegInitKernelPackage,
    NegDeleteKernelContext,
    NegInitKernelContext,
    NegMapKernelHandle,
    NegMakeSignature,
    NegVerifySignature,
    NegSealMessage,
    NegUnsealMessage,
    NegGetContextToken,
    NegQueryContextAttributes,
    NegCompleteToken,
    NULL,
    NULL,
    NegSetPagingMode
};



//+-------------------------------------------------------------------------
//
//  Function:   NegInitKernelPackage
//
//  Synopsis:   Initialize an instance of the NtLm package in
//              a client's (kernel) address space
//
//  Arguments:  None
//
//  Returns:    STATUS_SUCCESS or
//              returns from ExInitializeResource
//
//  Notes:      we do what was done in SpInstanceInit()
//              from security\msv_sspi\userapi.cxx
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegInitKernelPackage(
    IN PSECPKG_KERNEL_FUNCTIONS KernelFunctions
    )
{
    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   NegDeleteKernelContext
//
//  Synopsis:   Deletes a kernel mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to delete
//              LsaContextHandle    - The Lsa mode handle
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegDeleteKernelContext(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{
    *LsaContextHandle = KernelContextHandle;
    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   NegInitKernelContext
//
//  Synopsis:   Creates a kernel-mode context from a packed LSA mode context
//
//  Arguments:  LsaContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NegInitKernelContext(
    IN ULONG_PTR LsaContextHandle,
    IN PSecBuffer PackedContext,
    OUT PULONG_PTR NewContextHandle
    )
{
    *NewContextHandle = LsaContextHandle;
    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegMapKernelHandle
//
//  Synopsis:   Maps a kernel handle into an LSA handle
//
//  Arguments:  KernelContextHandle - Kernel context handle of the context to map
//              LsaContextHandle - Receives LSA context handle of the context
//                      to map
//
//  Returns:    STATUS_SUCCESS on success
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NegMapKernelHandle(
    IN ULONG_PTR KernelContextHandle,
    OUT PULONG_PTR LsaContextHandle
    )
{
    *LsaContextHandle = KernelContextHandle;
    return (STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSignMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegMakeSignature(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   NegVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleVerifyMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
NegVerifySignature(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+-------------------------------------------------------------------------
//
//  Function:   NegSealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleSealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
NegSealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG fQOP,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Function:   NegUnsealMessage
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  KernelContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes: This was stolen from net\svcdlls\ntlmssp\client\sign.c ,
//         routine SspHandleUnsealMessage. It's possible that
//         bugs got copied too
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegUnsealMessage(
    IN ULONG_PTR KernelContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSeqNo,
    OUT PULONG pfQOP
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



//+-------------------------------------------------------------------------
//
//  Function:   NegGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegGetContextToken(
    IN ULONG_PTR KernelContextHandle,
    OUT PHANDLE ImpersonationToken,
    OUT OPTIONAL PACCESS_TOKEN *RawToken
    )
{
    return(SEC_E_UNSUPPORTED_FUNCTION);
}



//+-------------------------------------------------------------------------
//
//  Function:   NegQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//              This API allows a customer of the security
//              services to determine certain attributes of
//              the context.  These are: sizes, names, and lifespan.
//
//  Effects:
//
//  Arguments:
//
//    ContextHandle - Handle to the context to query.
//
//    Attribute - Attribute to query.
//
//        #define SECPKG_ATTR_SIZES    0
//        #define SECPKG_ATTR_NAMES    1
//        #define SECPKG_ATTR_LIFESPAN 2
//
//    Buffer - Buffer to copy the data into.  The buffer must
//             be large enough to fit the queried attribute.
//
//
//  Requires:
//
//  Returns:
//
//        STATUS_SUCCESS - Call completed successfully
//
//        STATUS_INVALID_HANDLE -- Credential/Context Handle is invalid
//        STATUS_UNSUPPORTED_FUNCTION -- Function code is not supported
//
//  Notes:
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegQueryContextAttributes(
    IN ULONG_PTR KernelContextHandle,
    IN ULONG Attribute,
    IN OUT PVOID Buffer
    )
{
    CtxtHandle TempHandle;
    NTSTATUS Status ;
    SecPkgContext_NegotiationInfoW NegInfo ;
    PSecPkgInfoW PackageInfo = NULL ;
    PVOID BufferSave = Buffer ;
    ULONG ExtraSize = 0 ;


    TempHandle.dwLower = KsecBuiltinPackages[0].PackageId;
    TempHandle.dwUpper = KernelContextHandle;


    if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
    {
        PackageInfo = (PSecPkgInfoW) ExAllocatePool( PagedPool, sizeof( SecPkgInfoW ) );

        if ( !PackageInfo )
        {
            return STATUS_NO_MEMORY ;
        }

        ExtraSize = sizeof( SecPkgInfoW );

        Buffer = &NegInfo ;
        NegInfo.PackageInfo = PackageInfo ;
    }

    Status = KsecQueryContextAttributes(
                &TempHandle,
                Attribute,
                Buffer,
                PackageInfo,
                ExtraSize );

    if ( NT_SUCCESS( Status ) )
    {
        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            RtlCopyMemory( BufferSave, Buffer, sizeof( NegInfo ) );
        }
    }
    else
    {
        if ( Attribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            ExFreePool( PackageInfo );
        }
    }

    return Status ;

}



//+-------------------------------------------------------------------------
//
//  Function:   NegCompleteToken
//
//  Synopsis:   Completes a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
NegCompleteToken(
    IN ULONG_PTR ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
NTAPI
NegSetPagingMode(
    IN BOOLEAN Pagable
    )
{
    return STATUS_SUCCESS ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\h\lpcapi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        lpcapi.h
//
// Contents:    prototypes for SPMgr client lpc functions
//
//
// History:     3-7-94      MikeSw      Created
//
//------------------------------------------------------------------------

#ifndef __LPCAPI_H__
#define __LPCAPI_H__


typedef struct _Client {
    LIST_ENTRY          Next;
    PVOID               ProcessId;
    HANDLE              hPort;
    ULONG               fClient;
    LONG                cRefs;
} Client, *PClient;





//
// Credentials APIs (credapi.cxx)
//



SECURITY_STATUS SEC_ENTRY
SecpAcquireCredentialsHandle(
    PVOID_LPC           Context,
    PSECURITY_STRING    pssPrincipalName,
    PSECURITY_STRING    pssPackageName,
    ULONG               fCredentialUse,
    PLUID               pLogonID,
    PVOID               pvAuthData,
    SEC_GET_KEY_FN      pvGetKeyFn,
    PVOID               ulGetKeyArgument,
    PCRED_HANDLE_LPC         phCredentials,
    PTimeStamp          ptsExpiry,
    PULONG              Flags);


SECURITY_STATUS SEC_ENTRY
SecpAddCredentials(
    PVOID_LPC        Context,
    PCRED_HANDLE_LPC phCredentials,
    PSECURITY_STRING pPrincipalName,
    PSECURITY_STRING pPackageName,
    ULONG fCredentialUse,
    PVOID pvAuthData,
    SEC_GET_KEY_FN pvGetKeyFn,
    PVOID pvGetKeyArg,
    PTimeStamp Expiry,
    PULONG Flags
    );


SECURITY_STATUS SEC_ENTRY
SecpFreeCredentialsHandle(
    ULONG           fFree,
    PCRED_HANDLE_LPC     phCredential);

SECURITY_STATUS SEC_ENTRY
SecpQueryCredentialsAttributes( 
    PCRED_HANDLE_LPC     phCredential,
    ULONG           ulAttribute,
    PVOID           pBuffer,
    LONG            Flags,
    PULONG          Allocs,
    PVOID *         Buffers );

//
// Context APIs (ctxtapi.cxx)
//



SECURITY_STATUS SEC_ENTRY
SecpInitializeSecurityContext(  
    PVOID_LPC           ContextPointer,
    PCRED_HANDLE_LPC    phCredentials,
    PCONTEXT_HANDLE_LPC phContext,
    PSECURITY_STRING    pucsTarget,
    ULONG               fContextReq,
    ULONG               dwReserved1,
    ULONG               TargetDataRep,
    PSecBufferDesc      pInput,
    ULONG               dwReserved2,
    PCONTEXT_HANDLE_LPC phNewContext,
    PSecBufferDesc      pOutput,
    ULONG *             pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBOOLEAN            MappedContext,
    PSecBuffer          ContextData,
    ULONG *             Flags );

SECURITY_STATUS SEC_ENTRY
SecpAcceptSecurityContext(
    PVOID_LPC           ContextPointer,
    PCRED_HANDLE_LPC    phCredentials,
    PCONTEXT_HANDLE_LPC phContext,
    PSecBufferDesc      pInput,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCONTEXT_HANDLE_LPC phNewContext,
    PSecBufferDesc      pOutput,
    ULONG *             pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBOOLEAN            MappedContext,
    PSecBuffer          ContextData,
    ULONG *             Flags);

SECURITY_STATUS SEC_ENTRY
SecpDeleteSecurityContext(
    ULONG           fDelete,
    PCONTEXT_HANDLE_LPC     phContext);

#define SECP_DELETE_NO_BLOCK    0x00000001

SECURITY_STATUS SEC_ENTRY
SecpApplyControlToken(  
    PCONTEXT_HANDLE_LPC phContext,
    PSecBufferDesc      pInput);

//
// Misc. APIs (misc.cxx)
//

SECURITY_STATUS SEC_ENTRY
SecpGetUserInfo(IN         PLUID                   pLogonId,
                IN         ULONG                   fFlags,
                IN OUT     PSecurityUserData *     ppUserInfo);

SECURITY_STATUS SEC_ENTRY
SecpEnumeratePackages(  IN         PULONG               pcPackages,
                        IN OUT     PSecPkgInfo *        ppPackageInfo);

SECURITY_STATUS SEC_ENTRY
SecpQueryPackageInfo(   PSECURITY_STRING        pssPackageName,
                        PSecPkgInfo *           ppPackageInfo);

SECURITY_STATUS SEC_ENTRY
SecpPackageControl(     PSECURITY_STRING        pssPackageName,
                        unsigned long           dwFunctionCode,
                        PSecBuffer              pInput,
                        PSecBuffer              pOuput);

//
// Utility routines (util.cxx)
//

SECURITY_STATUS SEC_ENTRY
SecpGetBinding( ULONG_PTR               ulPackageId,
                PSEC_PACKAGE_BINDING_INFO BindingInfo );

SECURITY_STATUS SEC_ENTRY
SecpFindPackage(    PSECURITY_STRING        pssPackageName,
                    PULONG_PTR              pulPackagdId);


SECURITY_STATUS SEC_ENTRY
SecpDetach( void );


//
// Supplemental credential routines (suppcred.cxx)
//

SECURITY_STATUS SEC_ENTRY
SecpSaveCredentials(PCRED_HANDLE_LPC         pCredHandle,
                    PSecBuffer          pCredentials);

SECURITY_STATUS SEC_ENTRY
SecpGetCredentials( PCRED_HANDLE_LPC         pCredHandle,
                    PSecBuffer          pCredentials);

SECURITY_STATUS SEC_ENTRY
SecpDeleteCredentials(  PCRED_HANDLE_LPC         pCredHandle,
                        PSecBuffer          pKey);


#ifndef SECURITY_KERNEL

SECURITY_STATUS
SEC_ENTRY
SecpAddPackage(
    PUNICODE_STRING Package,
    PSECURITY_PACKAGE_OPTIONS Options);

SECURITY_STATUS
SEC_ENTRY
SecpDeletePackage(
    PUNICODE_STRING Package);

#endif

SECURITY_STATUS
SEC_ENTRY
SecpSetSession(
    ULONG   Request,
    ULONG_PTR Argument,
    PULONG_PTR Response,
    PVOID * ResponsePtr
    );

SECURITY_STATUS
SEC_ENTRY
SecpQueryContextAttributes(
    PVOID_LPC ContextPointer,
    PCONTEXT_HANDLE_LPC phContext,
    ULONG   ulAttribute,
    PVOID   pBuffer,
    PULONG  Allocs,
    PVOID * Buffers,
    PULONG  Flags
    );

SECURITY_STATUS
SEC_ENTRY
SecpSetContextAttributes(
    PCONTEXT_HANDLE_LPC phContext,
    ULONG       ulAttribute,
    PVOID       pBuffer,
    ULONG cbBuffer
    );


NTSTATUS
NTAPI
SecpGetUserName(
    ULONG Options,
    PUNICODE_STRING Name
    );


NTSTATUS
NTAPI
SecpGetLogonSessionData(
    IN PLUID LogonId,
    OUT PVOID * LogonSessionData
    );


NTSTATUS
NTAPI
SecpEnumLogonSession(
    PULONG LogonSessionCount,
    PLUID * LogonSessionList
    );

SECURITY_STATUS
SEC_ENTRY
LsapPolicyChangeNotify( IN ULONG Options,
                        IN BOOLEAN Register,
                        IN HANDLE EventHandle,
                        IN POLICY_NOTIFICATION_INFORMATION_CLASS NotifyInfoClass
                        );


SECURITY_STATUS
SecpLookupAccountSid(
    IN PSID Sid,
    OUT PSECURITY_STRING Name,
    OUT PULONG RequiredNameSize,
    OUT PSECURITY_STRING ReferencedDomain,
    OUT PULONG RequiredDomainSize,
    OUT PSID_NAME_USE NameUse
    );

SECURITY_STATUS
SecpLookupAccountName(
    IN PSECURITY_STRING Name,
    OUT PSECURITY_STRING ReferencedDomain,
    OUT PULONG RequiredDomainSize,
    IN OUT PULONG SidSize,
    OUT PSID Sid,
    OUT PSID_NAME_USE NameUse
    );

//
// LPC support routins
//
NTSTATUS
CreateConnection(
    PSTR     LogonProcessName OPTIONAL,
    ULONG    ClientMode OPTIONAL,
    HANDLE * phConnect,
    ULONG *  PackageCount,
    ULONG *  OperationalMode
    );

LSA_DISPATCH_FN SecpLsaCallback ;

//
// Linkee can replace this value and the library will call it instead
//

extern PLSA_DISPATCH_FN     SecpLsaDispatchFn;

//
// functions that must be provided by the linkee
//

SECURITY_STATUS
IsOkayToExec(PClient * pClient);

VOID
FreeClient(PClient pClient);



#define DEB_TRACE_LSA   0x00000008
#define DEB_TRACE_CALL  0x00000010

#if DBG

#ifdef SEC_KMODE

extern ULONG SecInfoLevel;

#define DEB_ERROR   0x00000001
#define DEB_WARN    0x00000002
#define DEB_TRACE   0x00000004

void KsecDebugOut(ULONG, const char *, ...);

#define DebugLog(x) KsecDebugOut x

#else

#include <dsysdbg.h>

DECLARE_DEBUG2(Sec);                 // Defines the SecInfoLevel

#define DebugLog(x)     SecDebugPrint x

#endif // usermode

#else // DBG

#define DebugLog(x)

#endif // DBG

#endif // __LPCAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\spn.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        spn.cxx
//
// Contents:    SPN Construction for kernel mode
//
// History:     2/10/99      RichardW    Created
//
//------------------------------------------------------------------------
#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "connmgr.h"

}

#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, SecMakeSPN )
#endif 

NTSTATUS
NTAPI
SecMakeSPNEx(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN PUNICODE_STRING TargetInfo OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG TotalSize OPTIONAL,
    IN BOOLEAN Allocate
    )
{
    SIZE_T TotalLength ;
    UNICODE_STRING Instance = { 0 };
    WCHAR InstanceBuffer[ 10 ];
    NTSTATUS Status ;
    UNICODE_STRING SPN = { 0 };
    PWSTR Where ;

    TotalLength = ServiceClass->Length +
                  ServiceName->Length +
                  2 * sizeof( WCHAR );

    if ( InstancePort )
    {
        Instance.Buffer = InstanceBuffer ;
        Instance.Length = 0 ;
        Instance.MaximumLength = sizeof( InstanceBuffer );

        Status = RtlIntegerToUnicodeString(
                        (ULONG) InstancePort,
                        10,
                        &Instance );

        if ( !NT_SUCCESS( Status ) )
        {
            return Status ;
        }

        TotalLength += Instance.Length + 2 * sizeof(WCHAR) ;
    }

    if ( InstanceName )
    {
        TotalLength += InstanceName->Length + 2 * sizeof( WCHAR );
    }

    if ( TargetInfo )
    {
        TotalLength += TargetInfo->Length + sizeof( WCHAR );
        
    }

    if ( TotalLength > 65535 )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    if ( TotalSize )
    {
        *TotalSize = (ULONG) TotalLength ;
    }

    if ( Allocate )
    {
        SPN.Buffer = (PWSTR) ExAllocatePool( PagedPool, TotalLength );

        if ( SPN.Buffer )
        {
            SPN.MaximumLength = (USHORT) TotalLength;
        }
        else
        {
            return STATUS_NO_MEMORY ;
        }
    }
    else 
    {
        if ( (Spn == NULL) ||
             ( Spn->MaximumLength < (USHORT) TotalLength ) )
        {
            return STATUS_BUFFER_OVERFLOW ;
        }

        SPN = *Spn ;
    }

    //
    // Now construct the SPN
    //

    Where = SPN.Buffer ;

    RtlCopyMemory(
        Where,
        ServiceClass->Buffer,
        ServiceClass->Length );

    Where += ServiceClass->Length / sizeof( WCHAR );

    *Where++ = L'/';

    if ( InstanceName )
    {
        RtlCopyMemory(
            Where,
            InstanceName->Buffer,
            InstanceName->Length );

        Where += InstanceName->Length / sizeof( WCHAR );

        if ( InstancePort )
        {
            *Where++ = L':';

            RtlCopyMemory(
                Where,
                Instance.Buffer,
                Instance.Length );

            Where += Instance.Length / sizeof( WCHAR );
        }

        *Where++ = L'/';
    }

    //
    // Now the service name:
    //

    RtlCopyMemory(
        Where,
        ServiceName->Buffer,
        ServiceName->Length );

    Where += ServiceName->Length / sizeof( WCHAR );

    if ( TargetInfo )
    {
        RtlCopyMemory(
            Where,
            TargetInfo->Buffer,
            TargetInfo->Length );

        Where += TargetInfo->Length / sizeof( WCHAR );
        
    }

    SPN.Length = (USHORT) ((Where - SPN.Buffer) * sizeof( WCHAR ));

    *Where++ = L'\0';

    *Spn = SPN ;

    return STATUS_SUCCESS ;

}

NTSTATUS
NTAPI
SecMakeSPN(
    IN PUNICODE_STRING ServiceClass,
    IN PUNICODE_STRING ServiceName,
    IN PUNICODE_STRING InstanceName OPTIONAL,
    IN USHORT InstancePort OPTIONAL,
    IN PUNICODE_STRING Referrer OPTIONAL,
    IN OUT PUNICODE_STRING Spn,
    OUT PULONG TotalSize OPTIONAL,
    IN BOOLEAN Allocate
    )
{

    return SecMakeSPNEx(
                ServiceClass,
                ServiceName,
                InstanceName,
                InstancePort,
                Referrer,
                NULL,
                Spn,
                TotalSize,
                Allocate );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\h\lpcefs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        lpcefs.h
//
// Contents:    prototypes for EFS client lpc functions
//
//
// History:     3-7-94      RobertRe      Created
//
//------------------------------------------------------------------------

#ifndef __LPCEFS_H__
#define __LPCEFS_H__

#include <efsstruc.h>

//
// Efs routines (efsp.cxx)
//

//
// Kernel mode API
//


SECURITY_STATUS
SEC_ENTRY
EfspGenerateKey(
   PEFS_DATA_STREAM_HEADER * EfsStream,
   PEFS_DATA_STREAM_HEADER   DirectoryEfsStream,
   ULONG                     DirectoryEfsStreamLength,
   PEFS_KEY *                Fek,
   PVOID *                   BufferBase,
   PULONG                    BufferLength
   );

NTSTATUS
SEC_ENTRY
EfspGenerateDirEfs(
    PEFS_DATA_STREAM_HEADER   DirectoryEfsStream,
    ULONG                     DirectoryEfsStreamLength,
    PEFS_DATA_STREAM_HEADER * EfsStream,
    PVOID *                   BufferBase,
    PULONG                    BufferLength
    );

NTSTATUS
SEC_ENTRY
EfspDecryptFek(
    PEFS_KEY *                Fek,
    PEFS_DATA_STREAM_HEADER   EfsStream,
    ULONG                     EfsStreamLength,
    ULONG                     OpenType,
    PEFS_DATA_STREAM_HEADER * NewEfs,
    PVOID *                   BufferBase,
    PULONG                    BufferLength
    );

NTSTATUS
SEC_ENTRY
EfspGenerateSessionKey(
    PEFS_INIT_DATAEXG InitDataExg
    );


#endif  // __LPCEFS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\support.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        support.cxx
//
// Contents:    support routines for ksecdd.sys
//
//
// History:     3-7-94      Created     MikeSw
//
//------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "connmgr.h"
}


//
// external prototypes
//

extern "C"
NTSTATUS
MapSecError(NTSTATUS hrError);


//
// Global Variables:
//




//
// Use local RPC for all SPM communication
//


WCHAR       szLsaEvent[] = SPM_EVENTNAME;

SecurityFunctionTable   SecTable = {SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                                    EnumerateSecurityPackages,
                                    NULL, // LogonUser,
                                    AcquireCredentialsHandle,
                                    FreeCredentialsHandle,
                                    NULL, // QueryCredentialAttributes,
                                    InitializeSecurityContext,
                                    AcceptSecurityContext,
                                    CompleteAuthToken,
                                    DeleteSecurityContext,
                                    ApplyControlToken,
                                    QueryContextAttributes,
                                    ImpersonateSecurityContext,
                                    RevertSecurityContext,
                                    MakeSignature,
                                    VerifySignature,
                                    FreeContextBuffer,
                                    NULL, // QuerySecurityPackageInfo
                                    SealMessage,
                                    UnsealMessage,
                                    ExportSecurityContext,
                                    ImportSecurityContextW,
                                    NULL,                       // reserved7
                                    NULL,                       // reserved8
                                    QuerySecurityContextToken,
                                    SealMessage,
                                    UnsealMessage
                                   };










//+-------------------------------------------------------------------------
//
//  Function:   SecAllocate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID * SEC_ENTRY
SecAllocate(ULONG cbMemory)
{
    ULONG_PTR Size = cbMemory;
    NTSTATUS scRet;
    PVOID  Buffer = NULL;
    scRet = ZwAllocateVirtualMemory(
                NtCurrentProcess(),
                &Buffer,
                0L,
                &Size,
                MEM_COMMIT,
                PAGE_READWRITE
                );
    if (!NT_SUCCESS(scRet))
    {
        return(NULL);
    }
    return(Buffer);
}



//+-------------------------------------------------------------------------
//
//  Function:   SecFree
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void SEC_ENTRY
SecFree(PVOID pvMemory)
{
    ULONG_PTR Length = 0;

    if ( (ULONG_PTR) pvMemory < MM_USER_PROBE_ADDRESS )
    {

        (VOID) ZwFreeVirtualMemory(
                     NtCurrentProcess(),
                     &pvMemory,
                     &Length,
                     MEM_RELEASE
                     );
        
    }
    else
    {
        ExFreePool( pvMemory );
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   IsOkayToExec
//
//  Synopsis:   Determines if it is okay to make a call to the SPM
//
//  Effects:    Binds if necessary to the SPM
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
IsOkayToExec(PClient * ppClient)
{
    SECURITY_STATUS scRet;
    PClient pClient;

    if (NT_SUCCESS(LocateClient(&pClient)))
    {
        if (ppClient)
        {
            *ppClient = pClient;
        }
        else
        {
            FreeClient(pClient);
        }

        return(STATUS_SUCCESS);
    }

    scRet = CreateClient(TRUE, &pClient);

    if (!NT_SUCCESS(scRet))
    {
        return(scRet);
    }
    if (ppClient)
    {
        *ppClient = pClient;
    }
    else
    {
        FreeClient(pClient);
    }

    return(STATUS_SUCCESS);
}




//+-------------------------------------------------------------------------
//
//  Function:   InitSecurityInterface
//
//  Synopsis:   returns function table of all the security function and,
//              more importantly, create a client session.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

PSecurityFunctionTable SEC_ENTRY
InitSecurityInterface(void)
{
    SECURITY_STATUS scRet;
    PClient pClient = NULL;


    scRet = IsOkayToExec(&pClient);
    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR, "Failed to init security interface: 0x%x\n",scRet));
        return(NULL);
    }

    SecpSetSession( SETSESSION_ADD_WORKQUEUE,
                    NULL,
                    NULL,
                    NULL );

    //
    // Do not free the client - this allows it to stay around while not
    // in use.
    //

    return(&SecTable);
}




//+-------------------------------------------------------------------------
//
//  Function:   MapSecurityError
//
//  Synopsis:   maps a HRESULT from the security interface to a NTSTATUS
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS SEC_ENTRY
MapSecurityError(SECURITY_STATUS Error)
{
    NTSTATUS Status;

    Status = RtlMapSecurityErrorToNtStatus( Error );

    // Apparently CreateFileW returns STATUS_INVALID_PARAMTER. Need to figure
    // out why that's happening.
    // If a previous ASSERT just fired (and was ignored) inside the LSA,
    // contact sfield & sethur to look at this issue.  A double assert
    // indicates RDR passed in a bad buffer, likely a buffer formatted by
    // the nego package, and passed directly into the NTLM package, or vice-versa
    //
    ASSERT(Status != STATUS_INVALID_PARAMETER);
    ASSERT(Status != STATUS_BUFFER_TOO_SMALL);

    return(Status);
}


extern "C"
NTSTATUS
SEC_ENTRY
MapObjectToLsa(
    IN PVOID Object,
    OUT PHANDLE LsaHandle
    )
{
    return STATUS_NOT_SUPPORTED ;
}


//+---------------------------------------------------------------------------
//
//  Function:   SecLookupAccountSid
//
//  Synopsis:   Kernel interface for translating a SID to a name
//
//  Arguments:  [Sid]        -- 
//              [NameSize]   -- 
//              [NameBuffer] -- 
//              [OPTIONAL]   -- 
//              [OPTIONAL]   -- 
//              [NameUse]    -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

NTSTATUS
SEC_ENTRY
SecLookupAccountSid(
    IN PSID Sid,
    IN OUT PULONG NameSize,
    OUT PUNICODE_STRING NameBuffer,
    IN OUT PULONG DomainSize OPTIONAL,
    OUT PUNICODE_STRING DomainBuffer OPTIONAL,
    OUT PSID_NAME_USE NameUse
    )
{
    UNICODE_STRING NameString = { 0 };
    UNICODE_STRING DomainString = { 0 };
    PUNICODE_STRING Name ;
    PUNICODE_STRING Domain ;
    NTSTATUS Status ;


    if ( NameBuffer->MaximumLength > 0 )
    {
        Name = NameBuffer ;
    }
    else
    {
        Name = &NameString ;
    }

    if ( DomainBuffer )
    {
        if ( DomainBuffer->MaximumLength > 0 )
        {
            Domain = DomainBuffer ;
        }
        else
        {
            Domain = &DomainString ;
        }
    }
    else
    {
        Domain = NULL; //&DomainString ;
    }


    Status = SecpLookupAccountSid(
                Sid,
                Name,
                NameSize,
                Domain,
                DomainSize,
                NameUse );


    return Status ;

}

//+---------------------------------------------------------------------------
//
//  Function:   SecLookupAccountName
//
//  Synopsis:   
//
//  Arguments:  [Name]     -- 
//              [SidSize]  -- 
//              [Sid]      -- 
//              [NameUse]  -- 
//              [OPTIONAL] -- 
//              [OPTIONAL] -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

NTSTATUS
SEC_ENTRY
SecLookupAccountName(
    IN PUNICODE_STRING Name,
    IN OUT PULONG SidSize,
    OUT PSID Sid,
    OUT PSID_NAME_USE NameUse,
    IN OUT PULONG DomainSize OPTIONAL,
    OUT PUNICODE_STRING ReferencedDomain OPTIONAL
    )
{
    UNICODE_STRING DomainString = { 0 };
    PUNICODE_STRING Domain ;
    NTSTATUS Status ;


    if ( ReferencedDomain )
    {
        if ( ReferencedDomain->MaximumLength > 0 )
        {
            Domain = ReferencedDomain ;
        }
        else
        {
            Domain = &DomainString ;
        }
    }
    else
    {
        Domain = &DomainString;
    }

    Status = SecpLookupAccountName(
                Name,
                Domain,
                DomainSize,
                SidSize,
                Sid,
                NameUse );

    return Status ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\driver\userstub.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        userstub.cxx
//
// Contents:    stubs for user-mode security APIs
//
//
// History:     3-7-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "secpch2.hxx"
#pragma hdrstop
extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "ksecdd.h"
#include "connmgr.h"
#include <ntlmsp.h>
#include <kerberos.h>
#include <negossp.h>


//
// Local Prototypes that can be paged:
//

SECURITY_STATUS
KsecLocatePackage(
    IN PUNICODE_STRING PackageName,
    OUT PSECPKG_KERNEL_FUNCTION_TABLE * Package,
    OUT PULONG_PTR PackageId
    );

}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, InitializePackages)

#ifdef KSEC_LEAK_TRACKING
#pragma alloc_text(PAGE, UninitializePackages)
#endif

#pragma alloc_text(PAGEMSG, CompleteAuthToken)
#pragma alloc_text(PAGEMSG, ImpersonateSecurityContext)
#pragma alloc_text(PAGEMSG, RevertSecurityContext)
#pragma alloc_text(PAGEMSG, QueryContextAttributes)
#pragma alloc_text(PAGEMSG, QuerySecurityContextToken)
#pragma alloc_text(PAGEMSG, MakeSignature)
#pragma alloc_text(PAGEMSG, VerifySignature)
#pragma alloc_text(PAGEMSG, SealMessage)
#pragma alloc_text(PAGEMSG, UnsealMessage)
#pragma alloc_text(PAGE, DeleteUserModeContext)
#pragma alloc_text(PAGE, InitUserModeContext)
#pragma alloc_text(PAGE, ExportSecurityContext)
#pragma alloc_text(PAGE, ImportSecurityContextW)
#pragma alloc_text(PAGE, KsecLocatePackage)
#pragma alloc_text(PAGE, KSecSerializeWinntAuthData)
#pragma alloc_text(PAGE, KsecSerializeAuthData)
#endif


extern SECPKG_KERNEL_FUNCTION_TABLE KerberosFunctionTable;
extern SECPKG_KERNEL_FUNCTION_TABLE NtLmFunctionTable;
extern SECPKG_KERNEL_FUNCTION_TABLE NegFunctionTable;

FAST_MUTEX  KsecPackageLock ;
LONG KsecConnectionIndicator ;
KEVENT KsecConnectEvent ;
ULONG KsecQuerySizes[] = {
    sizeof( SecPkgContext_Sizes ),
    sizeof( SecPkgContext_Names ),
    sizeof( SecPkgContext_Lifespan ),
    sizeof( SecPkgContext_DceInfo ),
    sizeof( SecPkgContext_StreamSizes ),
    sizeof( SecPkgContext_KeyInfo ),
    sizeof( SecPkgContext_Authority ),
    sizeof( SecPkgContext_ProtoInfo ),
    sizeof( SecPkgContext_PasswordExpiry ),
    sizeof( SecPkgContext_SessionKey ),
    sizeof( SecPkgContext_PackageInfo ),
    sizeof( SecPkgContext_UserFlags ),
    sizeof( SecPkgContext_NegotiationInfo ),
    sizeof( SecPkgContext_NativeNames ),
    sizeof( ULONG ),
    sizeof( PVOID )
};

#define KSecContextAttrSize( attr ) \
        ( attr < sizeof( KsecQuerySizes ) / sizeof( ULONG) ? KsecQuerySizes[ attr ] : sizeof( ULONG ) ) 

#define KSEC_CLEAR_CONTEXT_ATTR( attr, buffer ) \
    RtlZeroMemory( buffer,                      \
    KSecContextAttrSize( attr ) )
//
// This counter controls the paging mode.  >0 indicates that messagemode
// APIs should be paged in.  0 indicates normal operation.  <0 is error
//

LONG KsecPageModeCounter = 0 ;
FAST_MUTEX KsecPageModeMutex ;
HANDLE KsecPagableSection ;

PSECPKG_KERNEL_FUNCTION_TABLE * Packages;

ULONG cKernelPackages;



PSEC_BUILTIN_KPACKAGE   KsecDeferredPackages;

ULONG   KsecDeferredPackageCount;
BOOLEAN PackagesInitialized = FALSE;

UNICODE_STRING  KerberosName = {0, 0, MICROSOFT_KERBEROS_NAME_W };
UNICODE_STRING  NtlmName = {0, 0, NTLMSP_NAME };
UNICODE_STRING  NegotiateName = {0,0, NEGOSSP_NAME };

UCHAR NtlmTag[] = "NTLMSSP" ;

SEC_BUILTIN_KPACKAGE    KsecBuiltinPackages[] = {
    { &NegFunctionTable, &NegotiateName },
    { &KerberosFunctionTable, &KerberosName },
    { &NtLmFunctionTable, &NtlmName }
    } ;

SECPKG_KERNEL_FUNCTIONS KspKernelFunctions = {
        SecAllocate,
        SecFree,
        KSecCreateContextList,
        KSecInsertListEntry,
        KSecReferenceListEntry,
        KSecDereferenceListEntry,
        KSecSerializeWinntAuthData
        };

#define MAYBE_PAGED_CODE() \
    if ( KsecPageModeCounter == 0 ) \
    {                               \
        PAGED_CODE()                \
    }

#define FailIfNoPackages()          \
    if ( Packages == NULL )         \
    {                               \
        return STATUS_UNSUCCESSFUL ;\
    }

//+-------------------------------------------------------------------------
//
//  Function:   InitializePackages
//
//  Synopsis:   Initialize all kernel-mode security packages
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
InitializePackages(
    ULONG   LsaPackageCount )
{
    ULONG Index;
    SECURITY_STATUS scRet = SEC_E_OK;
    ULONG_PTR PackageId;

    PAGED_CODE();

    if ( PackagesInitialized )
    {
        return STATUS_SUCCESS ;
    }

    KSecLockPackageList();

    //
    // Someone might have initialized it by now, so check again.
    //

    if ( PackagesInitialized )
    {
        KSecUnlockPackageList();

        return(STATUS_SUCCESS);
    }

    //
    // Nope, no one doing this yet.  Try to set the flag that we're going
    // to do it.
    //

    if ( KsecConnectionIndicator == 0 )
    {
        KsecConnectionIndicator = 1 ;
    }
    else
    {
        //
        // other thread is already initializing.  Release the lock
        // and wait quietly:
        //

        KSecUnlockPackageList();

        KeWaitForSingleObject( 
            &KsecConnectEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL );


        if ( PackagesInitialized )
        {
            return STATUS_SUCCESS ;

        }

        return STATUS_UNSUCCESSFUL ;
    }

    KSecUnlockPackageList();


    Packages = (PSECPKG_KERNEL_FUNCTION_TABLE *) ExAllocatePool( NonPagedPool,
                    sizeof( PSECPKG_KERNEL_FUNCTION_TABLE ) * LsaPackageCount );


    if ( Packages == NULL )
    {
        return( SEC_E_INSUFFICIENT_MEMORY );
    }

    RtlZeroMemory( Packages,
                   sizeof( PSECPKG_KERNEL_FUNCTION_TABLE ) * LsaPackageCount );

    //
    // Loop through and determine the package id for all builtin packages
    //

    for ( Index = 0 ;
          Index < sizeof( KsecBuiltinPackages ) / sizeof( SEC_BUILTIN_KPACKAGE ) ;
          Index ++ )
    {
        RtlInitUnicodeString( KsecBuiltinPackages[ Index ].Name,
                              KsecBuiltinPackages[ Index ].Name->Buffer );

        scRet = SecpFindPackage( KsecBuiltinPackages[ Index ].Name,
                                 &PackageId );

        if ( NT_SUCCESS( scRet ) &&
             ( Packages[ PackageId ] == NULL ) )
        {
            DebugLog(( DEB_TRACE, "Assigning package %ws index %d\n",
                            KsecBuiltinPackages[Index].Name->Buffer,
                            PackageId ));

            Packages[ PackageId ] = KsecBuiltinPackages[ Index ].Table ;
            KsecBuiltinPackages[ Index ].PackageId = PackageId ;
        }
        else
        {
            DebugLog(( DEB_ERROR, "Could not find builtin package %ws\n",
                            KsecBuiltinPackages[Index].Name->Buffer ));

        }
    }

    if ( KsecDeferredPackageCount )
    {
        for ( Index = 0 ; Index < KsecDeferredPackageCount ; Index++ )
        {
            scRet = SecpFindPackage( KsecDeferredPackages[ Index ].Name,
                                     &PackageId );

            if ( NT_SUCCESS( scRet ) &&
                 ( Packages[ PackageId ] == NULL ) )
            {
                DebugLog(( DEB_TRACE, "Assigning package %ws index %d\n",
                                KsecDeferredPackages[Index].Name->Buffer,
                                PackageId ));

                Packages[ PackageId ] = KsecDeferredPackages[ Index ].Table ;
                KsecDeferredPackages[ Index ].PackageId = PackageId ;
            }
            else
            {
                DebugLog(( DEB_ERROR, "Could not find deferred package %ws\n",
                                KsecDeferredPackages[Index].Name->Buffer ));

            }
        }
    }
    //
    // Now, initialize them:
    //

    for ( Index = 0 ; Index < LsaPackageCount ; Index++ )
    {
        if ( Packages[ Index ] )
        {
            Packages[ Index ]->Initialize( &KspKernelFunctions );

            //
            // If at least one was set up, go with it.
            //

            PackagesInitialized = TRUE;
        }
    }

    cKernelPackages = LsaPackageCount ;

    KsecConnectionIndicator = 0 ;
    KeSetEvent( 
        &KsecConnectEvent, 
        1, 
        FALSE );

    return(scRet);
}


#ifdef KSEC_LEAK_TRACKING

//+---------------------------------------------------------------------------
//
//  Function:   UninitializePackages
//
//  Synopsis:   Frees allocated resources used for packages
//
//  Arguments:  --
//
//  History:    09-03-2000   NeillC   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
UninitializePackages(
    VOID
    )
{
    PSECPKG_KERNEL_FUNCTION_TABLE * TempPackages;

    KSecLockPackageList();
    TempPackages = Packages;
    Packages = NULL;
    KSecUnlockPackageList();

    if (TempPackages != NULL) {
        ExFreePool (TempPackages);
    }
}

#endif  // KSEC_LEAK_TRACKING


//+---------------------------------------------------------------------------
//
//  Function:   KsecRegisterSecurityProvider
//
//  Synopsis:   Registers a new security provider with the driver
//
//  Arguments:  [Name]  --
//              [Table] --
//
//  History:    9-16-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
KSecRegisterSecurityProvider(
    PUNICODE_STRING Name,
    PSECPKG_KERNEL_FUNCTION_TABLE Table)
{
    SEC_BUILTIN_KPACKAGE *  DeferredList ;
    NTSTATUS Status;
    PClient Client;
    ULONG_PTR PackageId;


    KSecLockPackageList();

    if ( Packages == NULL )
    {
        //
        // A driver connected before we were ready.  Put this on the deferred
        // list.
        //

        DeferredList = (PSEC_BUILTIN_KPACKAGE) ExAllocatePool(
                                                PagedPool,
                                                sizeof( SEC_BUILTIN_KPACKAGE ) *
                                                (KsecDeferredPackageCount + 1) );

        if ( DeferredList )
        {
            if ( KsecDeferredPackages )
            {
                RtlCopyMemory( DeferredList,
                               KsecDeferredPackages,
                               sizeof( SEC_BUILTIN_KPACKAGE ) *
                                        KsecDeferredPackageCount );

                ExFreePool( KsecDeferredPackages );

            }

            DeferredList[ KsecDeferredPackageCount ].Name = Name;
            DeferredList[ KsecDeferredPackageCount ].Table = Table ;

            KsecDeferredPackageCount ++ ;
            KsecDeferredPackages = DeferredList ;

            Status = SEC_E_OK ;
        }
        else
        {
            Status = SEC_E_INSUFFICIENT_MEMORY ;
        }
    }
    else
    {
        //
        // Okay, we're up and running.  Find a connection to the
        // LSA.  Hopefully, we've already got a connection, but if
        // not, we'll create a short lived one dynamically.
        //

        Status = LocateClient( &Client );

        if ( NT_ERROR( Status ) )
        {
            Status = CreateClient( FALSE, &Client );

            if (NT_ERROR( Status ) )
            {
                KSecUnlockPackageList();

                return( Status );

            }
        }

        if ( Name->Length + 2 > CBPREPACK )
        {
            KSecUnlockPackageList();

            FreeClient( Client );

            return( SEC_E_INSUFFICIENT_MEMORY );
        }

        Status = SecpFindPackage(   Name,
                                    &PackageId );

        if ( NT_SUCCESS( Status ) )
        {
            if ( PackageId >= cKernelPackages )
            {
                KSecUnlockPackageList();

                FreeClient( Client );

                return( SEC_E_SECPKG_NOT_FOUND );
            }

            if ( Packages[ PackageId ] == NULL )
            {
                Packages[ PackageId ] = Table ;

                Table->Initialize( &KspKernelFunctions );
            }
            else
            {
                Status = SEC_E_SECPKG_NOT_FOUND ;
            }
        }

        FreeClient( Client );

    }

    KSecUnlockPackageList();

    return( Status );
}


//+-------------------------------------------------------------------------
//
//  Function:   KsecLocatePackage
//
//  Synopsis:   Locates a package from its name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS
KsecLocatePackage(
    IN PUNICODE_STRING PackageName,
    OUT PSECPKG_KERNEL_FUNCTION_TABLE * Package,
    OUT PULONG_PTR PackageId
    )
{
    ULONG Index;

    PAGED_CODE();

    *Package = NULL ;

    for ( Index = 0 ;
          Index < sizeof( KsecBuiltinPackages ) / sizeof( SEC_BUILTIN_KPACKAGE ) ;
          Index ++ )
    {
        if (RtlEqualUnicodeString(
                PackageName,
                KsecBuiltinPackages[Index].Name,
                TRUE))
        {
            *Package = KsecBuiltinPackages[ Index ].Table ;
            *PackageId = KsecBuiltinPackages[ Index ].PackageId ;
            return(STATUS_SUCCESS);
        }
    }
    for (Index = 0; Index < KsecDeferredPackageCount ; Index++ )
    {
        if (RtlEqualUnicodeString(
                PackageName,
                KsecDeferredPackages[Index].Name,
                TRUE))
        {
            *Package = KsecDeferredPackages[Index].Table;
            *PackageId = KsecDeferredPackages[ Index ].PackageId ;
            return(STATUS_SUCCESS);
        }
    }
    return(SEC_E_SECPKG_NOT_FOUND);
}


extern "C"
SECURITY_STATUS
SEC_ENTRY
SecSetPagingMode(
    BOOLEAN Pageable
    )
{
    ULONG PackageIndex ;
    NTSTATUS Status = STATUS_SUCCESS ;

    PAGED_CODE();

    ExAcquireFastMutex( &KsecPageModeMutex );

    if ( !Pageable )
    {
        //
        // If we have already done the work, just bump the counter and return
        //
        if ( KsecPageModeCounter++ )
        {
            ExReleaseFastMutex( &KsecPageModeMutex );

            return STATUS_SUCCESS ;
        }
    }
    else
    {
        //
        // If the counter is greater than one, don't worry about setting
        // or resetting everything
        //

        if ( --KsecPageModeCounter )
        {
            ExReleaseFastMutex( &KsecPageModeMutex );

            return STATUS_SUCCESS ;
        }
    }

    //
    // At this point, we must actually do the work:
    //

    if ( Pageable )
    {
        for ( PackageIndex = 0 ; PackageIndex < cKernelPackages ; PackageIndex++ )
        {
            if ( Packages[ PackageIndex ] &&
                 Packages[ PackageIndex ]->SetPackagePagingMode )
            {
                Status = Packages[ PackageIndex ]->SetPackagePagingMode( TRUE );

                if ( !NT_SUCCESS( Status ) )
                {
                    break;
                }
            }
        }

        if ( NT_SUCCESS( Status ) )
        {
            MmUnlockPagableImageSection( KsecPagableSection );

            KsecPagableSection = NULL ;
        }

    }
    else
    {
        KsecPagableSection = MmLockPagableCodeSection( CompleteAuthToken  );

        if ( KsecPagableSection )
        {
            for ( PackageIndex = 0 ; PackageIndex < cKernelPackages ; PackageIndex++ )
            {
                if ( Packages[ PackageIndex ] &&
                     Packages[ PackageIndex ]->SetPackagePagingMode )
                {
                    Status = Packages[ PackageIndex ]->SetPackagePagingMode( FALSE );

                    if ( !NT_SUCCESS( Status ) )
                    {
                        break;
                    }
                }
            }
        }
    }

    ExReleaseFastMutex( &KsecPageModeMutex );

    return Status ;
}

//+-------------------------------------------------------------------------
//
//  Function:   CompleteAuthToken
//
//  Synopsis:   Kernel dispatch stub for CompleteAuthToken - just turns
//              around and calls the package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
CompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->CompleteToken(
                    phContext->dwUpper,
                    pToken);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }


    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   ImpersonateSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
ImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    )
{
    SECURITY_STATUS scRet;
    PACCESS_TOKEN AccessToken = NULL;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->GetToken(
                    phContext->dwUpper,
                    NULL,
                    &AccessToken
                    );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE ;
    }

    if (NT_SUCCESS(scRet))
    {
        ASSERT(AccessToken != NULL);
        scRet = PsImpersonateClient(
                    PsGetCurrentThread(),
                    AccessToken,
                    FALSE,              // don't copy on open
                    FALSE,              // not effective only
                    SeTokenImpersonationLevel(AccessToken)
                    );

    }


    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   RevertSecurityContext
//
//  Synopsis:   Revert the thread to the process identity
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
RevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    )
{
    SECURITY_IMPERSONATION_LEVEL Unused = SecurityImpersonation;

    PAGED_CODE();

    PsImpersonateClient(
        PsGetCurrentThread(),
        NULL,
        FALSE,
        FALSE,
        Unused
        );

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityContextToken
//
//  Synopsis:   Returns a copy ofthe context's token
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
QuerySecurityContextToken(
    PCtxtHandle                 phContext,
    PHANDLE                     TokenHandle
    )
{
    SECURITY_STATUS scRet;
    HANDLE      hToken = NULL ;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->GetToken(
                    phContext->dwUpper,
                    &hToken,
                    NULL
                    );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }
    if (NT_SUCCESS(scRet))
    {
        //
        // Duplicate the token so the caller may hold onto it after
        // deleting the context
        //

        scRet = NtDuplicateObject(
                    NtCurrentProcess(),
                    hToken,
                    NtCurrentProcess(),
                    TokenHandle,
                    0,                  // desired access
                    0,                  // handle attributes
                    DUPLICATE_SAME_ACCESS
                    );

    }

    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   QueryContextAttributes
//
//  Synopsis:   Queries attributes of a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



SECURITY_STATUS SEC_ENTRY
QueryContextAttributes(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    KSEC_CLEAR_CONTEXT_ATTR( ulAttribute, pBuffer );

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->QueryAttributes(
                    phContext->dwUpper,
                    ulAttribute,
                    pBuffer);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   MakeSignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
MakeSignature(  PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    SECURITY_STATUS scRet;

    MAYBE_PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->Sign(
                    phContext->dwUpper,
                    fQOP,
                    pMessage,
                    MessageSeqNo);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   VerifySignature
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to verify
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
VerifySignature(PCtxtHandle     phContext,
                PSecBufferDesc  pMessage,
                ULONG           MessageSeqNo,
                ULONG *         pfQOP)
{
    SECURITY_STATUS scRet;

    MAYBE_PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->Verify(
                    phContext->dwUpper,
                    pMessage,
                    MessageSeqNo,
                    pfQOP);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);

}

//+---------------------------------------------------------------------------
//
//  Function:   SealMessage
//
//  Synopsis:   Seals a message
//
//  Effects:
//
//  Arguments:  [phContext]     -- context to use
//              [fQOP]          -- quality of protection to use
//              [pMessage]      -- message
//              [MessageSeqNo]  -- sequence number of message
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
SealMessage(    PCtxtHandle         phContext,
                ULONG               fQOP,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo)
{
    SECURITY_STATUS scRet;

    MAYBE_PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->Seal(
                    phContext->dwUpper,
                    fQOP,
                    pMessage,
                    MessageSeqNo);
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);


}

//+---------------------------------------------------------------------------
//
//  Function:   UnsealMessage
//
//  Synopsis:   Unseal a private message
//
//  Arguments:  [phContext]     -- Context performing the unseal
//              [pMessage]      -- Message to unseal
//              [MessageSeqNo]  -- Sequence number of this message
//              [pfQOPUsed]     -- quality of protection used
//
//  History:    5-06-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
UnsealMessage(  PCtxtHandle         phContext,
                PSecBufferDesc      pMessage,
                ULONG               MessageSeqNo,
                ULONG *             pfQOP)
{
    SECURITY_STATUS scRet;

    MAYBE_PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)   {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->Unseal(
                    phContext->dwUpper,
                    pMessage,
                    MessageSeqNo,
                    pfQOP);
    }

    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);

}




//+-------------------------------------------------------------------------
//
//  Function:   DeleteUserModeContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
DeleteUserModeContext(
    IN PCtxtHandle phContext,           // Contxt to delete
    OUT PCtxtHandle phLsaContext
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext == NULL)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    if (phContext->dwLower < cKernelPackages)   {

        if (Packages[KsecPackageIndex(phContext->dwLower)]->DeleteContext == NULL)
        {
            return(SEC_E_UNSUPPORTED_FUNCTION);
        }

        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->DeleteContext(
                    phContext->dwUpper,
                    &phLsaContext->dwUpper);

        if( scRet == STATUS_INVALID_HANDLE )
        {
            //
            // NTBUG 402192
            // incomplete kernel mode contexts will cause a leak in the LSA
            // process.
            // Tell the LSA to delete the LSA mode handle.
            //

            DebugLog(( DEB_WARN, "Possibly invalid handle passed to DeleteUserModeContext (incomplete? %lx)\n", phContext->dwUpper ));
            scRet = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(scRet))
        {
            phLsaContext->dwLower = phContext->dwLower;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//--------------------------------------------------------------------------
//
//  Function:   MapKernelContextHandle
//
//  Synopsis:   Maps a context handle from kernel mode to lsa mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
MapKernelContextHandle(
    IN PCtxtHandle phContext,           // Contxt to map
    OUT PCtxtHandle phLsaContext
    )
{
    SECURITY_STATUS scRet = STATUS_SUCCESS;

    PAGED_CODE();

    FailIfNoPackages();

    //
    // If both elements are NULL, this is a null handle.
    //

    if ((phContext->dwLower == 0) && (phContext->dwUpper == 0))
    {
        *phLsaContext = *phContext;
    }
    else
    {
        if ( ( phContext->dwLower < cKernelPackages ) &&
             ( (PUCHAR) phContext->dwUpper < (PUCHAR) (MM_USER_PROBE_ADDRESS) ))
        {
            *phLsaContext = *phContext ;
            return STATUS_SUCCESS;
        }

        if (phContext->dwLower < cKernelPackages)   {
            scRet = Packages[KsecPackageIndex(phContext->dwLower)]->MapHandle(
                        phContext->dwUpper,
                        &phLsaContext->dwUpper);
            if (NT_SUCCESS(scRet))
            {
                phLsaContext->dwLower = phContext->dwLower;
            }
        }
        else
        {
            scRet = SEC_E_INVALID_HANDLE;
        }

    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   InitUserModeContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
InitUserModeContext(
    IN PCtxtHandle                 phContext,      // Contxt to init
    IN PSecBuffer                  pContextBuffer,
    OUT PCtxtHandle                phNewContext
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    if (phContext->dwLower < cKernelPackages)   {
        scRet = Packages[KsecPackageIndex(phContext->dwLower)]->InitContext(
                    phContext->dwUpper,
                    pContextBuffer,
                    &phNewContext->dwUpper
                    );
        if (NT_SUCCESS(scRet))
        {
            phNewContext->dwLower = phContext->dwLower;
        }
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   ExportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ExportSecurityContext(
    IN PCtxtHandle ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer MarshalledContext,
    OUT PHANDLE TokenHandle
    )
{
    SECURITY_STATUS scRet;

    PAGED_CODE();

    FailIfNoPackages();

    if (ContextHandle->dwLower < cKernelPackages)
    {
        scRet = Packages[KsecPackageIndex(ContextHandle->dwLower)]->ExportContext(
                    ContextHandle->dwUpper,
                    Flags,
                    MarshalledContext,
                    TokenHandle
                    );
    }
    else
    {
        scRet = SEC_E_INVALID_HANDLE;
    }

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   ImportSecurityContextW
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS
SEC_ENTRY
ImportSecurityContextW(
    IN PUNICODE_STRING PackageName,
    IN PSecBuffer MarshalledContext,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PSECPKG_KERNEL_FUNCTION_TABLE Package;
    ULONG_PTR TempContextHandle = -1;
    ULONG_PTR PackageId = -1;
    SECURITY_STATUS SecStatus = STATUS_SUCCESS;

    PAGED_CODE();

    FailIfNoPackages();

    SecStatus = KsecLocatePackage( PackageName,&Package, &PackageId );

    if ( NT_SUCCESS( SecStatus )  )
    {

        if (Package->ImportContext != NULL)
        {

            SecStatus = Package->ImportContext(
                            MarshalledContext,
                            TokenHandle,
                            &TempContextHandle
                            );

        }
        else
        {
            SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        }

        if (NT_SUCCESS(SecStatus))
        {
            ContextHandle->dwUpper = TempContextHandle;
            ContextHandle->dwLower = PackageId;
        }
    }
    else
    {
        SecStatus =  SEC_E_SECPKG_NOT_FOUND;
    }

    return(SecStatus);
}

extern "C"
SECURITY_STATUS
SEC_ENTRY
KSecValidateBuffer(
    PUCHAR Buffer,
    ULONG Length
    )
{
    UCHAR Test ;
    ULONG ClaimedLength ;
    ULONG ByteCount ;
    ULONG i ;

    if ( Length == 0 )
    {
        return STATUS_SUCCESS ;
    }

    if ( Length >= sizeof( NtlmTag )  )
    {
        if ( RtlEqualMemory( Buffer, NtlmTag, sizeof( NtlmTag ) ) )
        {
            return STATUS_SUCCESS ;
        }
    }
    //
    // This does a poor man's validation of the BER encoded SNEGO buffer
    //

    //
    // First, make sure the first byte is a BER value for Context Specific
    //

    Test = Buffer[0] & 0xC0 ;


    if ( (Test != 0x80 ) &&
         (Test != 0x40 ) )
    {
//        DbgPrint( "KSEC:  Buffer does not lead off with 'Context' or 'Application' specific\n");
        goto Bad_Buffer ;
    }

    //
    // Now, check the claimed size in the header with the size we were passed:
    //

    Buffer++ ;
    ClaimedLength = 0 ;

    if (*Buffer & 0x80)
    {
        ByteCount = *Buffer++ & 0x7f;

        for (i = 0; i < ByteCount ; i++ )
        {
            ClaimedLength <<= 8;
            ClaimedLength += *Buffer++;
        }
    }
    else
    {
        ByteCount = 0;
        ClaimedLength = *Buffer++;
    }

    if ( (ClaimedLength + 2 + ByteCount) != Length )
    {
//        DbgPrint( "KSEC: Packet claimed length %x, actual length is %x\n",
//                    ClaimedLength + 2 + ByteCount, Length );

        goto Bad_Buffer ;
    }

    return STATUS_SUCCESS ;

Bad_Buffer:

    return STATUS_DATA_ERROR ;


}

NTSTATUS
KSecSerializeWinntAuthData(
    IN PVOID pvAuthData,
    OUT PULONG SerializedSize,
    OUT PVOID * SerializedData
    )
{
    PSEC_WINNT_AUTH_IDENTITY Auth ;
    PSEC_WINNT_AUTH_IDENTITY_EX AuthEx ;
    PSEC_WINNT_AUTH_IDENTITY_EX Serialized ;
    SEC_WINNT_AUTH_IDENTITY_EX Local ;
    ULONG Size = 0 ;
    PUCHAR Where ;
    NTSTATUS Status = STATUS_SUCCESS ;


    //
    // We're in kernel mode, so we're trusting our callers not to
    // pass us bogus data.  
    //

    Auth = (PSEC_WINNT_AUTH_IDENTITY) pvAuthData ;
    AuthEx = (PSEC_WINNT_AUTH_IDENTITY_EX) pvAuthData ;

    if ( AuthEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION )
    {
        //
        // This is a EX structure.  
        //

        if ( AuthEx->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED )
        {
            //
            // Easy case:  This is already serialized by the caller.
            //

            Size = sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) ;

            if ( AuthEx->DomainLength )
            {
                Size += (AuthEx->DomainLength + 1) * sizeof(WCHAR) ;
                
            }
            if ( AuthEx->PackageListLength )
            {
                Size += (AuthEx->PackageListLength + 1) * sizeof( WCHAR );
                
            }

            if ( AuthEx->UserLength )
            {
                Size += (AuthEx->UserLength + 1) * sizeof( WCHAR );
                
            }

            if ( AuthEx->PasswordLength )
            {
                Size += (AuthEx->PasswordLength + 1) * sizeof( WCHAR );
                
            }

            *SerializedSize = Size ;
            *SerializedData = AuthEx ;

            return STATUS_SUCCESS ;
            
        }

        Auth = NULL ;

    }
    else
    {

        if ( Auth->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED )
        {
            //
            // Easy case:  This is already serialized by the caller.
            //

            Size = sizeof( SEC_WINNT_AUTH_IDENTITY ) ;

            if ( Auth->DomainLength )
            {
                Size += (Auth->DomainLength + 1) * sizeof( WCHAR ) ;
                
            }

            if ( Auth->PasswordLength )
            {
                Size += (Auth->PasswordLength + 1) * sizeof( WCHAR );
                
            }

            if ( Auth->UserLength )
            {
                Size += (Auth->UserLength + 1) * sizeof( WCHAR );
                
            }


            *SerializedSize = Size ;
            *SerializedData = Auth ;

            return STATUS_SUCCESS ;
            
            
        }

        AuthEx = NULL ;
    }

    if ( Auth )
    {
        Local.Flags = Auth->Flags ;
        Local.Domain = Auth->Domain ;
        Local.DomainLength = Auth->DomainLength ;
        Local.Password = Auth->Password ;
        Local.PasswordLength = Auth->PasswordLength ;
        Local.User = Auth->User ;
        Local.UserLength = Auth->UserLength ;

        Local.Version = SEC_WINNT_AUTH_IDENTITY_VERSION ;
        Local.Length = sizeof( SEC_WINNT_AUTH_IDENTITY_EX );
        Local.PackageList = NULL ;
        Local.PackageListLength = 0 ;

        AuthEx = &Local ;
        
    }

    if ( AuthEx )
    {
        Size = sizeof( SEC_WINNT_AUTH_IDENTITY_EX ) +
            ( AuthEx->DomainLength + AuthEx->PackageListLength +
            AuthEx->PasswordLength + AuthEx->UserLength + 4 ) * sizeof( WCHAR );

        Serialized = (PSEC_WINNT_AUTH_IDENTITY_EX) ExAllocatePool( PagedPool, Size );

        if ( Serialized )
        {
            Serialized->Flags = AuthEx->Flags | SEC_WINNT_AUTH_IDENTITY_MARSHALLED ;
            Serialized->Version = SEC_WINNT_AUTH_IDENTITY_VERSION ;
            Serialized->Length = sizeof( SEC_WINNT_AUTH_IDENTITY_EX );
            
            Where = (PUCHAR) ( Serialized + 1);

            if ( AuthEx->User )
            {
                Serialized->User = (PWSTR) (Where - (PUCHAR) Serialized );
                RtlCopyMemory(
                    Where,
                    AuthEx->User,
                    AuthEx->UserLength * sizeof( WCHAR ) );

                Serialized->UserLength = AuthEx->UserLength ;

                Where += AuthEx->UserLength * sizeof( WCHAR );


                *Where++ = '\0';    // unicode null terminator
                *Where++ = '\0';
                
            }
            else
            {

                Serialized->User = NULL ;
                Serialized->UserLength = 0 ;
            }

            if ( AuthEx->Domain )
            {
                Serialized->Domain = (PWSTR) (Where - (PUCHAR) Serialized );

                RtlCopyMemory(
                    Where,
                    AuthEx->Domain,
                    AuthEx->DomainLength * sizeof( WCHAR ) );

                Serialized->DomainLength = AuthEx->DomainLength ;

                Where += AuthEx->DomainLength * sizeof( WCHAR );

                *Where++ = '\0';    // unicode null terminator
                *Where++ = '\0';
                
            }
            else
            {
                Serialized->Domain = NULL ;
                Serialized->DomainLength = 0 ;
            }

            if ( AuthEx->Password )
            {
                Serialized->Password = (PWSTR) (Where - (PUCHAR) Serialized );
                RtlCopyMemory(
                    Where,
                    AuthEx->Password,
                    AuthEx->PasswordLength * sizeof( WCHAR ) );

                Serialized->PasswordLength = AuthEx->PasswordLength ;

                Where += AuthEx->PasswordLength * sizeof( WCHAR );

                *Where++ = '\0';    // unicode null terminator
                *Where++ = '\0';
                
            }
            else
            {
                Serialized->Password = NULL ;
                Serialized->PasswordLength = 0 ;
            }

            if ( AuthEx->PackageList )
            {
                Serialized->PackageList = (PWSTR) (Where - (PUCHAR) Serialized );
                RtlCopyMemory(
                    Where,
                    AuthEx->PackageList,
                    AuthEx->PackageListLength * sizeof( WCHAR ) );

                Serialized->PackageListLength = AuthEx->PackageListLength ;

                Where += AuthEx->PackageListLength * sizeof( WCHAR );

                *Where++ = '\0';    // unicode null terminator
                *Where++ = '\0';
                
            }
            else
            {
                Serialized->PackageList = NULL ;
                Serialized->PackageListLength = 0 ;
            }

            
        }
        else
        {
            Status = STATUS_NO_MEMORY ;
        }

        *SerializedSize = Size ;
        *SerializedData = Serialized;
        
    }

    return Status ;

}

NTSTATUS
KsecSerializeAuthData(
    PSECURITY_STRING Package,
    PVOID AuthData,
    PULONG SerializedSize,
    PVOID * SerializedData
    )
{


    return KSecSerializeWinntAuthData( AuthData, SerializedSize, SerializedData );

}



//+---------------------------------------------------------------------------
//
//  Function:   KsecQueryContextAttributes
//
//  Synopsis:   Thunk to get from kernel to LSA mode
//
//  Arguments:  [phContext]   -- 
//              [Attribute]   -- 
//              [Buffer]      -- 
//              [Extra]       -- 
//              [ExtraLength] -- 
//
//  Returns:    
//
//  Notes:      
//
//----------------------------------------------------------------------------

SECURITY_STATUS
KsecQueryContextAttributes(
    IN PCtxtHandle  phContext,
    IN ULONG        Attribute,
    IN OUT PVOID    Buffer,
    IN PVOID        Extra,
    IN ULONG        ExtraLength
    )
{
    ULONG Allocs = 8;
    PVOID Buffers[ 8 ];
    ULONG Flags ;
    PKSEC_LSA_MEMORY LsaMemory;
    NTSTATUS Status ;
    ULONG AttrSize ;
    ULONG Size ;

    AttrSize = KSecContextAttrSize( Attribute );
    Size = AttrSize + ExtraLength ;

    LsaMemory = KsecAllocLsaMemory( Size );

    if ( !LsaMemory )
    {
        return STATUS_NO_MEMORY ;
        
    }
    

    Status = KsecCopyPoolToLsa(
                LsaMemory,
                sizeof( KSEC_LSA_MEMORY_HEADER ),
                Buffer,
                AttrSize );

    if ( NT_SUCCESS( Status ) && ExtraLength )
    {
        Status = KsecCopyPoolToLsa(
                    LsaMemory,
                    sizeof( KSEC_LSA_MEMORY_HEADER ) + AttrSize,
                    Extra,
                    ExtraLength );
        
    }

    if ( !NT_SUCCESS( Status ) )
    {
        KsecFreeLsaMemory( LsaMemory );
        return Status ;
    }

    Flags = SPMAPI_FLAG_KMAP_MEM ;

    Status = SecpQueryContextAttributes(
                KsecLsaMemoryToContext(LsaMemory),
                phContext,
                Attribute,
                Buffer,
                &Allocs,
                Buffers,
                &Flags );

    if ( NT_SUCCESS( Status ) )
    {
        Status = KsecCopyLsaToPool(
                    Buffer,
                    LsaMemory,
                    (PUCHAR) LsaMemory->Region + sizeof( KSEC_LSA_MEMORY_HEADER ),
                    AttrSize );

        if ( NT_SUCCESS( Status ) && ExtraLength )
        {
            Status = KsecCopyLsaToPool(
                        Extra,
                        LsaMemory,
                        (PUCHAR) LsaMemory->Region + (sizeof( KSEC_LSA_MEMORY_HEADER) + AttrSize),
                        ExtraLength );
            
        }
                    
        
    }

    KsecFreeLsaMemory( LsaMemory );

    return Status ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\debug.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.c
//
//  Contents:   Debug support for the security client dll
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\debug.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       debug.h
//
//  Contents:   Debug headers for the security dll
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\extapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        extapi.cxx
//
// Contents:    user-mode stubs for security extension APIs
//
//
// History:     3-5-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "..\dll\extapi.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\stubdll\stubdll.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       stubdll.c
//
//  Contents:   Stub calls to secur32.DLL
//
//  Classes:
//
//  Functions:
//
//  History:    10-05-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include <windows.h>

int
WINAPI
LibMain(
    HINSTANCE   hDll,
    DWORD       dwReason,
    PVOID       Context)
{
    DisableThreadLibraryCalls( hDll );
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\negstubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       negstubs.cxx
//
//  Contents:   Stubs to the negotiate package
//
//  Classes:
//
//  Functions:
//
//  History:    8-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\negstubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\newstubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       newstubs.cxx
//
//  Contents:   Stubs from ntlmssp
//
//  History:    9-06-96   RichardW   Stolen from ntlmssp
//
//----------------------------------------------------------------------------

#include "..\dll\newstubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\lsastubs.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       lsastubs.cxx
//
//  Contents:   Stubs to the pseudo-sspi dll that talks to the LSA
//
//  Classes:
//
//  Functions:
//
//  History:    8-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\lsastubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\sasl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       newstubs.cxx
//
//  Contents:   Stubs from ntlmssp
//
//  History:    9-06-96   RichardW   Stolen from ntlmssp
//
//----------------------------------------------------------------------------

#include "..\dll\sasl.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\package.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        Package.c
//
// Contents:    Package management routines for the security DLL
//
//
// History:     12 Mar 92,  RichardW    Created
//              17 Aug 92,  RichardW    Rearranged, commented, etc.
//              08 Mar 94,  MikeSw      Moved to C++
//
//------------------------------------------------------------------------

#include "..\dll\package.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\secdll.h ===
//+-----------------------------------------------------------------------
//
// File:        SECDLL.H
//
// Contents:    Security DLL private defines
//
//
// History:     11 Mar 92   RichardW    Recreated
//
//------------------------------------------------------------------------

#include "..\dll\secdll.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\stubs.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        stubs.cxx
//
// Contents:    user-mode stubs for security API
//
//
// History:     3/5/94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "..\dll\stubs.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\handle.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       handle.cxx
//
//  Contents:   Manages the handle map to the thunking layer.
//
//  Classes:
//
//  Functions:
//
//  History:    1-10-00   RichardW   Created
//
//----------------------------------------------------------------------------

#include <secpch2.hxx>
#pragma hdrstop

extern "C"
{
#include <spmlpc.h>
#include <lpcapi.h>
#include "secdll.h"
}

LIST_ENTRY HandleMapList ;
RTL_CRITICAL_SECTION HandleMapLock ;

BOOL
SecpInitHandleMap(
    VOID
    )
{
    NTSTATUS Status ;

    InitializeListHead( &HandleMapList );

    Status = RtlInitializeCriticalSection( &HandleMapLock );

    return NT_SUCCESS( Status );
}

BOOL
SecpFreeHandleMap(
    VOID
    )
{
    PLIST_ENTRY Scan ;

    RtlEnterCriticalSection( &HandleMapLock );

    while ( ! IsListEmpty( &HandleMapList ) )
    {
        Scan = RemoveHeadList( &HandleMapList );

        LocalFree( Scan );
    }

    RtlLeaveCriticalSection( &HandleMapLock );

    RtlDeleteCriticalSection( &HandleMapLock );

    return TRUE ;
}


BOOL
SecpAddHandleMap(
    IN PSEC_HANDLE_LPC LsaHandle,
    OUT PSECWOW_HANDLE_MAP * LocalHandle
    )
{
    PLIST_ENTRY Scan ;
    PSECWOW_HANDLE_MAP HandleMap = NULL ;


    //
    // The most labor intensive function.  First, scan through the list, 
    // checking if we already have an entry for this:
    //

    RtlEnterCriticalSection( &HandleMapLock );

    Scan = HandleMapList.Flink ;

    while ( Scan != &HandleMapList )
    {
        HandleMap = CONTAINING_RECORD( Scan, SECWOW_HANDLE_MAP, List );

        if ( RtlEqualMemory( &HandleMap->Handle,
                             LsaHandle,
                             sizeof( SEC_HANDLE_LPC ) ) )
        {
            break;
        }

        Scan = Scan->Flink ;

        HandleMap = NULL ;
    }

    if ( HandleMap )
    {
        HandleMap->RefCount++ ;
        HandleMap->HandleCount++ ;

    }

    RtlLeaveCriticalSection( &HandleMapLock );

    if ( !HandleMap )
    {
        HandleMap = (PSECWOW_HANDLE_MAP) LocalAlloc( LMEM_FIXED, 
                                                     sizeof( SECWOW_HANDLE_MAP ) );

        if ( HandleMap )
        {
            HandleMap->RefCount = 1;
            HandleMap->HandleCount = 1;
            HandleMap->Handle = *LsaHandle;

            RtlEnterCriticalSection( &HandleMapLock );

            InsertHeadList( &HandleMapList, &HandleMap->List );

            RtlLeaveCriticalSection( &HandleMapLock );

            DebugLog(( DEB_TRACE, "New handle map at %p, for " POINTER_FORMAT ":" POINTER_FORMAT "\n",
                       HandleMap, LsaHandle->dwUpper, LsaHandle->dwLower ));

        }
    }

    *LocalHandle = HandleMap ;

    return (HandleMap != NULL);
}

VOID
SecpDeleteHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap
    )
{
    RtlEnterCriticalSection( &HandleMapLock );

    HandleMap->HandleCount-- ;

    SecpDerefHandleMap( HandleMap );

    RtlLeaveCriticalSection( &HandleMapLock );
}

VOID
SecpDerefHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap
    )
{
    BOOL FreeIt = FALSE;

    RtlEnterCriticalSection( &HandleMapLock );

    HandleMap->RefCount-- ;

    if ( HandleMap->RefCount == 0 )
    {
        RemoveEntryList( &HandleMap->List );

        FreeIt = TRUE ;
    }

    RtlLeaveCriticalSection( &HandleMapLock );

    if ( FreeIt )
    {
        DebugLog(( DEB_TRACE, "Freeing handle map at %p, for " POINTER_FORMAT ":" POINTER_FORMAT "\n",
                   HandleMap, HandleMap->Handle.dwUpper, HandleMap->Handle.dwLower ));

        LocalFree( HandleMap );
    }
}

VOID
SecpReferenceHandleMap(
    IN PSECWOW_HANDLE_MAP HandleMap,
    OUT PSEC_HANDLE_LPC LsaHandle
    )
{
    RtlEnterCriticalSection( &HandleMapLock );

    HandleMap->RefCount++ ;

    *LsaHandle = HandleMap->Handle ;

    RtlLeaveCriticalSection( &HandleMapLock );

    DebugLog(( DEB_TRACE, "Referencing handle map at %p for " POINTER_FORMAT ":" POINTER_FORMAT "\n",
                   HandleMap, HandleMap->Handle.dwUpper, HandleMap->Handle.dwLower ));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\stubsa.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       stubsa.cxx
//
//  Contents:   ANSI stubs for security functions
//
//  History:    8-05-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\stubsa.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\userstub.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        userstub.cxx
//
// Contents:    stubs for user-mode security APIs
//
//
// History:     3-7-94      MikeSw      Created
//
//------------------------------------------------------------------------

#include "..\dll\userstub.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\support.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        support.cxx
//
// Contents:    support routines for security dll
//
//
// History:     3-7-94      Created     MikeSw
//
//------------------------------------------------------------------------

#include "..\dll\support.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\security\wow6432\xlate.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       xlate.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9-02-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "..\dll\xlate.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\au.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    au.h

Abstract:

    LSA Authentication - Exported Function Definitions, Datatypes and Defines

    This module contains the LSA Authentication Routines that may be called
    by parts of the LSA outside the Authentication sub-component.

Author:

    Scott Birrell       (ScottBi)       March 24, 1992

Environment:

Revision History:

--*/

NTSTATUS
LsapAuOpenSam( BOOLEAN DuringStartup );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\adt.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adt.h

Abstract:

    Local Security Authority - Audit Log Management - Public Defines,
    data and function prototypes.

    Functions, data and defines in this module are exported to the
    whole of the Lsa subsystem from the Auditing Sub-component.

Author:

    Scott Birrell       (ScottBi)      November 20, 1991

Environment:

Revision History:

--*/

#ifndef _ADT_H
#define _ADT_H

//
// Initialization Pass for Auditing.
//

extern ULONG LsapAdtInitializationPass;

//
// Audit Log Information.  This must be kept in sync with the information
// in the Lsa Database.
//

extern POLICY_AUDIT_LOG_INFO LsapAdtLogInformation;

extern LSARM_POLICY_AUDIT_EVENTS_INFO LsapAdtEventsInformation;

//
// Audit Log Full Information.
//

extern POLICY_AUDIT_FULL_QUERY_INFO LsapAdtLogFullInformation;

//
// Audit Log Maximum Record Id.  Audit Records are numbered serially until
// this limit is reached, then numbering wraps to 0.
//

#define LSAP_ADT_MAXIMUM_RECORD_ID   (0x7fffffffL)

//
// Options for LsapAdtQueryAuditLogFullInfo
//

#define LSAP_ADT_LOG_FULL_UPDATE     ((ULONG)(0x00000001L))


NTSTATUS
LsapAdtWriteLogWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    );

NTSTATUS
LsapAdtSetInfoLog(
    IN LSAPR_HANDLE PolicyHandle,
    IN PPOLICY_AUDIT_LOG_INFO PolicyAuditLogInfo
    );

NTSTATUS
LsapAdtInitialize(
    );

NTSTATUS
LsapAdtInitializeDefaultAuditing(
    IN ULONG Options,
    OUT PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInformation
    );

VOID
LsapAdtAuditingLogon(
    PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInfo
    );


VOID
LsapAdtAuditPackageLoad(
    PUNICODE_STRING PackageFileName
    );

VOID
LsapAdtGenerateLsaAuditSystemAccessChange(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PSID TargetSid,
    IN PCWSTR szSystemAccess
    );

NTSTATUS
LsapAdtGenerateLsaAuditEvent(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG AuditEventCategory,
    IN ULONG AuditEventId,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG SidCount,
    IN PSID *Sids OPTIONAL,
    IN ULONG UnicodeStringCount,
    IN PUNICODE_STRING UnicodeStrings OPTIONAL,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo OPTIONAL
    );

NTSTATUS
LsapAdtTrustedDomainAdd(
    IN USHORT          EventType,
    IN PUNICODE_STRING pName,
    IN PSID            pSid,
    IN ULONG           Type,
    IN ULONG           Direction,
    IN ULONG           Attributes
    );

NTSTATUS
LsapAdtTrustedDomainRem(
    IN USHORT          EventType,
    IN PUNICODE_STRING pName,
    IN PSID            pSid,
    IN PSID            pClientSid,
    IN PLUID           pClientAuthId
    );

NTSTATUS
LsapAdtTrustedDomainMod(
    IN USHORT          EventType,
    IN PSID            pDomainSid,

    IN PUNICODE_STRING pOldName,
    IN ULONG           OldType,
    IN ULONG           OldDirection,
    IN ULONG           OldAttributes,

    IN PUNICODE_STRING pNewName,
    IN ULONG           NewType,
    IN ULONG           NewDirection,
    IN ULONG           NewAttributes
    );


NTSTATUS
LsapAdtGenerateLsaAuditEventWithClientSid(
    IN ULONG AuditEventCategory,
    IN ULONG AuditEventId,
    IN PSID ClientSid,
    IN LUID ClientAuthenticationId,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG SidCount,
    IN PSID *Sids OPTIONAL,
    IN ULONG UnicodeStringCount,
    IN PUNICODE_STRING UnicodeStrings OPTIONAL,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo OPTIONAL
    );

typedef enum _OBJECT_OPERATION_TYPE {
    ObjectOperationNone=0,
    ObjectOperationQuery,
    ObjectOperationDummyLast
} OBJECT_OPERATION_TYPE;

NTSTATUS
LsapAdtGenerateObjectOperationAuditEvent(
    IN LSAPR_HANDLE ObjectHandle,
    IN USHORT AuditEventType,
    IN OBJECT_OPERATION_TYPE OperationType
    );

NTSTATUS
LsapAdtGenerateDomainPolicyChangeAuditEvent(
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN USHORT AuditEventType,
    IN LSAP_DB_ATTRIBUTE* OldAttributes,
    IN LSAP_DB_ATTRIBUTE* NewAttributes,
    IN ULONG AttributeCount
    );

BOOLEAN
LsapAdtIsAuditingEnabledForCategory(
    IN POLICY_AUDIT_EVENT_TYPE AuditCategory,
    IN UINT AuditEventType
    );

NTSTATUS
LsapAdtTrustedForestNamespaceCollision(
    IN LSA_FOREST_TRUST_COLLISION_RECORD_TYPE CollisionTargetType,
    IN PUNICODE_STRING pCollisionTargetName,
    IN PUNICODE_STRING pForestRootDomainName,
    IN PUNICODE_STRING pTopLevelName,
    IN PUNICODE_STRING pDnsName,
    IN PUNICODE_STRING pNetbiosName,
    IN PSID            pSid,
    IN ULONG           NewFlags
    );

NTSTATUS
LsapAdtTrustedForestInfoEntryAdd(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    );

NTSTATUS
LsapAdtTrustedForestInfoEntryRem(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    );

NTSTATUS
LsapAdtTrustedForestInfoEntryMod(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
                                    
    IN ULONG           OldFlags,
    IN PUNICODE_STRING pOldTopLevelName,
    IN PUNICODE_STRING pOldDnsName,
    IN PUNICODE_STRING pOldNetbiosName,
    IN PSID            pOldSid,
                       
    IN ULONG           NewFlags,
    IN PUNICODE_STRING pNewTopLevelName,
    IN PUNICODE_STRING pNewDnsName,
    IN PUNICODE_STRING pNewNetbiosName,
    IN PSID            pNewSid
    );



#define LsapAdtAuditingEnabled()                                        \
            (LsapAdtEventsInformation.AuditingMode)

#define LsapAdtAuditingPolicyChanges()                                  \
            (LsapAdtAuditingEnabled() &&                               \
             (LsapAdtEventsInformation.EventAuditingOptions[ AuditCategoryPolicyChange ] & POLICY_AUDIT_EVENT_SUCCESS))


//
// Macro to determine the size of a PRIVILEGE_SET
//

#define LsapPrivilegeSetSize( PrivilegeSet )                                   \
        ( ( PrivilegeSet ) == NULL ? 0 :                                       \
        ((( PrivilegeSet )->PrivilegeCount > 0)                                \
         ?                                                                     \
         ((ULONG)sizeof(PRIVILEGE_SET) +                                       \
           (                                                                   \
             (( PrivilegeSet )->PrivilegeCount  -  ANYSIZE_ARRAY) *            \
             (ULONG)sizeof(LUID_AND_ATTRIBUTES)                                \
           )                                                                   \
         )                                                                     \
         : ((ULONG)sizeof(PRIVILEGE_SET) - (ULONG)sizeof(LUID_AND_ATTRIBUTES)) \
        ))


#endif // _ADT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\adtp.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtp.h

Abstract:

    Local Security Authority - Audit Log Management - Private Defines,
    data and function prototypes.

    Functions, data and defines in this module are internal to the
    Auditing Subcomponent of the LSA Subsystem.

Author:

    Scott Birrell       (ScottBi)      November 20, 1991

Environment:

Revision History:

--*/

#ifndef _LSAP_ADTP_
#define _LSAP_ADTP_


#include "ausrvp.h"


//
// Names of the registry keys where security event log information
// is rooted and the object names are listed under an event source
// module.
//

#define LSAP_ADT_AUDIT_MODULES_KEY_NAME L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\EventLog\\Security"
#define LSAP_ADT_OBJECT_NAMES_KEY_NAME  L"ObjectNames"



//
// Macros for setting fields in an SE_AUDIT_PARAMETERS array.
//
// These must be kept in sync with similar macros in se\sepaudit.c.
//


#define LsapSetParmTypeSid( AuditParameters, Index, Sid )                      \
    {                                                                          \
        if( Sid ) {                                                            \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeSid;         \
        (AuditParameters).Parameters[(Index)].Length = RtlLengthSid( (Sid) );  \
        (AuditParameters).Parameters[(Index)].Address = (Sid);                 \
                                                                               \
        } else {                                                               \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNone;        \
        (AuditParameters).Parameters[(Index)].Length = 0;                      \
        (AuditParameters).Parameters[(Index)].Address = NULL;                  \
                                                                               \
        }                                                                      \
    }


#define LsapSetParmTypeAccessMask( AuditParameters, Index, AccessMask, ObjectTypeIndex ) \
    {                                                                                    \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeAccessMask;            \
        (AuditParameters).Parameters[(Index)].Length = sizeof( ACCESS_MASK );            \
        (AuditParameters).Parameters[(Index)].Data[0] = (AccessMask);                    \
        (AuditParameters).Parameters[(Index)].Data[1] = (ObjectTypeIndex);               \
    }



#define LsapSetParmTypeString( AuditParameters, Index, String )                \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeString;      \
        (AuditParameters).Parameters[(Index)].Length =                         \
                sizeof(UNICODE_STRING)+(String)->Length;                       \
        (AuditParameters).Parameters[(Index)].Address = (String);              \
    }



#define LsapSetParmTypeUlong( AuditParameters, Index, Ulong )                  \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeUlong;       \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }

#define LsapSetParmTypeHexUlong( AuditParameters, Index, Ulong )               \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeHexUlong;    \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }

#define LsapSetParmTypeGuid( AuditParameters, Index, pGuid )                   \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type    = SeAdtParmTypeGuid;     \
        (AuditParameters).Parameters[(Index)].Length  = sizeof( GUID );        \
        (AuditParameters).Parameters[(Index)].Address = pGuid;                 \
    }

#define LsapSetParmTypeNoLogon( AuditParameters, Index )                       \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNoLogonId;   \
    }



#define LsapSetParmTypeLogonId( AuditParameters, Index, LogonId )              \
    {                                                                          \
        PLUID TmpLuid;                                                         \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeLogonId;     \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (LogonId) );   \
        TmpLuid = (PLUID)(&(AuditParameters).Parameters[(Index)].Data[0]);     \
        *TmpLuid = (LogonId);                                                  \
    }


#define LsapSetParmTypePrivileges( AuditParameters, Index, Privileges )                      \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypePrivs;                     \
        (AuditParameters).Parameters[(Index)].Length = LsapPrivilegeSetSize( (Privileges) ); \
        (AuditParameters).Parameters[(Index)].Address = (Privileges);                        \
    }


#define IsInRange(item,min_val,max_val) \
            (((item) >= min_val) && ((item) <= max_val))

//       
// see msaudite.mc for def. of valid category-id
//
#define IsValidCategoryId(c) \
            (IsInRange((c), SE_ADT_MIN_CATEGORY_ID, SE_ADT_MAX_CATEGORY_ID))

//
// see msaudite.mc for def. of valid audit-id
//

#define IsValidAuditId(a) \
            (IsInRange((a), SE_ADT_MIN_AUDIT_ID, SE_ADT_MAX_AUDIT_ID))

//
// check for reasonable value of parameter count. we must have atleast
// 2 parameters in the audit-params array. Thus the min limit is 3.
// The max limit is determined by the value in ntlsa.h
//

#define IsValidParameterCount(p) \
            (IsInRange((p), 2, SE_MAX_AUDIT_PARAMETERS))




///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Private data for Audit Log Management                                 //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

#define LSAP_ADT_LOG_FULL_SHUTDOWN_TIMEOUT    (ULONG) 0x0000012cL

extern RTL_CRITICAL_SECTION LsapAdtQueueLock;
extern RTL_CRITICAL_SECTION LsapAdtLogFullLock;

extern BOOLEAN LsapAuditSuccessfulLogons;

extern BOOLEAN LsapAuditFailedLogons;

//
// Options for LsapAdtWriteLog
//

#define LSAP_ADT_LOG_QUEUE_PREPEND        ((ULONG) 0x00000001L)

//
// Structure describing a queued audit record
//

typedef struct _LSAP_ADT_QUEUED_RECORD {

    LIST_ENTRY             Link;
    SE_ADT_PARAMETER_ARRAY Buffer;

} LSAP_ADT_QUEUED_RECORD, *PLSAP_ADT_QUEUED_RECORD;

//
// Audit Log Queue Header.  The queue is maintained in chronological
// (FIFO) order.  New records are appended to the back of the queue.
//

typedef struct _LSAP_ADT_LOG_QUEUE_HEAD {

    PLSAP_ADT_QUEUED_RECORD FirstQueuedRecord;
    PLSAP_ADT_QUEUED_RECORD LastQueuedRecord;

} LSAP_ADT_LOG_QUEUE_HEAD, *PLSAP_ADT_LOG_QUEUE_HEAD;

//
// Lsa Global flag to indicate if we are auditing logon events.
//

extern BOOLEAN LsapAdtLogonEvents;

//
// String that will be passed in for SubsystemName for audits generated
// by LSA (eg, logon, logoff, restart, etc).
//

extern UNICODE_STRING LsapSubsystemName;

//
// max number of replacement string params that we support in 
// eventlog audit record. 
//
#define SE_MAX_AUDIT_PARAM_STRINGS 32


///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//      The following structures and data are used by LSA to contain          /
//      drive letter-device name mapping information.  LSA obtains this       /
//      information once during initialization and saves it for use           /
//      by auditing code.                                                    