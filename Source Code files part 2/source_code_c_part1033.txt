mputer name
    in both Ansi and Unicode

Author:

    Dan Lafferty (danl)     09-Apr-1991

Environment:

    User Mode -Win32 (also uses nt RTL routines)

Revision History:

    09-Apr-1991     danl
        created

--*/

#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>
#include <ntdef.h>
#include <windef.h>
#include <winbase.h>    // LocalAlloc



DWORD
ElfpGetComputerName (
    OUT  LPSTR   *ComputerNamePtrA,
    OUT  LPWSTR  *ComputerNamePtrW
    )
/*++

Routine Description:

    This routine obtains the computer name from a persistent database,
    by calling the GetcomputerName[A,W] Win32 Base APIs

    This routine assumes the length of the computername is no greater
    than MAX_COMPUTERNAME_LENGTH, space for which it allocates using
    LocalAlloc.  It is necessary for the user to free that space using
    LocalFree when finished.

Arguments:

    ComputerNamePtrA - Pointer to the location of the Ansi computer name
    ComputerNamePtrW - Pointer to the location of the Unicode computer name

Return Value:

    NO_ERROR - If the operation was successful.

    Any other Win32 error if unsuccessful

--*/
{
    DWORD dwError = NO_ERROR;
    DWORD nSize   = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // Allocate a buffer to hold the largest possible computer name.
    //

    *ComputerNamePtrA = LocalAlloc(LMEM_ZEROINIT, nSize);
    *ComputerNamePtrW = LocalAlloc(LMEM_ZEROINIT, nSize * sizeof(WCHAR));

    if (*ComputerNamePtrA == NULL || *ComputerNamePtrW == NULL) {
        goto CleanExit;
    }

    //
    // Get the computer name string into the locally allocated buffers
    // by calling the Win32 GetComputerName[A,W] APIs.
    //

    if (!GetComputerNameA(*ComputerNamePtrA, &nSize)) {
        goto CleanExit;
    }

    //
    // GetComputerName always updates nSize
    //

    nSize = MAX_COMPUTERNAME_LENGTH + 1;

    if (!GetComputerNameW(*ComputerNamePtrW, &nSize)) {
        goto CleanExit;
    }

    return (NO_ERROR);

CleanExit:

    dwError = GetLastError();
    LocalFree(*ComputerNamePtrA);
    LocalFree(*ComputerNamePtrW);
    *ComputerNamePtrA = NULL;
    *ComputerNamePtrW = NULL;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\event.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    EVENT.H

Abstract:

    Contains the common data structures that should be put in one
    place in the tree.

Author:

    Rajen Shah   (rajens)   21-Aug-1991

Revision History:

--*/

//
// Switch to using the commonly defined (in ntdef.h) UNICODE_STRING
// Do a munge to fix this if it works ok
//

typedef UNICODE_STRING RPC_UNICODE_STRING, *PRPC_UNICODE_STRING;


//
// RPC definition of the SID structure.  Note the use of the [size_is()]
// qualifier to specify the number of elements in the variable size
// imbedded SubAuthorityCount array at runtime.
//
//
typedef struct _RPC_SID {
   UCHAR Revision;
   UCHAR SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
   [size_is(SubAuthorityCount)] ULONG SubAuthority[*];
} RPC_SID, *PRPC_SID, **PPRPC_SID;

//
// ANSI counted string
//

typedef struct _RPC_STRING {
    USHORT Length;
    USHORT MaximumLength;
//    [size_is(MaximumLength+0), length_is(Length+1)] PCHAR Buffer;
    [size_is(MaximumLength)] PCHAR Buffer;
} RPC_STRING,  *PRPC_STRING, RPC_ANSI_STRING, *PRPC_ANSI_STRING;

typedef struct _RPC_CLIENT_ID {
    ULONG UniqueProcess;
    ULONG UniqueThread;
} RPC_CLIENT_ID, *PRPC_CLIENT_ID;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\elfclnt\rpcbind.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    Contains the RPC bind and un-bind routines for the Eventlog
    client-side APIs.

Author:

    Rajen Shah      (rajens)    30-Jul-1991

Revision History:

    30-Jul-1991     RajenS
        created

--*/

//
// INCLUDES
//
#include <elfclntp.h>
#include <lmsvc.h>
#include <svcsp.h>  // SVCS_LRPC_*

#define SERVICE_EVENTLOG    L"EVENTLOG"


/****************************************************************************/
handle_t
EVENTLOG_HANDLE_W_bind (
    EVENTLOG_HANDLE_W   ServerName)

/*++

Routine Description:
    This routine calls a common bind routine that is shared by all services.
    This routine is called from the ElfOpenEventLog API client stub when
    it is necessary to bind to a server.
    The binding is done to allow impersonation by the server since that is
    necessary for the API calls.

Arguments:

    ServerName - A pointer to a string containing the name of the server
        to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    handle_t    bindingHandle;
    RPC_STATUS  status;

    // If we're connecting to the local services use LRPC to avoid bugs
    // with cached tokens in named pipes.  (Talk to AlbertT/MarioGo)
    // SVCS_LRPC_* defines come from svcsp.h

    if (ServerName == NULL ||
        wcscmp(ServerName, L"\\\\.") == 0 ) {
        
        PWSTR sb;
        status = RpcStringBindingComposeW(0,
                                          SVCS_LRPC_PROTOCOL, 
                                          0,
                                          SVCS_LRPC_PORT,
                                          0,
                                          &sb);

        if (status == RPC_S_OK) {
            status = RpcBindingFromStringBindingW(sb, &bindingHandle);

            RpcStringFreeW(&sb);

            if (status == RPC_S_OK) {
                return bindingHandle;
            }
        }
        return NULL;
    }

    status = RpcpBindRpc (
                ServerName,   
                SERVICE_EVENTLOG,
                NULL,
                &bindingHandle);

    // DbgPrint("EVENTLOG_bind: handle=%d\n",bindingHandle);
    return( bindingHandle);
}



/****************************************************************************/
void
EVENTLOG_HANDLE_W_unbind (
    EVENTLOG_HANDLE_W   ServerName,
    handle_t        BindingHandle)

/*++

Routine Description:

    This routine calls a common unbind routine that is shared by
    all services.

Arguments:

    ServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    RPC_STATUS  status;

    // DbgPrint("EVENTLOG_HANDLE_unbind: handle=%d\n",BindingHandle);
    status = RpcpUnbindRpc ( BindingHandle);
    return;

    UNREFERENCED_PARAMETER(ServerName);

}


handle_t
EVENTLOG_HANDLE_A_bind (
    EVENTLOG_HANDLE_A   ServerName)

/*++

Routine Description:

    This routine calls EVENTLOG_HANDLE_W_bind to do the work.

Arguments:

    ServerName - A pointer to a UNICODE string containing the name of
    the server to bind with.

Return Value:

    The binding handle is returned to the stub routine.  If the
    binding is unsuccessful, a NULL will be returned.

--*/
{
    UNICODE_STRING  ServerNameU;
    ANSI_STRING     ServerNameA;
    handle_t        bindingHandle;

    //
    // Convert the ANSI string to a UNICODE string before calling the
    // UNICODE routine.
    //
    RtlInitAnsiString (&ServerNameA, (PSTR)ServerName);

	ServerNameU.Buffer = NULL;

    RtlAnsiStringToUnicodeString (
            &ServerNameU,
            &ServerNameA,
            TRUE
            );

    bindingHandle = EVENTLOG_HANDLE_W_bind(
                (EVENTLOG_HANDLE_W)ServerNameU.Buffer
                );

    RtlFreeUnicodeString (&ServerNameU);

    return( bindingHandle);
}



/****************************************************************************/
void
EVENTLOG_HANDLE_A_unbind (
    EVENTLOG_HANDLE_A   ServerName,
    handle_t        BindingHandle)

/*++

Routine Description:

    This routine calls EVENTLOG_HANDLE_W_unbind.

Arguments:

    ServerName - This is the ANSI name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    none.

--*/
{
    UNICODE_STRING  ServerNameU;
    ANSI_STRING     ServerNameA;

    //
    // Convert the ANSI string to a UNICODE string before calling the
    // UNICODE routine.
    //
    RtlInitAnsiString (&ServerNameA, (PSTR)ServerName);

	ServerNameU.Buffer = NULL;

    RtlAnsiStringToUnicodeString (
            &ServerNameU,
            &ServerNameA,
            TRUE
            );

    EVENTLOG_HANDLE_W_unbind( (EVENTLOG_HANDLE_W)ServerNameU.Buffer,
                 BindingHandle );

    RtlFreeUnicodeString (&ServerNameU);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\ntsdexts\elfexts.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    elfexts.c

Abstract:

    This function contains the eventlog ntsd debugger extensions

Author:

    Dan Hinsley (DanHi) 22-May-1993

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <time.h>
#include <elf.h>
#include <elfdef.h>
#include <elfcommn.h>
#include <elfproto.h>
#include <svcsp.h>
#include <elfextrn.h>

//#define DbgPrint(_x_) (lpOutputRoutine) _x_
#define DbgPrint(_x_)
#define MAX_NAME 256
#define printf (lpOutputRoutine)
#define GET_DATA(DebugeeAddr, LocalAddr, Length) \
    Status = ReadProcessMemory(                  \
                GlobalhCurrentProcess,           \
                (LPVOID)DebugeeAddr,             \
                LocalAddr,                       \
                Length,                          \
                NULL                             \
                );

PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;

HANDLE GlobalhCurrentProcess;
BOOL Status;

//
// Initialize the global function pointers
//

VOID
InitFunctionPointers(
    HANDLE hCurrentProcess,
    PNTSD_EXTENSION_APIS lpExtensionApis
    )
{
    //
    // Load these to speed access if we haven't already
    //

    if (!lpOutputRoutine) {
        lpOutputRoutine = lpExtensionApis->lpOutputRoutine;
        lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine;
        lpCheckControlCRoutine = lpExtensionApis->lpCheckControlCRoutine;
    }

    //
    // Stick this in a global
    //

    GlobalhCurrentProcess = hCurrentProcess;
}

LPWSTR
GetUnicodeString(
    PUNICODE_STRING pUnicodeString
    )
{
    DWORD Pointer;
    UNICODE_STRING UnicodeString;

    GET_DATA(pUnicodeString, &UnicodeString, sizeof(UNICODE_STRING))
    Pointer = (DWORD) UnicodeString.Buffer;
    UnicodeString.Buffer = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,
        UnicodeString.Length + sizeof(WCHAR));
    GET_DATA(Pointer, UnicodeString.Buffer, UnicodeString.Length)

    return(UnicodeString.Buffer);
}

DWORD
GetLogFileAddress(
    LPSTR LogFileName,
    PLOGFILE LogFile
    )
{
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    DWORD Pointer;
    DWORD LogFileAnchor;
    LPWSTR ModuleName;

    //
    // Convert the string to UNICODE
    //

    RtlInitAnsiString(&AnsiString, LogFileName);
    RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

    //
    // Walk the logfile list looking for a match
    //

    LogFileAnchor = (lpGetExpressionRoutine)("LogFilesHead");

    GET_DATA(LogFileAnchor, &Pointer, sizeof(DWORD))

    while (Pointer != LogFileAnchor) {
        GET_DATA(Pointer, LogFile, sizeof(LOGFILE))
        ModuleName = GetUnicodeString(LogFile->LogModuleName);
        if (!_wcsicmp(ModuleName, UnicodeString.Buffer)) {
            break;
        }
        LocalFree(ModuleName);
        Pointer = (DWORD) LogFile->FileList.Flink;
    }

    RtlFreeUnicodeString(&UnicodeString);

    if (Pointer == LogFileAnchor) {
        return(0);
    }
    else {
        LocalFree(ModuleName);
        return(Pointer);
    }
}

//
// Dump an individual record
//

DWORD
DumpRecord(
    DWORD Record,
    DWORD RecordNumber,
    DWORD StartOfFile,
    DWORD EndOfFile
    )
{
    DWORD BufferLen;
    PCHAR TimeBuffer;
    PEVENTLOGRECORD EventLogRecord;
    LPWSTR Module;
    LPWSTR Computer;
    DWORD FirstPiece = 0;

    GET_DATA(Record, &BufferLen, sizeof(DWORD))

    //
    // See if it's a ELF_SKIP_DWORD, and if it is, return the top of the
    // file
    //

    if (BufferLen == ELF_SKIP_DWORD) {
        return(StartOfFile + sizeof(ELF_LOGFILE_HEADER));
    }

    //
    // See if it's the EOF record
    //

    if (BufferLen == ELFEOFRECORDSIZE) {
        return(0);
    }

    BufferLen += sizeof(DWORD); // get room for length of next record
    EventLogRecord = (PEVENTLOGRECORD) LocalAlloc(LMEM_ZEROINIT, BufferLen);

    //
    // If the record wraps, grab it piecemeal
    //

    if (EndOfFile && BufferLen + Record > EndOfFile) {
        FirstPiece = EndOfFile - Record;
        GET_DATA(Record, EventLogRecord, FirstPiece);
        GET_DATA((StartOfFile + sizeof(ELF_LOGFILE_HEADER)),
            ((PBYTE) EventLogRecord + FirstPiece), BufferLen - FirstPiece)
    }
    else {
        GET_DATA(Record, EventLogRecord, BufferLen)
    }

    //
    // If it's greater than the starting record, print it out
    //

    if (EventLogRecord->RecordNumber >= RecordNumber) {
        printf("\nRecord %d is %d [0x%X] bytes long starting at 0x%X\n",
            EventLogRecord->RecordNumber, EventLogRecord->Length,
            EventLogRecord->Length, Record);
        Module = (LPWSTR)(EventLogRecord+1);
        Computer = (LPWSTR)((PBYTE) Module + ((wcslen(Module) + 1) * sizeof(WCHAR)));
        printf("\tGenerated by %ws from system %ws\n", Module, Computer);

        TimeBuffer = ctime((time_t *)&(EventLogRecord->TimeGenerated));
        if (TimeBuffer) {
            printf("\tGenerated at %s", TimeBuffer);
        }
        else {
            printf("\tGenerated time field is blank\n");
        }
        TimeBuffer = ctime((time_t *)&(EventLogRecord->TimeWritten));
        if (TimeBuffer) {
            printf("\tWritten at %s", TimeBuffer);
        }
        else {
            printf("\tTime written field is blank\n");
        }

        printf("\tEvent Id = %d\n", EventLogRecord->EventID);
        printf("\tEventType = ");
        switch (EventLogRecord->EventType) {
            case EVENTLOG_SUCCESS:
                printf("Success\n");
                break;
            case EVENTLOG_ERROR_TYPE:
                printf("Error\n");
                break;
            case EVENTLOG_WARNING_TYPE:
                printf("Warning\n");
                break;
            case EVENTLOG_INFORMATION_TYPE:
                printf("Information\n");
                break;
            case EVENTLOG_AUDIT_SUCCESS:
                printf("Audit Success\n");
                break;
            case EVENTLOG_AUDIT_FAILURE:
                printf("Audit Failure\n");
                break;
            default:
                printf("Invalid value 0x%X\n", EventLogRecord->EventType);
        }
        printf("\t%d strings at offset 0x%X\n", EventLogRecord->NumStrings,
            EventLogRecord->StringOffset);
        printf("\t%d bytes of data at offset 0x%X\n", EventLogRecord->DataLength,
            EventLogRecord->DataOffset);
    }

    if (FirstPiece) {
        Record = StartOfFile + sizeof(ELF_LOGFILE_HEADER) + BufferLen -
            FirstPiece;
    }
    else {
        Record += EventLogRecord->Length;
    }

    LocalFree(EventLogRecord);
    return(Record);
}

//
// Dump a record, or all records, or n records
//

VOID
record(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    DWORD Pointer;
    LOGFILE LogFile;
    DWORD StartOfFile;
    DWORD EndOfFile = 0;
    DWORD RecordNumber = 0;

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    //
    // Evaluate the argument string to get the address of
    // the record to dump.
    //

    if (lpArgumentString && *lpArgumentString) {
        if (*lpArgumentString == '.') {
            if (GetLogFileAddress(lpArgumentString+1, &LogFile) == 0) {
                printf("Logfile %s not found\n", lpArgumentString+1);
                return;
            }
            Pointer = ((DWORD) (LogFile.BaseAddress)) + LogFile.BeginRecord;
        }
        else if (*lpArgumentString == '#') {
            RecordNumber = atoi(lpArgumentString + 1);
            printf("Dumping records starting at record #%d\n", RecordNumber);
            lpArgumentString = NULL;
        }
        else if (*lpArgumentString) {
            Pointer = (lpGetExpressionRoutine)(lpArgumentString);
        }
        else {
            printf("Invalid lead character 0x%02X\n", *lpArgumentString);
            return;
        }
    }

    if (!lpArgumentString || *lpArgumentString) {
        if (GetLogFileAddress("system", &LogFile) == 0) {
            printf("System Logfile not found\n");
            return;
        }
        Pointer = ((DWORD) (LogFile.BaseAddress)) + LogFile.BeginRecord;
    }

    StartOfFile = (DWORD) LogFile.BaseAddress;
    EndOfFile = (DWORD) LogFile.BaseAddress + LogFile.ActualMaxFileSize;

    //
    // Dump records starting wherever they told us to
    //

    while (Pointer < EndOfFile && Pointer && !(lpCheckControlCRoutine)()) {
        Pointer = DumpRecord(Pointer, RecordNumber, StartOfFile, EndOfFile);
    }


    return;
}

//
// Dump a single LogModule structure if it matches MatchName (NULL matches
// all)
//

PLIST_ENTRY
DumpLogModule(
    HANDLE hCurrentProcess,
    DWORD pLogModule,
    LPWSTR MatchName
    )
{
    LOGMODULE LogModule;
    WCHAR ModuleName[MAX_NAME / sizeof(WCHAR)];

    GET_DATA(pLogModule, &LogModule, sizeof(LogModule))
    GET_DATA(LogModule.ModuleName, &ModuleName, MAX_NAME)

    if (!MatchName || !_wcsicmp(MatchName, ModuleName)) {
        printf("\tModule Name %ws\n", ModuleName);
        printf("\tModule Atom 0x%X\n", LogModule.ModuleAtom);
        printf("\tPointer to LogFile 0x%X\n", LogModule.LogFile);
    }

    return (LogModule.ModuleList.Flink);
}

//
// Dump selected, or all, LogModule structures
//

VOID
logmodule(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    DWORD pLogModule;
    DWORD LogModuleAnchor;
    LPWSTR wArgumentString = NULL;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);
    UnicodeString.Buffer = NULL;

    //
    // Evaluate the argument string to get the address of
    // the logmodule to dump.  If no parm, dump them all.
    //

    if (lpArgumentString && *lpArgumentString == '.') {
        lpArgumentString++;
        RtlInitAnsiString(&AnsiString, lpArgumentString);
        RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
    }
    else if (lpArgumentString && *lpArgumentString) {
        pLogModule = (lpGetExpressionRoutine)(lpArgumentString);
        DumpLogModule(hCurrentProcess, pLogModule, NULL);
        return;
    }

    LogModuleAnchor = (lpGetExpressionRoutine)("LogModuleHead");

    GET_DATA(LogModuleAnchor, &pLogModule, sizeof(DWORD))

    while (pLogModule != LogModuleAnchor && !(lpCheckControlCRoutine)()) {
        pLogModule =
            (DWORD) DumpLogModule(hCurrentProcess, pLogModule,
                UnicodeString.Buffer);
        if (!UnicodeString.Buffer) {
            printf("\n");
        }
    }
    if (UnicodeString.Buffer) {
        RtlFreeUnicodeString(&UnicodeString);
    }

    return;
}

//
// Dump a single LogFile structure if it matches MatchName (NULL matches
// all)
//

PLIST_ENTRY
DumpLogFile(
    HANDLE hCurrentProcess,
    DWORD pLogFile,
    LPWSTR MatchName
    )
{
    LOGFILE LogFile;
    LPWSTR UnicodeName;

    //
    // Get the fixed part of the structure
    //

    GET_DATA(pLogFile, &LogFile, sizeof(LogFile))

    //
    // Get the Default module name
    //

    UnicodeName = GetUnicodeString(LogFile.LogModuleName);

    //
    // See if we're just looking for a particular one.  If we are and
    // this isn't it, bail out.
    //

    if (MatchName && _wcsicmp(MatchName, UnicodeName)) {
        LocalFree(UnicodeName);
        return (LogFile.FileList.Flink);
    }

    //
    // Otherwise print it out
    //

    printf("%ws", UnicodeName);
    LocalFree(UnicodeName);

    //
    // Now the file name of this logfile
    //

    UnicodeName = GetUnicodeString(LogFile.LogFileName);
    printf(" : %ws\n", UnicodeName);
    LocalFree(UnicodeName);

    if (LogFile.Notifiees.Flink == LogFile.Notifiees.Blink) {
        printf("\tNo active ChangeNotifies on this log\n");
    }
    else {
        printf("\tActive Change Notify!  Dump of this list not implemented\n");
    }

    printf("\tReference Count: %d\n\tFlags: ", LogFile.RefCount);
    if (LogFile.Flags == 0) {
        printf("No flags set ");
    }
    else {
        if (LogFile.Flags & ELF_LOGFILE_HEADER_DIRTY) {
            printf("Dirty ");
        }
        if (LogFile.Flags & ELF_LOGFILE_HEADER_WRAP) {
            printf("Wrapped ");
        }
        if (LogFile.Flags & ELF_LOGFILE_LOGFULL_WRITTEN) {
             printf("Logfull Written ");
        }
    }
    printf("\n");

    printf("\tMax Files Sizes [Cfg:Curr:Next]  0x%X : 0x%X : 0x%X\n",
        LogFile.ConfigMaxFileSize, LogFile.ActualMaxFileSize,
        LogFile.NextClearMaxFileSize);

    printf("\tRecord Numbers [Oldest:Curr] %d : %d\n",
        LogFile.OldestRecordNumber, LogFile.CurrentRecordNumber);

    printf("\tRetention period in days: %d\n", LogFile.Retention / 86400);

    printf("\tBase Address: 0x%X\n", LogFile.BaseAddress);

    printf("\tView size: 0x%X\n", LogFile.ViewSize);

    printf("\tOffset of beginning record: 0x%X\n", LogFile.BeginRecord);

    printf("\tOffset of ending record: 0x%X\n", LogFile.EndRecord);

    return (LogFile.FileList.Flink);
}

//
// Dump selected, or all, LogFile structures
//

VOID
logfile(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    DWORD pLogFile;
    DWORD LogFileAnchor;
    LPWSTR wArgumentString = NULL;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    BOOL AllocateString = FALSE;

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);
    UnicodeString.Buffer = NULL;

    //
    // Evaluate the argument string to get the address of
    // the logfile to dump.  If no parm, dump them all.
    //

    if (lpArgumentString && *lpArgumentString) {
        if(*lpArgumentString == '.') {
            lpArgumentString++;
            RtlInitAnsiString(&AnsiString, lpArgumentString);
            RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
        }
        else {
            pLogFile = (lpGetExpressionRoutine)(lpArgumentString);
            DumpLogFile(hCurrentProcess, pLogFile, NULL);
            return;
        }
    }

    LogFileAnchor = (lpGetExpressionRoutine)("LogFilesHead");

    GET_DATA(LogFileAnchor, &pLogFile, sizeof(DWORD))

    while (pLogFile != LogFileAnchor) {
        pLogFile =
            (DWORD) DumpLogFile(hCurrentProcess, pLogFile,
                UnicodeString.Buffer);
        if (!UnicodeString.Buffer) {
            printf("\n");
        }
    }

    if (UnicodeString.Buffer) {
        RtlFreeUnicodeString(&UnicodeString);
    }

    return;
}

//
// Dump a request packet structure
//

VOID
request(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    ELF_REQUEST_RECORD Request;
    DWORD Pointer;
    DWORD RecordSize;
    WRITE_PKT WritePkt;
    READ_PKT ReadPkt;
    CLEAR_PKT ClearPkt;
    BACKUP_PKT BackupPkt;
    LPWSTR FileName;
    CHAR Address[18];

    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    //
    // Evaluate the argument string to get the address of
    // the request packet to dump.
    //

    if (lpArgumentString && *lpArgumentString) {
        Pointer = (lpGetExpressionRoutine)(lpArgumentString);
    }
    else {
        printf("Must supply a request packet address\n");
        return;
    }

    GET_DATA(Pointer, &Request, sizeof(ELF_REQUEST_RECORD))

    switch (Request.Command ) {
        case ELF_COMMAND_READ:
            printf("\nRead packet\n");
            GET_DATA(Request.Pkt.ReadPkt, &ReadPkt, sizeof(READ_PKT))
            printf("\tLast Seek Position = %d\n", ReadPkt.LastSeekPos);
            printf("\tLast Seek Record = %d\n", ReadPkt.LastSeekRecord);
            printf("\tStart at record number %d\n", ReadPkt.RecordNumber);
            printf("\tRead %d bytes into buffer at 0x%X\n",
                ReadPkt.BufferSize, ReadPkt.Buffer);
            if (ReadPkt.Flags & ELF_IREAD_UNICODE) {
                printf("\tReturn in ANSI\n");
            }
            else {
                printf("\tReturn in UNICODE\n");
            }
            printf("\tRead flags: ");
            if (ReadPkt.ReadFlags & EVENTLOG_SEQUENTIAL_READ) {
                printf("Sequential ");
            }
            if (ReadPkt.ReadFlags & EVENTLOG_SEEK_READ) {
                printf("Seek ");
            }
            if (ReadPkt.ReadFlags & EVENTLOG_FORWARDS_READ) {
                printf("Forward ");
            }
            if (ReadPkt.ReadFlags & EVENTLOG_BACKWARDS_READ) {
                printf("Backwards ");
            }
            printf("\n");
            break;

        case ELF_COMMAND_WRITE:
            printf("\nWrite packet\n");
            if (Request.Flags == ELF_FORCE_OVERWRITE) {
                printf("with ELF_FORCE_OVERWRITE enabled\n");
            }
            else {
                printf("\n");
            }
            GET_DATA(Request.Pkt.WritePkt, &WritePkt, sizeof(WRITE_PKT))
            RecordSize = (WritePkt.Datasize);
            DumpRecord((DWORD)WritePkt.Buffer, 0, 0, 0);
            break;

        case ELF_COMMAND_CLEAR:
            printf("\nClear packet\n");
            GET_DATA(Request.Pkt.ClearPkt, &ClearPkt, sizeof(CLEAR_PKT))
            FileName = GetUnicodeString(ClearPkt.BackupFileName);
            printf("Backup filename = %ws\n", FileName);
            LocalFree(FileName);
            break;

        case ELF_COMMAND_BACKUP:
            printf("\nBackup packet\n");
            GET_DATA(Request.Pkt.BackupPkt, &BackupPkt, sizeof(BACKUP_PKT))
            FileName = GetUnicodeString(BackupPkt.BackupFileName);
            printf("Backup filename = %ws\n", FileName);
            LocalFree(FileName);
            break;

        case ELF_COMMAND_WRITE_QUEUED:
            printf("\nQueued Write packet\n");
            if (Request.Flags == ELF_FORCE_OVERWRITE) {
                printf("with ELF_FORCE_OVERWRITE enabled\n");
            }
            else {
                printf("\n");
            }
            printf("NtStatus = 0x%X\n", Request.Status);
            break;

        default:
            printf("\nInvalid packet\n");
    }

    printf("\nLogFile for this packet:\n\n");
    _itoa((DWORD) Request.LogFile, Address, 16);
    logfile(hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis,
        Address);

    printf("\nLogModule for this packet:\n\n");
    _itoa((DWORD)Request.Module, Address, 16);
    logmodule(hCurrentProcess, hCurrentThread, dwCurrentPc, lpExtensionApis,
        Address);

    return;
}

//
// Online help
//

VOID
help(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    InitFunctionPointers(hCurrentProcess, lpExtensionApis);

    printf("\nEventlog NTSD Extensions\n");

    if (!lpArgumentString || *lpArgumentString == '\0' ||
        *lpArgumentString == '\n' || *lpArgumentString == '\r') {
        printf("\tlogmodule - dump a logmodule structure\n");
        printf("\tlogfile   - dump a logfile structure\n");
        printf("\trequest   - dump a request record\n");
        printf("\trecord    - dump a eventlog record\n");
        printf("\n\tEnter help <cmd> for detailed help on a command\n");
    }
    else {
        if (!_stricmp(lpArgumentString, "logmodule")) {
            printf("\tlogmodule <arg>, where <arg> can be one of:\n");
            printf("\t\tno argument - dump all logmodule structures\n");
            printf("\t\taddress     - dump the logmodule at specified address\n");
            printf("\t\t.string     - dump the logmodule with name string\n");
        }
        else if (!_stricmp(lpArgumentString, "logfile")) {
            printf("\tlogfile <arg>, where <arg> can be one of:\n");
            printf("\t\tno argument - dump all logfile structures\n");
            printf("\t\taddress     - dump the logfile at specified address\n");
            printf("\t\t.string     - dump the logfile with name string\n");
        }
        else if (!_stricmp(lpArgumentString, "record")) {
            printf("\trecord <arg>, where <arg> can be one of:\n");
            printf("\t\tno argument - dump all records in system log\n");
            printf("\t\taddress     - dump records starting at specified address\n");
            printf("\t\t.string     - dump all records in the <string> log\n");
            printf("\t\t#<nnn>      - dumps records starting at nnn in system log\n");
            printf("\t\t#<nnn> .string  - dumps records starting at nnn in <string> log\n");
        }
        else if (!_stricmp(lpArgumentString, "request")) {
            printf("\trequest - dump the request record at specified address\n");
        }
        else {
            printf("\tInvalid command [%s]\n", lpArgumentString);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\eltest\eltest.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ELTEST.C

Abstract:

    Test Routines for the EventLog.

THINGS I WANT THIS TO DO...
    AddReg <ServerName> <logname> <EntryName> <EventMessageFile>
        <CategoryMessageFile> <CategoryCount> <ParameterMessageFile>
        <TypesSupported>   - Creates A Registry Entry.

        eltest addreg application mytest mf= eltest.dll cat=

    CreateMessageFile <??? Is this possible ???>

    WriteEvent <ServerName> <EventSource> <Type> <Category> <EventId> <UserSid?>
        <NumStrings> <Strings> <RawData>

    ReadLog <Server> <LogFile> <ReadFlags> <RecordOffset> <bufSize>
        If LogFile isn't one of the popular ones, then it could be a backup
        logfile.

    GetNumEvents <Server> <LogFile>

    GetOldest <Server> <LogFile>

    Clear <Server> <LogFile>

    Backup <Server> <LogFile> <BackupFile>


    LOOPTESTS....
    I should be able to run this test like mprtest such that it doesn't leave
    the test process until told.  This way we can register an event source,
    then if we call WriteEvent without a specified EventSource, it will use
    the stored source.  Calling RegisterEventSource twice without calling
    DeRegisterSource would be an error.  (Or better yet, I could keep a table
    of sources and handles).

    RegisterEventSource <EventSource>
    DeRegisterSource <EventSource>




PROTOTYPES FOR FUNCTION....

BOOL
CloseEventLog (
    HANDLE hEventLog
    )
BOOL
DeregisterEventSource (
    HANDLE hEventLog
    )

BOOL
NotifyChangeEventLog(
    HANDLE  hEventLog,
    HANDLE  hEvent
    )
BOOL
GetNumberOfEventLogRecords (
    HANDLE hEventLog,
    PDWORD NumberOfRecords
    )
BOOL
GetOldestEventLogRecord (
    HANDLE hEventLog,
    PDWORD OldestRecord
    )
BOOL
ClearEventLogW (
    HANDLE hEventLog,
    LPCWSTR BackupFileName
    )
BOOL
BackupEventLogW (
    HANDLE hEventLog,
    LPCWSTR BackupFileName
    )
HANDLE
OpenEventLogW (
    LPCWSTR  UNCServerName,
    LPCWSTR  ModuleName
    )
HANDLE
RegisterEventSourceW (
    LPCWSTR  UNCServerName,
    LPCWSTR  ModuleName
    )
HANDLE
OpenBackupEventLogW (
    LPCWSTR  UNCServerName,
    LPCWSTR  FileName
    )
BOOL
ReadEventLogW (
    HANDLE      hEventLog,
    DWORD       dwReadFlags,
    DWORD       dwRecordOffset,
    LPVOID      lpBuffer,
    DWORD       nNumberOfBytesToRead,
    DWORD       *pnBytesRead,
    DWORD       *pnMinNumberOfBytesNeeded
    )
BOOL
ReportEventW (
    HANDLE      hEventLog,
    WORD        wType,
    WORD        wCategory       OPTIONAL,
    DWORD       dwEventID,
    PSID        lpUserSid       OPTIONAL,
    WORD        wNumStrings,
    DWORD       dwDataSize,
    LPCWSTR     *lpStrings      OPTIONAL,
    LPVOID      lpRawData       OPTIONAL
    )




Author:

    Dan Lafferty    (danl)  09-March-1994

Environment:

    User Mode - Win32

Revision History:

    09-Mar-1994     danl
        created

--*/

//
// INCLUDES
//
#define UNICODE 1
#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h


#include <stdlib.h>     // atoi
#include <stdio.h>      // printf
#include <conio.h>      // getch
#include <string.h>     // strcmp
#include <windows.h>    // win32 typedefs
#include <tstr.h>       // Unicode
#include <debugfmt.h>   // FORMAT_LPTSTR

//------------------
// DEFINES
//------------------
#define APPLICATION_LOG     "Application"
#define SYSTEM_LOG          "System"
#define SECURITY_LOG        "Security"

#define REG_APPLICATION_KEY "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\"
#define REG_SYSTEM_KEY      "SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\"
#define REG_SECURITY_KEY    "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Security\\"

#define EVENT_SOURCE_NAME       "tevent"
#define MSG_DLL                 "%SystemRoot%\\System32\\tevent.dll"

#define VALUE_EVENT_MF          TEXT("EventMessageFile")
#define VALUE_CATEGORY_MF       TEXT("CategoryMessageFile")
#define VALUE_PARAMETER_MF      TEXT("ParameterMessageFile")
#define VALUE_TYPES_SUPPORTED   TEXT("TypesSupported")
#define VALUE_CATEGORY_COUNT    TEXT("CategoryCount")

#define TYPES_SUPPORTED        (EVENTLOG_ERROR_TYPE     |   \
                                EVENTLOG_WARNING_TYPE   |   \
                                EVENTLOG_INFORMATION_TYPE)
//----------------------
// GLOBALS
//----------------------
    LPTSTR  ApplLogRegName=TEXT(REG_APPLICATION_KEY);
    LPTSTR  SysLogRegName =TEXT(REG_SYSTEM_KEY);
    LPTSTR  SecLogRegName =TEXT(REG_SECURITY_KEY);
    LPTSTR  ApplLogName   = TEXT(APPLICATION_LOG);
    LPTSTR  SysLogName    = TEXT(SYSTEM_LOG);
    LPTSTR  SecLogName    = TEXT(SECURITY_LOG);

//----------------------
// FUNCTION PROTOTYPES
//----------------------

VOID
AddRegUsage(VOID);

DWORD
AddSourceToRegistry(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  LogName,
    IN  LPTSTR  EventSourceName,
    IN  LPTSTR  *argv,
    IN  DWORD   argc
    );

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    );

DWORD
DelSourceInRegistry(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  LogName,
    IN  LPTSTR  EventSourceName
    );

VOID
DisplayStatus (
    IN  LPTSTR              ServiceName,
    IN  LPTSTR              DisplayName,
    IN  LPSERVICE_STATUS    ServiceStatus
    );

BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    );

BOOL
ProcessArgs (
    LPTSTR      ServerName,
    DWORD       argc,
    LPTSTR      argv[]
    );

VOID
Usage(
    VOID);

VOID
ConfigUsage(VOID);

VOID
CreateUsage(VOID);

VOID
QueryUsage(VOID);

LONG
wtol(
    IN LPWSTR string
    );

VOID
UserInputLoop(
    LPTSTR  ServerName
    );
DWORD
ReadLogFile(
    LPTSTR  ServerName,
    LPTSTR  LogName,
    IN  LPTSTR  *argv,
    IN  DWORD   argc
    );
VOID
ReadLogUsage(VOID);

VOID
DisplayRecord(
    PEVENTLOGRECORD     pElRecord,
    BOOL                PrintTheHeader
    );

/****************************************************************************/
VOID __cdecl
main (
    DWORD           argc,
    PCHAR           argvAnsi[]
    )

/*++

Routine Description:

    Allows manual testing of the EVENTLOG API.

        eltest



Arguments:



Return Value:



--*/
{
    UCHAR   i;
    DWORD   j;
    DWORD   argIndex;
    LPTSTR  pServerName=NULL;
    LPTSTR  *argv;

    if (argc <2) {
        Usage();
        return;
    }

    //
    // Make the arguments unicode if necessary.
    //
#ifdef UNICODE
    if (!MakeArgsUnicode(argc, argvAnsi)) {
        return;
    }
#endif

    argv = (LPTSTR *)argvAnsi;

    argIndex = 1;
    if (STRNCMP (argv[1], TEXT("\\\\"), 2) == 0) {
        pServerName = argv[1];
        argIndex = 2;               // skip over servername.
    }

    //
    // Check to see if we are to run in Loop Mode, or in single function
    // mode.  In Loop Mode, we go into a loop, and ask the user for
    // input until the user decides to quit.
    //
    // Process Arguments:
    //
    // INDEX   0       1            2              3
    //         EL <ServerName> <Function> <FunctionOptions...>
    //

    if (STRICMP (argv[argIndex], TEXT("Loop")) == 0) {
        UserInputLoop(pServerName);
    }
    else {
        ProcessArgs(pServerName, argc-argIndex, &(argv[argIndex]));
    }


#ifdef UNICODE
    //
    // Free up the unicode strings if there are any
    //
    for(j=0; j<argc; j++) {
        LocalFree(argv[j]);
    }
#endif

    return;
}

VOID
UserInputLoop(
    LPTSTR  ServerName
    )

/*++

Routine Description:

    This function sits in a loop, gathering input from the user, and
    processing that input until the user indicates that it should stop.
    The following user commands indicate that we should stop:
        done
        exit
        stop
        quit

Arguments:


Return Value:


--*/
{
    UCHAR   i;
    DWORD   j;
    LPTSTR  *argv;
    UCHAR   buffer[255];
    LPSTR   argvA[20];
    DWORD   argc=0;
    BOOL    KeepGoing;

    do {
        //------------------------------
        // Get input from the user
        //------------------------------
        buffer[0] = 90-2;

        printf("\nwaiting for instructions... \n");
        _cgets(buffer);

        if (buffer[1] > 0) {
            //--------------------------------------
            // put the string in argv/argc format.
            //--------------------------------------
            buffer[1]+=2;       // make this an end offset
            argc=0;
            for (i=2,j=0; i<buffer[1]; i++,j++) {
                argc++;
                argvA[j] = &(buffer[i]);
                while ((buffer[i] != ' ') && (buffer[i] != '\0')) {
                    i++;
                }
                buffer[i] = '\0';
            }

            //------------------------------------------
            // Make the arguments unicode if necessary.
            //------------------------------------------
#ifdef UNICODE

            if (!MakeArgsUnicode(argc, argvA)) {
                return;
            }

#endif
            //-----------------------------------------------
            // If the first argument doesn't indicate that
            // we should stop, then process the arguments.
            //-----------------------------------------------
            argv = (LPTSTR *)argvA;

            if((STRICMP (argv[0], TEXT("done")) == 0) ||
               (STRICMP (argv[0], TEXT("stop")) == 0) ||
               (STRICMP (argv[0], TEXT("exit")) == 0) ||
               (STRICMP (argv[0], TEXT("quit")) == 0)) {
                KeepGoing  = FALSE;
            }
            else {
                KeepGoing = ProcessArgs(ServerName, argc, argv);
            }

#ifdef UNICODE
            //-----------------------------------------------
            // Free up the unicode strings if there are any
            //-----------------------------------------------
            for(j=0; j<argc; j++) {
                LocalFree(argv[j]);
            }
#endif
        }
    } while (KeepGoing);

    return;

}

/****************************************************************************/
BOOL
ProcessArgs (
    LPTSTR      ServerName,
    DWORD       argc,
    LPTSTR      argv[]
    )

/*++

Routine Description:


Arguments:



Return Value:



--*/

{
    DWORD           status;
    DWORD           specialFlag = FALSE;
    DWORD           argIndex;       // index to unchecked portion of arglist.


    argIndex = 0;

    //
    // If we are adding a registry entry, the get a handle to it.
    // Otherwise, get a handle to the LogFile.
    //
    //-----------------------
    // AddSourceToRegistry
    //-----------------------
    if (STRICMP (argv[argIndex], TEXT("AddReg")) == 0 ) {

        //
        // Must have at least "AddReg logname EntryName"
        //
        if (argc < (argIndex + 3)) {
            AddRegUsage();
            goto CleanExit;
        }

        status = AddSourceToRegistry(
                    ServerName,
                    argv[argIndex+1],    // LogName
                    argv[argIndex+2],    // SourceName
                    &argv[argIndex+1],
                    argc-(argIndex+2)
                    );
    }
    //-----------------------
    // DeleteFromRegistry
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("DelReg")) == 0) {
        //
        // Must have at least "DelReg logname EntryName"
        //
        if (argc < (argIndex + 3)) {
            goto CleanExit;
        }

        status = DelSourceInRegistry(
                    ServerName,
                    argv[argIndex+1],    // LogName
                    argv[argIndex+2]     // SourceName
                    );

    }
    //-----------------------
    // WriteEvent
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("WriteEvent")) == 0) {
        printf("In WriteEvent\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // ReadLog
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("ReadLog")) == 0) {
        printf("In ReadLog\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
        //
        // Must have at least "ReadLog logname"
        //
        if (argc < (argIndex + 2)) {
            ReadLogUsage();
            goto CleanExit;
        }

        status = ReadLogFile(
                    ServerName,         // ServerName
                    argv[argIndex+1],   // LogName
                    &argv[argIndex+1],  // argv
                    argc-(argIndex+1)); // argc
    }
    //-----------------------
    // GetNumEvents
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("GetNumEvents")) == 0) {
        printf("in GetNumEvents\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // GetOldest
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("GetOldest")) == 0) {
        printf("in GetOldest\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // ClearLog
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("ClearLog")) == 0) {
        printf("in ClearLog\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // Backup
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("Backup")) == 0) {
        printf("in Backup\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // RegisterSource
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("RegisterSource")) == 0) {
        printf("in RegisterSource\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //-----------------------
    // DeRegisterSource
    //-----------------------
    else if (STRICMP (argv[argIndex], TEXT("DeRegisterSource")) == 0) {
        printf("in DeRegisterSource\n");
        if (ServerName != NULL) {
            printf("ServerName = "FORMAT_LPTSTR"\n",ServerName);
        }
    }
    //****************
    // Exit Program
    //****************
    else if (STRICMP (argv[0], TEXT("Exit")) == 0) {
        //
        // THIS SHOULD CLOSE HANDLES.
        //
        return(FALSE);
    }
    else {
        printf("Bad argument\n");
        Usage();
    }

CleanExit:


    return(TRUE);
}



BOOL
MakeArgsUnicode (
    DWORD           argc,
    PCHAR           argv[]
    )


/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DWORD   i;

    //
    // ScConvertToUnicode allocates storage for each string.
    // We will rely on process termination to free the memory.
    //
    for(i=0; i<argc; i++) {

        if(!ConvertToUnicode( (LPWSTR *)&(argv[i]), argv[i])) {
            printf("Couldn't convert argv[%d] to unicode\n",i);
            return(FALSE);
        }


    }
    return(TRUE);
}

BOOL
ConvertToUnicode(
    OUT LPWSTR  *UnicodeOut,
    IN  LPSTR   AnsiIn
    )

/*++

Routine Description:

    This function translates an AnsiString into a Unicode string.
    A new string buffer is created by this function.  If the call to
    this function is successful, the caller must take responsibility for
    the unicode string buffer that was allocated by this function.
    The allocated buffer should be free'd with a call to LocalFree.

    NOTE:  This function allocates memory for the Unicode String.

Arguments:

    AnsiIn - This is a pointer to an ansi string that is to be converted.

    UnicodeOut - This is a pointer to a location where the pointer to the
        unicode string is to be placed.

Return Value:

    TRUE - The conversion was successful.

    FALSE - The conversion was unsuccessful.  In this case a buffer for
        the unicode string was not allocated.

--*/
{

    NTSTATUS        ntStatus;
    DWORD           bufSize;
    UNICODE_STRING  unicodeString;
    ANSI_STRING     ansiString;

    //
    // Allocate a buffer for the unicode string.
    //

    bufSize = (strlen(AnsiIn)+1) * sizeof(WCHAR);

    *UnicodeOut = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (UINT)bufSize);

    if (*UnicodeOut == NULL) {
        printf("ScConvertToUnicode:LocalAlloc Failure %ld\n",GetLastError());
        return(FALSE);
    }

    //
    // Initialize the string structures
    //
    RtlInitAnsiString( &ansiString, AnsiIn);

    unicodeString.Buffer = *UnicodeOut;
    unicodeString.MaximumLength = (USHORT)bufSize;
    unicodeString.Length = 0;

    //
    // Call the conversion function.
    //
    ntStatus = RtlAnsiStringToUnicodeString (
                &unicodeString,     // Destination
                &ansiString,        // Source
                (BOOLEAN)FALSE);    // Allocate the destination

    if (!NT_SUCCESS(ntStatus)) {

        printf("ScConvertToUnicode:RtlAnsiStringToUnicodeString Failure %lx\n",
        ntStatus);

        return(FALSE);
    }

    //
    // Fill in the pointer location with the unicode string buffer pointer.
    //
    *UnicodeOut = unicodeString.Buffer;

    return(TRUE);

}

/****************************************************************************/
VOID
DisplayStatus (
    IN  LPTSTR              ServiceName,
    IN  LPTSTR              DisplayName,
    IN  LPSERVICE_STATUS    ServiceStatus
    )

/*++

Routine Description:

    Displays the service name and  the service status.

    |
    |SERVICE_NAME: messenger
    |DISPLAY_NAME: messenger
    |        TYPE       : WIN32
    |        STATE      : ACTIVE,STOPPABLE, PAUSABLE, ACCEPTS_SHUTDOWN
    |        EXIT_CODE  : 0xC002001
    |        CHECKPOINT : 0x00000001
    |        WAIT_HINT  : 0x00003f21
    |

Arguments:

    ServiceName - This is a pointer to a string containing the name of
        the service.

    DisplayName - This is a pointer to a string containing the display
        name for the service.

    ServiceStatus - This is a pointer to a SERVICE_STATUS structure from
        which information is to be displayed.

Return Value:

    none.

--*/
{

    printf("\nSERVICE_NAME: "FORMAT_LPTSTR"\n", ServiceName);
    if (DisplayName != NULL) {
        printf("DISPLAY_NAME: "FORMAT_LPTSTR"\n", DisplayName);
    }

    printf("        TYPE               : %lx  ", ServiceStatus->dwServiceType);

    switch(ServiceStatus->dwServiceType){
    case SERVICE_WIN32_OWN_PROCESS:
        printf("WIN32_OWN_PROCESS \n");
        break;
    case SERVICE_WIN32_SHARE_PROCESS:
        printf("WIN32_SHARE_PROCESS \n");
        break;
    case SERVICE_WIN32:
        printf("WIN32 \n");
        break;
    case SERVICE_ADAPTER:
        printf("ADAPTER \n");
        break;
    case SERVICE_KERNEL_DRIVER:
        printf("KERNEL_DRIVER \n");
        break;
    case SERVICE_FILE_SYSTEM_DRIVER:
        printf("FILE_SYSTEM_DRIVER \n");
        break;
    case SERVICE_DRIVER:
        printf("DRIVER \n");
        break;
    default:
        printf(" ERROR \n");
    }

    printf("        STATE              : %lx  ", ServiceStatus->dwCurrentState);

    switch(ServiceStatus->dwCurrentState){
        case SERVICE_STOPPED:
            printf("STOPPED ");
            break;
        case SERVICE_START_PENDING:
            printf("START_PENDING ");
            break;
        case SERVICE_STOP_PENDING:
            printf("STOP_PENDING ");
            break;
        case SERVICE_RUNNING:
            printf("RUNNING ");
            break;
        case SERVICE_CONTINUE_PENDING:
            printf("CONTINUE_PENDING ");
            break;
        case SERVICE_PAUSE_PENDING:
            printf("PAUSE_PENDING ");
            break;
        case SERVICE_PAUSED:
            printf("PAUSED ");
            break;
        default:
            printf(" ERROR ");
    }

    //
    // Print Controls Accepted Information
    //

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_STOP) {
        printf("\n                                (STOPPABLE,");
    }
    else {
        printf("\n                                (NOT_STOPPABLE,");
    }

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE) {
        printf("PAUSABLE,");
    }
    else {
        printf("NOT_PAUSABLE,");
    }

    if (ServiceStatus->dwControlsAccepted & SERVICE_ACCEPT_SHUTDOWN) {
        printf("ACCEPTS_SHUTDOWN)\n");
    }
    else {
        printf("IGNORES_SHUTDOWN)\n");
    }

    //
    // Print Exit Code
    //
    printf("        WIN32_EXIT_CODE    : %d\t(0x%lx)\n",
        ServiceStatus->dwWin32ExitCode,
        ServiceStatus->dwWin32ExitCode);
    printf("        SERVICE_EXIT_CODE  : %d\t(0x%lx)\n",
        ServiceStatus->dwServiceSpecificExitCode,
        ServiceStatus->dwServiceSpecificExitCode  );

    //
    // Print CheckPoint & WaitHint Information
    //

    printf("        CHECKPOINT         : 0x%lx\n", ServiceStatus->dwCheckPoint);
    printf("        WAIT_HINT          : 0x%lx\n", ServiceStatus->dwWaitHint  );

    return;
}

VOID
Usage(
    VOID)
{
    printf("DESCRIPTION:\n");
    printf("\tEL is a command line program used for testing the eventlog \n");
    printf("USAGE:\n");
    printf("\tEL <ServerName> [Function] <FunctionOptions...> \n\n");
    printf("\tThe option <server> has the form \"\\\\ServerName\"\n");
    printf("\tFurther help on Functions can be obtained by typing: \"el [Function]\"\n");
    printf("\tFunctions:\n"
           "\t  AddReg-----------Creates a registry entry for an event source.\n"
           "\t  DelReg-----------Deletes a registry entry.\n"
           "\t  WriteEvent-------Writes an event.\n"
           "\t  ReadLog----------Reads from the logfile.\n"
           "\t  GetNumEvents-----Gets the number of events in the specified log.\n"
           "\t  GetOldest--------Gets the record number for the oldest record"
           "\t                   in the log\n"
           "\t  ClearLog---------Clears the specified Log.\n"
           "\t  Backup-----------Copies the specified log to a new file.\n"
           "\t  RegisterSource---Registers a name for the event source.\n"
           "\t                   The handle is stored internally.\n"
           "\t  DeRegisterSource-Closes handle opened with RegSource.\n"
           "\t  NotifyChange-----A thread is created which gets notified of EL changes.\n");

    printf("\n");
}

VOID
AddRegUsage(VOID)
{

    printf("\nAdds a subkey under one of the logfiles listed in the registry.\n");
    printf("SYNTAX: \n  eltest addreg <ServerName> logfile <SubKeyName> <option1> <option2>...\n");
    printf("ADDREG OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n");

    printf("    MsgFile=    Name of Event Message File\n"
           "    CatFile=    Name of Category Message File\n"
           "    ParamFile=  Name of Parameter Message File\n"
           "    CatCount=   Category Count\n"
           "    Type=       <error|warning|information|AuditSuccess|AuditFailure|All>\n");
    printf("EXAMPLE:\n   eltest addreg application myapp MsgFile= MyMsgs.dll"
           " Type= error Type= warning\n");

}

VOID
ConfigUsage(VOID)
{
    printf("Modifies a service entry in the registry and Service Database.\n");
    printf("SYNTAX: \nsc config <service> <option1> <option2>...\n");
    printf("CONFIG OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n"
        " type= <own|share|kernel|filesys|rec|adapt|error>\n"
        " start= <boot|system|auto|demand|disabled|error>\n"
        " error= <normal|severe|critical|error|ignore>\n"
        " binPath= <BinaryPathName>\n"
        " group= <LoadOrderGroup>\n"
        " tag= <yes|no>\n"
        " depend= <Dependencies(space seperated)>\n"
        " obj= <AccountName|ObjectName>\n"
        " DisplayName= <display name>\n"
        " password= <password> \n");
}
VOID
CreateUsage(VOID)
{
    printf("Creates a service entry in the registry and Service Database.\n");
    printf("SYNTAX: \nsc create <service> <option1> <option2>...\n");
    printf("CREATE OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n"
        " type= <own|share|kernel|filesys|rec|error>\n"
        " start= <boot|system|auto|demand|disabled|error>\n"
        " error= <normal|severe|critical|error|ignore>\n"
        " binPath= <BinaryPathName>\n"
        " group= <LoadOrderGroup>\n"
        " tag= <yes|no>\n"
        " depend= <Dependencies(space seperated)>\n"
        " obj= <AccountName|ObjectName>\n"
        " DisplayName= <display name>\n"
        " password= <password> \n");
}

VOID
ReadLogUsage(VOID)
{

    printf("\nReads a logfile and dumps the contents.\n");
    printf("SYNTAX: \n  eltest readlog <ServerName> logfile <option1> <option2>...\n");
    printf("READLOG OPTIONS:\n");
    printf("NOTE: The option name includes the equal sign.\n");

    printf("    ReadFlag=  <fwd|back|seek|seq> (default = fwd) \n"
           "    RecordNum=  record number where read should start (default=0)\n"
           "    BufSize=    size of the buffer (default = 10000)\n");
    printf("EXAMPLE:\n   eltest addreg application myapp MsgFile= MyMsgs.dll"
           " Type= error Type= warning\n");
}

DWORD
AddSourceToRegistry(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  LogName,
    IN  LPTSTR  EventSourceName,
    IN  LPTSTR  *argv,
    IN  DWORD   argc
    )

/*++

Routine Description:

    This function writes to the registry all the information to register
    this application as an event source.

Arguments:


Return Value:


--*/
{
    TCHAR   tempName[MAX_PATH];
    HKEY    hKey;
    DWORD   dwStatus=NO_ERROR;
    HKEY    hRegistry=HKEY_LOCAL_MACHINE;

    LPTSTR  EventMessageFile=NULL;
    LPTSTR  CategoryMessageFile=NULL;
    LPTSTR  ParameterMessageFile=NULL;
    DWORD   dwTypes=0;
    DWORD   dwCategoryCount=0;
    DWORD   i;

    //
    // Look at the LogName, and generate the appropriate registry key
    // path for that log.
    //
    if (STRICMP(LogName, ApplLogName) == 0) {
        STRCPY(tempName, ApplLogRegName);
    }
    else if (STRICMP(LogName, SysLogName) == 0) {
        STRCPY(tempName, SysLogRegName);
    }
    else if (STRICMP(LogName, SecLogName) == 0) {
        STRCPY(tempName, SecLogRegName);
    }
    else {
        printf("AddSourceToRegistry: Invalid LogName\n");
        return(ERROR_INVALID_PARAMETER);
    }
    STRCAT(tempName, EventSourceName);


    //
    // Get Variable Arguments
    //
    for (i=0; i<argc ;i++ ) {
        if (STRICMP(argv[i], TEXT("EventMsgFile=")) == 0) {
            EventMessageFile = argv[i+1];
            i++;
        }
        if (STRICMP(argv[i], TEXT("CategoryMsgFile=")) == 0) {
            CategoryMessageFile = argv[i+1];
            i++;
        }
        if (STRICMP(argv[i], TEXT("ParameterMsgFile=")) == 0) {
            ParameterMessageFile = argv[i+1];
            i++;
        }
        if (STRICMP(argv[i], TEXT("Type=")) == 0) {
            //--------------------------------------------------------
            // We want to allow for several arguments of type= in the
            // same line.  These should cause the different arguments
            // to be or'd together.
            //--------------------------------------------------------
            if (STRICMP(argv[i+1],TEXT("error")) == 0) {
                dwTypes |= EVENTLOG_ERROR_TYPE;
            }
            if (STRICMP(argv[i+1],TEXT("warning")) == 0) {
                dwTypes |= EVENTLOG_WARNING_TYPE;
            }
            if (STRICMP(argv[i+1],TEXT("information")) == 0) {
                dwTypes |= EVENTLOG_INFORMATION_TYPE;
            }
            if (STRICMP(argv[i+1],TEXT("AuditSuccess")) == 0) {
                dwTypes |= EVENTLOG_AUDIT_SUCCESS;
            }
            if (STRICMP(argv[i+1],TEXT("AuditFailure")) == 0) {
                dwTypes |= EVENTLOG_AUDIT_FAILURE;
            }
            if (STRICMP(argv[i+1],TEXT("All")) == 0) {
                dwTypes |= (EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE |
                            EVENTLOG_INFORMATION_TYPE | EVENTLOG_AUDIT_SUCCESS |
                            EVENTLOG_AUDIT_FAILURE);
            }
            else {
                printf("Invalid Type\n");
                AddRegUsage();
                return(ERROR_INVALID_PARAMETER);
            }
            i++;
        }
        if (STRICMP(argv[i], TEXT("CategoryCount=")) == 0) {
            dwCategoryCount = ATOL(argv[i+1]);
            i++;
        }

    }

    //
    // Connect to the registry on the correct machine.
    //
    printf("Connect to Registry\n");
    dwStatus = RegConnectRegistry(ServerName, HKEY_LOCAL_MACHINE, &hRegistry);
    if (dwStatus != NO_ERROR) {
        printf("RegConnectRegistry Failed %d\n",GetLastError());
        return(dwStatus);
    }

    //
    // Create the new key for this source
    //
    printf("Create Key\n");
    dwStatus = RegCreateKey(hRegistry, tempName, &hKey);
    if (dwStatus != ERROR_SUCCESS) {
        printf("Couldn't create Source Key in registry %d\n",dwStatus);
        return(dwStatus);
    }
    if (EventMessageFile != NULL) {
        printf("Set EventMessageFile\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_EVENT_MF,
                0,
                REG_EXPAND_SZ,
                (LPBYTE)EventMessageFile,
                STRLEN(EventMessageFile) + sizeof(TCHAR));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (messageFile) failed %d\n",GetLastError());
            goto CleanExit;
        }
    }
    //
    // Set the Category Message File
    //
    if (CategoryMessageFile != NULL) {
        printf("Set Category Message File\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_CATEGORY_MF,
                0,
                REG_EXPAND_SZ,
                (LPBYTE)CategoryMessageFile,
                STRLEN(CategoryMessageFile) + sizeof(TCHAR));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (category mf) failed %d\n",GetLastError());
            goto CleanExit;
        }
    }

    //
    // Set the Parameter Message File
    //
    if (ParameterMessageFile != NULL) {
        printf("Set Parameter Message File\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_PARAMETER_MF,
                0,
                REG_EXPAND_SZ,
                (LPBYTE)ParameterMessageFile,
                STRLEN(ParameterMessageFile) + sizeof(TCHAR));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (Parameter mf) failed %d\n",GetLastError());
            goto CleanExit;
        }
    }

    //
    // Set the Types Supported
    //
    if (dwTypes != 0) {
        printf("Set Types Supported\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_TYPES_SUPPORTED,
                0,
                REG_DWORD,
                (LPBYTE) &dwTypes,
                sizeof(DWORD));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (TypesSupported) failed %d\n",GetLastError());
            goto CleanExit;
        }

    }

    //
    // Set the Category Count
    //
    if (dwCategoryCount != 0) {
        printf("Set CategoryCount\n");
        dwStatus = RegSetValueEx(
                hKey,
                VALUE_CATEGORY_COUNT,
                0,
                REG_DWORD,
                (LPBYTE) &dwCategoryCount,
                sizeof(DWORD));

        if (dwStatus != ERROR_SUCCESS) {
            printf("RegSetValue (CategoryCount) failed %d\n",GetLastError());
            goto CleanExit;
        }
    }
    dwStatus = NO_ERROR;
CleanExit:
    RegCloseKey(hKey);
    RegCloseKey(hRegistry);
    return(dwStatus);
}

DWORD
DelSourceInRegistry(
    IN  LPTSTR  ServerName,
    IN  LPTSTR  LogName,
    IN  LPTSTR  EventSourceName
    )

/*++

Routine Description:

    This function writes to the registry all the information to register
    this application as an event source.

Arguments:


Return Value:


--*/
{
    LPTSTR  tempName;
    HKEY    hParentKey;
    BOOL    status=FALSE;
    DWORD   dwStatus;
    HKEY    hRegistry=HKEY_LOCAL_MACHINE;


    //
    // Look at the LogName, and generate the appropriate registry key
    // path for that log.
    //
    if (STRICMP(LogName, ApplLogName) == 0) {
        tempName = ApplLogRegName;
    }
    else if (STRICMP(LogName, SysLogName) == 0) {
        tempName = SysLogRegName;
    }
    else if (STRICMP(LogName, SecLogName) == 0) {
        tempName = SecLogRegName;
    }
    else {
        printf("AddSourceToRegistry: Invalid LogName\n");
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Connect to the registry on the correct machine.
    //
    dwStatus = RegConnectRegistry(ServerName, HKEY_LOCAL_MACHINE, &hRegistry);
    if (dwStatus != NO_ERROR) {
        printf("RegConnectRegistry Failed %d\n",GetLastError());
        return(status);
    }

    //
    // Open the Parent Key of the key we want to delete.
    //
    dwStatus = RegOpenKeyEx(
                hRegistry,
                tempName,
                0,
                KEY_ALL_ACCESS,
                &hParentKey);

    if (dwStatus != ERROR_SUCCESS) {
        printf("Couldn't open Parent of key to be deleted. %d\n",dwStatus);
        goto CleanExit;
    }
    //
    // Delete the subkey.
    //
    dwStatus = RegDeleteKey(hParentKey, EventSourceName);
    if (dwStatus != ERROR_SUCCESS) {
        printf("Couldn't delete "FORMAT_LPTSTR" key from registry %d\n",
            EventSourceName, dwStatus);
    }

    RegCloseKey(hParentKey);
CleanExit:
    RegCloseKey(hRegistry);
    return(status);
}

DWORD
ReadLogFile(
    LPTSTR  ServerName,
    LPTSTR  LogName,
    IN  LPTSTR  *argv,
    IN  DWORD   argc
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD   dwReadFlag = EVENTLOG_FORWARDS_READ;
    DWORD   dwRecordNum = 0;
    DWORD   BufSize = 10000;
    DWORD   numBytesRead;
    DWORD   numBytesReqd;
    LPVOID  pElBuffer = NULL;
    PEVENTLOGRECORD    pElRecord;
    BOOL    PrintTheHeader;
    DWORD   i;
    HANDLE  hEventLog=NULL;

    //
    // Get Variable Arguments
    //
    for (i=0; i<argc ;i++ ) {
        if (STRICMP(argv[i], TEXT("ReadFlag=")) == 0) {
            if (STRICMP(argv[i+1],TEXT("fwd")) == 0) {
                dwReadFlag |= EVENTLOG_FORWARDS_READ;
            }
            if (STRICMP(argv[i+1],TEXT("back")) == 0) {
                dwReadFlag |= EVENTLOG_BACKWARDS_READ;
            }
            if (STRICMP(argv[i+1],TEXT("seek")) == 0) {
                dwReadFlag |= EVENTLOG_SEEK_READ;
            }
            if (STRICMP(argv[i+1],TEXT("seq")) == 0) {
                dwReadFlag |= EVENTLOG_SEQUENTIAL_READ;
            }
            i++;
        }
        if (STRICMP(argv[i], TEXT("RecordNum=")) == 0) {
            dwRecordNum = ATOL(argv[i+1]);
            i++;
        }
        if (STRICMP(argv[i], TEXT("BufSize=")) == 0) {
            BufSize = ATOL(argv[i+1]);
            i++;
        }
        hEventLog = OpenEventLog(ServerName,LogName);
        if (hEventLog == NULL) {
            printf("OpenEventLog failed %d\n",GetLastError());
            return(0);
        }
        pElBuffer = LocalAlloc(LPTR, BufSize);
        if (pElBuffer == NULL) {
            printf("ReadLogFile: LocalAlloc Failed %d\n",GetLastError());
            goto CleanExit;
        }

        //---------------------------------------------------------
        // Read and Display the contents of the eventlog
        //---------------------------------------------------------
        PrintTheHeader = TRUE;
TryAgain:
        while(ReadEventLog(
                hEventLog,
                dwReadFlag,
                dwRecordNum,
                pElBuffer,
                BufSize,
                &numBytesRead,
                &numBytesReqd)) {

            pElRecord = (PEVENTLOGRECORD) pElBuffer;
            while ((PBYTE) pElRecord < (PBYTE) pElBuffer + numBytesRead) {
                //
                // Print the record to the display
                //
                DisplayRecord(pElRecord,PrintTheHeader);
                PrintTheHeader = FALSE;
                //
                // Move to the next event in the buffer
                //
                pElRecord = (PEVENTLOGRECORD)((PBYTE) pElRecord +
                    pElRecord->Length);
            }
        }
        switch(GetLastError()) {
        case ERROR_INSUFFICIENT_BUFFER:
            //
            // Increase the size of the buffer and try again
            //
            if (numBytesReqd > BufSize) {
                LocalFree(pElBuffer);
                BufSize = numBytesReqd;
                pElBuffer = LocalAlloc(LPTR, BufSize);
                if (!pElBuffer) {
                    printf("ReadLogFile: LocalAlloc Failed %d\n",GetLastError());
                }
                goto TryAgain;
            }
            else {
                printf("ReadLogFile #1: THIS SHOULD NEVER HAPPEN\n");
            }
            break;
        case ERROR_EVENTLOG_FILE_CHANGED:
            //
            // The current read position for this handle has been overwritten.
            // Reopen the file and print a message to the effect that some
            // records may have been missed.
            //
            printf("ReadLogFile: Current Read position has been overwritten\n");

            hEventLog = OpenEventLog(ServerName,LogName);
            if (hEventLog == NULL) {
                printf("OpenEventLog failed %d\n",GetLastError());
                goto CleanExit;
            }
            goto TryAgain;
        case ERROR_HANDLE_EOF:
            printf("EOF\n");
            break;
        default:
            printf("UnknownError: %d\n",GetLastError());
            break;
        }
    }
CleanExit:
    if (pElBuffer != NULL) {
        LocalFree(pElBuffer);
    }
    if (hEventLog != NULL) {
        CloseEventLog(hEventLog);
    }
    return(0);
}

VOID
DisplayRecord(
    PEVENTLOGRECORD     pElRecord,
    BOOL                PrintTheHeader
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    if (PrintTheHeader) {
        printf("RecNum/tTimeGen/tWriteTime/tEventID/tType/tNumStr/tCat/n");
    }
    printf("%d/t%d/t%d/t%d/t%d/t%d/t%d\n",
        pElRecord->RecordNumber,
        pElRecord->TimeGenerated,
        pElRecord->TimeWritten,
        pElRecord->EventID,
        pElRecord->EventType,
        pElRecord->NumStrings,
        pElRecord->EventCategory);
}

LONG
wtol(
    IN LPWSTR string
    )
{
    LONG value = 0;

    while((*string != L'\0')  &&
            (*string >= L'0') &&
            ( *string <= L'9')) {
        value = value * 10 + (*string - L'0');
        string++;
    }

    return(value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\config.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CONFIG.C

Abstract:

    This file contains the routines that walk the configuration registry.

Author:

    Rajen Shah  (rajens)    1-Jul-1991


Revision History:

    29-Aug-1994     Danl
        We no longer grow log files in place.  Therefore, the MaxSize value
        in the registery ends up being advisory only.  We don't try to reserve
        that much memory at init time.  So it could happen that when we need
        a larger file size that we may not have enough memory to allocate
        MaxSize bytes.
    28-Mar-1994     Danl
        ReadRegistryInfo:  LogFileInfo->LogFileName wasn't getting updated
        when using the default (generated) LogFileName.
    16-Mar-1994     Danl
        Fixed Memory Leaks in ReadRegistryInfo().  Call to
        RtlDosPathNameToNtPathName allocates memory that wasn't being free'd.
    03-Mar-1995     MarkBl
        Added GuestAccessRestriction flag initialization in ReadRegistryInfo.

--*/

//
// INCLUDES
//

#include <eventp.h>
#include <elfcfg.h>
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>

//
// STRUCTURES
//

//
// This structure contains all the information used to setup and
// for listening to registry changes in the eventlog tree.
//
typedef struct _REG_MONITOR_INFO
{
    HANDLE      NotifyEventHandle;
    DWORD       Timeout;
    HANDLE      WorkItemHandle;
    HANDLE      RegMonitorHandle;
}
REG_MONITOR_INFO, *LPREG_MONITOR_INFO;


//
// GLOBALS
//

//
// IMPORTANT: If NUM_KEYS_MONITORED is changed, be sure to update the initialization of GlRegMonitorInfo and
//            the ElfAllEventsCleared macro accordingly.
//
#define NUM_KEYS_MONITORED 2
REG_MONITOR_INFO    GlRegMonitorInfo[NUM_KEYS_MONITORED] = { {NULL, 0, NULL, NULL}, {NULL, 0, NULL, NULL} };

#define ElfAllEventsCleared() (GlRegMonitorInfo[0].NotifyEventHandle == NULL && \
                               GlRegMonitorInfo[1].NotifyEventHandle == NULL )
//
// LOCAL FUNCTIONS
//
VOID
ElfRegistryMonitor(
    PVOID   pParms,
    BOOLEAN fWaitStatus
    );

BOOL
ElfSetupMonitor(
    LPREG_MONITOR_INFO  pMonitorInfo
    );



VOID
ProcessChange (
    HANDLE          hLogFile,
    PUNICODE_STRING ModuleName,
    PUNICODE_STRING LogFileName,
    ULONG           MaxSize,
    ULONG           Retention,
    ULONG           GuestAccessRestriction,
    LOGPOPUP        logpLogPopup,
    DWORD dwAutoBackup
    )

/*++

Routine Description:

    This routine is called by ProcessRegistryChanges for each log file.

Arguments:


Return Value:

    None

--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PLOGMODULE      pModule;
    PLOGFILE        pLogFile;
    ULONG           Size;
    PVOID           BaseAddress;
    PUNICODE_STRING pFileNameString;
    LPWSTR          FileName;
    PVOID           FreeAddress;


    pModule = GetModuleStruc (ModuleName);

    //
    // If this module didn't exist, this was a brand new log file and
    // we need to create all the structures
    //
    if (pModule == ElfDefaultLogModule &&
        wcscmp(ModuleName->Buffer, ELF_DEFAULT_MODULE_NAME))
    {
        ELF_LOG1(MODULES,
                 "ProcessChange: %ws log doesn't exist -- creating\n",
                 ModuleName->Buffer);

        Status = SetUpDataStruct(LogFileName,
                                 MaxSize,
                                 Retention,
                                 GuestAccessRestriction,
                                 ModuleName,
                                 hLogFile,
                                 ElfNormalLog,
                                 logpLogPopup,
                                 dwAutoBackup);
        return;
    }

    //
    // Update values
    //

    pLogFile = pModule->LogFile;

    pLogFile->Retention = Retention;
    pLogFile->logpLogPopup = logpLogPopup;
    pLogFile->AutoBackupLogFiles = dwAutoBackup;

    //
    // Check to see if the name has changed.  If it has, and the log
    // hasn't been used yet, then use the new name.  Be sure to free
    // memory that was used for the old name.
    //
    if ((wcscmp(pLogFile->LogFileName->Buffer, LogFileName->Buffer) != 0)
          &&
        (pLogFile->BeginRecord == pLogFile->EndRecord))
    {
        pFileNameString = ElfpAllocateBuffer(sizeof(UNICODE_STRING)
                                               + LogFileName->MaximumLength);

        if (pFileNameString != NULL)
        {
            FileName = (LPWSTR)(pFileNameString + 1);
            wcscpy(FileName, LogFileName->Buffer);
            RtlInitUnicodeString(pFileNameString, FileName);

            ElfpFreeBuffer(pLogFile->LogFileName);
            pLogFile->LogFileName = pFileNameString;
        }
    }

    //
    // The log file can only be grown dynamically.  To shrink it,
    // it has to be cleared.
    //
    if (pLogFile->ConfigMaxFileSize < ELFFILESIZE(MaxSize))
    {
        /*
            Description of recent changes.  Problem and Solution:
            A couple of problems exist.  (1) There is no error
            checking if memory can't be allocated or mapped, and
            therefore, no error paths exist for handling these
            situations.  (2) Now that the eventlog is in services.exe
            there isn't a good way to synchronize memory allocations.

            Solution:
            I considered having some utility routines for managing
            memory in the eventlog.  These would attempt to
            extend a reserved block, or get a new reserved block.
            However, there are so many places where that could fail,
            it seemed very cumbersome to support the reserved blocks.
            So the current design only deals with mapped views.
            The ConfigMaxFileSize is only used to limit the size of
            the mapped view, and doesn't reserve anything.  This
            means you are not guaranteed to be operating with a file as
            large as the MaxSize specified in the registry.  But then,
            you weren't guarenteed that it would even work with the
            original design.
        */

        ELF_LOG3(TRACE,
                 "ProcessChange: Growing %ws log from %x bytes to %x bytes\n",
                 ModuleName->Buffer,
                 pLogFile->ConfigMaxFileSize,
                 ELFFILESIZE(MaxSize));

        pLogFile->ConfigMaxFileSize    = ELFFILESIZE(MaxSize);
        pLogFile->NextClearMaxFileSize = ELFFILESIZE(MaxSize);
    }
    else if (pLogFile->ConfigMaxFileSize > ELFFILESIZE(MaxSize))
    {
        //
        // They're shrinking the size of the log file.
        // Next time we clear the log file, we'll use the new size
        // and new retention.
        //
        ELF_LOG3(TRACE,
                 "ProcessChange: Shrinking %ws log from %x bytes to %x bytes at next clear\n",
                 ModuleName->Buffer,
                 pLogFile->ConfigMaxFileSize,
                 ELFFILESIZE(MaxSize));

        pLogFile->NextClearMaxFileSize = ELFFILESIZE(MaxSize);
    }

    //
    // Now see if they've added any new modules for this log file
    //
    SetUpModules(hLogFile, pLogFile, TRUE);

    return;
}

VOID
ProcessRegistryChanges (
    VOID
    )

/*++

Routine Description:

    This routine processes that changes that have occurred in the
    eventlog node. It does this by rescanning the whole Eventlog node
    and then comparing with what it has as the current configuration.

Arguments:

    NONE.

Return Value:

    NONE

--*/
{
    NTSTATUS              Status;
    HANDLE                hLogFile;
    UNICODE_STRING        SubKeyName;
    ULONG                 Index = 0;
    BYTE                  Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_NODE_INFORMATION KeyBuffer = (PKEY_NODE_INFORMATION) Buffer;
    ULONG                 ActualSize;
    LOG_FILE_INFO         LogFileInfo;
    PWCHAR                SubKeyString;
    OBJECT_ATTRIBUTES     ObjectAttributes;
    PLOGMODULE            pModule;
    LOGPOPUP              logpLogPopup;

#if DBG

    ULONG    ulActualSize;

#endif  // DBG


    ELF_LOG0(TRACE,
             "ProcessRegistryChanges: Handling change in Eventlog service key\n");

    //
    // Take the global resource so that nobody is making changes or
    // using the existing configured information.
    //

    GetGlobalResource (ELF_GLOBAL_SHARED);


#if DBG

    //
    // See if the Debug flag changed
    //

    RtlInitUnicodeString(&SubKeyName, VALUE_DEBUG);

    Status = NtQueryValueKey(hEventLogNode,
                             &SubKeyName,
                             KeyValuePartialInformation,
                             KeyBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);

    if (NT_SUCCESS(Status))
    {
        if (((PKEY_VALUE_PARTIAL_INFORMATION) KeyBuffer)->Type == REG_DWORD)
        {
            ElfDebugLevel = *(LPDWORD) (((PKEY_VALUE_PARTIAL_INFORMATION) KeyBuffer)->Data);
        }
    }
    else
    {
        ELF_LOG1(TRACE,
                 "ProcessRegistryChanges: NtQueryValueKey for ElfDebugLevel failed %#x\n",
                 Status);
    }

    ELF_LOG1(TRACE,
             "ProcessRegistryChanges: New ElfDebugLevel is %#x\n",
             ElfDebugLevel);

#endif  // DBG


    Status = STATUS_SUCCESS;

    //
    // Loop thru the subkeys under Eventlog and set up each logfile
    //

    while (NT_SUCCESS(Status))
    {
        Status = NtEnumerateKey(hEventLogNode,
                                Index++,
                                KeyNodeInformation,
                                KeyBuffer,
                                ELF_MAX_REG_KEY_INFO_SIZE,
                                &ActualSize);

        if (NT_SUCCESS(Status))
        {
            //
            // It turns out the Name isn't null terminated, so we need
            // to copy it somewhere and null terminate it before we use it
            //
            SubKeyString = ElfpAllocateBuffer(KeyBuffer->NameLength + sizeof (WCHAR));

            if (!SubKeyString)
            {
                //
                // No one to notify, just give up till next time.
                //
                ELF_LOG0(ERROR,
                         "ProcessRegistryChanges: Unable to allocate subkey -- returning\n");

                ReleaseGlobalResource();
                return;
            }

            memcpy(SubKeyString, KeyBuffer->Name, KeyBuffer->NameLength);
            SubKeyString[KeyBuffer->NameLength / sizeof(WCHAR)] = L'\0' ;

            //
            // Open the node for this logfile and extract the information
            // required by SetupDataStruct, and then call it.
            //

            RtlInitUnicodeString(&SubKeyName, SubKeyString);

            InitializeObjectAttributes(&ObjectAttributes,
                                      &SubKeyName,
                                      OBJ_CASE_INSENSITIVE,
                                      hEventLogNode,
                                      NULL
                                      );

            Status = NtOpenKey(&hLogFile,
                               KEY_READ | KEY_SET_VALUE,
                               &ObjectAttributes);

            //
            // Should always succeed since I just enum'ed it, but if it
            // doesn't, just skip it
            //
            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ProcessRegistryChanges: NtOpenKey for subkey %ws failed %#x\n",
                         SubKeyName,
                         Status);

                ElfpFreeBuffer(SubKeyString);
                Status = STATUS_SUCCESS; // to keep the enum going
                continue;
            }

            //
            // Get the updated information from the registry.  Note that we
            // have to initialize the "log full" popup policy before doing
            // so since ReadRegistryInfo will compare the value found in the
            // registry (if there is one) to the current value.
            //

            pModule = GetModuleStruc(&SubKeyName);

            LogFileInfo.logpLogPopup = pModule->LogFile->logpLogPopup;

            Status = ReadRegistryInfo(hLogFile,
                                      &SubKeyName,
                                      &LogFileInfo);

            if (NT_SUCCESS(Status))
            {
                //
                // Now process any changes for the log file.
                // ProcessChange deals with any errors.
                //
                ProcessChange (
                    hLogFile,
                    &SubKeyName,
                    LogFileInfo.LogFileName,
                    LogFileInfo.MaxFileSize,
                    LogFileInfo.Retention,
                    LogFileInfo.GuestAccessRestriction,
                    LogFileInfo.logpLogPopup,
                    LogFileInfo.dwAutoBackup);

                //
                // Free the buffer that was allocated in ReadRegistryInfo.
                //
                ElfpFreeBuffer(LogFileInfo.LogFileName);
            }
            else
            {
                ELF_LOG2(ERROR,
                         "ProcessRegistryChanges: ReadRegistryInfo for subkey %ws failed %#x\n",
                         SubKeyString,
                         Status);
            }

            ElfpFreeBuffer(SubKeyString);
            NtClose(hLogFile);
        }
    }

    //
    // Release the global resource.
    //
    ReleaseGlobalResource();

} // ProcessRegistryChanges


NTSTATUS
ElfCheckForComputerNameChange(
    )

/*++

Routine Description:

    This routine checks to determine if the computer name has changed.  If
    it has, then it generates an event.
Arguments:

    NONE

Return Value:

    NONE

--*/
{
    LPWSTR      Dates[2];
    NTSTATUS           Status;
    UNICODE_STRING     ValueName;
    ULONG              ulActualSize;
    DWORD dwLen;
	WCHAR wElfComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	WCHAR wComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
	BYTE            Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION ValueBuffer =
        (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
	
    RtlInitUnicodeString(&ValueName, VALUE_COMPUTERNAME);

	// Read the name that the event log stored.

    Status = NtQueryValueKey(hEventLogNode,
                             &ValueName,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);
	if (!NT_SUCCESS(Status) || ValueBuffer->DataLength == 0)
    {
        ELF_LOG1(ERROR,
                 "ElfCheckForComputerNameChange: NtQueryValueKey for current name failed %#x\n",
                 Status);
        return Status;
    }
	wcscpy(wElfComputerName, (WCHAR *)ValueBuffer->Data);
	
	// Read the active name.

    Status = NtQueryValueKey(hComputerNameNode,
                             &ValueName,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);
	if (!NT_SUCCESS(Status) || ValueBuffer->DataLength == 0)
    {
        ELF_LOG1(ERROR,
                 "ElfCheckForComputerNameChange: NtQueryValueKey for active name failed %#x\n",
                 Status);
        return Status;
    }
	wcscpy(wComputerName, (WCHAR *)ValueBuffer->Data);

	// If the names are the same, just return STATUS_SUCCESS

	if (!_wcsicmp(wElfComputerName, wComputerName))
		return STATUS_SUCCESS;
	
	Dates[0] = wElfComputerName;
	Dates[1] = wComputerName;
    ElfpCreateElfEvent(EVENT_ComputerNameChange,
                       EVENTLOG_INFORMATION_TYPE,
                       0,                    // EventCategory
                       2,                    // NumberOfStrings
                       Dates,                 // Strings
                       NULL,                 // Data
                       0,                    // Datalength
                       0,
                       FALSE);                   // flags

	dwLen = sizeof(WCHAR) * (wcslen(wComputerName) + 1);
    Status = NtSetValueKey(hEventLogNode,
                                   &ValueName,
                                   0,
                                   REG_SZ,
                                   wComputerName,
                                   dwLen);
	
    if (!NT_SUCCESS(Status))
        ELF_LOG1(ERROR,
                 "ElfCheckForComputerNameChange: NtSetValueKey failed %#x\n",
                 Status);

    return Status;
                       
}

VOID
ElfRegistryMonitor (
    PVOID     pParms,
    BOOLEAN   fWaitStatus
    )

/*++

Routine Description:

    This is the entry point for the thread that will monitor changes in
    the registry. If anything changes, it will have to scan the change
    and then make the appropriate changes to the data structures in the
    service to reflect the new information.

Arguments:

    NONE

Return Value:

    NONE

--*/
{
    NTSTATUS            ntStatus;
    LPREG_MONITOR_INFO  pMonitorInfo = (LPREG_MONITOR_INFO)pParms;

    ELF_LOG0(TRACE,
             "ElfRegistryMonitor: Registry monitor thread waking up\n");

    //
    // Deregister the work item (must be done even if the
    // WT_EXECUTEONLYONCE flag is specified)
    //
    if (pMonitorInfo->WorkItemHandle != NULL)
    {
        ntStatus = RtlDeregisterWait(pMonitorInfo->WorkItemHandle);
        pMonitorInfo->WorkItemHandle = NULL;

        if (!NT_SUCCESS(ntStatus))
        {
            ELF_LOG1(ERROR,
                     "ElfRegistryMonitor: RtlDeregisterWorkItem failed %#x\n",
                     ntStatus);
        }
    }

    if (GetElState() == STOPPING)
    {
        //
        // If the eventlog is shutting down, then we need
        // to terminate this thread.
        //
        ELF_LOG0(TRACE, "ElfRegistryMonitor: Shutdown\n");

        //
        // Close the registry handle and registry event handle.
        //
        if( pMonitorInfo->NotifyEventHandle != NULL )
        {
            NtClose( pMonitorInfo->NotifyEventHandle );
            pMonitorInfo->NotifyEventHandle = NULL;
        }

        if( pMonitorInfo->RegMonitorHandle != NULL )
        {
            NtClose(pMonitorInfo->RegMonitorHandle);
            pMonitorInfo->RegMonitorHandle = NULL;
        }

        //
        // This thread will perform the final cleanup for the eventlog.
        // Cleanup is not initiated until all events have been signaled 
        //  and closed
        //
        if( ElfAllEventsCleared() )
        {
            ElfpCleanUp(EventFlags);
        }
        return;
    }

    if (fWaitStatus == TRUE)
    {
       ELF_LOG0(TRACE,
                "ElfRegistryMonitor: Running because of a timeout -- running queued list\n");

       //
       // Timer popped, try running the list
       //
       if (!IsListEmpty(&QueuedEventListHead))
       {
           //
           // There are things queued up to write, do it
           //
           WriteQueuedEvents();
       }

       //
       // Don't wait again
       //
       pMonitorInfo->Timeout = INFINITE;
    }
    else
    {
        ELF_LOG0(TRACE,
                 "ElfRegistryMonitor: Running because of notification\n");

        ProcessRegistryChanges ();
        ElfCheckForComputerNameChange();
    }

    if (!ElfSetupMonitor(pMonitorInfo))
    {
        ELF_LOG0(ERROR,
                 "ElfRegistryMonitor: ElfSetupMonitor failed -- "
                     "no longer listening for reg changes\n");
    }

    ELF_LOG0(TRACE,
             "ElfRegistryMonitor: Returning\n");

    return;

} // ElfRegistryMonitor

VOID
InitNotify(
    PVOID   pData
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    DWORD               status   = NO_ERROR;
    DWORD               Buffer;
    PVOID               pBuffer  = &Buffer;
    LPREG_MONITOR_INFO  pMonitorInfo;

    static IO_STATUS_BLOCK IoStatusBlock;

    ELF_LOG0(TRACE,
             "InitNotify: Registering Eventlog key with NtNotifyChangeKey\n");

    pMonitorInfo = (LPREG_MONITOR_INFO)pData;

    NtStatus = NtNotifyChangeKey (
                    pMonitorInfo->RegMonitorHandle,
                    pMonitorInfo->NotifyEventHandle,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    REG_NOTIFY_CHANGE_LAST_SET |
                    REG_NOTIFY_CHANGE_NAME,
                    TRUE,
                    pBuffer,
                    1,
                    TRUE);    // return and wait on event

    if (!NT_SUCCESS(NtStatus))
    {
        ELF_LOG1(ERROR,
                 "InitNotify: NtNotifyChangeKey on Eventlog key failed %#x\n",
                 NtStatus);

        status = RtlNtStatusToDosError(NtStatus);
    }

    ELF_LOG0( TRACE, "InitNotify: Returning\n" );

    return;

} // InitNotify

BOOL
ElfSetupMonitor(
    LPREG_MONITOR_INFO  pMonitorInfo
    )

/*++

Routine Description:

    This function submits a request for a registry NotifyChangeKey
    and then submits a work item to the service controller thread
    management system to wait for the Notification handle to become
    signaled.

Arguments:

    pMonitorInfo - This is a pointer to a MONITOR_INFO structure.  This
        function fills in the WorkItemHandle member of that structure
        if successfully adds a new work item.

Return Value:

    TRUE - if successful in setting up.
    FALSE - if unsuccessful.  A work item hasn't been submitted, and
        we won't be listening for registry changes.

--*/
{
    NTSTATUS  Status = STATUS_SUCCESS;

    //
    // Call NtNotifyChange Key via the thread pool
    // and make sure the thread that created the I/O
    // request will always be around.
    //
    Status = RtlQueueWorkItem(InitNotify,              // Callback
                              pMonitorInfo,            // pContext
                              WT_EXECUTEONLYONCE |
                                WT_EXECUTEINPERSISTENTIOTHREAD);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfSetupMonitor: RtlQueueWorkItem failed %#x\n",
                 Status);

        return FALSE;
    }

    //
    // Add the work item that is to be called when the
    // NotifyEventHandle is signalled.
    //

    Status = RtlRegisterWait(&pMonitorInfo->WorkItemHandle,
                             pMonitorInfo->NotifyEventHandle,  // Waitable handle
                             ElfRegistryMonitor,               // Callback
                             pMonitorInfo,                     // pContext
                             pMonitorInfo->Timeout,            // Timeout
                             WT_EXECUTEONLYONCE |
                               WT_EXECUTEINPERSISTENTIOTHREAD);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfSetupMonitor: RtlRegisterWait failed %#x\n",
                 Status);

        return FALSE;
    }

    return TRUE;

}  // ElfSetupMonitor

BOOL
ElfStartRegistryMonitor()

/*++

Routine Description:

    This routine starts up the thread that monitors changes in the registry.

    This function calls ElfSetupMonitor() to register for the change
    notification and to submit a work item to wait for the registry
    change event to get signaled.  When signalled, the ElfRegistryMonitor()
    callback function is called by a thread from the services thread pool.
    This callback function services the notification.

Arguments:

    NONE

Return Value:

    TRUE if thread creation succeeded, FALSE otherwise.

Note:


--*/
{
    NTSTATUS        Status       = STATUS_SUCCESS;
    DWORD           LoopCounter  = 0;
    BOOL            ReturnStatus = TRUE;
    DWORD           LoopCount;

    ELF_LOG0(TRACE, "ElfStartRegistryMonitor: Setting up registry change notification\n");

    if (hEventLogNode == NULL)
    {
        ELF_LOG0(ERROR, "ElfStartRegistryMonitor: No Eventlog key -- exiting\n");

        return FALSE;
    }

    if (hComputerNameNode == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfStartRegistryMonitor: No ComputerName key -- exiting\n");

        return FALSE;
    }

    GlRegMonitorInfo[0].RegMonitorHandle = hEventLogNode;
    GlRegMonitorInfo[1].RegMonitorHandle = hComputerNameNode;

    //
    // Create the events on which to wait
    //

    for( LoopCount = 0; LoopCount < NUM_KEYS_MONITORED; LoopCount++ )
    {

        Status = NtCreateEvent(&GlRegMonitorInfo[LoopCount].NotifyEventHandle,
                               EVENT_ALL_ACCESS,
                               NULL,
                               NotificationEvent,
                               FALSE);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR, "ElfStartRegistryMonitor: NtCreateEvent failed %#x\n",
                     Status);

            GlRegMonitorInfo[LoopCount].NotifyEventHandle = NULL;

            break;

        }

        //
        // Fill in the Monitor info structure with the event handle
        // and a 5 minute timeout.
        //
        GlRegMonitorInfo[LoopCount].Timeout           = 5 * 60 * 1000;
        GlRegMonitorInfo[LoopCount].WorkItemHandle    = NULL;
    }

    //
    // Cleanup all events, its all or nothing
    //
    if(!NT_SUCCESS(Status))
    {
        for( LoopCount = 0; LoopCount < NUM_KEYS_MONITORED; LoopCount++ )
        {
            if( GlRegMonitorInfo[LoopCount].NotifyEventHandle != NULL )
            {
                NtClose( GlRegMonitorInfo[LoopCount].NotifyEventHandle );
                GlRegMonitorInfo[LoopCount].NotifyEventHandle = NULL;
            }

        }

        return FALSE;
    }


    //
    // Setup for the change notify and
    // submit the work item to the eventlog threadpool.
    //
    for( LoopCount = 0; LoopCount < NUM_KEYS_MONITORED; LoopCount++ )
    {

        if (!ElfSetupMonitor(&GlRegMonitorInfo[LoopCount]))
        {
            ELF_LOG0(ERROR,
                     "ElfStartRegistryMonitor: ElfSetupMonitor failed -- exiting\n");
    
            //
            // Note that it's OK to close this handle as there's no way
            // the handle was used for a registered wait at this point
            // (since ElfSetupMonitor failed).
            //
            NtClose( GlRegMonitorInfo[LoopCount].NotifyEventHandle );
            GlRegMonitorInfo[LoopCount].NotifyEventHandle = NULL;

            return FALSE;
        }

        //
        //Set this flag since we have at least one success
        //If any startup fails, then this setting will ensure that all
        // started monitors are shutdown
        //
        EventFlags |= ELF_STARTED_REGISTRY_MONITOR;
    }
    
    ELF_LOG0(TRACE, "ElfStartRegistryMonitor: Exiting after successful call\n");

    return TRUE;

} // ElfStartRegistryMonitor

VOID
StopRegistryMonitor ()

/*++

Routine Description:

    This routine wakes up the work item that has been submitted for the
    purpose of monitoring registry eventlog changes.  The thread created
    to service that work item will actually do the clean-up of the monitor
    thread.


Arguments:

    NONE

Return Value:

    NONE

--*/

{
    DWORD LoopCount = 0;

    ELF_LOG0(TRACE, "StopRegistryMonitor: Stopping registry monitor\n");

    //
    // Wake up the RegistryMonitorThread.
    //
    for( LoopCount = 0; LoopCount < NUM_KEYS_MONITORED; LoopCount++ )
    {
        if (GlRegMonitorInfo[LoopCount].NotifyEventHandle != NULL)
        {
            SetEvent(GlRegMonitorInfo[LoopCount].NotifyEventHandle);
        }
    }

    return;

} // StopRegistryMonitor


NTSTATUS
ReadRegistryInfo (
    HANDLE          hLogFile,
    PUNICODE_STRING SubKeyName,
    PLOG_FILE_INFO  LogFileInfo
    )

/*++

Routine Description:

    This routine reads in the information from the node pointed to by
    hLogFile and stores it in the a structure so that the
    necessary data structures can be set up for the service.

    ALLOCATIONS:  If successful, this function allocates memory for
        LogFileInfo->LogFileName.  It is the responsiblilty of the caller
        to free this memory.

Arguments:

    hLogFile - A handle to the Eventlog\<somelogfile> node in the registry
    KeyName  - The subkey for this logfile to open
    LogFileInfo - The structure to fill in with the data

Return Value:

    NTSTATUS

--*/
{

#define EXPAND_BUFFER_SIZE 64

    NTSTATUS        Status;
    BOOLEAN         RegistryCorrupt = FALSE;
    BYTE            Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    ULONG           ActualSize;
    UNICODE_STRING  ValueName;
    UNICODE_STRING  UnexpandedName;
    UNICODE_STRING  ExpandedName;
    ULONG           NumberOfBytes = 0;
    BYTE            ExpandNameBuffer[EXPAND_BUFFER_SIZE];
    PUNICODE_STRING FileNameString;
    LPWSTR          FileName;
    BOOL            ExpandedBufferWasAllocated=FALSE;
    PKEY_VALUE_FULL_INFORMATION ValueBuffer =
        (PKEY_VALUE_FULL_INFORMATION) Buffer;

    ASSERT(hLogFile != NULL);

    ELF_LOG1(TRACE,
             "ReadRegistryInfo: Reading information for %ws log\n",
             SubKeyName->Buffer);

    //
    // MaxSize
    //
    RtlInitUnicodeString(&ValueName, VALUE_MAXSIZE);

    Status = NtQueryValueKey(hLogFile,
                             &ValueName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ActualSize);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ReadRegistryInfo: Can't read MaxSize value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

        LogFileInfo->MaxFileSize = ELF_DEFAULT_MAX_FILE_SIZE;
        RegistryCorrupt = TRUE;
    }
    else
    {
        LogFileInfo->MaxFileSize = *((PULONG)(Buffer +
            ValueBuffer->DataOffset));

    ELF_LOG2(TRACE,
             "ReadRegistryInfo: New MaxSize value for %ws log is %#x\n",
             SubKeyName->Buffer,
             LogFileInfo->MaxFileSize);
    }

    //
    // Retention period
    //
    RtlInitUnicodeString(&ValueName, VALUE_RETENTION);

    Status = NtQueryValueKey(hLogFile,
                             &ValueName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ActualSize);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ReadRegistryInfo: Can't read Retention value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

        LogFileInfo->Retention = ELF_DEFAULT_RETENTION_PERIOD;
        RegistryCorrupt = TRUE;
    }
    else
    {
        LogFileInfo->Retention = *((PULONG)(Buffer +
            ValueBuffer->DataOffset));

    ELF_LOG2(TRACE,
             "ReadRegistryInfo: New Retention value for %ws log is %#x\n",
             SubKeyName->Buffer,
             LogFileInfo->Retention);
    }

    //
    // RestrictGuestAccess
    //
    RtlInitUnicodeString(&ValueName, VALUE_RESTRICT_GUEST_ACCESS);

    Status = NtQueryValueKey(hLogFile,
                             &ValueName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ActualSize);

    if (!NT_SUCCESS(Status))
    {
        //
        // TRACE rather than ERROR as this value is optional
        //
        ELF_LOG2(TRACE,
                 "ReadRegistryInfo: Can't read GuestAccessRestriction value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

        LogFileInfo->GuestAccessRestriction = ELF_GUEST_ACCESS_UNRESTRICTED;
    }
    else
    {
        if (*((PULONG)(Buffer + ValueBuffer->DataOffset)) == 1)
        {
            ELF_LOG1(TRACE,
                     "ReadRegistryInfo: Restricting Guest access to %ws log\n",
                     SubKeyName->Buffer);

            LogFileInfo->GuestAccessRestriction = ELF_GUEST_ACCESS_RESTRICTED;
        }
        else
        {
            ELF_LOG1(TRACE,
                     "ReadRegistryInfo: NOT restricting Guest access to %ws log\n",
                     SubKeyName->Buffer);

            LogFileInfo->GuestAccessRestriction = ELF_GUEST_ACCESS_UNRESTRICTED;
        }
    }

    //
    // Autobackup value (optional!)
    //

    RtlInitUnicodeString(&ValueName, REGSTR_VAL_AUTOBACKUPLOGFILES);

    Status = NtQueryValueKey(hLogFile,
                             &ValueName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ActualSize);

    if (!NT_SUCCESS(Status))
    {
        //
        // TRACE rather than ERROR as this value is optional
        //
        ELF_LOG2(TRACE,
                 "ReadRegistryInfo: Can't read AutoBackupLogFiles value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

        LogFileInfo->dwAutoBackup = ELF_DEFAULT_AUTOBACKUP;
    }
    else
    {
        LogFileInfo->dwAutoBackup = *((PULONG)(Buffer +
            ValueBuffer->DataOffset));

        ELF_LOG2(TRACE,
             "ReadRegistryInfo: AutoBackupLogFiles for %ws log is %#x\n",
             SubKeyName->Buffer,
             LogFileInfo->dwAutoBackup);
    }

    //
    // Filename
    //
    RtlInitUnicodeString(&ValueName, VALUE_FILENAME);

    Status = NtQueryValueKey(hLogFile,
                             &ValueName,
                             KeyValueFullInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ActualSize);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ReadRegistryInfo: Can't read Filename value for %ws log %#x\n",
                 SubKeyName->Buffer,
                 Status);

        //
        // Allocate the buffer for the UNICODE_STRING for the filename and
        // initialize it. (41 = \Systemroot\system32\config\xxxxxxxx.evt)
        //
        FileNameString = ElfpAllocateBuffer(41 * sizeof(WCHAR) + sizeof(UNICODE_STRING));

        if (!FileNameString)
        {
            ELF_LOG0(ERROR,
                     "ReadRegistryInfo: Unable to allocate FileNameString\n");

            return STATUS_NO_MEMORY;
        }

        LogFileInfo->LogFileName = FileNameString;
        FileName = (LPWSTR)(FileNameString + 1);
        wcscpy(FileName, L"\\Systemroot\\System32\\Config\\");
        wcsncat(FileName, SubKeyName->Buffer, 8);
        wcscat(FileName, L".evt");
        RtlInitUnicodeString(FileNameString, FileName);

        RegistryCorrupt = TRUE;
    }
    else
    {
        //
        // If it's a REG_EXPAND_SZ expand it
        //

        if (ValueBuffer->Type == REG_EXPAND_SZ)
        {
            ELF_LOG0(TRACE,
                     "ReadRegistryInfo: Filename is a REG_EXPAND_SZ -- expanding\n");

            //
            // Initialize the UNICODE_STRING, when the string isn't null
            // terminated
            //
            UnexpandedName.MaximumLength = UnexpandedName.Length =
                (USHORT) ValueBuffer->DataLength;

            UnexpandedName.Buffer = (PWSTR) ((PBYTE) ValueBuffer +
                ValueBuffer->DataOffset);

            //
            // Call the magic expand-o api
            //
            ExpandedName.Length = ExpandedName.MaximumLength = EXPAND_BUFFER_SIZE;
            ExpandedName.Buffer = (LPWSTR) ExpandNameBuffer;

            Status = RtlExpandEnvironmentStrings_U(NULL,
                                                   &UnexpandedName,
                                                   &ExpandedName,
                                                   &NumberOfBytes);

            if (Status == STATUS_BUFFER_TOO_SMALL)
            {
                ELF_LOG0(TRACE,
                         "ReadRegistryInfo: Expansion buffer too small -- retrying\n");

                //
                // The default buffer wasn't big enough.  Allocate a
                // bigger one and try again
                //
                ExpandedName.Length = ExpandedName.MaximumLength = (USHORT) NumberOfBytes;

                ExpandedName.Buffer = ElfpAllocateBuffer(ExpandedName.Length);

                if (!ExpandedName.Buffer)
                {
                    ELF_LOG0(ERROR,
                             "ReadRegistryInfo: Unable to allocate larger Filename buffer\n");

                    return(STATUS_NO_MEMORY);
                }

                ExpandedBufferWasAllocated = TRUE;

                Status = RtlExpandEnvironmentStrings_U(NULL,
                                                       &UnexpandedName,
                                                       &ExpandedName,
                                                       &NumberOfBytes);
            }

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG1(ERROR,
                         "ReadRegistryInfo: RtlExpandEnvironmentStrings_U failed %#x\n",
                         Status);

                if (ExpandedBufferWasAllocated)
                {
                    ElfpFreeBuffer(ExpandedName.Buffer);
                }

                return Status;
            }
        }
        else
        {
            //
            // It doesn't need to be expanded, just set up the UNICODE_STRING
            // for the conversion to an NT pathname
            //
            ExpandedName.MaximumLength = ExpandedName.Length =
                (USHORT) ValueBuffer->DataLength;

            ExpandedName.Buffer = (PWSTR) ((PBYTE) ValueBuffer +
                ValueBuffer->DataOffset);
        }

        //
        // Now convert from a DOS pathname to an NT pathname
        //
        // NOTE:  this allocates a buffer for ValueName.Buffer.
        //
        if (!RtlDosPathNameToNtPathName_U(ExpandedName.Buffer,
                                          &ValueName,
                                          NULL,
                                          NULL))
        {
            ELF_LOG0(ERROR,
                     "ReadRegistryInfo: RtlDosPathNameToNtPathName_U failed\n");

            if (ExpandedBufferWasAllocated)
            {
                ElfpFreeBuffer(ExpandedName.Buffer);
            }

            return STATUS_UNSUCCESSFUL;
        }

        //
        // Allocate memory for the unicode string structure and the buffer
        // so that it can be free'd with a single call.
        //
        FileNameString = ElfpAllocateBuffer(
                            sizeof(UNICODE_STRING) +
                                ((ValueName.Length + 1) * sizeof(WCHAR)));

        if (FileNameString == NULL)
        {
            ELF_LOG0(ERROR,
                     "ReadRegistryInfo: Unable to allocate copy of NT filename\n");

            if (ExpandedBufferWasAllocated)
            {
                ElfpFreeBuffer(ExpandedName.Buffer);
            }

            //
            // RtlDosPathNameToNtPathName_U allocates off the process heap
            //
            RtlFreeHeap(RtlProcessHeap(), 0, ValueName.Buffer);

            return STATUS_NO_MEMORY;
        }

        //
        // Copy the NtPathName string into the new buffer, and initialize
        // the unicode string.
        //
        FileName = (LPWSTR)(FileNameString + 1);
        wcsncpy(FileName, ValueName.Buffer, ValueName.Length);
        *(FileName+ValueName.Length) = L'\0';
        RtlInitUnicodeString(FileNameString, FileName);

        //
        // RtlDosPathNameToNtPathName_U allocates off the process heap
        //
        RtlFreeHeap(RtlProcessHeap(), 0, ValueName.Buffer);

        //
        // Clean up if I had to allocate a bigger buffer than the default
        //

        if (ExpandedBufferWasAllocated)
        {
            ElfpFreeBuffer(ExpandedName.Buffer);
        }
    }

    //
    // Add the LogFileName to the LogFileInfo structure.
    //
    LogFileInfo->LogFileName = FileNameString;

    ELF_LOG2(TRACE,
             "ReadRegistryInfo: New (expanded) Filename value for %ws log is %ws\n",
             SubKeyName->Buffer,
             LogFileInfo->LogFileName->Buffer);


    //
    // "Log full" popup policy -- never change the security log
    //
    if (_wcsicmp(SubKeyName->Buffer, ELF_SECURITY_MODULE_NAME) != 0)
    {
        RtlInitUnicodeString(&ValueName, VALUE_LOGPOPUP);

        Status = NtQueryValueKey(hLogFile,
                                 &ValueName,
                                 KeyValueFullInformation,
                                 ValueBuffer,
                                 ELF_MAX_REG_KEY_INFO_SIZE,
                                 &ActualSize);

        if (NT_SUCCESS(Status))
        {
            LOGPOPUP  logpRegValue = *(PULONG)(Buffer + ValueBuffer->DataOffset);

            //
            // Only update the value if this constitutes a change in the current policy
            //
            if (LogFileInfo->logpLogPopup == LOGPOPUP_NEVER_SHOW
                 ||
                logpRegValue == LOGPOPUP_NEVER_SHOW)
            {
                LogFileInfo->logpLogPopup =
                                (logpRegValue == LOGPOPUP_NEVER_SHOW ? LOGPOPUP_NEVER_SHOW :
                                                                       LOGPOPUP_CLEARED);
            }
        }
        else
        {
            //
            // TRACE rather than ERROR as this value is optional
            //
            ELF_LOG2(TRACE,
                     "ReadRegistryInfo: Can't read LogPopup value for %ws log %#x\n",
                     SubKeyName->Buffer,
                     Status);
        }
    }

    //
    // If we didn't find all the required values, tell someone
    //

    if (RegistryCorrupt)
    {
        ELF_LOG1(ERROR,
                 "ReadRegistryInfo: One or more registry values for %ws log invalid\n",
                 SubKeyName->Buffer);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\alert.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ALERT.C

Abstract:

    This file contains the routine that sends the alert to the admin.

Author:

    Rajen Shah  (rajens)    28-Aug-1991


Revision History:


--*/

//
// INCLUDES
//

#include <eventp.h>
#include <string.h>
#include <lmalert.h>                // LAN Manager alert structures



BOOL
SendAdminAlert(
    ULONG           MessageID,
    ULONG           NumStrings,
    UNICODE_STRING  *pStrings
    )
/*++

Routine Description:

    This routine raises an ADMIN alert with the message specified.


Arguments:

    MessageID  - Message ID.
    NumStrings - Number of replacement strings.
    pStrings   - Array of UNICODE_STRING Replacement strings.

Return Value:

    NONE

--*/
{
    NET_API_STATUS NetStatus;

    BYTE AlertBuffer[ELF_ADMIN_ALERT_BUFFER_SIZE + sizeof(ADMIN_OTHER_INFO)];
    ADMIN_OTHER_INFO UNALIGNED *VariableInfo = (PADMIN_OTHER_INFO) AlertBuffer;

    DWORD DataSize;
    DWORD i;
    LPWSTR pReplaceString;

    VariableInfo->alrtad_errcode = MessageID;
    VariableInfo->alrtad_numstrings = NumStrings;

    pReplaceString = (LPWSTR)(AlertBuffer + sizeof(ADMIN_OTHER_INFO));

    //
    // Copy over the replacement strings
    //

    for (i = 0; i < NumStrings; i++)
    {
        RtlMoveMemory(pReplaceString, pStrings[i].Buffer, pStrings[i].MaximumLength);

        pReplaceString = (LPWSTR) ((PBYTE) pReplaceString + pStrings[i].MaximumLength);
    }

    DataSize = (DWORD) ((PBYTE) pReplaceString - (PBYTE) AlertBuffer);

    NetStatus = NetAlertRaiseEx(ALERT_ADMIN_EVENT,
                                AlertBuffer,
                                DataSize,
                                EVENTLOG_SVC_NAMEW);

    if (NetStatus != NERR_Success)
    {
        ELF_LOG2(ERROR,
                 "SendAdminAlert: NetAlertRaiseEx for alert %d failed %d\n",
                 MessageID,
                 NetStatus);

        //
        // Probably just not started yet, try again later
        //

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\control.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    CONTROL.C

Abstract:

    This file contains the control handler for the eventlog service.

Author:

    Rajen Shah  (rajens)    16-Jul-1991

Revision History:


--*/

//
// INCLUDES
//

#include <eventp.h>

//
// DEFINITIONS
//

//
// Controls accepted by the service
//
#define     ELF_CONTROLS_ACCEPTED           SERVICE_ACCEPT_SHUTDOWN;


//
// GLOBALS
//

    CRITICAL_SECTION StatusCriticalSection = {0};
    SERVICE_STATUS   ElStatus              = {0};
    DWORD            HintCount             = 0;
    DWORD            ElUninstallCode       = 0;  // reason for uninstalling
    DWORD            ElSpecificCode        = 0;
    DWORD            ElState               = STARTING;



VOID
ElfControlResponse(
    DWORD   opCode
    )

{
    DWORD   state;

    ELF_LOG1(TRACE,
             "ElfControlResponse: Received control %d\n",
             opCode);

    //
    // Determine the type of service control message and modify the
    // service status, if necessary.
    //
    switch(opCode)
    {
        case SERVICE_CONTROL_SHUTDOWN:
        {
            HKEY    hKey;
            ULONG   ValueSize;
            ULONG   ShutdownReason = 0xFF;
            ULONG   rc;

            //
            // If the service is installed, shut it down and exit.
            //

            ElfStatusUpdate(STOPPING);

            GetGlobalResource (ELF_GLOBAL_EXCLUSIVE);
            
            //
            // Cause the timestamp writing thread to exit
            //

            if (g_hTimestampEvent != NULL)
            {
                SetEvent (g_hTimestampEvent);
            }

            //
            // Indicate a normal shutdown in the registry
            //

            ElfWriteTimeStamp(EVENT_NormalShutdown,
                              FALSE);

            //
            // Determine the reason for this normal shutdown
            //

            rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                REGSTR_PATH_RELIABILITY,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                NULL);

            if (rc == ERROR_SUCCESS)
            {
                ValueSize = sizeof(ULONG);

                rc = RegQueryValueEx(hKey,
                                     REGSTR_VAL_SHUTDOWNREASON,
                                     0,
                                     NULL,
                                     (PUCHAR) &ShutdownReason,
                                     &ValueSize);

                if (rc == ERROR_SUCCESS)
                {
                    RegDeleteValue (hKey, REGSTR_VAL_SHUTDOWNREASON);
                }                                                                  

                RegCloseKey (hKey);
            }

            //
            // Log an event that says we're stopping
            //

            ElfpCreateElfEvent(EVENT_EventlogStopped,
                               EVENTLOG_INFORMATION_TYPE,
                               0,                    // EventCategory
                               0,                    // NumberOfStrings
                               NULL,                 // Strings
                               &ShutdownReason,      // Data
                               sizeof(ULONG),        // Datalength
                               0,
                               FALSE);                   // flags

            //
            // Now force it to be written before we shut down
            //
            WriteQueuedEvents();

            ReleaseGlobalResource();

            //
            // If the RegistryMonitor is started, wakeup that
            // worker thread and have it handle the rest of the
            // shutdown.
            //
            // Otherwise The main thread should pick up the
            // fact that a shutdown during startup is occuring.
            //
            if (EventFlags & ELF_STARTED_REGISTRY_MONITOR)
            {
                StopRegistryMonitor();
            }

            break ;
        }

        case SERVICE_CONTROL_INTERROGATE:

            ElfStatusUpdate(UPDATE_ONLY);
            break;

        default:

            //
            // This should never happen.
            //
            ELF_LOG1(ERROR,
                     "ElfControlResponse: Received unexpected control %d\n",
                     opCode);

            ASSERT(FALSE);
            break ;
    }

    return;
}


DWORD
ElfBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    ExitCode,
    IN DWORD    ServiceSpecificCode
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DWORD  status;

    EnterCriticalSection(&StatusCriticalSection);

    ELF_LOG2(ERROR,
             "ElfBeginForcedShutdown: error %d, service-specific error %d\n",
             ExitCode,
             ServiceSpecificCode);

    //
    // See if the eventlog is already stopping for some reason.
    // It could be that the ControlHandler thread received a control to
    // stop the eventlog just as we decided to stop ourselves.
    //
    if ((ElState != STOPPING) && (ElState != STOPPED))
    {
        if (PendingCode == PENDING)
        {
            ELF_LOG0(TRACE,
                     "ElfBeginForcedShutdown: Starting pending shutdown\n");

            ElStatus.dwCurrentState = SERVICE_STOP_PENDING;
            ElState = STOPPING;
        }
        else
        {
            //
            // The shutdown is to take immediate effect.
            //
            ELF_LOG0(TRACE,
                     "ElfBeginForcedShutdown: Starting immediate shutdown\n");

            ElStatus.dwCurrentState = SERVICE_STOPPED;
            ElStatus.dwControlsAccepted = 0;
            ElStatus.dwCheckPoint = 0;
            ElStatus.dwWaitHint = 0;
            ElState = STOPPED;
        }

        ElUninstallCode = ExitCode;
        ElSpecificCode = ServiceSpecificCode;

        ElStatus.dwWin32ExitCode = ExitCode;
        ElStatus.dwServiceSpecificExitCode = ServiceSpecificCode;
    }

    //
    // Cause the timestamp writing thread to exit
    //

    if (g_hTimestampEvent != NULL)
    {
        SetEvent (g_hTimestampEvent);
    }

    //
    // Send the new status to the service controller.
    //

    ASSERT(ElfServiceStatusHandle != 0);

    if (!SetServiceStatus( ElfServiceStatusHandle, &ElStatus ))
    {
        ELF_LOG1(ERROR,
                 "ElfBeginForcedShutdown: SetServicestatus failed %d\n",
                 GetLastError());
    }

    status = ElState;

    ELF_LOG1(TRACE,
             "ElfBeginForcedShutdown: New state is %d\n",
             status);

    LeaveCriticalSection(&StatusCriticalSection);
    return status;
}


DWORD
ElfStatusUpdate(
    IN DWORD    NewState
    )

/*++

Routine Description:

    Sends a status to the Service Controller via SetServiceStatus.

    The contents of the status message is controlled by this routine.
    The caller simply passes in the desired state, and this routine does
    the rest.  For instance, if the Eventlog passes in a STARTING state,
    This routine will update the hint count that it maintains, and send
    the appropriate information in the SetServiceStatus call.

    This routine uses transitions in state to determine which status
    to send.  For instance if the status was STARTING, and has changed
    to RUNNING, this routine sends SERVICE_RUNNING to the Service
    Controller.

Arguments:

    NewState - Can be any of the state flags:
                UPDATE_ONLY - Simply send out the current status
                STARTING    - The Eventlog is in the process of initializing
                RUNNING     - The Eventlog has finished with initialization
                STOPPING    - The Eventlog is in the process of shutting down
                STOPPED     - The Eventlog has completed the shutdown.

Return Value:

    CurrentState - This may not be the same as the NewState that was
        passed in.  It could be that the main thread is sending in a new
        install state just after the Control Handler set the state to
        STOPPING.  In this case, the STOPPING state will be returned so as
        to inform the main thread that a shut-down is in process.

--*/

{
    DWORD       status;
    BOOL        inhibit = FALSE;    // Used to inhibit sending the status
                                    // to the service controller.

    EnterCriticalSection(&StatusCriticalSection);

    ELF_LOG2(TRACE,
             "ElfStatusUpdate: old state = %d, new state = %d\n",
             ElState,
             NewState);

    if (NewState == STOPPED)
    {
        if (ElState == STOPPED)
        {
            //
            // It was already stopped, don't send another SetServiceStatus.
            //
            inhibit = TRUE;
        }
        else
        {
            //
            // The shut down is complete, indicate that the eventlog
            // has stopped.
            //
            ElStatus.dwCurrentState =  SERVICE_STOPPED;
            ElStatus.dwControlsAccepted = 0;
            ElStatus.dwCheckPoint = 0;
            ElStatus.dwWaitHint = 0;

            ElStatus.dwWin32ExitCode = ElUninstallCode;
            ElStatus.dwServiceSpecificExitCode = ElSpecificCode;
        }

        ElState = NewState;
    }
    else if (NewState != UPDATE_ONLY)
    {
        //
        // We are not being asked to change to the STOPPED state.
        //
        switch(ElState)
        {
            case STARTING:

                if (NewState == STOPPING)
                {
                    ElStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                    ElStatus.dwControlsAccepted = 0;
                    ElStatus.dwCheckPoint = HintCount++;
                    ElStatus.dwWaitHint = ELF_WAIT_HINT_TIME;
                    ElState = NewState;

                    EventlogShutdown = TRUE;
                }
                else if (NewState == RUNNING)
                {
                    //
                    // The Eventlog Service has completed installation.
                    //
                    ElStatus.dwCurrentState =  SERVICE_RUNNING;
                    ElStatus.dwCheckPoint = 0;
                    ElStatus.dwWaitHint = 0;

                    ElStatus.dwControlsAccepted = ELF_CONTROLS_ACCEPTED;
                    ElState = NewState;
                }
                else
                {
                    //
                    // The NewState must be STARTING.  So update the pending
                    // count
                    //

                    ElStatus.dwCurrentState =  SERVICE_START_PENDING;
                    ElStatus.dwControlsAccepted = 0;
                    ElStatus.dwCheckPoint = HintCount++;
                    ElStatus.dwWaitHint = ELF_WAIT_HINT_TIME;
                }

                break;

            case RUNNING:

                if (NewState == STOPPING)
                {
                    ElStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                    ElStatus.dwControlsAccepted = 0;

                    EventlogShutdown = TRUE;
                }

                ElStatus.dwCheckPoint = HintCount++;
                ElStatus.dwWaitHint = ELF_WAIT_HINT_TIME;
                ElState = NewState;

                break;

            case STOPPING:

                //
                // No matter what else was passed in, force the status to
                // indicate that a shutdown is pending.
                //
                ElStatus.dwCurrentState =  SERVICE_STOP_PENDING;
                ElStatus.dwControlsAccepted = 0;
                ElStatus.dwCheckPoint = HintCount++;
                ElStatus.dwWaitHint = ELF_WAIT_HINT_TIME;
                EventlogShutdown = TRUE;

                break;

            case STOPPED:

                ASSERT(NewState == STARTING);

                //
                // The Eventlog Service is starting up after being stopped.
                // This can occur if the service is manually started after
                // failing to start.
                //
                ElStatus.dwCurrentState =  SERVICE_START_PENDING;
                ElStatus.dwCheckPoint = 0;
                ElStatus.dwWaitHint = 0;
                ElStatus.dwControlsAccepted = ELF_CONTROLS_ACCEPTED;
                ElState = NewState;

                break;
        }
    }

    if (!inhibit)
    {
        ASSERT(ElfServiceStatusHandle != 0);

        if (!SetServiceStatus(ElfServiceStatusHandle, &ElStatus))
        {
            ELF_LOG1(ERROR,
                     "ElfStatusUpdate: SetServiceStatus failed %d\n",
                     GetLastError());
        }
    }

    status = ElState;

    ELF_LOG1(TRACE,
             "ElfStatusUpdate: Exiting with state = %d\n",
             ElState);

    LeaveCriticalSection(&StatusCriticalSection);

    return status;
}


DWORD
GetElState (
    VOID
    )

/*++

Routine Description:

    Obtains the state of the Eventlog Service.  This state information
    is protected as a critical section such that only one thread can
    modify or read it at a time.

Arguments:

    none

Return Value:

    The Eventlog State is returned as the return value.

--*/
{
    DWORD   status;

    EnterCriticalSection(&StatusCriticalSection);
    status = ElState;
    LeaveCriticalSection(&StatusCriticalSection);

    return status;
}


NTSTATUS
ElfpInitStatus(
    VOID
    )
/*++

Routine Description:

    Initializes the critical section that is used to guard access to the
    status database.

Arguments:

    none

Return Value:

    none

--*/
{
    ElStatus.dwCurrentState = SERVICE_START_PENDING;
    ElStatus.dwServiceType  = SERVICE_WIN32;

    return ElfpInitCriticalSection(&StatusCriticalSection);
}


VOID
ElCleanupStatus(VOID)

/*++

Routine Description:

    Deletes the critical section used to control access to the thread and
    status database.

Arguments:

    none

Return Value:

    none

Note:


--*/
{
    DeleteCriticalSection(&StatusCriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\copy.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    copy.c

Abstract:

    This module contains the routine to copy a file.

Author:

    Dan Hinsley (DanHi) 24-Feb-1991

Revision History:

    02-Feb-1994     Danl
        Fixed memory leak where ioBuffer wasn't getting free'd when doing
        an error exit from ElfpCopyFile.

--*/

//
// INCLUDES
//

#include <eventp.h>


NTSTATUS
ElfpCopyFile (
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING TargetFileName
    )

/*++

Routine Description:

    This routine copies or appends from the source file to the target file.
    If the target file already exists, the copy fails.

Arguments:

    SourceHandle - An open handle to the source file.

    TargetFileName - The name of the file to copy to.


Return Value:

    NTSTATUS - STATUS_SUCCESS or error.

--*/

{
    NTSTATUS Status;

    IO_STATUS_BLOCK IoStatusBlock;
    FILE_STANDARD_INFORMATION sourceStandardInfo;

    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE TargetHandle;

    PCHAR ioBuffer;
    ULONG ioBufferSize;
    ULONG bytesRead;

    //
    // Get the size of the file so we can set the attributes of the target
    // file.
    //
    Status = NtQueryInformationFile(
                 SourceHandle,
                 &IoStatusBlock,
                 &sourceStandardInfo,
                 sizeof(sourceStandardInfo),
                 FileStandardInformation
                 );

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpCopyFile: Unable to query size of source file %#x\n",
                 Status);

        return Status;
    }

    //
    // Open the target file, fail if the file already exists.
    //

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    TargetFileName,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

    Status = NtCreateFile(&TargetHandle,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          &(sourceStandardInfo.EndOfFile),
                          FILE_ATTRIBUTE_NORMAL,
                          0,                       // Share access
                          FILE_CREATE,
                          FILE_SYNCHRONOUS_IO_ALERT | FILE_SEQUENTIAL_ONLY,
                          NULL,                    // EA buffer
                          0);                      // EA length

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfpCopyFile: NtCreateFile of file %ws failed %#x\n",
                 TargetFileName->Buffer,
                 Status);

        return Status;
    }

    //
    // Allocate a buffer to use for the data copy.
    //
    ioBufferSize = 4096;

    ioBuffer = ElfpAllocateBuffer (ioBufferSize);

    if (ioBuffer == NULL)
    {
        ELF_LOG1(ERROR,
                 "ElfpCopyFile: Unable to allocate I/O buffer to copy file %ws\n",
                 TargetFileName->Buffer);

        NtClose(TargetHandle);
        return STATUS_NO_MEMORY;
    }

    //
    // Copy data--read from source, write to target.  Do this until
    // all the data is written or an error occurs.
    //
    while ( TRUE )
    {
        Status = NtReadFile(
                         SourceHandle,
                         NULL,                // Event
                         NULL,                // ApcRoutine
                         NULL,                // ApcContext
                         &IoStatusBlock,
                         ioBuffer,
                         ioBufferSize,
                         NULL,                // ByteOffset
                         NULL);               // Key

        if (!NT_SUCCESS(Status) && Status != STATUS_END_OF_FILE)
        {
            ELF_LOG1(ERROR,
                     "ElfpCopyFile: NtReadFile of source file failed %#x\n",
                     Status);

            ElfpFreeBuffer(ioBuffer);
            NtClose(TargetHandle);
            return Status;
        }

        if (IoStatusBlock.Information == 0 || Status == STATUS_END_OF_FILE)
        {
            break;
        }

        bytesRead = (ULONG)IoStatusBlock.Information;

        Status = NtWriteFile(
                          TargetHandle,
                          NULL,               // Event
                          NULL,               // ApcRoutine
                          NULL,               // ApcContext
                          &IoStatusBlock,
                          ioBuffer,
                          bytesRead,
                          NULL,               // ByteOffset
                          NULL);              // Key

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpCopyFile: NtWriteFile to file %ws failed %#x\n",
                     TargetFileName->Buffer,
                     Status);

            ElfpFreeBuffer(ioBuffer);
            NtClose(TargetHandle);
            return Status;
        }
    }

    ElfpFreeBuffer (ioBuffer);

    Status = NtClose(TargetHandle);

    ASSERT(NT_SUCCESS(Status));

    return STATUS_SUCCESS;

} // ElfpCopyFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfapi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ELFAPI.C

Abstract:

    This module contains the server end of the Elf APIs.


Author:

    Rajen Shah  (rajens)    29-Jul-1991


Revision History:

    14-May-01           a-jyotig
        Removed impersonation from ElfrClearELFW as it is no longer required to
		identify the client that clears a log.

	02-Mar-01           drbeck
        Modified ElfrClearELFW to impersonate client so that a SACL placed on the
        system event log will correctly identify the client that clears a log.
        
                
    10-Sep-1998         jschwart
        Added ElfrGetLogInformation (GetEventlogInformation) API

    30-Jan-1995         MarkBl
        Backup operators are allowed to open the security log, but only
        to perform backup operations. All other operations are prohibited.

    13-Oct-1993         Danl
        ElfrOpenELA:  Fixed Memory Leak bug where it was not calling
        RtlFreeUnicodeString for pRegModuleNameU and PModuleNameU.

    29-Jul-1991         RajenS
        Created

--*/
/****
@doc    EXTERNAL INTERFACES EVTLOG
****/


#include <eventp.h>
#include <elfcfg.h>
#include <stdio.h>  // swprintf
#include <stdlib.h>
#include <memory.h>
#include <clussprt.h>

//
// Maximum number of ChangeNotify requests per context handle
//
#define MAX_NOTIFY_REQUESTS     5

#if defined(_WIN64)
#define ALIGN_UP_64(x,t) (((x) + (t) - 1) & ~((t)-1))
#else
#define ALIGN_UP_64(x,t) (x)
#endif


//
//  PROTOTYPES
//
NTSTATUS
ElfpOpenELW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING ModuleName,
    IN  PRPC_UNICODE_STRING RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle,
    IN  ULONG               DesiredAccess
    );

NTSTATUS
ElfpOpenELA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         ModuleName,
    IN  PRPC_STRING         RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle,
    IN  ULONG               DesiredAccess
    );

VOID
FreePUStringArray (
    IN  PUNICODE_STRING  * pUStringArray,
    IN  USHORT             NumStrings
    );

NTSTATUS
VerifyElfHandle(
    IN IELF_HANDLE LogHandle
    );

NTSTATUS
VerifyUnicodeString(
    IN PUNICODE_STRING pUString
    );

NTSTATUS
VerifyAnsiString(
    IN PANSI_STRING pAString
    );



//
// These APIs only have one interface, since they don't take or return strings
//

NTSTATUS
ElfrNumberOfRecords(
    IN  IELF_HANDLE     LogHandle,
    OUT PULONG          NumberOfRecords
    )
/*++

Routine Description:

  This is the RPC server entry point for the ElfrCurrentRecord API.

Arguments:

    LogHandle       - The context-handle for this module's call.

    NumberOfRecords - Where to return the total number of records in the
                      log file.

Return Value:

    Returns an NTSTATUS code.


--*/
{
    PLOGMODULE Module;
    NTSTATUS   Status;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrNumberOfRecords: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Insure the caller has read access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "ElfrNumberOfRecords: LogHandle doesn't have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //

    if (NumberOfRecords == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrNumberOfRecords: NumberOfRecords is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //

    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrNumberOfRecords: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // If the OldestRecordNumber is 0, that means we have an empty
    // file, else we calculate the difference between the oldest
    // and next record numbers
    //

    Module = FindModuleStrucFromAtom(LogHandle->Atom);

    if (Module != NULL)
    {
        *NumberOfRecords = Module->LogFile->OldestRecordNumber == 0 ? 0 :
        Module->LogFile->CurrentRecordNumber -
            Module->LogFile->OldestRecordNumber;
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrNumberOfRecords: No module struc associated with atom\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


NTSTATUS
ElfrOldestRecord(
    IN  IELF_HANDLE         LogHandle,
    OUT PULONG          OldestRecordNumber
    )
{
    PLOGMODULE Module;
    NTSTATUS   Status;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrOldestRecord: VerifyElfHandle failed %#x\n",
                  Status);

        return Status;
    }

    //
    // Insure the caller has read access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "ElfrOldestRecord: LogHandle doesn't have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //
    if (OldestRecordNumber == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrOldestRecord: OldestRecordNumber is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //
    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrOldestRecord: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    Module = FindModuleStrucFromAtom (LogHandle->Atom);

    if (Module != NULL)
    {
        *OldestRecordNumber = Module->LogFile->OldestRecordNumber;
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrOldestRecord: No module struc associated with atom\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


NTSTATUS
ElfrChangeNotify(
    IN  IELF_HANDLE         LogHandle,
    IN  RPC_CLIENT_ID       ClientId,
    IN  ULONG               Event
    )
{
    NTSTATUS Status;
    NTSTATUS RpcStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ProcessHandle = NULL;
    HANDLE EventHandle;
    PLOGMODULE Module;
    PNOTIFIEE Notifiee;
    CLIENT_ID tempCli;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: VerifyElfHandle failed %#x\n",
                  Status);

        return Status;
    }

    //
    // Ensure the caller has read access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "ElfrChangeNotify: LogHandle doesn't have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // First make sure that this is a local call and that it is not a
    // handle that was created for a backup log file
    //

    if (LogHandle->Flags & ELF_LOG_HANDLE_REMOTE_HANDLE ||
        LogHandle->Flags & ELF_LOG_HANDLE_BACKUP_LOG)
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: Handle is for a %ws log\n",
                 LogHandle->Flags & ELF_LOG_HANDLE_REMOTE_HANDLE ? L"remote" :
                                                                   L"backup");

        return STATUS_INVALID_HANDLE;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //

    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrChangeNotify: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Make sure the client has the right to open this process
    //

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: RpcImpersonateClient failed %#x\n",
                 RpcStatus);

        return RpcStatus;
    }

    //
    // First get a handle to the process using the passed in ClientId. Note
    // that the ClientId is supplied by the client so a rogue client may
    // supply any client ID. However, because we impersonate when opening
    // the process we don't get any additional access the client doesn't have.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,                   // UNICODE string
                               0,                      // Attributes
                               NULL,                   // Root directory
                               NULL);                  // Security descriptor

#ifdef _WIN64

    tempCli.UniqueProcess = (HANDLE)ULongToPtr(ClientId.UniqueProcess);
    tempCli.UniqueThread = (HANDLE)ULongToPtr(ClientId.UniqueThread);

    Status = NtOpenProcess(&ProcessHandle,
                           PROCESS_DUP_HANDLE,
                           &ObjectAttributes,
                           &tempCli);

#else
    Status = NtOpenProcess(&ProcessHandle,
                           PROCESS_DUP_HANDLE,
                           &ObjectAttributes,
                           (PCLIENT_ID) &ClientId);
#endif

    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: RpcRevertToSelf failed %#x\n",
                 RpcStatus);
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Now dupe the handle they passed in for the event
        //
        Status = NtDuplicateObject(ProcessHandle,
                                   LongToHandle(Event),
                                   NtCurrentProcess(),
                                   &EventHandle,
                                   0,
                                   0,
                                   DUPLICATE_SAME_ACCESS);

         if (NT_SUCCESS(Status))
         {
             //
             // Create a new NOTIFIEE control block to link in
             //
             Notifiee = ElfpAllocateBuffer(sizeof(NOTIFIEE));

             if (Notifiee)
             {
                 //
                 // Fill in the fields
                 //
                 Notifiee->Handle = LogHandle;
                 Notifiee->Event = EventHandle;

                 //
                 // Find the LOGFILE associated with this handle
                 //
                 Module = FindModuleStrucFromAtom(LogHandle->Atom);

                 if (Module != NULL)
                 {
                     //
                     // Get exclusive access to the log file. This will ensure
                     // no one else is accessing the file.
                     //
                     RtlAcquireResourceExclusive(&Module->LogFile->Resource,
                                                 TRUE);   // Wait until available

                     //
                     // Enforce the limit of ChangeNotify requests per context handle
                     //
                     if (LogHandle->dwNotifyRequests == MAX_NOTIFY_REQUESTS)
                     {
                         ELF_LOG1(ERROR,
                                  "ElfrChangeNotify: Already %d requests for this handle\n",
                                  MAX_NOTIFY_REQUESTS);

                         NtClose(EventHandle);
                         ElfpFreeBuffer(Notifiee);
                         Status = STATUS_INSUFFICIENT_RESOURCES;
                     }
                     else
                     {
                         //
                         // Insert the new notifiee into the list and increment this
                         // context handle's ChangeNotify request count
                         //
                         InsertHeadList(&Module->LogFile->Notifiees,
                                        &Notifiee->Next);

                         LogHandle->dwNotifyRequests++;
                     }

                     //
                     // Free the resource
                     //
                     RtlReleaseResource ( &Module->LogFile->Resource );
                 }
                 else
                 {
                     ELF_LOG0(ERROR,
                              "ElfrChangeNotify: No module struc associated with atom\n");

                     NtClose(EventHandle);
                     ElfpFreeBuffer(Notifiee);
                     Status = STATUS_INVALID_HANDLE;
                 }
             }
             else
             {
                 ELF_LOG0(ERROR,
                          "ElfrChangeNotify: Unable to allocate NOTIFIEE block\n");

                 Status = STATUS_NO_MEMORY;

                 //
                 // Free the duplicated handle
                 //
                 CloseHandle(EventHandle);
             }
         }
         else
         {
             ELF_LOG1(ERROR,
                      "ElfrChangeNotify: NtDuplicateObject failed %#x\n",
                      Status);
         }
    }
    else
    {
        ELF_LOG1(ERROR,
                 "ElfrChangeNotify: NtOpenProcess failed %#x\n",
                 Status);

        if (Status == STATUS_INVALID_CID)
        {
            Status = STATUS_INVALID_HANDLE;
        }
    }

    if (ProcessHandle)
    {
        NtClose(ProcessHandle);
    }

    return Status;
}


NTSTATUS
ElfrGetLogInformation(
    IN     IELF_HANDLE    LogHandle,
    IN     ULONG          InfoLevel,
    OUT    PBYTE          lpBuffer,
    IN     ULONG          cbBufSize,
    OUT    PULONG         pcbBytesNeeded
    )
/*++

Routine Description:

  This is the RPC server entry point for the ElfrGetLogInformation API.

Arguments:

    LogHandle      - The context-handle for this module's call.
    InfoLevel      - Infolevel that specifies which information the user is requesting
    lpBuffer       - Buffer into which to place the information
    cbBufSize      - Size of lpBuffer, in bytes
    pcbBytesNeeded - Required size of the buffer

Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS   ntStatus;
    PLOGMODULE pLogModule;

    //
    // Check the handle before proceeding.
    //
    ntStatus = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfrGetLogInformation: VerifyElfHandle failed %#x\n",
                 ntStatus);

        return ntStatus;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //

    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrGetLogInformation: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Take the appropriate actions based on the Infolevel
    //
    switch (InfoLevel)
    {
        case EVENTLOG_FULL_INFO:

            *pcbBytesNeeded = sizeof(EVENTLOG_FULL_INFORMATION);

            if (cbBufSize < *pcbBytesNeeded)
            {
                ELF_LOG2(ERROR,
                         "ElfrGetLogInformation: buffer size = %d, required size = %d\n",
                         cbBufSize,
                         *pcbBytesNeeded);

                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            //
            // Get the module associated with this log handle
            //
            pLogModule = FindModuleStrucFromAtom(LogHandle->Atom);

            if (pLogModule != NULL)
            {
                //
                // The caller has the permission for this operation.  Note
                // that an access check is done when opening the log, so
                // there's no need to repeat it here.
                //
                ((LPEVENTLOG_FULL_INFORMATION)lpBuffer)->dwFull =

                    (pLogModule->LogFile->Flags & ELF_LOGFILE_LOGFULL_WRITTEN ?
                         TRUE :
                         FALSE);

                ELF_LOG2(TRACE,
                         "ElfrGetLogInformation: %ws log is %ws\n",
                         pLogModule->LogFile->LogModuleName->Buffer,
                         pLogModule->LogFile->Flags & ELF_LOGFILE_LOGFULL_WRITTEN ?
                             L"full" :
                             L"not full");
            }
            else
            {
                ELF_LOG0(ERROR,
                         "ElfrGetLogInformation: No module struc associated with atom\n");

                ntStatus = STATUS_INVALID_HANDLE;
            }

            break;

        default:

            ELF_LOG1(ERROR,
                     "ElfrGetLogInformation: Invalid InfoLevel %d\n",
                     InfoLevel);

            ntStatus = STATUS_INVALID_LEVEL;
            break;
    }

    return ntStatus;
}


//
// UNICODE APIs
//



NTSTATUS
ElfrClearELFW (
    IN  IELF_HANDLE         LogHandle,
    IN  PRPC_UNICODE_STRING BackupFileName
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrClearELFW API.

  CleanExit lable was written to add some cleanup code. The cleanup code was 
  removed later as it was not required but the lable is retained in order to 
  add any cleanup code if required in future 

Arguments:

    LogHandle       - The context-handle for this module's call.  This must
                      not have been returned from OpenBackupEventlog, or
                      this call will fail with invalid handle.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS            Status;
    PLOGMODULE          Module;
    ELF_REQUEST_RECORD  Request;
    CLEAR_PKT           ClearPkt;
    DWORD               status = NO_ERROR;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrClearELFW: VerifyElfHandle failed %#x\n",
                 Status);

        goto CleanExit;
    }

    //
    // Ensure the caller has clear access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_CLEAR))
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFW: LogHandle doesn't have clear access\n");

        Status = STATUS_ACCESS_DENIED;
        goto CleanExit;
    }

    //
    // Verify additional arguments.
    //
    if (BackupFileName != NULL)
    {
        Status = VerifyUnicodeString(BackupFileName);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG0(ERROR,
                     "ElfrClearELFW: BackupFileName is an invalid Unicode string\n");

            goto CleanExit;
        }
    }

    //
    // Can't clear a backup log
    //

    if (LogHandle->Flags & ELF_LOG_HANDLE_BACKUP_LOG)
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFW: Handle is for a backup log\n");

        Status = STATUS_INVALID_HANDLE;
        goto CleanExit;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //
    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFW: Handle is a backup handle\n");

        Status = STATUS_ACCESS_DENIED;
        goto CleanExit;
    }

    //
    // Find the matching module structure
    //

    Module = FindModuleStrucFromAtom (LogHandle->Atom);

    Request.Pkt.ClearPkt = &ClearPkt;
    Request.Flags = 0;

    if (Module != NULL)
    {
        //
        // Verify that the caller has clear access to this logfile
        //

        if (!RtlAreAllAccessesGranted(LogHandle->GrantedAccess,
                                      ELF_LOGFILE_CLEAR))
        {
            ELF_LOG1(ERROR,
                     "ElfrClearELFW: Caller does not have clear access to %ws log\n",
                     Module->LogFile->LogModuleName->Buffer);

            Status = STATUS_ACCESS_DENIED;
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Fill in the request packet
            //

            Request.Module = Module;
            Request.LogFile = Module->LogFile;
            Request.Command = ELF_COMMAND_CLEAR;
            Request.Status = STATUS_SUCCESS;
            Request.Pkt.ClearPkt->BackupFileName =
                                (PUNICODE_STRING)BackupFileName;

            //
            // Call the worker routine to do the operation.
            //

            ElfPerformRequest(&Request);

            //
            // Extract status of operation from the request packet
            //

            Status = Request.Status;

            //
            // If this was the Security Logfile, and the clear was
            // successful, then generate an audit.
            //
            if (NT_SUCCESS(Status) &&
                (_wcsicmp(ELF_SECURITY_MODULE_NAME,
                          Module->LogFile->LogModuleName->Buffer) == 0))
            {
                //
                // We just cleared the security log.  Now we want to add
                // a new event to that log to indicate who did it.
                //
                ElfpGenerateLogClearedEvent(LogHandle);
            }
        }
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFW: No module struc associated with atom\n");

        Status = STATUS_INVALID_HANDLE;
    }

CleanExit:

    return Status;
}


NTSTATUS
ElfrBackupELFW (
    IN  IELF_HANDLE         LogHandle,
    IN  PRPC_UNICODE_STRING BackupFileName
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrBackupELFW API.

Arguments:

    LogHandle       - The context-handle for this module's call.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS            Status;
    PLOGMODULE          Module;
    ELF_REQUEST_RECORD  Request;
    BACKUP_PKT          BackupPkt;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrBackupELFW: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has read access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFW: LogHandle doesn't have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Make sure the client has SE_BACKUP_PRIVILEGE enabled.  Note
    // that we attempted to enable this on the client side
    //
    if (ElfpTestClientPrivilege(SE_BACKUP_PRIVILEGE, NULL) != STATUS_SUCCESS)
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFW: Client does not have SE_BACKUP_PRIVILEGE\n");

        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Verify additional arguments.
    //
    Status = VerifyUnicodeString(BackupFileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFW: BackupFileName is not a valid Unicode string\n");

        return Status;
    }

    //
    // A filename must be specified.
    //

    if (BackupFileName->Length == 0) {
        return(STATUS_INVALID_PARAMETER);
    }

    Request.Pkt.BackupPkt = &BackupPkt;
    Request.Flags = 0;

    //
    // Find the matching module structure
    //
    Module = FindModuleStrucFromAtom(LogHandle->Atom);

    if (Module != NULL)
    {
        //
        // Fill in the request packet

        Request.Module  = Module;
        Request.LogFile = Module->LogFile;
        Request.Command = ELF_COMMAND_BACKUP;
        Request.Status  = STATUS_SUCCESS;
        Request.Pkt.BackupPkt->BackupFileName =
                            (PUNICODE_STRING)BackupFileName;

        //
        // Call the worker routine to do the operation.
        //
        ElfPerformRequest (&Request);

        //
        // Extract status of operation from the request packet
        //
        Status = Request.Status;
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFW: No module struc associated with atom\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


NTSTATUS
ElfrCloseEL (
    IN OUT  PIELF_HANDLE    LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrCloseEL API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS Status;

    //
    // Check the handle before proceeding.
    //
    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrCloseEL: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    Status = VerifyElfHandle(*LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrCloseEL: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Call the rundown routine to do all the work
    //
    IELF_HANDLE_rundown(*LogHandle);

    *LogHandle = NULL; // so RPC knows it's closed

    return STATUS_SUCCESS;
}


NTSTATUS
ElfrDeregisterEventSource(
    IN OUT  PIELF_HANDLE    LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrDeregisterEventSource API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS Status;

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrDeregisterEventSource: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check the handle before proceeding.
    //
    Status = VerifyElfHandle(*LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrDeregisterEventSource: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //
    if ((*LogHandle)->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrDeregisterEventSource: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Call the rundown routine to do all the work
    //
    IELF_HANDLE_rundown(*LogHandle);

    *LogHandle = NULL; // so RPC knows it's closed

    return STATUS_SUCCESS;
}



NTSTATUS
ElfrOpenBELW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING BackupFileName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrOpenBELW API.  It creates
  a module structure $BACKUPnnn where nnn is a unique number for every backup
  log that is opened.  It then calls ElfpOpenELW to actually open the file.


Arguments:

    UNCServerName   - Not used.

    BackupFileName  - Name of the backup log file.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                              context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".


--*/
{

    NTSTATUS        Status;
    UNICODE_STRING  BackupStringW;
    LPWSTR          BackupModuleName;
    PLOGMODULE      pModule;
    DWORD           dwModuleNumber;

//
// Size of buffer (in bytes) required for a UNICODE string of $BACKUPnnn
//

#define SIZEOF_BACKUP_MODULE_NAME 64

    UNREFERENCED_PARAMETER(UNCServerName);

    //
    // Check arguments.
    //

    Status = VerifyUnicodeString(BackupFileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELW: BackupFileName is not a Unicode string\n");

        return Status;
    }

    //
    // A filename must be specified.
    //
    if (BackupFileName->Length == 0)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELW: Length of BackupFileName is 0\n");

        return STATUS_INVALID_PARAMETER;
    }

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELW: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Create a unique module name by incrementing a global value
    //
    BackupModuleName = ElfpAllocateBuffer(SIZEOF_BACKUP_MODULE_NAME);

    if (BackupModuleName == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELW: Unable to allocate memory for BackupModuleName\n");

        return STATUS_NO_MEMORY;
    }

    //
    // Serialize read, increment of the global backup module number.
    // Note: double-timing the log file list critical section so as to not
    // require another critical section specifically dedicated to this
    // operation.
    //
    RtlEnterCriticalSection (&LogFileCritSec);

    dwModuleNumber = BackupModuleNumber++;

    RtlLeaveCriticalSection (&LogFileCritSec);

    swprintf(BackupModuleName, L"$BACKUP%06d", dwModuleNumber);
    RtlInitUnicodeString(&BackupStringW, BackupModuleName);

    ELF_LOG2(TRACE,
             "ElfrOpenBELW: Backing up module %ws to file %ws\n",
             BackupModuleName,
             BackupFileName->Buffer);

    //
    // Call SetupDataStruct to build the module and log data structures
    // and actually open the file.
    //
    // NOTE:  If this call is successful, the Unicode String Buffer for
    //  BackupStringW (otherwise known as BackupModuleName) will be attached
    //  to the LogModule structure, and should not be free'd.
    //
    Status = SetUpDataStruct(
                    BackupFileName,  // Filename
                    0,               // Max size, it will use actual
                    0,               // retention period, not used for bkup
                    ELF_GUEST_ACCESS_UNRESTRICTED,  // restrict guest
                                     // access flag, inapplicable for bkup
                    &BackupStringW,  // Module name
                    NULL,            // Handle to registry, not used
                    ElfBackupLog,    // Log type
                    LOGPOPUP_NEVER_SHOW,
                    ELF_DEFAULT_AUTOBACKUP);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG3(ERROR,
                 "ElfrOpenBELW: SetUpDataStruct for file %ws (module %ws) failed %#x\n",
                 BackupFileName->Buffer,
                 BackupModuleName,
                 Status);

        ElfpFreeBuffer(BackupModuleName);
        return Status;
    }

    //
    // Call ElfOpenELW to actually open the log file and get a handle.
    //
    Status = ElfpOpenELW(NULL,
                         (PRPC_UNICODE_STRING) &BackupStringW,
                         NULL,
                         MajorVersion,
                         MinorVersion,
                         LogHandle,
                         ELF_LOGFILE_READ);

    if (NT_SUCCESS(Status))
    {
        //
        // Mark this as a handle for a backup log, so we can clean up
        // differently when it's closed, as well as disallow clear, backup
        // and write operations.
        //

        (*LogHandle)->Flags |= ELF_LOG_HANDLE_BACKUP_LOG;
    }
    else
    {
        ELF_LOG3(ERROR,
                 "ElfrOpenBELW: ElfpOpenELW for file %ws (module %ws) failed %#x\n",
                 BackupFileName->Buffer,
                 BackupModuleName,
                 Status);

        //
        // If we couldn't open the log file, then we need to tear down
        // the DataStruct we set up with SetUpDataStruct.
        //
        pModule = GetModuleStruc(&BackupStringW);

        //
        // We'd better be unlinking the same module we just created
        //
        ASSERT(_wcsicmp(pModule->ModuleName, BackupModuleName) == 0);

        Status = ElfpCloseLogFile(pModule->LogFile, ELF_LOG_CLOSE_BACKUP);

        UnlinkLogModule(pModule);
        DeleteAtom(pModule->ModuleAtom);

        //
        // NB : DO NOT decrement the logfile reference count - this has
        //      been done in ElfpCloseLogFile.
        //
        if (pModule->LogFile->RefCount == 0)
        {
            ELF_LOG1(TRACE,
                     "ElfrOpenBELW: Reference count for %ws log is 0 -- destroying\n",
                     pModule->ModuleName);

            UnlinkLogFile(pModule->LogFile); // Unlink the structure
            RtlDeleteResource ( &pModule->LogFile->Resource );
            RtlDeleteSecurityObject(&pModule->LogFile->Sd);
            ElfpFreeBuffer (pModule->LogFile->LogFileName);
            ElfpFreeBuffer (pModule->LogFile->LogModuleName);
            ElfpFreeBuffer (pModule->LogFile);
        }

        ElfpFreeBuffer(pModule->ModuleName);
        ElfpFreeBuffer(pModule);
    }

    return Status;
}


NTSTATUS
ElfrRegisterEventSourceW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING ModuleName,
    IN  PRPC_UNICODE_STRING RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrRegisterEventSourceW API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Not used.

    MajorVersion/MinorVersion - The version of the client.

    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".

Note:

    For now, just call ElfpOpenELW.

--*/
{
    //
    // All arguments checked in ElfpOpenELW.
    //
    return ElfpOpenELW(UNCServerName,
                       ModuleName,
                       RegModuleName,
                       MajorVersion,
                       MinorVersion,
                       LogHandle,
                       ELF_LOGFILE_WRITE);
}


NTSTATUS
ElfrOpenELW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING ModuleName,
    IN  PRPC_UNICODE_STRING RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrOpenELW API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Not used.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".


--*/
{
    //
    // All arguments checked in ElfpOpenELW.
    //

    return ElfpOpenELW(UNCServerName,
                       ModuleName,
                       RegModuleName,
                       MajorVersion,
                       MinorVersion,
                       LogHandle,
                       ELF_LOGFILE_READ);
}


NTSTATUS
ElfpOpenELW (
    IN  EVENTLOG_HANDLE_W   UNCServerName,
    IN  PRPC_UNICODE_STRING ModuleName,
    IN  PRPC_UNICODE_STRING RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle,
    IN  ULONG               DesiredAccess
    )

/*++

Routine Description:

  Looks alot like ElfrOpenELW but also gets passed a DesiredAccess.

Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Not used.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

    DesiredAccess   - Indicates the access desired for this logfile.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".

--*/
{
    NTSTATUS        Status;
    PLOGMODULE      Module;
    IELF_HANDLE     LogIHandle;
    BOOL            ForSecurityLog = FALSE;

    //
    // Check arguments.
    //

    Status = VerifyUnicodeString(ModuleName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG0(ERROR,
                 "ElfpOpenELW: ModuleName is not a Unicode string\n");

        return Status;
    }

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpOpenELW: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allocate a new structure for the context handle
    //

    LogIHandle = (IELF_HANDLE) ElfpAllocateBuffer (
                                    sizeof (*LogIHandle)
                                  + ModuleName->Length
                                  + sizeof (WCHAR)
                                  );

    if (LogIHandle)
    {
        //
        // Find the module structure in order to pull out the Atom.
        //
        // GetModuleStruc *always* succeeds! (returns default if module
        // not found).
        //

        Module = GetModuleStruc((PUNICODE_STRING) ModuleName);

        //
        // Validate the caller has appropriate access to this logfile.
        // If this is the security log, then check privilege instead.
        //
        if (_wcsicmp(ELF_SECURITY_MODULE_NAME, Module->LogFile->LogModuleName->Buffer) == 0)
        {
            ELF_LOG0(TRACE,
                     "ElfpOpenELW: Opening Security log\n");

            ForSecurityLog = TRUE;
        }

        Status = ElfpAccessCheckAndAudit(
                     L"EventLog",            // SubSystemName
                     L"LogFile",             // ObjectTypeName
                     Module->ModuleName,     // ObjectName
                     LogIHandle,             // Context handle - required?
                     Module->LogFile->Sd,    // Security Descriptor
                     DesiredAccess,          // Requested Access
                     NULL,                   // GENERIC_MAPPING
                     ForSecurityLog);        // Indicates the check is for security log

        if (NT_SUCCESS(Status))
        {
            LogIHandle->Atom = Module->ModuleAtom;

            LogIHandle->NameLength = ModuleName->Length + sizeof(WCHAR);

            RtlCopyMemory(LogIHandle->Name, ModuleName->Buffer, ModuleName->Length);

            LogIHandle->Name[ModuleName->Length / sizeof(WCHAR)] = L'\0';

            LogIHandle->MajorVersion = MajorVersion; // Store the version
            LogIHandle->MinorVersion = MinorVersion; // of the client

            //
            // Initialize seek positions and flags to zero.
            //

            LogIHandle->SeekRecordPos    = 0;
            LogIHandle->SeekBytePos      = 0;
            LogIHandle->Flags            = 0;
            LogIHandle->dwNotifyRequests = 0;

            //
            // Link in this structure to the list of context handles
            //

            LogIHandle->Signature = ELF_CONTEXTHANDLE_SIGN; // DEBUG
            LinkContextHandle (LogIHandle);

            *LogHandle = LogIHandle;                // Set return handle
            Status = STATUS_SUCCESS;                // Set return status
        }
        else
        {
            ELF_LOG1(TRACE,
                     "ElfpOpenELW: ElfpAccessCheckAndAudit failed %#x\n",
                     Status);

            ElfpFreeBuffer(LogIHandle);
        }
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfpOpenELW: Unable to allocate LogIHandle\n");

        Status = STATUS_NO_MEMORY;
    }

    return Status;

    UNREFERENCED_PARAMETER(UNCServerName);
    UNREFERENCED_PARAMETER(RegModuleName);
}


NTSTATUS
w_ElfrReadEL (
    IN      ULONG       Flags,                  // ANSI or UNICODE
    IN      IELF_HANDLE LogHandle,
    IN      ULONG       ReadFlags,
    IN      ULONG       RecordNumber,
    IN      ULONG       NumberOfBytesToRead,
    IN      PBYTE       Buffer,
    OUT     PULONG      NumberOfBytesRead,
    OUT     PULONG      MinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the worker for the ElfrReadEL APIs.

Arguments:

   Same as ElfrReadELW API except that Flags contains an indication
   of whether this is ANSI or UNICODE.

Return Value:

    Same as the main API.

NOTES:

    We assume that the client-side has validated the flags to ensure that
    only one type of each bit is set. No checking is done at the server end.


--*/
{
    NTSTATUS            Status;
    PLOGMODULE          Module;
    ELF_REQUEST_RECORD  Request;
    READ_PKT            ReadPkt;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "w_ElfrReadEL: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has read access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_READ))
    {
        ELF_LOG0(ERROR,
                 "w_ElfrReadEL: LogHandle does not have read access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //

    if (Buffer == NULL || !NumberOfBytesRead || !MinNumberOfBytesNeeded)
    {
        ELF_LOG1(ERROR,
                 "w_ElfrReadEL: %ws\n",
                 (Buffer == NULL ? L"Buffer is NULL" :
                      (!NumberOfBytesRead ? L"NumberOfBytesRead is 0" :
                                            L"MinNumberOfBytesNeeded is 0")));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // The ELF_HANDLE_INVALID_FOR_READ flag bit would be set if the
    // file changed underneath this handle.
    //

    if (LogHandle->Flags & ELF_LOG_HANDLE_INVALID_FOR_READ)
    {
        ELF_LOG0(ERROR,
                 "w_ElfrReadEL: Logfile changed under this handle -- invalid for read\n");

        return STATUS_EVENTLOG_FILE_CHANGED;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //

    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "w_ElfrReadEL: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    Request.Pkt.ReadPkt = &ReadPkt; // Set up read packet in request packet

    //
    // Find the matching module structure
    //
    Module = FindModuleStrucFromAtom (LogHandle->Atom);

    //
    // Only continue if the module was found
    //

    if (Module != NULL)
    {
        ELF_LOG1(TRACE,
                 "w_ElfrReadEL: Performing read on module %ws\n",
                 Module->ModuleName);

        //
        // Fill in the request packet
        //
        Request.Module = Module;
        Request.Flags = 0;
        Request.LogFile = Module->LogFile;
        Request.Command = ELF_COMMAND_READ;
        Request.Status = STATUS_SUCCESS;

        Request.Pkt.ReadPkt->MinimumBytesNeeded = *MinNumberOfBytesNeeded;
        Request.Pkt.ReadPkt->BufferSize = NumberOfBytesToRead;
        Request.Pkt.ReadPkt->Buffer = (PVOID)Buffer;
        Request.Pkt.ReadPkt->ReadFlags = ReadFlags;
        Request.Pkt.ReadPkt->RecordNumber = RecordNumber;
        Request.Pkt.ReadPkt->LastSeekPos = LogHandle->SeekBytePos;
        Request.Pkt.ReadPkt->LastSeekRecord = LogHandle->SeekRecordPos;
        Request.Pkt.ReadPkt->Flags = Flags;     // Indicate UNICODE or ANSI

        //
        // Pass along whether the last read was in a forward or backward
        // direction (affects how we treat being at EOF). Then reset the
        // bit in the handle depending on what this read is.
        //
        if (LogHandle->Flags & ELF_LOG_HANDLE_LAST_READ_FORWARD)
        {
            Request.Pkt.ReadPkt->Flags |= ELF_LAST_READ_FORWARD;
        }

        if (ReadFlags & EVENTLOG_FORWARDS_READ)
        {
            LogHandle->Flags |= ELF_LOG_HANDLE_LAST_READ_FORWARD;
        }
        else
        {
            LogHandle->Flags &= ~(ELF_LOG_HANDLE_LAST_READ_FORWARD);
        }


        //
        // Perform the operation
        //
        ElfPerformRequest(&Request);

        //
        // Update current seek positions
        //
        LogHandle->SeekRecordPos = Request.Pkt.ReadPkt->LastSeekRecord;
        LogHandle->SeekBytePos   = Request.Pkt.ReadPkt->LastSeekPos;

        //
        // Set up return values
        //
        *NumberOfBytesRead      = Request.Pkt.ReadPkt->BytesRead;
        *MinNumberOfBytesNeeded = Request.Pkt.ReadPkt->MinimumBytesNeeded;

        Status = Request.Status;
    }
    else
    {
        ELF_LOG0(ERROR,
                 "w_ElfrReadEL: No module associated with atom in LogHandle\n");

        Status = STATUS_INVALID_HANDLE;

        //
        // Set the NumberOfBytesNeeded to zero since there are no bytes to
        // transfer.
        //
        *NumberOfBytesRead = 0;
        *MinNumberOfBytesNeeded = 0;
    }

    return Status;
}


NTSTATUS
ElfrReadELW (
    IN      IELF_HANDLE LogHandle,
    IN      ULONG       ReadFlags,
    IN      ULONG       RecordNumber,
    IN      ULONG       NumberOfBytesToRead,
    IN      PBYTE       Buffer,
    OUT     PULONG      NumberOfBytesRead,
    OUT     PULONG      MinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrReadELW API.

Arguments:



Return Value:

    Returns an NTSTATUS code, NumberOfBytesRead if the read was successful
    and MinNumberOfBytesNeeded if the buffer was not big enough.


--*/
{
    //
    // Call the worker with the UNICODE flag.
    // All arguments checked in w_ElfrReadEL.
    //
    return w_ElfrReadEL(ELF_IREAD_UNICODE,
                        LogHandle,
                        ReadFlags,
                        RecordNumber,
                        NumberOfBytesToRead,
                        Buffer,
                        NumberOfBytesRead,
                        MinNumberOfBytesNeeded);
}


NTSTATUS
ElfrReportEventW (
    IN      IELF_HANDLE LogHandle,
    IN      ULONG               EventTime,
    IN      USHORT              EventType,
    IN      USHORT              EventCategory OPTIONAL,
    IN      ULONG               EventID,
    IN      USHORT              NumStrings,
    IN      ULONG               DataSize,
    IN      PRPC_UNICODE_STRING ComputerName,
    IN      PRPC_SID            UserSid,
    IN      PRPC_UNICODE_STRING Strings[],
    IN      PBYTE               Data,
    IN      USHORT              Flags,
    IN OUT  PULONG              RecordNumber OPTIONAL,
    IN OUT  PULONG              TimeWritten  OPTIONAL
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrReportEventW API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS            Status;
    PLOGMODULE          Module;
    ELF_REQUEST_RECORD  Request;
    WRITE_PKT           WritePkt;

    ULONG RecordLength;
    ULONG StringOffset, DataOffset;
    ULONG StringsSize;
    USHORT i;
    PVOID EventBuffer;
    PEVENTLOGRECORD EventLogRecord;
    PWSTR  ReplaceStrings, SrcString;
    PBYTE  BinaryData;
    PUNICODE_STRING  UComputerName;
    PWSTR   UModuleName;
    ULONG   PadSize;
    ULONG   UserSidLength = 0;              // Init to zero
    ULONG   UserSidOffset;
    ULONG   ModuleNameLen, ComputerNameLen; // Length in bytes
    ULONG   zero = 0;                       // For pad bytes
    LARGE_INTEGER    Time;
    ULONG   LogTimeWritten;

    //
    // These will be for Security Auditing to use for paired events.
    //
    UNREFERENCED_PARAMETER(RecordNumber);
    UNREFERENCED_PARAMETER(TimeWritten);

    //
    // Check the handle before proceeding.
    //
    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventW: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Insure the caller has write access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_WRITE))
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventW: LogHandle does not have write access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //
    Status = VerifyUnicodeString(ComputerName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventW: ComputerName is not a valid Unicode string %#x\n",
                 Status);

        return Status;
    }

    if (Strings == NULL && NumStrings != 0)
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventW: Strings is NULL and NumStrings is non-zero (%d)\n",
                 NumStrings);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // This condition is TRUE iff a backup operator has opened the security
    // log. In this case deny access, since backup operators are allowed
    // only backup operation on the security log.
    //
    if (LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP)
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventW: Handle is a backup handle\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Make sure the SID passed in is valid
    //

    if (ARGUMENT_PRESENT(UserSid))
    {
        if (!IsValidSid(UserSid))
        {
            ELF_LOG0(ERROR,
                     "ElfrReportEventW: UserSid is invalid\n");

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Verify the string arguments
    //
    for (i = 0; i < NumStrings; i++ )
    {
        Status = VerifyUnicodeString(Strings[i]);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfrReportEventW: String %d is not a valid Unicode string %#x\n",
                     i,
                     Status);

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Can't write to a backup log
    //

    if (LogHandle->Flags & ELF_LOG_HANDLE_BACKUP_LOG)
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventW: Handle is for a backup log\n");

        return STATUS_INVALID_HANDLE;
    }

    //
    // Make sure they didn't pass in a null pointer for the data, but tell
    // me there was something there (I still think RPC should protect me from
    // this!)
    //
    if (!Data && DataSize != 0)
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventW: Data is NULL and DataSize is non-zero (%d)\n",
                 DataSize);

        return STATUS_INVALID_PARAMETER;
    }

    UComputerName = (PUNICODE_STRING)ComputerName;
    UModuleName   = LogHandle->Name;

    Request.Pkt.WritePkt = &WritePkt;   // Set up write packet in request packet
    Request.Flags = 0;

    //
    // Find the matching module structure
    //

    Module = FindModuleStrucFromAtom (LogHandle->Atom);

    if (Module != NULL)
    {
        //
        // Generate any additional information needed in the record.
        //
        // Info that we have                Info to generate
        // -----------------                ----------------
        //  Modulename                      UserSidLength
        //  EventType                       Length
        //  EventID                         StringOffset
        //  NumStrings                      DataOffset
        //  Strings                         PadBytes
        //  DataLength                      LogTimeWritten
        //  Data
        //  UserSidOffset
        //  UserSid
        //  ComputerName
        //  TimeGenerated
        //

        // LogTimeWritten
        // We need to generate a time when the log is written. This
        // gets written in the log so that we can use it to test the
        // retention period when wrapping the file.
        //

        NtQuerySystemTime(&Time);
        RtlTimeToSecondsSince1970(&Time,
                                  &LogTimeWritten);


        //
        // USERSIDLENTGH
        //
        if (UserSid)
        {
            UserSidLength = RtlLengthSid((PSID)UserSid);

            ELF_LOG1(TRACE,
                     "ElfrReportEventW: Length of sid is %d\n",
                     UserSidLength);
        }

        //
        // USERSIDOFFSET
        //
        // Extract the lengths from the STRING structure, and take care of
        // the trailing NULLs.
        //
        ModuleNameLen   = (wcslen(UModuleName) + 1) * sizeof (WCHAR);
        ComputerNameLen = UComputerName->Length + sizeof(WCHAR);

        ELF_LOG1(TRACE,
                 "ElfrReportEventW: Module name length (bytes) is %d\n",
                 ModuleNameLen);

        ELF_LOG1(TRACE,
                 "ElfrReportEventW: Computer name length (bytes) is %d\n",
                 UComputerName->Length + sizeof(WCHAR));

        UserSidOffset = sizeof(EVENTLOGRECORD) + ModuleNameLen + ComputerNameLen;
        UserSidOffset = ALIGN_UP_64(UserSidOffset, sizeof(PVOID));

        //
        // STRING OFFSET:
        //
        StringOffset = UserSidOffset + UserSidLength;

        //
        // Calculate the length of strings so that we can see how
        // much space is needed for that.
        //
        StringsSize = 0;

        for (i = 0; i < NumStrings; i++)
        {
            ELF_LOG3(TRACE,
                     "ElfrReportEventW: Length (bytes) of string %d (%ws) is %d\n",
                     i,
                     Strings[i]->Buffer,
                     Strings[i]->Length + sizeof(WCHAR));

            StringsSize += Strings[i]->Length + sizeof(WCHAR);
        }

        //
        // DATA OFFSET:
        //
        DataOffset = StringOffset + StringsSize;

        //
        // Determine how big a buffer is needed for the eventlog record.
        //
        RecordLength = DataOffset
                         + DataSize
                         + sizeof(RecordLength); // Size excluding pad bytes

        ELF_LOG1(TRACE,
                 "ElfrReportEventW: RecordLength (no pad bytes) is %d\n",
                 RecordLength);

        //
        // Determine how many pad bytes are needed to align to a DWORD
        // boundary.
        //

        PadSize = sizeof(ULONG) - (RecordLength % sizeof(ULONG));

        RecordLength += PadSize;    // True size needed

        ELF_LOG2(TRACE,
                 "ElfrReportEventW: RecordLength (with %d pad bytes) is %d\n",
                 PadSize,
                 RecordLength);

        //
        // Allocate the buffer for the Eventlog record
        //
        EventBuffer = ElfpAllocateBuffer(RecordLength);

        if (EventBuffer != NULL)
        {
            //
            // Fill up the event record
            //
            EventLogRecord = (PEVENTLOGRECORD)EventBuffer;

            EventLogRecord->Length = RecordLength;
            EventLogRecord->TimeGenerated = EventTime;
            EventLogRecord->Reserved  = ELF_LOG_FILE_SIGNATURE;
            EventLogRecord->TimeWritten = LogTimeWritten;
            EventLogRecord->EventID = EventID;
            EventLogRecord->EventType = EventType;
            EventLogRecord->EventCategory = EventCategory;
            EventLogRecord->ReservedFlags = Flags;
            EventLogRecord->ClosingRecordNumber = 0;
            EventLogRecord->NumStrings = NumStrings;
            EventLogRecord->StringOffset = StringOffset;
            EventLogRecord->DataLength = DataSize;
            EventLogRecord->DataOffset = DataOffset;
            EventLogRecord->UserSidLength = UserSidLength;
            EventLogRecord->UserSidOffset = UserSidOffset;

            //
            // Fill in the variable-length fields
            //

            //
            // STRINGS
            //
            ReplaceStrings = (PWSTR)((ULONG_PTR)EventLogRecord + (ULONG)StringOffset);

            for (i = 0; i < NumStrings; i++)
            {
                SrcString = (PWSTR) Strings[i]->Buffer;

                ELF_LOG1(TRACE,
                         "ElfrReportEventW: Copying string %d into record\n",
                         i);

                RtlCopyMemory(ReplaceStrings, SrcString, Strings[i]->Length);

                ReplaceStrings[Strings[i]->Length / sizeof(WCHAR)] = L'\0';
                ReplaceStrings = (PWSTR)((PBYTE) ReplaceStrings
                                                     + Strings[i]->Length
                                                     + sizeof(WCHAR));
            }

            //
            // MODULENAME
            //
            BinaryData = (PBYTE) EventLogRecord + sizeof(EVENTLOGRECORD);

            RtlCopyMemory(BinaryData,
                          UModuleName,
                          ModuleNameLen);

            ELF_LOG1(TRACE,
                     "ElfrReportEventW: Copying module name (%ws) into record\n",
                     UModuleName);

            //
            // COMPUTERNAME
            //
            ReplaceStrings = (LPWSTR) (BinaryData + ModuleNameLen);

            RtlCopyMemory(ReplaceStrings,
                          UComputerName->Buffer,
                          UComputerName->Length);

            ReplaceStrings[UComputerName->Length / sizeof(WCHAR)] = L'\0';

            ELF_LOG1(TRACE,
                     "ElfrReportEventW: Copying computer name (%ws) into record\n",
                     ReplaceStrings);

            //
            // USERSID
            //

            BinaryData = ((PBYTE) EventLogRecord) + UserSidOffset;

            RtlCopyMemory(BinaryData,
                          UserSid,
                          UserSidLength);

            //
            // BINARY DATA
            //
            BinaryData = (PBYTE) ((ULONG_PTR)EventLogRecord + DataOffset);

            if (Data)
            {
                RtlCopyMemory(BinaryData,
                              Data,
                              DataSize);
            }

            //
            // PAD  - Fill with zeros
            //
            BinaryData = (PBYTE) ((ULONG_PTR)BinaryData + DataSize);

            RtlCopyMemory(BinaryData,
                          &zero,
                          PadSize);

            //
            // LENGTH at end of record
            //
            BinaryData = (PBYTE)((ULONG_PTR) BinaryData + PadSize); // Point after pad bytes

            ((PULONG) BinaryData)[0] = RecordLength;

            //
            // Make sure we are in the right place
            //
            ASSERT ((ULONG_PTR)BinaryData
                == (RecordLength + (ULONG_PTR)EventLogRecord) - sizeof(ULONG));

            //
            // Set up request packet.
            // Link event log record into the request structure.
            //
            Request.Module = Module;
            Request.LogFile = Request.Module->LogFile;
            Request.Command = ELF_COMMAND_WRITE;

            Request.Pkt.WritePkt->Buffer = (PVOID)EventBuffer;
            Request.Pkt.WritePkt->Datasize = RecordLength;

            //
            // Perform the operation
            //
            ElfPerformRequest( &Request );

            //
            // Replicate the event if part of a cluster
            //
            ElfpReplicateEvent(Module, EventBuffer, RecordLength);

            //
            // Free up the buffer
            //
            ElfpFreeBuffer(EventBuffer);

            Status = Request.Status;                // Set status of WRITE
        }
        else
        {
            ELF_LOG0(ERROR,
                     "ElfrReportEventW: Unable to allocate EventLogRecord\n");

            Status = STATUS_NO_MEMORY;
        }

    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventW: No module associated with atom in LogHandle\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


//
// ANSI APIs
//

NTSTATUS
ElfrClearELFA (
    IN  IELF_HANDLE     LogHandle,
    IN  PRPC_STRING     BackupFileName
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrClearELFA API.

Arguments:

    LogHandle       - The context-handle for this module's call.

    BackupFileName  - Name of the file to back up the current log file.
                      NULL implies not to back up the file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  BackupFileNameU;

    //
    // Check the handle before proceeding.
    //
    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrClearELFA: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has clear access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_CLEAR))
    {
        ELF_LOG0(ERROR,
                 "ElfrClearELFA: Handle doesn't have clear access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //

    Status = VerifyAnsiString((PANSI_STRING) BackupFileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrClearELFA: BackupFileName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    //
    // Convert the BackupFileName to a UNICODE STRING and call the
    // UNICODE API to do the work.
    //
    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &BackupFileNameU,
                                          (PANSI_STRING) BackupFileName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        Status = ElfrClearELFW(LogHandle,
                               (PRPC_UNICODE_STRING) &BackupFileNameU);

        RtlFreeUnicodeString (&BackupFileNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfrClearELFA: Conversion of Ansi string %s to Unicode failed %#x\n",
                 BackupFileName->Buffer,
                 Status);
    }

    return Status;

}



NTSTATUS
ElfrBackupELFA (
    IN  IELF_HANDLE     LogHandle,
    IN  PRPC_STRING     BackupFileName
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrBackupELFA API.

Arguments:

    LogHandle       - The context-handle for this module's call.

    BackupFileName  - Name of the file to back up the current log file.


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  BackupFileNameU;

    //
    // Check the handle before proceeding.
    //

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrBackupELFA: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has backup access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_BACKUP))
    {
        ELF_LOG0(ERROR,
                 "ElfrBackupELFA: Handle does not have backup access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //
    Status = VerifyAnsiString((PANSI_STRING) BackupFileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrBackupELFA: BackupFileName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    //
    // Convert the BackupFileName to a UNICODE STRING and call the
    // UNICODE API to do the work.
    //
    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &BackupFileNameU,
                                          (PANSI_STRING) BackupFileName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        Status = ElfrBackupELFW(LogHandle,
                                (PRPC_UNICODE_STRING) &BackupFileNameU);

        RtlFreeUnicodeString(&BackupFileNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfrBackupELFA: Conversion of Ansi string %s to Unicode failed %#x\n",
                 BackupFileName->Buffer,
                 Status);
    }

    return Status;

}


NTSTATUS
ElfrRegisterEventSourceA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         ModuleName,
    IN  PRPC_STRING         RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrRegisterEventSourceA API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Not used.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".

Note:

    For now, just call ElfrOpenELA.


--*/
{

    NTSTATUS Status;
    PLOGMODULE Module;
    UNICODE_STRING ModuleNameU;

    //
    // Check arguments.
    //
    // LogHandle check in ElfpOpenELA.
    //

    Status = VerifyAnsiString((PANSI_STRING) ModuleName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrRegisterEventSourceA: ModuleName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &ModuleNameU,
                                          (PANSI_STRING) ModuleName,
                                          TRUE);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfrRegisterEventSourceA: Conversion of Ansi string %s "
                     "to Unicode failed %#x\n",
                 ModuleName->Buffer,
                 Status);

        return Status;
    }

    Module = GetModuleStruc((PUNICODE_STRING) &ModuleNameU);

    RtlFreeUnicodeString(&ModuleNameU);

    return ElfpOpenELA(UNCServerName,
                       ModuleName,
                       RegModuleName,
                       MajorVersion,
                       MinorVersion,
                       LogHandle,
                       ELF_LOGFILE_WRITE);
}

NTSTATUS
ElfrOpenELA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         ModuleName,
    IN  PRPC_STRING         RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrOpenEL API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Name of module to use to determine the log file.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".


--*/
{
    //
    // All arguments checked in ElfpOpenELA.
    //

    return ElfpOpenELA(UNCServerName,
                       ModuleName,
                       RegModuleName,
                       MajorVersion,
                       MinorVersion,
                       LogHandle,
                       ELF_LOGFILE_READ);
}


NTSTATUS
ElfpOpenELA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         ModuleName,
    IN  PRPC_STRING         RegModuleName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle,
    IN  ULONG               DesiredAccess
    )

/*++

Routine Description:

  Looks alot loke ElfrOpenELA, only this also takes a DesiredAccess parameter.


Arguments:

    UNCServerName   - Not used.

    ModuleName      - Name of the module that is making this call.

    RegModuleName   - Name of module to use to determine the log file.

    MajorVersion/MinorVersion - The version of the client.


    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".

--*/
{
    NTSTATUS       Status;
    UNICODE_STRING ModuleNameU;

    //
    // Check arguments.
    //
    Status = VerifyAnsiString((PANSI_STRING) ModuleName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpOpenELA: ModuleName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpOpenELA: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Convert the ModuleName and RegModulename to UNICODE STRINGs and call
    // the UNICODE API to do the work.
    //

    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &ModuleNameU,
                                          (PANSI_STRING) ModuleName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        //
        // We *KNOW* that the UNCServerName is not used
        // by ElfpOpenELW so we save ourselves some work
        // and just pass in a NULL.
        //
        Status = ElfpOpenELW((EVENTLOG_HANDLE_W) NULL,
                             (PRPC_UNICODE_STRING) &ModuleNameU,
                             NULL,
                             MajorVersion,
                             MinorVersion,
                             LogHandle,
                             DesiredAccess);

        RtlFreeUnicodeString(&ModuleNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfpOpenELA: Conversion of Ansi string %s to Unicode failed %#x\n",
                 ModuleName->Buffer,
                 Status);
    }

    return (Status);
    UNREFERENCED_PARAMETER(UNCServerName);
}


NTSTATUS
ElfrOpenBELA (
    IN  EVENTLOG_HANDLE_A   UNCServerName,
    IN  PRPC_STRING         FileName,
    IN  ULONG               MajorVersion,
    IN  ULONG               MinorVersion,
    OUT PIELF_HANDLE        LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrOpenBEL API.
  This routine allocates a structure for the context handle, finds
  the matching module name and fills in the data. It returns the
  pointer to the handle structure.


Arguments:

    UNCServerName   - Not used.

    FileName        - Filename of the logfile

    MajorVersion/MinorVersion - The version of the client.

    LogHandle       - Pointer to the place where the pointer to the
                      context handle structure will be placed.

Return Value:

    Returns an NTSTATUS code and, if no error, a "handle".


--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  FileNameU;

    //
    // Check arguments.
    //

    Status = VerifyAnsiString((PANSI_STRING) FileName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrOpenBELA: FileName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    //
    // A filename must be specified.
    //
    if (FileName->Length == 0)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELA: Filename length is 0\n");

        return STATUS_INVALID_PARAMETER;
    }

    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrOpenBELA: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Convert the FileName to a UNICODE STRINGs and call
    // the UNICODE API to do the work.
    //
    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &FileNameU,
                                          (PANSI_STRING) FileName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        //
        // We *KNOW* that the UNCServerName is not used
        // by ElfrOpenELW so we save ourselves some work
        // and just pass in a NULL.
        //
        Status = ElfrOpenBELW ((EVENTLOG_HANDLE_W) NULL,
                               (PRPC_UNICODE_STRING) &FileNameU,
                               MajorVersion,
                               MinorVersion,
                               LogHandle);

        RtlFreeUnicodeString(&FileNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfrOpenBELA: Error converting Ansi string %s to Unicode %#x\n",
                 FileName->Buffer,
                 Status);
    }

    return Status;
    UNREFERENCED_PARAMETER(UNCServerName);

}



NTSTATUS
ElfrReadELA (
    IN      IELF_HANDLE LogHandle,
    IN      ULONG       ReadFlags,
    IN      ULONG       RecordNumber,
    IN      ULONG       NumberOfBytesToRead,
    IN      PBYTE       Buffer,
    OUT     PULONG      NumberOfBytesRead,
    OUT     PULONG      MinNumberOfBytesNeeded
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrReadEL API.

Arguments:



Return Value:

    Returns an NTSTATUS code, NumberOfBytesRead if the read was successful
    and MinNumberOfBytesNeeded if the buffer was not big enough.


--*/
{
    //
    // Call the worker with the ANSI flag.
    // All arguments checked in w_ElfrReadEL.
    //
    return w_ElfrReadEL(ELF_IREAD_ANSI,
                        LogHandle,
                        ReadFlags,
                        RecordNumber,
                        NumberOfBytesToRead,
                        Buffer,
                        NumberOfBytesRead,
                        MinNumberOfBytesNeeded);
}



NTSTATUS
ConvertStringArrayToUnicode (
    PUNICODE_STRING *pUStringArray,
    PANSI_STRING    *Strings,
    USHORT          NumStrings
    )

/*++

Routine Description:

  This routine takes an array of PANSI_STRINGs and generates an array of
  PUNICODE_STRINGs. The destination array has already been allocated
  by the caller, but the structures for the UNICODE_STRINGs will need
  to be allocated by this routine.

Arguments:

    pUStringArray   - Array of PUNICODE_STRINGs.
    Strings         - Array of PANSI_STRINGs.
    NumStrings      - Number of elements in the arrays.

Return Value:

    Returns an NTSTATUS code.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT   i;

    //
    // For each string passed in, allocate a UNICODE_STRING buffer
    // and set it to the UNICODE equivalent of the string passed in.
    //
    for (i = 0; i < NumStrings; i++)
    {
        if (Strings[i])
        {
            Status = VerifyAnsiString(Strings[i]);

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ConvertStringArrayToUnicode: String %d is not "
                             "a valid Ansi string %#x\n",
                         i,
                         Status);

                break;
            }

            pUStringArray[i] = ElfpAllocateBuffer(sizeof(UNICODE_STRING));

            if (pUStringArray[i])
            {
                Status = RtlAnsiStringToUnicodeString(pUStringArray[i],
                                                      (PANSI_STRING) Strings[i],
                                                      TRUE);

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG2(ERROR,
                             "ConvertStringArrayToUnicode: Conversion of Ansi string "
                                 "%s to Unicode failed %#x\n",
                             Strings[i]->Buffer,
                             Status);
                }
            }
            else
            {
                ELF_LOG2(ERROR,
                         "ConvertStringArrayToUnicode: Unable to allocate memory for "
                             "Unicode string %d (Ansi string %s)\n",
                         i,
                         Strings[i]->Buffer);

                Status = STATUS_NO_MEMORY;
            }
        }
        else
        {
            pUStringArray[i] = NULL;
        }

        if (!NT_SUCCESS(Status))
        {
            break;                  // Jump out of loop and return status
        }
    }

    //
    // Free any allocations on failure.
    //

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ConvertStringArrayToUnicode: Function failed %#x\n",
                 Status);

        FreePUStringArray(pUStringArray, (USHORT)(i + 1));
    }

    return Status;
}



VOID
FreePUStringArray (
    PUNICODE_STRING  *pUStringArray,
    USHORT          NumStrings
    )
/*++

Routine Description:

  This routine takes the PUNICODE_STRING array that was filled in by
  ConvertStringArrayToUnicode and frees the buffer portion of
  each unicode string and then the UNICODE structure itseld. It handles
  the case where the array may not have been filled completely due
  to insufficient memory.

Arguments:

    pUStringArray   - Array of PUNICODE_STRINGs.
    NumStrings      - Number of elements in the array.

Return Value:

    NONE.

--*/
{
    USHORT      i;

    for (i = 0; i < NumStrings; i++)
    {
        if (pUStringArray[i])
        {
            if (pUStringArray[i]->Buffer)
            {
                //
                // Free the string buffer
                //
                RtlFreeUnicodeString(pUStringArray[i]);
            }

            //
            // Free the UNICODE_STRING itself -- this may be allocated
            // even if the string buffer isn't (if RtlAnsiStringToUnicodeString
            // failed in the ConvertStringArrayToUnicode call)
            //
            ElfpFreeBuffer(pUStringArray[i]);
            pUStringArray[i] = NULL;
        }
    }
}



NTSTATUS
ElfrReportEventA (
    IN      IELF_HANDLE         LogHandle,
    IN      ULONG               Time,
    IN      USHORT              EventType,
    IN      USHORT              EventCategory OPTIONAL,
    IN      ULONG               EventID,
    IN      USHORT              NumStrings,
    IN      ULONG               DataSize,
    IN      PRPC_STRING         ComputerName,
    IN      PRPC_SID            UserSid,
    IN      PRPC_STRING         Strings[],
    IN      PBYTE               Data,
    IN      USHORT              Flags,
    IN OUT  PULONG              RecordNumber OPTIONAL,
    IN OUT  PULONG              TimeWritten OPTIONAL
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrReportEventA API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS            Status;
    UNICODE_STRING      ComputerNameU;
    PUNICODE_STRING     *pUStringArray = NULL;

    //
    // Check the handle before proceeding.
    //
    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventA: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has write access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_WRITE))
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventA: Handle doesn't have write access\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // Verify additional arguments.
    //
    Status = VerifyAnsiString((PANSI_STRING) ComputerName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventA: ComputerName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    if (Strings == NULL && NumStrings != 0)
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventA: Strings is NULL and NumStrings is non-zero (%d)\n",
                 NumStrings);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Convert the ComputerName to a UNICODE STRING and call the
    // UNICODE API.
    //
    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &ComputerNameU,
                                          (PANSI_STRING) ComputerName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        if (NumStrings)
        {
            pUStringArray = ElfpAllocateBuffer(NumStrings * sizeof(PUNICODE_STRING));

            if (pUStringArray)
            {
                //
                // Convert the array of STRINGs to an array of UNICODE-STRINGs
                // before calling the unicode API.
                // We can just use the array of Strings passed in since we
                // don't need to use it anywhere else.
                //
                Status = ConvertStringArrayToUnicode(pUStringArray,
                                                     (PANSI_STRING *) Strings,
                                                     NumStrings);
            }
            else
            {
                ELF_LOG0(ERROR,
                         "ElfrReportEventA: Unable to allocate pUStringArray\n");

                Status = STATUS_NO_MEMORY;
            }
        }

        if (NT_SUCCESS(Status))
        {
            Status = ElfrReportEventW(LogHandle,
                                      Time,
                                      EventType,
                                      EventCategory,
                                      EventID,
                                      NumStrings,
                                      DataSize,
                                      (PRPC_UNICODE_STRING) &ComputerNameU,
                                      UserSid,
                                      (PRPC_UNICODE_STRING*) pUStringArray,
                                      Data,
                                      Flags,        // Flags        | paired event
                                      RecordNumber, // RecordNumber | support. not in
                                      TimeWritten); // TimeWritten  | product 1

            FreePUStringArray(pUStringArray, NumStrings);
        }

        RtlFreeUnicodeString(&ComputerNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfrReportEventA: Conversion of Ansi string %s to Unicode failed %#X\n",
                 ComputerName->Buffer,
                 Status);
    }

    ElfpFreeBuffer(pUStringArray);

    return Status;
}


NTSTATUS
VerifyElfHandle(
    IN IELF_HANDLE LogHandle
    )

/*++

Routine Description:

    Verify the handle via its DWORD signature.

Arguments:

    LogHandle   - Handle to verify.

Return Value:

    STATUS_SUCCESS          - Presumably valid handle.
    STATUS_INVALID_HANDLE   - Invalid handle.

--*/
{
    NTSTATUS Status;

    if (LogHandle != NULL)
    {
        try
        {
            if (LogHandle->Signature == ELF_CONTEXTHANDLE_SIGN)
            {
                Status = STATUS_SUCCESS;
            }
            else
            {
                ELF_LOG2(ERROR,
                         "VerifyElfHandle: Incorrect LogHandle signature %#x "
                             "(should be %#x)\n",
                         LogHandle->Signature,
                         ELF_CONTEXTHANDLE_SIGN);

                Status = STATUS_INVALID_HANDLE;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ELF_LOG1(ERROR,
                     "VerifyElfHandle: Exception %#x caught while probing LogHandle\n",
                     GetExceptionCode());

            Status = STATUS_INVALID_HANDLE;
        }
    }
    else
    {
        ELF_LOG0(ERROR,
                 "VerifyElfHandle: LogHandle is NULL\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


ULONG
Safewcslen(
    UNALIGNED WCHAR *p,
    LONG            MaxLength
    )
/*++

    Safewcslen - Strlen that won't exceed MaxLength

Routine Description:

    This routine is called to determine the size of a UNICODE_STRING

Arguments:
    p         - The string to count.
    MaxLength - The maximum length to look at.


Return Value:

    Number of bytes in the string (or MaxLength)

--*/
{
    ULONG Count = 0;

    if (p)
    {
        while (MaxLength > 0 && *p++ != UNICODE_NULL)
        {
            MaxLength -= sizeof(WCHAR);
            Count     += sizeof(WCHAR);
        }
    }

    return Count;
}


ULONG
Safestrlen(
    UNALIGNED char *p,
    LONG           MaxLength
    )
/*++

    Safestrlen - Strlen that won't exceed MaxLength

Routine Description:

    This routine is called to determine the length of an ANSI_STRING

Arguments:
    p         - The string to count.
    MaxLength - The maximum length to look at.


Return Value:

    Number of chars in the string (or MaxLength)

--*/
{
    ULONG Count = 0;

    if (p)
    {
        while (MaxLength > 0 && *p++ != '\0')
        {
            MaxLength--;
            Count++;
        }
    }

    return Count;
}



NTSTATUS
VerifyUnicodeString(
    IN PUNICODE_STRING pUString
    )

/*++

Routine Description:

    Verify the unicode string. The string is invalid if:
        The UNICODE_STRING structure ptr is NULL.
        The MaximumLength field is invalid (too small).
        The Length field is incorrect.

Arguments:

    pUString    - String to verify.

Return Value:

    STATUS_SUCCESS              - Valid string.
    STATUS_INVALID_PARAMETER    - I wonder.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Check validity of structure fields and actual string
    // length vs. length value supplied
    //
    if (!pUString ||
        pUString->MaximumLength < pUString->Length ||
        pUString->Length != Safewcslen(pUString->Buffer,
                                       pUString->MaximumLength))
    {
        ELF_LOG1(ERROR,
                 "VerifyUnicodeString: String is invalid because %ws\n",
                 (!pUString ?
                     L"it's NULL" :
                     (pUString->MaximumLength < pUString->Length ? L"MaximumLength < Length" :
                                                                   L"Length is incorrect")));

        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}



NTSTATUS
VerifyAnsiString(
    IN PANSI_STRING pAString
    )

/*++

Routine Description:

    Verify the ansi string. The string is invalid if:
        The ANSI_STRING structure ptr is NULL.
        The MaximumLength field is invalid (too small).
        The Length field is incorrect.

Arguments:

    pAString    - String to verify.

Return Value:

    STATUS_SUCCESS              - Valid string.
    STATUS_INVALID_PARAMETER    - I wonder.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pAString ||
        pAString->MaximumLength < pAString->Length ||
        pAString->Length != Safestrlen(pAString->Buffer,
                                       pAString->MaximumLength))
    {
        ELF_LOG1(ERROR,
                 "VerifyAnsiString: String is invalid because %ws\n",
                 (!pAString ?
                     L"it's NULL" :
                     (pAString->MaximumLength < pAString->Length ? L"MaximumLength < Length" :
                                                                   L"Length is incorrect")));

        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}



//SS:changes made to enable cluster wide event logging
/****
@func       NTSTATUS | ElfrRegisterClusterSvc|  This is the server entrypoint
            for ElfRegisterClusterSvc.  The cluster service registers
            itself with the event log service to enable propagation of events
            across the cluster.  The binding handle to the cluster service for
            propagation of events is obtained.

@parm       IN  EVENTLOG_HANDLE_W | UNCServerName | This parameter is ignored. It
            is retained for correspondence with other elf apis.

@parm       OUT PULONG | pulSize | A pointer to a long where the size of the
            packed event information structure is returned.

@parm       OUT PBYTE | *ppPackedEventInfo| A pointer to the packed event information
            structure for propagation is returned via this parameter.

@comm       The cluster service propagates events contained in this structure
            and deletes the memory after it has done so.  Once the cluster service has
            registered with the eventlog service, the eventlog service passes up
            logged events to the cluster service for propagation.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f ElfRegisterClusterSvc> <f ElfrDeregisterClusterSvc>
****/
NTSTATUS
ElfrRegisterClusterSvc(
    IN  EVENTLOG_HANDLE_W UNCServerName,
    OUT PULONG            pulSize,
    OUT PBYTE             *ppPackedEventInfo)
{
    ULONG               ulTotalSize       = 0;
    ULONG               ulTotalEventsSize = 0;
    ULONG               ulNumLogFiles     = 0;
    PPROPLOGFILEINFO    pPropLogFileInfo  = NULL;
    NTSTATUS            Status;
    PPACKEDEVENTINFO    pPackedEventInfo  = NULL;
    UINT                i;
    PEVENTSFORLOGFILE   pEventsForLogFile;
    WCHAR               *pBinding         = NULL;
    HANDLE              hClusSvcNode      = NULL;
    UNICODE_STRING      RootRegistryNode;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    BOOL                bAcquired = FALSE;
    BOOL                bInitedCritSec    = FALSE;

    ELF_LOG0(CLUSTER,
             "ElfRegisterClusterSvc: Entry\n");

    //
    // Initialize the OUT parameters
    //
    *pulSize = 0;
    *ppPackedEventInfo = NULL;

    //
    // Check to see if the cluster service is installed.
    //
    RtlInitUnicodeString(&RootRegistryNode, REG_CLUSSVC_NODE_PATH);
    InitializeObjectAttributes(&ObjectAttributes,
                               &RootRegistryNode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&hClusSvcNode, KEY_READ | KEY_NOTIFY, &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfRegisterClusterSvc: NtOpenKey of %ws failed %#x\n",
                 REG_CLUSSVC_NODE_PATH,
                 Status);

        goto FnExit;
    }

    NtClose(hClusSvcNode);

    Status = STATUS_SUCCESS;

    //
    // If the cluster service dies and restarts again in the same session
    // then it will try to register again.
    // We dont reinitialize these globals again to prevent leaks
    //
    RtlEnterCriticalSection(&gClPropCritSec);

    if (!gbClustering)
    {
        ELF_LOG0(CLUSTER,
                 "ElfRegisterClusterSvc: gbClustering is FALSE\n");

        //
        // Load the cluster support dll
        //
        ghClusDll = LoadLibraryW(L"CLUSSPRT.DLL");

        if (!ghClusDll)
        {
            RtlLeaveCriticalSection(&gClPropCritSec);
            Status = STATUS_DLL_NOT_FOUND;
            goto FnExit;
        }
    }
    //
    // Get the function entry points
    //
    gpfnPropagateEvents   = (PROPAGATEEVENTSPROC) GetProcAddress(ghClusDll,
                                                                 "PropagateEvents");

    gpfnBindToCluster     = (BINDTOCLUSTERPROC) GetProcAddress(ghClusDll,
                                                               "BindToClusterSvc");

    gpfnUnbindFromCluster = (UNBINDFROMCLUSTERPROC) GetProcAddress(ghClusDll,
                                                                   "UnbindFromClusterSvc");


    if (!gpfnPropagateEvents || !gpfnBindToCluster || !gpfnUnbindFromCluster)
    {
        ELF_LOG1(ERROR,
                 "ElfRegisterClusterSvc: GetProcAddress for %ws in clussprt.dll failed\n",
                 (!gpfnPropagateEvents ? L"PropagateEvents" :
                                         (!gpfnBindToCluster ? L"BindToClusterSvc" :
                                                               L"UnbindFromClusterSvc")));

        RtlLeaveCriticalSection(&gClPropCritSec);
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto FnExit;
    }

    //
    // If we had bound to the cluster service previously, unbind and then rebind
    //
    if (ghCluster)
    {
        (*gpfnUnbindFromCluster)(ghCluster);
    }
    //
    // Bind to the cluster service
    //
    ghCluster = (*gpfnBindToCluster)(NULL);

    if (!ghCluster)
    {
        ELF_LOG1(ERROR,
                 "ElfRegisterClusterSvc: BindToCluster failed %d\n",
                 GetLastError());

        RtlLeaveCriticalSection(&gClPropCritSec);
        Status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    RtlLeaveCriticalSection(&gClPropCritSec);

    //
    // Since we are going to read the logs, make sure the service is running
    //
    while((GetElState() == RUNNING) && (!bAcquired))
    {

        bAcquired = RtlAcquireResourceShared(&GlobalElfResource,
                                             FALSE);             // Don't wait

        if (!bAcquired)
        {
            ELF_LOG0(CLUSTER,
                     "ElfRegisterClusterSvc: Sleep waiting for global resource\n");

            Sleep(ELF_GLOBAL_RESOURCE_WAIT);
        }
    }

    //
    // If the resource was not available and the status of the service
    // changed to one of the "non-working" states, then we just return
    // unsuccesful.  Rpc should not allow this to happen.
    //
    if (!bAcquired)
    {
        ELF_LOG0(ERROR,
                 "ElfRegisterClusterSvc: Global resource not acquired\n");

        Status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Determine the size of and acquire read locks on all files.
    // FindSizeofEventsSinceStart acquires the per-log locks if
    // there are events in that log to propagate.
    //
    Status = FindSizeofEventsSinceStart(&ulTotalEventsSize,
                                        &ulNumLogFiles,
                                        &pPropLogFileInfo);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfRegisterClusterSvc: FindSizeofEventsSinceStart failed %#x\n",
                 Status);

        goto FnExit;
    }

    //
    // If there are any events to propagate
    //
    if (ulNumLogFiles && ulTotalEventsSize && pPropLogFileInfo)
    {
        ulTotalSize = sizeof(PACKEDEVENTINFO)                          // header
                          + (sizeof(ULONG) * ulNumLogFiles)            // offsets
                          + (sizeof(EVENTSFORLOGFILE) * ulNumLogFiles) // info per log
                          + ulTotalEventsSize;

        //
        // Allocate memory
        //
        *ppPackedEventInfo = (PBYTE) ElfpAllocateBuffer(ulTotalSize);

        if (!(*ppPackedEventInfo))
        {
            ELF_LOG1(ERROR,
                     "ElfRegisterClusterSvc: Unable to allocate %d bytes for pPackedEventInfo\n",
                     ulTotalSize);

            //
            // Free the read locks acquired in FindSizeofEventsSinceStart
            //
            for (i=0;i<ulNumLogFiles;i++)
            {
                RtlReleaseResource(&(pPropLogFileInfo[i].pLogFile->Resource));
            }

            Status = STATUS_NO_MEMORY;
            goto FnExit;
        }

        pPackedEventInfo = (PPACKEDEVENTINFO)(*ppPackedEventInfo);

        ELF_LOG2(CLUSTER,
                 "ElfRegisterClusterSvc: Allocated %d bytes, pPackedEventInfo is %#x\n",
                 ulTotalSize,
                 pPackedEventInfo);

        pPackedEventInfo->ulNumEventsForLogFile = ulNumLogFiles;

        for (i = 0;i < ulNumLogFiles; i++)
        {
            //
            // Set the offsets to the EVENTSFORLOGFILE structures
            //
            pPackedEventInfo->ulOffsets[i] =
                ((i == 0) ? (sizeof(PACKEDEVENTINFO) + ulNumLogFiles * sizeof(ULONG)) :
                            (pPackedEventInfo->ulOffsets[i - 1]
                                 + (pPropLogFileInfo[i - 1].ulTotalEventSize
                                 + sizeof(EVENTSFORLOGFILE))));

            ELF_LOG2(CLUSTER,
                     "ElfRegisterClusterSvc: pPackedEventInfo->ulOffsets[%d] = %d\n",
                     i,
                     pPackedEventInfo->ulOffsets[i]);

            pEventsForLogFile = (PEVENTSFORLOGFILE) ((PBYTE) pPackedEventInfo
                                                         + pPackedEventInfo->ulOffsets[i]);

            //
            // Set the size of the ith EVENTSFORLOGFILE structure
            //
            pEventsForLogFile->ulSize = sizeof(EVENTSFORLOGFILE)
                                            + pPropLogFileInfo[i].ulTotalEventSize;

            //
            // Copy the file name (or should we get the module name?)
            //
            lstrcpyW(pEventsForLogFile->szLogicalLogFile,
                     pPropLogFileInfo[i].pLogFile->LogModuleName->Buffer);

            //
            // Set the number of events
            //
            pEventsForLogFile->ulNumRecords = pPropLogFileInfo[i].ulNumRecords;

            ELF_LOG3(CLUSTER,
                     "ElfRegisterClusterSvc: pEventsForLogFile struct -- ulSize = %d, "
                         "Logical file = %ws, ulNumRecords = %d\n",
                     pEventsForLogFile->ulSize,
                     pEventsForLogFile->szLogicalLogFile,
                     pEventsForLogFile->ulNumRecords);

            //
            // Get the events
            //
            Status = GetEventsToProp((PEVENTLOGRECORD) ((PBYTE) pEventsForLogFile
                                                            + sizeof(EVENTSFORLOGFILE)),
                                                        pPropLogFileInfo + i);

            //
            // If that fails, set the ulNumRecords to 0 so tha
            // on a write this data is discarded.
            //
            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfRegisterClusterSvc: GetEventsToProp for %ws log failed %#x\n",
                         pPropLogFileInfo[i].pLogFile->LogModuleName->Buffer,
                         Status);

                pEventsForLogFile->ulNumRecords=0;

                //
                // Reset the error -- we will go to the next file
                //
                Status = STATUS_SUCCESS;
            }

            //
            // Advance the startpointer for all the files so if the cluster service
            // dies and is restarted, these events won't be propagated again
            //
            pPropLogFileInfo[i].pLogFile->SessionStartRecordNumber =
                pPropLogFileInfo[i].pLogFile->CurrentRecordNumber;

            ELF_LOG1(CLUSTER,
                     "ElfRegisterClusterSvc: Done processing %ws log\n",
                     pPropLogFileInfo[i].pLogFile->LogModuleName->Buffer);

            RtlReleaseResource (&(pPropLogFileInfo[i].pLogFile->Resource));
        }

        //
        // Set the total size
        //
        pPackedEventInfo->ulSize = pPackedEventInfo->ulOffsets[ulNumLogFiles - 1]
                                       + pPropLogFileInfo[ulNumLogFiles - 1].ulTotalEventSize
                                       + sizeof(EVENTSFORLOGFILE);

        *pulSize = pPackedEventInfo->ulSize;
    }

    RtlEnterCriticalSection (&gClPropCritSec);

    //
    // If the cluster service hadnt registered before or glClPackedEventInfo is NULL
    //
    if (!gbClustering || !gpClPackedEventInfo)
    {
        //
        // Allocate memory for processing events for propagation
        //
        ulTotalSize = sizeof(PACKEDEVENTINFO)              // header
                          + (sizeof(ULONG) * 1)            // offsets
                          + (sizeof(EVENTSFORLOGFILE) * 1) // per-log info
                          + MAXSIZE_OF_EVENTSTOPROP;

        //
        // Allocate memory
        //
        gpClPackedEventInfo = (PPACKEDEVENTINFO) ElfpAllocateBuffer(ulTotalSize);

        if (!gpClPackedEventInfo)
        {
            ELF_LOG1(ERROR,
                     "ElfRegisterClusterSvc: Unable to allocate %d bytes "
                         "for gpClPackedEventInfo\n",
                     ulTotalSize);

            Status = STATUS_NO_MEMORY;
            RtlLeaveCriticalSection (&gClPropCritSec);
            goto FnExit;
        }

        //
        // Setup the PACKEDEVENTINFO
        //
        gpClPackedEventInfo->ulNumEventsForLogFile = 1;
        gpClPackedEventInfo->ulOffsets[0]= sizeof(PACKEDEVENTINFO) + sizeof(ULONG);
    }

    //
    // Set the flag to true so that propagation is now on.
    //
    gbClustering = TRUE;
    RtlLeaveCriticalSection (&gClPropCritSec);

FnExit:

    if (!NT_SUCCESS(Status))
    {
        //
        // Something went wrong
        //
        ELF_LOG1(ERROR,
                 "ElfRegisterClusterSvc: Exiting with error %#x\n",
                 Status);

        RtlEnterCriticalSection(&gClPropCritSec);

        ElfpFreeBuffer(gpClPackedEventInfo);
        gpClPackedEventInfo = NULL;

        if (ghCluster && gpfnUnbindFromCluster)
        {
            (*gpfnUnbindFromCluster)(ghCluster);
            ghCluster = NULL;
        }

        if (ghClusDll)
        {
            FreeLibrary(ghClusDll);
            ghClusDll = NULL;
        }

        RtlLeaveCriticalSection(&gClPropCritSec);
    }

    //
    // Free the pPropLogFileInfo stucture
    //
    ElfpFreeBuffer(pPropLogFileInfo);

    if (bAcquired)
    {
        ReleaseGlobalResource();
    }

    ELF_LOG1(CLUSTER,
             "ElfRegisterClusterSvc: Returning status %#x\n",
             Status);

    ELF_LOG2(CLUSTER,
             "ElfRegisterClusterSvc: *pulSize = %d, *ppPackedEventInfo = %#x\n",
             *pulSize,
             *ppPackedEventInfo);

    return Status;
}



/****
@func       NTSTATUS | ElfrDeregisterClusterSvc| This is the server entry point
            for ElfDeregisterClusterSvc().  Before shutdown the cluster
            service deregisters itself for propagation of events from the
            eventlog service.

@comm       Note that events logged after the cluster service goes down
            are not propagated.  Binding handle is freed.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f ElfrRegisterClusterSvc>
****/
NTSTATUS
ElfrDeregisterClusterSvc(
    IN EVENTLOG_HANDLE_W UNCServerName
    )
{
    ELF_LOG0(CLUSTER,
             "ElfDeregisterClusterSvc: ElfrDeregisterClusterSvc: Entry\n");

    RtlEnterCriticalSection (&gClPropCritSec);

    if (gbClustering)
    {
        gbClustering = FALSE;

        ElfpFreeBuffer(gpClPackedEventInfo);
        gpClPackedEventInfo = NULL;

        //
        // Unload the cluster support dll
        //
        if (ghCluster && gpfnUnbindFromCluster)
        {
            (*gpfnUnbindFromCluster)(ghCluster);
            ghCluster = NULL;
        }

        if (ghClusDll)
        {
            FreeLibrary(ghClusDll);
            ghClusDll = NULL;
        }
    }

    RtlLeaveCriticalSection (&gClPropCritSec);

    ELF_LOG0(CLUSTER,
             "ElfDeregisterClusterSvc: Exit\n");

    return STATUS_SUCCESS;
}



/****
@func   NTSTATUS | ElfrWriteClusterEvents| The cluster service calls this
        api to log events reported at other nodes of the cluster in the event log files.

@parm   IN EVENTLOG_HANDLE_W | UNCServerName | Not used.

@parm   IN ULONG | ulSize | The size of the    packed event information structure.

@parm   IN PBYTE | pPackedEventInfo| A pointer to the packed event information
        structure for propagation.

@comm   The pPackedEventInfo is delinearized into eventlogbuffers for different event
        log files and the events are recorded in the appropriate eventlog file.  Multiple
        events per log file are supported.

@rdesc  Returns a result code. ERROR_SUCCESS on success.

@xref
****/
NTSTATUS
ElfrWriteClusterEvents(
    IN EVENTLOG_HANDLE_W UNCServerName,
    IN ULONG             ulSize,
    IN BYTE              *pBuffer
    )
{
    UINT                i,j;
    PEVENTSFORLOGFILE   pEventsForLogFile;
    UNICODE_STRING      ModuleName;
    PLOGMODULE          pLogModule;
    PEVENTLOGRECORD     pEventLogRecord;
    ELF_REQUEST_RECORD  Request;
    PPACKEDEVENTINFO    pPackedEventInfo;
    NTSTATUS            Status = STATUS_SUCCESS;
    WRITE_PKT           WritePkt;
    HANDLE              hClientToken = NULL;
    BOOL                bCheckMember;

    //
    // Impersonate to figure if the caller is in the admin group.
    // The cluster service must run in an account that has local
    // Admin privileges
    //
    Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrWriteClusterEvents: RpcImpersonateClient failed %#x\n",
                 Status);

        goto FnExit;
    }


    if (!OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hClientToken))
    {
        ELF_LOG1(ERROR,
                 "ElfrWriteClusterEvents: OpenThreadToken failed %d\n",
                 GetLastError());

        RpcRevertToSelf();
        Status = STATUS_ACCESS_DENIED;
        goto FnExit;
    }

    if (!CheckTokenMembership(hClientToken,
                              ElfGlobalData->AliasAdminsSid,
                              &bCheckMember))
    {
        ELF_LOG1(ERROR,
                 "ElfrWriteClusterEvents: CheckTokenMembership failed %d\n",
                 GetLastError());

        RpcRevertToSelf();
        Status = STATUS_ACCESS_DENIED;
        goto FnExit;
    }

    if (!bCheckMember)
    {
        ELF_LOG0(ERROR,
                 "ElfrWriteClusterEvents: Caller is not an Admin\n");

        Status = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        goto FnExit;
    }

    //
    // Stop impersonating
    //
    Status = I_RpcMapWin32Status(RpcRevertToSelf());

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrWriteClusterEvents: RpcRevertToSelf failed %#x\n",
                 Status);

        goto FnExit;
    }

    //
    // We want to put this in a try/except block because we're
    // probing potentially bad user-supplied data.
    //
    try
    {
        pPackedEventInfo = (PPACKEDEVENTINFO)pBuffer;

        
        //
        // Validate input parameters and check that clustering is on
        //
        if (!pPackedEventInfo
             ||
            !ulSize
             ||
            (((PBYTE)pPackedEventInfo + sizeof(PACKEDEVENTINFO)) > (PBYTE)(pBuffer + ulSize))
             ||
             ((PBYTE)pPackedEventInfo + ulSize <= pBuffer)   //if ulSize is large to cause overflow 
             ||
            (pPackedEventInfo->ulSize != ulSize)
             ||
            (!gbClustering))
        {
            ELF_LOG1(ERROR,
                     "ElfrWriteClusterEvents: Invalid parameter passed in -- %ws\n",
                     (!pPackedEventInfo ?
                          L"pPackedEventInfo is NULL" :
                          (!ulSize ?
                               L"ulSize is 0" :
                               (!gbClustering ?
                                    L"gbClustering is FALSE" :
                                    (pPackedEventInfo->ulSize != ulSize ?
                                         L"ulSize mismatch" :
                                         L"pBuffer too small or ulSize too large")))));

            Status = STATUS_INVALID_PARAMETER;
            goto FnExit;
        }

        ELF_LOG2(CLUSTER,
                 "ElfrWriteClusterEvents: ulSize = %d, ulNumEventsForLogFile = %d\n",
                 ulSize,
                 pPackedEventInfo->ulNumEventsForLogFile);


        if ((((PBYTE)pPackedEventInfo + sizeof(PACKEDEVENTINFO) + 
            (sizeof(DWORD) * (pPackedEventInfo->ulNumEventsForLogFile))) < 
            (PBYTE)(pBuffer)) ||
            (((PBYTE)pPackedEventInfo + sizeof(PACKEDEVENTINFO) + 
            (sizeof(DWORD) * (pPackedEventInfo->ulNumEventsForLogFile))) < 
            (PBYTE)(pBuffer + sizeof(PACKEDEVENTINFO))))                 
        {
            ELF_LOG0(ERROR,
                     "ElfrWriteClusterEvents: Buffer/values passed in caused overflow\n");
            Status = STATUS_INVALID_PARAMETER;                     
            goto FnExit;
        }

        //check to see whether we have valid offsets for each eventlog file in the buffer
        //first check to see the buffer passed in is big enough to contain the offsets
        if (((PBYTE)pPackedEventInfo + sizeof(PACKEDEVENTINFO) + 
            (sizeof(DWORD) * (pPackedEventInfo->ulNumEventsForLogFile))) > 
            (PBYTE)(pBuffer + ulSize))
        {
            ELF_LOG0(ERROR,
                     "ElfrWriteClusterEvents: Buffer passed in doesnt contain offsets for all the eventlogfiles\n");
            Status = STATUS_INVALID_PARAMETER;
            goto FnExit;
        }
        //
        // Setup the request packet
        //
        Request.Pkt.WritePkt = &WritePkt;   // Set up write packet in request packet
        Request.Flags = 0;

        //
        // For each log
        //
        for (i = 0; i < pPackedEventInfo->ulNumEventsForLogFile; i++)
        {
            pEventsForLogFile = (PEVENTSFORLOGFILE) ((PBYTE)pPackedEventInfo +
                                                         pPackedEventInfo->ulOffsets[i]);

            //
            // Check for overflow or pointer past end of buffer
            //
            if (((PBYTE) pEventsForLogFile < pBuffer)
                   ||
                (((PBYTE) pEventsForLogFile + sizeof(EVENTSFORLOGFILE)) >
                       (PBYTE) (pBuffer + ulSize)))
            {
                ELF_LOG2(ERROR,
                         "ElfrWriteClusterEvents: Bad offset for log %d -- %ws\n",
                         i,
                         ((PBYTE) pEventsForLogFile < pBuffer ? L"offset caused overflow" :
                                                                L"offset past end of buffer"));

                Status = STATUS_INVALID_PARAMETER;
                goto FnExit;
            }

            ELF_LOG2(CLUSTER,
                     "ElfrWriteClusterEvents: szLogicalFile = %ws, ulNumRecords = %d\n",
                     pEventsForLogFile->szLogicalLogFile,
                     pEventsForLogFile->ulNumRecords);

            //
            // Find the module -- since we dont trust this string, force null termination
            //
            pEventsForLogFile->szLogicalLogFile[MAXLOGICALLOGNAMESIZE - 1] = L'\0';

            RtlInitUnicodeString(&ModuleName, pEventsForLogFile->szLogicalLogFile);
            pLogModule = GetModuleStruc(&ModuleName);

            if (!pLogModule)
            {
                ELF_LOG1(ERROR,
                     "ElfrWriteClusterEvents: Bogus ModuleName %ws passed in\n",
                     pEventsForLogFile->szLogicalLogFile);
                //skip this log file and go to the next one                     
                continue;                                     
            }
            

            //
            // GetModuleStruc always returns something non-NULL -- if the
            // given module name is bogus, we'll use the Application log.
            //
            ELF_LOG2(CLUSTER,
                     "ElfrWriteClusterEvents: Processing records for %ws module (%ws log)\n",
                     pLogModule->ModuleName,
                     pLogModule->LogFile->LogModuleName->Buffer);

            Request.Module  = pLogModule;
            Request.LogFile = Request.Module->LogFile;
            Request.Command = ELF_COMMAND_WRITE;
            pEventLogRecord = (PEVENTLOGRECORD) (pEventsForLogFile->pEventLogRecords);

            for (j = 0;
                 j < pEventsForLogFile->ulNumRecords &&
                     pEventLogRecord->Reserved == ELF_LOG_FILE_SIGNATURE;
                 j++)
            {
                //
                // Check for pointer past end of buffer
                //
                if (((PBYTE) pEventLogRecord + pEventLogRecord->Length) >
                        (PBYTE) (pBuffer + ulSize))
                {
                    ELF_LOG3(ERROR,
                             "ElfrWriteClusterEvents: Record %d for %ws module "
                                 "(%ws log) too long\n",
                             j,
                             pLogModule->ModuleName,
                             pLogModule->LogFile->LogModuleName->Buffer);

                    Status = STATUS_INVALID_PARAMETER;
                    goto FnExit;
                }

                //
                // Fill in a request packet for the current record
                //
                Request.Pkt.WritePkt->Buffer   = pEventLogRecord;
                Request.Pkt.WritePkt->Datasize = pEventLogRecord->Length;

                //
                // SS: Should we get exclusive access to the log so that
                //     the current record number is not incremented
                //     for an event that needs to be propagated
                //     before the session start record number is set here?
                //
                ElfPerformRequest(&Request);

                //
                // Advance the session start record number, so that
                // we don't propagate an event propagated to us
                //
                pLogModule->LogFile->SessionStartRecordNumber =
                    pLogModule->LogFile->CurrentRecordNumber;

                //
                // Extract status of operation from the request packet
                //
                Status = Request.Status;

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG3(ERROR,
                             "ElfrWriteClusterEvents: Failed to write record %d to "
                                 "%ws log %#x\n",
                             j,
                             pLogModule->LogFile->LogModuleName->Buffer,
                             Status);
                }

                pEventLogRecord = (PEVENTLOGRECORD) ((PBYTE) pEventLogRecord +
                                                          pEventLogRecord->Length);
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG1(ERROR,
                 "ElfrWriteClusterEvents: Exception %#x caught probing passed-in buffer\n",
                 GetExceptionCode());

        Status = STATUS_INVALID_PARAMETER;
    }

FnExit:

    if (hClientToken)
    {
        CloseHandle(hClientToken);
    }

    return Status;
}

/****
@func   NTSTATUS | ElfpReplicateEvent| The cluster service calls this
        api to log events reported at other nodes of the cluster in the event log files.

@parm   IN PLOGMODULE | pModule| A pointer to a module for the eventlog file.

@parm   IN PVOID | pEventBuffer | A pointer to the event buffer.

@parm   IN DWORD | dwRecordLength| The length of the event buffer in bytes.

@comm   This replicates an event log record across a cluster.

@rdesc  Returns a result code. ERROR_SUCCESS on success.

@xref
****/
NTSTATUS
ElfpReplicateEvent(
    IN PLOGMODULE   pModule,
    IN PVOID        pEventBuffer,
    IN DWORD        dwRecordLength
)
{
    DWORD               dwError = ERROR_SUCCESS;

    if (dwRecordLength >= MAXSIZE_OF_EVENTSTOPROP )
    {
        ELF_LOG0(TRACE,
                 "ElfpReplicateEvent: eventlog record size is bigger than supported size\n");
        return(dwError);
    }
    
    //
    // Acquire the critical section for this global propagation area
    //
    RtlEnterCriticalSection (&gClPropCritSec);

    if (gbClustering)
    {
        PEVENTSFORLOGFILE   pEventsForLogFile;

        ELF_LOG0(TRACE,
                 "ElfpReplicateEvent: Part of a cluster -- propagating the event\n");

        //
        // Packed event info consists of:
        //
        //    1. PACKEDEVENTINFO structure
        //    2. size of offsets (currently 1 -- sizeof(ULONG))
        //    3. EVENTSFORLOGFILE structure
        //    4. The record itself
        //
        gpClPackedEventInfo->ulSize = sizeof(PACKEDEVENTINFO)
                                          + sizeof(ULONG)
                                          + sizeof(EVENTSFORLOGFILE)
                                          + dwRecordLength;

        pEventsForLogFile =
            (PEVENTSFORLOGFILE)((PBYTE) gpClPackedEventInfo
                                            + gpClPackedEventInfo->ulOffsets[0]);

        //
        // Set the events for log file structure
        //
        pEventsForLogFile->ulNumRecords = 1;

        lstrcpyW(pEventsForLogFile->szLogicalLogFile,
                 pModule->LogFile->LogModuleName->Buffer);

        pEventsForLogFile->ulSize = sizeof(EVENTSFORLOGFILE)
                                        + dwRecordLength;

        RtlCopyMemory(pEventsForLogFile->pEventLogRecords,
                      (PVOID) pEventBuffer,
                      dwRecordLength);

        dwError = (*gpfnPropagateEvents)(ghCluster,
                                         gpClPackedEventInfo->ulSize,
                                         (PUCHAR) gpClPackedEventInfo);

        //
        // Advance the session start record number so that the same
        // record doesnt get propagated twice.  If the service restarts,
        // don't advance the session number if the call doesn't succeed.
        //
        // Issue:  If the server is multi-threaded, we might lose events
        //         if a latter one gets propagated before one that gets
        //         written to the log earlier.  I dont think this is an
        //         eventlog problem since we are calling in a CS
        //
        if (dwError == ERROR_SUCCESS)
        {
            pModule->LogFile->SessionStartRecordNumber =
                pModule->LogFile->CurrentRecordNumber;
        }
    }

    RtlLeaveCriticalSection (&gClPropCritSec);

    return(dwError);
}

//SS:end of changes made to enable cluster wide event logging
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfcfg.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfcfg.h

Abstract:

    This file contains default settings for the eventlog service.

Author:

    Rajen Shah (rajens) 16-Aug-1991

Revision History:

--*/

#ifndef _EVENTDEFAULTS_
#define _EVENTDEFAULTS_

//
// Default for the Application log file
//
//

#define     ELF_DEFAULT_MODULE_NAME           ELF_APPLICATION_MODULE_NAME
#define     ELF_APPLICATION_DEFAULT_LOG_FILE  L"\\SystemRoot\\system32\\config\\appevent.evt"
#define     ELF_SYSTEM_DEFAULT_LOG_FILE       L"\\SystemRoot\\system32\\config\\sysevent.evt"
#define     ELF_SECURITY_DEFAULT_LOG_FILE     L"\\SystemRoot\\system32\\config\\secevent.evt"
#define     ELF_DEFAULT_MAX_FILE_SIZE         512*1024
#define     ELF_DEFAULT_RETENTION_PERIOD      1*24*3600
#define     ELF_DEFAULT_AUTOBACKUP         0

#define     ELF_GUEST_ACCESS_UNRESTRICTED     0
#define     ELF_GUEST_ACCESS_RESTRICTED       1

//
// Default title for the "log full" message box
//
#define     ELF_DEFAULT_MESSAGE_BOX_TITLE     L"Eventlog Service"

//
// Maximum size for the buffer that will read the key values from the
// registry.
//

#define     ELF_MAX_REG_KEY_INFO_SIZE         200

//
// String defines for the pre-defined nodes in the registry
// These are used to get to the appropriate nodes.
//

#define     REG_EVENTLOG_NODE_PATH  \
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Eventlog"

#define REGSTR_VAL_AUTOBACKUPLOGFILES  L"AutoBackupLogFiles"

#define     REG_COMPUTERNAME_NODE_PATH  \
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"

//SS: start of changes for replicated event logging across the cluster
#define     REG_CLUSSVC_NODE_PATH  \
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\ClusSvc"

//SS: end of changes for replicated event logging across the cluster

//
// String defines for the values for each of the configured pieces of
// information in the eventlog\logfiles node.  These exist per logfile.
//
//

#define     VALUE_FILENAME              L"File"
#define     VALUE_MAXSIZE               L"Maxsize"
#define     VALUE_RETENTION             L"Retention"
#define     VALUE_RESTRICT_GUEST_ACCESS L"RestrictGuestAccess"
#define     VALUE_LOGPOPUP              L"LogFullPopup"
#define     VALUE_DEBUG                 L"ElfDebugLevel"
#define     VALUE_COMPUTERNAME          L"ComputerName"

#endif // ifndef _EVENTDEFAULTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfdbg.h ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    scdebug.h

Abstract:

    Contains debug macros used by the Service Controller.

Author:

    Jonathan Schwartz (jschwart)    18-Nov-1999

Revision History:

    18-Nov-1999    jschwart
        Created from Service Controller's debugging macros

--*/

#ifndef _ELFDBG_H
#define _ELFDBG_H

#if DBG

//
// Debug output macros.
//
#define ELF_LOG0(level,string)               \
    if( ElfDebugLevel & (DEBUG_ ## level)){  \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId());         \
    }

#define ELF_LOG1(level,string,var)           \
    if( ElfDebugLevel & (DEBUG_ ## level)){  \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId(),var);     \
    }

#define ELF_LOG2(level,string,var1,var2)             \
    if( ElfDebugLevel & (DEBUG_ ## level)){          \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId(),var1,var2); \
    }

#define ELF_LOG3(level,string,var1,var2,var3)        \
    if( ElfDebugLevel & (DEBUG_ ## level)){          \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId(),var1,var2,var3); \
    }

#define ELF_LOG4(level,string,var1,var2,var3,var4)       \
    if( ElfDebugLevel & (DEBUG_ ## level)){              \
        DbgPrint("[ELF] %lx: " string,GetCurrentThreadId(),var1,var2,var3); \
    }

#else

#define ELF_LOG0(level,string)
#define ELF_LOG1(level,string,var)
#define ELF_LOG2(level,string,var1,var2)
#define ELF_LOG3(level,string,var1,var2,var3)
#define ELF_LOG4(level,string,var1,var2,var3,var4)

#endif  // DBG

#define DEBUG_NONE        0x00000000
#define DEBUG_ERROR       0x00000001
#define DEBUG_TRACE       0x00000002
#define DEBUG_MODULES     0x00000004
#define DEBUG_CLUSTER     0x00000008
#define DEBUG_LPC         0x00000010
#define DEBUG_HANDLE      0x00000020
#define DEBUG_FILES       0x00000040

#define DEBUG_ALL         0xffffffff

#endif  // _ELFDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfdata.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    DATA.C

Abstract:

    This file contains all the global data elements of the eventlog service.

Author:

    Rajen Shah  (rajens)    10-Jul-1991

[Environment:]

    User Mode - Win32, except for NTSTATUS returned by some functions.

Revision History:

    10-Jul-1991     RajenS
        created

--*/

//
// INCLUDES
//

#include <eventp.h>
#include <elfcfg.h>


#if DBG

//
// Always write errors to the debugger on checked builds
//
DWORD ElfDebugLevel = DEBUG_ERROR;

#endif  // DBG


//
// Handles used for the LPC port.
//
HANDLE ElfConnectionPortHandle;
HANDLE ElfCommunicationPortHandle;

// The heads of various linked lists
//
LIST_ENTRY      LogFilesHead;               // Log files

RTL_CRITICAL_SECTION    LogFileCritSec;     // Accessing log files

LIST_ENTRY      LogModuleHead;              // Modules registered for logging

RTL_CRITICAL_SECTION    LogModuleCritSec;   // Accessing log files

LIST_ENTRY      LogHandleListHead;          // Context-handles for log handles

RTL_CRITICAL_SECTION    LogHandleCritSec;   // Accessing log handles

LIST_ENTRY      QueuedEventListHead;        // Deferred events to write

RTL_CRITICAL_SECTION QueuedEventCritSec;    // Accessing the deferred events

LIST_ENTRY      QueuedMessageListHead;      // Deferred messagebox

RTL_CRITICAL_SECTION QueuedMessageCritSec;  // Accessing the deferred mb's

//
// Service-related global data
//

SERVICE_STATUS_HANDLE ElfServiceStatusHandle;

//
// The following resource is used to serialize access to the resources
// of the Eventlog service at the highest level. It is used to make sure
// that the threads that write/read/clear the log file(s) do not step over
// the threads that monitor the registry and deal with service control
// operations.
//
// The threads that operate on the log file(s) have Shared access to the
// resource, since they are further serialized on the file that they are
// working on.
//
// The threads that will modify the internal data structures, or the state
// of the service, need Exclusive access to the resource so that we can
// control access to the data structures and log files.
//

RTL_RESOURCE        GlobalElfResource;

//
// This is used by the Backup API to signify which 4K block of the log it's
// currently reading.  This is used to prevent a writer from overwriting this
// block while it is reading it.  The event is used to let a writer block if
// it was going to overwrite the current backup block, and get pulsed when
// the backup thread moves to the next block.

PVOID               ElfBackupPointer;
HANDLE              ElfBackupEvent;

//
// Handle for the LPC thread
//
HANDLE      LPCThreadHandle;

//
// Handle for the MessageBox thread
//
HANDLE      MBThreadHandle;

//
// Handle and ID for the registry monitor thread
//
HANDLE      RegistryThreadHandle;
DWORD       RegistryThreadId;

//
// Bitmask of things that have been allocated and/or started by the
// service. When the service terminates, this is what needs to be
// cleaned.
//
ULONG       EventFlags;     // Keep track of what is allocated

//
// Record used to indicate the end of the event records in the file.
//
ELF_EOF_RECORD  EOFRecord = {  ELFEOFRECORDSIZE,
                               0x11111111,
                               0x22222222,
                               0x33333333,
                               0x44444444,
                               FILEHEADERBUFSIZE,
                               FILEHEADERBUFSIZE,
                               1,
                               1,
                               ELFEOFRECORDSIZE
                            };

//
// Default module to use if no match is found, APPLICATION
//

PLOGMODULE ElfDefaultLogModule;

//
// Module for the eventlog service itself
//

PLOGMODULE ElfModule;

//
// Module for security
//

PLOGMODULE ElfSecModule;

//
// Handle (key) to the event log node in the registry.
// This is set up by the service main function.
//

HANDLE      hEventLogNode;

//
// Handle (key) to the ComputerName node in the registry.
// This is set up by the service main function.
//

HANDLE      hComputerNameNode;

//
// Used to create a unigue module name for backup logs
//

DWORD BackupModuleNumber;

//
// NT well-known SIDs
//
PSVCS_GLOBAL_DATA       ElfGlobalData;

//
// Global anonymous logon sid - used in log ACL's. The only SID allocated
// specifically by the eventlog service, all others are passed in from
// the service controller in ElfGlobalData.
//

PSID AnonymousLogonSid;

//
// Shutdown Flag
//
BOOL    EventlogShutdown;

HANDLE  ElfGlobalSvcRefHandle;

//
// This is the string used as the title of the log full message box.
// GlobalMessageBoxTitle will either point to the default string or
// to the string allocated in the format Message function.
//
LPWSTR  GlobalMessageBoxTitle;


//SS:start of changes for clustering
BOOL                    gbClustering=FALSE; //the cluster service has registered for replication of events
PPACKEDEVENTINFO        gpClPackedEventInfo=NULL; //pointer to preallocated memory for event propagation
RTL_CRITICAL_SECTION    gClPropCritSec;     // for using the global glClPackedEventInfo structure
HMODULE                 ghClusDll=NULL;
PROPAGATEEVENTSPROC     gpfnPropagateEvents=NULL;
BINDTOCLUSTERPROC       gpfnBindToCluster=NULL;
UNBINDFROMCLUSTERPROC   gpfnUnbindFromCluster=NULL;
HANDLE                  ghCluster=NULL;
//SS: end of changes for clustering
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfextrn.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfextrn.h

Abstract:

    This file contains all the externs for the global variables.

Author:

    Rajen Shah (rajens) 10-Jul-1991

Revision History:

--*/

#include <clussprt.h>

//
// DEFINITIONS
//

#define   EVENTLOG_SVC_NAMEW   L"EVENTLOG"


#if DBG

extern      DWORD  ElfDebugLevel;

#endif  // DBG


extern      HANDLE ElfConnectionPortHandle;
extern      HANDLE ElfCommunicationPortHandle;

extern      PWSTR Computername;

extern      LIST_ENTRY  LogFilesHead;       // Log files
extern      LIST_ENTRY  LogModuleHead;      // Modules registered for logging
extern      LIST_ENTRY  LogHandleListHead;  // Context-handles for log handles
extern      LIST_ENTRY  QueuedEventListHead; // Deferred events
extern      LIST_ENTRY  QueuedMessageListHead; //Deferred Messagebox

extern      RTL_CRITICAL_SECTION    LogFileCritSec;
extern      RTL_CRITICAL_SECTION    LogModuleCritSec;
extern      RTL_CRITICAL_SECTION    LogHandleCritSec;
extern      RTL_CRITICAL_SECTION    QueuedEventCritSec;
extern      RTL_CRITICAL_SECTION    QueuedMessageCritSec;

extern      SERVICE_STATUS ElfServiceStatus;
extern      SERVICE_STATUS_HANDLE ElfServiceStatusHandle;

extern      RTL_RESOURCE        GlobalElfResource;

extern      PSID        AnonymousLogonSid;

extern      PVOID       ElfBackupPointer;
extern      HANDLE      ElfBackupEvent;

extern      HANDLE      LPCThreadHandle;

extern      HANDLE      MBThreadHandle;

extern      HANDLE      RegistryThreadHandle;
extern      DWORD       RegistryThreadId;

extern      ULONG       EventFlags;

extern      ELF_EOF_RECORD  EOFRecord;

extern      PLOGMODULE ElfDefaultLogModule;

extern      PLOGMODULE ElfModule;

extern      PLOGMODULE ElfSecModule;

extern      HANDLE      hEventLogNode;

extern      HANDLE      hComputerNameNode;

extern      DWORD       BackupModuleNumber;

extern      PSVCS_GLOBAL_DATA   ElfGlobalData;    // WellKnownSids

extern      BOOL EventlogShutdown;

extern      HANDLE ElfGlobalSvcRefHandle;

extern      LPWSTR  GlobalMessageBoxTitle;

extern      HANDLE  g_hTimestampEvent;

//changes to support clustering
extern      BOOL                    gbClustering; 
extern      PPACKEDEVENTINFO        gpClPackedEventInfo;
extern      RTL_CRITICAL_SECTION    gClPropCritSec;     
extern      HMODULE                 ghClusDll;
extern      PROPAGATEEVENTSPROC     gpfnPropagateEvents;
extern      BINDTOCLUSTERPROC       gpfnBindToCluster;
extern      UNBINDFROMCLUSTERPROC   gpfnUnbindFromCluster;
extern      HANDLE                  ghCluster;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfdef.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfdef.h

Abstract:

    This file contains defines for the eventlog service.

Author:

    Rajen Shah (rajens) 1-Jul-1991

Revision History:

--*/

#ifndef _EVENTDEF_
#define _EVENTDEF_

//
// Logfile object specific access type
//
#define ELF_LOGFILE_READ             0x0001
#define ELF_LOGFILE_WRITE            0x0002
#define ELF_LOGFILE_CLEAR            0x0004
#define ELF_LOGFILE_START            0x0008
#define ELF_LOGFILE_STOP             0x000C
#define ELF_LOGFILE_CONFIGURE        0x0010
#define ELF_LOGFILE_BACKUP           0x0020     // Set iff a backup operator
                                                // opens the security log -
                                                // this overrides all other
                                                // flags.

#define ELF_LOGFILE_ALL_ACCESS       (STANDARD_RIGHTS_REQUIRED       | \
                                         ELF_LOGFILE_READ            | \
                                         ELF_LOGFILE_WRITE           | \
                                         ELF_LOGFILE_CLEAR           | \
                                         ELF_LOGFILE_START           | \
                                         ELF_LOGFILE_STOP            | \
                                         ELF_LOGFILE_CONFIGURE)

//
// Three types of logfiles are defined from a security perspective:
//
//    ELF_LOGFILE_SECURITY    - Only Admins/LocalSystem can RW these files
//    ELF_LOGFILE_SYSTEM      - Only Admins/LocalSystem can W these files
//    ELF_LOGFILE_APPLICATION - World can R/W these files
//
// System and Security will be SECURE, Application will be NON_SECURE
//

#define ELF_LOGFILE_SECURITY      0x0000
#define ELF_LOGFILE_SYSTEM        0x0001
#define ELF_LOGFILE_APPLICATION   0x0002

//
// Macro to convert a given file size into one that is "acceptable" for
// eventlogging. It basically truncates it to a 64K boundary making sure
// that it is as least 64K
//

#define     ELFFILESIZE(x) ((x & 0xFFFF0000) ? (x & 0xFFFF0000) : 65536)

//
// The largest possible buffer we would need to hold an admin alert
// information. This primarily depends on the number and length of the
// replacement strings that would be passed with the message ID.
//

#define     ELF_ADMIN_ALERT_BUFFER_SIZE     256

//
// Timeout defines.
//

#define     INFINITE_WAIT_TIME          -1      // Wait time for events
#define     ELF_GLOBAL_RESOURCE_WAIT    2000    // 2-second timeout for global resource

//
// Signature placed before each event record in a file. Is used to
// validate where we are in a file.
//

#define     ELF_RECORD_SIGNATURE    0x654c6652 // ASCII for eLfR

//
// Size by which to grow a log file until it reaches the max size
//

#define     ELF_DEFAULT_LOG_SIZE 65536

//
// Bits for whether to take the global resource exclusively or shared.
//

#define     ELF_GLOBAL_SHARED       0x0001
#define     ELF_GLOBAL_EXCLUSIVE    0x0002

//
// Flag bits to keep track of what resources have been allocated at INIT time
//

#define     ELF_INIT_LOGHANDLE_CRIT_SEC       0x0001
#define     ELF_INIT_GLOBAL_RESOURCE          0x0002
#define     ELF_STARTED_LPC_THREAD            0x0004
#define     ELF_STARTED_REGISTRY_MONITOR      0x0008
#define     ELF_STARTED_RPC_SERVER            0x0010
#define     ELF_INIT_LOGFILE_CRIT_SEC         0x0020
#define     ELF_INIT_LOGMODULE_CRIT_SEC       0x0040
#define     ELF_INIT_WELL_KNOWN_SIDS          0x0080
#define     ELF_INIT_QUEUED_EVENT_CRIT_SEC    0x0100
#define     ELF_INIT_QUEUED_MESSAGE_CRIT_SEC  0x0200
#define     ELF_INIT_CLUS_CRIT_SEC            0x0400

//
// Enumeration and macro to keep track of the "log full" popup per log
//

#define     IS_WORKSTATION()        (USER_SHARED_DATA->NtProductType == NtProductWinNt)

typedef enum
{
    LOGPOPUP_NEVER_SHOW = 0,         // Never show it for this log (e.g., Security)
    LOGPOPUP_CLEARED,                // Show it when this log fills up
    LOGPOPUP_ALREADY_SHOWN           // Don't show it again until this log is cleared
}
LOGPOPUP, *PLOGPOPUP;


//
// Structure containing information on each log file
//
// ActualMaxFileSize and ConfigMaxFileSize are stored in BYTEs.
// ActualMaxFileSize is the actual size of the file on the disk.
// ConfigMaxFileSize is the configured size of the file, which may not
// be the same as the actual size of the file.
//
// CurrentRecordNumber is the next absolute record number to write
//
// OldestRecordNumber is the next one to get overwritten
//
// Retention time is stored as the number of seconds.
//
// BaseAddress points to the physical beginning of the file.
//
// ViewSize is ALWAYS the size of the file in bytes.
//
// For the Flag bits, see the ELF_LOGFILE_HEADER_xxxx bits defined below.
//

typedef struct _LOGFILE {
    LIST_ENTRY      FileList;
    LIST_ENTRY      Notifiees;          // List of ChangeNotify recipients
    PUNICODE_STRING LogFileName;        // Full path name of log file
    PUNICODE_STRING LogModuleName;      // Name of default module for this log
    ULONG           RefCount;           // Number of modules using this file
    ULONG           Flags;              // Autowrap, dirty, etc. - See bits below
    ULONG           ConfigMaxFileSize;  // Max it can be
    ULONG           ActualMaxFileSize;  // How big it is now
    ULONG           NextClearMaxFileSize; // Can't be shrunk on the fly
    ULONG           CurrentRecordNumber;// The next one to be created
    ULONG           OldestRecordNumber; // The next one to overwrite
    ULONG           SessionStartRecordNumber; //the first record number logged in this session
    ULONG           Retention;          // Max. Retention time
    ULONG           NextClearRetention; // they shrank the file when they set this
    HANDLE          FileHandle;         // Handle to open file
    HANDLE          SectionHandle;      // Memory mapped section handle
    PVOID           BaseAddress;        // Map view base address
    ULONG           ViewSize;           // Mapped view size
    ULONG           BeginRecord;        // Offset of first log record
    ULONG           EndRecord;          // Offset of byte after last log record
    ULONG           ulLastPulseTime;    // Time this log was last notified of a change
    LOGPOPUP        logpLogPopup;       // "Log full" policy for this log
    PSECURITY_DESCRIPTOR Sd;            // User security object for this log
    RTL_RESOURCE    Resource;
    BOOL              bFullAlertDone;
    DWORD           AutoBackupLogFiles;
} LOGFILE, *PLOGFILE;

//
// Structure containing information on each module that is registered to
// log events.
//

typedef struct _LOGMODULE {
    LIST_ENTRY  ModuleList;
    PWSTR       ModuleName;         // Name of module
    ATOM        ModuleAtom;         // Atom identifying this module
    PLOGFILE    LogFile;            // Log file for this module
} LOGMODULE, *PLOGMODULE;

//
// Command codes put in the request packets.
//

#define     ELF_COMMAND_READ         1
#define     ELF_COMMAND_WRITE        2
#define     ELF_COMMAND_CLEAR        3
#define     ELF_COMMAND_BACKUP       4
#define     ELF_COMMAND_WRITE_QUEUED 5

//
// Structures that contain the operation-specific information.
//

typedef struct _WRITE_PKT {
    DWORD       Datasize;           // Size of data in the buffer
    PVOID       Buffer;             // Contains filled event log record
} WRITE_PKT, *PWRITE_PKT;


//
// The following flag bits are used in the READ_PKT Flag field.
//

#define     ELF_IREAD_UNICODE       0x0001
#define     ELF_IREAD_ANSI          0x0002
#define     ELF_LAST_READ_FORWARD   0x0004

typedef struct _READ_PKT {
    ULONG       Flags;              // UNICODE or ANSI
    ULONG       BufferSize;         // Bytes to read
    PVOID       Buffer;             // User's buffer
    ULONG       ReadFlags;          // Sequential? Forwards? Random-access? Backwards?
    ULONG       RecordNumber;       // Where to start the READ
    ULONG       MinimumBytesNeeded; // For return info if buffer too small
    ULONG       LastSeekPos;        // Last seek position in terms of bytes
    ULONG       LastSeekRecord;     // Last seek position in terms of records
    ULONG       BytesRead;          // Bytes read - for return to caller
    ULONG       RecordsRead;
} READ_PKT, *PREAD_PKT;

typedef struct _CLEAR_PKT {
    PUNICODE_STRING         BackupFileName; // File to back up current log file (or NULL)
} CLEAR_PKT, *PCLEAR_PKT;

typedef struct _BACKUP_PKT {
    PUNICODE_STRING         BackupFileName; // File to back up current log file (or NULL)
} BACKUP_PKT, *PBACKUP_PKT;

//
// Flags used in the ELF_REQUEST_RECORD
//

#define ELF_FORCE_OVERWRITE    0x01  // Ignore retention period for this write

//
// Structure for the packet that contains all the information needed
// to perform the request.
//

typedef struct _ELF_REQUEST_RECORD {
    USHORT      Flags;
    NTSTATUS    Status;             // To return status of operation
    PLOGFILE    LogFile;            // File on which to operate
    PLOGMODULE  Module;             // Information on module
    USHORT      Command;            // Operation to be performed
    union {
        PWRITE_PKT      WritePkt;
        PREAD_PKT       ReadPkt;
        PCLEAR_PKT      ClearPkt;
        PBACKUP_PKT     BackupPkt;
    } Pkt;
} ELF_REQUEST_RECORD, *PELF_REQUEST_RECORD;

typedef 
#ifdef _WIN64
__declspec(align(8))
#endif
struct _ELF_ALERT_RECORD {
    DWORD    TimeOut;
    DWORD    MessageId;
    DWORD    NumberOfStrings;
    // array of UNICODE_STRINGs NumberOfStringsLong
    // each string
} ELF_ALERT_RECORD, * PELF_ALERT_RECORD;

typedef struct _ELF_MESSAGE_RECORD {
    DWORD    MessageId;
    DWORD    NumberOfStrings;
    // UNICODE null terminated strings
} ELF_MESSAGE_RECORD, * PELF_MESSAGE_RECORD;

//
// Record for the linked list of deferred events (these are raised by the
// eventlog service itself for writing once the current operation is complete
//

typedef struct _ELF_QUEUED_EVENT {
    LIST_ENTRY  Next;
    enum _ELF_QUEUED_EVENT_TYPE {
        Event,
        Alert,
        Message
    } Type;
    union _ELF_QUEUED_EVENT_DATA {
        ELF_REQUEST_RECORD Request;
        ELF_ALERT_RECORD Alert;
        ELF_MESSAGE_RECORD Message;
    } Event;
} ELF_QUEUED_EVENT, *PELF_QUEUED_EVENT;

//
// Structure containing information on callers of ElfChangeNotify
//

typedef struct _NOTIFIEE {
    LIST_ENTRY      Next;
    IELF_HANDLE     Handle;
    HANDLE          Event;
} NOTIFIEE, *PNOTIFIEE;


//
// Structure that describes the header that is at the beginning of the
// log files.
//
// To see if there are any records in the file, one must subtract the
// EndOffset from the StartOffset (allowing for the file having wrapped
// around) and check for a difference of greater than 1.
//
// The header size is stored at the beginning and end so that it looks
// just like any other event log record (the lengths do at any rate).
//

typedef struct _ELF_LOGFILE_HEADER {
    ULONG       HeaderSize;             // Size of this header
    ULONG       Signature;              // Signature field
    ULONG       MajorVersion;
    ULONG       MinorVersion;
    ULONG       StartOffset;            // Where the first record is located
    ULONG       EndOffset;              // The end of the last record + 1
    ULONG       CurrentRecordNumber;    // The next record to create
    ULONG       OldestRecordNumber;     // The next record to overwrite
    ULONG       MaxSize;                // Max. size when file was created
    ULONG       Flags;                  // DIRTY, etc.
    ULONG       Retention;              // Last Retention period.
    ULONG       EndHeaderSize;          // Size of this header
} ELF_LOGFILE_HEADER, *PELF_LOGFILE_HEADER;

#define     FILEHEADERBUFSIZE       sizeof(ELF_LOGFILE_HEADER)
#define     ELF_LOG_FILE_SIGNATURE  0x654c664c  // ASCII for eLfL

//
// The following flag bits are used in ELF_LOGFILE_HEADER and in the
// LOGFILE structures' Flag fields.
//

#define     ELF_LOGFILE_HEADER_DIRTY    0x0001  // File has been written to
#define     ELF_LOGFILE_HEADER_WRAP     0x0002  // The file has wrapped
#define     ELF_LOGFILE_LOGFULL_WRITTEN 0x0004  // Written logfull record
#define     ELF_LOGFILE_ARCHIVE_SET     0x0008  // Archive bit flag


//
// Structure that defines the record that identifies the end of the
// circular log file.
// This record is used to identify where the last record in the circular
// buffer is located.
//
// NOTE: It is *essential* that this record is of a size that a "normal"
//       event log record can never have. There is code that relies on
//       this fact to detect an "EOF" record.
//
//       Care must be taken to not disturb the first part of this record.  It
//       is used to identify an EOF record.  ELFEOFUNIQUEPART must be the
//       number of bytes that are constant.
//

typedef struct _ELF_EOF_RECORD {
    ULONG       RecordSizeBeginning;
    ULONG       One;
    ULONG       Two;
    ULONG       Three;
    ULONG       Four;
    ULONG       BeginRecord;
    ULONG       EndRecord;
    ULONG       CurrentRecordNumber;
    ULONG       OldestRecordNumber;
    ULONG       RecordSizeEnd;
} ELF_EOF_RECORD, *PELF_EOF_RECORD;

#define     ELFEOFRECORDSIZE        sizeof (ELF_EOF_RECORD)

//
// The following constant is how much of the EOF record is constant, and can
// be used to identify an EOF record
//

#define     ELFEOFUNIQUEPART        5 * sizeof(ULONG)

//
// This is used to fill the end of a log record so that the fixed portion
// of a log record doesn't split the end of the file.  It must be less than
// the minimum size of any valid record
//

#define ELF_SKIP_DWORD sizeof(ELF_EOF_RECORD) - 1


//
// Time for the sender of a start or stop request to the Eventlog
// service to wait (in milliseconds) before checking on the
// Eventlog service again to see if it is done
//

#define ELF_WAIT_HINT_TIME            20000     // 20 seconds


//
// Flags used by ElfpCloseLogFile
//

#define ELF_LOG_CLOSE_NORMAL                    0x0000
#define ELF_LOG_CLOSE_FORCE                     0x0001
#define ELF_LOG_CLOSE_BACKUP                    0x0002

//
// Structure used to store information read from the registry
//

typedef struct _LOG_FILE_INFO {
    PUNICODE_STRING LogFileName;
    ULONG           MaxFileSize;
    ULONG           Retention;
    ULONG           GuestAccessRestriction;
    LOGPOPUP        logpLogPopup;
    DWORD           dwAutoBackup;
} LOG_FILE_INFO, *PLOG_FILE_INFO;


//
// DEBUG stuff.
//

//
// This signature is placed in the context handle for debug purposes only,
// to track down a bug in freeing the structures.
//

#define     ELF_CONTEXTHANDLE_SIGN          0x654c6648  // ASCII for eLfH

//
// The different file open (or create) options are based on the type of file.
// The types, and their meanings are:
//
//      ElfNormalLog        Normal log file, opened for cached io
//      ElfSecurityLog      Audit logs, opened for write-thru
//      ElfBackupLog        Not an active log file, opened read only, cached
//

typedef enum _ELF_LOG_TYPE {
    ElfNormalLog,
    ElfSecurityLog,
    ElfBackupLog
} ELF_LOG_TYPE, *PELF_LOG_TYPE;


//
// Eventlog States (used as return codes)
//

#define UPDATE_ONLY         0   // no change in state - just send current status.
#define STARTING            1   // the messenger is initializing.
#define RUNNING             2   // initialization completed normally - now running
#define STOPPING            3   // uninstall pending
#define STOPPED             4   // uninstalled
#define PAUSED              5   // Paused
#define PAUSING             6   // In the process of pausing
#define CONTINUING          7   // In the process of continuing

//
// Forced Shutdown PendingCodes
//
#define PENDING     TRUE
#define IMMEDIATE   FALSE

//
// defines for reliability logging
//
#define DEFAULT_INTERVAL 0

#define SHUTDOWN_UNPLANNED   0x80000000
#define SHUTDOWN_REASON_MASK 0xFFFF

typedef enum _TIMESTAMPEVENT{

    EVENT_Boot=0,
    EVENT_NormalShutdown,
    EVENT_AbNormalShutdown

} TIMESTAMPEVENT, *PTIMESTAMPEVENT;


//SS:Clustering specific extensions
typedef struct _PROPLOGFILEINFO{
    PLOGFILE    pLogFile;
    PVOID       pStartPosition;
    PVOID       pEndPosition;
    ULONG       ulTotalEventSize; 
    ULONG       ulNumRecords;
}PROPLOGFILEINFO, *PPROPLOGFILEINFO;

//structure for propagation is preallocated.
#define MAXSIZE_OF_EVENTSTOPROP (1 * 1024)

#endif // ifndef _EVENTDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfproto.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfproto.h

Abstract:

    This file contains the prototypes for the Eventlog service.

Author:

    Rajen Shah (rajens) 12-Aug-1991

Revision History:

--*/

#ifndef _ELFPROTO_
#define _ELFPROTO

//
// Other prototypes
//
VOID
ElfpCreateHeap(
    VOID
    );

PVOID
ElfpAllocateBuffer(
    ULONG size
    );

BOOLEAN
ElfpFreeBuffer(
    PVOID BufPtr
    );

VOID
ElfPerformRequest( 
    PELF_REQUEST_RECORD Request
    );


PLOGMODULE
GetModuleStruc (
    PUNICODE_STRING ModuleName
    );

PLOGMODULE
FindModuleStrucFromAtom (
    ATOM Atom 
    );

VOID
ElfControlResponse(
    DWORD
    );

VOID
IELF_HANDLE_rundown(
    IELF_HANDLE    ElfHandle
    );

VOID
LinkContextHandle(
    IELF_HANDLE     LogHandle
    );

VOID
UnlinkContextHandle (
    IELF_HANDLE     LogHandle
    );

VOID
LinkLogModule (
    PLOGMODULE   pLogModule,
    ANSI_STRING * pModuleNameA
    );

VOID
UnlinkLogModule (
    PLOGMODULE pLogModule
    );

VOID
LinkLogFile (
    PLOGFILE   pLogFile
    );

VOID
UnlinkLogFile (
    PLOGFILE pLogFile
    );

VOID
GetGlobalResource (
    DWORD Type
    );

VOID
ReleaseGlobalResource(
    VOID
    );

NTSTATUS
SetUpDataStruct (
    PUNICODE_STRING     LogFileName,
    ULONG               MaxFileSize,
    ULONG               Retention,
    ULONG               GuestAccessRestriction,
    PUNICODE_STRING     ModuleName,
    HANDLE              hLogFile,
    ELF_LOG_TYPE        LogType,
    LOGPOPUP            logpLogPopup,
    DWORD               dwAutoBackup
    );

NTSTATUS
SetUpModules (
    HANDLE              hLogFile,
    PLOGFILE            pLogFile,
    BOOLEAN             bAllowDupes
    );

BOOL
StartLPCThread (
    VOID
    );

VOID
StopLPCThread (
    VOID
    );

BOOL
ElfStartRegistryMonitor (
    VOID
    );

VOID
StopRegistryMonitor (
    VOID
    );

NTSTATUS
ReadRegistryInfo (
    HANDLE          hLogFiles,
    PUNICODE_STRING SubKeyName,
    PLOG_FILE_INFO  LogFileInfo
    );

NTSTATUS
ElfOpenLogFile (
    PLOGFILE pLogFile,
    ELF_LOG_TYPE LogType
    );

NTSTATUS
ElfpCloseLogFile (
    PLOGFILE    pLogFile,
    DWORD       Flags
    );

BOOL
ValidFilePos (
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
    PVOID PhysicalEOF,
    PVOID BaseAddress,
    BOOL  fCheckBeginEndRange
    );

VOID
ElfpCleanUp (
    ULONG EventFlags
    );

NTSTATUS
ElfpCopyFile (
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING TargetFileName
    );

VOID
FreeModuleAndLogFileStructs (VOID);

NTSTATUS
ElfpFlushFiles (VOID);


VOID
InvalidateContextHandlesForLogFile (
    PLOGFILE    pLogFile
    );

VOID
FixContextHandlesForRecord (
    DWORD RecordOffset,
    DWORD NewRecordOffset
    );

PLOGFILE
FindLogFileFromName (
    PUNICODE_STRING LogFileName
    );

BOOL
SendAdminAlert (
    ULONG   MessageID,
    ULONG   NumStrings,
    UNICODE_STRING  *pStrings
    );

PVOID
NextRecordPosition (
    ULONG   ReadFlags,
    PVOID   CurrPosition,
    ULONG   CurrRecordLength,
    PVOID   BeginRecord,
    PVOID   EndRecord,
    PVOID   PhysicalEOF,
    PVOID   PhysStart
    );

VOID
NotifyChange (
    PLOGFILE pLogFile
    );

VOID
WriteQueuedEvents (
    VOID
    );

VOID
FlushQueuedEvents (
    VOID
    );

VOID
PerformWriteRequest (
    PELF_REQUEST_RECORD Request
    );

NTSTATUS
ElfpCreateLogFileObject(
    PLOGFILE LogFile,
    DWORD Type,
    ULONG GuestAccessRestriction
    );

VOID
ElfpDeleteLogFileObject(
    PLOGFILE LogFile
    );

VOID
ElfpCloseAudit(
    IN  LPWSTR      SubsystemName,
    IN  IELF_HANDLE ContextHandle
    );

NTSTATUS
ElfpAccessCheckAndAudit(
    IN     LPWSTR SubsystemName,
    IN     LPWSTR ObjectTypeName,
    IN     LPWSTR ObjectName,
    IN OUT IELF_HANDLE ContextHandle,
    IN     PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN     ACCESS_MASK DesiredAccess,
    IN     PGENERIC_MAPPING GenericMapping,
    IN     BOOL ForSecurityLog
    );

NTSTATUS
ElfCreateWellKnownSids(
    VOID
    );

VOID
ElfFreeWellKnownSids(
    VOID
    );

NTSTATUS
ElfCreateAndSetSD(
    IN  PRTL_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

NTSTATUS
ElfCreateUserSecurityObject(
    IN  PRTL_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  BOOLEAN IsDirectoryObject,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

VOID
ElfpCreateElfEvent(
    IN ULONG EventId,
    IN USHORT EventType,
    IN USHORT EventCategory,
    IN USHORT NumStrings,
    IN LPWSTR * Strings,
    IN LPVOID Data,
    IN ULONG DataSize,
    IN USHORT Flags,
    IN BOOL ForSecurity
    );


VOID
ElfpCreateQueuedAlert(
    DWORD MessageId,
    DWORD NumberOfStrings,
    LPWSTR Strings[]
    );

VOID
ElfpCreateQueuedMessage(
    DWORD MessageId,
    DWORD NumberOfStrings,
    LPWSTR Strings[]
    );

NTSTATUS
ElfpInitCriticalSection(
    PRTL_CRITICAL_SECTION  pCritsec
    );

NTSTATUS
ElfpInitResource(
    PRTL_RESOURCE  pResource
    );

DWORD
ElfStatusUpdate(
    IN DWORD    NewState
    );

DWORD
GetElState (
    VOID
    );

VOID
ElfpGenerateLogClearedEvent(
    IELF_HANDLE     LogHandle
    );

NTSTATUS
ElfpInitStatus(
    VOID
    );

VOID
ElCleanupStatus(
    VOID
    );

DWORD
ElfBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    ExitCode,
    IN DWORD    ServiceSpecificCode
    );

NTSTATUS
ElfpTestClientPrivilege(
    IN ULONG  ulPrivilege,
    IN HANDLE hThreadToken     OPTIONAL
    );

//SS: added to extend clustering support
NTSTATUS
FindSizeofEventsSinceStart (
    OUT PULONG               pulTotalEventSize,
    IN PULONG                pulNumLogFiles,
    OUT PPROPLOGFILEINFO     *ppPropLogFileInfo
    );    
    
NTSTATUS
GetEventsToProp(
    IN PEVENTLOGRECORD       pEventLogRecords,
    IN PPROPLOGFILEINFO      pPropLogFileInfo
    );

NTSTATUS
ElfCheckForComputerNameChange(
    );

NTSTATUS
ElfpReplicateEvent(
    IN PLOGMODULE   pLogModule,
    IN PVOID        pEventBuffer,
    IN DWORD        dwRecordLength
);

//SS: end of changes for clustering

VOID
ElfWriteTimeStamp(
    TIMESTAMPEVENT  EventType,
    BOOLEAN         Append
    );

VOID CALLBACK
ElfWriteLastAliveTimeStamp(
    UINT    uID,
    UINT    uMsg,
    DWORD   dwUser,
    DWORD   dw1,
    DWORD   dw2
    );

NTSTATUS
FlushLogFile(
    PLOGFILE    pLogFile
    );

#endif // ifndef _ELFPROTO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfrpc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ELFRPC.C

Abstract:

    This file contains the routines that handle the RPC calls to the
    Eventlog service via the Elf APIs.

Author:

    Rajen Shah  (rajens)    16-Jul-1991

Revision History:

    15-Feb-1995     MarkBl
        Unlink the ElfHandle *prior* to unlinking the module. Otherwise,
        if another thread happens to coincidentally be in the routine
        FindModuleStrucFromAtom, it's not going to get a hit for the
        module atom.

    18-May-1994     Danl
        IELF_HANDLE_rundown:  If the eventlog has been shutdown, then
        we want to skip the code in this routine because most of the
        resources will have been free'd.

    31-Jan-1994     Danl
        IELF_HANDLE_rundown: Notifiee structure was being free'd and then
        referenced when it's handle was removed from the list.  Now this
        is fixed so it advances to the next Notifiee in the list BEFORE the
        buffer is free'd.

--*/

//
// INCLUDES
//

#include <eventp.h>

extern DWORD  ElState;


VOID
IELF_HANDLE_rundown(
    IELF_HANDLE    ElfHandle
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle and to free any allocated data.  It also does all
    the work for ElfrCloseEL.

    It has to undo whatever was done in ElfrOpenEventLog in terms of
    allocating memory.

Arguments:

    None.

Return Value:

--*/

{
    PLOGMODULE pModule;
    NTSTATUS Status;
    PNOTIFIEE Notifiee;
    PNOTIFIEE NotifieeToDelete;

    //
    // Generate an Audit if neccessary
    //
    ElfpCloseAudit(L"EventLog", ElfHandle);

    //
    // If the eventlog service is stopped or in the process of
    // stopping, then we just want to ignore this rundown and return.
    //
    // Note, we don't bother calling GetElState() because that uses
    // a critical section which may not exist anymore as the
    // eventlog service has been shutdown.
    //
    // The eventlog isn't designed to be shutdown (except when the
    // system is shutdown), so it isn't real good at cleaning up
    // its resources.
    //
    if (ElState == STOPPING || ElState == STOPPED)
    {
        ELF_LOG1(HANDLE,
                 "IELF_HANDLE_rundown: Skipping rundown since ElState is %ws\n",
                 (ElState == STOPPING ? L"STOPPING" :
                                        L"STOPPED"));

        return;
    }

    ELF_LOG1(HANDLE,
             "IELF_HANDLE_rundown: Run down context handle %#x\n",
             ElfHandle);

    if (ElfHandle->Signature != ELF_CONTEXTHANDLE_SIGN)
    {
        ELF_LOG0(ERROR,
                 "IELF_HANDLE_rundown: Invalid context handle in rundown routine\n");

        return;
    }

    pModule = FindModuleStrucFromAtom(ElfHandle->Atom);

    //
    // This shouldn't ever happen.  It means that a handle got created
    // and its module went away without the handle getting closed.
    //
    if (!pModule)
    {
        ELF_LOG1(ERROR,
                 "IELF_HANDLE_rundown: Could not find module for atom %d on close\n",
                 ElfHandle->Atom);

        return;
    }

    UnlinkContextHandle(ElfHandle);    // Unlink it from the linked list

    //
    // If this handle was for a backup module, then we need to
    // close the file and clean up the data structures.  The standard logs
    // (Application, Security, and System) are never freed.
    //
    if (ElfHandle->Flags & ELF_LOG_HANDLE_BACKUP_LOG)
    {
        ELF_LOG0(HANDLE,
                 "IELF_HANDLE_rundown: Handle was for a backup log\n");

        Status = ElfpCloseLogFile(pModule->LogFile, ELF_LOG_CLOSE_BACKUP);

        UnlinkLogModule(pModule);
        DeleteAtom(pModule->ModuleAtom);
        ElfpFreeBuffer(pModule->ModuleName);

        //
        // ElfpCloseLogFile decrements the RefCount.
        //
        if (pModule->LogFile->RefCount == 0)
        {
            ELF_LOG1(HANDLE,
                     "IELF_HANDLE_rundown: RefCount for LogFile %ws is 0 -- unlinking\n",
                     pModule->LogFile->LogFileName->Buffer);

            UnlinkLogFile(pModule->LogFile);
            RtlDeleteResource ( &pModule->LogFile->Resource );
            RtlDeleteSecurityObject(&pModule->LogFile->Sd);

            ElfpFreeBuffer(pModule->LogFile->LogFileName);
            ElfpFreeBuffer(pModule->LogFile->LogModuleName);
            ElfpFreeBuffer(pModule->LogFile);
        }

        ElfpFreeBuffer(pModule);
    }
    else
    {
        ELF_LOG0(HANDLE,
                 "IELF_HANDLE_rundown: Handle was not for a backup log\n");

        //
        // See if this handle had an ElfChangeNotify outstanding and if so,
        // remove it from the list.  ElfChangeNotify can't be called with a
        // handle to a backup file.
        //

        //
        // Get exclusive access to the log file. This will ensure no one
        // else is accessing the file.
        //
        RtlAcquireResourceExclusive(&pModule->LogFile->Resource,
                                    TRUE);                  // Wait until available

        //
        // Walk the linked list and remove any entries for this handle
        //
        Notifiee = CONTAINING_RECORD(pModule->LogFile->Notifiees.Flink,
                                     struct _NOTIFIEE,
                                     Next);

        while (Notifiee->Next.Flink != pModule->LogFile->Notifiees.Flink)
        {
            //
            // If it's for this handle, remove it from the list
            //
            if (Notifiee->Handle == ElfHandle)
            {
                ELF_LOG0(HANDLE,
                         "IELF_HANDLE_rundown: Deleting a ChangeNotify request for handle\n");

                RemoveEntryList(&Notifiee->Next);
                NtClose(Notifiee->Event);
                NotifieeToDelete = Notifiee;

                Notifiee = CONTAINING_RECORD(Notifiee->Next.Flink,
                                             struct _NOTIFIEE,
                                             Next);

                ElfpFreeBuffer(NotifieeToDelete);
            }
            else
            {
                Notifiee = CONTAINING_RECORD(Notifiee->Next.Flink,
                                             struct _NOTIFIEE,
                                             Next);
            }
        }

        //
        // Free the resource
        //
        RtlReleaseResource ( &pModule->LogFile->Resource );
    }

    ElfpFreeBuffer(ElfHandle);    // Free the context-handle structure

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfsec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    elfsec.c


Author:

    Dan Hinsley (danhi)     28-Mar-1992

Environment:

    Calls NT native APIs.

Revision History:

    27-Oct-1993     danl
        Make Eventlog service a DLL and attach it to services.exe.
        Removed functions that create well-known SIDs.  This information
        is now passed into the Elfmain as a Global data structure containing
        all well-known SIDs.

    28-Mar-1992     danhi
        created - based on scsec.c in svcctrl by ritaw

    03-Mar-1995     markbl
        Added guest & anonymous logon log access restriction feature.

    18-Mar-2001     a-jyotig
        Added clean up code to ElfpAccessCheckAndAudit to reset the 
		g_lNumSecurityWriters to 0 in case of any error 
--*/

#include <eventp.h>
#include <elfcfg.h>
#include <Psapi.h>
#define PRIVILEGE_BUF_SIZE  512

extern long    g_lNumSecurityWriters;
BOOL g_bGetClientProc = FALSE;

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

NTSTATUS
ElfpGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );

NTSTATUS
ElfpReleasePrivilege(
    VOID
    );

//-------------------------------------------------------------------//
//                                                                   //
// Structure that describes the mapping of generic access rights to  //
// object specific access rights for a LogFile object.               //
//                                                                   //
//-------------------------------------------------------------------//

static GENERIC_MAPPING LogFileObjectMapping = {

    STANDARD_RIGHTS_READ           |       // Generic read
        ELF_LOGFILE_READ,

    STANDARD_RIGHTS_WRITE          |       // Generic write
        ELF_LOGFILE_WRITE,

    STANDARD_RIGHTS_EXECUTE        |       // Generic execute
        ELF_LOGFILE_START          |
        ELF_LOGFILE_STOP           |
        ELF_LOGFILE_CONFIGURE,

    ELF_LOGFILE_ALL_ACCESS                 // Generic all
    };


//-------------------------------------------------------------------//
//                                                                   //
// Functions                                                         //
//                                                                   //
//-------------------------------------------------------------------//

NTSTATUS
ElfpCreateLogFileObject(
    PLOGFILE LogFile,
    DWORD Type,
    ULONG GuestAccessRestriction
    )

/*++

Routine Description:

    This function creates the security descriptor which represents
    an active log file.

Arguments:

    LogFile - pointer the the LOGFILE structure for this logfile

Return Value:


--*/
{
    NTSTATUS Status;
    DWORD NumberOfAcesToUse;

#define ELF_LOGFILE_OBJECT_ACES  12            // Number of ACEs in this DACL

    RTL_ACE_DATA AceData[ELF_LOGFILE_OBJECT_ACES] = {

        {ACCESS_DENIED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_ALL_ACCESS,               &AnonymousLogonSid},

        {ACCESS_DENIED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_ALL_ACCESS,               &(ElfGlobalData->AliasGuestsSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_ALL_ACCESS,               &(ElfGlobalData->LocalSystemSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ | ELF_LOGFILE_CLEAR, &(ElfGlobalData->AliasAdminsSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_BACKUP,                   &(ElfGlobalData->AliasBackupOpsSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ | ELF_LOGFILE_CLEAR, &(ElfGlobalData->AliasSystemOpsSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_READ,                     &(ElfGlobalData->WorldSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE,                    &(ElfGlobalData->AliasAdminsSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE,                    &(ElfGlobalData->LocalServiceSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE,                    &(ElfGlobalData->NetworkServiceSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE,                    &(ElfGlobalData->AliasSystemOpsSid)},

        {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
               ELF_LOGFILE_WRITE,                    &(ElfGlobalData->WorldSid)}
        };

    PRTL_ACE_DATA pAceData = NULL;

    //
    // NON_SECURE logfiles let anyone read/write to them, secure ones
    // only let admins/local system do this.  so for secure files we just
    // don't use the last ACE
    //
    // Adjust the ACL start based on the passed GuestAccessRestriction flag.
    // The first two aces deny all log access to guests and/or anonymous
    // logons. The flag, GuestAccessRestriction, indicates that these two
    // deny access aces should be applied. Note that the deny aces and the
    // GuestAccessRestriction flag are not applicable to the security log,
    // since users and anonymous logons, by default, do not have access.
    //

    switch (Type)
    {
        case ELF_LOGFILE_SECURITY:

            ELF_LOG0(TRACE,
                     "ElfpCreateLogFileObject: Creating security Logfile\n");

            pAceData = AceData + 2;         // Deny ACEs *not* applicable
            NumberOfAcesToUse = 3;
            break;

        case ELF_LOGFILE_SYSTEM:

            ELF_LOG1(TRACE,
                     "ElfpCreateLogFileObject: Creating System Logfile -- "
                         "Guest access = %d\n", GuestAccessRestriction);

            if (GuestAccessRestriction == ELF_GUEST_ACCESS_RESTRICTED)
            {
                pAceData = AceData;         // Deny ACEs *applicable*
                NumberOfAcesToUse = 10;
            }
            else
            {
                pAceData = AceData + 2;     // Deny ACEs *not* applicable
                NumberOfAcesToUse = 8;
            }
            break;

        case ELF_LOGFILE_APPLICATION:

            ELF_LOG1(TRACE,
                     "ElfpCreateLogFileObject: Creating Application Logfile -- "
                         "Guest access = %d\n", GuestAccessRestriction);

            if (GuestAccessRestriction == ELF_GUEST_ACCESS_RESTRICTED)
            {
                pAceData = AceData;         // Deny ACEs *applicable*
                NumberOfAcesToUse = 12;
            }
            else
            {
                pAceData = AceData + 2;     // Deny ACEs *not* applicable
                NumberOfAcesToUse = 10;
            }
            break;

        default:

            //
            // We got an unknown type -- this should never happen
            //
            ELF_LOG1(ERROR,
                     "ElfpCreateLogFileObject: Invalid Type %#x\n",
                     Type);

            ASSERT(FALSE);
            return STATUS_INVALID_LEVEL;
    }

    Status = RtlCreateUserSecurityObject(
                   pAceData,
                   NumberOfAcesToUse,
                   NULL,                        // Owner
                   NULL,                        // Group
                   TRUE,                        // IsDirectoryObject
                   &LogFileObjectMapping,
                   &LogFile->Sd);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpCreateLogFileObject: RtlCreateUserSecurityObject failed %#x\n",
                 Status);
    }

    return Status;
}



VOID
ElfpDeleteLogFileObject(
    PLOGFILE LogFile
    )

/*++

Routine Description:

    This function deletes the self-relative security descriptor which
    represents an eventlog logfile object.

Arguments:

    LogFile - pointer the the LOGFILE structure for this logfile

Return Value:

    None.

--*/
{
    RtlDeleteSecurityObject(&LogFile->Sd);
}


NTSTATUS
ElfpVerifyThatCallerIsLSASS(
    )
/*++

Routine Description:

    This is called if the someone is trying to register themselves as an
    event source for the security log.  Only local copy of lsass.exe is 
    allowed to do that.

Return Value:

    NT status mapped to Win32 errors.

--*/
{
    UINT            LocalFlag;
    long            lCnt;
    ULONG           pid;
    HANDLE          hProcess;
    DWORD           dwNumChar;
    WCHAR           wModulePath[MAX_PATH + 1];
    WCHAR           wLsassPath[MAX_PATH + 1];
    RPC_STATUS      RpcStatus;

    // first of all, only local calls are valid

    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: I_RpcBindingIsClientLocal failed %d\n",
                 RpcStatus);
        return I_RpcMapWin32Status(RpcStatus);
    }
    if(LocalFlag == 0)
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: Non local connect tried to get write access to security %d\n", 5);
        return E_ACCESSDENIED;             // access denied
    }

    // Get the process id

    RpcStatus = I_RpcBindingInqLocalClientPID(NULL, &pid );
    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: I_RpcBindingInqLocalClientPID failed %d\n",
                 RpcStatus);
        return I_RpcMapWin32Status(RpcStatus);
    }

    // Get the process

    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if(hProcess == NULL)
        return E_ACCESSDENIED;

    // Get the module name of whoever is calling us.

    dwNumChar = GetModuleFileNameExW(hProcess, NULL, wModulePath, MAX_PATH);
    CloseHandle(hProcess);
    if(dwNumChar == 0)
        return E_ACCESSDENIED;

    dwNumChar = GetWindowsDirectoryW(wLsassPath, MAX_PATH);
    if(dwNumChar == 0)
        return GetLastError();
    if(dwNumChar > MAX_PATH - 19)
        return E_ACCESSDENIED;                   // should never happen

    lstrcatW(wLsassPath, L"\\system32\\lsass.exe");
    if(lstrcmpiW(wLsassPath, wModulePath))
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: Non lsass process connect tried to get write access to security, returning %d\n", 5);
        return E_ACCESSDENIED;             // access denied
    }

    // One last check is to make sure that this access is granted only once

    lCnt = InterlockedIncrement(&g_lNumSecurityWriters);
    if(lCnt == 1)
        return 0;               // all is well!
    else
    {
        InterlockedDecrement(&g_lNumSecurityWriters);
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: tried to get a second security write handle, returnin %d\n", 5);
        return E_ACCESSDENIED;             // access denied

    }
}

void DumpClientProc()
/*++

Routine Description:

    This dumps the client's process id and is used for debugging purposes.

--*/
{
    ULONG           pid;
    RPC_STATUS      RpcStatus;

    // Get the process id

    RpcStatus = I_RpcBindingInqLocalClientPID(NULL, &pid );
    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "DumpClientProc: I_RpcBindingInqLocalClientPID failed %d\n",
                 RpcStatus);
        return;
    }
    else
        ELF_LOG1(TRACE, "DumpClientProc: The client proc is %d\n", pid);
    return;
}

NTSTATUS
ElfpAccessCheckAndAudit(
    IN     LPWSTR SubsystemName,
    IN     LPWSTR ObjectTypeName,
    IN     LPWSTR ObjectName,
    IN OUT IELF_HANDLE ContextHandle,
    IN     PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN     ACCESS_MASK DesiredAccess,
    IN     PGENERIC_MAPPING GenericMapping,
    IN     BOOL ForSecurityLog
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    ObjectName - Supplies the name of the object being accessed.

    ContextHandle - Supplies the context handle to the object.  On return, the
        granted access is written to the AccessGranted field of this structure
        if this call succeeds.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ForSecurityLog - TRUE if the access check is for the security log.
        This is a special case that may require a privilege check.

Return Value:

    NT status mapped to Win32 errors.

--*/
{
    NTSTATUS   Status;
    RPC_STATUS RpcStatus;

    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;

    BOOLEAN         GenerateOnClose = FALSE;
    NTSTATUS        AccessStatus;
    ACCESS_MASK     GrantedAccess = 0;
    HANDLE          ClientToken = NULL;
    PRIVILEGE_SET   PrivilegeSet;
    ULONG           PrivilegeSetLength = sizeof(PRIVILEGE_SET);
    ULONG           privileges[1];


    GenericMapping = &LogFileObjectMapping;

    RtlInitUnicodeString(&Subsystem, SubsystemName);
    RtlInitUnicodeString(&ObjectType, ObjectTypeName);
    RtlInitUnicodeString(&Object, ObjectName);

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: RpcImpersonateClient failed %d\n",
                 RpcStatus);

        return I_RpcMapWin32Status(RpcStatus);
    }

    // if the client is asking to write to the security log, make sure it is lsass.exe and no one
    // else.

    if(ForSecurityLog && (DesiredAccess & ELF_LOGFILE_WRITE))
    {
        Status = ElfpVerifyThatCallerIsLSASS();
        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfpVerifyThatCallerIsLSASS failed %#x\n",
                     Status);
            goto CleanExit;
        }
    }
    else if(g_bGetClientProc)
        DumpClientProc();

    //
    // Get a token handle for the client
    //
    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_QUERY,        // DesiredAccess
                               TRUE,               // OpenAsSelf
                               &ClientToken);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: NtOpenThreadToken failed %#x\n",
                 Status);

        goto CleanExit;
    }

    //
    // We want to see if we can get the desired access, and if we do
    // then we also want all our other accesses granted.
    // MAXIMUM_ALLOWED gives us this.
    //
    DesiredAccess |= MAXIMUM_ALLOWED;

    //
    // Bug #57153 -- Make sure that the current user has the right to manage
    // the security log.  Without this check, the Eventlog will allow all
    // administrators to manage the log, even if they don't have the access.
    //
    if (ForSecurityLog)
    {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    Status = NtAccessCheck(SecurityDescriptor,
                           ClientToken,
                           DesiredAccess,
                           GenericMapping,
                           &PrivilegeSet,
                           &PrivilegeSetLength,
                           &GrantedAccess,
                           &AccessStatus);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: NtAccessCheck failed %#x\n",
                 Status);

        goto CleanExit;
    }

    if (AccessStatus != STATUS_SUCCESS)
    {
        ELF_LOG1(TRACE,
                 "ElfpAccessCheckAndAudit: NtAccessCheck refused access -- status is %#x\n",
                 AccessStatus);

        //
        // MarkBl 1/30/95 : Modified this code a bit to give backup operators
        //                  the ability to open the security log for purposes
        //                  of backup.
        //
        if ((AccessStatus == STATUS_ACCESS_DENIED       || 
             AccessStatus == STATUS_PRIVILEGE_NOT_HELD) && 
            (ForSecurityLog)
           )
        {
            //
            // MarkBl 1/30/95 :  First, evalutate the existing code (performed
            //                   for read or clear access), since its
            //                   privilege check is more rigorous than mine.
            //
            Status = STATUS_ACCESS_DENIED;

            if (!(DesiredAccess & ELF_LOGFILE_WRITE))
            {
                //
                // If read or clear access to the security log is desired,
                // then we will see if this user passes the privilege check.
                //
                //
                // Do Privilege Check for SeSecurityPrivilege
                // (SE_SECURITY_NAME).
                //
                // MarkBl 1/30/95 : Modified code to fall through on error
                //                  instead of the jump to 'CleanExit'.
                //
                Status = ElfpTestClientPrivilege(SE_SECURITY_PRIVILEGE,
                                                 ClientToken);

                if (NT_SUCCESS(Status))
                {
                    GrantedAccess |= (ELF_LOGFILE_READ | ELF_LOGFILE_CLEAR);

                    ELF_LOG0(TRACE,
                             "ElfpAccessCheckAndAudit: ElfpTestClientPrivilege for "
                                 "SE_SECURITY_PRIVILEGE succeeded\n");
                }
                else
                {
                    ELF_LOG1(TRACE,
                             "ElfpAccessCheckAndAudit: ElfpTestClientPrivilege for "
                                 "SE_SECURITY_PRIVILEGE failed %#x\n",
                             Status);
                }
            }

            //
            // MarkBl 1/30/95 : Finally, my code. If this user has backup
            //                  privilege, let the open succeed.
            //
            if (!NT_SUCCESS(Status))
            {
                Status = ElfpTestClientPrivilege(SE_BACKUP_PRIVILEGE,
                                                 ClientToken);

                if (NT_SUCCESS(Status))
                {
                    ELF_LOG0(TRACE,
                             "ElfpAccessCheckAndAudit: ElfpTestClientPrivilege for "
                                 "SE_BACKUP_PRIVILEGE succeeded\n");

                    GrantedAccess |= ELF_LOGFILE_BACKUP;
                }
                else
                {
                    ELF_LOG1(ERROR,
                             "ElfpAccessCheckAndAudit: ElfpTestClientPrivilege for "
                                 "SE_BACKUP_PRIVILEGE failed %#x\n",
                             Status);
                    // special "fix" for wmi eventlog provider which is hard coded
                    // to look for a specific error code
                    
                    if(AccessStatus == STATUS_PRIVILEGE_NOT_HELD)
                        Status = AccessStatus;

                    goto CleanExit;
                }
            }

            // special "fix" for wmi eventlog provider which is hard coded
            // to look for a specific error code
            
            if(!NT_SUCCESS(Status) && AccessStatus == STATUS_PRIVILEGE_NOT_HELD)
                Status = AccessStatus;
        }
        else
        {
            Status = AccessStatus;
        }
    }


    //
    // Revert to Self
    //
    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: RpcRevertToSelf failed %d\n",
                 RpcStatus);

        //
        // We don't return the error status here because we don't want
        // to write over the other status that is being returned.
        //
    }

    //
    // Get SeAuditPrivilege so I can call NtOpenObjectAuditAlarm.
    // If any of this stuff fails, I don't want the status to overwrite the
    // status that I got back from the access and privilege checks.
    //
    privileges[0] = SE_AUDIT_PRIVILEGE;
    AccessStatus  = ElfpGetPrivilege(1, privileges);

    if (!NT_SUCCESS(AccessStatus))
    {
       ELF_LOG1(ERROR,
                "ElfpAccessCheckAndAudit: ElfpGetPrivilege (SE_AUDIT_PRIVILEGE) failed %#x\n",
                AccessStatus);
    }

    //
    // Call the Audit Alarm function.
    //
    AccessStatus = NtOpenObjectAuditAlarm(
                        &Subsystem,
                        (PVOID) &ContextHandle,
                        &ObjectType,
                        &Object,
                        SecurityDescriptor,
                        ClientToken,            // Handle ClientToken
                        DesiredAccess,
                        GrantedAccess,
                        &PrivilegeSet,          // PPRIVLEGE_SET
                        FALSE,                  // BOOLEAN ObjectCreation,
                        TRUE,                   // BOOLEAN AccessGranted,
                        &GenerateOnClose);

    if (!NT_SUCCESS(AccessStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: NtOpenObjectAuditAlarm failed %#x\n",
                 AccessStatus);
    }
    else
    {
        if (GenerateOnClose)
        {
            ContextHandle->Flags |= ELF_LOG_HANDLE_GENERATE_ON_CLOSE;
        }
    }

    //
    // Update the GrantedAccess in the context handle.
    //
    ContextHandle->GrantedAccess = GrantedAccess;

    NtClose(ClientToken);

    ElfpReleasePrivilege();

    return Status;

CleanExit:

    //
    // Revert to Self
    //
    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: RpcRevertToSelf (CleanExit) failed %d\n",
                 RpcStatus);

        //
        // We don't return the error status here because we don't want
        // to write over the other status that is being returned.
        //
    }

	// if we return failure status due to any reason, the log handle will not be given 
	// to the requesting process (lsass.exe). But we have already incremented g_lNumSecurityWriters
	// if g_lNumSecurityWriters > 0 then lsass will not be able to get the access next time.
	// So decrement g_lNumSecurityWriters if we have already incremented g_lNumSecurityWriters and
	// if we are returning failure

	if (!NT_SUCCESS(Status))
	{
		InterlockedExchange(&g_lNumSecurityWriters,0L);
	}

    if (ClientToken != NULL)
    {
        NtClose(ClientToken);
    }

    return Status;
}


VOID
ElfpCloseAudit(
    IN  LPWSTR      SubsystemName,
    IN  IELF_HANDLE ContextHandle
    )

/*++

Routine Description:

    If the GenerateOnClose flag in the ContextHandle is set, then this function
    calls NtCloseAuditAlarm in order to generate a close audit for this handle.

Arguments:

    ContextHandle - This is a pointer to an ELF_HANDLE structure.  This is the
        handle that is being closed.

Return Value:

    none.

--*/
{
    UNICODE_STRING  Subsystem;
    NTSTATUS        Status;
    NTSTATUS        AccessStatus;
    ULONG           privileges[1];

    RtlInitUnicodeString(&Subsystem, SubsystemName);

    if (ContextHandle->Flags & ELF_LOG_HANDLE_GENERATE_ON_CLOSE)
    {
        BOOLEAN     WasEnabled = FALSE;

        //
        // Get Audit Privilege
        //
        privileges[0] = SE_AUDIT_PRIVILEGE;
        AccessStatus = ElfpGetPrivilege(1, privileges);

        if (!NT_SUCCESS(AccessStatus))
        {
            ELF_LOG1(ERROR,
                     "ElfpCloseAudit: ElfpGetPrivilege (SE_AUDIT_PRIVILEGE) failed %#x\n",
                     AccessStatus);
        }

        //
        // Generate the Audit.
        //
        Status = NtCloseObjectAuditAlarm(&Subsystem,
                                         ContextHandle,
                                         TRUE);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfpCloseAudit: NtCloseObjectAuditAlarm failed %#x\n",
                     Status);
        }

        ContextHandle->Flags &= (~ELF_LOG_HANDLE_GENERATE_ON_CLOSE);

        ElfpReleasePrivilege();
    }

    return;
}


NTSTATUS
ElfpGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    )

/*++

Routine Description:

    This function alters the privilege level for the current thread.

    It does this by duplicating the token for the current thread, and then
    applying the new privileges to that new token, then the current thread
    impersonates with that new token.

    Privileges can be relinquished by calling ElfpReleasePrivilege().

Arguments:

    numPrivileges - This is a count of the number of privileges in the
        array of privileges.

    pulPrivileges - This is a pointer to the array of privileges that are
        desired.  This is an array of ULONGs.

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT 
	functions that are called.

--*/
{
    NTSTATUS                    ntStatus;
    HANDLE                      ourToken;
    HANDLE                      newToken;
    OBJECT_ATTRIBUTES           Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    ULONG                       returnLen;
    PTOKEN_PRIVILEGES           pTokenPrivilege = NULL;
    DWORD                       i;

    //
    // Initialize the Privileges Structure
    //
    pTokenPrivilege =
        (PTOKEN_PRIVILEGES) ElfpAllocateBuffer(sizeof(TOKEN_PRIVILEGES)
                                                   + (sizeof(LUID_AND_ATTRIBUTES) *
                                                          numPrivileges));

    if (pTokenPrivilege == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpGetPrivilege: Unable to allocate memory for pTokenPrivilege\n");

        return STATUS_NO_MEMORY;
    }

    pTokenPrivilege->PrivilegeCount = numPrivileges;

    for (i = 0; i < numPrivileges; i++)
    {
        pTokenPrivilege->Privileges[i].Luid = RtlConvertLongToLuid(pulPrivileges[i]);
        pTokenPrivilege->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    //
    // Initialize Object Attribute Structure.
    //
    InitializeObjectAttributes(&Obja, NULL, 0L, NULL, NULL);

    //
    // Initialize Security Quality Of Service Structure
    //
    SecurityQofS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQofS.ImpersonationLevel = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;

    Obja.SecurityQualityOfService = &SecurityQofS;

    //
    // Open our own Token
    //
    ntStatus = NtOpenProcessToken(NtCurrentProcess(),
                                  TOKEN_DUPLICATE,
                                  &ourToken);

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpGetPrivilege: NtOpenProcessToken failed %#x\n",
                 ntStatus);

        ElfpFreeBuffer(pTokenPrivilege);
        return ntStatus;
    }

    //
    // Duplicate that Token
    //
    ntStatus = NtDuplicateToken(
                ourToken,
                TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &Obja,
                FALSE,                  // Duplicate the entire token
                TokenImpersonation,     // TokenType
                &newToken);             // Duplicate token

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpGetPrivilege: NtDuplicateToken failed %#x\n",
                 ntStatus);

        ElfpFreeBuffer(pTokenPrivilege);
        NtClose(ourToken);
        return ntStatus;
    }

    //
    // Add new privileges
    //
    ntStatus = NtAdjustPrivilegesToken(
                newToken,                   // TokenHandle
                FALSE,                      // DisableAllPrivileges
                pTokenPrivilege,            // NewState
                0,                          // size of previous state buffer
                NULL,                       // no previous state info
                &returnLen);                // numBytes required for buffer.

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpGetPrivilege: NtAdjustPrivilegesToken failed %#x\n",
                 ntStatus);

        ElfpFreeBuffer(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return ntStatus;
    }

    //
    // Begin impersonating with the new token
    //
    ntStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      (PVOID) &newToken,
                                      (ULONG) sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpGetPrivilege: NtAdjustPrivilegeToken failed %#x\n",
                 ntStatus);

        ElfpFreeBuffer(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return ntStatus;
    }

    ElfpFreeBuffer(pTokenPrivilege);
    NtClose(ourToken);
    NtClose(newToken);

    return STATUS_SUCCESS;
}



NTSTATUS
ElfpReleasePrivilege(
    VOID
    )

/*++

Routine Description:

    This function relinquishes privileges obtained by calling ElfpGetPrivilege().

Arguments:

    none

Return Value:

    STATUS_SUCCESS - If the operation was completely successful.

    Otherwise, it returns the error that occurred.

--*/
{
    NTSTATUS    ntStatus;
    HANDLE      NewToken;


    //
    // Revert To Self.
    //
    NewToken = NULL;

    ntStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      &NewToken,
                                      (ULONG) sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpReleasePrivilege: NtSetInformation thread failed %#x\n",
                 ntStatus);

        return ntStatus;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ElfpTestClientPrivilege(
    IN ULONG  ulPrivilege,
    IN HANDLE hThreadToken     OPTIONAL
    )

/*++

Routine Description:

    Checks if the client has the supplied privilege.

Arguments:

    None

Return Value:

    STATUS_SUCCESS - if the client has the appropriate privilege.

    STATUS_ACCESS_DENIED - client does not have the required privilege

--*/
{
    NTSTATUS      Status;
    PRIVILEGE_SET PrivilegeSet;
    BOOLEAN       Privileged;
    HANDLE        Token;
    RPC_STATUS    RpcStatus;

    UNICODE_STRING SubSystemName;
    RtlInitUnicodeString(&SubSystemName, L"Eventlog");

    if (hThreadToken != NULL)
    {
        Token = hThreadToken;
    }
    else
    {
        RpcStatus = RpcImpersonateClient(NULL);

        if (RpcStatus != RPC_S_OK)
        {
            ELF_LOG1(ERROR,
                     "ElfpTestClientPrivilege: RpcImpersonateClient failed %d\n",
                     RpcStatus);

            return I_RpcMapWin32Status(RpcStatus);
        }

        Status = NtOpenThreadToken(NtCurrentThread(),
                                   TOKEN_QUERY,
                                   TRUE,
                                   &Token);

        if (!NT_SUCCESS(Status))
        {
            //
            // Forget it.
            //
            ELF_LOG1(ERROR,
                     "ElfpTestClientPrivilege: NtOpenThreadToken failed %#x\n",
                     Status);

            RpcRevertToSelf();

            return Status;
        }
    }

    //
    // See if the client has the required privilege
    //
    PrivilegeSet.PrivilegeCount          = 1;
    PrivilegeSet.Control                 = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid       = RtlConvertLongToLuid(ulPrivilege);
    PrivilegeSet.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    Status = NtPrivilegeCheck(Token,
                              &PrivilegeSet,
                              &Privileged);

    if (NT_SUCCESS(Status) || (Status == STATUS_PRIVILEGE_NOT_HELD))
    {
        Status = NtPrivilegeObjectAuditAlarm(
                                    &SubSystemName,
                                    NULL,
                                    Token,
                                    0,
                                    &PrivilegeSet,
                                    Privileged);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfpTestClientPrivilege: NtPrivilegeObjectAuditAlarm failed %#x\n",
                     Status);
        }
    }
    else
    {
        ELF_LOG1(ERROR,
                 "ElfpTestClientPrivilege: NtPrivilegeCheck failed %#x\n",
                 Status);
    }

    if (hThreadToken == NULL )
    {
        //
        // We impersonated inside of this function
        //
        NtClose(Token);
        RpcRevertToSelf();
    }

    //
    // Handle unexpected errors
    //

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpTestClientPrivilege: Failed %#x\n",
                 Status);

        return Status;
    }

    //
    // If they failed the privilege check, return an error
    //

    if (!Privileged)
    {
        ELF_LOG0(ERROR,
                 "ElfpTestClientPrivilege: Client failed privilege check\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // They passed muster
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elflpc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    elflpc.c

Abstract:

    This file contains the routines that deal with the LPC port in the
    eventlog service.

Author:

    Rajen Shah  (rajens)    10-Jul-1991

Revision History:



--*/

//
// INCLUDES
//

#include <eventp.h>
#include <ntiolog.h>    // For IO_ERROR_LOG_[MESSAGE/PACKET]
#include <ntiologc.h>   // QUOTA error codes
#include <elfkrnl.h>
#include <stdlib.h>
#include <memory.h>
#include <elfextrn.h>   // Computername

#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <ntdef.h>
#include <ntstatus.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <lmcons.h>
#include <string.h>
#include <lmerr.h>
#include <elfmsg.h>


//
//  Global value for the "system" module
//

PLOGMODULE SystemModule = NULL;

NTSTATUS
SetUpLPCPort(
    VOID
    )

/*++

Routine Description:

    This routine sets up the LPC port for the service.

Arguments:

    None

Return Value:

--*/
{
    NTSTATUS status;
    UNICODE_STRING SystemString;
    UNICODE_STRING unicodePortName;
    OBJECT_ATTRIBUTES objectAttributes;
    PORT_MESSAGE connectionRequest;

    ELF_LOG0(LPC,
             "SetUpLPCPort: Enter\n");

    //
    // We're going to need this every time, so just get it once
    //
    ASSERT(SystemModule == NULL);

    //
    // Get the system module to log driver events
    //
    RtlInitUnicodeString(&SystemString, ELF_SYSTEM_MODULE_NAME);
    SystemModule = GetModuleStruc(&SystemString);

    //
    // The System log and its default module should have been created by now.
    //
    ASSERT(_wcsicmp(SystemModule->ModuleName, ELF_SYSTEM_MODULE_NAME) == 0);

    //
    // Initialize the handles to zero so that we can determine what to do
    // if we need to clean up.
    //
    ElfConnectionPortHandle = NULL;
    ElfCommunicationPortHandle = NULL;

    //
    // Create the LPC port.
    //
    RtlInitUnicodeString( &unicodePortName, ELF_PORT_NAME_U );

    InitializeObjectAttributes(
            &objectAttributes,
            &unicodePortName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    status = NtCreatePort(&ElfConnectionPortHandle,
                          &objectAttributes,
                          0,
                          ELF_PORT_MAX_MESSAGE_LENGTH,
                          ELF_PORT_MAX_MESSAGE_LENGTH * 32);

    if (!NT_SUCCESS(status))
    {
        ELF_LOG2(ERROR,
                 "SetUpLPCPort: Error creating LPC port %ws %#x\n",
                 ELF_PORT_NAME_U,
                 status);
    }

    ELF_LOG1(LPC,
             "SetUpLPCPort: Exiting with status %#x\n",
             status);

    return status;
}



LPWSTR
ElfpCopyString(
    LPWSTR Destination,
    LPWSTR Source,
    ULONG Length
    )

/*++

Routine Description:

    Copies a string to the destination.  Correctly NUL terminates
    the string.


Arguments:

    Destination - place where string is to be copied
    
    Source - string that may or may not be NUL terminated
    
    Length - length in bytes of string being copied.  May include NUL

Return Value:

    LPWSTR to first WCHAR past NUL

--*/
{
    //
    //  Copy the data
    //
    RtlMoveMemory(Destination, Source, Length);

    //
    //  Make sure it's NULL terminated
    //
    if (Length != 0)
    {
        Destination += Length / sizeof(WCHAR) - 1;

        if (*Destination != L'\0')
        {
            Destination++;
            *Destination = L'\0';
        }
    }
    else
    {
        *Destination = L'0';
    }

    return Destination + 1;
}


NTSTATUS
ElfProcessIoLPCPacket( 
    ULONG                 PacketLength,
    PIO_ERROR_LOG_MESSAGE pIoErrorLogMessage
    )

/*++

Routine Description:

    This routine takes the packet received from the LPC port and processes it.
    The logfile will be system, the module name will be the driver that 
    generated the packet, the SID will always be NULL and
    there will always be one string, which will be the device name.

    It extracts the information from the LPC packet, and then calls the
    common routine to do the work of formatting the data into
    an event record and writing it out to the log file.


Arguments:

    pIoErrorLogMessage - Pointer to the data portion of the packet just
                         received through the LPC port.


Return Value:

    Status of this operation.

--*/

{
    NTSTATUS status;
    ELF_REQUEST_RECORD  Request;
    WRITE_PKT WritePkt;

    ULONG RecordLength;
    PEVENTLOGRECORD EventLogRecord;
    LPWSTR DestinationString, SourceString;
    PBYTE BinaryData;
    ULONG PadSize;
    LARGE_INTEGER Time;
    ULONG TimeWritten;
    PULONG pEndLength;
    ULONG i = 0;
    PWCHAR pwch;
    PWCHAR pwStart;
    PWCHAR pwEnd;
    ULONG StringLength;
	WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	ULONG  ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
	BOOL bOK;
    PacketLength = min(pIoErrorLogMessage->Size, PacketLength);

    try
    {
        // Get the computer name

    	bOK = GetComputerNameW(LocalComputerName, &ComputerNameLength);
		if(bOK == FALSE)
		{
            ELF_LOG1(ERROR,
                 "ElfProcessIoLPCPacket: failed calling GetComputerNameW, last error 0x%x\n",
                  GetLastError());
            return STATUS_UNSUCCESSFUL;    
		}
    	ComputerNameLength = (ComputerNameLength+1)*sizeof(WCHAR); // account for the NULL
    	
        //
        // Validate the packet, First make sure there are the correct
        // number of NULL terminated strings, and remember the
        // total number of bytes to copy
        //
        pwStart = pwch = (PWCHAR) ((PBYTE) pIoErrorLogMessage +
                                       pIoErrorLogMessage->EntryData.StringOffset);

        pwEnd = (PWCHAR) ((PBYTE) pIoErrorLogMessage + PacketLength);

        while (pwch < pwEnd
                &&
               i < pIoErrorLogMessage->EntryData.NumberOfStrings)
        {
                if (*pwch == L'\0')
                {
                    i++;
                }

                pwch++;
        }

        StringLength = (ULONG) (pwch - pwStart) * sizeof(WCHAR);

        //
        // Now make sure everything in the packet is true
        //

        if ((i != pIoErrorLogMessage->EntryData.NumberOfStrings)
              ||
            (pIoErrorLogMessage->DriverNameOffset 
                 + pIoErrorLogMessage->DriverNameLength >= PacketLength)
              ||
            (pIoErrorLogMessage->EntryData.StringOffset >= PacketLength)
              ||
            (FIELD_OFFSET(IO_ERROR_LOG_MESSAGE, EntryData) 
                 + FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) 
                 + (ULONG) pIoErrorLogMessage->EntryData.DumpDataSize >= PacketLength))
        {    
            //
            // It's a bad packet, log it and return
            //
            ELF_LOG0(ERROR,
                     "ElfProcessIoLPCPacket: Bad LPC packet -- dumping it to System log\n");

            ElfpCreateElfEvent(EVENT_BadDriverPacket,
                               EVENTLOG_ERROR_TYPE,
                               0,                    // EventCategory
                               0,                    // NumberOfStrings
                               NULL,                 // Strings
                               pIoErrorLogMessage,   // Data
                               PacketLength,         // Datalength
                               0,
                               FALSE);                   // flags

            return STATUS_UNSUCCESSFUL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // It's a bad packet, log it and return
        //
        ELF_LOG1(ERROR,
                 "ElfProcessIoLPCPacket: Exception %#x caught processing I/O LPC packet\n",
                 GetExceptionCode());

        ElfpCreateElfEvent(EVENT_BadDriverPacket,
                           EVENTLOG_ERROR_TYPE,
                           0,                    // EventCategory
                           0,                    // NumberOfStrings
                           NULL,                 // Strings
                           NULL,                 // Data
                           0,                    // Datalength
                           0,
                           FALSE);                   // flags

        return STATUS_UNSUCCESSFUL;
    }

    //
    // The packet should be an IO_ERROR_LOG_MESSAGE
    //
    ASSERT(pIoErrorLogMessage->Type == IO_TYPE_ERROR_MESSAGE);

    //
    // Set up write packet in request packet
    //
    Request.Pkt.WritePkt = &WritePkt;
    Request.Flags = 0;

    //
    // Generate any additional information needed in the record.
    //

    //
    // TIMEWRITTEN
    // We need to generate a time when the log is written. This
    // gets written in the log so that we can use it to test the
    // retention period when wrapping the file.
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(
                        &Time,
                        &TimeWritten
                        );

    //
    // Determine how big a buffer is needed for the eventlog record.
    //
    RecordLength = sizeof(EVENTLOGRECORD)
                       + ComputerNameLength                   // computer name
                       + 2 * sizeof(WCHAR)                    // terminating NULLs
                       + PacketLength
                       - FIELD_OFFSET(IO_ERROR_LOG_MESSAGE, EntryData)
                       + sizeof(RecordLength);                // final len

    //
    // Determine how many pad bytes are needed to align to a DWORD
    // boundary.
    //
    PadSize = sizeof(ULONG) - (RecordLength % sizeof(ULONG));

    RecordLength += PadSize;    // True size needed

    //
    // Allocate the buffer for the Eventlog record
    //
    EventLogRecord = (PEVENTLOGRECORD) ElfpAllocateBuffer(RecordLength);

    if (EventLogRecord != (PEVENTLOGRECORD) NULL)
    {
        //
        // Fill up the event record
        //
        EventLogRecord->Length = RecordLength;

        RtlTimeToSecondsSince1970(&pIoErrorLogMessage->TimeStamp,
                                  &EventLogRecord->TimeGenerated);

        EventLogRecord->Reserved    = ELF_LOG_FILE_SIGNATURE;
        EventLogRecord->TimeWritten = TimeWritten;
        EventLogRecord->EventID     = pIoErrorLogMessage->EntryData.ErrorCode;

        //
        // Set EventType based on the high order nibble of
        // pIoErrorLogMessage->EntryData.ErrorCode
        //
        if (NT_INFORMATION(pIoErrorLogMessage->EntryData.ErrorCode))
        {
            EventLogRecord->EventType = EVENTLOG_INFORMATION_TYPE;
        }
        else if (NT_WARNING(pIoErrorLogMessage->EntryData.ErrorCode))
        {
            EventLogRecord->EventType = EVENTLOG_WARNING_TYPE;
        }
        else if (NT_ERROR(pIoErrorLogMessage->EntryData.ErrorCode))
        {
            EventLogRecord->EventType = EVENTLOG_ERROR_TYPE;
        }
        else
        {
            //
            // Unknown, set to error
            //
            ELF_LOG1(LPC,
                     "ElfProcessIoLPCPacket: Unknown EventType (high nibble of ID %#x)\n",
                     EventLogRecord->EventID);

            EventLogRecord->EventType = EVENTLOG_ERROR_TYPE;
        }

        EventLogRecord->NumStrings    = pIoErrorLogMessage->EntryData.NumberOfStrings;
        EventLogRecord->EventCategory = pIoErrorLogMessage->EntryData.EventCategory;
        EventLogRecord->StringOffset  = sizeof(EVENTLOGRECORD)
                                            + pIoErrorLogMessage->DriverNameLength
                                            + ComputerNameLength;

        EventLogRecord->DataLength    = FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                                            + pIoErrorLogMessage->EntryData.DumpDataSize;

        EventLogRecord->DataOffset    = EventLogRecord->StringOffset + StringLength;

        //
        // Quota events contain a SID.
        //
        if (pIoErrorLogMessage->EntryData.ErrorCode == IO_FILE_QUOTA_LIMIT
             ||
            pIoErrorLogMessage->EntryData.ErrorCode == IO_FILE_QUOTA_THRESHOLD)
        {
            PFILE_QUOTA_INFORMATION pFileQuotaInformation =
                (PFILE_QUOTA_INFORMATION) pIoErrorLogMessage->EntryData.DumpData;

            ELF_LOG0(LPC,
                     "ElfProcessIoLPCPacket: Event is a Quota event\n");

            EventLogRecord->UserSidLength = pFileQuotaInformation->SidLength;
            EventLogRecord->UserSidOffset = EventLogRecord->DataOffset
                                                + FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                                                + FIELD_OFFSET(FILE_QUOTA_INFORMATION, Sid);

            EventLogRecord->DataLength    = EventLogRecord->UserSidOffset -
                                                EventLogRecord->DataOffset;
        }
        else
        {
            EventLogRecord->UserSidLength = 0;
            EventLogRecord->UserSidOffset = 0;
        }

        //
        // Fill in the variable-length fields
        //

        //
        // MODULENAME
        //
        // Use the driver name as the module name, since its location is
        // described by an offset from the start of the IO_ERROR_LOG_MESSAGE
        // turn it into a pointer
        //
        DestinationString = (LPWSTR) ((LPBYTE) EventLogRecord + sizeof(EVENTLOGRECORD));
        SourceString = (LPWSTR) ((LPBYTE) pIoErrorLogMessage
                                      + pIoErrorLogMessage->DriverNameOffset);

        DestinationString = ElfpCopyString(DestinationString,
                                           SourceString,
                                           pIoErrorLogMessage->DriverNameLength);

        //
        // COMPUTERNAME
        //
        DestinationString = ElfpCopyString(DestinationString,
                                           LocalComputerName,
                                           ComputerNameLength);

        //
        // STRINGS
        //
        DestinationString = ElfpCopyString(DestinationString, pwStart, StringLength);

        //
        // BINARY DATA
        //
        BinaryData = (LPBYTE) DestinationString;

        RtlMoveMemory(BinaryData, 
                      &pIoErrorLogMessage->EntryData,
                      FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) 
                          + pIoErrorLogMessage->EntryData.DumpDataSize);

        //
        // LENGTH at end of record
        //
        pEndLength = (PULONG) ((LPBYTE) EventLogRecord + RecordLength - sizeof(ULONG));
        *pEndLength = RecordLength;

        //
        // Set up request packet.
        // Link event log record into the request structure.
        //
        Request.Module  = SystemModule;
        Request.LogFile = Request.Module->LogFile;
        Request.Command = ELF_COMMAND_WRITE;

        Request.Pkt.WritePkt->Buffer   = (PVOID) EventLogRecord;
        Request.Pkt.WritePkt->Datasize = RecordLength;

        //
        // Perform the operation
        //
        ElfPerformRequest( &Request );

        //
        // Replicate the event if part of a cluster
        //
        ElfpReplicateEvent(SystemModule, EventLogRecord, RecordLength);

        //
        // Free up the buffer
        //
        ElfpFreeBuffer(EventLogRecord);

        status = Request.Status;                // Set status of WRITE
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfProcessIoLPCPacket: Unable to allocate memory for EventLogRecord\n");

        status = STATUS_NO_MEMORY;
    }

    return status;
}



NTSTATUS
ElfProcessSmLPCPacket(
    ULONG PacketLength,
    PSM_ERROR_LOG_MESSAGE SmErrorLogMessage
    )

/*++

Routine Description:

    This routine takes the packet received from the LPC port and processes it.
    The packet is an SM_ERROR_LOG_MESSAGE.  The logfile will be system, the 
    module name will be SMSS, the SID will always be NULL and
    there will always be one string, which will be the filename

    It extracts the information from the LPC packet, and then calls the
    common routine to do the work of formatting the data into
    an event record and writing it out to the log file.


Arguments:

    SmErrorLogMessage - Pointer to the data portion of the packet just
                        received through the LPC port.


Return Value:

    Status of this operation.

--*/

{
    NTSTATUS status;
    ELF_REQUEST_RECORD  Request;
    WRITE_PKT WritePkt;

    ULONG RecordLength;
    PEVENTLOGRECORD EventLogRecord;
    LPWSTR DestinationString, SourceString;
    PBYTE BinaryData;
    ULONG PadSize;
    LARGE_INTEGER Time;
    ULONG TimeWritten;
    PULONG pEndLength;
	WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	ULONG  ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
	BOOL bOK;

    try
    {
    	// Get the computer name

		bOK = GetComputerNameW(LocalComputerName, &ComputerNameLength);
		if(bOK == FALSE)
		{
        	ELF_LOG1(ERROR,
                 "ElfProcessIoLPCPacket: failed calling GetComputerNameW, last error 0x%x\n",
                  GetLastError());
            return STATUS_UNSUCCESSFUL;    
		}
    	ComputerNameLength = (ComputerNameLength+1)*sizeof(WCHAR);
        //
        //  Validate the packet.  
        //
        if (PacketLength < sizeof(SM_ERROR_LOG_MESSAGE) 

                ||
            
            // 
            //  Offset begins before header
            //
             
            SmErrorLogMessage->StringOffset < sizeof(*SmErrorLogMessage)
                
                ||

            //
            //  Offset begins after packet
            //

            SmErrorLogMessage->StringOffset >= PacketLength

                ||

            //
            //  Length of string longer than packet
            //

            SmErrorLogMessage->StringLength > PacketLength

                ||

            //
            //  String end after end of packet
            //

            SmErrorLogMessage->StringOffset
                + SmErrorLogMessage->StringLength > PacketLength

             )
        {
            RtlRaiseStatus(STATUS_UNSUCCESSFUL);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // It's a bad packet, log it and return
        //
        ELF_LOG1(ERROR,
                 "ElfProcessSmLPCPacket: Exception %#x caught processing SMSS LPC packet\n",
                 GetExceptionCode());

        ELF_LOG3(ERROR,
                 "SmErrorLogMessage->StringOffset %#x\n"
                     "\tPacketLength %#x\n"
                     "\tSmErrorLogMessage->StringLength %#x\n",
                 SmErrorLogMessage->StringOffset,
                 PacketLength,
                 SmErrorLogMessage->StringLength);

        ElfpCreateElfEvent(EVENT_BadDriverPacket,
                           EVENTLOG_ERROR_TYPE,
                           0,                    // EventCategory
                           0,                    // NumberOfStrings
                           NULL,                 // Strings
                           NULL,                 // Data
                           0,                    // Datalength
                           0,
                           FALSE);                   // flags

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set up write packet in request packet
    //
    Request.Pkt.WritePkt = &WritePkt;
    Request.Flags = 0;

    //
    // Generate any additional information needed in the record.
    //

    //
    //  Determine how big a buffer is needed for the eventlog record.  
    //  We overestimate string lengths rather than probing for 
    //  terminating NUL's
    //
    RecordLength = sizeof(EVENTLOGRECORD)
                       + sizeof(L"system")
                       + ComputerNameLength + sizeof(WCHAR)
                       + SmErrorLogMessage->StringLength + sizeof(WCHAR)
                       + sizeof(RecordLength);

    //
    //  Since the RecordLength at the end must be ULONG aligned, we round 
    //  up the total size to be ULONG aligned.
    //
    RecordLength += sizeof(ULONG) - (RecordLength % sizeof(ULONG));

    //
    // Allocate the buffer for the Eventlog record
    //
    EventLogRecord = (PEVENTLOGRECORD) ElfpAllocateBuffer(RecordLength);

    if (EventLogRecord == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfProcessSmLPCPacket: Unable to allocate memory for EventLogRecord\n");

        return STATUS_NO_MEMORY;
    }

    //
    // Fill up the event record
    //
    EventLogRecord->Length   = RecordLength;
    EventLogRecord->Reserved = ELF_LOG_FILE_SIGNATURE;

    RtlTimeToSecondsSince1970(&SmErrorLogMessage->TimeStamp,
                              &EventLogRecord->TimeGenerated);

    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time, &EventLogRecord->TimeWritten);
    EventLogRecord->EventID = SmErrorLogMessage->Status;

    //
    // set EventType based on the high order nibble of
    // the eventID
    //
    if (NT_INFORMATION(EventLogRecord->EventID))
    {
        EventLogRecord->EventType =  EVENTLOG_INFORMATION_TYPE;
    }
    else if (NT_WARNING(EventLogRecord->EventID))
    {
        EventLogRecord->EventType =  EVENTLOG_WARNING_TYPE;
    }
    else if (NT_ERROR(EventLogRecord->EventID))
    {
        EventLogRecord->EventType = EVENTLOG_ERROR_TYPE;
    }
    else
    {
        //
        // Unknown, set to error
        //
        ELF_LOG1(LPC,
                 "ElfProcessSmLPCPacket: Unknown EventType (high nibble of ID %#x)\n",
                 EventLogRecord->EventID);

        EventLogRecord->EventType = EVENTLOG_ERROR_TYPE;
    }

    //
    //  There is a single string;  it is the name of the file being 
    //  replaced
    //
    EventLogRecord->NumStrings    = 1;
    EventLogRecord->EventCategory = ELF_CATEGORY_SYSTEM_EVENT;

    //
    //  Nothing for ReservedFlags
    //  Nothing for ClosingRecordNumber
    //
    EventLogRecord->StringOffset = sizeof(EVENTLOGRECORD) 
                                       + sizeof( L"system" )
                                       + ComputerNameLength;

    //
    //  No SID's present
    //
    EventLogRecord->UserSidLength = 0;
    EventLogRecord->UserSidOffset = 0;
    EventLogRecord->DataLength    = 0;
    EventLogRecord->DataOffset    = 0;

    //
    // Fill in the variable-length fields
    //
    // MODULENAME
    //
    // SMSS
    //
    DestinationString = (LPWSTR) ((LPBYTE) EventLogRecord + sizeof(EVENTLOGRECORD));

    DestinationString = ElfpCopyString(DestinationString, 
                                       L"system", 
                                       sizeof(L"system"));

    //
    // COMPUTERNAME
    //
    DestinationString = ElfpCopyString(DestinationString,
                                       LocalComputerName,
                                       ComputerNameLength);

    //
    // STRING
    //
    SourceString = (LPWSTR) ((LPBYTE) SmErrorLogMessage + SmErrorLogMessage->StringOffset);

    ELF_LOG2(LPC,
             "ElfProcessSmLPCPacket: String is '%*ws'\n",
             SmErrorLogMessage->StringLength,
             SourceString);

    DestinationString = ElfpCopyString(DestinationString,
                                       SourceString,
                                       SmErrorLogMessage->StringLength);

    //
    // LENGTH at end of record
    //
    pEndLength = (PULONG) ((LPBYTE) EventLogRecord + RecordLength - sizeof(ULONG));
    *pEndLength = RecordLength;

    //
    // Set up request packet.
    // Link event log record into the request structure.
    //
    Request.Module  = SystemModule;
    Request.LogFile = Request.Module->LogFile;
    Request.Command = ELF_COMMAND_WRITE;

    Request.Pkt.WritePkt->Buffer   = (PVOID) EventLogRecord;
    Request.Pkt.WritePkt->Datasize = RecordLength;

    //
    // Perform the operation
    //
    ElfPerformRequest( &Request );


    //
    // Replicate the event if part of a cluster
    //
    ElfpReplicateEvent(SystemModule, EventLogRecord, RecordLength);

    //
    // Free up the buffer
    //
    ElfpFreeBuffer( EventLogRecord );

    return Request.Status;
}



NTSTATUS
ElfProcessLPCCalls(
    VOID
    )

/*++

Routine Description:

    This routine waits for messages to come through the LPC port to
    the system thread. When one does, it calls the appropriate routine to
    handle the API, then replies to the system thread indicating that the
    call has completed if the message was a request, if it was a datagram,
    it just waits for the next message.

Arguments:


Return Value:

--*/

{
    NTSTATUS status;

    BOOL SendReply = FALSE;

    ELF_REPLY_MESSAGE   replyMessage;
    PELF_PORT_MSG       receiveMessage;
    PHANDLE             PortConnectionHandle;

    //
    // Loop dispatching API requests.
    //
    receiveMessage = ElfpAllocateBuffer(ELF_PORT_MAX_MESSAGE_LENGTH + sizeof(PORT_MESSAGE));

    if (!receiveMessage)
    {
        ELF_LOG0(ERROR,
                 "ElfProcessLPCCalls: Unable to allocate memory for receiveMessage\n");

        return STATUS_NO_MEMORY;
    }

    while (TRUE)
    {
        //
        // On the first call to NtReplyWaitReceivePort, don't send a
        // reply since there's nobody to whom to reply.  However, on
        // subsequent calls send a reply to the message from the prior
        // time if that message wasn't an LPC_DATAGRAM.
        //
        status = NtReplyWaitReceivePort(
                                       ElfConnectionPortHandle,
                     (PVOID)           &PortConnectionHandle,
                     (PPORT_MESSAGE)   (SendReply ? &replyMessage : NULL),
                     (PPORT_MESSAGE)   receiveMessage
                 );

        if (!NT_SUCCESS(status))
        {
            ELF_LOG1(ERROR,
                     "ElfProcessLPCCalls: NtReplyWaitReceivePort failed %#x\n",
                     status);

            return status;
        }

        ELF_LOG0(LPC,
                 "ElfProcessLPCCalls: Received message\n");

        //
        // Take the record received and perform the operation.  Strip off
        // the PortMessage and just send the packet.
        //

        //
        // Set up the response message to be sent on the next call to
        // NtReplyWaitReceivePort if this wasn't a datagram.
        // 'status' contains the status to return from this call.
        // Only process messages that are LPC_REQUEST or LPC_DATAGRAM
        //
        if (receiveMessage->PortMessage.u2.s2.Type == LPC_REQUEST
             ||
            receiveMessage->PortMessage.u2.s2.Type == LPC_DATAGRAM)
        {
            ELF_LOG1(LPC,
                     "ElfProcessLPCCalls: LPC message type = %ws\n",
                     (receiveMessage->PortMessage.u2.s2.Type == LPC_REQUEST ? "LPC_REQUEST" :
                                                                              "LPC_DATAGRAM"));

            if (receiveMessage->MessageType == IO_ERROR_LOG)
            {
                ELF_LOG0(LPC,
                         "ElfProcessLPCCalls: SM_IO_LOG\n");

                status =  ElfProcessIoLPCPacket(receiveMessage->PortMessage.u1.s1.DataLength, 
                                                &receiveMessage->u.IoErrorLogMessage);
            }
            else if (receiveMessage->MessageType == SM_ERROR_LOG)
            {
                ELF_LOG0(LPC,
                         "ElfProcessLPCCalls: SM_ERROR_LOG\n");

                status = ElfProcessSmLPCPacket(receiveMessage->PortMessage.u1.s1.DataLength, 
                                               &receiveMessage->u.SmErrorLogMessage);
            }
            else
            {
                ELF_LOG1(ERROR,
                         "ElfProcessLPCCalls: Unknown MessageType %#x\n",
                         receiveMessage->MessageType);
                status = STATUS_UNSUCCESSFUL;
            }

            if (receiveMessage->PortMessage.u2.s2.Type == LPC_REQUEST)
            {
                replyMessage.PortMessage.u1.s1.DataLength  = sizeof(replyMessage)
                                                                 - sizeof(PORT_MESSAGE);

                replyMessage.PortMessage.u1.s1.TotalLength = sizeof(replyMessage);
                replyMessage.PortMessage.u2.ZeroInit       = 0;

                replyMessage.PortMessage.ClientId 
                    = receiveMessage->PortMessage.ClientId;

                replyMessage.PortMessage.MessageId 
                    = receiveMessage->PortMessage.MessageId;

                replyMessage.Status = status;
    
                SendReply = TRUE;
            }
            else
            {
                SendReply = FALSE;
            }
        }
        else if (receiveMessage->PortMessage.u2.s2.Type == LPC_CONNECTION_REQUEST)
        {
            PHANDLE pSavedHandle = NULL;
            BOOLEAN Accept       = TRUE;

            ELF_LOG0(LPC,
                     "ElfProcessLPCCalls: Processing connection request\n");

            pSavedHandle = ElfpAllocateBuffer(sizeof (HANDLE));

            if (pSavedHandle)
            {
                status = NtAcceptConnectPort(pSavedHandle,
                                             pSavedHandle,
                                             &receiveMessage->PortMessage,
                                             Accept,
                                             NULL,
                                             NULL);
            } else {

               ELF_LOG0(ERROR, "ElfProcessLPCCalls: Unable to allocate LPC handle\n");
               status = STATUS_NO_MEMORY;

            }

            if (!Accept)
            {
                if(pSavedHandle)
                {
                  ElfpFreeBuffer(pSavedHandle);
                  pSavedHandle = NULL;
                }

                continue;
            }

            if (NT_SUCCESS(status))
            {
                status = NtCompleteConnectPort(*pSavedHandle);

                if (!NT_SUCCESS(status))
                {
                    ELF_LOG1(ERROR,
                             "ElfProcessLPCCalls: NtAcceptConnectPort failed %#x\n",
                             status);

                    NtClose(*pSavedHandle);
                }
            }

            if (!NT_SUCCESS(status))
            {
                ELF_LOG1(ERROR,
                         "ElfProcessLPCCalls: Cleaning up failed connect\n", status);

                if(pSavedHandle)
                {
                  ElfpFreeBuffer(pSavedHandle);
                  pSavedHandle = NULL;
                }
            }
        }
        else if (receiveMessage->PortMessage.u2.s2.Type == LPC_PORT_CLOSED)
        {
            ELF_LOG0(LPC,
                     "ElfProcessLPCCalls: Processing port closed\n");

            ASSERT(PortConnectionHandle != NULL);

            NtClose(*PortConnectionHandle);
            ElfpFreeBuffer(PortConnectionHandle);


        }
        else
        {
            //
            // We received a message type we didn't expect, probably due to
            // error.
            //
            ELF_LOG1(ERROR,
                     "ElfProcessLPCCalls: Unknown message type %#x received on LPC port\n",
                     receiveMessage->PortMessage.u2.s2.Type);
        }
    }

} // ElfProcessLPCCalls



DWORD
MainLPCThread(
    LPVOID      LPCThreadParm
    )

/*++

Routine Description:

    This is the main thread that monitors the LPC port from the I/O system.
    It takes care of creating the LPC port, and waiting for input, which
    it then transforms into the right operation on the event log.


Arguments:

    NONE

Return Value:

    NONE

--*/

{
    NTSTATUS    Status;

    ELF_LOG0(LPC,
             "MainLPCThread: Inside LPC thread\n");

    Status = SetUpLPCPort();

    if (NT_SUCCESS(Status))
    {
        //
        // Loop forever. This thread will be killed when the service terminates.
        //
        while (TRUE)
        {
            Status = ElfProcessLPCCalls ();
        }
    }

    ELF_LOG1(ERROR,
             "MainLPCThread: SetUpLPCPort failed %#x\n",
             Status);

    return Status;

    UNREFERENCED_PARAMETER(LPCThreadParm);
}



BOOL
StartLPCThread(
    VOID
    )

/*++

Routine Description:

    This routine starts up the thread that monitors the LPC port.

Arguments:

    NONE

Return Value:

    TRUE if thread creation succeeded, FALSE otherwise.

Note:


--*/
{
    DWORD       error;
    DWORD       ThreadId;

    ELF_LOG0(LPC,
             "StartLPCThread: Start up the LPC thread\n");

    //
    // Start up the actual thread.
    //
    LPCThreadHandle = CreateThread(NULL,               // lpThreadAttributes
                                   4096,               // dwStackSize
                                   MainLPCThread,      // lpStartAddress
                                   NULL,               // lpParameter
                                   0L,                 // dwCreationFlags
                                   &ThreadId);         // lpThreadId

    if (LPCThreadHandle == NULL)
    {
        error = GetLastError();

        ELF_LOG1(ERROR,
                 "MainLPCThread: CreateThread failed %d\n",
                 error);

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\elfutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ELFUTIL.C

Abstract:

    This file contains all the utility routines for the Eventlog service.

Author:

    Rajen Shah  (rajens)    16-Jul-1991


Revision History:
    01-May-2001     a-jyotig
		CurrentTime is initialized to 0 in function WriteQueuedEvents. 
		Refer to prefix bug# 318163
--*/

//
// INCLUDES
//

#include <eventp.h>
#include <lmalert.h>
#include <string.h>
#include <stdlib.h>

extern DWORD  ElState;

PLOGMODULE
FindModuleStrucFromAtom(
    ATOM Atom
    )

/*++

Routine Description:

    This routine scans the list of module structures and finds the one
    that matches the module atom.

Arguments:

    Atom contains the atom matching the module name.

Return Value:

    A pointer to the log module structure is returned.
    NULL if no matching atom is found.

Note:

--*/
{
    PLOGMODULE  ModuleStruc;

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogModuleCritSec);

    ModuleStruc = CONTAINING_RECORD(LogModuleHead.Flink,
                                    LOGMODULE,
                                    ModuleList);

    while ((ModuleStruc->ModuleList.Flink != &LogModuleHead)
             &&
           (ModuleStruc->ModuleAtom != Atom))
    {
        ModuleStruc = CONTAINING_RECORD(ModuleStruc->ModuleList.Flink,
                                        LOGMODULE,
                                        ModuleList);
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogModuleCritSec);

    return (ModuleStruc->ModuleAtom == Atom ? ModuleStruc : NULL);
}



PLOGMODULE
GetModuleStruc(
    PUNICODE_STRING ModuleName
    )

/*++

Routine Description:

    This routine returns a pointer to the log module structure for the
    module specified in ModuleName. If none exists, the default structure
    for application is returned.

Arguments:

    ModuleName contains the name of the module.

Return Value:

    A pointer to the log module structure is returned.

Note:


--*/
{
    NTSTATUS    Status;
    ATOM        ModuleAtom;
    ANSI_STRING ModuleNameA;
    PLOGMODULE  pModule;

    Status = RtlUnicodeStringToAnsiString(&ModuleNameA,
                                          ModuleName,
                                          TRUE);

    if (!NT_SUCCESS(Status))
    {
        //
        // Not much else we can do here...
        //
        ELF_LOG2(ERROR,
                 "GetModuleStruc: Unable to convert Unicode string %ws to Ansi %#x\n",
                 ModuleName->Buffer,
                 Status);

        return ElfDefaultLogModule;
    }

    //
    // Guarantee that it's NULL terminated
    //
    ModuleNameA.Buffer[ModuleNameA.Length] = '\0';

    ModuleAtom = FindAtomA(ModuleNameA.Buffer);

    RtlFreeAnsiString(&ModuleNameA);

    if (ModuleAtom == (ATOM)0)
    {
        ELF_LOG1(TRACE,
                 "GetModuleStruc: No atom found for module %ws -- defaulting to Application\n",
                 ModuleName->Buffer);

        return ElfDefaultLogModule;
    }
     
    pModule = FindModuleStrucFromAtom(ModuleAtom);

    return (pModule != NULL ? pModule : ElfDefaultLogModule);
}



VOID
UnlinkContextHandle(
    IELF_HANDLE     LogHandle
    )

/*++

Routine Description:

    This routine unlinks the LogHandle specified from the linked list of
    context handles.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    LogHandle points to a context handle structure.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogHandleCritSec);

    //
    // Remove this entry
    //
    RemoveEntryList(&LogHandle->Next);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogHandleCritSec);
}


VOID
LinkContextHandle(
    IELF_HANDLE    LogHandle
    )

/*++

Routine Description:

    This routine links the LogHandle specified into the linked list of
    context handles.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    LogHandle points to a context handle structure.

Return Value:

    NONE

Note:


--*/
{
    ASSERT(LogHandle->Signature == ELF_CONTEXTHANDLE_SIGN);

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogHandleCritSec);

    //
    // Place structure at the beginning of the list.
    //
    InsertHeadList(&LogHandleListHead, &LogHandle->Next);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogHandleCritSec);
}


VOID
UnlinkQueuedEvent(
    PELF_QUEUED_EVENT QueuedEvent
    )

/*++

Routine Description:

    This routine unlinks the QueuedEvent specified from the linked list of
    QueuedEvents.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    QueuedEvent - The request to remove from the linked list

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&QueuedEventCritSec);

    //
    // Remove this entry
    //
    RemoveEntryList(&QueuedEvent->Next);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedEventCritSec);
}



VOID
LinkQueuedEvent(
    PELF_QUEUED_EVENT QueuedEvent
    )

/*++

Routine Description:

    This routine links the QueuedEvent specified into the linked list of
    QueuedEvents.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    QueuedEvent - The request to add from the linked list

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&QueuedEventCritSec);

    //
    // Place structure at the beginning of the list.
    //
    InsertHeadList(&QueuedEventListHead, &QueuedEvent->Next);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedEventCritSec);
}


DWORD
WINAPI
ElfpSendMessage(
    LPVOID UnUsed
    )

/*++

Routine Description:

    This routines just uses MessageBox to pop up a message.

    This is it's own routine so we can spin a thread to do this, in case the
    user doesn't hit the OK button for a while.

Arguments:

    NONE

Return Value:

    NONE

Note:

--*/
{
    PVOID MessageBuffer;
    HANDLE hLibrary;
    LPWSTR * StringPointers;
    DWORD i;
    PELF_QUEUED_EVENT QueuedEvent;
    PELF_QUEUED_EVENT FlushEvent;

    //
    // If we are shutting down, we need to return
    // and allow resources to be freed
    //
    if (ElState == STOPPING || ElState == STOPPED)
    {
        ELF_LOG1(TRACE,
                 "ElfpSendMessage: Skipping SendMessage since ElState is %ws\n",
                 (ElState == STOPPING ? L"STOPPING" :
                                        L"STOPPED"));

        return 0;
    }

    RtlEnterCriticalSection(&QueuedMessageCritSec);

    //
    // First get a handle to the message file used for the message text
    //
    hLibrary = LoadLibraryEx(L"NETMSG.DLL",
                             NULL,
                             LOAD_LIBRARY_AS_DATAFILE);

    if (hLibrary != NULL)
    {
        //
        // Walk the linked list and process each element
        //

        QueuedEvent = CONTAINING_RECORD(QueuedMessageListHead.Flink,
                                        struct _ELF_QUEUED_EVENT,
                                        Next);

        while (QueuedEvent->Next.Flink != QueuedMessageListHead.Flink)
        {
            ASSERT(QueuedEvent->Type == Message);

            //
            // Unlock the linked list -- normally not a safe thing since we're
            // about to play with a pointer to an element in it, but:
            //
            //     a. This is the only routine where a list item can be removed/deleted
            //
            //     b. We don't touch the only potentially-volatile structure member
            //            (QueuedEvent->Next) until we're in the critsec again below
            //
            //     c. Only one thread at a time executes this code (enforced by
            //            MBThreadHandle, which is only read/written inside the critsec)
            //
            RtlLeaveCriticalSection(&QueuedMessageCritSec);

            //
            // Build the array of pointers to the insertion strings
            //
            StringPointers =
                (LPWSTR *) ElfpAllocateBuffer(QueuedEvent->Event.Message.NumberOfStrings
                                                  * sizeof(LPWSTR));

            if (StringPointers)
            {
                //
                // Build the array of pointers to the insertion string(s)
                //
                if (QueuedEvent->Event.Message.NumberOfStrings)
                {
                    StringPointers[0] = (LPWSTR) ((PBYTE) &QueuedEvent->Event.Message +
                                                       sizeof(ELF_MESSAGE_RECORD));

                    for (i = 1;
                         i < QueuedEvent->Event.Message.NumberOfStrings;
                         i++)
                    {
                        StringPointers[i] = StringPointers[i-1]
                                                + wcslen(StringPointers[i - 1])
                                                + 1;
                    }
                }

                //
                // Call FormatMessage to build the message
                //
                if (FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                     FORMAT_MESSAGE_FROM_HMODULE,
                                   hLibrary,
                                   QueuedEvent->Event.Message.MessageId,
                                   0,                       // Default language ID
                                   (LPWSTR) &MessageBuffer,
                                   0,                       // Min # of bytes to allocate
                                   (va_list *) StringPointers))
                {
                    //
                    // Now actually display it
                    //
                    MessageBoxW(NULL,
                                (LPWSTR) MessageBuffer,
                                GlobalMessageBoxTitle,
                                MB_OK |
                                  MB_SETFOREGROUND |
                                  MB_ICONEXCLAMATION |
                                  MB_SERVICE_NOTIFICATION);

                    LocalFree(MessageBuffer);
                }
                else
                {
                    ELF_LOG1(ERROR,
                             "ElfpSendMessage: FormatMessage failed %d\n",
                             GetLastError());
                }

                ElfpFreeBuffer(StringPointers);
            }

            //
            // If we are shutting down, we need to break out of this loop
            // and allow resources to be freed
            //
            if (ElState == STOPPING || ElState == STOPPED)
            {
                ELF_LOG1(TRACE,
                         "ElfpSendMessage: Aborting SendMessage since ElState is %ws\n",
                         (ElState == STOPPING ? L"STOPPING" :
                                                L"STOPPED"));

                FreeLibrary(hLibrary);
                MBThreadHandle = NULL;
                return 0;
            }

            RtlEnterCriticalSection (&QueuedMessageCritSec);

            //
            // Move to the next one, saving this one to delete it
            //
            FlushEvent = QueuedEvent;

            QueuedEvent = CONTAINING_RECORD(QueuedEvent->Next.Flink,
                                            struct _ELF_QUEUED_EVENT,
                                            Next);

            //
            // Now remove this from the queue and free it if we successfully
            // processed it
            //
            RemoveEntryList (&FlushEvent->Next);
        }

        FreeLibrary(hLibrary);
    }
    else
    {
        //
        // We couldn't load the message DLL -- leave the queued event
        // on the list and try it the next time this thread spins up.
        //
        ELF_LOG1(ERROR,
                 "ElfpSendMessage: LoadLibraryEx of netmsg.dll failed %d\n",
                 GetLastError());
    }

    MBThreadHandle = NULL;

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection (&QueuedMessageCritSec);

    ELF_LOG0(TRACE, "ElfpSendMessage: MessageBox thread exiting\n");

    return 0;
}


VOID
LinkQueuedMessage (
    PELF_QUEUED_EVENT QueuedEvent
    )

/*++

Routine Description:

    This routine links the QueuedEvent specified into the linked list of
    QueuedMessages.  If there's not already a messagebox thread running,
    it starts one.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    QueuedEvent - The request to add from the linked list

Return Value:

    NONE

Note:


--*/
{
    DWORD ThreadId;

    // Lock the linked list

    RtlEnterCriticalSection(&QueuedMessageCritSec);


    // Place structure at the end of the list.

    InsertTailList(&QueuedMessageListHead, &QueuedEvent->Next);

    if (!MBThreadHandle)
    {
        ELF_LOG0(TRACE,
                 "LinkQueuedMessage: Spinning up a MessageBox thread\n");

        //
        // Since the user can just let this sit on their screen,
        // spin a thread for this
        //
        MBThreadHandle = CreateThread(NULL,               // lpThreadAttributes
                                      4096,               // dwStackSize
                                      ElfpSendMessage,    // lpStartAddress
                                      NULL,               // lpParameter
                                      0L,                 // dwCreationFlags
                                      &ThreadId);         // lpThreadId
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedMessageCritSec);
}



VOID
NotifyChange(
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine runs the list of events that are registered with
    ElfChangeNotify to be notified when a log has changed, and pulses
    the event.

    In order to protect against multiple thread/process access to the
    list at the same time, we use an exclusive resource.

Arguments:

    LogHandle points to a context handle structure.

Return Value:

    NONE

Note:

--*/
{

    //
    // How frequently will I try to pulse the events?  How about every
    // 5 seconds
    //

#define MINIMUM_PULSE_TIME 5

    PNOTIFIEE Notifiee;
    LARGE_INTEGER Time;
    ULONG CurrentTime = 0;
    NTSTATUS Status;

    //
    // Get exclusive access to the log file. This will ensure no one
    // else is accessing the file.
    //

    RtlAcquireResourceExclusive(&pLogFile->Resource,
                                TRUE);                  // Wait until available

    //
    // See if we've done this in the last MINIMUM_PULSE_TIME seconds
    //
    Status = NtQuerySystemTime(&Time);

    if (NT_SUCCESS(Status))
    {
        RtlTimeToSecondsSince1970(&Time, &CurrentTime);

        if (CurrentTime > pLogFile->ulLastPulseTime + MINIMUM_PULSE_TIME)
        {
            ELF_LOG1(TRACE,
                     "NotifyChange: Pulsing ChangeNotify events -- current time is %ul\n",
                     CurrentTime);

            //
            // Remember that we pulsed
            //
            pLogFile->ulLastPulseTime = CurrentTime;

            //
            // Walk the linked list and and pulse any events
            //
            Notifiee = CONTAINING_RECORD(pLogFile->Notifiees.Flink,
                                         struct _NOTIFIEE,
                                         Next);

            while (Notifiee->Next.Flink != pLogFile->Notifiees.Flink)
            {
                //
                // Pulse each event as we get to it.
                //
                NtPulseEvent(Notifiee->Event,NULL);

                Notifiee = CONTAINING_RECORD(Notifiee->Next.Flink,
                                             struct _NOTIFIEE,
                                             Next);
            }
        }
    }
    else
    {
        ELF_LOG1(ERROR,
                 "NotifyChange: NtQuerySystemTime failed %#x\n",
                 Status);
    }

    //
    // Free the resource
    //
    RtlReleaseResource ( &pLogFile->Resource );
}



VOID
WriteQueuedEvents(
    VOID
    )

/*++

Routine Description:

    This routine runs the list of queued events and writes them.

    In order to protect against multiple thread/process access to the
    list at the same time, we use an exclusive resource.

Arguments:

    NONE

Return Value:

    NONE

Note:

--*/
{
    PELF_QUEUED_EVENT QueuedEvent;
    PELF_QUEUED_EVENT FlushEvent;
    BOOLEAN           bFlushEvent;
    LARGE_INTEGER     Time;
    ULONG             CurrentTime = 0;

    static ULONG      LastAlertTried  = 0;
    static BOOLEAN    LastAlertFailed = FALSE;

    // Lock the linked list, you must get the System Log File Resource
    // first, it is the higher level lock

    RtlAcquireResourceExclusive(&ElfModule->LogFile->Resource,
                                TRUE);                  // Wait until available

    RtlEnterCriticalSection(&QueuedEventCritSec);

    //
    // Walk the linked list and process each element
    //
    QueuedEvent = CONTAINING_RECORD(QueuedEventListHead.Flink,
                                    struct _ELF_QUEUED_EVENT,
                                    Next);

    while (QueuedEvent->Next.Flink != QueuedEventListHead.Flink)
    {
        //
        // Default is to flush the event after processing
        //
        bFlushEvent = TRUE;

        //
        // Do the appropriate thing
        //
        if (QueuedEvent->Type == Event)
        {
            PerformWriteRequest(&QueuedEvent->Event.Request);
        }
        else if (QueuedEvent->Type == Alert)
        {
            //
            // Don't even try to send failed alerts quicker than once a minute
            //
            NtQuerySystemTime(&Time);
            RtlTimeToSecondsSince1970(&Time, &CurrentTime);

            if (!LastAlertFailed || CurrentTime > LastAlertTried + 60)
            {
                ELF_LOG1(TRACE,
                         "WriteQueuedEvents: Sending alert -- current time is %ul\n",
                         CurrentTime);

                LastAlertFailed = 
                    
                    !SendAdminAlert(QueuedEvent->Event.Alert.MessageId,
                                    QueuedEvent->Event.Alert.NumberOfStrings,
                                    (PUNICODE_STRING) ((PBYTE) QueuedEvent
                                                          + FIELD_OFFSET(ELF_QUEUED_EVENT, Event)
                                                          + sizeof(ELF_ALERT_RECORD)));

                LastAlertTried = CurrentTime;
            }

            //
            // Only try to write it for 5 minutes, then give up (the
            // alerter service may not be configured to run)
            //
            if (LastAlertFailed
                 &&
                QueuedEvent->Event.Alert.TimeOut > CurrentTime)
            {
                ELF_LOG1(TRACE,
                         "WriteQueuedEvents: Alert failed -- will retry until timeout at %ul\n",
                         QueuedEvent->Event.Alert.TimeOut);

                bFlushEvent = FALSE;
            }
        }

        //
        // Move to the next one, saving this one to delete it
        //
        FlushEvent = QueuedEvent;

        QueuedEvent = CONTAINING_RECORD(QueuedEvent->Next.Flink,
                                        struct _ELF_QUEUED_EVENT,
                                        Next);

        //
        // Now remove this from the queue and free it if we successfully
        // processed it
        //
        if (bFlushEvent)
        {
            UnlinkQueuedEvent(FlushEvent);
            ElfpFreeBuffer(FlushEvent);
        }
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedEventCritSec);
    RtlReleaseResource(&ElfModule->LogFile->Resource);
}



VOID
FlushQueuedEvents(
    VOID
    )

/*++

Routine Description:

    This routine runs the list of queued events and frees them.

    In order to protect against multiple thread/process access to the
    list at the same time, we use an exclusive resource.

Arguments:

    NONE

Return Value:

    NONE

Note:

--*/
{

    PELF_QUEUED_EVENT QueuedEvent;
    PELF_QUEUED_EVENT FlushEvent;

    // Lock the linked list

    RtlEnterCriticalSection(&QueuedEventCritSec);

    //
    // Walk the linked list and and free the memory for any events
    //
    QueuedEvent = CONTAINING_RECORD(QueuedEventListHead.Flink,
                                    struct _ELF_QUEUED_EVENT,
                                    Next);

    while (QueuedEvent->Next.Flink != QueuedEventListHead.Flink)
    {
        //
        // Free each event as we get to it.
        //
        FlushEvent = QueuedEvent;

        QueuedEvent = CONTAINING_RECORD(QueuedEvent->Next.Flink,
                                        struct _ELF_QUEUED_EVENT,
                                        Next);

        ElfpFreeBuffer(FlushEvent);
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedEventCritSec);
}



VOID
UnlinkLogModule(
    PLOGMODULE LogModule
    )

/*++

Routine Description:

    This routine unlinks the LogModule specified from the linked list.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    LogModule points to a context handle structure.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogModuleCritSec);

    //
    // Remove this entry
    //
    RemoveEntryList(&LogModule->ModuleList);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogModuleCritSec);
}



VOID
LinkLogModule (
    PLOGMODULE    LogModule,
    ANSI_STRING * pModuleNameA
    )

/*++

Routine Description:

    This routine links the LogModule specified into the linked list.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    LogModule points to a context handle structure.
    ANSI LogModule name.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogModuleCritSec);

    //
    // Add the atom for this module.
    //
    LogModule->ModuleAtom = AddAtomA(pModuleNameA->Buffer);

    //
    // Place structure at the beginning of the list.
    //
    InsertHeadList(&LogModuleHead, &LogModule->ModuleList);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogModuleCritSec);
}


VOID
UnlinkLogFile(
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine unlinks the LogFile structure specified from the linked
    list of log files;
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    pLogFile points to a log file structure.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    //
    // Remove this entry
    //
    RemoveEntryList(&pLogFile->FileList);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);
}



VOID
LinkLogFile (
    PLOGFILE   pLogFile
    )

/*++

Routine Description:

    This routine links the LogFile specified into the linked list of
    log files.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    pLogFile points to a context handle structure.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    //
    // Place structure at the beginning of the list.
    //
    InsertHeadList(&LogFilesHead, &pLogFile->FileList);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);
}



VOID
GetGlobalResource (
    DWORD Type
    )

/*++

Routine Description:

    This routine takes the global resource either for shared access or
    exclusive access depending on the value of Type. It waits forever for
    the resource to become available.

Arguments:

    Type is one of ELF_GLOBAL_SHARED or ELF_GLOBAL_EXCLUSIVE.

Return Value:

    NONE

Note:


--*/
{
    BOOL    Acquired;

    if (Type & ELF_GLOBAL_SHARED)
    {
        Acquired = RtlAcquireResourceShared(&GlobalElfResource,
                                            TRUE);              // Wait forever
    }
    else
    {
        //
        // Assume EXCLUSIVE
        //
        Acquired = RtlAcquireResourceExclusive(&GlobalElfResource,
                                               TRUE);           // Wait forever
    }
 
    ASSERT(Acquired);      // This must always be TRUE.
}


VOID
ReleaseGlobalResource(
    VOID
    )

/*++

Routine Description:

    This routine releases the global resource.

Arguments:

    NONE

Return Value:

    NONE

Note:


--*/
{
    RtlReleaseResource(&GlobalElfResource);
}


VOID
InvalidateContextHandlesForLogFile(
    PLOGFILE    pLogFile
    )

/*++

Routine Description:

    This routine walks through the context handles and marks the ones
    that point to the LogFile passed in as "invalid for read".

Arguments:

    Pointer to log file structure.

Return Value:

    NONE.

Note:


--*/
{
    IELF_HANDLE LogHandle;
    PLOGMODULE  pLogModule;

    //
    // Lock the context handle list
    //
    RtlEnterCriticalSection(&LogHandleCritSec);

    //
    // Walk the linked list and mark any matching context handles as
    // invalid.
    //
    LogHandle = CONTAINING_RECORD(LogHandleListHead.Flink,
                                  struct _IELF_HANDLE,
                                  Next);


    while (LogHandle->Next.Flink != LogHandleListHead.Flink)
    {
        pLogModule = FindModuleStrucFromAtom(LogHandle->Atom);

        ASSERT(pLogModule);

        if (pLogModule && (pLogFile == pLogModule->LogFile))
        {
            LogHandle->Flags |= ELF_LOG_HANDLE_INVALID_FOR_READ;
        }

        LogHandle = CONTAINING_RECORD(LogHandle->Next.Flink,
                                      struct _IELF_HANDLE,
                                      Next);
    }

    //
    // Unlock the context handle list
    //
    RtlLeaveCriticalSection(&LogHandleCritSec);
}



VOID
FixContextHandlesForRecord(
    DWORD RecordOffset,
    DWORD NewRecordOffset
    )

/*++

Routine Description:

    This routine makes sure that the record starting at RecordOffset isn't
    the current record for any open handle.  If it is, the handle is adjusted
    to point to the next record.

Arguments:

    RecordOffset - The byte offset in the log of the record that is about
                   to be overwritten.
    NewStartingRecord - The new location to point the handle to (this is the
                        new first record)

Return Value:

    NONE.

Note:


--*/
{
    IELF_HANDLE LogHandle;

    //
    // Lock the context handle list
    //
    RtlEnterCriticalSection(&LogHandleCritSec);

    //
    // Walk the linked list and fix any matching context handles
    //
    LogHandle = CONTAINING_RECORD(LogHandleListHead.Flink,
                                  struct _IELF_HANDLE,
                                  Next);

    while (LogHandle->Next.Flink != LogHandleListHead.Flink)
    {
        if (LogHandle->SeekBytePos == RecordOffset)
        {
            LogHandle->SeekBytePos = NewRecordOffset;
        }

        LogHandle = CONTAINING_RECORD(LogHandle->Next.Flink,
                                      struct _IELF_HANDLE,
                                      Next);
    }

    //
    // Unlock the context handle list
    //
    RtlLeaveCriticalSection(&LogHandleCritSec);
}


PLOGFILE
FindLogFileFromName(
    PUNICODE_STRING pFileName
    )

/*++

Routine Description:

    This routine looks at all the log files to find one that matches
    the name passed in.

Arguments:

    Pointer to name of file.

Return Value:

    Matching LOGFILE structure if file in use.

Note:


--*/
{
    PLOGFILE pLogFile;

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    pLogFile = CONTAINING_RECORD(LogFilesHead.Flink,
                                 LOGFILE,
                                 FileList);

    while (pLogFile->FileList.Flink != LogFilesHead.Flink)
    {
        //
        // BUGBUG: This should probably be _wcsicmp() since the log module
        //         names are assumed to be case insensitive (so the log
        //         file names should be as well else we can get weirdness
        //         with overlapping module names if somebody creates a log
        //         named something like "application" or "system")
        //
        if (wcscmp(pLogFile->LogFileName->Buffer, pFileName->Buffer) == 0)
            break;

        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);

    return (pLogFile->FileList.Flink == LogFilesHead.Flink ? NULL : pLogFile);
}


#define ELF_MODULE_NAME   L"EventLog"
#define ELFSEC_MODULE_NAME   L"SECURITY"
    
VOID
ElfpCreateElfEvent(
    IN ULONG  EventId,
    IN USHORT EventType,
    IN USHORT EventCategory,
    IN USHORT NumStrings,
    IN LPWSTR * Strings,
    IN LPVOID Data,
    IN ULONG  DataSize,
    IN USHORT Flags,
    IN BOOL ForSecurity
    )

/*++

Routine Description:

    This creates an request packet to write an event on behalf of the event
    log service itself.  It then queues this packet to a linked list for
    writing later.

Arguments:

    The fields to use to create the event record


Return Value:

    None

Note:


--*/
{
    PELF_QUEUED_EVENT QueuedEvent;
    PWRITE_PKT WritePkt;
    PEVENTLOGRECORD EventLogRecord;
    PBYTE BinaryData;
    ULONG RecordLength;
    ULONG StringOffset, DataOffset;
    USHORT StringsSize = 0;
    USHORT i;
    ULONG PadSize;
    ULONG ModuleNameLen; // Length in bytes
    ULONG zero = 0;      // For pad bytes
    LARGE_INTEGER    Time;
    ULONG LogTimeWritten;
    PWSTR ReplaceStrings;
	WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	ULONG  ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
	BOOL bOK;
    LPWSTR pwcModule;

    if(ForSecurity)
        pwcModule = ELFSEC_MODULE_NAME;
    else
        pwcModule = ELF_MODULE_NAME;

	// Get the computer name

	bOK = GetComputerNameW(LocalComputerName, &ComputerNameLength);
	if(bOK == FALSE)
	{
    	ELF_LOG1(ERROR,
             "ElfpCreateElfEvent: failed calling GetComputerNameW, last error 0x%x\n",
              GetLastError());
        return;    
	}
    ComputerNameLength = (ComputerNameLength+1)*sizeof(WCHAR);

    ELF_LOG1(TRACE,
             "ElfpCreateElfEvent: Logging event ID %d\n",
             EventId);

    //
    // LogTimeWritten
    // We need to generate a time when the log is written. This
    // gets written in the log so that we can use it to test the
    // retention period when wrapping the file.
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time,
                              &LogTimeWritten);

    //
    // Figure out how big a buffer to allocate
    //
    ModuleNameLen = (wcslen(pwcModule) + 1) * sizeof (WCHAR);

    ELF_LOG1(TRACE,
             "ElfpCreateElfEvent: Length of module name is %d\n",
             ModuleNameLen);

    StringOffset = sizeof(EVENTLOGRECORD)
                     + ModuleNameLen
                     + ComputerNameLength;

    //
    // Calculate the length of strings so that we can see how
    // much space is needed for that.
    //
    for (i = 0; i < NumStrings; i++)
    {
        StringsSize += wcslen(Strings[i]) + 1;

        ELF_LOG2(TRACE,
                 "ElfpCreateElfEvent: Length of string %d (including NULL) is %d\n",
                 i,
                 wcslen(Strings[i]) + 1);
    }

    //
    // DATA OFFSET:
    //
    DataOffset = StringOffset + StringsSize * sizeof(WCHAR);

    //
    // Determine how big a buffer is needed for the queued event record.
    //
    RecordLength = sizeof(ELF_QUEUED_EVENT)
                     + sizeof(WRITE_PKT)
                     + DataOffset
                     + DataSize
                     + sizeof(RecordLength); // Size excluding pad bytes

    ELF_LOG1(TRACE,
             "ElfpCreateElfEvent: RecordLength (no pad bytes) is %d\n",
             RecordLength);

    //
    // Determine how many pad bytes are needed to align to a DWORD
    // boundary.
    //
    PadSize = sizeof(ULONG) - (RecordLength % sizeof(ULONG));

    RecordLength += PadSize;    // True size needed

    ELF_LOG2(TRACE,
             "ElfpCreateElfEvent: RecordLength (with %d pad bytes) is %d\n",
             PadSize,
             RecordLength);

    //
    // Allocate the buffer for the Eventlog record
    //
    QueuedEvent = (PELF_QUEUED_EVENT) ElfpAllocateBuffer(RecordLength);

    WritePkt = (PWRITE_PKT) (QueuedEvent + 1);

    if (QueuedEvent != NULL)
    {
        //
        // Fill up the event record
        //
        RecordLength  -= (sizeof(ELF_QUEUED_EVENT) + sizeof(WRITE_PKT));
        EventLogRecord = (PEVENTLOGRECORD) (WritePkt + 1);

        EventLogRecord->Length              = RecordLength;
        EventLogRecord->TimeGenerated       = LogTimeWritten;
        EventLogRecord->Reserved            = ELF_LOG_FILE_SIGNATURE;
        EventLogRecord->TimeWritten         = LogTimeWritten;
        EventLogRecord->EventID             = EventId;
        EventLogRecord->EventType           = EventType;
        EventLogRecord->EventCategory       = EventCategory;
        EventLogRecord->ReservedFlags       = 0;
        EventLogRecord->ClosingRecordNumber = 0;
        EventLogRecord->NumStrings          = NumStrings;
        EventLogRecord->StringOffset        = StringOffset;
        EventLogRecord->DataLength          = DataSize;
        EventLogRecord->DataOffset          = DataOffset;
        EventLogRecord->UserSidLength       = 0;
        EventLogRecord->UserSidOffset       = StringOffset;

        //
        // Fill in the variable-length fields
        //

        //
        // STRINGS
        //
        ReplaceStrings = (PWSTR) ((PBYTE) EventLogRecord
                                       + StringOffset);

        for (i = 0; i < NumStrings; i++)
        {
            ELF_LOG2(TRACE,
                     "ElfpCreateElfEvent: Copying string %d (%ws) into record\n",
                     i,
                     Strings[i]);

            wcscpy(ReplaceStrings, Strings[i]);
            ReplaceStrings += wcslen(Strings[i]) + 1;
        }

        //
        // MODULENAME
        //
        BinaryData = (PBYTE) EventLogRecord + sizeof(EVENTLOGRECORD);

        RtlCopyMemory(BinaryData,
                      pwcModule,
                      ModuleNameLen);

        //
        // COMPUTERNAME
        //
        BinaryData += ModuleNameLen; // Now point to computername

        RtlCopyMemory(BinaryData,
                      LocalComputerName,
                      ComputerNameLength);

        //
        // BINARY DATA
        //
        BinaryData = (PBYTE) ((PBYTE) EventLogRecord + DataOffset);
        RtlCopyMemory(BinaryData, Data, DataSize);

        //
        // PAD  - Fill with zeros
        //
        BinaryData += DataSize;
        RtlCopyMemory(BinaryData, &zero, PadSize);

        //
        // LENGTH at end of record
        //
        BinaryData += PadSize;  // Point after pad bytes
        ((PULONG) BinaryData)[0] = RecordLength;

        //
        // Build the QueuedEvent Packet
        //
        QueuedEvent->Type = Event;

        QueuedEvent->Event.Request.Pkt.WritePkt           = WritePkt;
        if(ForSecurity)
        {
            QueuedEvent->Event.Request.Module                 = ElfSecModule;
            QueuedEvent->Event.Request.LogFile                = ElfSecModule->LogFile;
        }
        else
        {
            if(ElfModule)
            {
                QueuedEvent->Event.Request.Module                 = ElfModule;
                QueuedEvent->Event.Request.LogFile                = ElfModule->LogFile;
            }
            else
            {
                QueuedEvent->Event.Request.Module                 = NULL;
                QueuedEvent->Event.Request.LogFile                = NULL;
            }
        }
        QueuedEvent->Event.Request.Flags                  = Flags;
        QueuedEvent->Event.Request.Command                = ELF_COMMAND_WRITE;
        QueuedEvent->Event.Request.Pkt.WritePkt->Buffer   = EventLogRecord;
        QueuedEvent->Event.Request.Pkt.WritePkt->Datasize = RecordLength;

        //
        // Now Queue it on the linked list
        //
        LinkQueuedEvent(QueuedEvent);
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfpCreateElfEvent: Unable to allocate memory for QueuedEvent\n");
    }
}


VOID
ElfpCreateQueuedAlert(
    DWORD MessageId,
    DWORD NumberOfStrings,
    LPWSTR Strings[]
    )
{
    DWORD i;
    DWORD RecordLength;
    PELF_QUEUED_EVENT QueuedEvent;
    PUNICODE_STRING UnicodeStrings;
    LPWSTR pString;
    PBYTE ptr;
    LARGE_INTEGER Time;
    ULONG CurrentTime;

    ELF_LOG1(TRACE,
             "ElfpCreateQueuedAlert: Creating alert for message ID %d\n",
             MessageId);

    //
    // Turn the input strings into UNICODE_STRINGS and figure out how
    // big to make the buffer to allocate
    //
    RecordLength   = sizeof(UNICODE_STRING) * NumberOfStrings;
    UnicodeStrings = ElfpAllocateBuffer(RecordLength);

    if (!UnicodeStrings)
    {
        ELF_LOG0(TRACE,
                 "ElfpCreateQueuedAlert: Unable to allocate memory for UnicodeStrings\n");

        return;
    }

    RecordLength += FIELD_OFFSET(ELF_QUEUED_EVENT, Event) + 
                        sizeof(ELF_ALERT_RECORD);

    for (i = 0; i < NumberOfStrings; i++)
    {
        RtlInitUnicodeString(&UnicodeStrings[i], Strings[i]);
        RecordLength += UnicodeStrings[i].MaximumLength;

        ELF_LOG2(TRACE,
                 "ElfpCreateQueuedAlert: Length of string %d is %d\n",
                 i,
                 UnicodeStrings[i].MaximumLength);
    }

    //
    // Now allocate what will be the real queued event
    //

    QueuedEvent = ElfpAllocateBuffer(RecordLength);

    if (!QueuedEvent)
    {
        ELF_LOG0(ERROR,
                 "ElfpCreateQueuedAlert: Unable to allocate memory for QueuedEvent\n");

        ElfpFreeBuffer(UnicodeStrings);
        return;
    }

    QueuedEvent->Type = Alert;

    QueuedEvent->Event.Alert.MessageId       = MessageId;
    QueuedEvent->Event.Alert.NumberOfStrings = NumberOfStrings;

    //
    // If we can't send the alert in 5 minutes, give up
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time, &CurrentTime);

    QueuedEvent->Event.Alert.TimeOut = CurrentTime + 300;

    //
    // Move the array of UNICODE_STRINGS into the queued event and
    // point UnicodeStrings at it.  Then fix up the Buffer pointers.
    //
    ptr = (PBYTE) QueuedEvent
               + FIELD_OFFSET(ELF_QUEUED_EVENT, Event)
               + sizeof(ELF_ALERT_RECORD);

    RtlCopyMemory(ptr,
                  UnicodeStrings,
                  sizeof(UNICODE_STRING) * NumberOfStrings);

    ElfpFreeBuffer(UnicodeStrings);
    UnicodeStrings = (PUNICODE_STRING) ptr;

    pString = (LPWSTR) (ptr + sizeof(UNICODE_STRING) * NumberOfStrings);

    for (i = 0; i < NumberOfStrings; i++)
    {
        ELF_LOG3(TRACE,
                 "ElfpCreateQueuedAlert: Copying string %d (%*ws) into QueuedEvent record\n",
                 i,
                 UnicodeStrings[i].MaximumLength / sizeof(WCHAR),
                 UnicodeStrings[i].Buffer);

        RtlCopyMemory(pString,
                      UnicodeStrings[i].Buffer,
                      UnicodeStrings[i].MaximumLength);

        UnicodeStrings[i].Buffer = pString;

        pString = (LPWSTR) ((PBYTE) pString + UnicodeStrings[i].MaximumLength);
    }

    LinkQueuedEvent(QueuedEvent);
}



VOID
ElfpCreateQueuedMessage(
    DWORD MessageId,
    DWORD NumberOfStrings,
    LPWSTR Strings[]
    )
{
    DWORD i;
    DWORD RecordLength = 0;
    PELF_QUEUED_EVENT QueuedEvent;
    LPWSTR pString;

    ELF_LOG1(TRACE,
             "ElfpCreateQueuedMessage: Creating message for message ID %d\n",
             MessageId);

    //
    // Figure out how big to make the buffer to allocate
    //
    RecordLength = sizeof(ELF_QUEUED_EVENT);

    for (i = 0; i < NumberOfStrings; i++)
    {
        RecordLength += (wcslen(Strings[i]) + 1) * sizeof(WCHAR);

        ELF_LOG2(TRACE,
                 "ElfpCreateQueuedMessage: Length of string %d (including NULL) is %d\n",
                 i,
                 wcslen(Strings[i]) + 1);
    }

    //
    // Now allocate what will be the real queued event
    //
    QueuedEvent = ElfpAllocateBuffer(RecordLength);

    if (!QueuedEvent)
    {
        ELF_LOG0(ERROR,
                 "ElfpCreateQueuedMessage: Unable to allocate memory for QueuedEvent\n");

        return;
    }

    QueuedEvent->Type = Message;

    QueuedEvent->Event.Message.MessageId       = MessageId;
    QueuedEvent->Event.Message.NumberOfStrings = NumberOfStrings;

    //
    // Move the array of UNICODE strings into the queued event
    //

    pString = (LPWSTR) ((PBYTE) QueuedEvent
                             + FIELD_OFFSET(ELF_QUEUED_EVENT, Event)
                             + sizeof(ELF_MESSAGE_RECORD));

    for (i = 0; i < NumberOfStrings; i++)
    {
        wcscpy(pString, Strings[i]);
        pString += wcslen(Strings[i]) + 1;

        ELF_LOG2(TRACE,
                 "ElfpCreateQueuedMessage: Copying string %d (%ws) into QueuedEvent buffer\n",
                 i,
                 Strings[i]);
    }

    LinkQueuedMessage(QueuedEvent);
}


NTSTATUS
ElfpInitCriticalSection(
    PRTL_CRITICAL_SECTION  pCritsec
    )
{
    NTSTATUS  ntStatus;

    //
    // RtlInitializeCriticalSection will raise an exception
    // if it runs out of resources
    //

    try
    {
        ntStatus = RtlInitializeCriticalSection(pCritsec);

        if (!NT_SUCCESS(ntStatus))
        {
            ELF_LOG1(ERROR,
                     "ElfpInitCriticalSection: RtlInitializeCriticalSection failed %#x\n",
                     ntStatus);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG1(ERROR,
                 "ElfpInitCriticalSection: Exception %#x caught initializing critsec\n",
                 GetExceptionCode());

        ntStatus = STATUS_NO_MEMORY;
    }

    return ntStatus;
}


NTSTATUS
ElfpInitResource(
    PRTL_RESOURCE  pResource
    )
{
    NTSTATUS  ntStatus = STATUS_SUCCESS;

    //
    // RtlInitializeResource will raise an exception
    // if it runs out of resources
    //

    try
    {
        RtlInitializeResource(pResource);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG1(ERROR,
                 "ElfpInitResource: Exception %#x caught initializing resource\n",
                 GetExceptionCode());

        ntStatus = STATUS_NO_MEMORY;
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\eventlog.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This file contains the main routines for the NT Event Logging Service.

Author:

    Rajen Shah  (rajens)    1-Jul-1991

Revision History:

    02-Mar-01           drbeck
        Modified ElfWriteProductInfoEvent to utilize GetVersionEx for OS major
        and minor version numbers as well as for the build number. The
        value CurrentBuild under the HKLM/SOFTWARE/Microsoft/Windows NT/CurrentVersion 
        registry is obsolete.
        
    26-Jan-1994     Danl
        SetUpModules:  Fixed memory leak where the buffers for the enumerated
        key names were never free'd.  Also fixed problem where the size of
        the MULTI_SZ buffer used for the "Sources" key was calculated by
        using the names in the registry, while the copying was done
        using the names in the module list.  When registry keys are deleted,
        the module list entry is retained until the next boot.  Since the
        module list is larger, it would overwrite the MULTI_SZ buffer.

    1-Nov-1993      Danl
        Make Eventlog service a DLL and attach it to services.exe.
        Pass in GlobalData to Elfmain.  This GlobalData structure contains
        all well-known SIDs and pointers to the Rpc Server (Start & Stop)
        routines.  Get rid of the service process main function.

    1-Jul-1991      RajenS
        created

--*/

//
// INCLUDES
//

#include <eventp.h>
#include <ntrpcp.h>
#include <elfcfg.h>
#include <string.h>
#include <tstr.h>     // WCSSIZE
#include <alertmsg.h> // ALERT_ELF manifests


//
// Bit Flags used for Progress Reporting in SetupDataStruct().
//
#define LOGFILE_OPENED  0x00000001
#define MODULE_LINKED   0x00000002
#define LOGFILE_LINKED  0x00000004

HANDLE  g_hTimestampWorkitem;
HANDLE  g_hTimestampEvent;
ULONG   g_PreviousInterval = DEFAULT_INTERVAL;
long    g_lNumSecurityWriters = 0;

//
// Local Function Prorotypes
//
VOID
ElfInitMessageBoxTitle(
    VOID
    );



NTSTATUS
SetUpDataStruct (
    PUNICODE_STRING     LogFileName,
    ULONG               MaxFileSize,
    ULONG               Retention,
    ULONG               GuestAccessRestriction,
    PUNICODE_STRING     ModuleName,
    HANDLE              hLogFile,
    ELF_LOG_TYPE        LogType,
    LOGPOPUP            logpLogPopup,
    DWORD               dwAutoBackup
)

/*++

Routine Description:

    This routine sets up the information for one module. It is called from
    ElfSetUpConfigDataStructs for each module to be configured.

    Module information is passed into this routine and a LOGMODULE structure
    is created for it.  If the logfile associated with this module doesn't
    exist, a LOGFILE structure is created for it, and added to the linked
    list of LOGFILE structures.  The LOGMODULE is associated with the LOGFILE,
    and it is added to the linked list of LOGMODULE structures.  The logfile
    is opened and mapped to memory.

    Finally, at the end, this function calls SetUpModules, which looks at
    all the subkeys in the registry under this logfile, and adds any new ones
    to the linked list, and updates the Sources MULTI_SZ for the event viewer.

Arguments:

    LogFileName - Name of log file for this module.  If this routine needs
        a copy of this name it will make one, so that the caller can free
        the name afterwards if that is desired.

    MaxFileSize - Max size of the log file.
    Retention   - Max retention for the file.
    ModuleName  - Name of module that this file is associated with.
    RegistryHandle - Handle to the root node for this LogFile's info
                     in the registry.  This is used to enumerate all the
                     modules under this key.

Return Value:

    Pointer to Module structure that is allocated in this routine.
    NTSTATUS

Note:


--*/
{
    NTSTATUS        Status   = STATUS_SUCCESS;
    PLOGFILE        pLogFile = NULL;
    PLOGMODULE      pModule  = NULL;
    ANSI_STRING     ModuleNameA;
    DWORD           Type;
    BOOL            bAllocatedLogInfo   = FALSE;
    PUNICODE_STRING SavedBackupFileName = NULL;
    DWORD           StringLength;
    PLOGMODULE      OldDefaultLogModule = NULL;
    DWORD           Progress = 0L;

    //
    // Argument check.
    //

    if ((LogFileName == NULL)         ||
        (LogFileName->Buffer == NULL) ||
        (ModuleName == NULL))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // If the default log file for a module is also being used by another
    // module, then we just link that same file structure with the other
    // module.
    //
    // Truncate the maximum size of the log file to a 4K boundary.
    // This is to allow for page granularity.
    //

    pLogFile = FindLogFileFromName (LogFileName);

    pModule  = ElfpAllocateBuffer (sizeof (LOGMODULE) );

    if (pModule == NULL)
    {
        return(STATUS_NO_MEMORY);
    }

    if (pLogFile == NULL)
    {
        //
        //--------------------------------------
        // CREATE A NEW LOGFILE !!
        //--------------------------------------
        // A logfile by this name doesn't exist yet.  So we will create
        // one so that we can add the module to it.
        //

        ELF_LOG1(TRACE,
                "SetupDataStruct: Create new struct for %ws log\n",
                LogFileName->Buffer);

        pLogFile = ElfpAllocateBuffer(sizeof(LOGFILE));

        if (pLogFile == NULL)
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: Unable to allocate struct for %ws log\n",
                     LogFileName->Buffer);

            ElfpFreeBuffer(pModule);
            return STATUS_NO_MEMORY;
        }

        //
        // Allocate a new LogFileName that can be attached to the
        // new pLogFile structure.
        //
        StringLength = LogFileName->Length + sizeof(WCHAR);
        SavedBackupFileName = (PUNICODE_STRING) ElfpAllocateBuffer(
            sizeof(UNICODE_STRING) + StringLength);

        if (SavedBackupFileName == NULL)
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: Unable to allocate backup name for %ws log\n",
                     LogFileName->Buffer);

            ElfpFreeBuffer(pModule);
            ElfpFreeBuffer(pLogFile);
            return STATUS_NO_MEMORY;
        }

        SavedBackupFileName->Buffer = (LPWSTR)((LPBYTE) SavedBackupFileName +
            sizeof(UNICODE_STRING));

        SavedBackupFileName->Length = LogFileName->Length;
        SavedBackupFileName->MaximumLength = (USHORT) StringLength;
        RtlMoveMemory(SavedBackupFileName->Buffer, LogFileName->Buffer,
            LogFileName->Length);
        SavedBackupFileName->Buffer[SavedBackupFileName->Length / sizeof(WCHAR)] =
            L'\0';

        //
        // This is the first user - RefCount gets incrememted below
        //
        pLogFile->RefCount          = 0;
        pLogFile->FileHandle        = NULL;
        pLogFile->LogFileName       = SavedBackupFileName;
        pLogFile->ConfigMaxFileSize = ELFFILESIZE(MaxFileSize);
        pLogFile->Retention         = Retention;
        pLogFile->ulLastPulseTime   = 0;
        pLogFile->logpLogPopup      = logpLogPopup;
        pLogFile->bFullAlertDone = FALSE;
        pLogFile->AutoBackupLogFiles = dwAutoBackup;

        //
        // Save away the default module name for this file
        //
        pLogFile->LogModuleName = ElfpAllocateBuffer(
            sizeof(UNICODE_STRING) + ModuleName->MaximumLength);

        //
        // This flag can be set since pLogfile->LogModuleName
        // will be initialized after this point
        //
        bAllocatedLogInfo = TRUE;

        if (pLogFile->LogModuleName == NULL)
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: Unable to allocate module name for %ws log\n",
                     LogFileName->Buffer);

            Status = STATUS_NO_MEMORY;
            goto ErrorExit;
        }

        pLogFile->LogModuleName->MaximumLength = ModuleName->MaximumLength;
        pLogFile->LogModuleName->Buffer =
            (LPWSTR)(pLogFile->LogModuleName + 1);
        RtlCopyUnicodeString(pLogFile->LogModuleName, ModuleName);

        InitializeListHead (&pLogFile->Notifiees);

        pLogFile->NextClearMaxFileSize = pLogFile->ConfigMaxFileSize;

        Status = ElfpInitResource(&pLogFile->Resource);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: Unable to init resource for %ws log\n",
                     LogFileName->Buffer);

            goto ErrorExit;
        }

        LinkLogFile ( pLogFile );   // Link it in

        Progress |= LOGFILE_LINKED;

    } // endif (pLogfile == NULL)

    //--------------------------------------
    // ADD THE MODULE TO THE LOG MODULE LIST
    //--------------------------------------
    // Set up the module data structure for the default (which is
    // the same as the logfile keyname).
    //

    pLogFile->RefCount++;
    pModule->LogFile = pLogFile;
    pModule->ModuleName = (LPWSTR) ModuleName->Buffer;

    Status = RtlUnicodeStringToAnsiString (
                    &ModuleNameA,
                    ModuleName,
                    TRUE);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "SetupDataStruct: Unable to convert module name %ws to Ansi %#x\n",
                 ModuleName->Buffer,
                 Status);

        pLogFile->RefCount--;
        goto ErrorExit;
    }

    //
    // Link the new module in.
    //

    LinkLogModule(pModule, &ModuleNameA);

    RtlFreeAnsiString (&ModuleNameA);

    Progress |= MODULE_LINKED;

    //
    // Open up the file and map it to memory.  Impersonate the
    // caller so we can use UNC names
    //

    if (LogType == ElfBackupLog)
    {
        Status = RpcImpersonateClient(NULL);

        if (Status == RPC_S_OK)
        {
            Status = ElfOpenLogFile (pLogFile, LogType);
            RpcRevertToSelf();
        }
        else
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: RpcImpersonateClient failed %#x\n",
                     Status);
        }
    }
    else
    {
        Status = ElfOpenLogFile (pLogFile, LogType);
    }

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG3(ERROR,
                 "SetupDataStruct: Couldn't open %ws for module %ws %#x\n",
                 LogFileName->Buffer,
                 ModuleName->Buffer,
                 Status);

        if (LogType != ElfBackupLog)
        {
            ElfpCreateQueuedAlert(ALERT_ELF_LogFileNotOpened,
                                  1,
                                  &(ModuleName->Buffer));
        }

        pLogFile->RefCount--;
        goto ErrorExit;
    }

    Progress |= LOGFILE_OPENED;

    //
    // If this is the application module, remember the pointer
    // to use if a module doesn't have an entry in the registry
    //

    if (!_wcsicmp(ModuleName->Buffer, ELF_DEFAULT_MODULE_NAME))
    {
        OldDefaultLogModule = ElfDefaultLogModule;
        ElfDefaultLogModule = pModule;
    }

    //
    // Create the security descriptor for this logfile.  Only
    // the system and security modules are secured against
    // reads and writes by world.  Also, make sure we never
    // pop up a "log full" message for the Security log -- this
    // would be a C2 violation.
    //

    if (!_wcsicmp(ModuleName->Buffer, ELF_SYSTEM_MODULE_NAME))
    {
        Type = ELF_LOGFILE_SYSTEM;
    }
    else if (!_wcsicmp(ModuleName->Buffer, ELF_SECURITY_MODULE_NAME))
    {
        Type                   = ELF_LOGFILE_SECURITY;
        pLogFile->logpLogPopup = LOGPOPUP_NEVER_SHOW;
    }
    else
    {
        Type = ELF_LOGFILE_APPLICATION;
    }

    //
    // Create a Security Descriptor for this Logfile
    //   (RtlDeleteSecurityObject() can be used to free
    //    pLogFile->Sd).
    //
    Status = ElfpCreateLogFileObject(pLogFile, Type, GuestAccessRestriction);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "SetupDataStruct: Unable to create SD for log %ws %#x\n",
                 ModuleName->Buffer,
                 Status);

        pLogFile->RefCount--;
        goto ErrorExit;
    }

    //
    // Now that we've added the default module name, see if there are any
    // modules configured to log to this file, and if so, create the module
    // structures for them.
    //

    SetUpModules(hLogFile, pLogFile, FALSE);

    return STATUS_SUCCESS;

ErrorExit:

    if (Progress & LOGFILE_OPENED)
    {
        ElfpCloseLogFile(pLogFile, ELF_LOG_CLOSE_BACKUP);
    }

    if (Progress & MODULE_LINKED)
    {
        UnlinkLogModule(pModule);
        DeleteAtom(pModule->ModuleAtom);
    }

    if (bAllocatedLogInfo)
    {
        if (Progress & LOGFILE_LINKED)
        {
            UnlinkLogFile(pLogFile);
            RtlDeleteResource (&pLogFile->Resource);
        }

        ElfpFreeBuffer(pLogFile->LogModuleName);
        ElfpFreeBuffer(SavedBackupFileName);
        ElfpFreeBuffer(pLogFile);
    }

    ElfpFreeBuffer(pModule);

    if (OldDefaultLogModule != NULL)
    {
        ElfDefaultLogModule = OldDefaultLogModule;
    }

    return Status;
}


NTSTATUS
SetUpModules(
    HANDLE      hLogFile,
    PLOGFILE    pLogFile,
    BOOLEAN     bAllowDupes
    )
/*++

Routine Description:

    This routine sets up the information for all modules for a logfile.

    The subkeys under a logfile in the eventlog portion of the registry
    are enumerated.  For each unique subkey, a LOGMODULE structure is
    created.  Each new structures is added to a linked list
    of modules for that logfile.

    If there was one or more unique subkeys, meaning the list has changed
    since we last looked, then we go through the entire linked list of
    log modules, and create a MULTI_SZ list of all the modules.  This list
    is stored in the Sources value for that logfile for the event viewer
    to use.

    NOTE:  A module is never un-linked from the linked list of log modules
    even if the registry subkey for it is removed.  This should probably
    be done sometime.  It would make the eventlog more robust.

Arguments:

    hLogFile    - Registry key for the Log File node
    pLogFile    - pointer to the log file structure
    bAllowDupes - If true, it's ok to already have a module with the same
                  name (used when processing change notify of registry)

Return Value:

    NTSTATUS - If unsuccessful, it is not a fatal error.

        Even if this status is unsuccessful, me may have been able
        to store some of the new subkeys in the LogModule list.  Also, we
        may have been able to update the Sources MULTI_SZ list.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    BYTE        Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_NODE_INFORMATION KeyBuffer = (PKEY_NODE_INFORMATION) Buffer;
    ULONG       ActualSize;
    PWCHAR      SubKeyString;
    UNICODE_STRING NewModule;
    ANSI_STRING ModuleNameA;
    PLOGMODULE  pModule;
    ULONG       Index = 0;
    ATOM        Atom;
    PWCHAR      pList;
    DWORD       ListLength = 0;
    UNICODE_STRING ListName;
    BOOLEAN     ListChanged = FALSE;
    PLIST_ENTRY pListEntry;

    //
    // Create the module structures for all modules under this logfile.  We
    // don't actually need to open the key, since we don't use any information
    // stored there, it's existence is all we care about here.  Any data is
    // used by the Event Viewer (or any viewing app).  If this is used to
    // setup a backup file, hLogFile is NULL since there aren't any other
    // modules to map to this file.
    //

    while (NT_SUCCESS(Status) && hLogFile)
    {
        Status = NtEnumerateKey(hLogFile,
                                Index++,
                                KeyNodeInformation,
                                KeyBuffer,
                                ELF_MAX_REG_KEY_INFO_SIZE,
                                &ActualSize);

        if (NT_SUCCESS(Status))
        {
            //
            // It turns out the Name isn't null terminated, so we need
            // to copy it somewhere and null terminate it before we use it
            //

            SubKeyString = ElfpAllocateBuffer(KeyBuffer->NameLength + sizeof(WCHAR));

            if (!SubKeyString)
            {
                return STATUS_NO_MEMORY;
            }

            memcpy(SubKeyString, KeyBuffer->Name, KeyBuffer->NameLength);
            SubKeyString[KeyBuffer->NameLength / sizeof(WCHAR)] = L'\0' ;

            //
            // Add the atom for this module name
            //

            RtlInitUnicodeString(&NewModule, SubKeyString);

            Status = RtlUnicodeStringToAnsiString (
                            &ModuleNameA,
                            &NewModule,
                            TRUE);

            if (!NT_SUCCESS(Status))
            {
                //
                // We can't continue, so we will leave the modules
                // we've linked so far, and move on in an attempt to
                // create the Sources MULTI_SZ list.
                //
                ELF_LOG1(TRACE,
                         "SetUpModules: Unable to convert name for module %ws\n",
                         SubKeyString);

                ElfpFreeBuffer(SubKeyString);
                break;
            }

            Atom = FindAtomA(ModuleNameA.Buffer);

            //
            // Make sure we've not already added one by this name
            //

            if (FindModuleStrucFromAtom(Atom))
            {
                //
                // We've already encountered a module by this name.  If
                // this is init time, it's a configuration error.  Report
                // it and move on.  If we're processing a change notify
                // from the registry, this is ok (it means we're rescanning
                // an existing Event Source for an existing log).
                //
                if (!bAllowDupes)
                {
                    ELF_LOG1(ERROR,
                             "SetUpModules: Module %ws exists in two log files.\n",
                             SubKeyString);
                }

                RtlFreeAnsiString(&ModuleNameA);
                ElfpFreeBuffer(SubKeyString);
                continue;
            }

            ListChanged = TRUE;

            pModule  = ElfpAllocateBuffer (sizeof (LOGMODULE) );

            if (!pModule)
            {
                ELF_LOG1(ERROR,
                         "SetUpModules: Unable to allocate structure for module %ws\n",
                         SubKeyString);

                RtlFreeAnsiString (&ModuleNameA);
                ElfpFreeBuffer(SubKeyString);
                return(STATUS_NO_MEMORY);
            }

            //
            // Set up a module data structure for this module
            //

            pModule->LogFile = pLogFile;
            pModule->ModuleName = SubKeyString;

            //
            // Link the new module in.
            //

            LinkLogModule(pModule, &ModuleNameA);

            ELF_LOG1(TRACE,
                     "SetUpModules: Module %ws successfully created/linked\n",
                     SubKeyString);

            RtlFreeAnsiString (&ModuleNameA);
        }
    }

    if (Status == STATUS_NO_MORE_ENTRIES)
    {
        //
        // It's not required that there are configured modules for a log
        // file.
        //

        Status = STATUS_SUCCESS;
    }

    //
    // If the list has changed, or if we've been called during init, and not
    // as the result of a changenotify on the registry (bAllowDupes == FALSE)
    // then create the sources key
    //

    if (hLogFile && (ListChanged || !bAllowDupes))
    {
        //
        // Now create a MULTI_SZ entry with all the module names for eventvwr
        //
        // STEP 1: Calculate amount of storage needed by running thru the
        //         module list, finding any module that uses this log file.
        //
        pListEntry = LogModuleHead.Flink;

        while (pListEntry != &LogModuleHead)
        {
            pModule = CONTAINING_RECORD (pListEntry, LOGMODULE, ModuleList);

            if (pModule->LogFile == pLogFile)
            {
                //
                // This one is for the log we're working on, get the
                // size of its name.
                //
                ListLength += WCSSIZE(pModule->ModuleName);

                ELF_LOG2(MODULES,
                         "SetUpModules: Adding module %ws to list for %ws log\n",
                         pModule->ModuleName,
                         pLogFile->LogFileName->Buffer);
            }

            pListEntry = pModule->ModuleList.Flink;
        }

        //
        // STEP 2:  Allocate storage for the MULTI_SZ.
        //
        pList = ElfpAllocateBuffer(ListLength + sizeof(WCHAR));

        //
        // If I can't allocate the list, just press on
        //

        if (pList)
        {
            //
            // STEP 3: Copy all the module names for this logfile into
            //         the MULTI_SZ string.
            //
            SubKeyString = pList; // Save this away

            pListEntry = LogModuleHead.Flink;

            while (pListEntry != &LogModuleHead)
            {
                pModule = CONTAINING_RECORD(pListEntry,
                                            LOGMODULE,
                                            ModuleList);

                if (pModule->LogFile == pLogFile)
                {
                    //
                    // This one is for the log we're working on, put it in the list
                    //

                    wcscpy(pList, pModule->ModuleName);
                    pList += wcslen(pModule->ModuleName);
                    pList++;
                }

                pListEntry = pModule->ModuleList.Flink;
            }

            *pList = L'\0'; // The terminating NULL

            RtlInitUnicodeString(&ListName, L"Sources");

            Status = NtSetValueKey(hLogFile,
                                   &ListName,
                                   0,
                                   REG_MULTI_SZ,
                                   SubKeyString,
                                   ListLength + sizeof(WCHAR));

            ElfpFreeBuffer(SubKeyString);
        }
        else
        {
            ELF_LOG1(ERROR,
                     "SetUpModules: Unable to allocate list for %ws log\n",
                     pLogFile->LogFileName->Buffer);
        }
    }

    return Status;
}


NTSTATUS
ElfSetUpConfigDataStructs(
    VOID
    )

/*++

Routine Description:

    This routine sets up all the necessary data structures for the eventlog
    service.  It enumerates the keys in the Logfiles registry node to
    determine what to setup.

Arguments:

    NONE

Return Value:

    NONE

Note:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hLogFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING SubKeyName;
    PUNICODE_STRING pLogFileName = NULL;
    PUNICODE_STRING pModuleName = NULL;
    UNICODE_STRING EventlogModuleName;
    UNICODE_STRING EventlogSecModuleName;
    ULONG Index = 0;
    BYTE Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_NODE_INFORMATION KeyBuffer = (PKEY_NODE_INFORMATION) Buffer;
    ULONG ActualSize;
    LOG_FILE_INFO LogFileInfo;
    PWCHAR SubKeyString;
    LPWSTR ModuleName;

    ELF_LOG0(TRACE,
             "ElfSetUpConfigDataStructs: Entering\n");

    //
    // Initialize the Atom table whose size is the maximum number of
    // module structures possible, i.e. ELF_MAX_LOG_MODULES.
    //
    if (!InitAtomTable(ELF_MAX_LOG_MODULES))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get a handle to the Logfiles subkey.  If it doesn't exist, just use
    // the hard-coded defaults.
    //

    if (hEventLogNode)
    {
        //
        // Loop thru the subkeys under Eventlog and set up each logfile
        //

        while (NT_SUCCESS(Status))
        {
            Status = NtEnumerateKey(hEventLogNode,
                                    Index++,
                                    KeyNodeInformation,
                                    KeyBuffer,
                                    ELF_MAX_REG_KEY_INFO_SIZE,
                                    &ActualSize);

            if (NT_SUCCESS(Status))
            {
                //
                // It turns out the Name isn't null terminated, so we need
                // to copy it somewhere and null terminate it before we use it
                //

                SubKeyString = ElfpAllocateBuffer(KeyBuffer->NameLength + sizeof(WCHAR));

                if (!SubKeyString)
                {
                    return STATUS_NO_MEMORY;
                }

                memcpy(SubKeyString, KeyBuffer->Name, KeyBuffer->NameLength);
                SubKeyString[KeyBuffer->NameLength / sizeof(WCHAR)] = L'\0';

                //
                // Open the node for this logfile and extract the information
                // required by SetupDataStruct, and then call it.
                //

                RtlInitUnicodeString(&SubKeyName, SubKeyString);

                InitializeObjectAttributes(&ObjectAttributes,
                                           &SubKeyName,
                                           OBJ_CASE_INSENSITIVE,
                                           hEventLogNode,
                                           NULL);

                Status = NtOpenKey(&hLogFile,
                                   KEY_READ | KEY_SET_VALUE,
                                   &ObjectAttributes);

                if (!NT_SUCCESS(Status))
                {
                    //
                    // Unclear how this could happen since I just enum'ed
                    // it, but if I can't open it, I just pretend like it
                    // wasn't there to begin with.
                    //
                    ELF_LOG1(TRACE,
                             "ElfSetUpConfigDataStructs: Unable to open key for %ws log\n",
                             SubKeyName);

                    ElfpFreeBuffer(SubKeyString);
                    Status = STATUS_SUCCESS; // so we don't terminate the loop
                    continue;
                }

                //
                // Get the information from the registry.  Note that we have to
                // initialize the "log full" popup policy before doing so since
                // ReadRegistryInfo will compare the value found in the registry
                // (if there is one) to the current value.
                //

                LogFileInfo.logpLogPopup = IS_WORKSTATION() ? LOGPOPUP_NEVER_SHOW :
                                                              LOGPOPUP_CLEARED;

                Status = ReadRegistryInfo(hLogFile,
                                          &SubKeyName,
                                          &LogFileInfo);

                if (NT_SUCCESS(Status))
                {
                    //
                    // Now set up the actual data structures.  Failures are
                    // dealt with in the routine.  Note that the check for
                    // the security log (i.e., for LOGPOPUP_NEVER_SHOW) is
                    // made in SetUpDataStruct
                    //

                    SetUpDataStruct(LogFileInfo.LogFileName,
                                    LogFileInfo.MaxFileSize,
                                    LogFileInfo.Retention,
                                    LogFileInfo.GuestAccessRestriction,
                                    &SubKeyName,
                                    hLogFile,
                                    ElfNormalLog,
                                    LogFileInfo.logpLogPopup,
                                    LogFileInfo.dwAutoBackup);

                    NtClose(hLogFile);

                }
                else
                {
                    ELF_LOG1(ERROR,
                             "ElfSetUpConfigdataStructs: ReadRegistryInfo failed %#x\n",
                             Status);
                }
            }
        }
    } // if (hEventLogNode)
    else
    {
        LOGPOPUP  logpLogPopup = IS_WORKSTATION() ? LOGPOPUP_NEVER_SHOW :
                                                    LOGPOPUP_CLEARED;

        //
        // The information doesn't exist in the registry, set up the
        // three default logs.
        //
        pLogFileName = ElfpAllocateBuffer(sizeof(UNICODE_STRING));
        pModuleName =  ElfpAllocateBuffer(sizeof(UNICODE_STRING));

        if (!pLogFileName || !pModuleName)
        {
            ElfpFreeBuffer(pLogFileName);
            ElfpFreeBuffer(pModuleName);
            return STATUS_NO_MEMORY;
        }

        //
        // Application log
        //
        RtlInitUnicodeString(pLogFileName, ELF_APPLICATION_DEFAULT_LOG_FILE);
        RtlInitUnicodeString(pModuleName,  ELF_DEFAULT_MODULE_NAME);

        //
        // On success, don't free pModuleName as the pointer to it
        // is stored away in the LogFile struct
        //
        Status = SetUpDataStruct(pLogFileName,
                                 ELF_DEFAULT_MAX_FILE_SIZE,
                                 ELF_DEFAULT_RETENTION_PERIOD,
                                 ELF_GUEST_ACCESS_UNRESTRICTED,
                                 pModuleName,
                                 NULL,
                                 ElfNormalLog,
                                 logpLogPopup,
                                ELF_DEFAULT_AUTOBACKUP);

        ElfpFreeBuffer(pLogFileName);
        pLogFileName = NULL;

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfSetUpConfigDatastructs: Unable to set up %ws log\n",
                     ELF_DEFAULT_MODULE_NAME);

            ElfpFreeBuffer(pModuleName);
            pModuleName = NULL;
        }

        pLogFileName = ElfpAllocateBuffer(sizeof(UNICODE_STRING));
        pModuleName =  ElfpAllocateBuffer(sizeof(UNICODE_STRING));

        if (!pLogFileName || !pModuleName)
        {
            ElfpFreeBuffer(pLogFileName);
            ElfpFreeBuffer(pModuleName);
            return(STATUS_NO_MEMORY);
        }

        //
        // System log
        //
        RtlInitUnicodeString(pLogFileName, ELF_SYSTEM_DEFAULT_LOG_FILE);
        RtlInitUnicodeString(pModuleName,  ELF_SYSTEM_MODULE_NAME);

        Status = SetUpDataStruct(pLogFileName,
                                 ELF_DEFAULT_MAX_FILE_SIZE,
                                 ELF_DEFAULT_RETENTION_PERIOD,
                                 ELF_GUEST_ACCESS_UNRESTRICTED,
                                 pModuleName,
                                 NULL,
                                 ElfNormalLog,
                                 logpLogPopup,
                                ELF_DEFAULT_AUTOBACKUP);

        ElfpFreeBuffer(pLogFileName);
        pLogFileName = NULL;

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfSetUpConfigDatastructs: Unable to set up %ws log\n",
                     ELF_SYSTEM_MODULE_NAME);

            ElfpFreeBuffer(pModuleName);
            pModuleName = NULL;
        }

        pLogFileName = ElfpAllocateBuffer(sizeof(UNICODE_STRING));
        pModuleName  = ElfpAllocateBuffer(sizeof(UNICODE_STRING));

        if (!pLogFileName || !pModuleName)
        {
            ElfpFreeBuffer(pLogFileName);
            ElfpFreeBuffer(pModuleName);
            return(STATUS_NO_MEMORY);
        }

        //
        // Security log
        //
        RtlInitUnicodeString(pLogFileName, ELF_SECURITY_DEFAULT_LOG_FILE);
        RtlInitUnicodeString(pModuleName,  ELF_SECURITY_MODULE_NAME);

        Status = SetUpDataStruct(pLogFileName,
                                 ELF_DEFAULT_MAX_FILE_SIZE,
                                 ELF_DEFAULT_RETENTION_PERIOD,
                                 ELF_GUEST_ACCESS_UNRESTRICTED,
                                 pModuleName,
                                 NULL,
                                 ElfNormalLog,
                                 LOGPOPUP_NEVER_SHOW,
                                ELF_DEFAULT_AUTOBACKUP);    // Never popup for the security log

        ElfpFreeBuffer(pLogFileName);
        pLogFileName = NULL;

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfSetUpConfigDatastructs: Unable to set up %ws log\n",
                     ELF_SECURITY_MODULE_NAME);

            ElfpFreeBuffer(pModuleName);
            pModuleName = NULL;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // If we just ran out of keys, that's OK (unless there weren't any at all)
    //
    if (Status == STATUS_NO_MORE_ENTRIES && Index != 1)
    {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Make sure we created the Application log file, since it is the
        // default.  If it wasn't created, use the first module created
        // (this is at the tail of the list since I insert them at the
        // head).  If this happens, send an alert to the admin.
        //

        if (!ElfDefaultLogModule)
        {
            ELF_LOG0(ERROR,
                     "ElfSetUpConfigDatastructs: No Application module -- creating default\n");

            if (IsListEmpty(&LogModuleHead))
            {
                //
                // No logs were created, might as well shut down
                //
                ELF_LOG0(ERROR,
                         "ElfSetUpConfigDatastructs: No logs created -- exiting\n");

                return STATUS_EVENTLOG_CANT_START;
            }

            ElfDefaultLogModule = CONTAINING_RECORD(LogModuleHead.Blink,
                                                    LOGMODULE,
                                                    ModuleList);

            ModuleName = ELF_DEFAULT_MODULE_NAME;

            ELF_LOG2(ERROR,
                     "ElfSetUpConfigDatastructs: Using file/default %ws/%ws as default log\n",
                     ElfDefaultLogModule->LogFile->LogFileName->Buffer,
                     ElfDefaultLogModule->LogFile->LogModuleName->Buffer);

            ElfpCreateQueuedAlert(ALERT_ELF_DefaultLogCorrupt,
                                  1,
                                  &(ElfDefaultLogModule->LogFile->LogModuleName->Buffer));
        }

        //
        // Now get the Module for the Eventlog service to use.  GetModuleStruc
        // always succeeds, returning the default log if the requested one
        // isn't configured.
        //

        RtlInitUnicodeString(&EventlogModuleName, L"eventlog");
        ElfModule = GetModuleStruc(&EventlogModuleName);
        RtlInitUnicodeString(&EventlogSecModuleName, L"SECURITY");
        ElfSecModule = GetModuleStruc(&EventlogSecModuleName);
        
    }

    return Status;
}


VOID
ElfWriteTimeStamp(
    TIMESTAMPEVENT  EventType,
    BOOLEAN         CheckPreviousStamp
    )
/*++

Routine Description:

    This routine writes a time stamp in the form of a systemtime structure
    to the registry which is then used to extract reliability data.

Arguments:

    EventType          - Indicates what type of event we are logging
    CheckPreviousStamp - Whether we should check for the existance of a previous
                         time stamp which indicates a prior system crash.
Return Value:

    NONE

Note:


--*/
{
    SYSTEMTIME  stCurrentUTCTime;
    SYSTEMTIME  stPreviousUTCTime;
    SYSTEMTIME  stPreviousLocalTime;
    DWORD dwDirtyFlag = 1;

    HKEY        hKey;
    LONG        rc;
    DWORD       ValueSize;
    ULONG       Interval = DEFAULT_INTERVAL;
    ULONG       wchars;
    LPWSTR      DateTimeBuffer[2];

    rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                        REGSTR_PATH_RELIABILITY,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL);

    if (rc != ERROR_SUCCESS)
    {
        return;
    }

    if (EventType == EVENT_NormalShutdown)
    {
        //
        // Delete the time stamp registry value, this is how we indicate a clean shutdown
        //
        RegDeleteValue(hKey, REGSTR_VAL_LASTALIVESTAMP);
        RegFlushKey(hKey);
        RegCloseKey(hKey);
        return;
    }

    //
    // Get the current UTC time
    //

    GetSystemTime(&stCurrentUTCTime);

    if (CheckPreviousStamp)
    {
        ValueSize = sizeof(SYSTEMTIME);

        rc = RegQueryValueEx(hKey,
                             REGSTR_VAL_LASTALIVESTAMP,
                             0,
                             NULL,
                             (PUCHAR) &stPreviousUTCTime,
                             &ValueSize);

        //
        // If we can successfully read a systemtime structure it indicates
        // that the previous shutdown was abnormal, i.e. we didn't execute
        // or normal shutdown cleanup code.
        //

        //
        // Format the time and date of the crash time stamp
        // appropriately for the locale and log a #6008 event
        //


        if ((rc == ERROR_SUCCESS) && (ValueSize == sizeof(SYSTEMTIME)))
        {
            SYSTEMTIME  lpData[2];          // Data for the event

            if (!SystemTimeToTzSpecificLocalTime(NULL,
                                                 &stPreviousUTCTime,
                                                 &stPreviousLocalTime))
            {
                //
                // Couldn't convert to the active time zone -- use UTC
                //
                stPreviousLocalTime = stPreviousUTCTime;
            }

            //
            // Write the local time and the UTC time for the "last alive"
            // timestamp since NT4SP5 shipped with only the local time
            // as the event data.  This allows tools that work on NT4SP5
            // to continue working on NT5.
            //
            lpData[0] = stPreviousLocalTime;
            lpData[1] = stPreviousUTCTime;

            wchars = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                   0,
                                   &stPreviousLocalTime,
                                   NULL,
                                   NULL,
                                   0);

            DateTimeBuffer[0] = ElfpAllocateBuffer(wchars * sizeof(WCHAR));

            if (DateTimeBuffer[0])
            {
                GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                              0,
                              &stPreviousLocalTime,
                              NULL,
                              DateTimeBuffer[0],
                              wchars);

                wchars = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                       0,
                                       &stPreviousLocalTime,
                                       NULL,
                                       NULL,
                                       0);

                DateTimeBuffer[1] = ElfpAllocateBuffer(wchars * sizeof(WCHAR));

                if (DateTimeBuffer[1])
                {
                    GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                  0,
                                  &stPreviousLocalTime,
                                  NULL,
                                  DateTimeBuffer[1],
                                  wchars);

                    ElfpCreateElfEvent(
                        EVENT_EventlogAbnormalShutdown,
                        EVENTLOG_ERROR_TYPE,
                        0,                        // EventCategory
                        2,                        // NumberOfStrings
                        DateTimeBuffer,           // Strings
                        lpData,                   // "Last alive" times
                        2 * sizeof(SYSTEMTIME),   // Datalength
                        0,
                        FALSE);                       // flags

                    ElfpFreeBuffer(DateTimeBuffer[1]);
			        RegSetValueEx(hKey,
                     L"DirtyShutDown",
                     0,
                     REG_DWORD,
                     (PUCHAR) &dwDirtyFlag,
                     sizeof(DWORD));
                }

                ElfpFreeBuffer(DateTimeBuffer[0]);

            }
        }
    }

    //
    // Set the current time stamp
    //
    RegSetValueEx(hKey,
                  REGSTR_VAL_LASTALIVESTAMP,
                  0,
                  REG_BINARY,
                  (PUCHAR) &stCurrentUTCTime,
                  sizeof(SYSTEMTIME));

    RegFlushKey (hKey);
    RegCloseKey (hKey);
}


VOID
ElfWriteProductInfoEvent (
    VOID
    )
/*++

Routine Description:

    This function writes an event #6009 which includes the OS version, build #,
    service pack level, MP/UP, and Free/Checked.

Arguments:

    NONE

Return Value:

    NONE

Note:


--*/

{

#define NUM_INFO_VALUES     4  //EVENT_EventLogProductInfo requires 4 parameters
#define NUM_VERSION_SIZE    10 //Digits in a DWORD

    NTSTATUS        Status      = STATUS_SUCCESS;
    HKEY            hKey        = NULL;
    ULONG           ValueSize   = 0;
    LPWSTR          NullString  = L"";

    LPWSTR          StringBuffers[NUM_INFO_VALUES] = {NULL, NULL, NULL, NULL};
    
    OSVERSIONINFOEX OsVersion;
    WCHAR           wszTemp[NUM_VERSION_SIZE];
    UINT            i;


    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if( !GetVersionEx( (LPOSVERSIONINFO)&OsVersion ) )
    {
        return;
    }
    
    //Allocate storage

    //Buffer 0 holds the version number in the format of 5.xx.
    StringBuffers[0] = ElfpAllocateBuffer( (2*NUM_VERSION_SIZE + 2) * sizeof(WCHAR) );

    //Buffer 1 holds the build number
    StringBuffers[1] = ElfpAllocateBuffer( (NUM_VERSION_SIZE)       * sizeof(WCHAR) );

    //Buffer 2 holds the service pack
    StringBuffers[2] = ElfpAllocateBuffer( sizeof(OsVersion.szCSDVersion)           );

    if( StringBuffers[0] == NULL || 
        StringBuffers[1] == NULL || 
        StringBuffers[2] == NULL )
    {
        goto ErrorExit;
    }

    //
    //Add major version
    //
    _ltow (
        OsVersion.dwMajorVersion,
        wszTemp,
        10
    );

    wcscpy( StringBuffers[0], wszTemp );
    wcscat( StringBuffers[0], L"."    );

    //
    //Add minor version
    //
    _ltow (
        OsVersion.dwMinorVersion,
        wszTemp,
        10
    );

    if( OsVersion.dwMinorVersion < 10 )
    {
        wcscat( StringBuffers[0], L"0" );
    }

    wcscat( StringBuffers[0], wszTemp );
    wcscat( StringBuffers[0], L"."    );

    //
    //Get build number
    //
    _ltow (
        OsVersion.dwBuildNumber,
        wszTemp,
        10
    );

    wcscpy( StringBuffers[1], wszTemp );

    //Get service pack info
    wcscpy( StringBuffers[2], OsVersion.szCSDVersion );

    //
    // Get OS type (uniprocessor or multiprocessor chk or free)
    // Open HKLM\Software\Microsoft\Windows NT\CurrentVersion
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_NT_CURRENTVERSION,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey)

        != ERROR_SUCCESS)
    {
        goto ErrorExit;
    }

    //
    // For each of the registry values, query for the string size, allocate storage,
    // and query the actual value
    //
    if ((RegQueryValueEx (hKey,
                          REGSTR_VAL_CURRENT_TYPE,
                          0,
                          NULL,
                          NULL,
                          &ValueSize)
         == ERROR_SUCCESS)

         &&

         ValueSize != 0)
    {
        StringBuffers[3] = ElfpAllocateBuffer(ValueSize);

        if (StringBuffers[3] != NULL) 
            {

                RegQueryValueEx(hKey,
                                REGSTR_VAL_CURRENT_TYPE,
                                0,
                                NULL,
                                (PUCHAR) StringBuffers[3],
                                &ValueSize);
    
                ValueSize = 0;
            }
    }
    else
    {
        StringBuffers[3] = NullString;
    }

    ElfpCreateElfEvent(
        EVENT_EventLogProductInfo,
        EVENTLOG_INFORMATION_TYPE,
        0,                            // EventCategory
        NUM_INFO_VALUES,              // NumberOfStrings
        StringBuffers,                // Strings
        NULL,                         // EventData
        0,                            // Datalength
        0,
        FALSE);                           // flags

    
ErrorExit:

    for (i = 0; i < NUM_INFO_VALUES-1; i++)
    {
        if (StringBuffers[i] != NULL && StringBuffers[i] != NullString)
        {
            ElfpFreeBuffer(StringBuffers[i]);
        }
    }

    if( hKey != NULL )
    {
        RegCloseKey (hKey);
    }

#undef NUM_INFO_VALUES
#undef NUM_VERSION_SIZE

}


VOID
TimeStampProc(
    PVOID   Interval,
    BOOLEAN fWaitStatus
    )
{
    NTSTATUS ntStatus;
    HANDLE   hWaitHandle;
    ULONG    ValueSize;
    HKEY     hKey;
    ULONG    NewInterval;
    ULONG    rc;

    //
    // Deregister the wait (note that we must do this even
    // if the WT_EXECUTEONLYONCE flag is set)
    //
    ntStatus = RtlDeregisterWait(g_hTimestampWorkitem);

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "TimeStampProc: RtlDeregister wait failed %#x\n",
                  ntStatus);
    }

    if (fWaitStatus == FALSE)
    {
        //
        // The event log service is stopping
        //

        return;
    }

    //
    // Note:  NewInterval is specified in minutes
    //
    NewInterval = (ULONG)((ULONG_PTR)Interval);

    //
    //  The event timed out -- write a timestamp
    //

    ElfWriteTimeStamp (EVENT_AbNormalShutdown, FALSE);

    //
    // recheck the time stamp interval value
    //

    rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                        REGSTR_PATH_RELIABILITY,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL);

    if ( rc == ERROR_SUCCESS )
    {
        ValueSize = sizeof (ULONG);

        rc = RegQueryValueEx(hKey,
                             REGSTR_VAL_LASTALIVEINTERVAL,
                             0,
                             NULL,
                             (PUCHAR) &NewInterval,
                             &ValueSize);

        if ( rc != ERROR_SUCCESS )
        {
            //
            // Couldn't get the value -- stop timestamping
            //
            return;
        }

        RegCloseKey (hKey);
    }

    if (NewInterval != 0)
    {
        //
        // Reregister the wait
        //

        ntStatus = RtlRegisterWait(&g_hTimestampWorkitem,
                                   g_hTimestampEvent,
                                   TimeStampProc,           // Callback
                                   (PVOID) UlongToPtr(NewInterval),     // Context
                                   NewInterval * 60 * 1000, // Timeout, in ms
                                   WT_EXECUTEONLYONCE);
    }

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "TimeStampProc: RtlRegisterWait failed %#x\n",
                 ntStatus);
    }
}


NTSTATUS EnsureComputerName(
	)
/*++

Routine Description:

    This routine ensures that the computer name.

Arguments:

Return Value:

    status value, STATUS_SUCCESS if all is well.

--*/

{
    NTSTATUS           Status;
    UNICODE_STRING     ValueName;
    ULONG              ulActualSize;
	WCHAR wComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
	DWORD dwLen;
	BOOL bRet;
	BYTE            Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION ValueBuffer =
        (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    RtlInitUnicodeString(&ValueName, VALUE_COMPUTERNAME);

	// Determine if there is a String under the eventlog key that
	// contains the current name.

    Status = NtQueryValueKey(hEventLogNode,
                             &ValueName,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);
	
    if (NT_SUCCESS(Status))
    {
        if(ValueBuffer->DataLength != 0)
        	return STATUS_SUCCESS;	// all is well, there is already a string
    }

	// Get the computer name and write it

    bRet = GetComputerName(wComputerName, &dwComputerNameLen);
    if(bRet == FALSE)
    {
        ELF_LOG1(ERROR,
                 "EnsureComputerName: GetComputerName failed %#x\n",
                 GetLastError());
		return STATUS_UNSUCCESSFUL;
    }

	// calc size in byte including null

	dwLen = sizeof(WCHAR) * (dwComputerNameLen + 1);
    Status = NtSetValueKey(hEventLogNode,
                                   &ValueName,
                                   0,
                                   REG_SZ,
                                   wComputerName,
                                   dwLen);
	
    if (!NT_SUCCESS(Status))
        ELF_LOG1(ERROR,
                 "EnsureComputerName: NtSetValueKey failed %#x\n",
                 Status);
	return Status;
}

VOID
SvcEntry_Eventlog(
    DWORD               argc,
    LPWSTR              argv[],
    PSVCS_GLOBAL_DATA   SvcsGlobalData,
    HANDLE              SvcRefHandle
    )

/*++

Routine Description:

    This is the main routine for the Event Logging Service.

Arguments:

    Command-line arguments.

Return Value:

    NONE

--*/
{
    NTSTATUS           Status;
    OBJECT_ATTRIBUTES  ObjectAttributes;
    UNICODE_STRING     RootRegistryNode;
    UNICODE_STRING     ComputerNameRegistryNode;
    ULONG              Win32Error = NO_ERROR;
    ELF_REQUEST_RECORD FlushRequest;
    BYTE               Buffer[ELF_MAX_REG_KEY_INFO_SIZE];

    PKEY_VALUE_FULL_INFORMATION ValueBuffer = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    HKEY        hKey;
    ULONG       ValueSize = sizeof(ULONG);

#if DBG

    UNICODE_STRING     ValueName;
    ULONG              ulActualSize;

#endif  // DBG

    g_lNumSecurityWriters = 0;

    //
    // Set up the object that describes the root node for the eventlog service
    //
    RtlInitUnicodeString(&RootRegistryNode, REG_EVENTLOG_NODE_PATH);
    InitializeObjectAttributes(&ObjectAttributes,
                               &RootRegistryNode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // If this fails, we'll just use the defaults
    //
    Status = NtOpenKey(&hEventLogNode, KEY_READ | KEY_NOTIFY | KEY_SET_VALUE, &ObjectAttributes);
    if (NT_SUCCESS(Status))
    {
        Status = EnsureComputerName();
	    if (!NT_SUCCESS(Status))
	    {
	        //
	        // Not much we can do here as we don't even have a
	        // SERVICE_STATUS_HANDLE at this point.
	        //
	        return;
	    }
    }


    RtlInitUnicodeString(&ComputerNameRegistryNode, REG_COMPUTERNAME_NODE_PATH);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ComputerNameRegistryNode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&hComputerNameNode, KEY_READ | KEY_NOTIFY, &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: NtOpenKey for ComputerName failed %#x -- exiting\n",
                 Status);

        //
        // Not much we can do here as we don't even have a
        // SERVICE_STATUS_HANDLE at this point.
        //
        return;
    }

///////////////////////////////////////////////////////

#if DBG

    //
    // See if there's a debug value
    //
    RtlInitUnicodeString(&ValueName, VALUE_DEBUG);

    Status = NtQueryValueKey(hEventLogNode,
                             &ValueName,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);

    if (NT_SUCCESS(Status))
    {
        if (((PKEY_VALUE_PARTIAL_INFORMATION) ValueBuffer)->Type == REG_DWORD)
        {
            ElfDebugLevel = *(LPDWORD) (((PKEY_VALUE_PARTIAL_INFORMATION) ValueBuffer)->Data);
        }
    }

    ELF_LOG1(TRACE,
             "SvcEntry_Eventlog: ElfDebugLevel = %#x\n",
             ElfDebugLevel);

#endif  // DBG


    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    ElfGlobalSvcRefHandle = SvcRefHandle;
    ElfGlobalData         = SvcsGlobalData;

    //
    // Initialize the list heads for the modules and log files.
    //
    InitializeListHead(&LogFilesHead);
    InitializeListHead(&LogModuleHead);
    InitializeListHead(&QueuedEventListHead);
    InitializeListHead(&QueuedMessageListHead);

    //
    // Initialize to 0 so that we can clean up before exiting
    //
    EventFlags = 0;

    //
    // Create the Eventlog's private heap if possible.  This must be
    // done before any calls to ElfpAllocateBuffer are made.
    //
    ElfpCreateHeap();

    //
    // Initialize the status data.
    //
    Status = ElfpInitStatus();

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: ElfpInitStatus failed %#x -- exiting\n",
                 Status);

        //
        // Not much we can do here as we don't even have a
        // SERVICE_STATUS_HANDLE at this point.
        //
        return;
    }

    //
    // Set up control handler
    //
    if ((ElfServiceStatusHandle = RegisterServiceCtrlHandler(
                                      EVENTLOG_SVC_NAMEW,
                                      ElfControlResponse)) == 0)
    {
        Win32Error = GetLastError();

        //
        // If we got an error, we need to set status to uninstalled, and end the
        // thread.
        //
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: RegisterServiceCtrlHandler failed %#x\n",
                 Win32Error);

        goto cleanupandexit;
    }

    //
    // Notify the Service Controller for the first time that we are alive
    // and are in a start pending state
    //
    //  *** UPDATE STATUS ***
    ElfStatusUpdate(STARTING);

    //
    // Get the localized title for message box popups.
    //
    ElfInitMessageBoxTitle();

    //
    // Initialize a critical section for use when adding or removing
    // LogFiles or LogModules. This must be done before we process any
    // file information.
    //
    Status = ElfpInitCriticalSection(&LogFileCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create LogFileCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_LOGFILE_CRIT_SEC;

    Status = ElfpInitCriticalSection(&LogModuleCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create LogModuleCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_LOGMODULE_CRIT_SEC;

    Status = ElfpInitCriticalSection(&QueuedEventCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create QueuedEventCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_QUEUED_EVENT_CRIT_SEC;

    Status = ElfpInitCriticalSection(&QueuedMessageCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create QueuedMessageCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_QUEUED_MESSAGE_CRIT_SEC;

    //
    // Initialize global anonymous logon sid for use in log ACL's.
    //

    Status = RtlAllocateAndInitializeSid(
                &NtAuthority,
                1,
                SECURITY_ANONYMOUS_LOGON_RID,
                0, 0, 0, 0, 0, 0, 0,
                &AnonymousLogonSid);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create anonymous logon SID %#x\n",
                 Status);

        goto cleanupandexit;
    }

    //
    // Set up the data structures for the Logfiles and Modules.
    //

    Status = ElfSetUpConfigDataStructs();

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: ElfSetUpConfigDataStructs failed %#x\n",
                 Status);

        goto cleanupandexit;
    }

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STARTING);

    //
    // Initialize a critical section for use when adding or removing
    // context handles (LogHandles).
    //
    Status = ElfpInitCriticalSection(&LogHandleCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create LogHandleCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_LOGHANDLE_CRIT_SEC;

    //
    // Initialize the context handle (log handle) list.
    //
    InitializeListHead( &LogHandleListHead );

    //
    // Initialize the Global Resource.
    //
    Status = ElfpInitResource(&GlobalElfResource);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create GlobalElfResource %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_GLOBAL_RESOURCE;

    //
    //Initialize a CritSec for clustering support
    //
    Status = ElfpInitCriticalSection(&gClPropCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create gClPropCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_CLUS_CRIT_SEC;

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STARTING);

    // Create a thread for watching the LPC port.
    //

    if (!StartLPCThread())
    {
        ELF_LOG0(ERROR,
                 "SvcEntry_Eventlog: StartLPCThread failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanupandexit;
    }

    EventFlags |= ELF_STARTED_LPC_THREAD;

    //
    // Tell service controller of that we are making progress
    //
    ElfStatusUpdate(STARTING);

    //
    // Create a thread for watching for changes in the registry.
    //
    if (!ElfStartRegistryMonitor())
    {
        ELF_LOG0(ERROR,
                 "SvcEntry_Eventlog: ElfStartRegistryMonitor failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanupandexit;
    }

    EventFlags |= ELF_STARTED_REGISTRY_MONITOR;

    //
    // Write out an event that says we started
    //

    ElfpCreateElfEvent(EVENT_EventlogStarted,
                       EVENTLOG_INFORMATION_TYPE,
                       0,                    // EventCategory
                       0,                    // NumberOfStrings
                       NULL,                 // Strings
                       NULL,                 // Data
                       0,                    // Datalength
                       0,
                       FALSE);                   // flags

    //
    // Write a boot event with version info
    //
    ElfWriteProductInfoEvent();

	// Write a computer name change event if that is applicable

	ElfCheckForComputerNameChange();
	
    //
    // Read from the registry to determine the time stamp interval, default to 5 minutes
    //
    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_RELIABILITY,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey);

    if (Status == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey,
                        REGSTR_VAL_LASTALIVEINTERVAL,
                        0,
                        NULL,
                        (PUCHAR) &g_PreviousInterval,
                        &ValueSize);

        RegCloseKey (hKey);
    }
    //
    // If this is setup, then dont do the periodic timestamp writting
    // Setup has the feature where the last write is ignored and so
    // the code acted as if a dirty shutdown happened.
    //

    if(SvcsGlobalData->fSetupInProgress)
    {
        g_PreviousInterval = 0;     // stops the timer thread from starting    
        ElfWriteTimeStamp(EVENT_NormalShutdown,
                          FALSE);   // clears out the time stamp.
    }

    if (g_PreviousInterval != 0)
    {
        //
        // Write out the first timer based abnormal shutdown time stamp
        //

        ElfWriteTimeStamp (EVENT_AbNormalShutdown, TRUE);
    }

    //
    // Write out any events that were queued up during initialization
    //

    FlushRequest.Command = ELF_COMMAND_WRITE_QUEUED;

    ElfPerformRequest(&FlushRequest);

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STARTING);

    //
    // Finish setting up the RPC server
    //
    // NOTE:  Now all RPC servers in services.exe share the same pipe name.
    // However, in order to support communication with version 1.0 of WinNt,
    // it is necessary for the Client Pipe name to remain the same as
    // it was in version 1.0.  Mapping to the new name is performed in
    // the Named Pipe File System code.
    //
    Status = ElfGlobalData->StartRpcServer(
                ElfGlobalData->SvcsRpcPipeName,
                eventlog_ServerIfHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: StartRpcServer failed %#x\n",
                 Status);

        goto cleanupandexit;
    }

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(RUNNING);

    EventFlags |= ELF_STARTED_RPC_SERVER;

    if (GetElState() == RUNNING)
    {
        if ( g_PreviousInterval != 0 )
        {
            //
            // Create a thread to periodically write
            // a time stamp to the registry.
            //

            g_hTimestampEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

            if (g_hTimestampEvent != NULL)
            {
                Status = RtlRegisterWait(&g_hTimestampWorkitem,
                                         g_hTimestampEvent,
                                         TimeStampProc,              // Callback
                                         (PVOID) UlongToPtr(g_PreviousInterval), // Context
                                         0,                          // Timeout
                                         WT_EXECUTEONLYONCE);

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "SvcEntry_Eventlog: RtlRegisterWait failed %#x\n",
                             Status);
                }
            }
            else
            {
                ELF_LOG1(ERROR,
                         "SvcEntry_Eventlog: CreateEvent for timestamp failed %d\n",
                         GetLastError());
            }
        }

        ELF_LOG0(TRACE,
                 "SvcEntry_Eventlog: Service running -- main thread returning\n");

        return;
    }

cleanupandexit:

    //
    // Come here if there is cleanup necessary.
    //
    ELF_LOG0(ERROR,
             "SvcEntry_Eventlog: Exiting on error\n");

    if (Win32Error == NO_ERROR)
    {
        Win32Error = RtlNtStatusToDosError(Status);
    }

    ElfBeginForcedShutdown(PENDING, Win32Error, Status);

    //
    // If the registry monitor has been initialized, then
    // let it do the shutdown cleanup.  All we need to do
    // here is wake it up.
    // Otherwise, this thread will do the cleanup.
    //
    if (EventFlags & ELF_STARTED_REGISTRY_MONITOR)
    {
        StopRegistryMonitor();
    }
    else
    {
        ElfpCleanUp(EventFlags);
    }

    return;
}


VOID
ElfInitMessageBoxTitle(
    VOID
    )

/*++

Routine Description:

    Obtains the title text for the message box used to display messages.
    If the title is successfully obtained from the message file, then
    that title is pointed to by GlobalAllocatedMsgTitle and
    GlobalMessageBoxTitle.  If unsuccessful, then GlobalMessageBoxTitle
    left pointing to the DefaultMessageBoxTitle.

    NOTE:  If successful, a buffer is allocated by this function.  The
    pointer stored in GlobalAllocatedMsgTitle and it should be freed when
    done with this buffer.

Arguments:

Return Value:

    none

--*/
{
    LPVOID      hModule;
    DWORD       msgSize;

    //
    // This function should be called only once during initialization.  Note
    // that it needs to be called before the Eventlog's RPC server is started
    // or else it's possible for the log to fill up, which will generate a
    // "log full" popup with no title (since GlobalMessageBoxTitle is NULL).
    //
    ASSERT(GlobalMessageBoxTitle == NULL);

    hModule = LoadLibraryEx(L"netevent.dll",
                            NULL,
                            LOAD_LIBRARY_AS_DATAFILE);

    if ( hModule == NULL)
    {
        ELF_LOG1(ERROR,
                 "ElfInitMessageBoxTitle: LoadLibrary of netevent.dll failed %d\n",
                 GetLastError());

        return;
    }

    msgSize = FormatMessageW(
                FORMAT_MESSAGE_FROM_HMODULE |       //  dwFlags
                  FORMAT_MESSAGE_ARGUMENT_ARRAY |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hModule,
                TITLE_EventlogMessageBox,           //  MessageId
                0,                                  //  dwLanguageId
                (LPWSTR) &GlobalMessageBoxTitle,    //  lpBuffer
                0,                                  //  nSize
                NULL);

    if (msgSize == 0)
    {
        ELF_LOG2(ERROR,
                 "ElfInitMessageBoxTitle: FormatMessage failed %d -- using %ws\n",
                 GetLastError(),
                 ELF_DEFAULT_MESSAGE_BOX_TITLE);

        GlobalMessageBoxTitle = ELF_DEFAULT_MESSAGE_BOX_TITLE;
    }

    FreeLibrary(hModule);
    return;
}


#ifdef EXIT_PROCESS

//
// This code is compiled into the Eventlog to track down a DLL that's loaded
// into services.exe and calls ExitProcess.  Since this DLL should never be
// unloaded, we break into the debugger on DLL_PROCESS_DETACH.  To use this,
// the following need to be added to the sources file:
//
// DLLENTRY=  DllInit
//
// -DEXIT_PROCESS  (to the C_DEFINES line)
//

BOOL
DllInit(
    IN  HINSTANCE   hDll,
    IN  DWORD       dwReason,
    IN  PCONTEXT    pContext OPTIONAL
    )
{
    switch (dwReason) {

        case DLL_PROCESS_ATTACH:

            //
            // No notification of THREAD_ATTACH and THREAD_DETACH
            //
            DisableThreadLibraryCalls(hDll);
            break;

        case DLL_PROCESS_DETACH:

            //
            // This should NEVER happen -- it means services.exe
            // is exiting via an ExitProcess call
            //
            DebugBreak();
            break;
    }

    return TRUE;
}

#endif  // EXIT_PROCESS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\eventp.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    eventp.h

Abstract:

    Private include file for eventlog service

Author:

    Rajen Shah (rajens) 12-Jul-1991

Revision History:

--*/

#define UNICODE             // This service uses unicode APIs

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntelfapi.h>
#include <netevent.h>       // Manifest constants for Events

#include <windows.h>
#include <winsvc.h>

#include <lmcons.h>
#include <lmerr.h>
#include <rpc.h>
#include <svcsp.h>          // SVCS_ENTRY_POINT, PSVCS_GLOBAL_DATA
#include <regstr.h>

#include <elf.h>

#include <elfdef.h>
#include <elfcommn.h>
#include <elfproto.h>
#include <elfextrn.h>

#include <elfdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\logclear.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    logclear.c

Abstract:

    Contains functions used to log an event indicating who cleared the log.
    This is only called after the security log has been cleared.

Author:

    Dan Lafferty (danl)     01-July-1994

Environment:

    User Mode -Win32

Revision History:

    01-July-1994    danl & robertre
        Created - Rob supplied the code which I fitted into the eventlog.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <msaudite.h>
#include <eventp.h>
#include <tstr.h>
#include <winsock2.h>

#define NUM_STRINGS     6


//
// LOCAL FUNCTION PROTOTYPES
//
BOOL
GetUserInfo(
    IN HANDLE Token,
    OUT LPWSTR *UserName,
    OUT LPWSTR *DomainName,
    OUT LPWSTR *AuthenticationId,
    OUT PSID *UserSid
    );

LPWSTR
ElfpGetComputerName(
    VOID
    );

LPWSTR 
GetNameFromIPAddress(
	LPWSTR pszComputerNameFromBinding);

BOOL
IsLocal(
    VOID
    );
    
VOID
ElfpGenerateLogClearedEvent(
    IELF_HANDLE    LogHandle
    )

/*++

Routine Description:

    This function generates an event indicating that the log was cleared.

Arguments:

    LogHandle -- This is a handle to the log that the event is to be placed in.
        It is intended that this function only be called when the SecurityLog
        has been cleared.  So it is expected the LogHandle will always be
        a handle to the security log.

Return Value:

    None -- Either it works or it doesn't.  If it doesn't, there isn't much
            we can do about it.

--*/
{
    LPWSTR  UserName               = NULL;
    LPWSTR  DomainName             = NULL;
    LPWSTR  AuthenticationId       = NULL;
    LPWSTR  ClientUserName         = NULL;
    LPWSTR  ClientDomainName       = NULL;
    LPWSTR  ClientAuthenticationId = NULL;
    PSID    UserSid                = NULL;
    PSID    ClientSid              = NULL;
    LPWSTR  ComputerName           = NULL;
    DWORD   i;
    BOOL    Result;
    HANDLE  Token;
    PUNICODE_STRING StringPtrArray[NUM_STRINGS];
    UNICODE_STRING  StringArray[NUM_STRINGS];
    NTSTATUS        Status;
    LARGE_INTEGER   Time;
    ULONG           EventTime;
    ULONG           LogHandleGrantedAccess;
    UNICODE_STRING  ComputerNameU;
    DWORD           dwStatus;

    //
    // Get information about the Eventlog service (i.e., LocalSystem)
    //
    Result = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &Token);

    if (!Result)
    {
        ELF_LOG1(ERROR,
                 "ElfpGenerateLogClearedEvent: OpenProcessToken failed %d\n",
                 GetLastError());

        return;
    }

    Result = GetUserInfo(Token,
                         &UserName,
                         &DomainName,
                         &AuthenticationId,
                         &UserSid);

    CloseHandle(Token);

    if (!Result)
    {
        ELF_LOG1(ERROR,
                 "ElfpGenerateLogClearedEvent: GetUserInfo failed %d\n",
                 GetLastError());

        return;
    }

    ELF_LOG3(TRACE,
             "ElfpGenerateLogClearedEvent: GetUserInfo returned: \n"
                 "\tUserName         = %ws,\n"
                 "\tDomainName       = %ws,\n"
                 "\tAuthenticationId = %ws\n",
             UserName,
             DomainName,
             AuthenticationId);

    //
    // Now impersonate in order to get the client's information.
    // This call should never fail.
    //
    dwStatus = RpcImpersonateClient(NULL);

    if (dwStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpGenerateLogClearedEvent: RpcImpersonateClient failed %d\n",
                 dwStatus);
        goto CleanExit;
                 
    }

    Result = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &Token);

    if (Result)
    {
        Result = GetUserInfo(Token,
                             &ClientUserName,
                             &ClientDomainName,
                             &ClientAuthenticationId,
                             &ClientSid);

        CloseHandle(Token);

        if (!Result)
        {
            ELF_LOG1(ERROR,
                     "ElfpGenerateLogClearedEvent: GetUserInfo (call 2) failed %d\n",
                     GetLastError());

            goto CleanExit;
        }
    }
    else
    {
        //
        // We're impersonating here, so this should never
        // happen but just in case, use dashes
        //
        ELF_LOG1(ERROR,
                 "ElfpGenerateLogClearedEvent: OpenThreadToken failed %d\n",
                 GetLastError());

        ASSERT(FALSE);

        ClientUserName = L"-";
        ClientDomainName = L"-";
        ClientAuthenticationId = L"-";
    }

    ELF_LOG3(TRACE,
             "ElfpGenerateLogClearedEvent: GetUserInfo (call 2) returned: \n"
                 "\tUserName         = %ws,\n"
                 "\tDomainName       = %ws,\n"
                 "\tAuthenticationId = %ws\n",
             ClientUserName,
             ClientDomainName,
             ClientAuthenticationId);

    RtlInitUnicodeString(&StringArray[0], UserName);
    RtlInitUnicodeString(&StringArray[1], DomainName);
    RtlInitUnicodeString(&StringArray[2], AuthenticationId);
    RtlInitUnicodeString(&StringArray[3], ClientUserName);
    RtlInitUnicodeString(&StringArray[4], ClientDomainName);
    RtlInitUnicodeString(&StringArray[5], ClientAuthenticationId);

    //
    // Create an array of pointers to UNICODE_STRINGs.
    //
    for (i = 0; i < NUM_STRINGS; i++)
    {
        StringPtrArray[i] = &StringArray[i];
    }

    //
    // Generate the time of the event. This is done on the client side
    // since that is where the event occurred.
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time, &EventTime);

    //
    // Generate the ComputerName of the client.
    // We have to do this in the client side since this call may be
    // remoted to another server and we would not necessarily have
    // the computer name there.
    //

    ComputerName = ElfpGetComputerName();
    if(ComputerName == NULL)
    	goto CleanExit;				// ElfpGetComputerName dumps error msg
    RtlInitUnicodeString(&ComputerNameU, ComputerName);

    //
    // Since all processes other than LSA are given read-only access
    // to the security log, we have to explicitly give the current
    // process the right to write the "Log cleared" event
    //
    LogHandleGrantedAccess    = LogHandle->GrantedAccess;
    LogHandle->GrantedAccess |= ELF_LOGFILE_WRITE;

    Status = ElfrReportEventW (
                 LogHandle,                         // Log Handle
                 EventTime,                         // Time
                 EVENTLOG_AUDIT_SUCCESS,            // Event Type
                 (USHORT)SE_CATEGID_SYSTEM,         // Event Category
                 SE_AUDITID_AUDIT_LOG_CLEARED,      // EventID
                 NUM_STRINGS,                       // NumStrings
                 0,                                 // DataSize
                 &ComputerNameU,                    // ComputerNameU
                 UserSid,                           // UserSid
                 StringPtrArray,                    // *Strings
                 NULL,                              // Data
                 0,                                 // Flags
                 NULL,                              // RecordNumber
                 NULL);                             // TimeWritten

    LogHandle->GrantedAccess = LogHandleGrantedAccess;

CleanExit:

    //
    // We only come down this path if we know for sure that these
    // first three have been allocated.
    //
    ElfpFreeBuffer(UserName);
    ElfpFreeBuffer(DomainName);
    ElfpFreeBuffer(AuthenticationId);

    ElfpFreeBuffer(UserSid);
    ElfpFreeBuffer(ClientUserName);
    ElfpFreeBuffer(ClientDomainName);
    ElfpFreeBuffer(ClientAuthenticationId);
    ElfpFreeBuffer(ClientSid);
    ElfpFreeBuffer(ComputerName);
    //
    // Stop impersonating
    //
    dwStatus = RpcRevertToSelf();
    
    if (dwStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpGenerateLogClearedEvent: RpcRevertToSelf failed %d\n",
                 GetLastError());
    }
}


BOOL
GetUserInfo(
    IN HANDLE  Token,
    OUT LPWSTR *UserName,
    OUT LPWSTR *DomainName,
    OUT LPWSTR *AuthenticationId,
    OUT PSID   *UserSid
    )

/*++

Routine Description:

    This function gathers information about the user identified with the
    token.

Arguments:
    Token - This token identifies the entity for which we are gathering
        information.
    UserName - This is the entity's user name.
    DomainName -  This is the entity's domain name.
    AuthenticationId -  This is the entity's Authentication ID.
    UserSid - This is the entity's SID.

NOTE:
    Memory is allocated by this routine for UserName, DomainName,
    AuthenticationId, and UserSid.  It is the caller's responsibility to
    free this memory.

Return Value:
    TRUE - If the operation was successful.  It is possible that
        UserSid did not get allocated in the successful case.  Therefore,
        the caller should test prior to freeing.
    FALSE - If unsuccessful.  No memory is allocated in this case.


--*/
{
    PTOKEN_USER      Buffer      = NULL;
    LPWSTR           Domain      = NULL;
    LPWSTR           AccountName = NULL;
    SID_NAME_USE     Use;
    BOOL             Result;
    DWORD            RequiredLength;
    DWORD            AccountNameSize;
    DWORD            DomainNameSize;
    TOKEN_STATISTICS Statistics;
    WCHAR            LogonIdString[256];
    DWORD            Status = ERROR_SUCCESS;


    *UserSid = NULL;

    Result = GetTokenInformation(Token, TokenUser, NULL, 0, &RequiredLength);

    if (!Result)
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            ELF_LOG1(TRACE,
                     "GetUserInfo: GetTokenInformation needs %d bytes\n",
                     RequiredLength);

            Buffer = ElfpAllocateBuffer(RequiredLength);

            if (Buffer == NULL)
            {
                ELF_LOG0(ERROR,
                         "GetUserInfo: Unable to allocate memory for token\n");

                return FALSE;
            }

            Result = GetTokenInformation(Token,
                                         TokenUser,
                                         Buffer,
                                         RequiredLength,
                                         &RequiredLength);

            if (!Result)
            {
                ELF_LOG1(ERROR,
                         "GetUserInfo: GetTokenInformation (call 2) failed %d\n",
                         GetLastError());

                return FALSE;
            }
        }
        else
        {
            ELF_LOG1(ERROR,
                     "GetUserInfo: GetTokenInformation (call 1) failed %d\n",
                     GetLastError());

            return FALSE;
        }
    }

    AccountNameSize = 0;
    DomainNameSize  = 0;

    Result = LookupAccountSidW(L"",
                               Buffer->User.Sid,
                               NULL,
                               &AccountNameSize,
                               NULL,
                               &DomainNameSize,
                               &Use);

    if (!Result)
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            AccountName = ElfpAllocateBuffer((AccountNameSize + 1) * sizeof(WCHAR));
            Domain = ElfpAllocateBuffer((DomainNameSize + 1) * sizeof(WCHAR));

            if (AccountName == NULL)
            {
                ELF_LOG1(ERROR,
                         "GetUserInfo: Unable to allocate %d bytes for AccountName\n",
                         AccountNameSize);

                goto ErrorCleanup;
            }

            if (Domain == NULL)
            {
                ELF_LOG1(ERROR,
                         "GetUserInfo: Unable to allocate %d bytes for Domain\n",
                         DomainNameSize);

                goto ErrorCleanup;
            }

            Result = LookupAccountSidW(L"",
                                       Buffer->User.Sid,
                                       AccountName,
                                       &AccountNameSize,
                                       Domain,
                                       &DomainNameSize,
                                       &Use
                                       );
            if (!Result)
            {
                ELF_LOG1(ERROR,
                         "GetUserInfo: LookupAccountSid (call 2) failed %d\n",
                         GetLastError());

                goto ErrorCleanup;
            }
        }
        else
        {
            ELF_LOG1(ERROR,
                     "GetUserInfo: LookupAccountsid (call 1) failed %d\n",
                     GetLastError());

            goto ErrorCleanup;
        }
    }
    else
    {
        ELF_LOG0(ERROR,
                 "GetUserInfo: LookupAccountSid succeeded unexpectedly\n");

        goto ErrorCleanup;
    }

    ELF_LOG2(TRACE,
             "GetUserInfo: Name = %ws\\%ws\n",
             Domain,
             AccountName);

    Result = GetTokenInformation(Token,
                                 TokenStatistics,
                                 &Statistics,
                                 sizeof(Statistics),
                                 &RequiredLength);

    if (!Result)
    {
        ELF_LOG1(ERROR,
                 "GetUserInfo: GetTokenInformation (call 3) failed %d\n",
                 GetLastError());

        goto ErrorCleanup;
    }

    swprintf(LogonIdString,
             L"(0x%X,0x%X)",
             Statistics.AuthenticationId.HighPart,
             Statistics.AuthenticationId.LowPart);

    ELF_LOG1(TRACE,
             "GetUserInfo: LogonIdString = %ws\n",
             LogonIdString);

    *AuthenticationId = ElfpAllocateBuffer(WCSSIZE(LogonIdString));

    if (*AuthenticationId == NULL)
    {
        ELF_LOG0(ERROR,
                 "GetUserInfo: Unable to allocate memory for AuthenticationId\n");

        goto ErrorCleanup;
    }

    wcscpy(*AuthenticationId, LogonIdString);

    //
    // Return accumulated information
    //
    *UserSid = ElfpAllocateBuffer(GetLengthSid(Buffer->User.Sid));

    if (*UserSid == NULL)
    {
        ELF_LOG0(ERROR,
                 "GetUserInfo: Unable to allocate memory for UserSid\n");

        goto ErrorCleanup;
    }

    Result = CopySid(GetLengthSid(Buffer->User.Sid),
                     *UserSid,
                     Buffer->User.Sid);

    ElfpFreeBuffer(Buffer);

    *DomainName = Domain;
    *UserName   = AccountName;

    return TRUE;

ErrorCleanup:

    ElfpFreeBuffer(Buffer);
    ElfpFreeBuffer(Domain);
    ElfpFreeBuffer(AccountName);
    ElfpFreeBuffer(*UserSid);
    ElfpFreeBuffer(*AuthenticationId);

    return FALSE;
}



LPWSTR 
GetNameFromIPAddress(
	LPWSTR pszComputerNameFromBinding)
/*++

Routine Description:

    Examines a string and determines if it looks like an ip address.  If it
    does, then it converts it to a fqdn

Arguments:

    Machine name:  Could be xxx.xxx.xxx.xxx or anything else!

Return Value:

    If successful, returns a fully qualified domain name which the caller
    will free.  Returns NULL if there are any problems.


--*/
{

	LPWSTR pComputerName = NULL;
	DWORD dwAddr;
	char cName[17];  // should be plenty of room
	size_t NumConv;
	HOSTENT  FAR * pEnt;
	DWORD dwSize;
	WORD wVersionRequested;
	WSADATA wsaData;
	int error;
	
	NumConv = wcstombs(cName, pszComputerNameFromBinding, 16);  
	if(NumConv == -1 || NumConv == 0)
	    return NULL;

	// convert the string into a network order dword representation
	
	dwAddr = inet_addr(cName);
	if(dwAddr == INADDR_NONE)
		return NULL;

	//  initialize sockets.

	wVersionRequested = MAKEWORD( 2, 2 );
 
    error = WSAStartup( wVersionRequested, &wsaData );
	if(error != 0)
	{
	   	ELF_LOG1(TRACE,
           "GetNameFromIPAddress: failed to initialize sockets, error = 0x%x\n", error);
		return NULL;
	}

		
	pEnt = gethostbyaddr((char FAR *)&dwAddr, 4, PF_INET);
	if(pEnt == NULL || pEnt->h_name == NULL)
	{
	   	ELF_LOG1(TRACE,
                 "GetNameFromIPAddress: failed gethostbyaddr, error = 0x%x\n",
                 WSAGetLastError());
		WSACleanup();
		return NULL;
	}
	dwSize = strlen(pEnt->h_name) + 1 ;
	pComputerName = ElfpAllocateBuffer(2*dwSize);
	if(pComputerName == NULL)
	{
	   	ELF_LOG0(ERROR,
                 "GetNameFromIPAddress: failed trying to allocate memory\n");
	    WSACleanup();
		return NULL;
	}
	pComputerName[0] = 0;
	mbstowcs(pComputerName, pEnt->h_name, dwSize);
    WSACleanup();
	return pComputerName;
}

BOOL
IsLocal(
    VOID
    )
/*++

Routine Description:

    Determines if the caller is local. 

Arguments:

    NONE

Return Value:

    TRUE if definately local.


--*/
{
    UINT            LocalFlag;
    RPC_STATUS      RpcStatus;
    RpcStatus = I_RpcBindingIsClientLocal(0, &LocalFlag);

    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "IsLocal: I_RpcBindingIsClientLocal failed %d\n",
                 RpcStatus);
        return FALSE;
    }
    if(LocalFlag == 0)
        return FALSE;
    else
    	return TRUE;
}

LPWSTR
ElfpGetComputerName(
    VOID
    )

/*++

Routine Description:

    This routine gets the LPWSTR name of the computer. 

Arguments:

    NONE

Return Value:

    Returns a pointer to the computer name, or a NULL.  Note that the caller
    is expected to free this via 


--*/
{
    RPC_STATUS      RpcStatus;
    handle_t hServerBinding = NULL;
    LPWSTR pszBinding = NULL;
    LPWSTR pszComputerNameFromBinding = NULL;
	LPWSTR pszComputerName = NULL;
	DWORD dwSize;
	BOOL bOK;

//      Check if the connection is local.  If it is, then just 
//      call GetComputerName

	if(IsLocal())
	{
		dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
		pszComputerName = ElfpAllocateBuffer(2*dwSize);
		if(pszComputerName == NULL)
		{
        	ELF_LOG0(ERROR,
                 "ElfpGetComputerName: failed trying to allocate memory\n");
			return NULL;
		}
		bOK = GetComputerNameW(pszComputerName, &dwSize);
		if(bOK == FALSE)
		{
			ElfpFreeBuffer(pszComputerName);
        	ELF_LOG1(ERROR,
                 "ElfpGetComputerName: failed calling GetComputerNameW, last error 0x%x\n",
                  GetLastError());
            return NULL;    
		}
		else
			return pszComputerName;
	}

    RpcStatus = RpcBindingServerFromClient( NULL, &hServerBinding );
    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "ElfpGetComputerName: RpcBindingServerFromClient failed %d\n",
                 RpcStatus);
        return NULL;
    }

	// This gets us something like "ncacn_np:xxx.xxx.xxx.xxx" or 
	// "ncacn_np:localMachine"
	
    RpcStatus = RpcBindingToStringBinding( hServerBinding, &pszBinding );
    if( RpcStatus != ERROR_SUCCESS )
    {
        ELF_LOG1(ERROR,
                 "ElfpGetComputerName: RpcBindingToStringBinding failed %d\n",
                 RpcStatus);
        goto CleanExitGetCompName;
    } 

    // Acquire just the network address.  That will be something like
    // "xxx.xxx.xxx.xxx" or "mymachine"

    RpcStatus = RpcStringBindingParse( pszBinding,
                                                NULL,
                                                NULL,
                                                &pszComputerNameFromBinding,
                                                NULL,
                                                NULL );
    if( RpcStatus != ERROR_SUCCESS || pszComputerNameFromBinding == NULL)
    {
        ELF_LOG1(ERROR,
                 "ElfpGetComputerName: RpcStringBindingParse failed %d\n",
                 RpcStatus);
        goto CleanExitGetCompName;
    }

    // sometimes the name is an ip address.  If it is, then the following determines
    // that and returns the right string.

	pszComputerName = GetNameFromIPAddress(pszComputerNameFromBinding);                                                
	if(pszComputerName == NULL)
	{
		dwSize = wcslen(pszComputerNameFromBinding) + 1;
		pszComputerName = ElfpAllocateBuffer(2*dwSize);
		if(pszComputerName == NULL)
		{
        	ELF_LOG0(ERROR,
                 "ElfpGetComputerName: failed trying to allocate memory\n");
		}
		else
			wcscpy(pszComputerName, pszComputerNameFromBinding);
	}

CleanExitGetCompName:
	if(hServerBinding)
		RpcStatus = RpcBindingFree(&hServerBinding);
	if(pszBinding)
		RpcStatus = RpcStringFree(&pszBinding);
	if(pszComputerNameFromBinding)
		RpcStatus = RpcStringFree(&pszComputerNameFromBinding);
    return pszComputerName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\file.c ===
/*

Copyright (c) 1990  Microsoft Corporation

Module Name:

    FILE.C

Abstract:

    This file contains the routines that deal with file-related operations.

Author:

    Rajen Shah  (rajens)    07-Aug-1991

Revision History:

    29-Aug-1994     Danl
        We no longer grow log files in place.  So there is no need to
        reserve the MaxConfigSize block of memory.

    18-Apr-2001     Danl
        Modified the function RevalidateLogHeader to change an ASSERT to a check 
		in order to return a proper error code if the condition is TRUE
--*/

//
// INCLUDES
//

#include <eventp.h>
#include <alertmsg.h>  // ALERT_ELF manifests

//
// Macros
//

#define IS_EOF(Ptr, Size) \
    ((Ptr)->Length == ELFEOFRECORDSIZE && \
        RtlCompareMemory (Ptr, &EOFRecord, Size) == Size)

#ifdef CORRUPTED


BOOLEAN
VerifyLogIntegrity(
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine walks the log file to verify that it isn't corrupt


Arguments:

    A pointer to the LOGFILE structure for the log to validate.

Return Value:

    TRUE if log OK
    FALSE if it is corrupt

Note:


--*/
{

    PEVENTLOGRECORD pEventLogRecord;
    PEVENTLOGRECORD pNextRecord;
    PVOID PhysicalStart;
    PVOID PhysicalEOF;
    PVOID BeginRecord;
    PVOID EndRecord;

    pEventLogRecord =
        (PEVENTLOGRECORD)((PBYTE) pLogFile->BaseAddress + pLogFile->BeginRecord);

    PhysicalStart =
        (PVOID) ((PBYTE) pLogFile->BaseAddress + FILEHEADERBUFSIZE);

    PhysicalEOF =
        (PVOID) ((PBYTE) pLogFile->BaseAddress + pLogFile->ViewSize);

    BeginRecord = (PVOID)((PBYTE) pLogFile->BaseAddress + pLogFile->BeginRecord);
    EndRecord   = (PVOID)((PBYTE) pLogFile->BaseAddress + pLogFile->EndRecord);

    while(pEventLogRecord->Length != ELFEOFRECORDSIZE)
    {
        pNextRecord =
            (PEVENTLOGRECORD) NextRecordPosition(EVENTLOG_FORWARDS_READ,
                                                 (PVOID) pEventLogRecord,
                                                 pEventLogRecord->Length,
                                                 BeginRecord,
                                                 EndRecord,
                                                 PhysicalEOF,
                                                 PhysicalStart);

        if (!pNextRecord || pNextRecord->Length == 0)
        {
            ELF_LOG2(ERROR,
                     "VerifyLogIntegrity: The %ws logfile is corrupt near %p\n",
                     pLogFile->LogModuleName->Buffer,
                     pEventLogRecord);

            return FALSE;
        }

        pEventlogRecord = pNextRecord;
    }

    return TRUE;
}

#endif // CORRUPTED


NTSTATUS
FlushLogFile(
    PLOGFILE    pLogFile
    )

/*++

Routine Description:

    This routine flushes the file specified. It updates the file header,
    and then flushes the virtual memory which causes the data to get
    written to disk.

Arguments:

    pLogFile points to the log file structure.

Return Value:

    NONE

Note:


--*/
{
    NTSTATUS    Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID       BaseAddress;
    SIZE_T      RegionSize;
    PELF_LOGFILE_HEADER pLogFileHeader;

    //
    // If the dirty bit is set, update the file header before flushing it.
    //
    if (pLogFile->Flags & ELF_LOGFILE_HEADER_DIRTY)
    {
        ELF_LOG1(FILES,
                 "FlushLogFile: %ws log is dirty -- updating header before flushing\n",
                 pLogFile->LogModuleName->Buffer);

        pLogFileHeader = (PELF_LOGFILE_HEADER) pLogFile->BaseAddress;

        pLogFile->Flags &= ~ELF_LOGFILE_HEADER_DIRTY; // Remove dirty bit

        pLogFileHeader->Flags               = pLogFile->Flags;
        pLogFileHeader->StartOffset         = pLogFile->BeginRecord;
        pLogFileHeader->EndOffset           = pLogFile->EndRecord;
        pLogFileHeader->CurrentRecordNumber = pLogFile->CurrentRecordNumber;
        pLogFileHeader->OldestRecordNumber  = pLogFile->OldestRecordNumber;
    }

    //
    // Flush the memory in the section that is mapped to the file.
    //
    BaseAddress = pLogFile->BaseAddress;
    RegionSize  = pLogFile->ViewSize;

    Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                  &BaseAddress,
                                  &RegionSize,
                                  &IoStatusBlock);

    return Status;
}



NTSTATUS
ElfpFlushFiles(
    VOID
    )

/*++

Routine Description:

    This routine flushes all the log files and forces them on disk.
    It is usually called in preparation for a shutdown or a pause.

Arguments:

    NONE

Return Value:

    NONE

Note:


--*/

{

    PLOGFILE    pLogFile;
    NTSTATUS    Status = STATUS_SUCCESS;

    //
    // Make sure that there's at least one file to flush
    //

    if (IsListEmpty(&LogFilesHead))
    {
        ELF_LOG0(FILES,
                 "ElfpFlushFiles: No log files -- returning success\n");

        return STATUS_SUCCESS;
    }

    pLogFile = (PLOGFILE) CONTAINING_RECORD(LogFilesHead.Flink, LOGFILE, FileList);

    //
    // Go through this loop at least once. This ensures that the termination
    // condition will work correctly.
    //
    do
    {
        Status = FlushLogFile(pLogFile);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpFlushFiles: FlushLogFile on %ws log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);
        }

        //
        // Get the next one
        //
        pLogFile = (PLOGFILE) CONTAINING_RECORD(pLogFile->FileList.Flink, LOGFILE, FileList);
    }
    while ((pLogFile->FileList.Flink != LogFilesHead.Flink) && (NT_SUCCESS(Status)));

    return Status;
}


NTSTATUS
ElfpCloseLogFile(
    PLOGFILE    pLogFile,
    DWORD       Flags
    )

/*++

Routine Description:

    This routine undoes whatever is done in ElfOpenLogFile.

Arguments:

    pLogFile points to the log file structure.

Return Value:

    NTSTATUS.

Note:


--*/
{
    PELF_LOGFILE_HEADER pLogFileHeader;
    PVOID               BaseAddress;
    ULONG               Size;

    ELF_LOG2(FILES,
             "ElfpCloseLogfile: Closing and unmapping file %ws (%ws log)\n",
             pLogFile->LogFileName->Buffer,
             pLogFile->LogModuleName->Buffer);


#ifdef CORRUPTED

    //
    // Just for debugging a log corruption problem
    //

    if (!VerifyLogIntegrity(pLogFile))
    {
        ELF_LOG1(FILES,
                 "ElfpCloseLogfile: Integrity check failed for file %ws\n",
                 pLogFile->LogFileName->Buffer);
    }

#endif // CORRUPTED


    //
    // If the dirty bit is set, update the file header before closing it.
    // Check to be sure it's not a backup file that just had the dirty
    // bit set when it was copied.
    //

    if (pLogFile->Flags & ELF_LOGFILE_HEADER_DIRTY
         &&
        !(Flags & ELF_LOG_CLOSE_BACKUP))
    {
        pLogFile->Flags &= ~(ELF_LOGFILE_HEADER_DIRTY |
                             ELF_LOGFILE_ARCHIVE_SET  );   // Remove dirty &
                                                            // archive bits
        if(pLogFile->BaseAddress)
        {
            pLogFileHeader = (PELF_LOGFILE_HEADER) pLogFile->BaseAddress;

            pLogFileHeader->StartOffset         = pLogFile->BeginRecord;
            pLogFileHeader->EndOffset           = pLogFile->EndRecord;
            pLogFileHeader->CurrentRecordNumber = pLogFile->CurrentRecordNumber;
            pLogFileHeader->OldestRecordNumber  = pLogFile->OldestRecordNumber;
            pLogFileHeader->Flags               = pLogFile->Flags;
        }
    }

    //
    // Decrement the reference count, and if it goes to zero, unmap the file
    // and close the handle. Also force the close if fForceClosed is TRUE.
    //

    if ((--pLogFile->RefCount == 0) || (Flags & ELF_LOG_CLOSE_FORCE))
    {
        //
        // Last user has gone.
        // Close all the views and the file and section handles.  Free up
        // any extra memory we had reserved, and unlink any structures
        //
        if (pLogFile->BaseAddress)     // Unmap it if it was allocated
        {
            NtUnmapViewOfSection(NtCurrentProcess(),
                                 pLogFile->BaseAddress);
            pLogFile->BaseAddress = NULL;
        }

        if (pLogFile->SectionHandle)
        {
            NtClose(pLogFile->SectionHandle);
            pLogFile->SectionHandle = NULL;
        }

        if (pLogFile->FileHandle)
        {
            NtClose(pLogFile->FileHandle);
            pLogFile->FileHandle = NULL;
        }
    }

    return STATUS_SUCCESS;

} // ElfpCloseLogFile



NTSTATUS
RevalidateLogHeader(
    PELF_LOGFILE_HEADER pLogFileHeader,
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine is called if we encounter a "dirty" log file. The
    routine walks through the file until it finds a signature for a valid log
    record.  Then it walks backwards from the first record it found until it 
    finds the EOF record from the other direction.  It then walks forward thru 
	the file until it finds the EOF record, or an invalid record.
    It then rebuilds the header and writes it back to the log.  If it can't
    find any valid records, it rebuilds the header to reflect an empty log
    file.  If it finds a trashed file, it writes 256 bytes of the log out in
    an event to the system log.

Arguments:

    pLogFileHeader points to the header of the log file.
    pLogFile points to the log file structure.

Return Value:

    NTSTATUS.

Note:

    This is an expensive routine since it scans the entire file.

    It assumes that the records are on DWORD boundaries.

--*/
{
    PVOID Start, End;
    PDWORD pSignature;
    PEVENTLOGRECORD pEvent;
    PEVENTLOGRECORD FirstRecord;
    PEVENTLOGRECORD FirstPhysicalRecord;
    PEVENTLOGRECORD pLastGoodRecord = NULL;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    SIZE_T Size;
    int iNumWrap = 0;

    ELF_LOG1(FILES,
             "RevalidateLogHeader: %ws log had dirty bit set -- revalidating\n",
             pLogFile->LogModuleName->Buffer);

    //
    // BUGBUG: This function is full of return statements from inside the
    //         try-except block.  They need to go away.
    //

    try
    {
        //
        // Physical start and end of log file (skipping header)
        //
        Start = (PVOID) ((PBYTE) pLogFile->BaseAddress + FILEHEADERBUFSIZE);
        End = (PVOID) ((PBYTE) pLogFile->BaseAddress + pLogFile->ActualMaxFileSize);

        //
        // First see if the log has wrapped.  The EOFRECORDSIZE is for the one
        // case where the EOF record wraps so that its final length just replaces
        // the next record's starting length
        //
        pEvent = (PEVENTLOGRECORD) Start;

        if (pEvent->Reserved != ELF_LOG_FILE_SIGNATURE
             ||
            pEvent->RecordNumber != 1
             ||
            pEvent->Length == ELFEOFRECORDSIZE)
        {
            ELF_LOG1(FILES,
                     "RevalidateLogHeader: %ws log has wrapped -- looking for "
                         "first valid record\n",
                     pLogFile->LogModuleName->Buffer);

            //
            // Log has already wrapped, go looking for the first valid record
            //
            for (pSignature = (PDWORD) Start;
                 (PVOID) pSignature < End;
                 pSignature++)
            {
                if (*pSignature == ELF_LOG_FILE_SIGNATURE)
                {
                    //
                    // Make sure it's really a record
                    //
                    pEvent = CONTAINING_RECORD(pSignature, EVENTLOGRECORD, Reserved);

                    if (!ValidFilePos(pEvent, Start, End, End, pLogFileHeader, TRUE))
                    {
                        //
                        // Nope, not really, keep trying
                        //
                        continue;
                    }

                    //
                    // This is a valid record, Remember this so you can use
                    // it later
                    //
                    FirstPhysicalRecord = pEvent;

                    ELF_LOG1(FILES,
                             "RevalidateLogHeader: First physical record in %ws log "
                                 "found at %p\n",
                             FirstPhysicalRecord);

                    //
                    // Walk backwards from here (wrapping if necessary) until
                    // you hit the EOF record or an invalid record.
                    //
                    while (pEvent
                            &&
                           ValidFilePos(pEvent, Start, End, End, pLogFileHeader, TRUE))
                    {
                        //
                        // See if it's the EOF record
                        //

                        //
                        // BUGBUG:  If (End - pEvent) is less than ELFEOFUNIQUEPART,
                        //          we never validate what should be the remainder of
                        //          the EOF record at the start of the logfile
                        //
                        if (IS_EOF(pEvent,
                                   min(ELFEOFUNIQUEPART,
                                       (ULONG_PTR) ((PBYTE) End - (PBYTE) pEvent))))
                        {
                            ELF_LOG2(FILES,
                                     "RevalidateLogHeader: Found EOF record (backwards "
                                         "scan) for log %ws at %p\n",
                                     pLogFile->LogModuleName->Buffer,
                                     pEvent);

                            break;
                        }

                        pLastGoodRecord = pEvent;

                        pEvent = NextRecordPosition (
                                     EVENTLOG_SEQUENTIAL_READ |
                                         EVENTLOG_BACKWARDS_READ,
                                     pEvent,
                                     pEvent->Length,
                                     0,
                                     0,
                                     End,
                                     Start);

                        if(pLastGoodRecord < pEvent)
                            iNumWrap++;

                        //
                        // Make sure we're not in an infinite loop
                        //
                        if (pEvent == FirstPhysicalRecord || iNumWrap > 4)
                        {
                            ELF_LOG1(FILES,
                                     "RevalidateLogHeader: Infinite loop (backwards scan) "
                                         "in %ws log -- no EOF or invalid record found\n",
                                     pLogFile->LogModuleName->Buffer);

                            return STATUS_UNSUCCESSFUL;
                        }
                    }

                    //
                    // Found the first record, now go look for the last
                    //
                    ELF_LOG2(FILES,
                             "RevalidateLogHeader: First valid record in %ws "
                                 "log is at %p\n",
                             pLogFile->LogModuleName->Buffer,
                             pLastGoodRecord);

                    FirstRecord = pLastGoodRecord;
                    break;
                }
            }

            if (pSignature == End || pLastGoodRecord == NULL)
            {
                //
                // Either there were no valid records in the file or
                // the only valid record was the EOF record (which
                // means the log is trashed anyhow).  Give up
                // and we'll set it to an empty log file.
                //
                ELF_LOG1(FILES,
                         "RevalidateLogHeader: No valid records found in %ws log\n",
                         pLogFile->LogModuleName->Buffer);

                return STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            ELF_LOG1(FILES,
                     "RevalidateLogHeader: %ws log has not wrapped -- "
                         "first record is at %p\n",
                     pLogFile->LogModuleName->Buffer);

            //
            // We haven't wrapped yet
            //
            FirstPhysicalRecord = FirstRecord = Start;
        }

        //
        // Now read forward looking for the last good record
        //
        pEvent = FirstPhysicalRecord;

        while (pEvent
                &&
               ValidFilePos(pEvent, Start, End, End, pLogFileHeader, TRUE))
        {
            //
            // See if it's the EOF record
            //
            if (IS_EOF(pEvent,
                       min(ELFEOFUNIQUEPART,
                           (ULONG_PTR) ((PBYTE) End - (PBYTE) pEvent))))
            {
                ELF_LOG2(FILES,
                         "RevalidateLogHeader: Found EOF record (forwards scan) "
                             "for log %ws at %p\n",
                         pLogFile->LogModuleName->Buffer,
                         pEvent);

                break;
            }

            pLastGoodRecord = pEvent;

            pEvent = NextRecordPosition(EVENTLOG_SEQUENTIAL_READ |
                                          EVENTLOG_FORWARDS_READ,
                                        pEvent,
                                        pEvent->Length,
                                        0,
                                        0,
                                        End,
                                        Start);

            if(pLastGoodRecord > pEvent)
                iNumWrap++;

            //
            // Make sure we're not in an infinite loop
            //
            if (pEvent == FirstPhysicalRecord || iNumWrap > 4)
            {
                ELF_LOG1(FILES,
                         "RevalidateLogHeader: Infinite loop (forwards scan) "
                             "in %ws log -- no EOF or invalid record found\n",
                         pLogFile->LogModuleName->Buffer);


                return(STATUS_UNSUCCESSFUL);
            }
        }

        //
        // Now we know the first record (FirstRecord) and the last record
        // (pLastGoodRecord) so we can create the header an EOF record and
        // write them out (EOF record gets written at pEvent)
        //
        // First the EOF record
        //
        //
        // If the EOF record was wrapped, we can't write out the entire record at
        // once.  Instead, we'll write out as much as we can and then write the
        // rest out at the beginning of the log
        //
        Size = min((PBYTE) End - (PBYTE) pEvent, ELFEOFRECORDSIZE);

        if (Size != ELFEOFRECORDSIZE)
        {
            // Make absolutely sure we have enough room to write the remainder of
            // the EOF record.  Note that this should always be the case since the
            // record was wrapped around to begin with.  To do this, make sure
            // that the number of bytes we're writing after the header is <= the
            // offset of the first record from the end of the header
            //
			
			//Refer to bug# 359188. This scenario should never happen but because of 
			//unknown reasons, it happened to occur in one of the log files. so the 
			//following check which was ASSERT in the earlier version was changed to 
			//return STATUS_UNSUCCESSFUL

            if((ELFEOFRECORDSIZE - Size) <= (ULONG)((PBYTE) FirstRecord
                                       - (PBYTE) pLogFileHeader
                                       - FILEHEADERBUFSIZE))

			{
                ELF_LOG1(FILES,
                         "RevalidateLogHeader: Overlapping EOF record "
                             "in %ws log -- No space for writing remainder of EOF record between file header and first record \n",
                         pLogFile->LogModuleName->Buffer);
				return(STATUS_UNSUCCESSFUL);        
			}

		}


		EOFRecord.BeginRecord = (ULONG) ((PBYTE) FirstRecord - (PBYTE) pLogFileHeader);
        EOFRecord.EndRecord = (ULONG) ((PBYTE) pEvent - (PBYTE) pLogFileHeader);

        EOFRecord.CurrentRecordNumber = pLastGoodRecord->RecordNumber + 1;
        EOFRecord.OldestRecordNumber  = FirstRecord->RecordNumber;

        ByteOffset = RtlConvertUlongToLargeInteger((ULONG) ((PBYTE) pEvent
                                                       - (PBYTE) pLogFileHeader));

        Status = NtWriteFile(
                    pLogFile->FileHandle,   // Filehandle
                    NULL,                   // Event
                    NULL,                   // APC routine
                    NULL,                   // APC context
                    &IoStatusBlock,         // IO_STATUS_BLOCK
                    &EOFRecord,             // Buffer
                    (ULONG) Size,           // Length
                    &ByteOffset,            // Byteoffset
                    NULL);                  // Key

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "RevalidateLogHeader: EOF record write for %ws log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);

            return Status;
        }

        if (Size != ELFEOFRECORDSIZE)
        {
            PBYTE   pBuff;

            pBuff = (PBYTE) &EOFRecord + Size;
            Size = ELFEOFRECORDSIZE - Size;
            ByteOffset = RtlConvertUlongToLargeInteger(FILEHEADERBUFSIZE);

			// We have already made sure we have enough room to write the remainder of
            // the EOF record. 

            //ASSERT(Size <= (ULONG)((PBYTE) FirstRecord
            //                           - (PBYTE) pLogFileHeader
            //                           - FILEHEADERBUFSIZE));

            Status = NtWriteFile(
                        pLogFile->FileHandle,   // Filehandle
                        NULL,                   // Event
                        NULL,                   // APC routine
                        NULL,                   // APC context
                        &IoStatusBlock,         // IO_STATUS_BLOCK
                        pBuff,                  // Buffer
                        (ULONG) Size,           // Length
                        &ByteOffset,            // Byteoffset
                        NULL);                  // Key

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "RevalidateLogHeader: EOF record write (part 2) for "
                             "%ws log failed %#x\n",
                         pLogFile->LogModuleName->Buffer,
                         Status);

                return Status;
            }
        }

        //
        // Now the header
        //

        pLogFileHeader->StartOffset = (ULONG) ((PBYTE) FirstRecord - (PBYTE) pLogFileHeader);
        pLogFileHeader->EndOffset   = (ULONG) ((PBYTE) pEvent- (PBYTE) pLogFileHeader);

        pLogFileHeader->CurrentRecordNumber = pLastGoodRecord->RecordNumber + 1;
        pLogFileHeader->OldestRecordNumber  = FirstRecord->RecordNumber;

        pLogFileHeader->HeaderSize = pLogFileHeader->EndHeaderSize = FILEHEADERBUFSIZE;
        pLogFileHeader->Signature  = ELF_LOG_FILE_SIGNATURE;
        pLogFileHeader->Flags      = 0;

        if (pLogFileHeader->StartOffset != FILEHEADERBUFSIZE)
        {
            pLogFileHeader->Flags |= ELF_LOGFILE_HEADER_WRAP;
        }

        pLogFileHeader->MaxSize      = pLogFile->ActualMaxFileSize;
        pLogFileHeader->Retention    = pLogFile->Retention;
        pLogFileHeader->MajorVersion = ELF_VERSION_MAJOR;
        pLogFileHeader->MinorVersion = ELF_VERSION_MINOR;

        //
        // Now flush this to disk to commit it
        //
        Start = pLogFile->BaseAddress;
        Size  = FILEHEADERBUFSIZE;

        Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                      &Start,
                                      &Size,
                                      &IoStatusBlock);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "RevalidateLogHeader: NtFlushVirtualMemory for %ws log "
                         "header failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}


NTSTATUS
ElfOpenLogFile (
    PLOGFILE    pLogFile,
    ELF_LOG_TYPE LogType
    )

/*++

Routine Description:

    Open the log file, create it if it does not exist.
    Create a section and map a view into the log file.
    Write out the header to the file, if it is newly created.
    If "dirty", update the "start" and "end" pointers by scanning
    the file.  Set AUTOWRAP if the "start" does not start right after
    the file header.

Arguments:

    pLogFile -- pointer to the log file structure, with the relevant data
                filled in.

    CreateOptions -- options to be passed to NtCreateFile that indicate
                     whether to open an existing file, or to create it
                     if it does not exist.

Return Value:

    NTSTATUS.

Note:

    It is up to the caller to set the RefCount in the Logfile structure.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER MaximumSizeOfSection;
    LARGE_INTEGER ByteOffset;
    PELF_LOGFILE_HEADER pLogFileHeader;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    ULONG IoStatusInformation;
    ULONG FileDesiredAccess;
    ULONG SectionDesiredAccess;
    ULONG SectionPageProtection;
    ULONG CreateOptions;
    ULONG CreateDisposition;
    SIZE_T ViewSize;

    //
    // File header in a new file has the "Start" and "End" pointers the
    // same since there are no records in the file.
    //
    static ELF_LOGFILE_HEADER FileHeaderBuf = { FILEHEADERBUFSIZE, // Size
                                                ELF_LOG_FILE_SIGNATURE,
                                                ELF_VERSION_MAJOR,
                                                ELF_VERSION_MINOR,
                                                FILEHEADERBUFSIZE, // Start offset
                                                FILEHEADERBUFSIZE, // End offset
                                                1,                 // Next record #
                                                0,                 // Oldest record #
                                                0,                 // Maxsize
                                                0,                 // Flags
                                                0,                 // Retention
                                                FILEHEADERBUFSIZE  // Size
                                              };

    //
    // Set the file open and section create options based on the type of log
    // file this is.
    //
    switch (LogType)
    {
        case ElfNormalLog:

            ELF_LOG0(FILES,
                     "ElfpOpenLogfile: Opening ElfNormalLog\n");

            CreateDisposition = FILE_OPEN_IF;
            FileDesiredAccess = GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE;

            SectionDesiredAccess = SECTION_MAP_READ | SECTION_MAP_WRITE
                                       | SECTION_QUERY | SECTION_EXTEND_SIZE;

            SectionPageProtection = PAGE_READWRITE;
            CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;
            break;

        case ElfSecurityLog:

            ELF_LOG0(FILES,
                     "ElfpOpenLogfile: Opening ElfSecurityLog\n");

            CreateDisposition = FILE_OPEN_IF;
            FileDesiredAccess = GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE;

            SectionDesiredAccess = SECTION_MAP_READ | SECTION_MAP_WRITE
                                       | SECTION_QUERY | SECTION_EXTEND_SIZE;

            SectionPageProtection = PAGE_READWRITE;
            CreateOptions = FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT;
            break;

        case ElfBackupLog:

            ELF_LOG0(FILES,
                     "ElfpOpenLogfile: Opening ElfBackupLog\n");

            CreateDisposition = FILE_OPEN;
            FileDesiredAccess = GENERIC_READ | SYNCHRONIZE;
            SectionDesiredAccess = SECTION_MAP_READ | SECTION_QUERY;
            SectionPageProtection = PAGE_READONLY;
            CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;
            break;
    }

    ELF_LOG1(FILES,
             "ElfpOpenLogfile: Opening and mapping %ws\n",
             pLogFile->LogFileName->Buffer);

    if (pLogFile->FileHandle != NULL)
    {
        //
        // The log file is already in use. Do not reopen or remap it.
        //
        ELF_LOG0(FILES,
                 "ElfpOpenLogfile: Log file already in use by another module\n");
    }
    else
    {
        //
        // Initialize the logfile structure so that it is easier to clean
        // up.
        //
        pLogFile->ActualMaxFileSize = ELF_DEFAULT_LOG_SIZE;
        pLogFile->Flags = 0;
        pLogFile->BaseAddress = NULL;
        pLogFile->SectionHandle = NULL;

        //
        // Set up the object attributes structure for the Log File
        //
        InitializeObjectAttributes(&ObjectAttributes,
                                   pLogFile->LogFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        //
        // Open the Log File. Create it if it does not exist and it's not
        // being opened as a backup file.  If creating, create a file of
        // the maximum size configured.
        //
        MaximumSizeOfSection = RtlConvertUlongToLargeInteger(ELF_DEFAULT_LOG_SIZE);

        Status = NtCreateFile(&pLogFile->FileHandle,
                              FileDesiredAccess,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              &MaximumSizeOfSection,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ,
                              CreateDisposition,
                              CreateOptions,
                              NULL,
                              0);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpOpenLogfile: Open of %ws log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);

            goto cleanup;
        }

        //
        // If the file already existed, get its size and use that as the
        // actual size of the file.
        //
        IoStatusInformation = (ULONG) IoStatusBlock.Information;

        if (!( IoStatusInformation & FILE_CREATED ))
        {
            ELF_LOG1(FILES,
                     "ElfpOpenLogfile: File %ws already exists\n",
                     pLogFile->LogFileName->Buffer);

            Status = NtQueryInformationFile(pLogFile->FileHandle,
                                            &IoStatusBlock,
                                            &FileStandardInfo,
                                            sizeof (FileStandardInfo),
                                            FileStandardInformation);

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfpOpenLogfile: NtQueryInformationFile for %ws failed %#x\n",
                         pLogFile->LogFileName->Buffer,
                         Status);

                goto cleanup;
            }
            else
            {
                ELF_LOG3(FILES,
                         "ElfpOpenLogfile: Use existing size for %ws log: %#x:%#x\n",
                         pLogFile->LogModuleName->Buffer,
                         FileStandardInfo.EndOfFile.HighPart,
                         FileStandardInfo.EndOfFile.LowPart);

                MaximumSizeOfSection.LowPart  = FileStandardInfo.EndOfFile.LowPart;
                MaximumSizeOfSection.HighPart = FileStandardInfo.EndOfFile.HighPart;

                //
                // Make sure that the high DWORD of the file size is ZERO.
                //
                // BUGBUG:  Is this OK for 64-bit machines?
                //
                ASSERT(MaximumSizeOfSection.HighPart == 0);

                //
                // If the filesize if 0, set it to the minimum size
                //
                if (MaximumSizeOfSection.LowPart == 0)
                {
                    ELF_LOG1(FILES,
                             "ElfpOpenLogfile: File was size 0 -- setting it to %#x\n",
                             ELF_DEFAULT_LOG_SIZE);

                    MaximumSizeOfSection.LowPart = ELF_DEFAULT_LOG_SIZE;
                }

                //
                // Set actual size of file
                //
                pLogFile->ActualMaxFileSize = MaximumSizeOfSection.LowPart;

                //
                // If the size of the log file is reduced, a clear must
                // happen for this to take effect
                //
                if (pLogFile->ActualMaxFileSize > pLogFile->ConfigMaxFileSize)
                {
                    pLogFile->ConfigMaxFileSize = pLogFile->ActualMaxFileSize;
                }
            }
        }

        //
        // Create a section mapped to the Log File just opened
        //
        Status = NtCreateSection(
                    &pLogFile->SectionHandle,
                    SectionDesiredAccess,
                    NULL,
                    &MaximumSizeOfSection,
                    SectionPageProtection,
                    SEC_COMMIT,
                    pLogFile->FileHandle);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpOpenLogfile: NtCreateSection for %ws failed %#x\n",
                     pLogFile->LogFileName->Buffer,
                     Status);

            goto cleanup;
        }

        //
        // Map a view of the Section into the eventlog address space
        //
        ViewSize = 0;

        Status = NtMapViewOfSection(
                        pLogFile->SectionHandle,
                        NtCurrentProcess(),
                        &pLogFile->BaseAddress,
                        0,
                        0,
                        NULL,
                        &ViewSize,
                        ViewUnmap,
                        0,
                        SectionPageProtection);

        pLogFile->ViewSize = (ULONG) ViewSize;

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpOpenLogfile: NtMapViewOfSection for %ws failed %#x\n",
                     pLogFile->LogFileName->Buffer,
                     Status);

            goto cleanup;
        }
        pLogFile->bFullAlertDone = FALSE;

        //
        // If the file was just created, write out the file header.
        //
        if (IoStatusInformation & FILE_CREATED)
        {
            ELF_LOG1(FILES,
                     "ElfpOpenLogfile: Created file %ws\n",
                     pLogFile->LogFileName->Buffer);

JustCreated:

            FileHeaderBuf.MaxSize   = pLogFile->ActualMaxFileSize;
            FileHeaderBuf.Flags     = 0;
            FileHeaderBuf.Retention = pLogFile->Retention;

            //
            // Copy the header into the file
            //
            ByteOffset = RtlConvertUlongToLargeInteger(0);

            Status = NtWriteFile(
                        pLogFile->FileHandle,   // Filehandle
                        NULL,                   // Event
                        NULL,                   // APC routine
                        NULL,                   // APC context
                        &IoStatusBlock,         // IO_STATUS_BLOCK
                        &FileHeaderBuf,         // Buffer
                        FILEHEADERBUFSIZE,      // Length
                        &ByteOffset,            // Byteoffset
                        NULL);                  // Key

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfpOpenLogfile: File header write for %ws failed %#x\n",
                         pLogFile->LogFileName->Buffer,
                         Status);

                goto cleanup;
            }

            //
            // Copy the "EOF" record right after the header
            //
            ByteOffset = RtlConvertUlongToLargeInteger(FILEHEADERBUFSIZE);

            Status = NtWriteFile(
                        pLogFile->FileHandle,   // Filehandle
                        NULL,                   // Event
                        NULL,                   // APC routine
                        NULL,                   // APC context
                        &IoStatusBlock,         // IO_STATUS_BLOCK
                        &EOFRecord,             // Buffer
                        ELFEOFRECORDSIZE,       // Length
                        &ByteOffset,            // Byteoffset
                        NULL);                  // Key

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfpOpenLogfile: EOF record write for %ws failed %#x\n",
                         pLogFile->LogFileName->Buffer,
                         Status);

                goto cleanup;
            }
        }

        //
        // Check to ensure that this is a valid log file. We look at the
        // size of the header and the signature to see if they match, as
        // well as checking the version number.
        //
        pLogFileHeader = (PELF_LOGFILE_HEADER) (pLogFile->BaseAddress);

        if ((pLogFileHeader->HeaderSize != FILEHEADERBUFSIZE)
              ||
            (pLogFileHeader->EndHeaderSize != FILEHEADERBUFSIZE)
              ||
            (pLogFileHeader->Signature  != ELF_LOG_FILE_SIGNATURE)
              ||
            (pLogFileHeader->MajorVersion != ELF_VERSION_MAJOR)
              ||
            (pLogFileHeader->MinorVersion != ELF_VERSION_MINOR))
        {
            //
            // This file is corrupt -- reset it to an empty log unless
            // it's being opened as a backup file.  If it is, fail the
            // open
            //
            ELF_LOG1(FILES,
                     "ElfpOpenLogfile: Invalid file header in %ws\n",
                     pLogFile->LogFileName->Buffer);

            if (LogType == ElfBackupLog)
            {
               Status = STATUS_EVENTLOG_FILE_CORRUPT;
               goto cleanup;
            }
            else
            {
                ElfpCreateQueuedAlert(ALERT_ELF_LogFileCorrupt,
                                      1,
                                      &pLogFile->LogModuleName->Buffer);
                //
                // Treat it like it was just created
                //
                goto JustCreated;
            }
        }
        else
        {
            //
            // If the "dirty" bit is set in the file header, then we need to
            // revalidate the BeginRecord and EndRecord fields since we did not
            // get a chance to write them out before the system was rebooted.
            // If the dirty bit is set and it's a backup file, just fail the
            // open.
            //
            if (pLogFileHeader->Flags & ELF_LOGFILE_HEADER_DIRTY)
            {
                ELF_LOG1(FILES,
                         "ElfpOpenLogfile: File %ws has dirty header\n",
                         pLogFile->LogFileName->Buffer);

                if (LogType == ElfBackupLog)
                {
                   Status = STATUS_EVENTLOG_FILE_CORRUPT;
                   goto cleanup;
                }
                else
                {
                   Status = RevalidateLogHeader (pLogFileHeader, pLogFile);
                }
            }

            if (NT_SUCCESS(Status))
            {
                //
                // Set the beginning and end record positions in our
                // data structure as well as the wrap flag if appropriate.
                //
                pLogFile->EndRecord   = pLogFileHeader->EndOffset;
                pLogFile->BeginRecord = pLogFileHeader->StartOffset;

                if (pLogFileHeader->Flags & ELF_LOGFILE_HEADER_WRAP)
                {
                    pLogFile->Flags |= ELF_LOGFILE_HEADER_WRAP;
                }

                ELF_LOG3(FILES,
                         "ElfpOpenLogfile: %ws log -- BeginRecord: %#x, EndRecord: %#x\n",
                         pLogFile->LogModuleName->Buffer,
                         pLogFile->BeginRecord,
                         pLogFile->EndRecord);
            }
            else
            {
                //
                // Couldn't validate the file, treat it like it was just
                // created (turn it into an empty file)
                //
                goto JustCreated;
            }

#ifdef CORRUPTED

            //
            // Just for debugging a log corruption problem
            //

            if (!VerifyLogIntegrity(pLogFile))
            {
                ELF_LOG1(ERROR,
                         "ElfpOpenLogfile: Integrity check failed for %ws\n",
                         pLogFile->LogFileName->Buffer);
            }

#endif // CORRUPTED

        }

        //
        // Fill in the first and last record number values in the LogFile
        // data structure.
        //
        // SS: Save the record number of the first record in this session
        // so that if the cluster service starts after the eventlog service
        // it will be able to forward the pending records for replication
        // when the cluster service registers
        //
        pLogFile->SessionStartRecordNumber = pLogFileHeader->CurrentRecordNumber;
        pLogFile->CurrentRecordNumber      = pLogFileHeader->CurrentRecordNumber;
        pLogFile->OldestRecordNumber       = pLogFileHeader->OldestRecordNumber;
    }

    return Status;

cleanup:

    //
    // Clean up anything that got allocated
    //
    if (pLogFile->ViewSize)
    {
        NtUnmapViewOfSection(NtCurrentProcess(), pLogFile->BaseAddress);
        pLogFile->BaseAddress = NULL;
    }

    if (pLogFile->SectionHandle)
    {
        NtClose(pLogFile->SectionHandle);
        pLogFile->SectionHandle = NULL;
    }

    if (pLogFile->FileHandle)
    {
        NtClose (pLogFile->FileHandle);
        pLogFile->FileHandle = NULL;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\memory.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    MEMORY.C

Abstract:

    This file contains the routines that deal with memory management.

Author:

    Rajen Shah	(rajens)    12-Jul-1991

[Environment:]

    User Mode - Win32, except for NTSTATUS returned by some functions.

Revision History:

    Jonathan Schwartz (jschwart)  10-Dec-1999
        Have the Eventlog use its own heap

--*/

//
// INCLUDES
//
#include <eventp.h>

//
// GLOBALS
//
PVOID g_pElfHeap;


VOID
ElfpCreateHeap(
    VOID
    )
{
    DWORD  dwHeapFlags;

#if DBG

    //
    // Turn on tail and free checking on debug builds.
    //
    dwHeapFlags = HEAP_GROWABLE
                   | HEAP_FREE_CHECKING_ENABLED
                   | HEAP_TAIL_CHECKING_ENABLED;

#else   // ndef DBG

    dwHeapFlags = HEAP_GROWABLE;

#endif  // DBG

    //
    // Create the heap
    //
    g_pElfHeap = RtlCreateHeap(dwHeapFlags,  // Flags
                               NULL,         // HeapBase
                               32 * 1024,    // ReserveSize (32K)
                               4096,         // CommitSize (4K)
                               NULL,         // HeapLock
                               NULL);        // GrowthThreshhold

    if (g_pElfHeap == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpCreateHeap: RtlCreateHeap failed -- using process heap\n");

        g_pElfHeap = RtlProcessHeap();
    }

    return;
}


PVOID
ElfpAllocateBuffer(
    ULONG Size
    )

/*++

Routine Description:

    Allocate a buffer of the given size


Arguments:

    Number of bytes to allocate

Return Value:

    Pointer to allocated buffer (or NULL).

--*/
{
    return RtlAllocateHeap(g_pElfHeap, 0, Size);
}



BOOLEAN
ElfpFreeBuffer(
    PVOID Address
    )

/*++

Routine Description:

    Frees a buffer previously allocated by ElfpAllocateBuffer.

Arguments:

    Pointer to buffer.

Return Value:

    TRUE if the block was properly freed, FALSE if not

Note:


--*/
{
    //
    // Note that RtlFreeHeap handles NULL
    //
    return RtlFreeHeap(g_pElfHeap, 0, Address);
}


PVOID
MIDL_user_allocate (
    size_t Size
    )
{
    //
    // The server-side RPC calls in the Eventlog expect any
    // UNICODE_STRINGs passed in either to have a length equal
    // to the max length or to be NULL-terminated.  We need to
    // zero the memory here to supply that NULL-termination.
    //
    return RtlAllocateHeap(g_pElfHeap, HEAP_ZERO_MEMORY, Size);
}


VOID
MIDL_user_free (
    PVOID Address
    )
{
    ElfpFreeBuffer(Address);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\operate.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    operate.c

Abstract:

    This file contains all the routines to perform operations on the
    log files. They are called by the thread that performs requests.

Author:

    Rajen Shah  (rajens)    16-Jul-1991

Revision History:

    04-Apr-1995     MarkBl
        Resets the file archive attribute on log write. The backup caller
        clears it.
    29-Aug-1994     Danl
        We no longer grow log files in place.  Therefore, the ExtendSize
        function will allocate a block that is as large as the old size plus
        the size of the new block that must be added.  If this allocation
        succeeds, then it will free up the old block.  If a failure occurs,
        we continue to use the old block as if we have already grown as much
        as we can.
    22-Jul-1994     Danl
        ValidFilePos:  Changed test for pEndRecordLen > PhysicalEOF
        so that it uses >=.  In the case where pEndRecordLen == PhysicalEOF,
        we want to wrap to find the last DWORD at the beginning of the File
        (after the header).

    08-Jul-1994     Danl
        PerformWriteRequest: Fixed overwrite logic so that in the case where
        a log is set up for always-overwrite, that we never go down the branch
        that indicates the log was full.  Previously, it would go down that
        branch if the current time was less than the log time (ie. someone
        set the clock back).

    18-Apr-2001     a-jyotig
		IsPositionWithinRange function changed to take 2 additional parameters 
		EOF and Base Address (BOF) and check if the position is between EOF
		and BOF
--*/

/****
@doc    EXTERNAL INTERFACES EVTLOG
****/

//
// INCLUDES
//
#include <eventp.h>
#include <alertmsg.h>  // ALERT_ELF manifests
#include "elfmsg.h"
#include <strsafe.h>
#define OVERWRITE_AS_NEEDED 0x00000000
#define NEVER_OVERWRITE     0xffffffff


//
// Prototypes
//

VOID PerformClearRequest(PELF_REQUEST_RECORD Request);

BOOL
IsPositionWithinRange(
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
	PVOID PhysEOF,
	PVOID BaseAddress
    );


VOID
ElfExtendFile (
    PLOGFILE pLogFile,
    ULONG    SpaceNeeded,
    PULONG   SpaceAvail
    )

/*++

Routine Description:

    This routine takes an open log file and extends the file and underlying
    section and view if possible.  If it can't be grown, it caps the file
    at this size by setting the ConfigMaxFileSize to the Actual.  It also
    updates the SpaceAvail parm which is used in PerformWriteRequest (the
    caller).

Arguments:

    pLogFile      - pointer to a LOGFILE structure for the open logfile
    ExtendAmount  - How much bigger to make the file/section/view
    SpaceAvail    - Update this with how much space was added to the section

Return Value:

    None - If we can't extend the file, we just cap it at this size for the
           duration of this boot.  We'll try again the next time the eventlog
           is closed and reopened.

Note:

    ExtendAmount should always be granular to 64K.

--*/
{
    LARGE_INTEGER NewSize;
    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T Size;
    IO_STATUS_BLOCK IoStatusBlock;

    //
    // Calculate how much to grow the file then extend the section by
    // that amount.  Do this in 64K chunks.
    //
    SpaceNeeded = ((SpaceNeeded - *SpaceAvail) & 0xFFFF0000) + 0x10000;

    if (SpaceNeeded > (pLogFile->ConfigMaxFileSize - pLogFile->ActualMaxFileSize))
    {
        //
        // We can't grow it by the full amount we need.  Grow
        // it to the max size and let file wrap take over.
        // If there isn't any room to grow, then return;
        //
        SpaceNeeded = pLogFile->ConfigMaxFileSize - pLogFile->ActualMaxFileSize;

        if (SpaceNeeded == 0)
        {
            return;
        }
    }

    NewSize = RtlConvertUlongToLargeInteger(pLogFile->ActualMaxFileSize + SpaceNeeded);

    //
    // Update the file size information, extend the section, and map the
    // new section
    //
    Status = NtSetInformationFile(pLogFile->FileHandle,
                                  &IoStatusBlock,
                                  &NewSize,
                                  sizeof(NewSize),
                                  FileEndOfFileInformation);


    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtSetInformationFile for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);

        goto ErrorExit;
    }

    Status = NtExtendSection(pLogFile->SectionHandle, &NewSize);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtExtendSection for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);

        goto ErrorExit;
    }

    //
    // Now that the section is extended, we need to map the new section.
    //

    //
    // Map a view of the entire section (with the extension).
    // Allow the allocator to tell us where it is located, and
    // what the size is.
    //
    BaseAddress = NULL;
    Size = 0;
    Status = NtMapViewOfSection(pLogFile->SectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                0,
                                NULL,
                                &Size,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE);

    if (!NT_SUCCESS(Status))
    {
        //
        // If this fails, just exit, and we will continue with the
        // view that we have.
        //
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtMapViewOfSection for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);

        goto ErrorExit;
    }

    //
    // Unmap the old section.
    //
    Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                  pLogFile->BaseAddress);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtUnmapeViewOfSection for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);
    }

    pLogFile->BaseAddress = BaseAddress;

    //
    // We managed to extend the file, update the actual size
    // and space available and press on.
    //
    if (pLogFile->Flags & ELF_LOGFILE_HEADER_WRAP)
    {
        //
        // Since we're wrapped, we want to move the "unwrapped" portion (i.e.,
        // everything from the first record to the end of the old file) down to
        // be at the bottom of the new file
        //
        // The call below moves memory as follows:
        //
        //  1. Destination -- PhysicalEOF - the size of the region
        //  2. Source      -- Address of the start of the first record
        //  3. Size        -- Num. bytes in the old file -
        //                      offset of the first record
        //
        //
        // Note that at this point, we have the following relevant variables
        //
        //  BaseAddress             -- The base address of the mapped section
        //  Size                    -- The size of the enlarged section
        //  pLogFile->ViewSize      -- The size of the old section
        //  pLogfile->BeginRecord   -- The offset of the first log record
        //

        //
        // Calculate the number of bytes to move
        //
        DWORD dwWrapSize = (DWORD)(pLogFile->ViewSize - pLogFile->BeginRecord);

        ELF_LOG1(FILES,
                 "ElfExtendFile: %ws is wrapped\n",
                 pLogFile->LogModuleName->Buffer);

        RtlMoveMemory((LPBYTE)BaseAddress + Size - dwWrapSize,
                      (LPBYTE)BaseAddress + pLogFile->BeginRecord,
                      dwWrapSize);

        //
        // We've moved the BeginRecord -- update the offset
        //
        pLogFile->BeginRecord = (ULONG)(Size - dwWrapSize);
    }

    pLogFile->ViewSize = (ULONG)Size;
    pLogFile->ActualMaxFileSize += SpaceNeeded;
    *SpaceAvail += SpaceNeeded;

    //
    // Now flush this to disk to commit it
    //
    BaseAddress = pLogFile->BaseAddress;
    Size        = FILEHEADERBUFSIZE;

    Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                  &BaseAddress,
                                  &Size,
                                  &IoStatusBlock);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtFlushVirtualMemory for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);
    }

    return;

ErrorExit:

    //
    // Couldn't extend the section for some reason.  Just wrap the file now.
    // Cap the file at this size, so we don't try and extend the section on
    // every write.  The next time the eventlog service is started up it
    // will revert to the configured max again.
    //

    //
    // BUGBUG:  Generate an Alert here
    //
    ELF_LOG1(ERROR,
             "ElfExtendFile: Couldn't extend %ws log\n",
             pLogFile->LogModuleName->Buffer);

    pLogFile->ConfigMaxFileSize = pLogFile->ActualMaxFileSize;

    return;
}



NTSTATUS
CopyUnicodeToAnsiRecord (
    OUT PVOID  Dest       OPTIONAL,
    IN  PVOID  Src,
    OUT PVOID  *NewBufPos OPTIONAL,
    OUT PULONG RecordSize
    )

/*++

Routine Description:

    This routine reads from the event log specified in the request packet.

    This routine uses memory mapped I/O to access the log file. This makes
    it much easier to move around the file.

Arguments:

    Dest - Points to destination buffer.  If NULL, calculate and return
           the record length without copying the record.

    Src  - Points to the UNICODE record.

    NewBufPos - Gets offset in Dest buffer after record just transferred.
                If Dest is NULL, this is ignored.

    RecordSize - Gets size of this (ANSI) record.

Return Value:

    STATUS_SUCCESS if no errors occur.  Specific NTSTATUS error otherwise.

Note:

--*/
{
    ANSI_STRING     StringA;
    UNICODE_STRING  StringU;
    PEVENTLOGRECORD SrcRecord, DestRecord;
    PWSTR           pStringU;
    PVOID           TempPtr;
    ULONG           PadSize, i;
    ULONG           zero = 0;
    WCHAR           *SrcStrings, *DestStrings;
    ULONG           RecordLength, *pLength;
    ULONG           ulTempLength;

    NTSTATUS        Status = STATUS_SUCCESS;

    DestRecord = (PEVENTLOGRECORD)Dest;
    SrcRecord  = (PEVENTLOGRECORD)Src;

    if (DestRecord != NULL)
    {
        DestRecord->TimeGenerated = SrcRecord->TimeGenerated;
        DestRecord->Reserved      = SrcRecord->Reserved;
        DestRecord->RecordNumber  = SrcRecord->RecordNumber;
        DestRecord->TimeWritten   = SrcRecord->TimeWritten;
        DestRecord->EventID       = SrcRecord->EventID;
        DestRecord->EventType     = SrcRecord->EventType;
        DestRecord->EventCategory = SrcRecord->EventCategory;
        DestRecord->NumStrings    = SrcRecord->NumStrings;
        DestRecord->UserSidLength = SrcRecord->UserSidLength;
        DestRecord->DataLength    = SrcRecord->DataLength;
    }

    //
    // Convert and copy over modulename
    //
    pStringU = (PWSTR)((ULONG_PTR)SrcRecord + sizeof(EVENTLOGRECORD));

    RtlInitUnicodeString(&StringU, pStringU);

    if (DestRecord != NULL)
    {
        Status = RtlUnicodeStringToAnsiString(&StringA,
                                              &StringU,
                                              TRUE);

        ulTempLength = StringA.MaximumLength;
    }
    else
    {
        ulTempLength = RtlUnicodeStringToAnsiSize(&StringU);
    }

    if (NT_SUCCESS(Status))
    {
        TempPtr = (PVOID)((ULONG_PTR)DestRecord + sizeof(EVENTLOGRECORD));

        if (DestRecord != NULL)
        {
            RtlMoveMemory ( TempPtr, StringA.Buffer, ulTempLength );
            RtlFreeAnsiString(&StringA);
        }

        TempPtr = (PVOID)((ULONG_PTR) TempPtr + ulTempLength);

        //
        // Convert and copy over computername
        //
        // TempPtr points to location in the destination for the computername
        //

        pStringU = (PWSTR)((ULONG_PTR)pStringU + StringU.MaximumLength);

        RtlInitUnicodeString ( &StringU, pStringU );

        if (DestRecord != NULL)
        {
            Status = RtlUnicodeStringToAnsiString (
                                        &StringA,
                                        &StringU,
                                        TRUE
                                        );

            ulTempLength = StringA.MaximumLength;
        }
        else
        {
            ulTempLength = RtlUnicodeStringToAnsiSize(&StringU);
        }

        if (NT_SUCCESS(Status))
        {
            if (DestRecord != NULL)
            {
                RtlMoveMemory ( TempPtr, StringA.Buffer, ulTempLength );
                RtlFreeAnsiString(&StringA);
            }

            TempPtr = (PVOID)((ULONG_PTR) TempPtr + ulTempLength);
        }
    }

    if (NT_SUCCESS(Status))
    {
        // TempPtr points to location after computername - i.e. UserSid.
        // Before we write out the UserSid, we ensure that we pad the
        // bytes so that the UserSid starts on a DWORD boundary.
        //
        PadSize = sizeof(ULONG)
                      - (ULONG)(((ULONG_PTR)TempPtr-(ULONG_PTR)DestRecord) % sizeof(ULONG));

        if (DestRecord != NULL)
        {
            RtlMoveMemory (TempPtr, &zero, PadSize);

            TempPtr = (PVOID)((ULONG_PTR)TempPtr + PadSize);

            //
            // Copy over the UserSid.
            //

            RtlMoveMemory(TempPtr,
                          (PVOID)((ULONG_PTR)SrcRecord + SrcRecord->UserSidOffset),
                          SrcRecord->UserSidLength);

            DestRecord->UserSidOffset = (ULONG)((ULONG_PTR)TempPtr - (ULONG_PTR)DestRecord);
        }
        else
        {
            TempPtr = (PVOID)((ULONG_PTR)TempPtr + PadSize);
        }

        //
        // Copy over the Strings
        //
        TempPtr = (PVOID)((ULONG_PTR)TempPtr + SrcRecord->UserSidLength);
        SrcStrings = (WCHAR *)((ULONG_PTR)SrcRecord + (ULONG)SrcRecord->StringOffset);
        DestStrings = (WCHAR *)TempPtr;

        for (i=0; i < SrcRecord->NumStrings; i++)
        {
            RtlInitUnicodeString (&StringU, SrcStrings);

            if (DestRecord != NULL)
            {
                Status = RtlUnicodeStringToAnsiString(&StringA,
                                                      &StringU,
                                                      TRUE);

                ulTempLength = StringA.MaximumLength;
            }
            else
            {
                ulTempLength = RtlUnicodeStringToAnsiSize(&StringU);
            }

            if (!NT_SUCCESS(Status))
            {
                //
                // Bail out
                //
                return Status;
            }

            if (DestRecord != NULL)
            {
                RtlMoveMemory(DestStrings,
                              StringA.Buffer,
                              ulTempLength);

                RtlFreeAnsiString (&StringA);
            }

            DestStrings = (WCHAR*)((ULONG_PTR)DestStrings + (ULONG)ulTempLength);
            SrcStrings  = (WCHAR*)((ULONG_PTR)SrcStrings + (ULONG)StringU.MaximumLength);
        }

        //
        // DestStrings points to the point after the last string copied.
        //
        if (DestRecord != NULL)
        {
            DestRecord->StringOffset = (ULONG)((ULONG_PTR)TempPtr - (ULONG_PTR)DestRecord);

            TempPtr = (PVOID)DestStrings;

            //
            // Copy over the binary Data
            //
            DestRecord->DataOffset = (ULONG)((ULONG_PTR)TempPtr - (ULONG_PTR)DestRecord);

            RtlMoveMemory(TempPtr,
                          (PVOID)((ULONG_PTR)SrcRecord + SrcRecord->DataOffset),
                          SrcRecord->DataLength);
        }
        else
        {
            TempPtr = (PVOID)DestStrings;
        }

        //
        // Now do the pad bytes.
        //
        TempPtr = (PVOID) ((ULONG_PTR) TempPtr + SrcRecord->DataLength);
        PadSize = sizeof(ULONG)
                      - (ULONG) (((ULONG_PTR) TempPtr - (ULONG_PTR) DestRecord) % sizeof(ULONG));

        RecordLength = (ULONG) ((ULONG_PTR) TempPtr
                                     + PadSize
                                     + sizeof(ULONG)
                                     - (ULONG_PTR)DestRecord);

        if (DestRecord != NULL)
        {
            RtlMoveMemory (TempPtr, &zero, PadSize);
            pLength = (PULONG)((ULONG_PTR)TempPtr + PadSize);
            *pLength = RecordLength;
            DestRecord->Length = RecordLength;

            ASSERT(((ULONG_PTR) DestRecord + RecordLength) ==
                       ((ULONG_PTR) pLength + sizeof(ULONG)));

            *NewBufPos = (PVOID) ((ULONG_PTR) DestRecord + RecordLength);
        }

        *RecordSize = RecordLength;
    }

    return Status;

} // CopyUnicodeToAnsiRecord


BOOL
ValidFilePos (
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
    PVOID PhysicalEOF,
    PVOID BaseAddress,
    BOOL  fCheckBeginEndRange
    )

/*++

Routine Description:

    This routine determines whether we are pointing to a valid beginning
    of an event record in the event log.  It does this by validating
    the signature then comparing the length at the beginning of the record to
    the length at the end, both of which have to be at least the size of the
    fixed length portion of an eventlog record.

Arguments:

    Position        - Pointer to be verified.
    BeginningRecord - Pointer to the beginning record in the file.
    EndingRecord    - Pointer to the byte after the ending record in the file.
    PhysicalEOF     - Pointer the physical end of the log.
    BaseAddress     - Pointer to the physical beginning of the log.

Return Value:

    TRUE if this position is valid.

Note:

    There is a possibility of error if a record just happens to have the
    ULONG at the current position the same as the value that number of
    bytes further on in the record. However, this is a very slim chance
    as it must have a valid log signature as well.

--*/
{
    PULONG  pEndRecordLength;
    BOOL    fValid = TRUE;

    PEVENTLOGRECORD pEventRecord;


    try
    {
        pEventRecord = (PEVENTLOGRECORD)Position;

        //
        // Verify that the pointer is within the range of BEGINNING->END
        //
        if ( fCheckBeginEndRange )
        {
            fValid = IsPositionWithinRange(Position,
                                           BeginningRecord,
                                           EndingRecord,
										   PhysicalEOF,
										   BaseAddress);
        }

        //
        // If the offset looks OK, then examine the lengths at the beginning
        // and end of the current record. If they don't match, then the position
        // is invalid.
        //
        if (fValid)
        {
            //
            // Make sure the length is a multiple number of DWORDS
            //
            if (pEventRecord->Length & 3)
            {
                fValid = FALSE;
            }
            else
            {
                pEndRecordLength = (PULONG) ((PBYTE) Position + pEventRecord->Length) - 1;

                //
                // If the file is wrapped, adjust the pointer to reflect the
                // portion of the record that is wrapped starting after the
                // header
                //
                if ((PVOID) pEndRecordLength >= PhysicalEOF)
                {
                   pEndRecordLength = (PULONG) ((PBYTE) BaseAddress +
                                                ((PBYTE) pEndRecordLength - (PBYTE) PhysicalEOF) +
                                                FILEHEADERBUFSIZE);
                }

				// Do a sanity check on this pointer before dereferencing.  DAVJ

                if ((PVOID) pEndRecordLength > PhysicalEOF)
				{
					return FALSE;
				}

                if (pEventRecord->Length == *pEndRecordLength
                     &&
                    pEventRecord->Length == ELFEOFRECORDSIZE)
                {
                    ULONG Size;

                    Size = min(ELFEOFUNIQUEPART,
                               (ULONG) ((PBYTE) PhysicalEOF - (PBYTE) pEventRecord));

                    if (RtlCompareMemory(pEventRecord,
                                         &EOFRecord,
                                         Size) == Size)
                    {
                        Size = ELFEOFUNIQUEPART - Size;

                        //
                        // If Size is non-zero, then the unique portion of
                        // the EOF record is wrapped across the end of file.
                        // Continue comparison at file beginning for the
                        // remainder of the record.
                        //
                        if ( Size )
                        {
                            PBYTE pRemainder = (PBYTE) &EOFRecord + ELFEOFUNIQUEPART - Size;

                            fValid = (RtlCompareMemory((PBYTE) BaseAddress + FILEHEADERBUFSIZE,
                                                       pRemainder,
                                                       Size) == Size);
                        }
                    }
                    else
                    {
                        fValid = FALSE;
                    }
                }
                else if ((pEventRecord->Length < sizeof(EVENTLOGRECORD))
                           ||
                         (pEventRecord->Reserved != ELF_LOG_FILE_SIGNATURE)
                           ||
                         (pEventRecord->Length != *pEndRecordLength))
                {
                    fValid = FALSE;
                }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG2(ERROR,
                 "ValidFilePos: Exception %#x caught validating file position %p\n",
                 GetExceptionCode(),
                 BeginningRecord);

       fValid = FALSE;
    }

    return fValid;
}


BOOL
IsPositionWithinRange(
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
	PVOID PhysEOF,
	PVOID BaseAddress
    )
{
    //
    // Verify that the pointer is within the range of [Beginning, End]
    //
    
	//This check was introduced to make sure that the position does not 
	//cross the file boundaries. Refer to Bug #370063. If required, one 
	//can change this check to make sure that the position lies between 
	//PhyStart i.e. BaseAddress + FILEHEADERBUFSIZE

	if((Position < BaseAddress) || (Position > PhysEOF))
		return FALSE;

	else if (EndingRecord > BeginningRecord)
    {
        return ((Position >= BeginningRecord) && (Position <= EndingRecord));
    }
    else if (EndingRecord < BeginningRecord)
    {
        return ((Position >= BeginningRecord) || (Position <= EndingRecord));
    }

    //
    // If BeginningRecord and EndingRecord are equal, it means that the only
    // record in the log file is the EOF record.  In that case, return FALSE
    // as Position isn't pointing to a valid (i.e., non-EOF) record.
    //
    return FALSE;
}


PVOID
FindStartOfNextRecord (
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
    PVOID PhysicalStart,
    PVOID PhysicalEOF,
    PVOID BaseAddress
    )

/*++

Routine Description:

    This routine starts at Position, and finds the beginning of the next
    valid record, wrapping around the physical end of the file if necessary.

Arguments:

    Position        - Pointer at which to start the search.
    BeginningRecord - Pointer to the beginning record in the file.
    EndingRecord    - Pointer to the byte after the ending record in the file.
    PhysicalStart   - Pointer to the start of log information (after header)
    PhysicalEOF     - Pointer to the physical end of the log.
    BaseAddress     - Pointer to the physical beginning of the log.

Return Value:

    A pointer to the start of the next valid record, NULL if there is no
    valid record.

Note:

    There is a possibility of error if a record just happens to have the
    ULONG at the current position the same as the value that number of
    bytes further on in the record. However, this is a very slim chance
    as it must have a valid log signature as well.

--*/
{
    PULONG ptr;
    PULONG EndOfBlock;
    PULONG EndOfFile;
    PVOID  pRecord;
    ULONG  Size;
    BOOL   StillLooking = TRUE;

    //
    // Search for a ULONG which matches a record signature
    //
    ptr = (PULONG) Position;
    EndOfBlock = EndOfFile = (PULONG) PhysicalEOF - 1;

    while (StillLooking)
    {
        //
        // Check to see if it is the EOF record
        //
        if (*ptr == ELFEOFRECORDSIZE)
        {
            //
            // Only scan up to the end of the file.  Just compare up the
            // constant information
            //

            //
            // BUGBUG:  If (End - pEvent) is less than ELFEOFUNIQUEPART,
            //          we never validate what should be the remainder of
            //          the EOF record at the start of the logfile
            //
            Size = min(ELFEOFUNIQUEPART,
                       (ULONG) ((PBYTE) PhysicalEOF - (PBYTE) ptr));

            pRecord = CONTAINING_RECORD(ptr,
                                        ELF_EOF_RECORD,
                                        RecordSizeBeginning);

            if (RtlCompareMemory(pRecord,
                                 &EOFRecord,
                                 Size) == Size)
            {
                ELF_LOG1(FILES,
                         "FindStartOfNextRecord: Found EOF record at %p\n",
                         pRecord);

                //
                // This is the EOF record, back up to the last record
                //
                (PBYTE) pRecord -= *((PULONG) pRecord - 1);

                if (pRecord < PhysicalStart)
                {
                    pRecord = (PBYTE) PhysicalEOF -
                                   ((PBYTE)PhysicalStart - (PBYTE)pRecord);
                }
            }

            if (ValidFilePos(pRecord,
                             BeginningRecord,
                             EndingRecord,
                             PhysicalEOF,
                             BaseAddress,
                             TRUE))
            {
                ELF_LOG1(FILES,
                         "FindStartOfNextRecord: Valid record at %p preceding EOF record\n",
                         pRecord);

                return pRecord;
            }
        }

        //
        // Check to see if it is an event record
        //
        if (*ptr == ELF_LOG_FILE_SIGNATURE)
        {
            //
            // This is a signature, see if the containing record is valid
            //
            pRecord = CONTAINING_RECORD(ptr,
                                        EVENTLOGRECORD,
                                        Reserved);

            if (ValidFilePos(pRecord,
                             BeginningRecord,
                             EndingRecord,
                             PhysicalEOF,
                             BaseAddress,
                             TRUE))
            {
                ELF_LOG1(FILES,
                         "FindStartOfNextRecord: Valid record found at %p\n",
                         pRecord);

                return pRecord;
            }
        }

        //
        // Bump to the next byte and see if we're done.
        //
        ptr++;

        if (ptr >= EndOfBlock)
        {
            //
            // Need the second test on this condition in case Position
            // happens to equal PhysicalEOF - 1 (EndOfBlock initial value);
            // without this, this loop would terminate prematurely.
            //
            if ((EndOfBlock == (PULONG) Position)
                  &&
                ((PULONG) Position != EndOfFile))
            {
                //
                // This was the top half, so we're done
                //
                StillLooking = FALSE;

                ELF_LOG0(FILES,
                         "FindStartOfNextRecord: Unsuccessfully searched "
                             "top half of file\n");
            }
            else
            {
                //
                // This was the bottom half, let's look in the top half
                //
                EndOfBlock = (PULONG) Position;
                ptr = (PULONG) PhysicalStart;

                ELF_LOG0(FILES,
                         "FindStartOfNextRecord: Unsuccessfully searched "
                             "bottom half of file -- searching top half\n");
            }
        }
    }

    //
    // Didn't find a valid record
    //
    return NULL;
}


PVOID
NextRecordPosition (
    ULONG   ReadFlags,
    PVOID   CurrPosition,
    ULONG   CurrRecordLength,
    PVOID   BeginRecord,
    PVOID   EndRecord,
    PVOID   PhysicalEOF,
    PVOID   PhysStart
    )

/*++

Routine Description:

    This routine seeks to the beginning of the next record to be read
    depending on the flags in the request packet.

Arguments:

    ReadFlags        - Read forwards or backwards
    CurrPosition     - Pointer to the current position.
    CurrRecordLength - Length of the record at the last position read.
    BeginRecord      - Logical first record
    EndRecord        - Logical last record (EOF record)
    PhysEOF          - End of file
    PhysStart        - Start of file pointer (following file header).

Return Value:

    New position or NULL if invalid record.

Note:


--*/
{

    PVOID       NewPosition;
    ULONG       Length;
    PDWORD      FillDword;

    if (ReadFlags & EVENTLOG_FORWARDS_READ)
    {
        //
        // If we're pointing at the EOF record, just set the position to
        // the first record
        //
        if (CurrRecordLength == ELFEOFRECORDSIZE)
        {
            ELF_LOG1(FILES,
                     "NextRecordPosition: Pointing to EOF record -- returning "
                         "address of first record (%p)\n",
                     BeginRecord);

            return BeginRecord;
        }

        NewPosition = (PVOID) ((ULONG_PTR) CurrPosition + CurrRecordLength);

        //
        // Take care of wrapping.
        //
        if (NewPosition >= PhysicalEOF)
        {
            NewPosition = (PBYTE)PhysStart
                               + ((PBYTE) NewPosition - (PBYTE) PhysicalEOF);
        }

        //
        // If this is a ELF_SKIP_DWORD, skip to the top of the file
        //
        if (*(PDWORD) NewPosition == ELF_SKIP_DWORD)
        {
           NewPosition = PhysStart;
        }
    }
    else
    {
        //
        // Reading backwards.
        //
        ASSERT (ReadFlags & EVENTLOG_BACKWARDS_READ);

        if (CurrPosition == BeginRecord)
        {
            //
            // This is the "end of file" if we're reading backwards.
            //
            ELF_LOG1(FILES,
                     "NextRecordPosition: Reading backwards and pointing to first "
                         "record -- returning address of last record (%p)\n",
                     EndRecord);

            return EndRecord;
        }
        else if (CurrPosition == PhysStart)
        {
           //
           // Flip to the bottom of the file, but skip and ELF_SKIP_DWORDs
           //
           FillDword = (PDWORD) PhysicalEOF; // last dword
           FillDword--;

           while (*FillDword == ELF_SKIP_DWORD)
           {
              FillDword--;
           }

           CurrPosition = (PVOID) (FillDword + 1);
        }

        Length = *((PULONG) CurrPosition - 1);

        if (Length < ELFEOFRECORDSIZE)
        {
            //
            // Bogus length, must be invalid record
            //
            ELF_LOG1(FILES,
                     "NextRecordPosition: Invalid record length (%d) encountered\n",
                     Length);

            return NULL;
        }

        NewPosition = (PBYTE) CurrPosition - Length;

        //
        // Take care of wrapping
        //

        if (NewPosition < PhysStart)
        {
            NewPosition = (PBYTE) PhysicalEOF
                               - ((PBYTE) PhysStart - (PBYTE) NewPosition);
        }
    }

    return NewPosition;
}



NTSTATUS
SeekToStartingRecord (
    PELF_REQUEST_RECORD Request,
    PVOID   *ReadPosition,
    PVOID   BeginRecord,
    PVOID   EndRecord,
    PVOID   PhysEOF,
    PVOID   PhysStart
    )
/*++

Routine Description:

    This routine seeks to the correct position as indicated in the
    request packet.

Arguments:

    Pointer to the request packet.
    Pointer to a pointer where the final position after the seek is returned.

Return Value:

    NTSTATUS and new position in file.

Note:

    This routine ensures that it is possible to seek to the position
    specified in the request packet. If not, then an error is returned
    which indicates that the file probably changed between the two
    READ operations, or else the record offset specified is beyond the
    end of the file.

--*/
{
    PVOID       Position;
    ULONG       RecordLen;
    ULONG       NumRecordsToSeek;
    ULONG       BytesPerRecord;
    ULONG       NumberOfRecords;
    ULONG       NumberOfBytes;
    ULONG       ReadFlags;

    //
    // If the beginning and the end are the same, then there are no
    // entries in this file.
    //
    if (BeginRecord == EndRecord)
    {
        ELF_LOG1(FILES,
                 "SeekToStartingRecord: %ws log is empty\n",
                 Request->Module->ModuleName);

        return STATUS_END_OF_FILE;
    }

    //
    // Find the last position (or the "beginning" if this is the first READ
    // call for this handle).
    //
    if (Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_SEQUENTIAL_READ)
    {
        if (Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_FORWARDS_READ)
        {
            //
            // If this is the first READ operation, LastSeekPosition will
            // be zero. In that case, we set the position to the first
            // record (in terms of time) in the file.
            //
            if (Request->Pkt.ReadPkt->LastSeekPos == 0)
            {
                ELF_LOG1(FILES,
                         "SeekToStartingRecord: First read (forwards) of %ws log\n",
                         Request->Module->ModuleName);

                Position = BeginRecord;
            }
            else
            {
                Position = (PBYTE) Request->LogFile->BaseAddress
                                + Request->Pkt.ReadPkt->LastSeekPos;

                //
                // If we're changing the direction we're reading, skip
                // forward one record.  This is because we're pointing at
                // the "next" record based on the last read direction
                //
                if (!(Request->Pkt.ReadPkt->Flags & ELF_LAST_READ_FORWARD))
                {
                    Position = NextRecordPosition(Request->Pkt.ReadPkt->ReadFlags,
                                                  Position,
                                                  ((PEVENTLOGRECORD) Position)->Length,
                                                  BeginRecord,
                                                  EndRecord,
                                                  PhysEOF,
                                                  PhysStart);
                }
                else
                {
                    //
                    // This *really* cheesy check exists to handle the case
                    // where Position could be on an ELF_SKIP_DWORD pad
                    // dword at end of the file.
                    //
                    // NB:  Must be prepared to handle an exception since
                    //      a somewhat unknown pointer is dereferenced.
                    //
                    NTSTATUS Status = STATUS_SUCCESS;

                    try
                    {
                        if (IsPositionWithinRange(Position,
                                                  BeginRecord,
                                                  EndRecord,
												  PhysEOF,
                                                  Request->LogFile->BaseAddress))
                        {
                            //
                            // If this is an ELF_SKIP_DWORD, skip to the
                            // top of the file.
                            //
                            if (*(PDWORD) Position == ELF_SKIP_DWORD)
                            {
                                ELF_LOG1(FILES,
                                         "SeekToStartingRecord: Next forward read position "
                                             "in %ws log is on an ELF_SKIP_DWORD\n",
                                         Request->Module->ModuleName);

                                Position = PhysStart;
                            }
                        }
                        else
                        {
                            //
                            // More likely the caller's handle was invalid
                            // if the position was not within range.
                            //
                            ELF_LOG1(ERROR,
                                     "SeekToStartingRecord: Next forward read position "
                                         "in %ws log is out of range -- log is corrupt\n",
                                     Request->Module->ModuleName);

                            Status = STATUS_INVALID_HANDLE;
                        }
                    }
                    except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        ELF_LOG2(ERROR,
                                 "SeekToStartingRecord: Caught exception %#x looking for "
                                     "next forward read position in %ws log\n",
                                 GetExceptionCode(),
                                 Request->Module->ModuleName);

                        Status = STATUS_EVENTLOG_FILE_CORRUPT;
                    }

                    if (!NT_SUCCESS(Status))
                    {
                        *ReadPosition = NULL;
                        return Status;
                    }
                }
            }
        }
        else
        {
            //
            // READ backwards
            //

            // If this is the first READ operation, LastSeekPosition will
            // be zero. In that case, we set the position to the last
            // record (in terms of time) in the file.
            //
            if (Request->Pkt.ReadPkt->LastSeekPos == 0)
            {
                ELF_LOG1(FILES,
                         "SeekToStartingRecord: First read (backwards) of %ws log\n",
                         Request->Module->ModuleName);

                Position = EndRecord;

                //
                // Subtract the length of the last record from the current
                // position to get to the beginning of the record.
                //
                // If that moves beyond the physical beginning of the file,
                // then we need to wrap around to the physical end of the file.
                //
                Position = (PBYTE) Position - *((PULONG) Position - 1);

                if (Position < PhysStart)
                {
                    Position = (PBYTE) PhysEOF - ((PBYTE) PhysStart - (PBYTE) Position);
                }
            }
            else
            {
                Position = (PBYTE) Request->LogFile->BaseAddress
                                + Request->Pkt.ReadPkt->LastSeekPos;

                //
                // If we're changing the direction we're reading, skip
                // forward one record.  This is because we're pointing at
                // the "next" record based on the last read direction
                //
                if (Request->Pkt.ReadPkt->Flags & ELF_LAST_READ_FORWARD)
                {
                    Position = NextRecordPosition(Request->Pkt.ReadPkt->ReadFlags,
                                                  Position,
                                                  0,          // not used if reading backwards
                                                  BeginRecord,
                                                  EndRecord,
                                                  PhysEOF,
                                                  PhysStart);
                }
            }
        }
    }
    else if (Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_SEEK_READ)
    {
        //
        // Make sure the record number passed in is valid
        //
        if (Request->Pkt.ReadPkt->RecordNumber < Request->LogFile->OldestRecordNumber
             ||
            Request->Pkt.ReadPkt->RecordNumber >= Request->LogFile->CurrentRecordNumber)
        {
            ELF_LOG1(ERROR,
                     "SeekToStartingRecord: Invalid record number %d\n",
                     Request->Pkt.ReadPkt->RecordNumber);

            return STATUS_INVALID_PARAMETER;
        }

        //
        // We're seeking to an absolute record number, so use the following
        // algorithm:
        //
        //   1. Calculate the average number of bytes per record
        //
        //   2. Based on this number seek to where the record should start
        //
        //   3. Find the start of the next record in the file
        //
        //   4. Walk (forwards or backwards) from there to the right record
        //

        //
        // 1. Calculate the average number of bytes per record
        //
        NumberOfRecords = Request->LogFile->CurrentRecordNumber
                              - Request->LogFile->OldestRecordNumber;

        NumberOfBytes = Request->LogFile->Flags & ELF_LOGFILE_HEADER_WRAP ?
                            Request->LogFile->ActualMaxFileSize :
                            Request->LogFile->EndRecord;

        NumberOfBytes -= FILEHEADERBUFSIZE;
        BytesPerRecord = NumberOfBytes / NumberOfRecords;

        //
        // 2. Calcuate the first guess as to what the offset of the desired
        //    record should be
        //
        Position = (PBYTE) Request->LogFile->BaseAddress
                        + Request->LogFile->BeginRecord
                        + BytesPerRecord
                            * (Request->Pkt.ReadPkt->RecordNumber
                                   - Request->LogFile->OldestRecordNumber);

        //
        // Align the position to a ULONG bountry.
        //
        Position = (PVOID) (((ULONG_PTR) Position + sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1));

        //
        // Take care of file wrap
        //
        if (Position >= PhysEOF)
        {
            Position = (PBYTE)PhysStart +
                            ((PBYTE) Position - (PBYTE) PhysEOF);

            if (Position >= PhysEOF)
            {
                //
                // It's possible, in an obscure error case, that Position
                // may still be beyond the EOF. Adjust, if so.
                //
                Position = BeginRecord;
            }
        }

        //
        // Bug fix:
        //
        // 57017 - Event Log Causes Services.Exe to Access Violate therefore
        //         Hanging the Server
        //
        // The calculation above can easily put Position out of range of
        // the begin/end file markers. This is not good. Adjust Position,
        // if necessary.
        //
        if (BeginRecord < EndRecord && Position >= EndRecord)
        {
            Position = BeginRecord;
        }
        else if (BeginRecord > EndRecord && Position >= EndRecord && Position < BeginRecord)
        {
            Position = BeginRecord;
        }
        else
        {
            // Do nothing.
        }

        //
        // 3. Get to the start of the next record after Position
        //
        Position = FindStartOfNextRecord(Position,
                                         BeginRecord,
                                         EndRecord,
                                         PhysStart,
                                         PhysEOF,
                                         Request->LogFile->BaseAddress);

        //
        //   4. Walk (forwards or backwards) from Position to the right record
        //
        if (Position)
        {
            if (Request->Pkt.ReadPkt->RecordNumber >
                    ((PEVENTLOGRECORD) Position)->RecordNumber)
            {
                NumRecordsToSeek = Request->Pkt.ReadPkt->RecordNumber
                                       - ((PEVENTLOGRECORD) Position)->RecordNumber;

                ReadFlags = EVENTLOG_FORWARDS_READ;

                ELF_LOG2(FILES,
                         "SeekToStartingRecord: Walking forward %d records from record %d\n",
                         NumRecordsToSeek,
                         ((PEVENTLOGRECORD) Position)->RecordNumber);
            }
            else
            {
                NumRecordsToSeek = ((PEVENTLOGRECORD) Position)->RecordNumber
                                        - Request->Pkt.ReadPkt->RecordNumber;

                ReadFlags = EVENTLOG_BACKWARDS_READ;

                ELF_LOG2(FILES,
                         "SeekToStartingRecord: Walking backward %d records from record %d\n",
                         NumRecordsToSeek,
                         ((PEVENTLOGRECORD) Position)->RecordNumber);
            }
        }

        while (Position != NULL && NumRecordsToSeek--)
        {
            RecordLen = ((PEVENTLOGRECORD) Position)->Length;

            Position = NextRecordPosition(ReadFlags,
                                          Position,
                                          RecordLen,
                                          BeginRecord,
                                          EndRecord,
                                          PhysEOF,
                                          PhysStart);
        }
    }
    else
    {
        //
        // Flags didn't specify a sequential or seek read
        //
        return STATUS_INVALID_PARAMETER;
    }

    *ReadPosition = Position;       // This is the new seek position

    if (!Position)
    {
        //
        // The record was invalid
        //
        ELF_LOG1(ERROR,
                 "SeekToStartingRecord: Position is NULL -- %ws log is corrupt\n",
                 Request->Module->ModuleName);

        return STATUS_EVENTLOG_FILE_CORRUPT;
    }

    return STATUS_SUCCESS;
}


VOID
CopyRecordToBuffer(
    IN     PBYTE       pReadPosition,
    IN OUT PBYTE       *ppBufferPosition,
    IN     ULONG       ulRecordSize,
    IN     PBYTE       pPhysicalEOF,
    IN     PBYTE       pPhysStart
    )

/*++

Routine Description:

    This routine copies the EVENTLOGRECORD at pReadPosition into
    *ppBufferPosition

Return Value:

    None.

--*/
{
    ULONG       ulBytesToMove;    // Number of bytes to copy

    ASSERT(ppBufferPosition != NULL);

    //
    // If the number of bytes to the end of the file is less than the
    // size of the record, then part of the record has wrapped to the
    // beginning of the file - transfer the bytes piece-meal.
    //
    // Otherwise, transfer the whole record.
    //
    ulBytesToMove = min(ulRecordSize,
                        (ULONG) (pPhysicalEOF - pReadPosition));

    if (ulBytesToMove < ulRecordSize)
    {
        //
        // We need to copy the bytes up to the end of the file,
        // and then wrap around and copy the remaining bytes of
        // this record.
        //
        RtlMoveMemory(*ppBufferPosition, pReadPosition, ulBytesToMove);

        //
        // Advance user buffer pointer, move read position to the
        // beginning of the file (past the file header), and
        // update bytes remaining to be moved for this record.
        //
        *ppBufferPosition += ulBytesToMove;

        pReadPosition = pPhysStart;

        ulBytesToMove = ulRecordSize - ulBytesToMove;     // Remaining bytes
    }

    //
    // Move the remaining bytes of the record OR the full record.
    //
    RtlMoveMemory(*ppBufferPosition, pReadPosition, ulBytesToMove);

    //
    // Update to new read positions
    //
    *ppBufferPosition += ulBytesToMove;
}


NTSTATUS
ReadFromLog(
    PELF_REQUEST_RECORD Request
    )
/*++

Routine Description:

    This routine reads from the event log specified in the request packet.

    This routine uses memory mapped I/O to access the log file. This makes
    it much easier to move around the file.

Arguments:

    Pointer to the request packet.

Return Value:

    NTSTATUS.

Note:

--*/
{
    NTSTATUS    Status;
    PVOID       ReadPosition;           // Current read position in file
    PVOID       BufferPosition;         // Current position in user's buffer
    ULONG       TotalBytesRead;         // Total Bytes transferred
    ULONG       TotalRecordsRead;       // Total records transferred
    ULONG       BytesInBuffer;          // Bytes remaining in buffer
    ULONG       RecordSize;             // Size of event record
    PVOID       PhysicalEOF;            // Physical end of file
    PVOID       PhysStart;              // Physical start of file (after file hdr)
    PVOID       BeginRecord;            // Points to first record
    PVOID       EndRecord;              // Points to byte after last record
    PVOID       TempBuf = NULL, TempBufferPosition;
    ULONG       RecordBytesTransferred;
    PEVENTLOGRECORD pEvent;

    //
    // Initialize variables.
    //
    BytesInBuffer    = Request->Pkt.ReadPkt->BufferSize;
    BufferPosition   = Request->Pkt.ReadPkt->Buffer;
    TotalBytesRead   = 0;
    TotalRecordsRead = 0;

    PhysicalEOF = (LPBYTE) Request->LogFile->BaseAddress
                       + Request->LogFile->ViewSize;

    PhysStart   = (LPBYTE) Request->LogFile->BaseAddress
                       + FILEHEADERBUFSIZE;

    BeginRecord = (LPBYTE) Request->LogFile->BaseAddress
                       + Request->LogFile->BeginRecord;   // Start at first record

    EndRecord   = (LPBYTE) Request->LogFile->BaseAddress
                       + Request->LogFile->EndRecord;     // Byte after end of last record

    //
    // "Seek" to the starting record depending on either the last seek
    // position, or the starting record offset passed in.
    //
    Status = SeekToStartingRecord(Request,
                                  &ReadPosition,
                                  BeginRecord,
                                  EndRecord,
                                  PhysicalEOF,
                                  PhysStart);

    if (NT_SUCCESS(Status))
    {
        //
        // Make sure the record is valid
        //

        if (!ValidFilePos(ReadPosition,
                          BeginRecord,
                          EndRecord,
                          PhysicalEOF,
                          Request->LogFile->BaseAddress,
                          TRUE))
        {
            ELF_LOG1(ERROR,
                     "ReadFromLog: Next record (%p) is not valid -- log is corrupt\n",
                     ReadPosition);

            Request->Pkt.ReadPkt->BytesRead = 0;
            Request->Pkt.ReadPkt->RecordsRead = 0;

            return STATUS_INVALID_HANDLE;
        }

        // make sure that if we asked for a specific record, that we got it

        if ((Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_SEEK_READ) &&
            (Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_BACKWARDS_READ))
        {
            pEvent = (PEVENTLOGRECORD)ReadPosition;
            if(pEvent->Length == ELFEOFRECORDSIZE || 
               pEvent->RecordNumber != Request->Pkt.ReadPkt->RecordNumber)
            {
                Request->Pkt.ReadPkt->BytesRead = 0;
                Request->Pkt.ReadPkt->RecordsRead = 0;
                return STATUS_EVENTLOG_FILE_CORRUPT;
            }
        }


        RecordSize = RecordBytesTransferred = *(PULONG) ReadPosition;

        if ((Request->Pkt.ReadPkt->Flags & ELF_IREAD_ANSI)
              &&
            (RecordSize != ELFEOFRECORDSIZE))
        {
            //
            //
            // If we were called by an ANSI API, then we need to read the
            // next record into a temporary buffer, process the data in
            // that record and copy it over to the real buffer as ANSI
            // strings (rather than UNICODE).
            //
            // We need to do this here since we won't be able to
            // appropriately size a record that wraps for an ANSI
            // call otherwise (we'll AV trying to read it past
            // the end of the log).
            //
            TempBuf = ElfpAllocateBuffer(RecordSize);

            if (TempBuf == NULL)
            {
                ELF_LOG0(ERROR,
                         "ReadFromLog: Unable to allocate memory for "
                             "Ansi record (1st call)\n");

                return STATUS_NO_MEMORY;
            }

            TempBufferPosition = BufferPosition;    // Save this away
            BufferPosition     = TempBuf;           // Read into TempBuf

            CopyRecordToBuffer((PBYTE) ReadPosition,
                               (PBYTE *) &BufferPosition,
                               RecordSize,
                               (PBYTE) PhysicalEOF,
                               (PBYTE) PhysStart);

            //
            // Call CopyUnicodeToAnsiRecord with a NULL destination
            // location in order to get the size of the Ansi record
            //
            Status = CopyUnicodeToAnsiRecord(NULL,
                                             TempBuf,
                                             NULL,
                                             &RecordBytesTransferred);

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG1(ERROR,
                         "ReadFromLog: CopyUnicodeToAnsiRecord failed %#x (1st call)\n",
                         Status);

                ElfpFreeBuffer(TempBuf);
                return Status;
            }
        }

        //
        // While there are records to be read, and more space in the buffer,
        // keep on reading records into the buffer.
        //
        while((RecordBytesTransferred <= BytesInBuffer)
                &&
              (RecordSize != ELFEOFRECORDSIZE))
        {
            //
            // If we were called by an ANSI API, then we need to take the
            // record read into TempBuf and transfer it over to the user's
            // buffer while converting any UNICODE strings to ANSI.
            //
            if (Request->Pkt.ReadPkt->Flags & ELF_IREAD_ANSI)
            {
                Status = CopyUnicodeToAnsiRecord(TempBufferPosition,
                                                 TempBuf,
                                                 &BufferPosition,
                                                 &RecordBytesTransferred);

                //
                // RecordBytesTransferred contains the bytes actually
                // copied into the user's buffer.
                //
                // BufferPosition points to the point in the user's buffer
                // just after this record.
                //
                ElfpFreeBuffer(TempBuf);
                TempBuf = NULL;

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "ReadFromLog: CopyUnicodeToAnsiRecord failed %x "
                                 "(2nd call)\n",
                             Status);

                    //
                    // Stop reading
                    //
                    break;
                }
            }
            else
            {
                //
                // Unicode call -- simply copy the record into the buffer
                //
                CopyRecordToBuffer((PBYTE) ReadPosition,
                                   (PBYTE *) &BufferPosition,
                                   RecordSize,
                                   (PBYTE) PhysicalEOF,
                                   (PBYTE) PhysStart);
            }

            //
            // Update the byte and record counts
            //
            TotalRecordsRead++;
            TotalBytesRead += RecordBytesTransferred;
            BytesInBuffer  -= RecordBytesTransferred;

            ReadPosition = NextRecordPosition(Request->Pkt.ReadPkt->ReadFlags,
                                              ReadPosition,
                                              RecordSize,
                                              BeginRecord,
                                              EndRecord,
                                              PhysicalEOF,
                                              PhysStart);

            //
            // Make sure the record is valid
            //
            if (ReadPosition == NULL
                 ||
                !ValidFilePos(ReadPosition,
                              BeginRecord,
                              EndRecord,
                              PhysicalEOF,
                              Request->LogFile->BaseAddress,
                              TRUE))
            {
                ELF_LOG0(ERROR,
                         "ReadFromLog: Next record is invalid -- log is corrupt\n");

                return STATUS_EVENTLOG_FILE_CORRUPT;
            }

            RecordSize = RecordBytesTransferred = *(PULONG) ReadPosition;

            if ((Request->Pkt.ReadPkt->Flags & ELF_IREAD_ANSI)
                  &&
                (RecordSize != ELFEOFRECORDSIZE))
            {
                TempBuf = ElfpAllocateBuffer(RecordSize);

                if (TempBuf == NULL)
                {
                    ELF_LOG0(ERROR,
                             "ReadFromLog: Unable to allocate memory for "
                                 "Ansi record (2nd call)\n");

                    return STATUS_NO_MEMORY;
                }

                TempBufferPosition = BufferPosition;    // Save this away
                BufferPosition     = TempBuf;           // Read into TempBuf

                CopyRecordToBuffer((PBYTE) ReadPosition,
                                   (PBYTE *) &BufferPosition,
                                   RecordSize,
                                   (PBYTE) PhysicalEOF,
                                   (PBYTE) PhysStart);

                //
                // Call CopyUnicodeToAnsiRecord with a NULL destination
                // location in order to get the size of the Ansi record
                //
                Status = CopyUnicodeToAnsiRecord(NULL,
                                                 TempBuf,
                                                 NULL,
                                                 &RecordBytesTransferred);

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "ReadFromLog: CopyUnicodeToAnsiRecord failed %#x "
                                 "(1st call)\n",
                             Status);

                    ElfpFreeBuffer(TempBuf);
                    return Status;
                }
            }
        } // while

        ElfpFreeBuffer(TempBuf);
        TempBuf = NULL;

        //
        // If we got to the end and did not read in any records, return
        // an error indicating that the user's buffer is too small if
        // we're not at the EOF record, or end of file if we are.
        //
        if (TotalRecordsRead == 0)
        {
            if (RecordSize == ELFEOFRECORDSIZE)
            {
                ELF_LOG0(FILES,
                         "ReadFromLog: No records read -- pointing at EOF record\n");

                Status = STATUS_END_OF_FILE;
            }
            else
            {
                //
                // We didn't read any records, and we're not at EOF, so
                // the buffer was too small
                //
                ELF_LOG1(ERROR,
                         "ReadFromLog: No records read -- buffer was too small "
                             "(%d bytes needed)\n",
                         RecordBytesTransferred);

                Status = STATUS_BUFFER_TOO_SMALL;
                Request->Pkt.ReadPkt->MinimumBytesNeeded = RecordBytesTransferred;
            }
        }

        //
        // Update the current file position.
        //
        Request->Pkt.ReadPkt->LastSeekPos =
                                (ULONG) ((ULONG_PTR) ReadPosition
                                             - (ULONG_PTR) Request->LogFile->BaseAddress);

        Request->Pkt.ReadPkt->LastSeekRecord += TotalRecordsRead;

        ELF_LOG1(FILES,
                 "ReadFromLog: %d records successfully read\n",
                 TotalRecordsRead);
    }
    else
    {
        ELF_LOG1(ERROR,
                 "ReadFromLog: SeekToStartingRecord failed %#x\n",
                 Status);
    }

    //
    // Set the bytes read in the request packet for return to client.
    //
    Request->Pkt.ReadPkt->BytesRead   = TotalBytesRead;
    Request->Pkt.ReadPkt->RecordsRead = TotalRecordsRead;

    return Status;
}




VOID
PerformReadRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine performs the READ request.
    It first grabs the log file structure resource and then proceeds
    to read from the file. If the resource is not available, it will
    block until it is.

    This routine impersonates the client in order to ensure that the correct
    access control is uesd. If the client does not have permission to read
    the file, the operation will fail.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE

Note:


--*/
{

    //
    // Get shared access to the log file. This will allow multiple
    // readers to get to the file together.
    //
    RtlAcquireResourceShared(&Request->Module->LogFile->Resource,
                             TRUE);                  // Wait until available

    //
    // Try to read from the log.  Note that a corrupt log is the
    // most likely cause of an exception (garbage pointers, etc).
    // The eventlog corruption error is a bit all-inclusive, but
    // necessary, since log state is pretty much indeterminable
    // in this situation.
    //
    try
    {
        Request->Status = ReadFromLog(Request);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG2(ERROR,
                 "PerformReadRequest: Caught exception %#x reading %ws log\n",
                 GetExceptionCode(),
                 Request->Module->ModuleName);

        Request->Status = STATUS_EVENTLOG_FILE_CORRUPT;
    }

    //
    // Release the resource
    //
    RtlReleaseResource(&Request->Module->LogFile->Resource);
}

//
// BUGBUG: These are only used in WriteToLog and they're not modified.
//         Probably cleaner to make them #define'd constants.
//
WCHAR wszAltDosDevices[] = L"\\DosDevices\\";
WCHAR wszDosDevices[] = L"\\??\\";
#define DOSDEVICES_LEN  ((sizeof(wszDosDevices) / sizeof(WCHAR)) - 1)
#define ALTDOSDEVICES_LEN  ((sizeof(wszAltDosDevices) / sizeof(WCHAR)) - 1)


VOID
WriteToLog(
    PLOGFILE    pLogFile,
    PVOID       Buffer,
    ULONG       BufSize,
    PULONG      Destination,
    ULONG       PhysEOF,
    ULONG       PhysStart
    )

/*++

Routine Description:

    This routine writes the record into the log file, allowing for wrapping
    around the end of the file.

    It assumes that the caller has serialized access to the file, and has
    ensured that there is enough space in the file for the record.

Arguments:

    Buffer      - Pointer to the buffer containing the event record.
    BufSize     - Size of the record to be written.
    Destination - Pointer to the destination - which is in the log file.
    PhysEOF     - Physical end of file.
    PhysStart   - Physical beginning of file (past the file header).

Return Value:

    NONE.

Note:


--*/
{
    ULONG    BytesToCopy;
    SIZE_T   FlushSize;
    ULONG    NewDestination;
    NTSTATUS Status;
    PVOID    BaseAddress;
    LPWSTR   pwszLogFileName;

    LARGE_INTEGER   ByteOffset;
    IO_STATUS_BLOCK IoStatusBlock;

    BytesToCopy = min(PhysEOF - *Destination, BufSize);

    ByteOffset = RtlConvertUlongToLargeInteger(*Destination);

    //
    // BUGBUG: If this call fails, we shouldn't set *Destination to
    //         NewDestination below.  The same is true if the second
    //         NtWriteFile call fails.
    //
    Status = NtWriteFile(pLogFile->FileHandle,   // Filehandle
                         NULL,                   // Event
                         NULL,                   // APC routine
                         NULL,                   // APC context
                         &IoStatusBlock,         // IO_STATUS_BLOCK
                         Buffer,                 // Buffer
                         BytesToCopy,            // Length
                         &ByteOffset,            // Byteoffset
                         NULL);                  // Key

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "WriteToLog: NtWriteFile (1st call) failed %#x\n",
                 Status);
    }

    NewDestination = *Destination + BytesToCopy;

    if (BytesToCopy != BufSize)
    {
        //
        // Wrap around to the beginning of the file and copy the
        // rest of the data.
        //
        Buffer = (PBYTE) Buffer + BytesToCopy;

        BytesToCopy = BufSize - BytesToCopy;

        ByteOffset = RtlConvertUlongToLargeInteger(PhysStart);

        Status = NtWriteFile(pLogFile->FileHandle,   // Filehandle
                             NULL,                   // Event
                             NULL,                   // APC routine
                             NULL,                   // APC context
                             &IoStatusBlock,         // IO_STATUS_BLOCK
                             Buffer,                 // Buffer
                             BytesToCopy,            // Length
                             &ByteOffset,            // Byteoffset
                             NULL);                  // Key

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "WriteToLog: NtWriteFile (2nd call) failed %#x\n",
                     Status);
        }

        NewDestination = PhysStart + BytesToCopy;

        //
        // Set "wrap" bit in log file structure
        //
        pLogFile->Flags |= ELF_LOGFILE_HEADER_WRAP;

        //
        // Now flush this to disk to commit it
        //
        BaseAddress = pLogFile->BaseAddress;
        FlushSize   = FILEHEADERBUFSIZE;

        Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                      &BaseAddress,
                                      &FlushSize,
                                      &IoStatusBlock);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "WriteToLog: NtFlushVirtualMemory failed %#x\n",
                     Status);
        }
    }

    *Destination = NewDestination;          // Return new destination

    //
    // Providing all succeeded above, if not set, set the archive file
    // attribute on this log.
    //

    if (NT_SUCCESS(Status)
         &&
        !(pLogFile->Flags & ELF_LOGFILE_ARCHIVE_SET))
    {
        //
        // Advance past prefix string, '\??\' or '\DosDevices\'
        //
        if ((pLogFile->LogFileName->Length / 2) >= DOSDEVICES_LEN
              &&
            !_wcsnicmp(wszDosDevices, pLogFile->LogFileName->Buffer, DOSDEVICES_LEN))
        {
            pwszLogFileName = pLogFile->LogFileName->Buffer + DOSDEVICES_LEN;
        }
        else if ((pLogFile->LogFileName->Length / 2) >= ALTDOSDEVICES_LEN
                   &&
                  !_wcsnicmp(wszAltDosDevices, pLogFile->LogFileName->Buffer, ALTDOSDEVICES_LEN))
        {
            pwszLogFileName = pLogFile->LogFileName->Buffer + ALTDOSDEVICES_LEN;
        }
        else
        {
            pwszLogFileName = pLogFile->LogFileName->Buffer;
        }

        if (SetFileAttributes(pwszLogFileName, FILE_ATTRIBUTE_ARCHIVE))
        {
            pLogFile->Flags |= ELF_LOGFILE_ARCHIVE_SET;
        }
        else
        {
            ELF_LOG2(ERROR,
                     "WriteToLog: SetFileAttributes on file %ws failed %d\n",
                     pwszLogFileName,
                     GetLastError());
        }
    }
}


NTSTATUS
AutoBackupLogFile(PELF_REQUEST_RECORD Request, ULONG OverwrittenEOF)

/*++

Routine Description:

    This routine makes a best attempt to backup the log file.
    It will log an event in the SECURITY log file indicating
    success or failure.

Arguments:

    Pointer to the request packet.

Return Value:

    NTSTATUS

Note:

--*/
{
    UNICODE_STRING BackupFileNameU;
    WCHAR          BackupFileName[64]; // holds the "unique" part of the name (wsprintf)
    PLOGFILE       pLogFile;           // For optimized access to structure
    WCHAR          BackupFileNamePrefix[] = L"Archive-";
    WCHAR*         EventMessage[3];
    WCHAR          Number[20]; // long enough to hold a DWORD represented as a string
    SYSTEMTIME          SystemTime;
    ELF_REQUEST_RECORD  ClearRequest;
    CLEAR_PKT           ClearPkt;
    USHORT              ClearStatus;
    NTSTATUS Status;
    ULONG WritePos;               // Position to write record
    
    pLogFile = Request->LogFile;          // Set local variable

    if (OverwrittenEOF)
    {
        //
        // The EOF record was at the end of the physical file,
        // and we overwrote it with ELF_SKIP_DWORDs, so we need
        // to put it back since we're not going to be able to
        // write a record.  We also need to turn the wrap bit
        // back off
        //
        pLogFile->Flags &= ~(ELF_LOGFILE_HEADER_WRAP);
        pLogFile->EndRecord = OverwrittenEOF;
        WritePos = OverwrittenEOF;

        //
        // Write out the EOF record
        //
        WriteToLog(pLogFile,
                   &EOFRecord,
                   ELFEOFRECORDSIZE,
                   &WritePos,
                   pLogFile->ActualMaxFileSize,
                   FILEHEADERBUFSIZE);

    }
    Status = FlushLogFile(pLogFile);
    if (!NT_SUCCESS(Status))
        return Status;

    //
    // Make BackupFileNameU unique.
    // Allocate enough space for the current LogModuleName, a NULL character, 
    // and BackupFileName bytes.
    // If AutoBackupPath is non-NULL, add space for that too.
    //
    // Rename file in place.
    //
    BackupFileNameU.Length = 0;
    BackupFileNameU.MaximumLength = ((wcslen(pLogFile->LogModuleName->Buffer) +
                                      wcslen(BackupFileNamePrefix) + 1        ) * sizeof(WCHAR)) + 
                                    sizeof(BackupFileName);
    BackupFileNameU.Buffer = ElfpAllocateBuffer(BackupFileNameU.MaximumLength);
    if (BackupFileNameU.Buffer == NULL) 
    {
        ELF_LOG0(ERROR,
             "AutoBackupLogFile:  failed due to lack of memory\n");
        return STATUS_NO_MEMORY;
    }

    StringCbCopy(BackupFileNameU.Buffer, BackupFileNameU.MaximumLength, 
                                BackupFileNamePrefix); 
    StringCbCat(BackupFileNameU.Buffer, BackupFileNameU.MaximumLength, 
                                pLogFile->LogModuleName->Buffer); 
    
    GetSystemTime(&SystemTime);

    StringCchPrintfW(BackupFileName, 64, L"-%u-%02u-%02u-%02u-%02u-%02u-%03u.evt", 
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond,
        SystemTime.wMilliseconds);

    StringCbCat(BackupFileNameU.Buffer, BackupFileNameU.MaximumLength,BackupFileName);
    BackupFileNameU.Length = wcslen(BackupFileNameU.Buffer) * sizeof(WCHAR);
    
    //
    // Fill in the request packet
    //

    ClearRequest.Pkt.ClearPkt = &ClearPkt;
    ClearRequest.Flags = 0;
    ClearRequest.Module = Request->Module;
    ClearRequest.LogFile = Request->LogFile;
    ClearRequest.Command = ELF_COMMAND_CLEAR;
    ClearRequest.Status = STATUS_SUCCESS;
    ClearRequest.Pkt.ClearPkt->BackupFileName = &BackupFileNameU;
    
    PerformClearRequest(&ClearRequest);

    //
    // Generate an audit in the Security log.
    //

    StringCchPrintfW(Number, 20, L"0x%x", ClearRequest.Status);

    EventMessage[0] = pLogFile->LogModuleName->Buffer;
    EventMessage[1] = BackupFileNameU.Buffer;
    EventMessage[2] = Number;

    if (NT_SUCCESS(ClearRequest.Status))
    {
        ELF_LOG0(TRACE,
                         "AutoBackupLogFile: auto backup and clear worked\n");
        
        ClearStatus = EVENTLOG_AUDIT_SUCCESS;
    }
    else
    {
        ELF_LOG1(ERROR,
                         "AutoBackupLogFile: failed calling clear/backup, error 0x%x\n",
                         ClearRequest.Status);
        ClearStatus = EVENTLOG_AUDIT_FAILURE;
    }
    
    ElfpCreateElfEvent(
         0x20c,                         // todo, get the #def
        ClearStatus,
        1,                      // EventCategory  (SE_CATEGID_SYSTEM)
        3,                      // NumberOfStrings
        EventMessage,           // Strings
        NULL,                   // Data
        0,                      // Datalength
        0,                      // Do not Overwrite if necc.
        TRUE);                  // For the Security Log file
    
    ElfpFreeBuffer(BackupFileNameU.Buffer);

    return ClearRequest.Status;
}


VOID
PerformWriteRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine writes the event log entry to the log file specified in
    the request packet.
    There is no need to impersonate the client since we want all clients
    to have access to writing to the log file.

    This routine does not use memory mapped I/O to access the log file. This
    is so the changes can be immediately committed to disk if that was how
    the log file was opened.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE

Note:

--*/
{
    NTSTATUS Status;
    ULONG WritePos;               // Position to write record
    LARGE_INTEGER Time;
    ULONG SpaceNeeded;            // Record size + "buffer" size
    ULONG CurrentTime = 0;
    PEVENTLOGRECORD EventRecord;
    ULONG RecordSize;
    ULONG DeletedRecordOffset;
    ULONG SpaceAvail;
    ULONG EarliestTime;
    PLOGFILE pLogFile;               // For optimized access to structure
    PELF_LOGFILE_HEADER pFileHeader;
    PVOID BaseAddress;
    IO_STATUS_BLOCK IoStatusBlock;
    PEVENTLOGRECORD pEventLogRecord;
    PDWORD FillDword;
    ULONG OverwrittenEOF = 0;
    BOOL bSecurity =  FALSE;
    BOOL fRetryWriteRequest = FALSE;

    pLogFile = Request->LogFile;          // Set local variable

    // Set some basic BOOLs

    if(!_wcsicmp(pLogFile->LogModuleName->Buffer, ELF_SECURITY_MODULE_NAME))
        bSecurity = TRUE;
    else
        bSecurity = FALSE;

    //This condition occurs under stress conditions 
    //and causes an AV further in this function
    if(pLogFile->BaseAddress == NULL) 
    {
        Request->Status = STATUS_INVALID_HANDLE;
        return;
    }
    //
    // Get exclusive access to the log file. This will ensure no one
    // else is accessing the file.
    //
    RtlAcquireResourceExclusive(&pLogFile->Resource,
                                TRUE);                  // Wait until available

    try
    {

RetryWriteRequest:
        
        //
        // Put in the record number
        //
        pEventLogRecord = (PEVENTLOGRECORD) Request->Pkt.WritePkt->Buffer;
        pEventLogRecord->RecordNumber = pLogFile->CurrentRecordNumber;

        //
        // Now, go to the end of the file and look for empty space.
        //
        // If there is enough space to write out the record, just
        // write it out and update the pointers.
        //
        // If there isn't enough space, then we need to check if we can
        // wrap around the file without overwriting any records that are
        // within the time retention period.
        // If we cannot find any room, then we have to return an error
        // that the file is full (and alert the administrator).
        //
        RecordSize  = Request->Pkt.WritePkt->Datasize;
        SpaceNeeded = RecordSize + ELFEOFRECORDSIZE;

        if (pLogFile->EndRecord > pLogFile->BeginRecord)
        {
            //
            // The current write position is after the position of the first
            // record, then we can write up to the end of the file without
            // worrying about overwriting existing records.
            //
            SpaceAvail = pLogFile->ActualMaxFileSize
                             - (pLogFile->EndRecord - pLogFile->BeginRecord + FILEHEADERBUFSIZE);
        }
        else if (pLogFile->EndRecord == pLogFile->BeginRecord
                  &&
                 !(pLogFile->Flags & ELF_LOGFILE_HEADER_WRAP))
        {
            //
            // If the write position is equal to the position of the first
            // record, and we have't wrapped yet, then the file is "empty"
            // and so we have room to the physical end of the file.
            //
            SpaceAvail = pLogFile->ActualMaxFileSize - FILEHEADERBUFSIZE;
        }
        else
        {
            //
            // If our write position is before the position of the first record, then
            // the file has wrapped and we need to deal with overwriting existing
            // records in the file.
            //
            SpaceAvail = pLogFile->BeginRecord - pLogFile->EndRecord;
        }

        //
        // We now have the number of bytes available to write the record
        // WITHOUT overwriting any existing records stored in SpaceAvail.
        // If that amount is not sufficient, then we need to create more space
        // by "deleting" existing records that are older than the retention
        // time that was configured for this file.
        //
        // We check the retention time against the time when the log was
        // written since that is consistent at the server. We cannot use the
        // client's time since that may vary if the clients are in different
        // time zones.
        //
        NtQuerySystemTime(&Time);
        RtlTimeToSecondsSince1970(&Time, &CurrentTime);

        EarliestTime = CurrentTime - pLogFile->Retention;

        Status = STATUS_SUCCESS;        // Initialize for return to caller

        //
        // Check to see if the file hasn't reached its maximum allowable
        // size yet, and also hasn't wrapped.  If not, grow it by as much as
        // needed, in 64K chunks.
        //
        if (pLogFile->ActualMaxFileSize < pLogFile->ConfigMaxFileSize
             &&
            SpaceNeeded > SpaceAvail)
        {
            //
            // Extend it.  This call cannot fail.  If it can't extend it, it
            // just caps it at the current size by changing
            // pLogFile->ConfigMaxFileSize
            //
            ElfExtendFile(pLogFile,
                          SpaceNeeded,
                          &SpaceAvail);
        }

        //
        // We don't want to split the fixed portion of a record across the
        // physical end of the file, it makes it difficult when referencing
        // these fields later (you have to check before you touch each one
        // to make sure it's not after the physical EOF).  So, if there's
        // not enough room at the end of the file for the fixed portion,
        // we fill it with a known byte pattern (ELF_SKIP_DWORD) that will
        // be skipped if it's found at the start of a record (as long as
        // it's less than the minimum record size, then we know it's not
        // the start of a valid record).
        //
        if (pLogFile->ActualMaxFileSize - pLogFile->EndRecord < sizeof(EVENTLOGRECORD))
        {
            //
            // Save the EndRecord pointer.  In case we don't have the space
            // to write another record, we'll need to rewrite the EOF where
            // it was
            //
            OverwrittenEOF = pLogFile->EndRecord;

            FillDword = (PDWORD) ((PBYTE) pLogFile->BaseAddress + pLogFile->EndRecord);

            while (FillDword < (PDWORD) ((LPBYTE) pLogFile->BaseAddress +
                                              pLogFile->ActualMaxFileSize))
            {
                   *FillDword = ELF_SKIP_DWORD;
                   FillDword++;
            }

            pLogFile->EndRecord = FILEHEADERBUFSIZE;
            SpaceAvail          = pLogFile->BeginRecord - FILEHEADERBUFSIZE;
            pLogFile->Flags    |= ELF_LOGFILE_HEADER_WRAP;
        }

        EventRecord = (PEVENTLOGRECORD) ((PBYTE) pLogFile->BaseAddress
                                              + pLogFile->BeginRecord);

        while (SpaceNeeded > SpaceAvail)
        {
            //
            // If this logfile can be overwrite-as-needed, or if it has
            // an overwrite time limit and the time hasn't expired, then
            // allow the new event to overwrite an older event.
            //
            if (pLogFile->Retention == OVERWRITE_AS_NEEDED
                 ||
                (pLogFile->Retention != NEVER_OVERWRITE
                  &&
                 (EventRecord->TimeWritten < EarliestTime
                   ||
                  Request->Flags & ELF_FORCE_OVERWRITE)))
            {
                //
                // OK to overwrite
                //
                ULONG NextRecord;
                ULONG SearchStartPos;
                BOOL  fBeginningRecordWrap = FALSE;
                BOOL  fInvalidRecordLength = FALSE;

                DeletedRecordOffset = pLogFile->BeginRecord;

                pLogFile->BeginRecord += EventRecord->Length;

                //
                // Ensure BeginRecord offset is DWORD-aligned.
                //
                pLogFile->BeginRecord = (pLogFile->BeginRecord + sizeof(ULONG) - 1)
                                             & ~(sizeof(ULONG) - 1);

                //
                // Check specifically for a record length value of zero.
                // Zero is considered invalid.
                //
                if (EventRecord->Length == 0)
                {
                    ELF_LOG2(ERROR,
                             "PerformWriteRequest: Zero-length record at "
                                 "offset %d in %ws log\n",
                             DeletedRecordOffset,
                             pLogFile->LogModuleName->Buffer);

                    fInvalidRecordLength = TRUE;
                }

                if (pLogFile->BeginRecord >= pLogFile->ActualMaxFileSize)
                {
                    ULONG BeginRecord;

                    //
                    // We're about to wrap around the end of the file. Adjust
                    // BeginRecord accordingly.
                    //
                    fBeginningRecordWrap = TRUE;
                    BeginRecord          = FILEHEADERBUFSIZE
                                               + (pLogFile->BeginRecord
                                                      - pLogFile->ActualMaxFileSize);

                    //
                    // If the record length was bogus (very large), it's possible
                    // the wrap-adjusted computed position is still beyond the
                    // end of file.  In thise case, mark it as bogus.
                    //
                    if (BeginRecord >= pLogFile->ActualMaxFileSize)
                    {
                        ELF_LOG3(ERROR,
                                 "PerformWriteRequest: Too-large record length (%#x) "
                                     "at offset %d in %ws log\n",
                                 EventRecord->Length,
                                 DeletedRecordOffset,
                                 pLogFile->LogModuleName->Buffer);

                        fInvalidRecordLength = TRUE;
                    }
                    else
                    {
                        pLogFile->BeginRecord = BeginRecord;
                    }
                }

                if (fInvalidRecordLength)
                {
                    //
                    // If the record length is considered bogus, adjust
                    // BeginRecord to be just beyond the length and signature of
                    // the previous record to scan for the next valid record.
                    //
                    pLogFile->BeginRecord = DeletedRecordOffset
                                                + (sizeof(ULONG) * 2);
                }

                //
                // Ensure the record referenced is indeed a valid record and that
                // we're not reading into a partially overwritten record. With a
                // circular log, it's possible to partially overwrite existing
                // entries with the EOF record and/or ELF_SKIP_DWORD values.
                //
                // Skip the record size to the record signature since the loop
                // below will search for the next valid signature.  Note that
                // the increment of SpaceAvail is undone when we find a valid
                // record below.
                //
                NextRecord = pLogFile->BeginRecord + sizeof(ULONG);

                if (NextRecord < pLogFile->ActualMaxFileSize)
                {
                    SpaceAvail += min(sizeof(ULONG),
                                      pLogFile->ActualMaxFileSize - NextRecord);
                }

                //
                // Seek to find a record signature.
                //
                SearchStartPos = pLogFile->BeginRecord;

                for ( ;; )
                {
                    PVOID Position;

                    for ( ;
                         NextRecord != SearchStartPos;
                         SpaceAvail += sizeof(ULONG), NextRecord += sizeof(ULONG))
                    {
                        if (NextRecord >= pLogFile->ActualMaxFileSize)
                        {
                            NextRecord = pLogFile->BeginRecord = FILEHEADERBUFSIZE;
                        }

                        if (*(PULONG) ((PBYTE) pLogFile->BaseAddress + NextRecord)
                                 == ELF_LOG_FILE_SIGNATURE)
                        {
                            //
                            // Found the next valid record signature
                            //
                            break;
                        }
                    }

                    Position = (PULONG) ((PBYTE) pLogFile->BaseAddress + NextRecord);

                    if (*(PULONG) Position == ELF_LOG_FILE_SIGNATURE)
                    {
                        //
                        // This record is valid so far, perform a final, more
                        // rigorous check for record validity.
                        //
                        if (ValidFilePos(CONTAINING_RECORD(Position,
                                                           EVENTLOGRECORD,
                                                           Reserved),
                                         NULL,
                                         NULL,
                                         (PBYTE) pLogFile->BaseAddress
                                              + pLogFile->ViewSize,
                                         pLogFile->BaseAddress,
                                         FALSE))
                         {
                            //
                            // The record is valid. Adjust SpaceAvail to not
                            // include a sub-portion of this record in the
                            // available space computation.
                            //
                            SpaceAvail -= sizeof(ULONG);
                            pLogFile->BeginRecord = NextRecord - sizeof(ULONG);
                            break;
                        }
                        else
                        {
                            //
                            // Continue the search for the next valid record.
                            //
                            // NB : Not calling FixContextHandlesForRecord
                            //      since we have not established a valid
                            //      beginning record position yet. Not that
                            //      it would do any good - this condition would
                            //      be evaluated in cases of corrupt logs.
                            //
                            ELF_LOG2(FILES,
                                     "PerformWriteRequest: Valid record signature with "
                                         "invalid record found at offset %d of %ws log\n",
                                     NextRecord,
                                     pLogFile->LogModuleName->Buffer);

                            SpaceAvail += sizeof(ULONG);
                            NextRecord += sizeof(ULONG);
                            continue;
                        }
                    }
                    else
                    {
                        //
                        // Not a single valid record can be found.  This is not
                        // good.  Consider the log corrupted and bail the write.
                        //
                        ELF_LOG1(ERROR,
                                 "PerformWriteRequest: No valid records found in %ws log\n",
                                 pLogFile->LogModuleName->Buffer);

                        Status = STATUS_EVENTLOG_FILE_CORRUPT;
                        ASSERT(Status != STATUS_EVENTLOG_FILE_CORRUPT);
                        break;
                    }
                }

                if (Status == STATUS_EVENTLOG_FILE_CORRUPT)
                {
                    break;
                }

                if (fBeginningRecordWrap)
                {
                    //
                    // Check to see if the file has reached its maximum allowable
                    // size yet.  If not, grow it by as much as needed in 64K
                    // chunks.
                    //
                    if (pLogFile->ActualMaxFileSize < pLogFile->ConfigMaxFileSize)
                    {
                        //
                        // Extend it.  This call cannot fail.  If it can't
                        // extend it, it just caps it at the current size by
                        // changing pLogFile->ConfigMaxFileSize.
                        //
                        ElfExtendFile(pLogFile,
                                      SpaceNeeded,
                                      &SpaceAvail);

                        //
                        // Since extending the file will cause it to be moved, we
                        // need to re-establish the address for the EventRecord.
                        //
                        EventRecord = (PEVENTLOGRECORD) ((PBYTE) pLogFile->BaseAddress
                                                              + DeletedRecordOffset);
                    }
                }

                //
                // Make sure no handle points to the record that we're getting
                // ready to overwrite, it one does, correct it to point to the
                // new first record.
                //
                FixContextHandlesForRecord(DeletedRecordOffset,
                                           pLogFile->BeginRecord);

                if (!fInvalidRecordLength)
                {
                    //
                    // Update SpaceAvail to include the deleted record's size.
                    // That is, if we have a high degree of confidence that
                    // it is valid.
                    //
                    SpaceAvail += EventRecord->Length;
                }

                //
                // Bump to the next record, file wrap was handled above
                //

                //
                // If these are ELF_SKIP_DWORDs, just move past them
                //
                FillDword = (PDWORD) ((PBYTE) pLogFile->BaseAddress
                                           + pLogFile->BeginRecord);

                if (*FillDword == ELF_SKIP_DWORD)
                {
                    SpaceAvail += pLogFile->ActualMaxFileSize - pLogFile->BeginRecord;
                    pLogFile->BeginRecord = FILEHEADERBUFSIZE;
                }

                EventRecord = (PEVENTLOGRECORD) ((PBYTE) pLogFile->BaseAddress
                                                      + pLogFile->BeginRecord);
            }
            else
            {
                //
                // CODEWORK: Split this out into a separate function
                //

                //
                // All records within retention period
                //
                ELF_LOG1(ERROR,
                         "PerformWriteRequest: %ws log is full\n",
                         pLogFile->LogModuleName->Buffer);

                //
                // Do new behavior.
                //
                // Auto backup, clear the log, and log and event that says the file 
                // was backed up and try to log the current event one more time.
                // 
                // If this cannot be done, we made our best attempt, so we will probably
                // crash on audit fail, and not log the event (revert to old behavior).
                //
                
                if ((pLogFile->AutoBackupLogFiles != 0) && (fRetryWriteRequest == FALSE)) {

                    AutoBackupLogFile(Request, OverwrittenEOF);

                    fRetryWriteRequest = TRUE;
                  
                    goto RetryWriteRequest;
                }

                //
                // Hang an event on the queuedevent list for later writing
                // if we haven't just written a log full event for this log.
                // Don't put up the popup during setup as there's nothing
                // the user can do about it until setup finishes.
                //
                if (pLogFile->logpLogPopup == LOGPOPUP_CLEARED
                     &&
                    !ElfGlobalData->fSetupInProgress && !bSecurity)
                {
                    INT     StringLen, id = -1;
                    LPTSTR  lpModuleNameLoc = NULL;
                    HMODULE StringsResource;

                    //
                    // We should never be popping up or logging an event
                    // for the security log
                    //
                    ASSERT(_wcsicmp(pLogFile->LogModuleName->Buffer,
                                    ELF_SECURITY_MODULE_NAME) != 0);

                    //
                    //  Get the localized module name from message table
                    //
                    StringsResource = GetModuleHandle(L"EVENTLOG.DLL");

                    ASSERT(StringsResource != NULL);

                    if (_wcsicmp(pLogFile->LogModuleName->Buffer,
                                 ELF_SYSTEM_MODULE_NAME) == 0)
                    {
                        id = ELF_MODULE_NAME_LOCALIZE_SYSTEM;
                    }
                    else if (_wcsicmp(pLogFile->LogModuleName->Buffer,
                                      ELF_APPLICATION_MODULE_NAME) == 0)
                    {
                        id = ELF_MODULE_NAME_LOCALIZE_APPLICATION;
                    }

                    if (id != -1)
                    {
                        StringLen = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                                    FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                                  StringsResource,
                                                  id,
                                                  0,
                                                  (LPTSTR) &lpModuleNameLoc,
                                                  0,
                                                  NULL);

                        if ((StringLen > 1) && (lpModuleNameLoc != NULL))
                        {
                            //
                            //  Get rid of cr/lf control code at the end
                            //
                            *(lpModuleNameLoc + StringLen - 2) = 0;
                        }
                    }

                    //
                    // Create the "log full" event -- use the name stored in the
                    // log's default module if it's not a well-known log type
                    //
                    ElfpCreateElfEvent(EVENT_LOG_FULL,
                                       EVENTLOG_ERROR_TYPE,
                                       0,                      // EventCategory
                                       1,                      // NumberOfStrings
                                       (lpModuleNameLoc != NULL) ?
                                           &lpModuleNameLoc :
                                           &Request->LogFile->LogModuleName->Buffer,
                                       NULL,                   // Data
                                       0,                      // Datalength
                                       ELF_FORCE_OVERWRITE,
                                       FALSE);   // Overwrite if necc.

                    ElfpCreateQueuedMessage(
                            ALERT_ELF_LogOverflow,
                            1,
                            (lpModuleNameLoc != NULL) ?
                                &lpModuleNameLoc :
                                &Request->Module->LogFile->LogModuleName->Buffer);

                    LocalFree(lpModuleNameLoc);

                    //
                    // Don't post the popup again until either the machine is
                    // rebooted or the log is cleared
                    //
                    pLogFile->logpLogPopup = LOGPOPUP_ALREADY_SHOWN;
                }
                else if(bSecurity)
                {
                        if(pLogFile->bFullAlertDone == FALSE)
                        ElfpCreateQueuedAlert(
                                ALERT_ELF_LogOverflow,
                                1,
                                &Request->Module->LogFile->LogModuleName->Buffer);
                        pLogFile->bFullAlertDone = TRUE;
                }

                pLogFile->Flags |= ELF_LOGFILE_LOGFULL_WRITTEN;

                if (OverwrittenEOF)
                {
                    //
                    // The EOF record was at the end of the physical file,
                    // and we overwrote it with ELF_SKIP_DWORDs, so we need
                    // to put it back since we're not going to be able to
                    // write a record.  We also need to turn the wrap bit
                    // back off
                    //
                    pLogFile->Flags &= ~(ELF_LOGFILE_HEADER_WRAP);
                    pLogFile->EndRecord = OverwrittenEOF;
                    WritePos = OverwrittenEOF;

                    //
                    // Write out the EOF record
                    //
                    WriteToLog(pLogFile,
                               &EOFRecord,
                               ELFEOFRECORDSIZE,
                               &WritePos,
                               pLogFile->ActualMaxFileSize,
                               FILEHEADERBUFSIZE);
                }

                Status = STATUS_LOG_FILE_FULL;
                break;              // Get out of while loop
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            // We have enough room to write the record and the EOF record.
            //

            //
            // Update OldestRecordNumber to reflect the records that were
            // overwritten amd increment the CurrentRecordNumber
            //
            // Make sure that the log isn't empty, if it is, the oldest
            // record is 1
            //
            if (pLogFile->BeginRecord == pLogFile->EndRecord)
            {
                pLogFile->OldestRecordNumber = 1;
            }
            else
            {
                pLogFile->OldestRecordNumber = EventRecord->RecordNumber;
            }

            pLogFile->CurrentRecordNumber++;

            //
            // If the dirty bit is not set, then this is the first time that
            // we have written to the file since we started. In that case,
            // set the dirty bit in the file header as well so that we will
            // know that the contents have changed.
            //
            if (!(pLogFile->Flags & ELF_LOGFILE_HEADER_DIRTY))
            {
                SIZE_T HeaderSize;

                pLogFile->Flags |= ELF_LOGFILE_HEADER_DIRTY;

                pFileHeader = (PELF_LOGFILE_HEADER) pLogFile->BaseAddress;
                pFileHeader->Flags |= ELF_LOGFILE_HEADER_DIRTY;

                //
                // Now flush this to disk to commit it
                //
                BaseAddress = pLogFile->BaseAddress;
                HeaderSize = FILEHEADERBUFSIZE;

                Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                              &BaseAddress,
                                              &HeaderSize,
                                              &IoStatusBlock);
                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "PerformWriteRequest: NtFlushVirtualMemory to add dirty "
                                 "flag to header failed %#x\n",
                             Status);
                }
            }

            //
            // Write the event to the log
            //
            WriteToLog(pLogFile,
                       Request->Pkt.WritePkt->Buffer,
                       RecordSize,
                       &(pLogFile->EndRecord),
                       pLogFile->ActualMaxFileSize,
                       FILEHEADERBUFSIZE);

            //
            // Use a separate variable for the position since we don't want
            // it updated.
            //
            WritePos = pLogFile->EndRecord;

            if (WritePos > pLogFile->ActualMaxFileSize)
            {
                WritePos -= pLogFile->ActualMaxFileSize - FILEHEADERBUFSIZE;
            }

            //
            // Update the EOF record fields
            //
            EOFRecord.BeginRecord         = pLogFile->BeginRecord;
            EOFRecord.EndRecord           = WritePos;
            EOFRecord.CurrentRecordNumber = pLogFile->CurrentRecordNumber;
            EOFRecord.OldestRecordNumber  = pLogFile->OldestRecordNumber;

            //
            // Write out the EOF record
            //
            WriteToLog(pLogFile,
                       &EOFRecord,
                       ELFEOFRECORDSIZE,
                       &WritePos,
                       pLogFile->ActualMaxFileSize,
                       FILEHEADERBUFSIZE);

            //
            // If we had just written a logfull record, turn the bit off.
            // Since we just wrote a record, technically it's not full anymore
            //
            if (!(Request->Flags & ELF_FORCE_OVERWRITE))
            {
                pLogFile->Flags &= ~(ELF_LOGFILE_LOGFULL_WRITTEN);
            }

            //
            // See if there are any ElfChangeNotify callers to notify, and if
            // there are, pulse their event
            //
            NotifyChange(pLogFile);
        }

        //
        // Set status field in the request packet.
        //
        Request->Status = Status;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG2(ERROR,
                 "PerformWriteRequest: Caught exception %#x writing to %ws log\n",
                 GetExceptionCode(),
                 pLogFile->LogModuleName->Buffer);

        Request->Status = STATUS_EVENTLOG_FILE_CORRUPT;
    }

    //
    // Release the resource
    //
    RtlReleaseResource ( &pLogFile->Resource );
}


VOID
PerformClearRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine will optionally back up the log file specified, and will
    delete it.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE

Note:

    On the exit path, when we do some "cleanup" work, we discard the
    status and instead return the status of the operation that is being
    performed.
    This is necessary since we wish to return any error condition that is
    directly related to the clear operation. For other errors, we will
    fail at a later stage.

--*/
{
    NTSTATUS Status, IStatus;
    PUNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_RENAME_INFORMATION NewName = NULL;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE  ClearHandle = NULL;
    FILE_DISPOSITION_INFORMATION DeleteInfo = {TRUE};
    ULONG FileRefCount;
    BOOLEAN FileRenamed = FALSE;

    //
    // Get exclusive access to the log file. This will ensure no one
    // else is accessing the file.
    //
    RtlAcquireResourceExclusive (&Request->Module->LogFile->Resource,
                                 TRUE);                  // Wait until available

    //
    // We have exclusive access to the file.
    //
    // We force the file to be closed, and store away the ref count
    // so that we can set it back when we reopen the file.
    // This is a little *sleazy* but we have exclusive access to the
    // logfile structure so we can play these games.
    //
    FileRefCount = Request->LogFile->RefCount;  // Store this away

    ElfpCloseLogFile(Request->LogFile, ELF_LOG_CLOSE_FORCE);
    Request->LogFile->FileHandle = NULL;        // For use later

    //
    // Open the file with delete access in order to rename it.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               Request->LogFile->LogFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenFile(&ClearHandle,
                        GENERIC_READ | DELETE | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_DELETE,
                        FILE_SYNCHRONOUS_IO_NONALERT);

    if (NT_SUCCESS(Status))
    {
        //
        // If the backup file name has been specified and is not NULL,
        // then we move the current file to the new file. If that fails,
        // then fail the whole operation.
        //
        if ((Request->Pkt.ClearPkt->BackupFileName != NULL)
              &&
            (Request->Pkt.ClearPkt->BackupFileName->Length != 0))
        {
            FileName = Request->Pkt.ClearPkt->BackupFileName;

            //
            // Set up the rename information structure with the new name
            //
            NewName = ElfpAllocateBuffer(FileName->Length
                                             + sizeof(WCHAR) + sizeof(*NewName));

            if (NewName)
            {
                RtlCopyMemory(NewName->FileName,
                              FileName->Buffer,
                              FileName->Length);

                //
                // Guarantee that it's NULL terminated
                //
                NewName->FileName[FileName->Length / sizeof(WCHAR)] = L'\0';

                NewName->ReplaceIfExists = FALSE;
                NewName->RootDirectory   = NULL;
                NewName->FileNameLength  = FileName->Length;

                Status = NtSetInformationFile(ClearHandle,
                                              &IoStatusBlock,
                                              NewName,
                                              FileName->Length + sizeof(*NewName),
                                              FileRenameInformation);

                if (Status == STATUS_NOT_SAME_DEVICE)
                {
                    //
                    // They want the backup file to be on a different
                    // device.  We need to copy this one, and then delete
                    // it.
                    //
                    ELF_LOG2(FILES,
                             "PerformClearRequest: Attempting to copy log file %ws "
                                 "to different device (%ws)\n",
                             Request->LogFile->LogFileName->Buffer,
                             NewName->FileName);

                    Status = ElfpCopyFile(ClearHandle, FileName);

                    if (NT_SUCCESS(Status))
                    {
                        ELF_LOG1(FILES,
                                 "PerformClearRequest: Copy succeeded -- deleting %ws\n",
                                 Request->LogFile->LogFileName->Buffer);

                        Status = NtSetInformationFile(ClearHandle,
                                                      &IoStatusBlock,
                                                      &DeleteInfo,
                                                      sizeof(DeleteInfo),
                                                      FileDispositionInformation);

                        if (!NT_SUCCESS (Status))
                        {
                            ELF_LOG2(ERROR,
                                     "PerformClearRequest: Delete of %ws after "
                                         "successful copy failed %#x\n",
                                     Request->LogFile->LogFileName->Buffer,
                                     Status);
                        }
                    }
                }
                else if (NT_SUCCESS (Status))
                {
                    FileRenamed = TRUE;
                }

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG2(ERROR,
                             "PerformClearRequest: Rename of %ws failed %#x\n",
                             Request->LogFile->LogFileName->Buffer,
                             Status);
                }
            }
            else
            {
                ELF_LOG0(ERROR,
                         "PerformClearRequest: Unable to allocate memory for "
                             "FILE_RENAME_INFORMATION structure\n");

                Status = STATUS_NO_MEMORY;
            }
        }
        else
        {
            //
            // No backup name was specified. Just delete the log file
            // (i.e. "clear it"). We can just delete it since we know
            // that the first time anything is written to a log file,
            // if that file does not exist, it is created and a header
            // is written to it. By deleting it here, we make it cleaner
            // to manage log files, and avoid having zero-length files all
            // over the disk.
            //
            ELF_LOG1(FILES,
                     "PerformClearRequest: No backup name specified -- deleting %ws\n",
                     Request->LogFile->LogFileName->Buffer);

            Status = NtSetInformationFile(ClearHandle,
                                          &IoStatusBlock,
                                          &DeleteInfo,
                                          sizeof(DeleteInfo),
                                          FileDispositionInformation);

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "PerformClearRequest: Delete of %ws failed %#x\n",
                         Request->LogFile->LogFileName->Buffer,
                         Status);
            }
        }

        IStatus = NtClose(ClearHandle);    // Discard status
        ASSERT(NT_SUCCESS(IStatus));
    }
    else
    {
        //
        // The open-for-delete failed.
        //
        ELF_LOG2(ERROR,
                 "PerformClearRequest: NtOpenFile of %ws for delete failed %#x\n",
                 Request->LogFile->LogFileName->Buffer,
                 Status);
    }

    //
    // If the user reduced the size of the log file, pick up the new
    // size as it couldn't be used until the log was cleared
    //
    if (NT_SUCCESS (Status))
    {
        if (Request->LogFile->NextClearMaxFileSize)
        {
            Request->LogFile->ConfigMaxFileSize = Request->LogFile->NextClearMaxFileSize;
        }

        //
        // We need to recreate the file or if the file was just closed,
        // then we reopen it.
        //
        IStatus = ElfOpenLogFile(Request->LogFile, ElfNormalLog);

        if (!NT_SUCCESS(IStatus))
        {
            ELF_LOG2(ERROR,
                     "PerformClearRequest: Open of %ws after successful delete "
                         "failed %#x\n",
                     Request->LogFile->LogFileName->Buffer,
                     IStatus);

            Status = IStatus;

            //
            // The open failed -- try to restore the old log file.  If
            // NewName is NULL, it means there was no backup file specified.
            //
            if (NewName != NULL)
            {
                //
                // Opening the new log file failed, reopen the old log and
                // return this error from the Api
                //
                PFILE_RENAME_INFORMATION OldName;
                UNICODE_STRING UnicodeString;

                //
                // There shouldn't be any way to fail unless we successfully
                // renamed the file, and there's no recovery if that happens.
                //

                //
                // BUGBUG: We can hit this if the user asked for the backup
                //         file to be put on a different device, in which
                //         case the delete succeeded but FileRenamed is
                //         still set to FALSE if ElfOpenLogFile fails.
                //
                ASSERT(FileRenamed == TRUE);

                //
                // Rename the file back to the original name. Reuse ClearHandle.
                //
                RtlInitUnicodeString(&UnicodeString, NewName->FileName);

                InitializeObjectAttributes(&ObjectAttributes,
                                           &UnicodeString,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL);

                IStatus = NtOpenFile(&ClearHandle,
                                     GENERIC_READ | DELETE | SYNCHRONIZE,
                                     &ObjectAttributes,
                                     &IoStatusBlock,
                                     FILE_SHARE_DELETE,
                                     FILE_SYNCHRONOUS_IO_NONALERT);

                if (NT_SUCCESS(IStatus))
                {
                    //
                    // Set up the rename information structure with the old name
                    //
                    OldName = ElfpAllocateBuffer(Request->LogFile->LogFileName->Length
                                                     + sizeof(WCHAR) + sizeof(*OldName));

                    if (OldName)
                    {
                        PUNICODE_STRING pFileName = Request->LogFile->LogFileName;

                        RtlCopyMemory(OldName->FileName,
                                      pFileName->Buffer,
                                      pFileName->Length);

                        //
                        // Guarantee that it's NULL terminated
                        //
                        OldName->FileName[pFileName->Length / sizeof(WCHAR)] = L'\0';

                        OldName->ReplaceIfExists = FALSE;
                        OldName->RootDirectory   = NULL;
                        OldName->FileNameLength  = pFileName->Length;

                        //
                        // Change the name of the backed-up (i.e., cleared) log
                        // file to its original name.
                        //
                        IStatus = NtSetInformationFile(ClearHandle,
                                                       &IoStatusBlock,
                                                       OldName,
                                                       pFileName->Length
                                                           + sizeof(*OldName)
                                                           + sizeof(WCHAR),
                                                       FileRenameInformation);

                        ASSERT(NT_SUCCESS(IStatus));

                        //
                        // Reopen the original file.  This has to work.
                        //
                        IStatus = ElfOpenLogFile(Request->LogFile, ElfNormalLog);
                        ASSERT(NT_SUCCESS(IStatus));

                        ElfpFreeBuffer(OldName);
                    }

                    NtClose(ClearHandle);
                }
                else
                {
                    ELF_LOG2(ERROR,
                             "PerformClearRequest: Open of backed-up log file %ws "
                                 "failed %#x\n",
                             NewName->FileName,
                             IStatus);
                }
            }
        }
    }
    else
    {
        //
        // The delete failed for some reason -- reopen the original log file
        //
        ELF_LOG1(FILES,
                 "PerformClearRequest: Delete of %ws failed -- reopening original file\n",
                 Request->LogFile->LogFileName->Buffer);

        IStatus = ElfOpenLogFile(Request->LogFile, ElfNormalLog);
        ASSERT(NT_SUCCESS(IStatus));
    }

    Request->LogFile->RefCount = FileRefCount;      // Restore old value.

    if (Request->LogFile->logpLogPopup == LOGPOPUP_ALREADY_SHOWN)
    {
        //
        // This log has a viewable popup (i.e., it's not LOGPOPUP_NEVER_SHOW),
        // so we should show it again if the log fills up.
        //
        Request->LogFile->logpLogPopup = LOGPOPUP_CLEARED;
    }

    Request->LogFile->bFullAlertDone = FALSE;
    //
    // Mark any open context handles that point to this file as "invalid for
    // read."  This will fail any further READ operations and force the caller
    // to close and reopen the handle.
    //
    InvalidateContextHandlesForLogFile(Request->LogFile);

    //
    // Set status field in the request packet.
    //
    Request->Status = Status;

    //
    // Release the resource
    //
    RtlReleaseResource(&Request->Module->LogFile->Resource);

    ElfpFreeBuffer(NewName);
}


VOID
PerformBackupRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine will back up the log file specified.

    This routine impersonates the client in order to ensure that the correct
    access control is used.

    This routine is entered with the ElfGlobalResource held in a shared
    state and the logfile lock is acquired shared to prevent writing, but
    allow people to still read.

    This copies the file in two chunks, from the first record to the end
    of the file, and then from the top of the file (excluding the header)
    to the end of the EOF record.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE, status is placed in the packet for later use by the API wrapper

--*/
{
    NTSTATUS Status, IStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    LARGE_INTEGER MaximumSizeOfSection;
    LARGE_INTEGER Offset;
    ULONG LastRecordNumber;
    ULONG OldestRecordNumber;
    HANDLE  BackupHandle        = INVALID_HANDLE_VALUE;
    PBYTE StartOfCopy;
    PBYTE EndOfCopy;
    ULONG BytesToCopy;
    ULONG EndRecord = FILEHEADERBUFSIZE;
    BOOL ImpersonatingClient = FALSE;
    ELF_LOGFILE_HEADER FileHeaderBuf = { FILEHEADERBUFSIZE, // Size
                                         ELF_LOG_FILE_SIGNATURE,
                                         ELF_VERSION_MAJOR,
                                         ELF_VERSION_MINOR,
                                         FILEHEADERBUFSIZE, // Start offset
                                         FILEHEADERBUFSIZE, // End offset
                                         1,                 // Next record #
                                         1,                 // Oldest record #
                                         0,                 // Maxsize
                                         0,                 // Flags
                                         0,                 // Retention
                                         FILEHEADERBUFSIZE  // Size
                                       };


    //
    // Get shared access to the log file. This will ensure no one
    // else clears the file.
    //
    RtlAcquireResourceShared(&Request->Module->LogFile->Resource,
                             TRUE);                  // Wait until available

    //
    // Save away the next record number.  We'll stop copying when we get to
    // the record before this one.  Also save the first record number so we
    // can update the header and EOF record.
    //
    LastRecordNumber   = Request->LogFile->CurrentRecordNumber;
    OldestRecordNumber = Request->LogFile->OldestRecordNumber;

    //
    // Impersonate the client
    //
    Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));

    if (NT_SUCCESS(Status))
    {
        //
        // Keep this info so I can only revert in 1 place
        //
        ImpersonatingClient = TRUE;

        //
        // Set up the object attributes structure for the backup file
        //
        InitializeObjectAttributes(&ObjectAttributes,
                                   Request->Pkt.BackupPkt->BackupFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        //
        // Open the backup file.  Fail if a file by this name already exists.
        //
        MaximumSizeOfSection =
                RtlConvertUlongToLargeInteger(Request->LogFile->ActualMaxFileSize);

        Status = NtCreateFile(&BackupHandle,
                              GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              &MaximumSizeOfSection,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ,
                              FILE_CREATE,
                              FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT,
                              NULL,
                              0);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "PerformBackupRequest: Open of backup file %ws failed %#x\n",
                     Request->Pkt.BackupPkt->BackupFileName->Buffer,
                     Status);

            goto errorexit;
        }

        //
        // Write out the header, we'll update it later
        //
        FileHeaderBuf.CurrentRecordNumber = LastRecordNumber;
        FileHeaderBuf.OldestRecordNumber  = OldestRecordNumber;
        FileHeaderBuf.Flags               = 0;
        FileHeaderBuf.Retention           = Request->LogFile->Retention;

        Status = NtWriteFile(BackupHandle,           // Filehandle
                             NULL,                   // Event
                             NULL,                   // APC routine
                             NULL,                   // APC context
                             &IoStatusBlock,         // IO_STATUS_BLOCK
                             &FileHeaderBuf,         // Buffer
                             FILEHEADERBUFSIZE,      // Length
                             NULL,                   // Byteoffset
                             NULL);                  // Key


        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "PerformBackupRequest: Write of header to backup file %ws "
                         "failed %#x\n",
                     Request->Pkt.BackupPkt->BackupFileName->Buffer,
                     Status);

            goto errorexit;
        }

        //
        // Scan from the end of the file skipping over ELF_SKIP_DWORDs
        // to figure out how far to copy.  If we haven't wrapped, we just
        // copy to the EndRecord offset.
        //
        if (Request->LogFile->Flags & ELF_LOGFILE_HEADER_WRAP)
        {
            EndOfCopy = (PBYTE) Request->LogFile->BaseAddress
                             + Request->LogFile->ActualMaxFileSize - sizeof(DWORD);

            while (*((PDWORD) EndOfCopy) == ELF_SKIP_DWORD)
            {
                EndOfCopy -= sizeof(DWORD);
            }

            EndOfCopy += sizeof(DWORD);
        }
        else
        {
            EndOfCopy = (PBYTE) Request->LogFile->BaseAddress
                             + Request->LogFile->EndRecord;
        }

        //
        // Now set the start position to be the first record and
        // calculate the number of bytes to copy
        //
        StartOfCopy = (PBYTE) Request->LogFile->BaseAddress
                           + Request->LogFile->BeginRecord;

        BytesToCopy = (ULONG) (EndOfCopy - StartOfCopy);
        EndRecord  += BytesToCopy;

        Status = NtWriteFile(BackupHandle,           // Filehandle
                             NULL,                   // Event
                             NULL,                   // APC routine
                             NULL,                   // APC context
                             &IoStatusBlock,         // IO_STATUS_BLOCK
                             StartOfCopy,            // Buffer
                             BytesToCopy,            // Length
                             NULL,                   // Byteoffset
                             NULL);                  // Key


        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "PerformBackupRequest: Block write to backup file %ws (1st "
                         "call) failed %#x\n",
                     Request->Pkt.BackupPkt->BackupFileName->Buffer,
                     Status);

            goto errorexit;
        }

        //
        // If the file's not wrapped, we're done except for the EOF
        // record.  If the file is wrapped we have to copy the 2nd
        // piece
        //
        if (Request->LogFile->Flags & ELF_LOGFILE_HEADER_WRAP)
        {
            StartOfCopy = (PBYTE) Request->LogFile->BaseAddress
                               + FILEHEADERBUFSIZE;

            EndOfCopy   = (PBYTE) Request->LogFile->BaseAddress
                               + Request->LogFile->EndRecord;

            BytesToCopy = (ULONG) (EndOfCopy - StartOfCopy);
            EndRecord  += BytesToCopy;

            Status = NtWriteFile(BackupHandle,           // Filehandle
                                 NULL,                   // Event
                                 NULL,                   // APC routine
                                 NULL,                   // APC context
                                 &IoStatusBlock,         // IO_STATUS_BLOCK
                                 StartOfCopy,            // Buffer
                                 BytesToCopy,            // Length
                                 NULL,                   // Byteoffset
                                 NULL);                  // Key


            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "PerformBackupRequest: Block write to backup file %ws "
                             "(2nd call) failed %#x\n",
                         Request->Pkt.BackupPkt->BackupFileName->Buffer,
                         Status);

                goto errorexit;
            }
        }

        //
        // Write out the EOF record after updating the fields needed for
        // recovery.
        //
        EOFRecord.BeginRecord         = FILEHEADERBUFSIZE;
        EOFRecord.EndRecord           = EndRecord;
        EOFRecord.CurrentRecordNumber = LastRecordNumber;
        EOFRecord.OldestRecordNumber  = OldestRecordNumber;

        Status = NtWriteFile(BackupHandle,           // Filehandle
                             NULL,                   // Event
                             NULL,                   // APC routine
                             NULL,                   // APC context
                             &IoStatusBlock,         // IO_STATUS_BLOCK
                             &EOFRecord,             // Buffer
                             ELFEOFRECORDSIZE,       // Length
                             NULL,                   // Byteoffset
                             NULL);                  // Key


        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "PerformBackupRequest: Write of EOF record to backup file "
                         "%ws failed %#x\n",
                     Request->Pkt.BackupPkt->BackupFileName->Buffer,
                     Status);

            goto errorexit;
        }

        //
        // Update the header with valid information
        //
        FileHeaderBuf.EndOffset = EndRecord;
        FileHeaderBuf.MaxSize   = EndRecord + ELFEOFRECORDSIZE;

        Offset = RtlConvertUlongToLargeInteger(0);

        Status = NtWriteFile(BackupHandle,           // Filehandle
                             NULL,                   // Event
                             NULL,                   // APC routine
                             NULL,                   // APC context
                             &IoStatusBlock,         // IO_STATUS_BLOCK
                             &FileHeaderBuf,         // Buffer
                             FILEHEADERBUFSIZE,      // Length
                             &Offset,                // Byteoffset
                             NULL);                  // Key

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "PerformBackupRequest: Rewrite of header to backup file "
                         "%ws failed %#x\n",
                     Request->Pkt.BackupPkt->BackupFileName->Buffer,
                     Status);

            goto errorexit;
        }

        //
        // Clear the LogFile flag archive bit, assuming the caller will
        // clear (or has cleared) this log's archive file attribute.
        // Note: No big deal if the caller didn't clear the archive
        // attribute.
        //
        // The next write to this log tests the LogFile flag archive bit.
        // If the bit is clear, the archive file attribute is set on the
        // log file.
        //
        Request->LogFile->Flags &= ~ELF_LOGFILE_ARCHIVE_SET;
    }
    else
    {
        ELF_LOG1(ERROR,
                 "PerformBackupRequest: RpcImpersonateClient failed %#x\n",
                 Status);
    }

errorexit:

    if (ImpersonatingClient)
    {
        IStatus = I_RpcMapWin32Status(RpcRevertToSelf());

        if (!NT_SUCCESS(IStatus))
        {
            ELF_LOG1(ERROR,
                     "PerformBackupRequest: RpcRevertToSelf failed %#x\n",
                     IStatus);
        }
    }

    //
    // Close the output file
    //
    if (BackupHandle != INVALID_HANDLE_VALUE)
    {
        NtClose(BackupHandle);
    }

    //
    // Set status field in the request packet.
    //
    Request->Status = Status;

    //
    // Release the resource
    //
    RtlReleaseResource(&Request->Module->LogFile->Resource);
}


VOID
ElfPerformRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine takes the request packet and performs the operation
    on the event log.

    Before it does that, it takes the Global serialization resource
    for a READ to prevent other threads from doing WRITE operations on
    the resources of the service.

    After it has performed the requested operation, it writes any records
    generated by the eventlog service that have been put on the queued event
    list.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE

--*/
{
    BOOL Acquired = FALSE;

    //
    // Acquire the global resource for shared access. If the resource is
    // not immediately available (i.e., don't wait) then some other thread
    // has it out for exclusive access.
    //
    // If we time out, one of two threads owns the global resource:
    //
    //      1) Thread monitoring the registry
    //              We can wait for this thread to finish so that the
    //              operation can continue.
    //
    //      2) Control thread
    //              In this case, it may turn out that the service is
    //              stopping.  We examine the current service state to
    //              see if it is still running. If so, we loop around
    //              and try to get the resource again.
    //

    while ((GetElState() == RUNNING) && (!Acquired))
    {
        Acquired = RtlAcquireResourceShared(&GlobalElfResource,
                                            FALSE);             // Don't wait

        if (!Acquired)
        {
            ELF_LOG1(TRACE,
                     "ElfPerformRequest: Sleep %d milliseconds waiting "
                         "for global resource\n",
                     ELF_GLOBAL_RESOURCE_WAIT);

            Sleep(ELF_GLOBAL_RESOURCE_WAIT);
        }
    }

    //
    // If the resource was not available and the status of the service
    // changed to one of the "non-working" states, then we just return
    // unsuccesful.  Rpc should not allow this to happen.
    //
    if (!Acquired)
    {
        ELF_LOG0(TRACE,
                 "ElfPerformRequest: Global resource not acquired\n");

        Request->Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        switch (Request->Command)
        {
            case ELF_COMMAND_READ:

                //
                // The read/write code paths are high risk for exceptions.
                // Ensure exceptions do not go beyond this point. Otherwise,
                // services.exe will be taken out.  Note that the try-except
                // blocks are in PerformReadRequest and PerformWriteRequest
                // since the risky calls are between calls to acquire and
                // release a resource -- if the block were out here, a thrown
                // exception would prevent the releasing of the resource
                // (Bug #175768)
                //

                PerformReadRequest(Request);
                break;

            case ELF_COMMAND_WRITE:

                PerformWriteRequest (Request);
                break;

            case ELF_COMMAND_CLEAR:
                PerformClearRequest(Request);
                break;

            case ELF_COMMAND_BACKUP:
                PerformBackupRequest(Request);
                break;

            case ELF_COMMAND_WRITE_QUEUED:
                break;
        }

        //
        // Now run the queued event list dequeueing elements and
        // writing them
        //
        if (!IsListEmpty(&QueuedEventListHead))
        {
            //
            // There are things queued up to write, do it
            //
            WriteQueuedEvents();
        }

        //
        // Release the global resource.
        //
        ReleaseGlobalResource();
    }
}


/****
@func         NTSTATUS | FindSizeofEventsSinceStart| This routine walks
            through all the logfile structures and returns the size of
            events that were reported since the start of the eventlog service
            and that need to be proapagated through the cluster-wide replicated
            logs.  For all logfiles that are returned in the list, the shared
            lock for their log file is held and must be released by the caller.

@parm        OUT PULONG | pulSize | Pointer to a LONG that contains the size on return.
@parm        OUT PULONG | pulNumLogFiles | Pointer to a LONG that number of log files
            configured for eventlogging.
@parm        OUT PPROPLOGFILEINFO | *ppPropLogFileInfo | A pointer to a PROPLOGFILEINFO with
            all the information about events that need to be propagated is returned via this.

@rdesc         Returns a result code. ERROR_SUCCESS on success.

@comm        This is called by ElfrRegisterClusterSvc
@xref        <f ElfrRegisterClusterSvc>
****/
NTSTATUS
FindSizeofEventsSinceStart(
    OUT PULONG            pulTotalEventSize,
    OUT PULONG            pulNumLogFiles,
    OUT PPROPLOGFILEINFO  *ppPropLogFileInfo
    )
{
    PLOGFILE            pLogFile;
    PVOID               pStartPropPosition;
    PVOID               pEndPropPosition;
    ULONG               ulSize;
    ULONG               ulNumLogFiles;
    PPROPLOGFILEINFO    pPropLogFileInfo = NULL;
    UINT                i;
    PVOID               PhysicalEOF;       // Physical end of file
    PVOID               PhysStart;         // Physical start of file (after file hdr)
    PVOID               BeginRecord;       // Points to first record
    PVOID               EndRecord;         // Points to byte after last record
    ELF_REQUEST_RECORD  Request;            // points to the elf request
    NTSTATUS            Status = STATUS_SUCCESS;
    READ_PKT            ReadPkt;

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    //
    // Initialize the number of files
    //
    ulNumLogFiles = 0;        // Count of files

    //
    // Initialize the number of files/total event size
    //
    *pulNumLogFiles    = 0;   // Count of files with events to be propagated
    *pulTotalEventSize = 0;

    //
    // Count the number of files
    // Initialize to the first logfile in the list
    //
    pLogFile = CONTAINING_RECORD(LogFilesHead.Flink,
                                 LOGFILE,
                                 FileList);

    //
    // While there are more
    //
    while(pLogFile->FileList.Flink != LogFilesHead.Flink)
    {
        ulNumLogFiles++;

        //
        // Advance to the next log file
        //
        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);
    }

    ELF_LOG1(CLUSTER,
             "FindSizeOfEventsSinceStart: %d log files\n",
             ulNumLogFiles);

    if (!ulNumLogFiles)
    {
        goto FnExit;
    }

    //
    // Allocate a structure for log file info
    //
    pPropLogFileInfo =
        (PPROPLOGFILEINFO) ElfpAllocateBuffer(ulNumLogFiles * sizeof(PROPLOGFILEINFO));

    if (!pPropLogFileInfo)
    {
        ELF_LOG0(ERROR,
                 "FindSizeOfEventsSinceStart: Unable to allocate memory "
                     "for pPropLogFileInfo\n");

        Status = STATUS_NO_MEMORY;
        goto FnExit;
    }

    //
    // Gather information about the files
    // Initialize to the first logfile in the list
    //
    pLogFile = CONTAINING_RECORD(LogFilesHead.Flink,
                                 LOGFILE,
                                 FileList);

    i = 0;

    //
    // While there are more
    //

    //
    // BUGBUG: Based on the generation of ulNumLogFiles above, these
    //         two checks are actually identical
    //
    while ((pLogFile->FileList.Flink != LogFilesHead.Flink)
             &&
           (i < ulNumLogFiles))
    {
        ELF_LOG1(CLUSTER,
                 "FindSizeOfEventsSinceStart: Processing file %ws\n",
                 pLogFile->LogFileName->Buffer);

        //
        // Get shared access to the log file. This will allow multiple
        // readers to get to the file together.
        //
        RtlAcquireResourceShared(&pLogFile->Resource,
                                 TRUE);                // Wait until available

        //
        // Check if any records need to be propagated
        //
        if (pLogFile->CurrentRecordNumber == pLogFile->SessionStartRecordNumber)
        {
            ELF_LOG1(CLUSTER,
                     "FindSizeOfEventsSinceStart: No records to propagate from %ws log\n",
                     pLogFile->LogModuleName->Buffer);

            goto process_nextlogfile;
        }

        //
        // Records need to be propagated, so find the positions in the
        // file where they are logged
        //
        PhysicalEOF = (LPBYTE) pLogFile->BaseAddress
                           + pLogFile->ViewSize;

        PhysStart   = (LPBYTE)pLogFile->BaseAddress
                           + FILEHEADERBUFSIZE;

        BeginRecord = (LPBYTE) pLogFile->BaseAddress
                           + pLogFile->BeginRecord;    // Start at first record

        EndRecord   = (LPBYTE)pLogFile->BaseAddress
                           + pLogFile->EndRecord;      // Byte after end of last record


        //
        // Set up the request structure
        //
        Request.Pkt.ReadPkt = &ReadPkt;
        Request.LogFile     = pLogFile;

        //
        // Set up the read packet structure for the first event logged in this session
        //
        Request.Pkt.ReadPkt->LastSeekPos  = 0;
        Request.Pkt.ReadPkt->ReadFlags    = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
        Request.Pkt.ReadPkt->RecordNumber = pLogFile->SessionStartRecordNumber;

        //
        //  Chittur Subbaraman (chitturs) - 3/22/99
        //
        //  Enclose the SeekToStartingRecord within a try-except block to
        //  account for the eventlog getting corrupted under certain
        //  circumstances (such as the system crashing). You don't want to
        //  read such corrupt records.
        //
        try
        {
            //
            // Find the size of events in this log file
            //
            Status = SeekToStartingRecord(&Request,
                                          &pStartPropPosition,
                                          BeginRecord,
                                          EndRecord,
                                          PhysicalEOF,
                                          PhysStart);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ELF_LOG2(ERROR,
                     "FindSizeOfEventsSinceStart: Caught exception %#x while "
                         "seeking first record in %ws log\n",
                     GetExceptionCode(),
                     pLogFile->LogModuleName->Buffer);

            Status = STATUS_EVENTLOG_FILE_CORRUPT;
        }

        //
        // Skip this log file if error
        //
        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "FindSizeOfEventsSinceStart: SeekToStartingRecord (1st call) for %ws "
                         "log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);

            //
            // Resetting status so that we skip only this file.
            //
            Status = STATUS_SUCCESS;
            goto process_nextlogfile;
        }

        //
        // SS: if this is not a valid position - the file could have wrapped since
        // Should be try and find the last valid record after the session start record
        // number then ?  Since this is unlikely to happen-its not worth the trouble
        // however valid position for session start record never succeeds even though
        // it is valid, so we skip it
        //

        //
        // Set up the read packet structure to seek till the start of the
        // last record
        //

        //
        // CODEWORK: We already have the position of the last record (via EndRecord)
        //           so just using ((PBYTE) EndRecord - *((PULONG) EndRecord - 1))
        //           should give the offset of the last record.
        //
        Request.Pkt.ReadPkt->LastSeekPos  = 0;
        Request.Pkt.ReadPkt->ReadFlags    = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
        Request.Pkt.ReadPkt->RecordNumber = pLogFile->CurrentRecordNumber - 1;

        //
        //  Chittur Subbaraman (chitturs) - 3/22/99
        //
        //  Enclose the SeekToStartingRecord within a try-except block to
        //  account for the eventlog getting corrupted under certain
        //  circumstances (such as the system crashing). You don't want to
        //  read such corrupt records.
        //
        try
        {
            Status = SeekToStartingRecord(&Request,
                                          &pEndPropPosition,
                                          BeginRecord,
                                          EndRecord,
                                          PhysicalEOF,
                                          PhysStart);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ELF_LOG2(ERROR,
                     "FindSizeOfEventsSinceStart: Caught exception %#x while "
                         "seeking last record in %ws log\n",
                     GetExceptionCode(),
                     pLogFile->LogModuleName->Buffer);

            Status = STATUS_EVENTLOG_FILE_CORRUPT;
        }

        //
        // Skip this log file if error
        //
        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "FindSizeOfEventsSinceStart: SeekToStartingRecord (2nd call) for %ws "
                         "log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);

            //
            // Resetting status so that we skip only this file.
            //
            Status = STATUS_SUCCESS;
            goto process_nextlogfile;
        }

        //
        // SS: if this is not a valid position - the file could have wrapped since
        //
        if (!ValidFilePos(pEndPropPosition,
                          BeginRecord,
                          EndRecord,
                          PhysicalEOF,
                          pLogFile->BaseAddress,
                          TRUE))
        {
            ELF_LOG1(ERROR,
                     "FindSizeOfEventsSinceStart: ValidFilePos for pEndPropPosition "
                         "in %ws log failed\n",
                     pLogFile->LogModuleName->Buffer);

            goto process_nextlogfile;
        }

        //
        // The end prop position
        //
        pEndPropPosition = (PBYTE) pEndPropPosition
                                + ((PEVENTLOGRECORD)pEndPropPosition)->Length;

        ELF_LOG3(CLUSTER,
                 "FindSizeOfEventsSinceStart: Log %ws, pStartPosition %p, pEndPosition %p\n",
                 pLogFile->LogModuleName->Buffer,
                 pStartPropPosition,
                 pEndPropPosition);

        //
        // If no records to propagate - skip the file
        //
        if (pStartPropPosition == pEndPropPosition)
        {
            ELF_LOG1(CLUSTER,
                     "FindSizeOfEventsSinceStart: Start and end positions in %ws log "
                         "are equal -- no events to propagate\n",
                     pLogFile->LogModuleName->Buffer);

            goto process_nextlogfile;
        }

        if (pEndPropPosition > pStartPropPosition)
        {
            ulSize = (ULONG) ((PBYTE) pEndPropPosition - (PBYTE) pStartPropPosition);
        }
        else
        {
            //
            // BUGBUG: This ignores any ELF_SKIP_DWORDs at the end of the file
            //
            ulSize = (ULONG) ((PBYTE) PhysicalEOF - (PBYTE) pStartPropPosition)
                          +
                     (ULONG) ((PBYTE)pEndPropPosition - (PBYTE)PhysStart);
        }

        ELF_LOG2(CLUSTER,
                 "FindSizeOfEventsSinceStart: Need to propagate %d bytes from %ws log\n",
                 ulSize,
                 pLogFile->LogModuleName->Buffer);

        pPropLogFileInfo[i].pLogFile         = pLogFile;
        pPropLogFileInfo[i].pStartPosition   = pStartPropPosition;
        pPropLogFileInfo[i].pEndPosition     = pEndPropPosition;
        pPropLogFileInfo[i].ulTotalEventSize = ulSize;
        pPropLogFileInfo[i].ulNumRecords     = pLogFile->CurrentRecordNumber
                                                   - pLogFile->SessionStartRecordNumber;
        i++;
        (*pulNumLogFiles)++;
        *pulTotalEventSize += ulSize;

        //
        // Advance to the next log file
        //
        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);

        //
        // NB: We were successful with this log file and we therefore hold on to
        //     the lock -- the caller will/must release it.
        //
        continue;

process_nextlogfile:

        //
        // We were not successful with the log file -- release the lock
        //
        RtlReleaseResource(&pLogFile->Resource);

        //
        // Advance to the next log file
        //
        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);
    }

    //
    // Free the memory if unsuccessful
    //
    if (!(*pulNumLogFiles))
    {
        ElfpFreeBuffer(pPropLogFileInfo);
        pPropLogFileInfo = NULL;
    }

FnExit:

    *ppPropLogFileInfo = pPropLogFileInfo;

    ELF_LOG3(CLUSTER,
             "FindSizeOfEventsSinceStart: ulTotalEventSize = %d, ulNumLogFiles = %d, "
                 "pPropLogFileInfo = %p\n",
             *pulTotalEventSize,
             *pulNumLogFiles,
             *ppPropLogFileInfo);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);
    return Status;
}

/****
@func   NTSTATUS | GetEventsToProp| Given a propagate log file
        info structure, this events prepares a block of eventlog
        records to propagate.  The shared lock to the logfile must
        be held thru when the PROPLOGINFO structure is prepared
        to when this routine is called.

@parm   OUT PEVENTLOGRECORD | pEventLogRecords | Pointer to a EVENTLOGRECORD
        structure where the events to be propagated are returned.
@parm   IN PPROPLOGFILEINFO | pPropLogFileInfo | Pointer to a PROPLOGFILEINFO
        structure that contains the information to retrieve events from the
        corresponding eventlog file.

@rdesc  Returns a result code. ERROR_SUCCESS on success.

@xref
****/
NTSTATUS
GetEventsToProp(
    IN PEVENTLOGRECORD  pEventLogRecords,
    IN PPROPLOGFILEINFO pPropLogFileInfo
    )
{
    PVOID       BufferPosition;
    PVOID       XferPosition;
    PVOID       PhysicalEOF;
    PVOID       PhysicalStart;
    ULONG       ulBytesToMove;
    NTSTATUS    Status = STATUS_SUCCESS;

    ELF_LOG1(CLUSTER,
             "GetEventsToProp: Getting events for %ws log\n",
             pPropLogFileInfo->pLogFile->LogModuleName->Buffer);

    BufferPosition = pEventLogRecords;
    ulBytesToMove  = pPropLogFileInfo->ulTotalEventSize;

    //
    // If the start and end positions are the same there are no bytes to copy
    //
    if (pPropLogFileInfo->pStartPosition == pPropLogFileInfo->pEndPosition)
    {
        ASSERT(FALSE);

        //
        // Shouldn't come here as FindSizeofEventsSinceStart checks
        // for this explicitly
        //
        return STATUS_SUCCESS;
    }

    //
    //  Chittur Subbaraman (chitturs) - 3/15/99
    //
    //  Enclose the memcpy within a try-except block to account for
    //  the eventlog getting corrupted under certain circumstances (such
    //  as the system crashing). You don't want to read such corrupt
    //  records.
    //
    try
    {
        XferPosition  = pPropLogFileInfo->pStartPosition;
        ulBytesToMove = pPropLogFileInfo->ulTotalEventSize;

        if (pPropLogFileInfo->pStartPosition > pPropLogFileInfo->pEndPosition)
        {
            //
            // The log is wrapped -- copy the bytes from the start position
            // to the end of the file
            //
            PhysicalEOF   = (PBYTE) pPropLogFileInfo->pLogFile->BaseAddress
                                  + pPropLogFileInfo->pLogFile->ViewSize;

            PhysicalStart = (PBYTE) pPropLogFileInfo->pLogFile->BaseAddress
                                  + FILEHEADERBUFSIZE;

            //
            // BUGBUG: This copies any ELF_SKIP_DWORDs that are at the
            //         end of the file
            //
            ulBytesToMove = (ULONG) ((PBYTE) PhysicalEOF
                                          - (PBYTE) pPropLogFileInfo->pStartPosition);

            RtlCopyMemory(BufferPosition, XferPosition, ulBytesToMove);

            //
            // Set it up for the second half
            //
            BufferPosition = (PBYTE) BufferPosition + ulBytesToMove;
            ulBytesToMove  = pPropLogFileInfo->ulTotalEventSize - ulBytesToMove;
            XferPosition   = PhysicalStart;
        }

        RtlCopyMemory(BufferPosition, XferPosition, ulBytesToMove);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG2(ERROR,
                 "GetEventsToProp: Caught exception %#x copying records from %ws log\n",
                 GetExceptionCode(),
                 pPropLogFileInfo->pLogFile->LogModuleName->Buffer);

        Status = STATUS_EVENTLOG_FILE_CORRUPT;
    }

    return Status;
}

//SS:end of changes made to enable cluster wide event logging
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\test\testwin.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TESTWIN.C

Abstract:

    Test program for the eventlog service. This program calls the Win
    APIs to test out the operation of the service.

Author:

    Rajen Shah  (rajens) 05-Aug-1991

Revision History:


--*/
/*----------------------*/
/* INCLUDES             */
/*----------------------*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>      // printf
#include <string.h>     // stricmp
#include <stdlib.h>
#include <windows.h>
#include <netevent.h>

//
// Turn on NotifyChangeEventLog
//
#define     TEST_NOTIFY         1
//#define     TEST_REMOTE         1

#define     READ_BUFFER_SIZE        1024*2      // Use 2K buffer

#define     SIZE_DATA_ARRAY         65

//
// Global buffer used to emulate "binary data" when writing an event
// record.
//
    DWORD    Data[SIZE_DATA_ARRAY];
//    LPWSTR   ServerName=L"\\\\danl2";
    LPWSTR   ServerName=NULL;


VOID
Initialize (
    VOID
    )
{
    DWORD   i;

    // Initialize the values in the data buffer.
    //
    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] = i;

}


BOOL
Usage (
    VOID
    )
{
    printf( "usage: \n" );
    printf( "-b <filename>  Tests BackupEventLog API\n");
    printf( "-c             Tests ClearEventLog API\n");
    printf( "-n             Tests NotifyChangeEventlog\n");
    printf( "-rsb           Reads event log sequentially backwards\n");
    printf( "-rsf           Reads event log sequentially forwards\n");
    printf( "-rrb <record>  Reads event log from <record> backwards\n");
    printf( "-rrf <record>  Reads event log from <record> forwards\n");
    printf( "-w <count>     Tests ReportEvent API <count> times\n");
    return ERROR_INVALID_PARAMETER;

} // Usage



BOOL
WriteLogEntry ( HANDLE LogHandle, DWORD EventID )

{
#define NUM_STRINGS     2

    BOOL    Status;
    WORD    EventType, i;
    DWORD   DataSize;
    PSID    pUserSid;

    PWSTR   Strings[NUM_STRINGS] = {L"StringAOne",
                                   L"StringATwo"
                                  };

    EventType = EVENTLOG_INFORMATION_TYPE;
    pUserSid   = NULL;
    DataSize  = sizeof(DWORD) * SIZE_DATA_ARRAY;

    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] += i;

    Status = ReportEventW (
                    LogHandle,
                    EventType,
                    0,            // event category
                    EventID,
                    pUserSid,
                    NUM_STRINGS,
                    DataSize,
                    Strings,
                    (PVOID)Data
                    );

    return (Status);
}

DWORD
WriteLogEntryMsg ( HANDLE LogHandle, DWORD EventID )
/*
    This function requires a registry entry in the Applications section
    of the Eventlog for TESTWINAPP, it will use the netevent.dll message file.
*/

{
#define NUM_STRINGS     2

    WORD    EventType;
    DWORD   DataSize;
    PSID    pUserSid;

    PWSTR   Strings[NUM_STRINGS];

    Strings[0] = L"This is a BOGUS message for TEST purposes Ignore this substitution text";
    Strings[1] = L"GHOST SERVICE in the long string format - I wanted a long string to pass into this function";

    EventType = EVENTLOG_INFORMATION_TYPE;
    pUserSid   = NULL;
    DataSize  = sizeof(DWORD) * SIZE_DATA_ARRAY;


    if (!ReportEventW (
                    LogHandle,
                    EventType,
                    0,            // event category
                    EVENT_SERVICE_START_FAILED_NONE,
                    pUserSid,
                    NUM_STRINGS,
                    0,              // DataSize
                    Strings,
                    (PVOID)NULL     // Data
                    )) {

        printf("ReportEventW failed %d\n",GetLastError());
        return(GetLastError());
    }
    return (NO_ERROR);
}


VOID
DisplayEventRecords( PVOID Buffer,
                     DWORD  BufSize,
                     ULONG *NumRecords)

{
    PEVENTLOGRECORD     pLogRecord;
    ANSI_STRING         StringA;
    UNICODE_STRING      StringU;
    PWSTR               pwString;
    DWORD               Count = 0;
    DWORD               Offset = 0;
    DWORD               i;

    pLogRecord = (PEVENTLOGRECORD) Buffer;

    while ((DWORD)Offset < BufSize) {

        printf("\nRecord # %lu\n", ++Count);

        printf("Length: 0x%lx TimeGenerated: 0x%lx  EventID: 0x%lx EventType: 0x%x\n",
                pLogRecord->Length, pLogRecord->TimeGenerated, pLogRecord->EventID,
                pLogRecord->EventType);

        printf("NumStrings: 0x%x StringOffset: 0x%lx UserSidLength: 0x%lx TimeWritten: 0x%lx\n",
                pLogRecord->NumStrings, pLogRecord->StringOffset,
                pLogRecord->UserSidLength, pLogRecord->TimeWritten);

        printf("UserSidOffset: 0x%lx    DataLength: 0x%lx    DataOffset:  0x%lx \n",
                pLogRecord->UserSidOffset, pLogRecord->DataLength,
                pLogRecord->DataOffset);

        //
        // Print out module name
        //
        pwString = (PWSTR)((DWORD)pLogRecord + sizeof(EVENTLOGRECORD));
        RtlInitUnicodeString (&StringU, pwString);
        RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

        printf("ModuleName:  %s ", StringA.Buffer);
        RtlFreeAnsiString (&StringA);

        //
        // Display ComputerName
        //
        pwString = pwString + (wcslen(pwString) + 1);

        RtlInitUnicodeString (&StringU, pwString);
        RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

        printf("ComputerName: %s\n",StringA.Buffer);
        RtlFreeAnsiString (&StringA);

        //
        // Display strings
        //
        pwString = (PWSTR)((DWORD)Buffer + pLogRecord->StringOffset);

        printf("\nStrings: \n");
        for (i=0; i<pLogRecord->NumStrings; i++) {

            RtlInitUnicodeString (&StringU, pwString);
            RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

            printf("  %s  \n",StringA.Buffer);

            RtlFreeAnsiString (&StringA);

            pwString = (PWSTR)((DWORD)pwString + StringU.MaximumLength);
        }

        // Get next record
        //
        Offset += pLogRecord->Length;

        pLogRecord = (PEVENTLOGRECORD)((DWORD)Buffer + Offset);

    }
    *NumRecords = Count;

}


BOOL
ReadFromLog ( HANDLE LogHandle,
             PVOID  Buffer,
             ULONG *pBytesRead,
             DWORD  ReadFlag,
             DWORD  Record
             )
{
    BOOL        Status;
    DWORD       MinBytesNeeded;
    DWORD       ErrorCode;

    Status = ReadEventLogW (
                        LogHandle,
                        ReadFlag,
                        Record,
                        Buffer,
                        READ_BUFFER_SIZE,
                        pBytesRead,
                        &MinBytesNeeded
                        );


    if (!Status) {
         ErrorCode = GetLastError();
         if (ErrorCode == ERROR_HANDLE_EOF) {
             Status = TRUE;
         }
         else if (ErrorCode == ERROR_NO_MORE_FILES) {
            printf("Buffer too small. Need %lu bytes min\n", MinBytesNeeded);
         }
         else {
             printf("Error from ReadEventLog %d \n", ErrorCode);
         }

    }

    return (Status);
}




BOOL
TestReadEventLog (DWORD Count, DWORD ReadFlag, DWORD Record)

{
    BOOL    bStatus,IStatus;
    DWORD   status;
    HANDLE  LogHandle;
    LPWSTR  ModuleName;
    DWORD   NumRecords, BytesReturned;
    PVOID   Buffer;
    DWORD   RecordOffset;
    DWORD   NumberOfRecords;
    DWORD   OldestRecord;

    printf("Testing ReadEventLog API to read %lu entries\n",Count);

    Buffer = malloc (READ_BUFFER_SIZE);

    //
    // Initialize the strings
    //
    NumRecords = Count;
    ModuleName = L"TESTWINAPP";

    //
    // Open the log handle
    //
    printf("OpenEventLog - ");
    LogHandle = OpenEventLogW (
                    ServerName,
                    ModuleName
                    );

    if (LogHandle == NULL) {
         printf("Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Get and print record information
        //

        bStatus = GetNumberOfEventLogRecords(LogHandle, & NumberOfRecords);
        if (bStatus) {
           bStatus = GetOldestEventLogRecord(LogHandle, & OldestRecord);
        }

        if (!bStatus) {
           printf("Query of record information failed with %X", GetLastError());
           return(bStatus);
        }

        printf("\nThere are %d records in the file, %d is the oldest"
         " record number\n", NumberOfRecords, OldestRecord);

        RecordOffset = Record;

        printf("Reading %u records\r", Count);

        while (Count) {

            //
            // Read from the log
            //
            bStatus = ReadFromLog ( LogHandle,
                                   Buffer,
                                   &BytesReturned,
                                   ReadFlag,
                                   RecordOffset
                                 );
            if (bStatus) {
                printf("Bytes read = 0x%lx\n", BytesReturned);
                printf("Read %u records\n", NumRecords);
                DisplayEventRecords(Buffer, BytesReturned, &NumRecords);
                Count -= NumRecords;
                RecordOffset += NumRecords;
            } else {
                break;
            }

            if (BytesReturned == 0)
                break;
        }
        printf("\n");

        if (!bStatus) {
            printf ("ReadFromLog Error - %d. Remaining count %lu\n", GetLastError(),
                Count);
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }

    return (bStatus);
}



BOOL
TestWriteEventLog (DWORD Count)

{
    DWORD       Status=NO_ERROR;
    BOOL        IStatus;
    HANDLE      LogHandle;
    LPWSTR      ModuleName;
    DWORD       EventID = 99;
    DWORD       WriteCount;
    DWORD       DataNum=0;

    printf("Testing ReportEvent API\n");

    //
    // Initialize the strings
    //
    ModuleName = L"TESTWINAPP";

    printf("Calling RegisterEventSource for WRITE %lu times\n", Count);
    while ((Count > 0) && (Status== NO_ERROR)) {
        //
        // Open the log handle
        //
        LogHandle = RegisterEventSourceW (
                        ServerName,
                        ModuleName
                        );

        if (LogHandle == NULL) {
            Status = GetLastError();
            printf("RegisterEventSource Failure - %d\n", Status);
            return(Status);

        } else {
            printf("Registered - ");
            WriteCount = 5;
            printf("Record # %u:  ", Count);

            while ((WriteCount>0) && (Status==NO_ERROR)) {

                //
                // Write an entry into the log
                //
                Data[0] = DataNum;                     // Make data "unique"
                EventID = (EventID + DataNum) % 100;   // Vary the eventids
                Status = WriteLogEntryMsg( LogHandle, EventID );
                DataNum++;
                WriteCount--;

                if (Status != NO_ERROR) {
                    printf ("WriteLogEntry Error - %d. Remaining count %lu\n",Status,Count);
                } else {
                    printf ("%d,",WriteCount);
                }
            }

            IStatus = DeregisterEventSource (LogHandle);
            printf(" - Deregistered\n");
        }
        Count--;
    }

    printf("\n");
    return (Status);
}



BOOL
TestClearLogFile ()

{
    BOOL        Status, IStatus;
    HANDLE      LogHandle;
    LPWSTR ModuleName, BackupName;

    printf("Testing ClearLogFile API\n");
    //
    // Initialize the strings
    //
    ModuleName = L"TESTWINAPP";

    //
    // Open the log handle
    //
    printf("Calling OpenEventLog for CLEAR - ");
    LogHandle = OpenEventLogW (
                    NULL,
                    ModuleName
                    );

    if (LogHandle == NULL) {
         printf("OpenEventLog Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Clear the log file and back it up to "view.log"
        //

        printf("Calling ClearEventLog backing up to view.log  ");
        BackupName = L"\\\\danhi386\\roote\\view.log";

        Status = ClearEventLogW (
                        LogHandle,
                        BackupName
                        );

        if (!Status) {
            printf ("ClearEventLog Error - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        //
        // Now just clear the file without backing it up
        //
        printf("Calling ClearEventLog with no backup  ");
        Status = ClearEventLogW (
                        LogHandle,
                        NULL
                        );

        if (!Status) {
            printf ("ClearEventLogError - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }

    return(Status);
}

BOOL
TestBackupLogFile (LPSTR BackupFileName)

{
    BOOL        Status, IStatus;
    HANDLE      LogHandle;
    LPWSTR ModuleName;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    printf("Testing BackupLogFile API\n");
    //
    // Initialize the strings
    //
    ModuleName = L"TESTWINAPP";

    //
    // Open the log handle
    //
    printf("Calling OpenEventLog for BACKUP - ");
    LogHandle = OpenEventLogW (
                    NULL,
                    ModuleName
                    );

    if (LogHandle == NULL) {
         printf("OpenEventLog Failure %d\n", GetLastError());

    } else {
        printf("OpenEventLog SUCCESS\n");

        //
        // Backup the log file to BackupFileName
        //

        printf("Calling BackupEventLog backing up to %s  ", BackupFileName);

    RtlInitAnsiString(&AnsiString, BackupFileName);
    RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

    Status = BackupEventLogW (LogHandle, UnicodeString.Buffer);

        if (!Status) {
            printf ("BackupEventLog failure - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }

    return(Status);
}

VOID
NotifyThread(
    HANDLE  hEventLog)
{
    Sleep(30000);
    printf("NotifyThread: Writing an event...\n");
    if (!WriteLogEntryMsg(hEventLog,1)) {
        printf("NotifyThread: WriteLogEntryMsg failed\n");
    }
    else {
        printf("Event was written\n");
    }
    ExitThread(NO_ERROR);
}

VOID
TestChangeNotify(
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    HANDLE      hEvent;
    HANDLE      hThread;
    HANDLE      hEventLog;
    DWORD       threadId;
    DWORD       status;

    hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (hEvent == NULL) {
        printf("CreateEvent Failed %d\n",GetLastError());
        return;
    }
#ifdef TEST_REMOTE
    hEventLog = RegisterEventSourceW(L"\\\\DANL2",L"TESTWINAPP");
#else
    hEventLog = RegisterEventSourceW(NULL,L"TESTWINAPP");
#endif
    if (hEventLog == NULL) {
        printf("OpenEventLog failed %d\n",GetLastError());
    }

#ifdef TEST_NOTIFY

    if (!NotifyChangeEventLog(hEventLog,hEvent)) {
        printf("NotifyChangeEventLog failed %d\n",GetLastError());
    }
#endif  // TEST_NOTIFY

    hThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)NotifyThread,hEventLog,0,&threadId);
    if (hThread == NULL) {
        printf("CreateThread Failed %d\n",GetLastError());
        CloseHandle(hEvent);
        return;
    }

    CloseHandle(hThread);

    printf("Wait for event to become signaled\n");
    status = WaitForSingleObject(hEvent,INFINITE);
    if (status == WAIT_OBJECT_0) {
        printf("The Event was signaled\n");
    }
    else {
        printf("The Event was NOT signaled\n");
    }
    return;
}
/****************************************************************************/
DWORD __cdecl
main (
    IN SHORT argc,
    IN PSZ argv[],
    IN PSZ envp[]
    )
/*++
*
* Routine Description:
*
*
*
* Arguments:
*
*
*
*
* Return Value:
*
*
*
--*/
/****************************************************************************/
{

    DWORD   ReadFlags;

    Initialize();           // Init any data

    if ( argc < 2 ) {
        printf( "Not enough parameters\n" );
        return Usage( );
    }

    if ( stricmp( argv[1], "-c" ) == 0 ) {

        if ( argc < 3 ) {
            return TestClearLogFile();
        }
    }
    else if ( stricmp( argv[1], "-b" ) == 0 ) {

        if ( argc < 3 ) {
            printf("You must supply a filename to backup to\n");
            return(FALSE);
        }

            return TestBackupLogFile(argv[2]);

    } else if (stricmp ( argv[1], "-rsf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-rsb" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-n" ) == 0 ) {
        TestChangeNotify();

    } else if (stricmp ( argv[1], "-rrf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags ,1);
        } else if (argc == 3) {
            return (TestReadEventLog (1, ReadFlags, atoi(argv[2])));
        }
    } else if (stricmp ( argv[1], "-rrb" ) == 0 ) {

        ReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_BACKWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags, 1);
        } else if (argc == 3) {
            return (TestReadEventLog (1, ReadFlags, atoi(argv[2])));
        }
    } else if (stricmp ( argv[1], "-w" ) == 0 ) {

        if ( argc < 3 ) {
            return TestWriteEventLog(1);
        } else if (argc == 3) {
            return (TestWriteEventLog (atoi(argv[2])));
        }

    } else {

        return Usage();
    }

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(envp);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\test\testwina.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TESTWINA.C

Abstract:

    Test program for the eventlog service. This program calls the Win
    APIs to test out the operation of the service.

Author:

    Rajen Shah  (rajens) 05-Aug-1991

Revision History:


--*/
/*----------------------*/
/* INCLUDES             */
/*----------------------*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>      // printf
#include <string.h>     // stricmp
#include <stdlib.h>
#include <windows.h>
#include <netevent.h>
//#include <elfcommn.h>


#define     READ_BUFFER_SIZE        1024*2      // Use 2K buffer

#define     SIZE_DATA_ARRAY         65

//
// Global buffer used to emulate "binary data" when writing an event
// record.
//
DWORD    Data[SIZE_DATA_ARRAY];
BOOL     bHackTestBackup = FALSE;
PCHAR pServerName = NULL;


VOID
Initialize (
    VOID
    )
{
    DWORD   i;

    // Initialize the values in the data buffer.
    //
    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] = i;

}


BOOL
Usage (
    VOID
    )
{
    printf( "usage: \n" );
    printf( "-c             Tests ClearEventLog API\n");
    printf( "-b filename    Tests BackupEventLog API\n");
    printf( "-rsb           Reads event log sequentially backwards\n");
    printf( "-rsf           Reads event log sequentially forwards\n");
    printf( "-rrb <record>  Reads event log from <record> backwards\n");
    printf( "-rrf <record>  Reads event log from <record> forwards\n");
    printf( "-w <count>     Tests ReportEvent API <count> times\n");
    return ERROR_INVALID_PARAMETER;

} // Usage



BOOL
WriteLogEntry ( HANDLE LogHandle, DWORD EventID )

{
#define NUM_STRINGS     2
#define MAX_STRING_SIZE 32767   // Max size is FFFF/2 for ANSI strings

    BOOL    Status;
    WORD    EventType;
    DWORD   i;
    DWORD   DataSize;
    PSID    pUserSid;
    PCHAR   BigString;

    // PSTR    Strings[NUM_STRINGS] = {"StringAOne","StringATwo" };
    PSTR    Strings[NUM_STRINGS];

    Strings[0] = "StringAOne";

    BigString = malloc(MAX_STRING_SIZE);

    for (i = 0; i < MAX_STRING_SIZE; i++) {
        BigString[i] = 'A';
    }

    BigString[MAX_STRING_SIZE-1] = '\0';
    Strings[1] = BigString;

    EventType = EVENTLOG_INFORMATION_TYPE;
    pUserSid   = NULL;
    DataSize  = sizeof(DWORD) * SIZE_DATA_ARRAY;

    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] += i;

    Status = ReportEventA (
                    LogHandle,
                    EventType,
                    0,           // event category
                    EventID,
                    pUserSid,
                    (WORD) NUM_STRINGS,
                    DataSize,
                    Strings,
                    (PVOID)Data
                    );

    free(BigString);
    return (Status);
}

BOOL
WriteLogEntryMsg ( HANDLE LogHandle, DWORD EventID )
/*
    This function requires a registry entry in the Applications section
    of the Eventlog for TESTWINAAPP, it will use the netevent.dll message file.
*/
{
#define NUM_STRINGS     2

    BOOL    Status;
    WORD    EventType;
    DWORD   DataSize;
    PSID    pUserSid;
    PCHAR   BigString;

    PSTR    Strings[NUM_STRINGS];

    Strings[0] = "This is a BOGUS message for TEST purposes Ignore this substitution text";
    Strings[1] = "GHOST SERVICE in the long string format - I wanted a long string to pass into this function";

    EventType = EVENTLOG_INFORMATION_TYPE;
    pUserSid   = NULL;
    DataSize  = sizeof(DWORD) * SIZE_DATA_ARRAY;

    Status = ReportEventA (
                    LogHandle,
                    EventType,
                    0,          // event category
                    EVENT_SERVICE_START_FAILED_NONE,
                    pUserSid,
                    (WORD) NUM_STRINGS,
                    0,          // DataSize
                    Strings,
                    (PVOID)NULL // Data
                    );

    free(BigString);
    return (Status);
}


VOID
DisplayEventRecords( PVOID Buffer,
                     DWORD  BufSize,
                     ULONG *NumRecords)

{
    PEVENTLOGRECORD     pLogRecord;
    PSTR                pString;
    DWORD               Count = 0;
    DWORD               Offset = 0;
    DWORD               i;

    pLogRecord = (PEVENTLOGRECORD) Buffer;

    while ((DWORD)Offset < BufSize) {

        Count++;

        printf("\n\nRecord # %lu\n", pLogRecord->RecordNumber);

        printf("Length: 0x%lx TimeGenerated: 0x%lx  EventID: 0x%lx EventType: 0x%x\n",
                pLogRecord->Length, pLogRecord->TimeGenerated, pLogRecord->EventID,
                pLogRecord->EventType);

        printf("NumStrings: 0x%x StringOffset: 0x%lx UserSidLength: 0x%lx TimeWritten: 0x%lx\n",
                pLogRecord->NumStrings, pLogRecord->StringOffset,
                pLogRecord->UserSidLength, pLogRecord->TimeWritten);

        printf("UserSidOffset: 0x%lx    DataLength: 0x%lx    DataOffset:  0x%lx \n",
                pLogRecord->UserSidOffset, pLogRecord->DataLength,
                pLogRecord->DataOffset);

        //
        // Print out module name
        //
        pString = (PSTR)((DWORD)pLogRecord + sizeof(EVENTLOGRECORD));
        printf("ModuleName:  %s  ", pString);

        //
        // Display ComputerName
        //
        pString = (PSTR)((DWORD)pString + strlen(pString) + 1);
        printf("ComputerName: %s\n",pString);

        //
        // Display strings
        //
        pString = (PSTR)((DWORD)Buffer + pLogRecord->StringOffset);

        printf("Strings: ");
        for (i=0; i<pLogRecord->NumStrings; i++) {

            printf("  %s  ", pString);
            pString = (PSTR)((DWORD)pString + strlen(pString) + 1);
        }

        // Get next record

        Offset += pLogRecord->Length;

        pLogRecord = (PEVENTLOGRECORD)((DWORD)Buffer + Offset);

    }
    *NumRecords = Count;

}


BOOL
ReadFromLog ( HANDLE LogHandle,
             PVOID  Buffer,
             ULONG *pBytesRead,
             DWORD  ReadFlag,
             DWORD  Record
             )
{
    BOOL        Status;
    DWORD       MinBytesNeeded;
    DWORD       ErrorCode;

    Status = ReadEventLogA (
                        LogHandle,
                        ReadFlag,
                        Record,
                        Buffer,
                        READ_BUFFER_SIZE,
                        pBytesRead,
                        &MinBytesNeeded
                        );


    if (!Status) {
         ErrorCode = GetLastError();
         printf("Error from ReadEventLog %d \n", ErrorCode);
         if (ErrorCode == ERROR_NO_MORE_FILES)
            printf("Buffer too small. Need %lu bytes min\n", MinBytesNeeded);

    }

    return (Status);
}




BOOL
TestReadEventLog (DWORD Count, DWORD ReadFlag, DWORD Record)

{
    BOOL    Status, IStatus;

    HANDLE      LogHandle;
    LPSTR  ModuleName;
    DWORD   NumRecords, BytesReturned;
    PVOID   Buffer;
    DWORD   RecordOffset;
    DWORD   NumberOfRecords;
    DWORD   OldestRecord;

    printf("Testing ReadEventLog API to read %lu entries\n",Count);

    Buffer = malloc (READ_BUFFER_SIZE);

    //
    // Initialize the strings
    //
    NumRecords = Count;
    ModuleName = "TESTWINAAPP";

    //
    // Open the log handle
    //

    //
    // This is just a quick and dirty way to test the api to read a backup
    // log, until I can fix test.c to be more general purpose.
    //

    if (bHackTestBackup) {
        printf("OpenBackupEventLog = ");
        LogHandle = OpenBackupEventLog(
                NULL,
                "\\\\danhi386\\roote\\view.log"
                );
    }
    else {
        printf("OpenEventLog - ");
        LogHandle = OpenEventLog (
            pServerName,
            ModuleName
            );
    }

    if (LogHandle == NULL) {
         printf("Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Get and print record information
        //

        Status = GetNumberOfEventLogRecords(LogHandle, & NumberOfRecords);
        if (NT_SUCCESS(Status)) {
           Status = GetOldestEventLogRecord(LogHandle, & OldestRecord);
        }

        if (!NT_SUCCESS(Status)) {
           printf("Get of record information failed with %X", Status);
           return(Status);
        }

        printf("\nThere are %d records in the file, %d is the oldest"
         " record number\n", NumberOfRecords, OldestRecord);

        RecordOffset = Record;

        while (Count && (BytesReturned != 0)) {

            printf("Read %u records\n", NumRecords);
            //
            // Read from the log
            //
            Status = ReadFromLog ( LogHandle,
                                   Buffer,
                                   &BytesReturned,
                                   ReadFlag,
                                   RecordOffset
                                 );
            if (Status) {
                printf("Bytes read = 0x%lx\n", BytesReturned);
                DisplayEventRecords(Buffer, BytesReturned, &NumRecords);
                Count -= NumRecords;
                RecordOffset += NumRecords;
            } else {
                break;
            }

        }
        printf("\n");

        if (!Status) {
            printf ("Error - %d. Remaining count %lu\n", GetLastError(), Count);
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }
    free(Buffer);
    return (Status);
}



BOOL
TestWriteEventLog (DWORD Count)

{
    BOOL        Status, IStatus;
    HANDLE      LogHandle=NULL;
    LPSTR       ModuleName;
    DWORD       EventID = 99;
    DWORD       WriteCount;

    printf("Testing ReportEvent API\n");

    //
    // Initialize the strings
    //
    ModuleName = "TESTWINAAPP";

    //
    // Open the log handle
    //
    while (Count && NT_SUCCESS(Status)) {
        //printf("Calling RegisterEventSource for WRITE %lu times - ", Count);
        LogHandle = RegisterEventSourceA (
                        pServerName,
                        ModuleName
                        );
    
        if (LogHandle == NULL) {
             printf("Error - %d\n", GetLastError());
    
        } else {
            printf("Registered - ");
            WriteCount = 5;
            printf("Record # %u ", Count);

            while (WriteCount && NT_SUCCESS(Status)) {

                //
                // Write an entry into the log
                //
                Data[0] = Count;                        // Make data "unique"
                EventID = (EventID + Count) % 100;      // Vary the eventids
                Status = WriteLogEntryMsg ( LogHandle, EventID );
                Count--;
                WriteCount--;
    
                if (!Status) {
                    printf ("Error - %d. Remaining count %lu\n", GetLastError(), Count);
                } else {
                    printf ("%d,",WriteCount);
                }
            }
            IStatus = DeregisterEventSource (LogHandle);
            printf(" - Deregistered\n");
        }
    }

    return (Status);
}



BOOL
TestClearLogFile ()

{
    BOOL        Status, IStatus;
    HANDLE      LogHandle;
    LPSTR ModuleName, BackupName;

    printf("Testing ClearLogFile API\n");
    //
    // Initialize the strings
    //
    ModuleName = "TESTWINAAPP";

    //
    // Open the log handle
    //
    printf("Calling OpenEventLog for CLEAR - ");
    LogHandle = OpenEventLogA (
                    pServerName,
                    ModuleName
                    );

    if (!Status) {
         printf("Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Clear the log file and back it up to "view.log"
        //

        printf("Calling ClearEventLog backing up to view.log  ");
        BackupName = "view.log";

        Status = ClearEventLogA (
                        LogHandle,
                        BackupName
                        );

        if (!Status) {
            printf ("Error - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        //
        // Now just clear the file without backing it up
        //
        printf("Calling ClearEventLog with no backup  ");
        Status = ClearEventLogA (
                        LogHandle,
                        NULL
                        );

        if (!Status) {
            printf ("Error - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }

    return(Status);
}


BOOL
TestBackupLogFile(
    LPSTR FileName
    )

{
    HANDLE      LogHandle;

    printf("Testing BackupEventLog API\n");

    //
    // Open the log handle
    //

    printf("Calling ElfOpenEventLog for BACKUP - ");
    LogHandle = OpenEventLogA (
                    NULL,
                    "Application"
                    );

    if (!LogHandle) {
         printf("Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Backup the log file
        //

        printf("Calling BackupEventLogFile backing up to %s\n", FileName);

        if (!BackupEventLogA (
                        LogHandle,
                        FileName
                        )) {
            printf ("Error - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }


        printf("Calling CloseEventLog - ");
        if (CloseEventLog (LogHandle)) {
            printf("Success\n");
        }
        else {
            printf("Failed with code %d\n", GetLastError());
        }
    }

    return(TRUE);
}


/****************************************************************************/
BOOL
main (
    IN SHORT argc,
    IN PSZ argv[],
    )
/*++
*
* Routine Description:
*
*
*
* Arguments:
*
*
*
*
* Return Value:
*
*
*
--*/
/****************************************************************************/
{

    DWORD   ReadFlags;

    Initialize();           // Init any data

    //
    // Just till I can replace this horrid parm parsing with my own
    //

    if (getenv("REMOTE")) {
       pServerName = "\\\\danhi20";
    }

    if ( argc < 2 ) {
        printf( "Not enough parameters\n" );
        return Usage( );
    }

    if ( stricmp( argv[1], "-c" ) == 0 ) {

        if ( argc < 3 ) {
            return TestClearLogFile();
        }

    } else if (stricmp ( argv[1], "-b" ) == 0 ) {

        if ( argc < 3 ) {
            return Usage();
        } else {
            return TestBackupLogFile(argv[2]);
        }

    } else if (stricmp ( argv[1], "-rsf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-xsf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ;
    bHackTestBackup = TRUE;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-rsb" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-rrf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags ,1);
        } else if (argc == 3) {
            return (TestReadEventLog (1, ReadFlags, atoi(argv[2])));
        }
    } else if (stricmp ( argv[1], "-rrb" ) == 0 ) {

        ReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_BACKWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags, 1);
        } else if (argc == 3) {
            return (TestReadEventLog (1, ReadFlags, atoi(argv[2])));
        }
    } else if (stricmp ( argv[1], "-w" ) == 0 ) {

        if ( argc < 3 ) {
            return TestWriteEventLog(1);
        } else if (argc == 3) {
            return (TestWriteEventLog (atoi(argv[2])));
        }

    } else {

        return Usage();
    }

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\server\terminat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TERMINAT.C

Abstract:

    This file contains all the cleanup routines for the Eventlog service.
    These routines are called when the service is terminating.

Author:

    Rajen Shah  (rajens)    09-Aug-1991


Revision History:


--*/

//
// INCLUDES
//

#include <eventp.h>
#include <ntrpcp.h>


VOID
StopLPCThread(
    VOID
    )

/*++

Routine Description:

    This routine stops the LPC thread and cleans up LPC-related resources.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    ELF_LOG0(TRACE,
             "StopLpcThread: Clean up LPC thread and global data\n");

    //
    // Close communication port handle
    //
    NtClose(ElfCommunicationPortHandle);

    //
    // Close connection port handle
    //
    NtClose(ElfConnectionPortHandle);

    //
    // Terminate the LPC thread.
    //
    if (!TerminateThread(LPCThreadHandle, NO_ERROR))
    {
        ELF_LOG1(ERROR,
                 "StopLpcThread: TerminateThread failed %d\n",
                 GetLastError());
    }

    CloseHandle(LPCThreadHandle);

    return;
}




VOID
FreeModuleAndLogFileStructs(
    VOID
    )

/*++

Routine Description:

    This routine walks the module and log file list and frees all the
    data structures.

Arguments:

    NONE

Return Value:

    NONE

Note:

    The file header and ditry bits must have been dealt with before
    this routine is called. Also, the file must have been unmapped and
    the handle closed.

--*/
{

    NTSTATUS Status;
    PLOGMODULE pModule;
    PLOGFILE pLogFile;

    ELF_LOG0(TRACE,
             "FreeModuleAndLogFileStructs: Emptying log module list\n");

    //
    // First free all the modules
    //
    while (!IsListEmpty(&LogModuleHead))
    {
        pModule = (PLOGMODULE) CONTAINING_RECORD(LogModuleHead.Flink, LOGMODULE, ModuleList);

        UnlinkLogModule(pModule);    // Remove from linked list
        ElfpFreeBuffer (pModule);    // Free module memory
    }

    //
    // Now free all the logfiles
    //
    ELF_LOG0(TRACE,
             "FreeModuleAndLogFileStructs: Emptying log file list\n");

    while (!IsListEmpty(&LogFilesHead))
    {
        pLogFile = (PLOGFILE) CONTAINING_RECORD(LogFilesHead.Flink, LOGFILE, FileList);

        Status = ElfpCloseLogFile(pLogFile, ELF_LOG_CLOSE_NORMAL);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(FILES,
                     "FreeModuleAndLogFileStructs: ElfpCloseLogFile on %ws failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);
        }

        UnlinkLogFile(pLogFile);

        RtlDeleteResource(&pLogFile->Resource);
        ElfpFreeBuffer(pLogFile->LogFileName);
        ElfpFreeBuffer(pLogFile->LogModuleName);
        ElfpFreeBuffer(pLogFile);
    }
}


VOID
ElfpCleanUp (
    ULONG EventFlags
    )

/*++

Routine Description:

    This routine cleans up before the service terminates. It cleans up
    based on the parameter passed in (which indicates what has been allocated
    and/or started.

Arguments:

    Bit-mask indicating what needs to be cleaned up.

Return Value:

    NONE

Note:
    It is expected that the RegistryMonitor has already
    been notified of Shutdown prior to calling this routine.

--*/
{
    DWORD   status = NO_ERROR;

    //
    // Notify the Service Controller for the first time that we are
    // about to stop the service.
    //
    ElfStatusUpdate(STOPPING);

    ELF_LOG0(TRACE, "ElfpCleanUp: Cleaning up so service can exit\n");

    //
    // Give the ElfpSendMessage thread a 1 second chance to exit before
    // we free the QueuedMessageCritSec critical section
    //
    if( MBThreadHandle != NULL )
    {
        ELF_LOG0(TRACE, "ElfpCleanUp: Waiting for ElfpSendMessage thread to exit\n");

        status = WaitForSingleObject(MBThreadHandle, 1000);

        if (status != WAIT_OBJECT_0)
        {
            ELF_LOG1(ERROR, 
                     "ElfpCleanUp: NtWaitForSingleObject status = %d\n",
                     status);
        }
    }

    //
    // Stop the RPC Server
    //
    if (EventFlags & ELF_STARTED_RPC_SERVER)
    {
        ELF_LOG0(TRACE,
                 "ElfpCleanUp: Stopping the RPC server\n");

        status = ElfGlobalData->StopRpcServer(eventlog_ServerIfHandle);

        if (status != NO_ERROR)
        {
            ELF_LOG1(ERROR,
                     "ElfpCleanUp: StopRpcServer failed %d\n",
                     status);
        }
    }

    //
    // Stop the LPC thread
    //
    if (EventFlags & ELF_STARTED_LPC_THREAD)
    {
        StopLPCThread();
    }

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STOPPING);

    //
    // Flush all the log files to disk.
    //
    ELF_LOG0(TRACE,
             "ElfpCleanUp: Flushing log files\n");

    ElfpFlushFiles();

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STOPPING);

    //
    // Clean up any resources that were allocated
    //
    FreeModuleAndLogFileStructs();

    //
    // If we queued up any events, flush them
    //
    ELF_LOG0(TRACE,
             "ElfpCleanUp: Flushing queued events\n");

    FlushQueuedEvents();

    //
    // Tell service controller of that we are making progress
    //
    ElfStatusUpdate(STOPPING);

    if (EventFlags & ELF_INIT_GLOBAL_RESOURCE)
    {
        RtlDeleteResource(&GlobalElfResource);
    }

    if (EventFlags & ELF_INIT_CLUS_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&gClPropCritSec);
    }

    if (EventFlags & ELF_INIT_LOGHANDLE_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&LogHandleCritSec);
    }

    if (EventFlags & ELF_INIT_QUEUED_MESSAGE_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&QueuedMessageCritSec);
    }

    if (EventFlags & ELF_INIT_QUEUED_EVENT_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&QueuedEventCritSec);
    }

    if (EventFlags & ELF_INIT_LOGMODULE_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&LogModuleCritSec);
    }

    if (EventFlags & ELF_INIT_LOGFILE_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&LogFileCritSec);
    }

    LocalFree(GlobalMessageBoxTitle);
    GlobalMessageBoxTitle = NULL;

    //
    // *** STATUS UPDATE ***
    //
    ELF_LOG0(TRACE,
             "ElfpCleanUp: The Eventlog service has left the building\n");

    ElfStatusUpdate(STOPPED);
    ElCleanupStatus();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\eventlog\test\test.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TEST.C

Abstract:

    Test program for the eventlog service. This program calls the Elf
    APIs to test out the operation of the service.

Author:

    Rajen Shah  (rajens) 05-Aug-1991

Revision History:


--*/
/*----------------------*/
/* INCLUDES             */
/*----------------------*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>      // printf
#include <string.h>     // stricmp
#include <stdlib.h>
#include <process.h>    // exit
#include <elfcommn.h>
#include <windows.h>
#include <ntiolog.h>
#include <malloc.h>

#define     READ_BUFFER_SIZE        1024*2      // Use 2K buffer

#define     SIZE_DATA_ARRAY         22

#define SET_OPERATION(x) \
        if (Operation != Invalid) { \
           printf("Only one operation at a time\n"); \
           Usage(); \
        } \
        Operation = x;

//
// Global buffer used to emulate "binary data" when writing an event
// record.
//
ULONG    Data[SIZE_DATA_ARRAY];
enum _OPERATION_TYPE {
   Invalid,
   Clear,
   Backup,
   Read,
   Write,
   Notify,
   TestFull,
   LPC
} Operation = Invalid;
ULONG ReadFlags;
BOOL Verbose = FALSE;
ULONG NumberofRecords = 1;
ULONG DelayInMilliseconds = 0;
CHAR DefaultModuleName[] = "TESTAPP";
PCHAR pModuleName = DefaultModuleName;
PCHAR pBackupFileName;
ANSI_STRING AnsiString;
UNICODE_STRING ServerName;
BOOL ReadingBackupFile = FALSE;
BOOL ReadingModule = FALSE;
BOOL WriteInvalidRecords = FALSE;
BOOL InvalidUser = FALSE;

// Function prototypes

VOID ParseParms(ULONG argc, PCHAR *argv);

VOID
Initialize (
    VOID
    )
{
    ULONG   i;

    // Initialize the values in the data buffer.
    //
    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] = i;

}


VOID
Usage (
    VOID
    )
{
    printf( "usage: \n" );
    printf( "-c              Clears the specified log\n");
    printf( "-b <filename>   Backs up the log to file <filename>\n");
    printf( "-f <filename>   Filename of backup log to use for read\n");
    printf( "-i              Generate invalid SID\n");
    printf( "-l[i] nn        Writes nn records thru LPC port [i ==> bad records]\n");
    printf( "-m <modulename> Module name to use for read/clear\n");
    printf( "-n              Test out change notify\n");
    printf( "-rsb            Reads nn event log records sequentially backwards\n");
    printf( "-rsf nn         Reads nn event log records sequentially forwards\n");
    printf( "-rrb <record>   Reads event log from <record> backwards\n");
    printf( "-rrf <record>   Reads event log from <record> forwards\n");
    printf( "-s <servername> Name of server to remote calls to\n");
    printf( "-t nn           Number of milliseconds to delay between read/write"
            " (default 0)\n\tOnly used with -l switch\n");
    printf( "-w <count>      Writes <count> records\n");
    printf( "-z              Test to see if the logs are full\n");
    exit(0);

} // Usage


NTSTATUS
WriteLogEntry (
    HANDLE LogHandle,
    ULONG EventID
    )
{
#define NUM_STRINGS     2
#define SIZE_TOKEN_BUFFER 512

    SYSTEMTIME systime;
    NTSTATUS Status;
    USHORT   EventType, i;
    ULONG    DataSize;
    PSID     pUserSid = NULL;
    PWSTR    Strings[NUM_STRINGS] = {L"StringOne", L"StringTwo"};
    PUNICODE_STRING UStrings[NUM_STRINGS];
    HANDLE   hProcess;
    HANDLE   hToken;
    PTOKEN_USER pTokenUser;
    DWORD    SizeRequired;

    EventType = EVENTLOG_INFORMATION_TYPE;
    DataSize  = sizeof(ULONG) * SIZE_DATA_ARRAY;

    //
    // Get the SID of the current user (process)
    //

    pTokenUser = malloc(SIZE_TOKEN_BUFFER);

    if (!InvalidUser) {
        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
            GetCurrentProcessId());
        if (!hProcess) {
            printf("Couldn't open the process, rc = %d\n", GetLastError());
            return(STATUS_UNSUCCESSFUL);
        }

        if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
            printf("Couldn't open the token, rc = %d\n", GetLastError());
            CloseHandle(hProcess);
            return(STATUS_UNSUCCESSFUL);
        }
        if (!pTokenUser) {
            printf("Couldn't allocate buffer for TokenUser\n");
            CloseHandle(hToken);
            CloseHandle(hProcess);
            return(STATUS_UNSUCCESSFUL);
        }

        if (!GetTokenInformation(hToken, TokenUser, pTokenUser, SIZE_TOKEN_BUFFER,
            &SizeRequired)) {
                printf("Couldn't get TokenUser information, rc = %d\n",
                    GetLastError());
                CloseHandle(hToken);
                CloseHandle(hProcess);
                free(pTokenUser);
                return(STATUS_UNSUCCESSFUL);
        }

        CloseHandle(hToken);
        CloseHandle(hProcess);
    }
    else {
        memset(pTokenUser, 0xFADE, SIZE_TOKEN_BUFFER);
        pTokenUser->User.Sid = (PSID)pUserSid;
    }

    pUserSid = pTokenUser->User.Sid;

    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] += i;

    // Allocate space for the unicode strings in the array, and
    // copy over the strings from Strings[] to that array.
    //
    for (i=0; i<NUM_STRINGS; i++) {

        UStrings[i] = malloc(sizeof(UNICODE_STRING));
        RtlInitUnicodeString (UStrings[i], Strings[i]);
        UStrings[i]->MaximumLength = UStrings[i]->Length + sizeof(WCHAR);
    }

    //
    // Vary the data sizes.
    //

    GetLocalTime(&systime);

    DataSize = systime.wMilliseconds % sizeof(Data);
    printf("\nData Size = %lu\n", DataSize);

    Status = ElfReportEventW (
                    LogHandle,
                    EventType,
                    0,             // category
                    EventID,
                    pUserSid,
                    NUM_STRINGS,
                    DataSize,
                    UStrings,
                    (PVOID)Data,
                    0,              // Flags        -  paired event support
                    NULL,           // RecordNumber  | not in product 1
                    NULL            // TimeWritten  -
                    );

    for (i=0; i<NUM_STRINGS; i++)
        free(UStrings[i]);

    free(pTokenUser);
    return (Status);
}


VOID
DisplayEventRecords( PVOID Buffer,
                     ULONG  BufSize,
                     PULONG NumRecords)

{
    PEVENTLOGRECORD     pLogRecord;
    LPWSTR              pwString;
    ULONG               Count = 0;
    ULONG               Offset = 0;
    ULONG               i;

    pLogRecord = (PEVENTLOGRECORD) Buffer;

    while (Offset < BufSize && Count < *NumRecords) {

        printf("\nRecord # %lu\n", pLogRecord->RecordNumber);

        printf("Length: 0x%lx TimeGenerated: 0x%lx  EventID: 0x%lx EventType: 0x%x\n",
                pLogRecord->Length, pLogRecord->TimeGenerated, pLogRecord->EventID,
                pLogRecord->EventType);

        printf("NumStrings: 0x%x StringOffset: 0x%lx UserSidLength: 0x%lx TimeWritten: 0x%lx\n",
                pLogRecord->NumStrings, pLogRecord->StringOffset,
                pLogRecord->UserSidLength, pLogRecord->TimeWritten);

        printf("UserSidOffset: 0x%lx DataLength: 0x%lx DataOffset: 0x%lx Category: 0x%lx\n",
                pLogRecord->UserSidOffset, pLogRecord->DataLength,
                pLogRecord->DataOffset, pLogRecord->EventCategory);

        //
        // Print out module name
        //

        pwString = (PWSTR)((LPBYTE) pLogRecord + sizeof(EVENTLOGRECORD));
        printf("ModuleName: %ws\n", pwString);

        //
        // Display ComputerName
        //
        pwString += wcslen(pwString) + 1;
        printf("ComputerName: %ws\n", pwString);

        //
        // Display strings
        //

        pwString = (PWSTR)((LPBYTE)pLogRecord + pLogRecord->StringOffset);

        printf("Strings: ");
        for (i=0; i<pLogRecord->NumStrings; i++) {

            printf("  %ws  ", pwString);
            pwString += wcslen(pwString) + 1;
        }

        printf("\n");

        //
        // If verbose mode, display binary data (up to 256 bytes)
        //

        if (Verbose) {
            PULONG pData;
            PULONG pEnd;

            if (pLogRecord->DataLength < 80) {
                pEnd = (PULONG)((PBYTE) pLogRecord + pLogRecord->DataOffset +
                    pLogRecord->DataLength);
            }
            else {
                pEnd = (PULONG)((PBYTE) pLogRecord + pLogRecord->DataOffset +
                    256);
            }

            printf("Data: \n\n");
            for (pData = (PULONG)((PBYTE) pLogRecord + pLogRecord->DataOffset);
                 pData < pEnd; (PBYTE) pData += 32) {

                printf("\t%08x %08x %08x %08x\n", pData[0], pData[1], pData[2],
                    pData[3]);
            }
        }

        // Get next record
        //
        Offset += pLogRecord->Length;

//        pLogRecord = (PEVENTLOGRECORD)((ULONG)Buffer + Offset);
        pLogRecord = (PEVENTLOGRECORD)((BYTE *)Buffer + Offset);

        Count++;

    }

    *NumRecords = Count;

}


NTSTATUS
ReadFromLog ( HANDLE LogHandle,
             PVOID  Buffer,
             PULONG pBytesRead,
             ULONG  ReadFlag,
             ULONG  Record
             )
{
    NTSTATUS    Status;
    ULONG       MinBytesNeeded;

    Status = ElfReadEventLogW (
                        LogHandle,
                        ReadFlag,
                        Record,
                        Buffer,
                        READ_BUFFER_SIZE,
                        pBytesRead,
                        &MinBytesNeeded
                        );


    if (Status == STATUS_BUFFER_TOO_SMALL)
        printf("Buffer too small. Need %lu bytes min\n", MinBytesNeeded);

    return (Status);
}


NTSTATUS
TestReadEventLog (
    ULONG Count,
    ULONG ReadFlag,
    ULONG Record
    )

{
    NTSTATUS    Status, IStatus;

    HANDLE      LogHandle;
    UNICODE_STRING  ModuleNameU;
    ANSI_STRING ModuleNameA;
    ULONG   NumRecords, BytesReturned;
    PVOID   Buffer;
    ULONG   RecordOffset;
    ULONG   NumberOfRecords;
    ULONG   OldestRecord;

    printf("Testing ElfReadEventLog API to read %lu entries\n",Count);

    Buffer = malloc (READ_BUFFER_SIZE);

    //
    // Initialize the strings
    //
    NumRecords = Count;
    RtlInitAnsiString(&ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    //
    // Open the log handle
    //

    if (ReadingBackupFile) {
        printf("ElfOpenBackupEventLog - ");
        Status = ElfOpenBackupEventLogW (
                        &ServerName,
                        &ModuleNameU,
                        &LogHandle
                        );
    }
    else {
        printf("ElfOpenEventLog - ");
        Status = ElfOpenEventLogW (
                        &ServerName,
                        &ModuleNameU,
                        &LogHandle
                        );
    }

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Get and print record information
        //

        Status = ElfNumberOfRecords(LogHandle, & NumberOfRecords);
        if (NT_SUCCESS(Status)) {
           Status = ElfOldestRecord(LogHandle, & OldestRecord);
        }

        if (!NT_SUCCESS(Status)) {
           printf("Query of record information failed with %X", Status);
           return(Status);
        }

        printf("\nThere are %d records in the file, %d is the oldest"
         " record number\n", NumberOfRecords, OldestRecord);

        RecordOffset = Record;

        while (Count && NT_SUCCESS(Status)) {

            printf("Read %u records\n", NumRecords);
            //
            // Read from the log
            //
            Status = ReadFromLog ( LogHandle,
                                   Buffer,
                                   &BytesReturned,
                                   ReadFlag,
                                   RecordOffset
                                 );
            if (NT_SUCCESS(Status)) {

                printf("Bytes read = 0x%lx\n", BytesReturned);
                NumRecords = Count;
                DisplayEventRecords(Buffer, BytesReturned, &NumRecords);
                Count -= NumRecords;
            }

        }
        printf("\n");

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_END_OF_FILE) {
               printf("Tried to read more records than in log file\n");
            }
            else {
                printf ("Error - 0x%lx. Remaining count %lu\n", Status, Count);
            }
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfCloseEventLog\n");
        IStatus = ElfCloseEventLog (LogHandle);
    }

    return (Status);
}


NTSTATUS
TestReportEvent (
    ULONG Count
    )

{
    NTSTATUS    Status, IStatus;
    HANDLE      LogHandle;
    UNICODE_STRING  ModuleNameU;
    ANSI_STRING ModuleNameA;
    ULONG EventID = 99;

    printf("Testing ElfReportEvent API\n");

    //
    // Initialize the strings
    //

    RtlInitAnsiString(&ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    //
    // Open the log handle
    //
    printf("Calling ElfRegisterEventSource for WRITE %lu times - ", Count);
    Status = ElfRegisterEventSourceW (
                    &ServerName,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        while (Count && NT_SUCCESS(Status)) {

            printf("Record # %u \n", Count);

            //
            // Write an entry into the log
            //
            Data[0] = Count;                        // Make data "unique"
            EventID = (EventID + Count) % 100;      // Vary the eventids
            Status = WriteLogEntry ( LogHandle, EventID );
            Count--;
        }
        printf("\n");

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_LOG_FILE_FULL) {
                printf("Log Full\n");
            }
            else {
                printf ("Error - 0x%lx. Remaining count %lu\n", Status, Count);
            }
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfDeregisterEventSource\n");
        IStatus = ElfDeregisterEventSource (LogHandle);
    }

    return (Status);
}


NTSTATUS
TestElfClearLogFile(
    VOID
    )

{
    NTSTATUS    Status, IStatus;
    HANDLE      LogHandle;
    UNICODE_STRING  BackupU, ModuleNameU;
    ANSI_STRING ModuleNameA;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE  ClearHandle;
    FILE_DISPOSITION_INFORMATION DeleteInfo = {TRUE};
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN DontRetry = FALSE;

    printf("Testing ElfClearLogFile API\n");
    //
    // Initialize the strings
    //
    RtlInitAnsiString( &ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    //
    // Open the log handle
    //
    printf("Calling ElfOpenEventLog for CLEAR - ");
    Status = ElfOpenEventLogW (
                    &ServerName,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Clear the log file and back it up to "view.evt"
        //

        RtlInitUnicodeString( &BackupU,
            L"\\SystemRoot\\System32\\Config\\view.evt" );
        BackupU.MaximumLength = BackupU.Length + sizeof(WCHAR);
retry:
        printf("Calling ElfClearEventLogFile backing up to view.evt  ");
        Status = ElfClearEventLogFileW (
                        LogHandle,
                        &BackupU
                        );

        if (Status == STATUS_OBJECT_NAME_COLLISION) {
            if (DontRetry) {
                printf("Still can't backup to View.Evt\n");
            }
            else {
                printf("Failed.\nView.Evt already exists, deleting ...\n");

                //
                // Open the file with delete access
                //

                InitializeObjectAttributes(
                                &ObjectAttributes,
                                &BackupU,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

                Status = NtOpenFile(&ClearHandle,
                                    GENERIC_READ | DELETE | SYNCHRONIZE,
                                    &ObjectAttributes,
                                    &IoStatusBlock,
                                    FILE_SHARE_DELETE,
                                    FILE_SYNCHRONOUS_IO_NONALERT
                                    );

                Status = NtSetInformationFile(
                            ClearHandle,
                            &IoStatusBlock,
                            &DeleteInfo,
                            sizeof(DeleteInfo),
                            FileDispositionInformation
                            );

                if (NT_SUCCESS (Status) ) {
                    Status = NtClose (ClearHandle);    // Discard status
                    goto retry;
                }

                printf("Delete failed 0x%lx\n",Status);
                Status = NtClose (ClearHandle);    // Discard status
                goto JustClear;
            }
        }

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }

JustClear:

        //
        // Now just clear the file without backing it up
        //
        printf("Calling ElfClearEventLogFile with no backup  ");
        Status = ElfClearEventLogFileW (
                        LogHandle,
                        NULL
                        );

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfCloseEventLog\n");
        IStatus = ElfCloseEventLog (LogHandle);
    }

    return(Status);
}


NTSTATUS
TestElfBackupLogFile(
    VOID
    )

{
    NTSTATUS    Status, IStatus;
    HANDLE      LogHandle;
    UNICODE_STRING  BackupU, ModuleNameU;
    ANSI_STRING AnsiString;

    printf("Testing ElfBackupLogFile API\n");

    //
    // Initialize the strings
    //

    RtlInitAnsiString( &AnsiString, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &AnsiString, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    //
    // Open the log handle
    //

    printf("Calling ElfOpenEventLog for BACKUP - ");
    Status = ElfOpenEventLogW (
                    &ServerName,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Backup the log file
        //

        printf("Calling ElfBackupEventLogFile backing up to %s ",
            pBackupFileName);

        RtlInitAnsiString( &AnsiString, pBackupFileName);
        RtlAnsiStringToUnicodeString(&BackupU, &AnsiString, TRUE);
        BackupU.MaximumLength = BackupU.Length + sizeof(WCHAR);

        Status = ElfBackupEventLogFileW (
                        LogHandle,
                        &BackupU
                        );

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }


        printf("Calling ElfCloseEventLog - ");
        IStatus = ElfCloseEventLog (LogHandle);
        if (NT_SUCCESS(IStatus)) {
            printf("Success\n");
        }
        else {
            printf("Failed with code %X\n", IStatus);
        }
    }

    return(Status);
}

#define DRIVER_NAME L"FLOPPY"
#define DEVICE_NAME L"A:"
#define STRING L"Test String"

// These include the NULL terminator, but is length in chars, not bytes
#define DRIVER_NAME_LENGTH 7
#define DEVICE_NAME_LENGTH 3
#define STRING_LENGTH 12

#define NUMBER_OF_DATA_BYTES 8

VOID
TestLPCWrite(
   DWORD NumberOfRecords,
   DWORD MillisecondsToDelay
   )
{

    HANDLE PortHandle;
    UNICODE_STRING PortName;
    NTSTATUS Status;
    SECURITY_QUALITY_OF_SERVICE Qos;
    PIO_ERROR_LOG_MESSAGE pIoErrorLogMessage;
    DWORD i;
    LPWSTR pDestinationString;
    PPORT_MESSAGE RequestMessage;
    PORT_MESSAGE ReplyMessage;
    WORD DataLength;
    WORD TotalLength;
    INT YorN;
    CHAR NumberString[8];
    ULONG MessageId = 1;
    DWORD BadType = 0;

    //
    // Warn the user about how this test works
    //

    printf("\nThis test doesn't end!  It will write a number of\n"
           "records, then prompt you to write more.  This is \n"
           "required since it is simulating the system thread\n"
           "which never shuts down it's connection\n\n"
           "Do you wish to continue with this test (y or n)? ");

    YorN = getc(stdin);

    if (YorN == 'n' || YorN == 'N') {
        return;
    }

    //
    // Initialize the SecurityQualityofService structure
    //

    Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    Qos.ImpersonationLevel = SecurityImpersonation;
    Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    Qos.EffectiveOnly = TRUE;

    //
    // Connect to the LPC Port
    //

    RtlInitUnicodeString( &PortName, L"\\ErrorLogPort" );

    Status = NtConnectPort(& PortHandle,
                           & PortName,
                           & Qos,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                           );

    if (!NT_SUCCESS(Status)) {
       printf("Connect to the LPC port failed with RC %X\n", Status);
       return;
    }

    //
    // Allocate the memory for the Message to send to the LPC port.  It
    // will contain a PORT_MESSAGE followed by an IO_ERROR_LOG_MESSAGE
    // followed by Drivername and Devicename UNICODE strings
    //

    DataLength =  PORT_MAXIMUM_MESSAGE_LENGTH -
        (sizeof(IO_ERROR_LOG_MESSAGE)
        + DRIVER_NAME_LENGTH  * sizeof(WCHAR)
        + DEVICE_NAME_LENGTH * sizeof(WCHAR)
        + STRING_LENGTH * sizeof(WCHAR));
    TotalLength = PORT_MAXIMUM_MESSAGE_LENGTH + (WORD) sizeof(PORT_MESSAGE);

    RequestMessage = (PPORT_MESSAGE) malloc(TotalLength);
    if (RequestMessage == NULL) {
       printf("Couldn't alloc %d bytes of memory for message\n", TotalLength);
       NtClose(PortHandle);
       return;
    }

    pIoErrorLogMessage = (PIO_ERROR_LOG_MESSAGE) ((LPBYTE) RequestMessage +
        sizeof(PORT_MESSAGE));

    //
    // Initialize the PORT_MESSAGE
    //

    RequestMessage->u1.s1.DataLength = PORT_MAXIMUM_MESSAGE_LENGTH;
    RequestMessage->u1.s1.TotalLength = TotalLength;
    RequestMessage->u2.s2.Type = 0;
    RequestMessage->u2.ZeroInit = 0;
    RequestMessage->ClientId.UniqueProcess = GetCurrentProcess();
    RequestMessage->ClientId.UniqueThread = GetCurrentThread();
    RequestMessage->MessageId = 0x1234;

    //
    // Initialize the IO_ERROR_LOG_MESSAGE
    //

    pIoErrorLogMessage->Type = IO_TYPE_ERROR_MESSAGE;
    pIoErrorLogMessage->Size = PORT_MAXIMUM_MESSAGE_LENGTH;
    pIoErrorLogMessage->DriverNameLength = DRIVER_NAME_LENGTH * sizeof(WCHAR);
    NtQuerySystemTime((PTIME) &pIoErrorLogMessage->TimeStamp);
    pIoErrorLogMessage->DriverNameOffset = sizeof(IO_ERROR_LOG_MESSAGE) +
        DataLength - sizeof(DWORD);

    pIoErrorLogMessage->EntryData.MajorFunctionCode = 1;
    pIoErrorLogMessage->EntryData.RetryCount = 5;
    pIoErrorLogMessage->EntryData.DumpDataSize = DataLength;
    pIoErrorLogMessage->EntryData.NumberOfStrings = 2;
    pIoErrorLogMessage->EntryData.StringOffset = sizeof(IO_ERROR_LOG_MESSAGE)
        - sizeof(DWORD) + DataLength +
        DRIVER_NAME_LENGTH * sizeof(WCHAR);
    pIoErrorLogMessage->EntryData.EventCategory = 0;
    pIoErrorLogMessage->EntryData.ErrorCode = 0xC0020008;
    pIoErrorLogMessage->EntryData.UniqueErrorValue = 0x20008;
    pIoErrorLogMessage->EntryData.FinalStatus = 0x1111;
    pIoErrorLogMessage->EntryData.SequenceNumber = 1;
    pIoErrorLogMessage->EntryData.IoControlCode = 0xFF;
    pIoErrorLogMessage->EntryData.DeviceOffset =
        RtlConvertUlongToLargeInteger(1);

    for (i = 0; i < DataLength ; i++ ) {
        pIoErrorLogMessage->EntryData.DumpData[i] = i;
    }

    //
    // Copy the strings
    //

    pDestinationString = (LPWSTR) ((LPBYTE) pIoErrorLogMessage
        + sizeof(IO_ERROR_LOG_MESSAGE)
        - sizeof(DWORD) + pIoErrorLogMessage->EntryData.DumpDataSize);
    wcscpy(pDestinationString, DRIVER_NAME);

    pDestinationString += DRIVER_NAME_LENGTH;
    wcscpy(pDestinationString, DEVICE_NAME);

    pDestinationString += DEVICE_NAME_LENGTH;
    wcscpy(pDestinationString, STRING);

    //
    // Write the packet as many times as requested, with delay, then ask
    // if they want to write more
    //
    while (NumberOfRecords) {

        printf("\n\nWriting %d records\n", NumberOfRecords);

        while(NumberOfRecords--) {
            printf(".");

            //
            // Put in a unique message number
            //

            RequestMessage->MessageId = MessageId++;

            //
            // If they want invalid records, give them invalid records
            //

            if (WriteInvalidRecords) {
                switch (BadType++) {
                case 0:
                    pIoErrorLogMessage->EntryData.DumpDataSize++;
                    break;

                case 1:
                    pIoErrorLogMessage->EntryData.NumberOfStrings++;
                    break;

                case 2:
                    pIoErrorLogMessage->EntryData.StringOffset++;
                    break;

                default:
                    BadType = 0;
                }
            }

            Status = NtRequestWaitReplyPort(PortHandle,
                                        RequestMessage,
                                        & ReplyMessage);

            if (!NT_SUCCESS(Status)) {
                printf("Request to LPC port failed with RC %X\n", Status);
                break;
            }

            //
            // Delay a little bit, if requested
            //

            if (MillisecondsToDelay) {
                Sleep(MillisecondsToDelay);
            }
        }
        printf("\nEnter the number of records to write ");

        while (!gets(NumberString) || !(NumberOfRecords = atoi(NumberString))) {
            printf("Enter the number of records to write ");
        }
    }

    //
    // Clean up and exit
    //

    Status = NtClose(PortHandle);
    if (!NT_SUCCESS(Status)) {
       printf("Close of Port failed with RC %X\n", Status);
    }

    free(RequestMessage);

    return;

}


VOID
TestChangeNotify(
   VOID
   )
{

    HANDLE Event;
    UNICODE_STRING  ModuleNameU;
    ANSI_STRING ModuleNameA;
    NTSTATUS Status;
    HANDLE LogHandle;
    OBJECT_ATTRIBUTES obja;
    ULONG NumRecords;
    ULONG BytesRead;
    ULONG MinBytesNeeded;
    PVOID Buffer;
    ULONG OldestRecord;
    ULONG NumberOfRecords;

    RtlInitAnsiString(&ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    Buffer = malloc (READ_BUFFER_SIZE);
    ASSERT(Buffer);

    //
    // Open the log handle
    //

    printf("ElfOpenEventLog - ");
    Status = ElfOpenEventLogW (
                    &ServerName,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);
         return;
    }

    printf("SUCCESS\n");

    //
    // Create the Event
    //

    InitializeObjectAttributes( &obja, NULL, 0, NULL, NULL);

    Status = NtCreateEvent(
                   &Event,
                   SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                   &obja,
                   SynchronizationEvent,
                   FALSE
                   );

    ASSERT(NT_SUCCESS(Status));

    //
    // Get the read pointer to the end of the log
    //

    Status = ElfOldestRecord(LogHandle, & OldestRecord);
    ASSERT(NT_SUCCESS(Status));
    Status = ElfNumberOfRecords(LogHandle, & NumberOfRecords);
    ASSERT(NT_SUCCESS(Status));
    OldestRecord += NumberOfRecords - 1;

    Status = ElfReadEventLogW (
                        LogHandle,
                        EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,
                        OldestRecord,
                        Buffer,
                        READ_BUFFER_SIZE,
                        &BytesRead,
                        &MinBytesNeeded
                        );


    //
    // This one should hit end of file
    //

    Status = ElfReadEventLogW (
                        LogHandle,
                        EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ,
                        0,
                        Buffer,
                        READ_BUFFER_SIZE,
                        &BytesRead,
                        &MinBytesNeeded
                        );

    if (Status != STATUS_END_OF_FILE) {
        printf("Hmmm, should have hit EOF (unless there are writes going"
            " on elsewhere- %X\n", Status);
    }

    //
    // Call ElfChangeNotify
    //

    Status = ElfChangeNotify(LogHandle, Event);
    ASSERT(NT_SUCCESS(Status));

    //
    // Now loop waiting for the event to get toggled
    //

    while (1) {

        Status = NtWaitForSingleObject(Event, FALSE, 0);
        printf("The change notify event just got kicked\n");

        //
        // Now read the new records
        //

        while(1) {

            Status = ElfReadEventLogW (
                                LogHandle,
                                EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ,
                                0,
                                Buffer,
                                READ_BUFFER_SIZE,
                                &BytesRead,
                                &MinBytesNeeded
                                );

            if (Status == STATUS_END_OF_FILE) {
                break;
            }

            NumRecords = 0xffff; // should be plenty
            DisplayEventRecords (Buffer, BytesRead, &NumRecords);
        }
    }
}


VOID
TestLogFull(
    VOID
    )
{
    HANDLE  hLogFile;
    BOOL    fIsFull;
    BOOLEAN fPrevious = FALSE;
    DWORD   i;
    DWORD   dwBytesNeeded;
    BOOL    fIsSecLog;
    
    LPWSTR  szLogNames[] = { L"Application", L"Security", L"System" };

    for (i = 0; i < sizeof(szLogNames) / sizeof(LPWSTR); i++) {

        fIsSecLog = (wcscmp(szLogNames[i], L"Security") == 0);

        if (fIsSecLog) {

            if (!NT_SUCCESS(RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                                               TRUE,
                                               FALSE,
                                               &fPrevious))) {

                printf("RtlAdjustPrivilege FAILED %d\n",
                       RtlNtStatusToDosError(GetLastError()));
            }
        }

        hLogFile = OpenEventLogW(NULL, szLogNames[i]);

        if (hLogFile != NULL) {

            if (GetEventLogInformation(hLogFile,
                                       0,          // Log full infolevel
                                       (LPBYTE)&fIsFull,
                                       sizeof(fIsFull),
                                       &dwBytesNeeded)) {

                printf("The %ws Log is%sfull\n",
                       szLogNames[i],
                       fIsFull ? " " : " not ");
            }
            else {

                printf("GetEventLogInformation FAILED %d for the %ws Log\n",
                       GetLastError(),
                       szLogNames[i]);
            }            
        }
        else {

            printf("OpenEventLog FAILED %d for the %ws Log\n",
                   GetLastError(),
                   szLogNames[i]);
        }

        if (fIsSecLog) {
            RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE, fPrevious, FALSE, &fPrevious);
        }
    }
}


VOID
__cdecl
main (
    IN SHORT argc,
    IN PSZ argv[]
    )
{

    Initialize();           // Init any data

    //
    // Parse the command line
    //

    ParseParms(argc, argv);

    switch (Operation) {
       case Clear:

          TestElfClearLogFile();
          break;

       case Backup:

          TestElfBackupLogFile();
          break;

       case Read:

          if (ReadFlags & EVENTLOG_SEEK_READ) {
              TestReadEventLog(1, ReadFlags, NumberofRecords) ;
          }
          else {
              TestReadEventLog(NumberofRecords, ReadFlags, 0) ;
          }
          break;

       case Write:

          TestReportEvent (NumberofRecords);
          break;

        case LPC:
          TestLPCWrite(NumberofRecords, DelayInMilliseconds);
          break;

        case Notify:
          TestChangeNotify();
          break;

        case TestFull:
          TestLogFull();
          break;

        default:
            printf("Invalid switch from ParseParms %d\n", Operation);
    }
}


VOID
ParseParms(
    ULONG argc,
    PCHAR *argv
    )
{

   ULONG i;
   PCHAR pch;

   for (i = 1; i < argc; i++) {    /* for each argument */
       if (*(pch = argv[i]) == '-') {
           while (*++pch) {
               switch (*pch) {
                   case 'b':

                     SET_OPERATION(Backup)

                     //
                     // Get the file name for backup
                     //

                     if (i+1 < argc) {
                        pBackupFileName = argv[++i];
                     }
                     else {
                        Usage();
                     }
                     break;

                   case 'c':

                     SET_OPERATION(Clear)

                     break;

                  case 'f':
                     if (i+1 < argc) {
                        pModuleName = argv[++i];
                        ReadingBackupFile = TRUE;
                     }
                     else {
                        Usage();
                     }
                     break;

                  case '?':
                  case 'h':
                  case 'H':
                     Usage();
                     break;

                  case 'i':
                     InvalidUser = TRUE;
                     break;

                  case 'l':

                     SET_OPERATION(LPC);

                     //
                     // See if they want invalid records
                     //

                     if (*++pch == 'i') {
                         WriteInvalidRecords = TRUE;
                     }

                     //
                     // See if they specified a number of records
                     //

                     if (i + 1 < argc && argv[i+1][0] != '-') {
                        NumberofRecords = atoi(argv[++i]);
                        if (NumberofRecords == 0) {
                           Usage();
                        }
                     }

                     break;

                  case 'm':
                     if (i+1 < argc) {
                        pModuleName = argv[++i];
                        ReadingModule = TRUE;
                     }
                     else {
                        Usage();
                     }
                     break;

                  case 'n':
                     SET_OPERATION(Notify)
                     break;

                   case 'r':

                     SET_OPERATION(Read)

                     //
                     // Different Read options
                     //

                     if (*++pch == 's') {
                        ReadFlags |= EVENTLOG_SEQUENTIAL_READ;
                     }
                     else if (*pch == 'r') {
                        ReadFlags |= EVENTLOG_SEEK_READ;
                     }
                     else {
                        Usage();
                     }

                     if (*++pch == 'f') {
                        ReadFlags |= EVENTLOG_FORWARDS_READ;
                     }
                     else if (*pch == 'b') {
                        ReadFlags |= EVENTLOG_BACKWARDS_READ;
                     }
                     else {
                        Usage();
                     }

                     //
                     // See if they specified a number of records
                     //

                     if (i + 1 < argc && argv[i+1][0] != '-') {
                        NumberofRecords = atoi(argv[++i]);
                        if (NumberofRecords == 0) {
                           Usage();
                        }
                     }

                     break;

                  case 's':
                     if (i+1 >= argc) {
                         printf("Must supply a server name with -s\n");
                         Usage();
                     }
                     RtlInitAnsiString(&AnsiString, argv[++i]);
                     RtlAnsiStringToUnicodeString(&ServerName, &AnsiString,
                        TRUE);
                     break;

                  case 't':
                     DelayInMilliseconds = atoi(argv[++i]);
                     break;

                  case 'v':
                     Verbose = TRUE;
                     break;

                  case 'w':

                     SET_OPERATION(Write)

                     //
                     // See if they specified a number of records
                     //

                     if (i + 1 < argc && argv[i+1][0] != '-') {
                        NumberofRecords = atoi(argv[++i]);
                        if (NumberofRecords == 0) {
                           Usage();
                        }
                     }

                     break;

                  case 'z':

                      SET_OPERATION(TestFull)
                      break;

                  default:        /* Invalid options */
                     printf("Invalid option %c\n\n", *pch);
                     Usage();
                     break;
               }
           }
       }

       //
       // There aren't any non switch parms
       //

       else {
          Usage();
       }
   }

   //
   // Verify parms are correct
   //


   if ( Operation == Invalid) {
       printf( "Must specify an operation\n");
       Usage( );
   }

   if (ReadingBackupFile && ReadingModule) {
       printf("-m and -f are mutually exclusive\n");
       Usage();
   }

   if (ReadingBackupFile && Operation == Write) {
       printf("You cannot write to a backup log file\n");
       Usage();
   }
   if (DelayInMilliseconds && Operation != LPC) {
       printf("\n\n-t switch is only used with -l\n\n");
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\allocsup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements the Allocation support routines for Cdfs.

    The data structure used here is the CD_MCB.  There is an entry in
    the Mcb for each dirent for a file.  The entry will map the offset
    within some file to a starting disk offset and number of bytes.
    The Mcb also contains the interleave information for an extent.
    An interleave consists of a number of blocks with data and a
    (possibly different) number of blocks to skip.  Any number of
    data/skip pairs may exist in an extent but the data and skip sizes
    are the same throughout the extent.

    We store the following information into an Mcb entry for an extent.

        FileOffset          Offset in file for start of extent
        DiskOffset          Offset on disk for start of extent
        ByteCount           Number of file bytes in extent, no skip bytes
        DataBlockByteCount  Number of bytes in each data block
        TotalBlockByteCount Number of bytes is data block and skip block

    The disk offset in the Mcb has already been biased by the size of
    the Xar block if present.  All of the byte count fields are aligned
    on logical block boundaries.  If this is a directory or path table
    then the file offset has been biased to round the initial disk
    offset down to a sector boundary.  The biasing is done when loading
    the values into an Mcb entry.

    An XA file has a header prepended to the file and each sector is 2352
    bytes.  The allocation information ignores the header and only deals
    with 2048 byte sectors.  Callers into the allocation package have
    adjusted the starting offset value to reflect 2048 sectors.  On return
    from this package the caller will have to convert from 2048 sector values
    into raw XA sector values.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_ALLOCSUP)

//
//  Local support routines
//

ULONG
CdFindMcbEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG FileOffset
    );

VOID
CdDiskOffsetFromMcbEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_MCB_ENTRY McbEntry,
    IN LONGLONG FileOffset,
    IN PLONGLONG DiskOffset,
    IN PULONG ByteCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdAddInitialAllocation)
#pragma alloc_text(PAGE, CdAddAllocationFromDirent)
#pragma alloc_text(PAGE, CdDiskOffsetFromMcbEntry)
#pragma alloc_text(PAGE, CdFindMcbEntry)
#pragma alloc_text(PAGE, CdInitializeMcb)
#pragma alloc_text(PAGE, CdLookupAllocation)
#pragma alloc_text(PAGE, CdTruncateAllocation)
#pragma alloc_text(PAGE, CdUninitializeMcb)
#endif


VOID
CdLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG FileOffset,
    OUT PLONGLONG DiskOffset,
    OUT PULONG ByteCount
    )

/*++

Routine Description:

    This routine looks through the mapping information for the file
    to find the logical diskoffset and number of bytes at that offset.
    We only deal with logical 2048 byte sectors here.

    If the mapping isn't present we will look it up on disk now.
    This routine assumes we are looking up a valid range in the file.  This
    routine raises if it can't find mapping for the file offset.

    The Fcb may not be locked prior to calling this routine.  We will always
    acquire it here.

Arguments:

    Fcb - Fcb representing this stream.

    FileOffset - Lookup the allocation beginning at this point.

    DiskOffset - Address to store the logical disk offset.

    ByteCount - Address to store the number of contiguous bytes beginning
        at DiskOffset above.

Return Value:

    None.

--*/

{
    BOOLEAN FirstPass = TRUE;
    ULONG McbEntryOffset;
    PFCB ParentFcb;
    BOOLEAN CleanupParent = FALSE;

    BOOLEAN UnlockFcb = FALSE;

    LONGLONG CurrentFileOffset;
    ULONG CurrentMcbOffset;
    PCD_MCB_ENTRY CurrentMcbEntry;

    DIRENT_ENUM_CONTEXT DirContext;
    DIRENT Dirent;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Use a try finally to facilitate cleanup.
    //

    try {

        //
        //  We use a loop to perform the lookup.  If we don't find the mapping in the
        //  first pass then we look up all of the allocation and then look again.

        while (TRUE) {

            //
            //
            //  Lookup the entry containing this file offset.
            //

            CdLockFcb( IrpContext, Fcb );
            UnlockFcb = TRUE;

            McbEntryOffset = CdFindMcbEntry( IrpContext, Fcb, FileOffset );

            //
            //  If within the Mcb then we use the data out of this entry and are
            //  done.
            //

            if (McbEntryOffset < Fcb->Mcb.CurrentEntryCount) {

                CdDiskOffsetFromMcbEntry( IrpContext,
                                          Fcb->Mcb.McbArray + McbEntryOffset,
                                          FileOffset,
                                          DiskOffset,
                                          ByteCount );

                break;

            //
            //  If this is not the first pass then the disk is corrupt.
            //

            } else if (!FirstPass) {

                CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }

            CdUnlockFcb( IrpContext, Fcb );
            UnlockFcb = FALSE;

            //
            //  Initialize the search dirent structures.
            //

            CdInitializeDirContext( IrpContext, &DirContext );
            CdInitializeDirent( IrpContext, &Dirent );

            //
            //  Otherwise we need to walk the dirents for this file until we find
            //  the one containing this entry.  The parent Fcb should always be
            //  present.
            //

            ParentFcb = Fcb->ParentFcb;
            CdAcquireFileShared( IrpContext, ParentFcb );
            CleanupParent = TRUE;

            //
            //  Do an unsafe test to see if we need to create a file object.
            //

            if (ParentFcb->FileObject == NULL) {

                CdCreateInternalStream( IrpContext, ParentFcb->Vcb, ParentFcb );
            }

            //
            //  Initialize the local variables to indicate the first dirent
            //  and lookup the first dirent.
            //

            CurrentFileOffset = 0;
            CurrentMcbOffset = 0;

            CdLookupDirent( IrpContext,
                            ParentFcb,
                            CdQueryFidDirentOffset( Fcb->FileId ),
                            &DirContext );

            //
            //  If we are adding allocation to the Mcb then add all of it.
            //

            while (TRUE ) {

                //
                //  Update the dirent from the on-disk dirent.
                //

                CdUpdateDirentFromRawDirent( IrpContext, ParentFcb, &DirContext, &Dirent );

                //
                //  Add this dirent to the Mcb if not already present.
                //

                CdLockFcb( IrpContext, Fcb );
                UnlockFcb = TRUE;

                if (CurrentMcbOffset >= Fcb->Mcb.CurrentEntryCount) {

                    CdAddAllocationFromDirent( IrpContext, Fcb, CurrentMcbOffset, CurrentFileOffset, &Dirent );
                }

                CdUnlockFcb( IrpContext, Fcb );
                UnlockFcb = FALSE;

                //
                //  If this is the last dirent for the file then exit.
                //

                if (!FlagOn( Dirent.DirentFlags, CD_ATTRIBUTE_MULTI )) {

                    break;
                }

                //
                //  If we couldn't find another entry then the directory is corrupt because
                //  the last dirent for a file doesn't exist.
                //

                if (!CdLookupNextDirent( IrpContext, ParentFcb, &DirContext, &DirContext )) {

                    CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
                }

                //
                //  Update our loop variables.
                //

                CurrentMcbEntry = Fcb->Mcb.McbArray + CurrentMcbOffset;
                CurrentFileOffset += CurrentMcbEntry->ByteCount;
                CurrentMcbOffset += 1;
            }

            //
            //  All of the allocation is loaded.  Go back and look up the mapping again.
            //  It better be there this time.
            //

            FirstPass = FALSE;
        }

    } finally {

        if (CleanupParent) {

            //
            //  Release the parent and cleanup the dirent structures.
            //

            CdReleaseFile( IrpContext, ParentFcb );

            CdCleanupDirContext( IrpContext, &DirContext );
            CdCleanupDirent( IrpContext, &Dirent );
        }

        if (UnlockFcb) { CdUnlockFcb( IrpContext, Fcb ); }
    }

    return;
}


VOID
CdAddAllocationFromDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG McbEntryOffset,
    IN LONGLONG StartingFileOffset,
    IN PDIRENT Dirent
    )

/*++

Routine Description:

    This routine is called to add an entry into the Cd Mcb.  We grow the Mcb
    as necessary and update the new entry.

    NOTE - The Fcb has already been locked prior to makeing this call.

Arguments:

    Fcb - Fcb containing the Mcb to update.

    McbEntryOffset - Offset into the Mcb array to add this data.

    StartingFileOffset - Offset in bytes from the start of the file.

    Dirent - Dirent containing the on-disk data for this entry.

Return Value:

    None

--*/

{
    ULONG NewArraySize;
    PVOID NewMcbArray;
    PCD_MCB_ENTRY McbEntry;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_LOCKED_FCB( Fcb );

    //
    //  If we need to grow the Mcb then do it now.
    //

    if (McbEntryOffset >= Fcb->Mcb.MaximumEntryCount) {

        //
        //  Allocate a new buffer and copy the old data over.
        //

        NewArraySize = Fcb->Mcb.MaximumEntryCount * 2 * sizeof( CD_MCB_ENTRY );

        NewMcbArray = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                NewArraySize,
                                                TAG_MCB_ARRAY );

        RtlZeroMemory( NewMcbArray, NewArraySize );
        RtlCopyMemory( NewMcbArray,
                       Fcb->Mcb.McbArray,
                       Fcb->Mcb.MaximumEntryCount * sizeof( CD_MCB_ENTRY ));

        //
        //  Deallocate the current array unless it is embedded in the Fcb.
        //

        if (Fcb->Mcb.MaximumEntryCount != 1) {

            ExFreePool( Fcb->Mcb.McbArray );
        }

        //
        //  Now update the Mcb with the new array.
        //

        Fcb->Mcb.MaximumEntryCount *= 2;
        Fcb->Mcb.McbArray = NewMcbArray;
    }

    //
    //  Update the new entry with the input data.
    //

    McbEntry = Fcb->Mcb.McbArray + McbEntryOffset;

    //
    //  Start with the location and length on disk.
    //

    McbEntry->DiskOffset = LlBytesFromBlocks( Fcb->Vcb, Dirent->StartingOffset );
    McbEntry->ByteCount = Dirent->DataLength;

    //
    //  Round the byte count up to a logical block boundary if this is
    //  the last extent.
    //

    if (!FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_MULTI )) {

        McbEntry->ByteCount = BlockAlign( Fcb->Vcb, McbEntry->ByteCount );
    }

    //
    //  The file offset is the logical position within this file.
    //  We know this is correct regardless of whether we bias the
    //  file size or disk offset.
    //

    McbEntry->FileOffset = StartingFileOffset;

    //
    //  Convert the interleave information from logical blocks to
    //  bytes.
    //

    if (Dirent->FileUnitSize != 0) {

        McbEntry->DataBlockByteCount = BytesFromBlocks( Fcb->Vcb, Dirent->FileUnitSize );
        McbEntry->TotalBlockByteCount = McbEntry->DataBlockByteCount +
                                        BytesFromBlocks( Fcb->Vcb, Dirent->InterleaveGapSize );

    //
    //  If the file is not interleaved then the size of the data block
    //  and total block are the same as the byte count.
    //

    } else {

        McbEntry->DataBlockByteCount =
        McbEntry->TotalBlockByteCount = McbEntry->ByteCount;
    }

    //
    //  Update the number of entries in the Mcb.  The Mcb is never sparse
    //  so whenever we add an entry it becomes the last entry in the Mcb.
    //

    Fcb->Mcb.CurrentEntryCount = McbEntryOffset + 1;

    return;
}


VOID
CdAddInitialAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG StartingBlock,
    IN LONGLONG DataLength
    )

/*++

Routine Description:

    This routine is called to set up the initial entry in an Mcb.

    This routine handles the single initial entry for a directory file.  We will 
    round the start block down to a sector boundary.  Our caller has already 
    biased the DataLength with any adjustments.  This is used for the case 
    where there is a single entry and we want to align the data on a sector 
    boundary.

Arguments:

    Fcb - Fcb containing the Mcb to update.

    StartingBlock - Starting logical block for this directory.  This is
        the start of the actual data.  We will bias this by the sector
        offset of the data.

    DataLength - Length of the data.

Return Value:

    None

--*/

{
    PCD_MCB_ENTRY McbEntry;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_LOCKED_FCB( Fcb );
    ASSERT( 0 == Fcb->Mcb.CurrentEntryCount);
    ASSERT( CDFS_NTC_FCB_DATA != Fcb->NodeTypeCode);

    //
    //  Update the new entry with the input data.
    //

    McbEntry = Fcb->Mcb.McbArray;

    //
    //  Start with the location and length on disk.
    //

    McbEntry->DiskOffset = LlBytesFromBlocks( Fcb->Vcb, StartingBlock );
    McbEntry->DiskOffset -= Fcb->StreamOffset;

    McbEntry->ByteCount = DataLength;

    //
    //  The file offset is the logical position within this file.
    //  We know this is correct regardless of whether we bias the
    //  file size or disk offset.
    //

    McbEntry->FileOffset = 0;

    //
    //  If the file is not interleaved then the size of the data block
    //  and total block are the same as the byte count.
    //

    McbEntry->DataBlockByteCount =
    McbEntry->TotalBlockByteCount = McbEntry->ByteCount;

    //
    //  Update the number of entries in the Mcb.  The Mcb is never sparse
    //  so whenever we add an entry it becomes the last entry in the Mcb.
    //

    Fcb->Mcb.CurrentEntryCount = 1;

    return;
}


VOID
CdTruncateAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingFileOffset
    )

/*++

Routine Description:

    This routine truncates the Mcb for a file by eliminating all of the Mcb
    entries from the entry which contains the given offset.

    The Fcb should be locked when this routine is called.

Arguments:

    Fcb - Fcb containing the Mcb to truncate.

    StartingFileOffset - Offset in the file to truncate the Mcb from.

Return Value:

    None

--*/

{
    ULONG McbEntryOffset;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_LOCKED_FCB( Fcb );

    //
    //  Find the entry containg this starting offset.
    //

    McbEntryOffset = CdFindMcbEntry( IrpContext, Fcb, StartingFileOffset );

    //
    //  Now set the current size of the mcb to this point.
    //

    Fcb->Mcb.CurrentEntryCount = McbEntryOffset;

    return;
}


VOID
CdInitializeMcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to initialize the Mcb in an Fcb.  We initialize
    this with an entry count of one and point to the entry in the Fcb
    itself.

    Fcb should be acquired exclusively when this is called.

Arguments:

    Fcb - Fcb containing the Mcb to initialize.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Set the entry counts to show there is one entry in the array and
    //  it is unused.
    //

    Fcb->Mcb.MaximumEntryCount = 1;
    Fcb->Mcb.CurrentEntryCount = 0;

    Fcb->Mcb.McbArray = &Fcb->McbEntry;

    return;
}


VOID
CdUninitializeMcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to cleanup an Mcb in an Fcb.  We look at the
    maximum run count in the Fcb and if greater than one we will deallocate
    the buffer.

    Fcb should be acquired exclusively when this is called.

Arguments:

    Fcb - Fcb containing the Mcb to uninitialize.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  If the count is greater than one then this is an allocated buffer.
    //

    if (Fcb->Mcb.MaximumEntryCount > 1) {

        ExFreePool( Fcb->Mcb.McbArray );
    }

    return;
}


//
//  Local suupport routine
//

ULONG
CdFindMcbEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG FileOffset
    )

/*++

Routine Description:

    This routine is called to find the Mcb entry which contains the file
    offset at the given point.  If the file offset is not currently in the
    Mcb then we return the offset of the entry to add.

    Fcb should be locked when this is called.

Arguments:

    Fcb - Fcb containing the Mcb to uninitialize.

    FileOffset - Return the Mcb entry which contains this file offset.

Return Value:

    ULONG - Offset in the Mcb of the entry for this offset.

--*/

{
    ULONG CurrentMcbOffset;
    PCD_MCB_ENTRY CurrentMcbEntry;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_LOCKED_FCB( Fcb );

    //
    //  We expect a linear search will be sufficient here.
    //

    CurrentMcbOffset = 0;
    CurrentMcbEntry = Fcb->Mcb.McbArray;

    while (CurrentMcbOffset < Fcb->Mcb.CurrentEntryCount) {

        //
        //  Check if the offset lies within the current Mcb position.
        //

        if (FileOffset < CurrentMcbEntry->FileOffset + CurrentMcbEntry->ByteCount) {

            break;
        }

        //
        //  Move to the next entry.
        //

        CurrentMcbOffset += 1;
        CurrentMcbEntry += 1;
    }

    //
    //  This is the offset containing this file offset (or the point
    //  where an entry should be added).
    //

    return CurrentMcbOffset;
}


//
//  Local support routine
//

VOID
CdDiskOffsetFromMcbEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_MCB_ENTRY McbEntry,
    IN LONGLONG FileOffset,
    IN PLONGLONG DiskOffset,
    IN PULONG ByteCount
    )

/*++

Routine Description:

    This routine is called to return the diskoffset and length of the file
    data which begins at offset 'FileOffset'.  We have the Mcb entry which
    contains the mapping and interleave information.

    NOTE - This routine deals with data in 2048 byte logical sectors.  If
        this is an XA file then our caller has already converted from
        'raw' file bytes to 'cooked' file bytes.

Arguments:

    McbEntry - Entry in the Mcb containing the allocation information.

    FileOffset - Starting Offset in the file to find the matching disk
        offsets.

    DiskOffset - Address to store the starting disk offset for this operation.

    ByteCount - Address to store number of contiguous bytes starting at this
        disk offset.

Return Value:

    None

--*/

{
    LONGLONG ExtentOffset;

    LONGLONG CurrentDiskOffset;
    LONGLONG CurrentExtentOffset;

    LONGLONG LocalByteCount;

    PAGED_CODE();
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Extent offset is the difference between the file offset and the start
    //  of the extent.
    //

    ExtentOffset = FileOffset - McbEntry->FileOffset;

    //
    //  Optimize the non-interleave case.
    //

    if (McbEntry->ByteCount == McbEntry->TotalBlockByteCount) {

        *DiskOffset = McbEntry->DiskOffset + ExtentOffset;

        LocalByteCount = McbEntry->ByteCount - ExtentOffset;

    } else {

        //
        //  Walk though any interleave until we reach the current offset in
        //  this extent.
        //

        CurrentExtentOffset = McbEntry->DataBlockByteCount;
        CurrentDiskOffset = McbEntry->DiskOffset;

        while (CurrentExtentOffset <= ExtentOffset) {

            CurrentDiskOffset += McbEntry->TotalBlockByteCount;
            CurrentExtentOffset += McbEntry->DataBlockByteCount;
        }

        //
        //  We are now positioned at the data block containing the starting
        //  file offset we were given.  The disk offset is the offset of
        //  the start of this block plus the extent offset into this block.
        //  The byte count is the data block byte count minus our offset into
        //  this block.
        //

        *DiskOffset = CurrentDiskOffset + (ExtentOffset + McbEntry->DataBlockByteCount - CurrentExtentOffset);

        //
        //  Make sure we aren't past the end of the data length.  This is possible
        //  if we only use part of the last data block on an interleaved file.
        //

        if (CurrentExtentOffset > McbEntry->ByteCount) {

            CurrentExtentOffset = McbEntry->ByteCount;
        }

        LocalByteCount = CurrentExtentOffset - ExtentOffset;
    }

    //
    //  If the byte count exceeds our limit then cut it to fit in 32 bits.
    //

    if (LocalByteCount > MAXULONG) {

        *ByteCount = MAXULONG;

    } else {

        *ByteCount = (ULONG) LocalByteCount;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\cachesup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    Cache.c

Abstract:

    This module implements the cache management routines for the Cdfs
    FSD and FSP, by calling the Common Cache Manager.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CACHESUP)

//
//  Local debug trace level
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCompleteMdl)
#pragma alloc_text(PAGE, CdCreateInternalStream)
#pragma alloc_text(PAGE, CdDeleteInternalStream)
#pragma alloc_text(PAGE, CdPurgeVolume)
#endif


VOID
CdCreateInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function creates an internal stream file for interaction
    with the cache manager.  The Fcb here can be for either a
    directory stream or for a path table stream.

Arguments:

    Vcb - Vcb for this volume.

    Fcb - Points to the Fcb for this file.  It is either an Index or
        Path Table Fcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT StreamFile = NULL;
    BOOLEAN DecrementReference = FALSE;

    BOOLEAN CleanupDirContext = FALSE;
    BOOLEAN UpdateFcbSizes = FALSE;

    DIRENT Dirent;
    DIRENT_ENUM_CONTEXT DirContext;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  We may only have the Fcb shared.  Lock the Fcb and do a
    //  safe test to see if we need to really create the file object.
    //

    CdLockFcb( IrpContext, Fcb );

    if (Fcb->FileObject != NULL) {

        CdUnlockFcb( IrpContext, Fcb );
        return;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Create the internal stream.  The Vpb should be pointing at our volume
        //  device object at this point.
        //

        StreamFile = IoCreateStreamFileObject( NULL, Vcb->Vpb->RealDevice );

        if (StreamFile == NULL) {

            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Initialize the fields of the file object.
        //

        StreamFile->ReadAccess = TRUE;
        StreamFile->WriteAccess = FALSE;
        StreamFile->DeleteAccess = FALSE;

        StreamFile->SectionObjectPointer = &Fcb->FcbNonpaged->SegmentObject;

        //
        //  Set the file object type and increment the Vcb counts.
        //

        CdSetFileObject( IrpContext,
                         StreamFile,
                         StreamFileOpen,
                         Fcb,
                         NULL );

        //
        //  We will reference the current Fcb twice to keep it from going
        //  away in the error path.  Otherwise if we dereference it
        //  below in the finally clause a close could cause the Fcb to
        //  be deallocated.
        //

        CdLockVcb( IrpContext, Vcb );
        CdIncrementReferenceCounts( IrpContext, Fcb, 2, 0 );
        CdUnlockVcb( IrpContext, Vcb );
        DecrementReference = TRUE;

        //
        //  Initialize the cache map for the file.
        //

        CcInitializeCacheMap( StreamFile,
                              (PCC_FILE_SIZES)&Fcb->AllocationSize,
                              TRUE,
                              &CdData.CacheManagerCallbacks,
                              Fcb );

        //
        //  Go ahead and store the stream file into the Fcb.
        //

        Fcb->FileObject = StreamFile;
        StreamFile = NULL;

        //
        //  If this is the first file object for a directory then we need to
        //  read the self entry for this directory and update the sizes
        //  in the Fcb.  We know that the Fcb has been initialized so
        //  that we have a least one sector available to read.
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED )) {

            ULONG NewDataLength;

            //
            //  Initialize the search structures.
            //

            CdInitializeDirContext( IrpContext, &DirContext );
            CdInitializeDirent( IrpContext, &Dirent );
            CleanupDirContext = TRUE;

            //
            //  Read the dirent from disk and transfer the data to the
            //  in-memory dirent.
            //

            CdLookupDirent( IrpContext,
                            Fcb,
                            Fcb->StreamOffset,
                            &DirContext );

            CdUpdateDirentFromRawDirent( IrpContext, Fcb, &DirContext, &Dirent );

            //
            //  Verify that this really for the self entry.  We do this by
            //  updating the name in the dirent and then checking that it matches
            //  one of the hard coded names.
            //

            CdUpdateDirentName( IrpContext, &Dirent, FALSE );

            if (Dirent.CdFileName.FileName.Buffer != CdUnicodeSelfArray) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            //
            //  If the data sizes are different then update the header
            //  and Mcb for this Fcb.
            //

            NewDataLength = BlockAlign( Vcb, Dirent.DataLength + Fcb->StreamOffset );

            if (NewDataLength == 0) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            if (NewDataLength != Fcb->FileSize.QuadPart) {

                Fcb->AllocationSize.QuadPart =
                Fcb->FileSize.QuadPart =
                Fcb->ValidDataLength.QuadPart = NewDataLength;

                CcSetFileSizes( Fcb->FileObject, (PCC_FILE_SIZES) &Fcb->AllocationSize );

                CdTruncateAllocation( IrpContext, Fcb, 0 );
                CdAddInitialAllocation( IrpContext,
                                        Fcb,
                                        Dirent.StartingOffset,
                                        NewDataLength );

                UpdateFcbSizes = TRUE;
            }

            //
            //  Check for the existence flag and transform to hidden.
            //

            if (FlagOn( Dirent.DirentFlags, CD_ATTRIBUTE_HIDDEN )) {

                SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
            }

            //
            //  Convert the time to NT time.
            //

            CdConvertCdTimeToNtTime( IrpContext,
                                     Dirent.CdTime,
                                     (PLARGE_INTEGER) &Fcb->CreationTime );

            //
            //  Update the Fcb flags to indicate we have read the
            //  self entry.
            //

            SetFlag( Fcb->FcbState, FCB_STATE_INITIALIZED );

            //
            //  If we updated the sizes then we want to purge the file.  Go
            //  ahead and unpin and then purge the first page.
            //

            CdCleanupDirContext( IrpContext, &DirContext );
            CdCleanupDirent( IrpContext, &Dirent );
            CleanupDirContext = FALSE;

            if (UpdateFcbSizes) {

                CcPurgeCacheSection( &Fcb->FcbNonpaged->SegmentObject,
                                     NULL,
                                     0,
                                     FALSE );
            }
        }

    } finally {

        //
        //  Cleanup any dirent structures we may have used.
        //

        if (CleanupDirContext) {

            CdCleanupDirContext( IrpContext, &DirContext );
            CdCleanupDirent( IrpContext, &Dirent );
        }

        //
        //  If we raised then we need to dereference the file object.
        //

        if (StreamFile != NULL) {

            ObDereferenceObject( StreamFile );
            Fcb->FileObject = NULL;
        }

        //
        //  Dereference and unlock the Fcb.
        //

        if (DecrementReference) {

            CdLockVcb( IrpContext, Vcb );
            CdDecrementReferenceCounts( IrpContext, Fcb, 1, 0 );
            CdUnlockVcb( IrpContext, Vcb );
        }

        CdUnlockFcb( IrpContext, Fcb );
    }

    return;
}


VOID
CdDeleteInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function creates an internal stream file for interaction
    with the cache manager.  The Fcb here can be for either a
    directory stream or for a path table stream.

Arguments:

    Fcb - Points to the Fcb for this file.  It is either an Index or
        Path Table Fcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Lock the Fcb.
    //

    CdLockFcb( IrpContext, Fcb );

    //
    //  Capture the file object.
    //

    FileObject = Fcb->FileObject;
    Fcb->FileObject = NULL;

    //
    //  It is now safe to unlock the Fcb.
    //

    CdUnlockFcb( IrpContext, Fcb );

    //
    //  Dereference the file object if present.
    //

    if (FileObject != NULL) {

        if (FileObject->PrivateCacheMap != NULL) {

            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }

        ObDereferenceObject( FileObject );
    }

    return;
}


NTSTATUS
CdCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the function of completing Mdl reads.
    It should be called only from CdFsdRead.

Arguments:

    Irp - Supplies the originating Irp.

Return Value:

    NTSTATUS - Will always be STATUS_SUCCESS.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    //
    // Do completion processing.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    CcMdlReadComplete( FileObject, Irp->MdlAddress );

    //
    // Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    // Complete the request and exit right away.
    //

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


NTSTATUS
CdPurgeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DismountUnderway
    )

/*++

Routine Description:

    This routine is called to purge the volume.  The purpose is to make all the stale file
    objects in the system go away in order to lock the volume.

    The Vcb is already acquired exclusively.  We will lock out all file operations by
    acquiring the global file resource.  Then we will walk through all of the Fcb's and
    perform the purge.

Arguments:

    Vcb - Vcb for the volume to purge.

    DismountUnderway - Indicates that we are trying to delete all of the objects.
        We will purge the Path Table and VolumeDasd and dereference all
        internal streams.

Return Value:

    NTSTATUS - The first failure of the purge operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVOID RestartKey = NULL;
    PFCB ThisFcb = NULL;
    PFCB NextFcb;

    BOOLEAN RemovedFcb;

    PAGED_CODE();

    //
    //  Force any remaining Fcb's in the delayed close queue to be closed.
    //

    CdFspClose( Vcb );

    //
    //  Acquire the global file resource.
    //

    CdAcquireAllFiles( IrpContext, Vcb );

    //
    //  Loop through each Fcb in the Fcb Table and perform the flush.
    //

    while (TRUE) {

        //
        //  Lock the Vcb to lookup the next Fcb.
        //

        CdLockVcb( IrpContext, Vcb );
        NextFcb = CdGetNextFcb( IrpContext, Vcb, &RestartKey );

        //
        //  Reference the NextFcb if present.
        //

        if (NextFcb != NULL) {

            NextFcb->FcbReference += 1;
        }

        //
        //  If the last Fcb is present then decrement reference count and call teardown
        //  to see if it should be removed.
        //

        if (ThisFcb != NULL) {

            ThisFcb->FcbReference -= 1;

            CdUnlockVcb( IrpContext, Vcb );

            CdTeardownStructures( IrpContext, ThisFcb, &RemovedFcb );

        } else {

            CdUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Break out of the loop if no more Fcb's.
        //

        if (NextFcb == NULL) {

            break;
        }

        //
        //  Move to the next Fcb.
        //

        ThisFcb = NextFcb;

        //
        //  If there is a image section then see if that can be closed.
        //

        if (ThisFcb->FcbNonpaged->SegmentObject.ImageSectionObject != NULL) {

            MmFlushImageSection( &ThisFcb->FcbNonpaged->SegmentObject, MmFlushForWrite );
        }

        //
        //  If there is a data section then purge this.  If there is an image
        //  section then we won't be able to.  Remember this if it is our first
        //  error.
        //

        if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
            !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                   NULL,
                                   0,
                                   FALSE ) &&
            (Status == STATUS_SUCCESS)) {

            Status = STATUS_UNABLE_TO_DELETE_SECTION;
        }

        //
        //  Dereference the internal stream if dismounting.
        //

        if (DismountUnderway &&
            (SafeNodeType( ThisFcb ) != CDFS_NTC_FCB_DATA) &&
            (ThisFcb->FileObject != NULL)) {

            CdDeleteInternalStream( IrpContext, ThisFcb );
        }
    }

    //
    //  Now look at the path table and volume Dasd Fcb's.
    //

    if (DismountUnderway) {

        if (Vcb->PathTableFcb != NULL) {

            ThisFcb = Vcb->PathTableFcb;
            InterlockedIncrement( &Vcb->PathTableFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            CdDeleteInternalStream( IrpContext, ThisFcb );

            InterlockedDecrement( &ThisFcb->FcbReference );

            CdTeardownStructures( IrpContext, ThisFcb, &RemovedFcb );
        }

        if (Vcb->VolumeDasdFcb != NULL) {

            ThisFcb = Vcb->VolumeDasdFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            InterlockedDecrement( &ThisFcb->FcbReference );

            CdTeardownStructures( IrpContext, ThisFcb, &RemovedFcb );
        }
    }

    //
    //  Release all of the files.
    //

    CdReleaseAllFiles( IrpContext, Vcb );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\cddata.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdData.c

Abstract:

    This module declares the global data used by the Cdfs file system.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDDATA_
#define _CDDATA_

//
//  Global data structures
//

extern CD_DATA CdData;
extern FAST_IO_DISPATCH CdFastIoDispatch;

//
//  Global constants
//

//
//  This is the number of times a mounted Vcb will be referenced on behalf
//  of the system.  The counts include the following references.
//
//      1 reference - shows the volume is mounted
//      1 reference - 1 for VolumeDasdFcb.
//      2 references - 1 for RootIndexFcb, 1 for internal stream.
//      2 references - 1 for PathTableFcb, 1 for internal stream.
//
//  For user references we add one for the reference in each of the internal
//  Fcb's.
//

#define CDFS_RESIDUAL_REFERENCE                     (6)
#define CDFS_RESIDUAL_USER_REFERENCE                (3)

//
//  Reserved directory strings
//

extern WCHAR CdUnicodeSelfArray[];
extern WCHAR CdUnicodeParentArray[];

extern UNICODE_STRING CdUnicodeDirectoryNames[];

//
//  Volume descriptor identifier strings.
//

extern CHAR CdHsgId[];
extern CHAR CdIsoId[];
extern CHAR CdXaId[];

//
//  Volume label for audio disks.
//

extern WCHAR CdAudioLabel[];
extern USHORT CdAudioLabelLength;

//
//  Pseudo file names for audio disks.
//

extern CHAR CdAudioFileName[];
extern UCHAR CdAudioFileNameLength;
extern ULONG CdAudioDirentSize;
extern ULONG CdAudioDirentsPerSector;
extern ULONG CdAudioSystemUseOffset;

#define AUDIO_NAME_ONES_OFFSET              (6)
#define AUDIO_NAME_TENS_OFFSET              (5)

//
//  Escape sequences for mounting Unicode volumes.
//

extern PCHAR CdJolietEscape[];

//
//  Hardcoded header for RIFF files.
//

extern LONG CdXAFileHeader[];
extern LONG CdAudioPlayHeader[];
extern LONG CdXAAudioPhileHeader[];


//
//  Turn on pseudo-asserts if CD_FREE_ASSERTS is defined.
//

#if !DBG
#ifdef CD_FREE_ASSERTS
#undef ASSERT
#undef ASSERTMSG
#define ASSERT(exp)        if (!(exp)) { extern BOOLEAN KdDebuggerEnabled; DbgPrint("%s:%d %s\n",__FILE__,__LINE__,#exp); if (KdDebuggerEnabled) { DbgBreakPoint(); } }
#define ASSERTMSG(msg,exp) if (!(exp)) { extern BOOLEAN KdDebuggerEnabled; DbgPrint("%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp); if (KdDebuggerEnabled) { DbgBreakPoint(); } }
#endif
#endif


//
//  The following assertion macros ensure that the indicated structure
//  is valid
//
//      ASSERT_STRUCT( IN PVOID Struct, IN CSHORT NodeType );
//      ASSERT_OPTIONAL_STRUCT( IN PVOID Struct OPTIONAL, IN CSHORT NodeType );
//
//      ASSERT_VCB( IN PVCB Vcb );
//      ASSERT_OPTIONAL_VCB( IN PVCB Vcb OPTIONAL );
//
//      ASSERT_FCB( IN PFCB Fcb );
//      ASSERT_OPTIONAL_FCB( IN PFCB Fcb OPTIONAL );
//
//      ASSERT_FCB_NONPAGED( IN PFCB_NONPAGED FcbNonpaged );
//      ASSERT_OPTIONAL_FCB( IN PFCB_NONPAGED FcbNonpaged OPTIONAL );
//
//      ASSERT_CCB( IN PSCB Ccb );
//      ASSERT_OPTIONAL_CCB( IN PSCB Ccb OPTIONAL );
//
//      ASSERT_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext );
//      ASSERT_OPTIONAL_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext OPTIONAL );
//
//      ASSERT_IRP( IN PIRP Irp );
//      ASSERT_OPTIONAL_IRP( IN PIRP Irp OPTIONAL );
//
//      ASSERT_FILE_OBJECT( IN PFILE_OBJECT FileObject );
//      ASSERT_OPTIONAL_FILE_OBJECT( IN PFILE_OBJECT FileObject OPTIONAL );
//
//  The following macros are used to check the current thread owns
//  the indicated resource
//
//      ASSERT_EXCLUSIVE_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_SHARED_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_RESOURCE_NOT_MINE( IN PERESOURCE Resource );
//
//  The following macros are used to check whether the current thread
//  owns the resoures in the given structures.
//
//      ASSERT_EXCLUSIVE_CDDATA
//
//      ASSERT_EXCLUSIVE_VCB( IN PVCB Vcb );
//
//      ASSERT_SHARED_VCB( IN PVCB Vcb );
//
//      ASSERT_EXCLUSIVE_FCB( IN PFCB Fcb );
//
//      ASSERT_SHARED_FCB( IN PFCB Fcb );
//
//      ASSERT_EXCLUSIVE_FILE( IN PFCB Fcb );
//
//      ASSERT_SHARED_FILE( IN PFCB Fcb );
//
//      ASSERT_LOCKED_VCB( IN PVCB Vcb );
//
//      ASSERT_NOT_LOCKED_VCB( IN PVCB Vcb );
//
//      ASSERT_LOCKED_FCB( IN PFCB Fcb );
//
//      ASSERT_NOT_LOCKED_FCB( IN PFCB Fcb );
//

//
//  Turn on the sanity checks if this is DBG or CD_FREE_ASSERTS
//

#if DBG
#undef CD_SANITY
#define CD_SANITY
#endif

#ifdef CD_SANITY

extern BOOLEAN CdTestRaisedStatus;

#define DebugBreakOnStatus(S) {                                                         \
    if (CdTestRaisedStatus) {                                                           \
        if ((S) == STATUS_DISK_CORRUPT_ERROR || (S) == STATUS_FILE_CORRUPT_ERROR) {     \
            DbgPrint( "CDFS: Breaking on possible media corruption (S = %08x)\n", (S)); \
            DbgPrint( "CDFS: Contact CDFS.SYS component owner for triage.\n");          \
            DbgPrint( "CDFS: 'eb %p 0' to disable this alert\n", &CdTestRaisedStatus ); \
            DbgBreakPoint();                                                            \
        }                                                                               \
    }                                                                                   \
}

#define ASSERT_STRUCT(S,T)                  ASSERT( SafeNodeType( S ) == (T) )
#define ASSERT_OPTIONAL_STRUCT(S,T)         ASSERT( ((S) == NULL) ||  (SafeNodeType( S ) == (T)) )

#define ASSERT_VCB(V)                       ASSERT_STRUCT( (V), CDFS_NTC_VCB )
#define ASSERT_OPTIONAL_VCB(V)              ASSERT_OPTIONAL_STRUCT( (V), CDFS_NTC_VCB )

#define ASSERT_FCB(F)                                           \
    ASSERT( (SafeNodeType( F ) == CDFS_NTC_FCB_DATA ) ||        \
            (SafeNodeType( F ) == CDFS_NTC_FCB_INDEX ) ||       \
            (SafeNodeType( F ) == CDFS_NTC_FCB_PATH_TABLE ) )

#define ASSERT_OPTIONAL_FCB(F)                                  \
    ASSERT( ((F) == NULL) ||                                    \
            (SafeNodeType( F ) == CDFS_NTC_FCB_DATA ) ||        \
            (SafeNodeType( F ) == CDFS_NTC_FCB_INDEX ) ||       \
            (SafeNodeType( F ) == CDFS_NTC_FCB_PATH_TABLE ) )

#define ASSERT_FCB_NONPAGED(FN)             ASSERT_STRUCT( (FN), CDFS_NTC_FCB_NONPAGED )
#define ASSERT_OPTIONAL_FCB_NONPAGED(FN)    ASSERT_OPTIONAL_STRUCT( (FN), CDFS_NTC_FCB_NONPAGED )

#define ASSERT_CCB(C)                       ASSERT_STRUCT( (C), CDFS_NTC_CCB )
#define ASSERT_OPTIONAL_CCB(C)              ASSERT_OPTIONAL_STRUCT( (C), CDFS_NTC_CCB )

#define ASSERT_IRP_CONTEXT(IC)              ASSERT_STRUCT( (IC), CDFS_NTC_IRP_CONTEXT )
#define ASSERT_OPTIONAL_IRP_CONTEXT(IC)     ASSERT_OPTIONAL_STRUCT( (IC), CDFS_NTC_IRP_CONTEXT )

#define ASSERT_IRP(I)                       ASSERT_STRUCT( (I), IO_TYPE_IRP )
#define ASSERT_OPTIONAL_IRP(I)              ASSERT_OPTIONAL_STRUCT( (I), IO_TYPE_IRP )

#define ASSERT_FILE_OBJECT(FO)              ASSERT_STRUCT( (FO), IO_TYPE_FILE )
#define ASSERT_OPTIONAL_FILE_OBJECT(FO)     ASSERT_OPTIONAL_STRUCT( (FO), IO_TYPE_FILE )

#define ASSERT_EXCLUSIVE_RESOURCE(R)        ASSERT( ExIsResourceAcquiredExclusiveLite( R ))

#define ASSERT_SHARED_RESOURCE(R)           ASSERT( ExIsResourceAcquiredSharedLite( R ))

#define ASSERT_RESOURCE_NOT_MINE(R)         ASSERT( !ExIsResourceAcquiredSharedLite( R ))

#define ASSERT_EXCLUSIVE_CDDATA             ASSERT( ExIsResourceAcquiredExclusiveLite( &CdData.DataResource ))
#define ASSERT_EXCLUSIVE_VCB(V)             ASSERT( ExIsResourceAcquiredExclusiveLite( &(V)->VcbResource ))
#define ASSERT_SHARED_VCB(V)                ASSERT( ExIsResourceAcquiredSharedLite( &(V)->VcbResource ))

#define ASSERT_EXCLUSIVE_FCB(F)             ASSERT( ExIsResourceAcquiredExclusiveLite( &(F)->FcbNonpaged->FcbResource ))
#define ASSERT_SHARED_FCB(F)                ASSERT( ExIsResourceAcquiredSharedLite( &(F)->FcbNonpaged->FcbResource ))

#define ASSERT_EXCLUSIVE_FILE(F)            ASSERT( ExIsResourceAcquiredExclusiveLite( (F)->Resource ))
#define ASSERT_SHARED_FILE(F)               ASSERT( ExIsResourceAcquiredSharedLite( (F)->Resource ))

#define ASSERT_LOCKED_VCB(V)                ASSERT( (V)->VcbLockThread == PsGetCurrentThread() )
#define ASSERT_NOT_LOCKED_VCB(V)            ASSERT( (V)->VcbLockThread != PsGetCurrentThread() )

#define ASSERT_LOCKED_FCB(F)                ASSERT( !FlagOn( (F)->FcbState, FCB_STATE_IN_FCB_TABLE) || ((F)->FcbLockThread == PsGetCurrentThread()))
#define ASSERT_NOT_LOCKED_FCB(F)            ASSERT( (F)->FcbLockThread != PsGetCurrentThread() )

#else

#define DebugBreakOnStatus(S)           { NOTHING; }

#define ASSERT_STRUCT(S,T)              { NOTHING; }
#define ASSERT_OPTIONAL_STRUCT(S,T)     { NOTHING; }
#define ASSERT_VCB(V)                   { NOTHING; }
#define ASSERT_OPTIONAL_VCB(V)          { NOTHING; }
#define ASSERT_FCB(F)                   { NOTHING; }
#define ASSERT_OPTIONAL_FCB(F)          { NOTHING; }
#define ASSERT_FCB_NONPAGED(FN)         { NOTHING; }
#define ASSERT_OPTIONAL_FCB(FN)         { NOTHING; }
#define ASSERT_CCB(C)                   { NOTHING; }
#define ASSERT_OPTIONAL_CCB(C)          { NOTHING; }
#define ASSERT_IRP_CONTEXT(IC)          { NOTHING; }
#define ASSERT_OPTIONAL_IRP_CONTEXT(IC) { NOTHING; }
#define ASSERT_IRP(I)                   { NOTHING; }
#define ASSERT_OPTIONAL_IRP(I)          { NOTHING; }
#define ASSERT_FILE_OBJECT(FO)          { NOTHING; }
#define ASSERT_OPTIONAL_FILE_OBJECT(FO) { NOTHING; }
#define ASSERT_EXCLUSIVE_RESOURCE(R)    { NOTHING; }
#define ASSERT_SHARED_RESOURCE(R)       { NOTHING; }
#define ASSERT_RESOURCE_NOT_MINE(R)     { NOTHING; }
#define ASSERT_EXCLUSIVE_CDDATA         { NOTHING; }
#define ASSERT_EXCLUSIVE_VCB(V)         { NOTHING; }
#define ASSERT_SHARED_VCB(V)            { NOTHING; }
#define ASSERT_EXCLUSIVE_FCB(F)         { NOTHING; }
#define ASSERT_SHARED_FCB(F)            { NOTHING; }
#define ASSERT_EXCLUSIVE_FILE(F)        { NOTHING; }
#define ASSERT_SHARED_FILE(F)           { NOTHING; }
#define ASSERT_LOCKED_VCB(V)            { NOTHING; }
#define ASSERT_NOT_LOCKED_VCB(V)        { NOTHING; }
#define ASSERT_LOCKED_FCB(F)            { NOTHING; }
#define ASSERT_NOT_LOCKED_FCB(F)        { NOTHING; }

#endif

#endif // _CDDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\cd.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Cd.h

Abstract:

    This module defines the on-disk structure of the Cdfs file system.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDFS_
#define _CDFS_

//
//  Sector size on Cdrom disks is hard-coded to 2048
//

#ifndef SECTOR_SIZE
#define SECTOR_SIZE                 (2048)
#endif

#define RAW_SECTOR_SIZE             (2352)
#define SECTOR_MASK                 (SECTOR_SIZE - 1)
#define INVERSE_SECTOR_MASK         ~(SECTOR_SIZE - 1)

#ifndef SECTOR_SHIFT
#define SECTOR_SHIFT                (11)
#endif

#define XA_SECTOR_SIZE              (2352)

//
//  Cdfs file id is a large integer.
//

typedef LARGE_INTEGER               FILE_ID;
typedef FILE_ID                     *PFILE_ID;

//
//  The following constants are values from the disk.
//

#define FIRST_VD_SECTOR             (16)

#define VOL_ID_LEN                  (5)
#define ESC_SEQ_LEN                 (3)

#define VERSION_1                   (1)

#define VD_TERMINATOR               (255)
#define VD_PRIMARY                  (1)
#define VD_SECONDARY                (2)

#define VOLUME_ID_LENGTH            (32)

//
//  Leave the following so that CdfsBoot.c will compile
//

#define CD_SECTOR_SIZE              (2048)

#define ISO_VOL_ID                  "CD001"
#define HSG_VOL_ID                  "CDROM"

#define ISO_ATTR_MULTI              0x0080
#define ISO_ATTR_DIRECTORY          0x0002

#define MIN_DIR_REC_SIZE        (sizeof( RAW_DIR_REC ) - MAX_FILE_ID_LENGTH)

#define RVD_STD_ID( r, i )      (i ?    r->StandardId       : \
                                        ((PRAW_HSG_VD) r)->StandardId )

#define RVD_DESC_TYPE( r, i )   (i ?    r->DescType         : \
                                        ((PRAW_HSG_VD) r)->DescType )

#define RVD_VERSION( r, i )     (i ?    r->Version          : \
                                        ((PRAW_HSG_VD) r)->Version )

#define RVD_LB_SIZE( r, i )     (i ?    r->LogicalBlkSzI    : \
                                        ((PRAW_HSG_VD) r)->LogicalBlkSzI )

#define RVD_VOL_SIZE( r, i )    (i ?    r->VolSpaceI      : \
                                        ((PRAW_HSG_VD) r)->VolSpaceI )

#define RVD_ROOT_DE( r, i )     (i ?    r->RootDe           : \
                                        ((PRAW_HSG_VD) r)->RootDe )

#define DE_FILE_FLAGS( iso, de ) (iso ? de->FlagsISO : de->FlagsHSG)

//
//  Data track flag for track entries in TOC
//

#define TOC_DATA_TRACK              (0x04)
#define TOC_LAST_TRACK              (0xaa)


//
//  There is considerable rearrangement of the volume descriptors for
//  ISO and HSG.  However, within each standard the same structure can
//  be used for both the primary and secondary descriptors.
//
//  Both of these structures are aligned correctly so that no
//  special macros will be needed to unpack them.
//

//
//  Declaration of length of root directory entry in volume descriptor
//

#define LEN_ROOT_DE                 (34)

//
//  Maximum length of file ID on the disk.  We allow file size beyond the ISO 9660
//  standard.
//

#define MAX_FILE_ID_LENGTH          (255)


typedef struct _RAW_ISO_VD {

    UCHAR       DescType;           // volume type: 1 = standard, 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CD001
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[2];     // LBN of 2 path tables Intel
    ULONG       PathTabLocM[2];     // LBN of 2 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[37];      // file name of copyright notice
    UCHAR       Abstract[37];       // file name of abstract
    UCHAR       Bibliograph[37];    // file name of bibliography
    UCHAR       CreateDate[17];     // volume creation date and time
    UCHAR       ModDate[17];        // volume modification date and time
    UCHAR       ExpireDate[17];     // volume expiration date and time
    UCHAR       EffectDate[17];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number = 1
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[653];     // remainder of 2048 bytes reserved

} RAW_ISO_VD;
typedef RAW_ISO_VD *PRAW_ISO_VD;


typedef struct _RAW_HSG_VD {

    ULONG       BlkNumI;            // logical block number Intel
    ULONG       BlkNumM;            // logical block number Motorola
    UCHAR       DescType;           // volume type: 1 = standard, 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CDROM
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[4];     // LBN of 4 path tables Intel
    ULONG       PathTabLocM[4];     // LBN of 4 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[32];      // file name of copyright notice
    UCHAR       Abstract[32];       // file name of abstract
    UCHAR       CreateDate[16];     // volume creation date and time
    UCHAR       ModDate[16];        // volume modification date and time
    UCHAR       ExpireDate[16];     // volume expiration date and time
    UCHAR       EffectDate[16];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[680];     // remainder of 2048 bytes reserved

} RAW_HSG_VD;
typedef RAW_HSG_VD *PRAW_HSG_VD;


typedef struct _RAW_JOLIET_VD {

    UCHAR       DescType;           // volume type: 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CD001
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII, Joliett Seq here
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[2];     // LBN of 2 path tables Intel
    ULONG       PathTabLocM[2];     // LBN of 2 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[37];      // file name of copyright notice
    UCHAR       Abstract[37];       // file name of abstract
    UCHAR       Bibliograph[37];    // file name of bibliography
    UCHAR       CreateDate[17];     // volume creation date and time
    UCHAR       ModDate[17];        // volume modification date and time
    UCHAR       ExpireDate[17];     // volume expiration date and time
    UCHAR       EffectDate[17];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number = 1
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[653];     // remainder of 2048 bytes reserved

} RAW_JOLIET_VD;
typedef RAW_JOLIET_VD *PRAW_JOLIET_VD;

//
//  Macros to access the different volume descriptors.
//

#define CdRvdId(R,F) (                  \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->StandardId :   \
    ((PRAW_ISO_VD) (R))->StandardId     \
)

#define CdRvdVersion(R,F) (             \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->Version :      \
    ((PRAW_ISO_VD) (R))->Version        \
)

#define CdRvdDescType(R,F) (            \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->DescType :     \
    ((PRAW_ISO_VD) (R))->DescType       \
)

#define CdRvdEsc(R,F) (                 \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->CharSet :      \
    ((PRAW_ISO_VD) (R))->CharSet        \
)

#define CdRvdVolId(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->VolumeId :     \
    ((PRAW_ISO_VD) (R))->VolumeId       \
)

#define CdRvdBlkSz(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->LogicalBlkSzI :\
    ((PRAW_ISO_VD) (R))->LogicalBlkSzI  \
)

#define CdRvdPtLoc(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->PathTabLocI[0]:\
    ((PRAW_ISO_VD) (R))->PathTabLocI[0] \
)

#define CdRvdPtSz(R,F) (                \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->PathTableSzI : \
    ((PRAW_ISO_VD) (R))->PathTableSzI   \
)

#define CdRvdDirent(R,F) (              \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->RootDe :       \
    ((PRAW_ISO_VD) (R))->RootDe         \
)

#define CdRvdVolSz(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->VolSpaceI :    \
    ((PRAW_ISO_VD) (R))->VolSpaceI      \
)


//
//  This structure is used to overlay a region of a disk sector
//  to retrieve a single directory entry.  There is a difference
//  in the file flags between the ISO and HSG version and a
//  additional byte in the ISO for the offset from Greenwich time.
//
//  The disk structure is aligned on a word boundary, so any 32
//  bit fields will be represented as an array of 16 bit fields.
//

typedef struct _RAW_DIRENT {

    UCHAR       DirLen;
    UCHAR       XarLen;
    UCHAR       FileLoc[4];
    UCHAR       FileLocMot[4];
    UCHAR       DataLen[4];
    UCHAR       DataLenMot[4];
    UCHAR       RecordTime[6];
    UCHAR       FlagsHSG;
    UCHAR       FlagsISO;
    UCHAR       IntLeaveSize;
    UCHAR       IntLeaveSkip;
    UCHAR       Vssn[2];
    UCHAR       VssnMot[2];
    UCHAR       FileIdLen;
    UCHAR       FileId[MAX_FILE_ID_LENGTH];

} RAW_DIRENT;
typedef RAW_DIRENT RAW_DIR_REC;
typedef RAW_DIRENT *PRAW_DIR_REC;
typedef RAW_DIRENT *PRAW_DIRENT;

#define CD_ATTRIBUTE_HIDDEN                         (0x01)
#define CD_ATTRIBUTE_DIRECTORY                      (0x02)
#define CD_ATTRIBUTE_ASSOC                          (0x04)
#define CD_ATTRIBUTE_MULTI                          (0x80)

#define CD_BASE_YEAR                                (1900)

#define MIN_RAW_DIRENT_LEN  (FIELD_OFFSET( RAW_DIRENT, FileId ) + 1)

#define BYTE_COUNT_8_DOT_3                          (24)

#define SHORT_NAME_SHIFT                            (5)

//
//  The following macro recovers the correct flag field.
//

#define CdRawDirentFlags(IC,RD) (                   \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG) ?   \
    (RD)->FlagsHSG :                                \
    (RD)->FlagsISO                                  \
)

//
//  The following macro converts from CD time to NT time.  On ISO
//  9660 media, we now pay attention to the GMT offset (integer
//  increments of 15 minutes offset from GMT).  HSG does not record
//  this field.
//
//  The restriction to the interval [-48, 52] comes from 9660 8.4.26.1
//
//  VOID
//  CdConvertCdTimeToNtTime (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCHAR CdTime,
//      OUT PLARGE_INTEGER NtTime
//      );
//

#define GMT_OFFSET_TO_NT ((LONGLONG) 15 * 60 * 1000 * 1000 * 10)

#define CdConvertCdTimeToNtTime(IC,CD,NT) {                     \
    TIME_FIELDS _TimeField;                                     \
    CHAR GmtOffset;                                             \
    _TimeField.Year = (CSHORT) *((PCHAR) CD) + CD_BASE_YEAR;    \
    _TimeField.Month = (CSHORT) *(Add2Ptr( CD, 1, PCHAR ));     \
    _TimeField .Day = (CSHORT) *(Add2Ptr( CD, 2, PCHAR ));      \
    _TimeField.Hour = (CSHORT) *(Add2Ptr( CD, 3, PCHAR ));      \
    _TimeField.Minute = (CSHORT) *(Add2Ptr( CD, 4, PCHAR ));    \
    _TimeField.Second = (CSHORT) *(Add2Ptr( CD, 5, PCHAR ));    \
    _TimeField.Milliseconds = (CSHORT) 0;                       \
    RtlTimeFieldsToTime( &_TimeField, NT );                     \
    if (!FlagOn((IC)->Vcb->VcbState, VCB_STATE_HSG) &&          \
        ((GmtOffset = *(Add2Ptr( CD, 6, PCHAR ))) != 0 ) &&     \
        (GmtOffset >= -48 && GmtOffset <= 52)) {                \
            (NT)->QuadPart += -GmtOffset * GMT_OFFSET_TO_NT;     \
        }                                                       \
}


//
//  The on-disk representation of a Path Table entry differs between
//  the ISO version and the HSG version.  The fields are the same
//  and the same size, but the positions are different.
//

typedef struct _RAW_PATH_ISO {

    UCHAR           DirIdLen;
    UCHAR           XarLen;
    USHORT          DirLoc[2];
    USHORT          ParentNum;
    UCHAR           DirId[MAX_FILE_ID_LENGTH];

} RAW_PATH_ISO;
typedef RAW_PATH_ISO *PRAW_PATH_ISO;
typedef RAW_PATH_ISO RAW_PATH_ENTRY;
typedef RAW_PATH_ISO *PRAW_PATH_ENTRY;

typedef struct _RAW_PATH_HSG {

    USHORT          DirLoc[2];
    UCHAR           XarLen;
    UCHAR           DirIdLen;
    USHORT          ParentNum;
    UCHAR           DirId[MAX_FILE_ID_LENGTH];

} RAW_PATH_HSG;
typedef RAW_PATH_HSG *PRAW_PATH_HSG;

#define MIN_RAW_PATH_ENTRY_LEN      (FIELD_OFFSET( RAW_PATH_ENTRY, DirId ) + 1)

//
//  The following macros are used to recover the different fields of the
//  Path Table entries.  The macro to recover the disk location of the
//  directory must copy it into a different variable for alignment reasons.
//
//      CdRawPathIdLen - Length of directory name in bytes
//      CdRawPathXar - Number of Xar blocks
//      CdRawPathLoc - Address of unaligned ulong for disk offset in blocks
//

#define CdRawPathIdLen(IC, RP) (                    \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->DirIdLen :              \
    (RP)->DirIdLen                                  \
)

#define CdRawPathXar(IC, RP) (                      \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->XarLen :                \
    (RP)->XarLen                                    \
)

#define CdRawPathLoc(IC, RP) (                      \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->DirLoc :                \
    (RP)->DirLoc                                    \
)


//
//  System use are for XA data.  The following is the system use area for
//  directory entries on XA data disks.
//

typedef struct _SYSTEM_USE_XA {

    //
    //  Owner ID.  Not used in this version.
    //

    UCHAR OwnerId[4];

    //
    //  Extent attributes.  Only interested if mode2 form2 or digital audio.
    //  This is stored big endian.  We will define the attribute flags so
    //  we can ignore this fact.
    //

    USHORT Attributes;

    //
    //  XA signature.  This value must be 'XA'.
    //

    USHORT Signature;

    //
    //  File Number.
    //

    UCHAR FileNumber;

    //
    //  Not used in this version.
    //

    UCHAR Reserved[5];

} SYSTEM_USE_XA;
typedef SYSTEM_USE_XA *PSYSTEM_USE_XA;

#define SYSTEM_USE_XA_FORM1             (0x0008)
#define SYSTEM_USE_XA_FORM2             (0x0010)
#define SYSTEM_USE_XA_DA                (0x0040)

#define SYSTEM_XA_SIGNATURE             (0x4158)

typedef enum _XA_EXTENT_TYPE {

    Form1Data = 0,
    Mode2Form2Data,
    CDAudio

} XA_EXTENT_TYPE;
typedef XA_EXTENT_TYPE *PXA_EXTENT_TYPE;

#endif // _CDFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\cdprocs.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdProcs.h

Abstract:

    This module defines all of the globally used procedures in the Cdfs
    file system.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDPROCS_
#define _CDPROCS_

#include <ntifs.h>

#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntddscsi.h>

#include "nodetype.h"
#include "Cd.h"
#include "CdStruc.h"
#include "CdData.h"

//**** x86 compiler bug ****

#if defined(_M_IX86)
#undef Int64ShraMod32
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#endif

//
//  Here are the different pool tags.
//

#define TAG_CCB                 'ccdC'      //  Ccb
#define TAG_CDROM_TOC           'ctdC'      //  TOC
#define TAG_DIRENT_NAME         'nddC'      //  CdName in dirent
#define TAG_ENUM_EXPRESSION     'eedC'      //  Search expression for enumeration
#define TAG_FCB_DATA            'dfdC'      //  Data Fcb
#define TAG_FCB_INDEX           'ifdC'      //  Index Fcb
#define TAG_FCB_NONPAGED        'nfdC'      //  Nonpaged Fcb
#define TAG_FCB_TABLE           'tfdC'      //  Fcb Table entry
#define TAG_FILE_NAME           'nFdC'      //  Filename buffer
#define TAG_GEN_SHORT_NAME      'sgdC'      //  Generated short name
#define TAG_IO_BUFFER           'fbdC'      //  Temporary IO buffer
#define TAG_IO_CONTEXT          'oidC'      //  Io context for async reads
#define TAG_IRP_CONTEXT         'cidC'      //  Irp Context
#define TAG_IRP_CONTEXT_LITE    'lidC'      //  Irp Context lite
#define TAG_MCB_ARRAY           'amdC'      //  Mcb array
#define TAG_PATH_ENTRY_NAME     'nPdC'      //  CdName in path entry
#define TAG_PREFIX_ENTRY        'epdC'      //  Prefix Entry
#define TAG_PREFIX_NAME         'npdC'      //  Prefix Entry name
#define TAG_SPANNING_PATH_TABLE 'psdC'      //  Buffer for spanning path table
#define TAG_UPCASE_NAME         'nudC'      //  Buffer for upcased name
#define TAG_VOL_DESC            'dvdC'      //  Buffer for volume descriptor
#define TAG_VPB                 'pvdC'      //  Vpb allocated in filesystem

//
//  Tag all of our allocations if tagging is turned on
//

#ifdef POOL_TAGGING

#undef FsRtlAllocatePool
#undef FsRtlAllocatePoolWithQuota
#define FsRtlAllocatePool(a,b) FsRtlAllocatePoolWithTag(a,b,'sfdC')
#define FsRtlAllocatePoolWithQuota(a,b) FsRtlAllocatePoolWithQuotaTag(a,b,'sfdC')

#endif // POOL_TAGGING


//
//  File access check routine, implemented in AcChkSup.c
//

//
//  BOOLEAN
//  CdIllegalFcbAccess (
//      IN PIRP_CONTEXT IrpContext,
//      IN TYPE_OF_OPEN TypeOfOpen,
//      IN ACCESS_MASK DesiredAccess
//      );
//

#define CdIllegalFcbAccess(IC,T,DA) (                           \
           BooleanFlagOn( (DA),                                 \
                          ((T) != UserVolumeOpen ?              \
                           (FILE_WRITE_ATTRIBUTES           |   \
                            FILE_WRITE_DATA                 |   \
                            FILE_WRITE_EA                   |   \
                            FILE_ADD_FILE                   |   \
                            FILE_ADD_SUBDIRECTORY           |   \
                            FILE_APPEND_DATA) : 0)          |   \
                          FILE_DELETE_CHILD                 |   \
                          DELETE                            |   \
                          WRITE_DAC ))


//
//  Allocation support routines, implemented in AllocSup.c
//
//  These routines are for querying allocation on individual streams.
//

VOID
CdLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG FileOffset,
    OUT PLONGLONG DiskOffset,
    OUT PULONG ByteCount
    );

VOID
CdAddAllocationFromDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG McbEntryOffset,
    IN LONGLONG StartingFileOffset,
    IN PDIRENT Dirent
    );

VOID
CdAddInitialAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG StartingBlock,
    IN LONGLONG DataLength
    );

VOID
CdTruncateAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingFileOffset
    );

VOID
CdInitializeMcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
CdUninitializeMcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );


//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

VOID
CdCreateInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    );

VOID
CdDeleteInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

NTSTATUS
CdCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdPurgeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DismountUnderway
    );

//
//  VOID
//  CdUnpinData (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PBCB *Bcb
//      );
//

#define CdUnpinData(IC,B)   \
    if (*(B) != NULL) { CcUnpinData( *(B) ); *(B) = NULL; }


//
//  Device I/O routines, implemented in DevIoSup.c
//
//  These routines perform the actual device read and writes.  They only affect
//  the on disk structure and do not alter any other data structures.
//

NTSTATUS
CdNonCachedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    );

NTSTATUS
CdNonCachedXARead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    );

BOOLEAN
CdReadSectors (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN BOOLEAN RaiseOnError,
    IN OUT PVOID Buffer,
    IN PDEVICE_OBJECT TargetDeviceObject
    );

NTSTATUS
CdCreateUserMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BufferLength,
    IN BOOLEAN RaiseOnError
    );

NTSTATUS
CdPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    );

//
//  VOID
//  CdMapUserBuffer (
//      IN PIRP_CONTEXT IrpContext
//      OUT PVOID UserBuffer
//      );
//
//  Returns pointer to sys address.  Will raise on failure.
//
//
//  VOID
//  CdLockUserBuffer (
//      IN PIRP_CONTEXT IrpContext,
//      IN ULONG BufferLength
//      );
//

#define CdMapUserBuffer(IC, UB) {                                               \
            *(UB) = (PVOID) ( ((IC)->Irp->MdlAddress == NULL) ?                 \
                    (IC)->Irp->UserBuffer :                                     \
                    (MmGetSystemAddressForMdlSafe( (IC)->Irp->MdlAddress, NormalPagePriority)));   \
            if (NULL == *(UB))  {                         \
                CdRaiseStatus( (IC), STATUS_INSUFFICIENT_RESOURCES);            \
            }                                                                   \
        }                                                                       
        

#define CdLockUserBuffer(IC,BL) {                   \
    if ((IC)->Irp->MdlAddress == NULL) {            \
        (VOID) CdCreateUserMdl( (IC), (BL), TRUE ); \
    }                                               \
}


//
//  Dirent support routines, implemented in DirSup.c
//

VOID
CdLookupDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG DirentOffset,
    OUT PDIRENT_ENUM_CONTEXT DirContext
    );

BOOLEAN
CdLookupNextDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIRENT_ENUM_CONTEXT CurrentDirContext,
    OUT PDIRENT_ENUM_CONTEXT NextDirContext
    );

VOID
CdUpdateDirentFromRawDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIRENT_ENUM_CONTEXT DirContext,
    IN OUT PDIRENT Dirent
    );

VOID
CdUpdateDirentName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDIRENT Dirent,
    IN ULONG IgnoreCase
    );

BOOLEAN
CdFindFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    OUT PCD_NAME *MatchingName
    );

BOOLEAN
CdFindDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    );

BOOLEAN
CdFindFileByShortName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN ULONG ShortNameDirentOffset,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    );

BOOLEAN
CdLookupNextInitialFileDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    );

VOID
CdLookupLastFileDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_ENUM_CONTEXT FileContext
    );

VOID
CdCleanupFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_ENUM_CONTEXT FileContext
    );

//
//  VOID
//  CdInitializeFileContext (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFILE_ENUM_CONTEXT FileContext
//      );
//
//
//  VOID
//  CdInitializeDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIRENT Dirent
//      );
//
//  VOID
//  CdInitializeDirContext (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIRENT_ENUM_CONTEXT DirContext
//      );
//
//  VOID
//  CdCleanupDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIRENT Dirent
//      );
//
//  VOID
//  CdCleanupDirContext (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIRENT_ENUM_CONTEXT DirContext
//      );
//
//  VOID
//  CdLookupInitialFileDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_ENUM_CONTEXT FileContext,
//      IN ULONG DirentOffset
//      );
//

#define CdInitializeFileContext(IC,FC) {                                \
    RtlZeroMemory( FC, sizeof( FILE_ENUM_CONTEXT ));                    \
    (FC)->PriorDirent = &(FC)->Dirents[0];                              \
    (FC)->InitialDirent = &(FC)->Dirents[1];                            \
    (FC)->CurrentDirent = &(FC)->Dirents[2];                            \
    (FC)->ShortName.FileName.MaximumLength = BYTE_COUNT_8_DOT_3;        \
    (FC)->ShortName.FileName.Buffer = (FC)->ShortNameBuffer;            \
}

#define CdInitializeDirent(IC,D)                                \
    RtlZeroMemory( D, sizeof( DIRENT ))

#define CdInitializeDirContext(IC,DC)                           \
    RtlZeroMemory( DC, sizeof( DIRENT_ENUM_CONTEXT ))

#define CdCleanupDirent(IC,D)  {                                \
    if (FlagOn( (D)->Flags, DIRENT_FLAG_ALLOC_BUFFER )) {       \
        ExFreePool( (D)->CdFileName.FileName.Buffer );          \
    }                                                           \
}

#define CdCleanupDirContext(IC,DC)                              \
    CdUnpinData( (IC), &(DC)->Bcb )

#define CdLookupInitialFileDirent(IC,F,FC,DO)                       \
    CdLookupDirent( IC,                                             \
                    F,                                              \
                    DO,                                             \
                    &(FC)->InitialDirent->DirContext );             \
    CdUpdateDirentFromRawDirent( IC,                                \
                                 F,                                 \
                                 &(FC)->InitialDirent->DirContext,  \
                                 &(FC)->InitialDirent->Dirent )


//
//  The following routines are used to manipulate the fscontext fields
//  of the file object, implemented in FilObSup.c
//

//
//  Type of opens.  FilObSup.c depends on this order.
//

typedef enum _TYPE_OF_OPEN {

    UnopenedFileObject = 0,
    StreamFileOpen,
    UserVolumeOpen,
    UserDirectoryOpen,
    UserFileOpen,
    BeyondValidType

} TYPE_OF_OPEN;
typedef TYPE_OF_OPEN *PTYPE_OF_OPEN;

VOID
CdSetFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PFCB Fcb OPTIONAL,
    IN PCCB Ccb OPTIONAL
    );

TYPE_OF_OPEN
CdDecodeFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PCCB *Ccb
    );

TYPE_OF_OPEN
CdFastDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb
    );


//
//  Name support routines, implemented in NameSup.c
//

VOID
CdConvertNameToCdName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PCD_NAME CdName
    );

VOID
CdConvertBigToLittleEndian (
    IN PIRP_CONTEXT IrpContext,
    IN PCHAR BigEndian,
    IN ULONG ByteCount,
    OUT PCHAR LittleEndian
    );

VOID
CdUpcaseName (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_NAME Name,
    IN OUT PCD_NAME UpcaseName
    );

VOID
CdDissectName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PUNICODE_STRING FinalName
    );

BOOLEAN
CdIs8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING FileName
    );

VOID
CdGenerate8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING FileName,
    IN ULONG DirentOffset,
    OUT PWCHAR ShortFileName,
    OUT PUSHORT ShortByteCount
    );

BOOLEAN
CdIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_NAME CurrentName,
    IN PCD_NAME SearchExpression,
    IN ULONG  WildcardFlags,
    IN BOOLEAN CheckVersion
    );

ULONG
CdShortNameDirentOffset (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name
    );

FSRTL_COMPARISON_RESULT
CdFullCompareNames (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    );


//
//  Filesystem control operations.  Implemented in Fsctrl.c
//

NTSTATUS
CdLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

NTSTATUS
CdUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );


//
//  Path table enumeration routines.  Implemented in PathSup.c
//

VOID
CdLookupPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG PathEntryOffset,
    IN ULONG Ordinal,
    IN BOOLEAN VerifyBounds,
    IN OUT PCOMPOUND_PATH_ENTRY CompoundPathEntry
    );

BOOLEAN
CdLookupNextPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PPATH_ENUM_CONTEXT PathContext,
    IN OUT PPATH_ENTRY PathEntry
    );

BOOLEAN
CdFindPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN PCD_NAME DirName,
    IN BOOLEAN IgnoreCase,
    IN OUT PCOMPOUND_PATH_ENTRY CompoundPathEntry
    );

VOID
CdUpdatePathEntryName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PPATH_ENTRY PathEntry,
    IN BOOLEAN IgnoreCase
    );

//
//  VOID
//  CdInitializeCompoundPathEntry (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCOMPOUND_PATH_ENTRY CompoundPathEntry
//      );
//
//  VOID
//  CdCleanupCompoundPathEntry (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCOMPOUND_PATH_ENTRY CompoundPathEntry
//      );
//

#define CdInitializeCompoundPathEntry(IC,CP)                                    \
    RtlZeroMemory( CP, sizeof( COMPOUND_PATH_ENTRY ))

#define CdCleanupCompoundPathEntry(IC,CP)     {                                 \
    CdUnpinData( (IC), &(CP)->PathContext.Bcb );                                \
    if ((CP)->PathContext.AllocatedData) {                                      \
        ExFreePool( (CP)->PathContext.Data );                                   \
    }                                                                           \
    if (FlagOn( (CP)->PathEntry.Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER )) {        \
        ExFreePool( (CP)->PathEntry.CdDirName.FileName.Buffer );                \
    }                                                                           \
}


//
//  Largest matching prefix searching routines, implemented in PrefxSup.c
//

VOID
CdInsertPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PFCB ParentFcb
    );

VOID
CdRemovePrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
CdFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *CurrentFcb,
    IN OUT PUNICODE_STRING RemainingName,
    IN BOOLEAN IgnoreCase
    );


//
//  Synchronization routines.  Implemented in Resrcsup.c
//
//  The following routines/macros are used to synchronize the in-memory structures.
//
//      Routine/Macro               Synchronizes                            Subsequent
//
//      CdAcquireCdData             Volume Mounts/Dismounts,Vcb Queue       CdReleaseCdData
//      CdAcquireVcbExclusive       Vcb for open/close                      CdReleaseVcb
//      CdAcquireVcbShared          Vcb for open/close                      CdReleaseVcb
//      CdAcquireAllFiles           Locks out operations to all files       CdReleaseAllFiles
//      CdAcquireFileExclusive      Locks out file operations               CdReleaseFile
//      CdAcquireFileShared         Files for file operations               CdReleaseFile
//      CdAcquireFcbExclusive       Fcb for open/close                      CdReleaseFcb
//      CdAcquireFcbShared          Fcb for open/close                      CdReleaseFcb
//      CdLockCdData                Fields in CdData                        CdUnlockCdData
//      CdLockVcb                   Vcb fields, FcbReference, FcbTable      CdUnlockVcb
//      CdLockFcb                   Fcb fields, prefix table, Mcb           CdUnlockFcb
//

typedef enum _TYPE_OF_ACQUIRE {
    
    AcquireExclusive,
    AcquireShared,
    AcquireSharedStarveExclusive

} TYPE_OF_ACQUIRE, *PTYPE_OF_ACQUIRE;

BOOLEAN
CdAcquireResource (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE Resource,
    IN BOOLEAN IgnoreWait,
    IN TYPE_OF_ACQUIRE Type
    );

//
//  BOOLEAN
//  CdAcquireCdData (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdReleaseCdData (
//      IN PIRP_CONTEXT IrpContext
//    );
//
//  BOOLEAN
//  CdAcquireVcbExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  CdAcquireVcbShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  VOID
//  CdReleaseVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  CdAcquireAllFiles (
//      IN PIRP_CONTEXT,
//      IN PVCB Vcb
//      );
//
//  VOID
//  CdReleaseAllFiles (
//      IN PIRP_CONTEXT,
//      IN PVCB Vcb
//      );
//
//  VOID
//  CdAcquireFileExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      );
//
//  VOID
//  CdAcquireFileShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdReleaseFile (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//    );
//
//  BOOLEAN
//  CdAcquireFcbExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  CdAcquireFcbShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  CdReleaseFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdLockCdData (
//      );
//
//  VOID
//  CdUnlockCdData (
//      );
//
//  VOID
//  CdLockVcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdUnlockVcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdLockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdUnlockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define CdAcquireCdData(IC)                                                             \
    ExAcquireResourceExclusiveLite( &CdData.DataResource, TRUE )

#define CdReleaseCdData(IC)                                                             \
    ExReleaseResourceLite( &CdData.DataResource )

#define CdAcquireVcbExclusive(IC,V,I)                                                   \
    CdAcquireResource( (IC), &(V)->VcbResource, (I), AcquireExclusive )

#define CdAcquireVcbShared(IC,V,I)                                                      \
    CdAcquireResource( (IC), &(V)->VcbResource, (I), AcquireShared )

#define CdReleaseVcb(IC,V)                                                              \
    ExReleaseResourceLite( &(V)->VcbResource )

#define CdAcquireAllFiles(IC,V)                                                         \
    CdAcquireResource( (IC), &(V)->FileResource, FALSE, AcquireExclusive )

#define CdReleaseAllFiles(IC,V)                                                         \
    ExReleaseResourceLite( &(V)->FileResource )

#define CdAcquireFileExclusive(IC,F)                                                    \
    CdAcquireResource( (IC), (F)->Resource, FALSE, AcquireExclusive )

#define CdAcquireFileShared(IC,F)                                                       \
    CdAcquireResource( (IC), (F)->Resource, FALSE, AcquireShared )

#define CdAcquireFileSharedStarveExclusive(IC,F)                                        \
    CdAcquireResource( (IC), (F)->Resource, FALSE, AcquireSharedStarveExclusive )

#define CdReleaseFile(IC,F)                                                             \
    ExReleaseResourceLite( (F)->Resource )

#define CdAcquireFcbExclusive(IC,F,I)                                                   \
    CdAcquireResource( (IC), &(F)->FcbNonpaged->FcbResource, (I), AcquireExclusive )

#define CdAcquireFcbShared(IC,F,I)                                                      \
    CdAcquireResource( (IC), &(F)->FcbNonpaged->FcbResource, (I), AcquireShared )

#define CdReleaseFcb(IC,F)                                                              \
    ExReleaseResourceLite( &(F)->FcbNonpaged->FcbResource )

#define CdLockCdData()                                                                  \
    ExAcquireFastMutex( &CdData.CdDataMutex );                                          \
    CdData.CdDataLockThread = PsGetCurrentThread()

#define CdUnlockCdData()                                                                \
    CdData.CdDataLockThread = NULL;                                                     \
    ExReleaseFastMutex( &CdData.CdDataMutex )

#define CdLockVcb(IC,V)                                                                 \
    ExAcquireFastMutex( &(V)->VcbMutex );                                               \
    ASSERT( NULL == (V)->VcbLockThread);                                                \
    (V)->VcbLockThread = PsGetCurrentThread()

#define CdUnlockVcb(IC,V)                                                               \
    ASSERT( NULL != (V)->VcbLockThread);                                                \
    (V)->VcbLockThread = NULL;                                                          \
    ExReleaseFastMutex( &(V)->VcbMutex )

#define CdLockFcb(IC,F) {                                                               \
    PVOID _CurrentThread = PsGetCurrentThread();                                        \
    if (_CurrentThread != (F)->FcbLockThread) {                                         \
        ExAcquireFastMutex( &(F)->FcbNonpaged->FcbMutex );                              \
        ASSERT( (F)->FcbLockCount == 0 );                                               \
        (F)->FcbLockThread = _CurrentThread;                                            \
    }                                                                                   \
    (F)->FcbLockCount += 1;                                                             \
}

#define CdUnlockFcb(IC,F) {                                                             \
    (F)->FcbLockCount -= 1;                                                             \
    if ((F)->FcbLockCount == 0) {                                                       \
        (F)->FcbLockThread = NULL;                                                      \
        ExReleaseFastMutex( &(F)->FcbNonpaged->FcbMutex );                              \
    }                                                                                   \
}

BOOLEAN
CdNoopAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
CdNoopRelease (
    IN PVOID Fcb
    );

BOOLEAN
CdAcquireForCache (
    IN PFCB Fcb,
    IN BOOLEAN Wait
    );

VOID
CdReleaseFromCache (
    IN PFCB Fcb
    );

VOID
CdAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
CdReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    );


//
//  In-memory structure support routines.  Implemented in StrucSup.c
//

VOID
CdInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PCDROM_TOC CdromToc,
    IN ULONG TocLength,
    IN ULONG TocTrackCount,
    IN ULONG TocDiskFlags,
    IN ULONG BlockFactor,
    IN ULONG MediaChangeCount
    );

VOID
CdUpdateVcbFromVolDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PCHAR RawIsoVd OPTIONAL
    );

VOID
CdDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    );

PFCB
CdCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_ID FileId,
    IN NODE_TYPE_CODE NodeTypeCode,
    OUT PBOOLEAN FcbExisted OPTIONAL
    );

VOID
CdInitializeFcbFromPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PPATH_ENTRY PathEntry
    );

VOID
CdInitializeFcbFromFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PFILE_ENUM_CONTEXT FileContext
    );

PCCB
CdCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Flags
    );

VOID
CdDeleteCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    );

BOOLEAN
CdCreateFileLock (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN BOOLEAN RaiseOnError
    );

VOID
CdDeleteFileLock (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_LOCK FileLock
    );

PIRP_CONTEXT
CdCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

VOID
CdCleanupIrpContext (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Post
    );

VOID
CdInitializeStackIrpContext (
    OUT PIRP_CONTEXT IrpContext,
    IN PIRP_CONTEXT_LITE IrpContextLite
    );

//
//  PIRP_CONTEXT_LITE
//  CdCreateIrpContextLite (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdFreeIrpContextLite (
//      IN PIRP_CONTEXT_LITE IrpContextLite
//      );
//

#define CdCreateIrpContextLite(IC)  \
    ExAllocatePoolWithTag( CdNonPagedPool, sizeof( IRP_CONTEXT_LITE ), TAG_IRP_CONTEXT_LITE )

#define CdFreeIrpContextLite(ICL)  \
    ExFreePool( ICL )

VOID
CdTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB StartingFcb,
    OUT PBOOLEAN RemovedStartingFcb
    );

//
//  VOID
//  CdIncrementCleanupCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdDecrementCleanupCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdIncrementReferenceCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ULONG ReferenceCount
//      IN ULONG UserReferenceCount
//      );
//
//  VOID
//  CdDecrementReferenceCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ULONG ReferenceCount
//      IN ULONG UserReferenceCount
//      );
//
//  VOID
//  CdIncrementFcbReference (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdDecrementFcbReference (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define CdIncrementCleanupCounts(IC,F) {        \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbCleanup += 1;                       \
    (F)->Vcb->VcbCleanup += 1;                  \
}

#define CdDecrementCleanupCounts(IC,F) {        \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbCleanup -= 1;                       \
    (F)->Vcb->VcbCleanup -= 1;                  \
}

#define CdIncrementReferenceCounts(IC,F,C,UC) { \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbReference += (C);                   \
    (F)->FcbUserReference += (UC);              \
    (F)->Vcb->VcbReference += (C);              \
    (F)->Vcb->VcbUserReference += (UC);         \
}

#define CdDecrementReferenceCounts(IC,F,C,UC) { \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbReference -= (C);                   \
    (F)->FcbUserReference -= (UC);              \
    (F)->Vcb->VcbReference -= (C);              \
    (F)->Vcb->VcbUserReference -= (UC);         \
}

//
//  PCD_IO_CONTEXT
//  CdAllocateIoContext (
//      );
//
//  VOID
//  CdFreeIoContext (
//      PCD_IO_CONTEXT IoContext
//      );
//

#define CdAllocateIoContext()                           \
    FsRtlAllocatePoolWithTag( CdNonPagedPool,           \
                              sizeof( CD_IO_CONTEXT ),  \
                              TAG_IO_CONTEXT )

#define CdFreeIoContext(IO)     ExFreePool( IO )

PFCB
CdLookupFcbTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_ID FileId
    );

PFCB
CdGetNextFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID *RestartKey
    );

NTSTATUS
CdProcessToc (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PCDROM_TOC CdromToc,
    IN OUT PULONG Length,
    OUT PULONG TrackCount,
    OUT PULONG DiskFlags
    );

//
//  For debugging purposes we sometimes want to allocate our structures from nonpaged
//  pool so that in the kernel debugger we can walk all the structures.
//

#define CdPagedPool                 PagedPool
#define CdNonPagedPool              NonPagedPool
#define CdNonPagedPoolCacheAligned  NonPagedPoolCacheAligned


//
//  Verification support routines.  Contained in verfysup.c
//

NTSTATUS
CdPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceToVerify
    );

BOOLEAN
CdCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB,
    IN BOOLEAN Force
    );

VOID
CdVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
CdVerifyFcbOperation (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    );

BOOLEAN
CdDismountVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

//
//  Macros to abstract device verify flag changes.
//

#define CdUpdateMediaChangeCount( V, C)  (V)->MediaChangeCount = (C)
#define CdUpdateVcbCondition( V, C)      (V)->VcbCondition = (C)

#define CdMarkRealDevForVerify( DO)  SetFlag( (DO)->Flags, DO_VERIFY_VOLUME)
#define CdMarkRealDevVerifyOk( DO)   ClearFlag( (DO)->Flags, DO_VERIFY_VOLUME)

#define CdRealDevNeedsVerify( DO)    BooleanFlagOn( (DO)->Flags, DO_VERIFY_VOLUME)

//
//  BOOLEAN
//  CdIsRawDevice (
//      IN PIRP_CONTEXT IrpContext,
//      IN NTSTATUS Status
//      );
//

#define CdIsRawDevice(IC,S) (           \
    ((S) == STATUS_DEVICE_NOT_READY) || \
    ((S) == STATUS_NO_MEDIA_IN_DEVICE)  \
)


//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

NTSTATUS
CdFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
CdPrePostIrp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
CdOplockComplete (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  Miscellaneous support routines
//

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (    \
//    (BOOLEAN)(((F) & (SF)) != 0) \
//)
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

//
//      CAST
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          IN (CAST)
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define Add2Ptr(PTR,INC,CAST) ((CAST)((PUCHAR)(PTR) + (INC)))

#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG_PTR)(OFFSET) - (ULONG_PTR)(BASE)))

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  The following macros round up and down to sector boundaries.
//

#define SectorAlign(L) (                                                \
    ((((ULONG)(L)) + (SECTOR_SIZE - 1)) & ~(SECTOR_SIZE - 1))           \
)

#define LlSectorAlign(L) (                                              \
    ((((LONGLONG)(L)) + (SECTOR_SIZE - 1)) & ~(SECTOR_SIZE - 1))        \
)

#define SectorTruncate(L) (                                             \
    ((ULONG)(L)) & ~(SECTOR_SIZE - 1)                                   \
)

#define LlSectorTruncate(L) (                                           \
    ((LONGLONG)(L)) & ~(SECTOR_SIZE - 1)                                \
)

#define BytesFromSectors(L) (                                           \
    ((ULONG) (L)) << SECTOR_SHIFT                                       \
)

#define SectorsFromBytes(L) (                                           \
    ((ULONG) (L)) >> SECTOR_SHIFT                                       \
)

#define LlBytesFromSectors(L) (                                         \
    Int64ShllMod32( (LONGLONG)(L), SECTOR_SHIFT )                       \
)

#define LlSectorsFromBytes(L) (                                         \
    Int64ShraMod32( (LONGLONG)(L), SECTOR_SHIFT )                       \
)

#define SectorOffset(L) (                                               \
    ((ULONG)(ULONG_PTR) (L)) & SECTOR_MASK                              \
)

#define SectorBlockOffset(V,LB) (                                       \
    ((ULONG) (LB)) & ((V)->BlocksPerSector - 1)                         \
)

#define BytesFromBlocks(V,B) (                                          \
    (ULONG) (B) << (V)->BlockToByteShift                                \
)

#define LlBytesFromBlocks(V,B) (                                        \
    Int64ShllMod32( (LONGLONG) (B), (V)->BlockToByteShift )             \
)

#define BlockAlign(V,L) (                                               \
    ((ULONG)(L) + (V)->BlockMask) & (V)->BlockInverseMask               \
)

//
//  Carefully make sure the mask is sign extended to 64bits
//

#define LlBlockAlign(V,L) (                                                     \
    ((LONGLONG)(L) + (V)->BlockMask) & (LONGLONG)((LONG)(V)->BlockInverseMask)  \
)

#define BlockOffset(V,L) (                                              \
    ((ULONG) (L)) & (V)->BlockMask                                      \
)

#define RawSectorAlign( B) ((((B)+(RAW_SECTOR_SIZE - 1)) / RAW_SECTOR_SIZE) * RAW_SECTOR_SIZE)

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

typedef union _USHORT2 {
    USHORT Ushort[2];
    ULONG  ForceAlignment;
} USHORT2, *PUSHORT2;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                           \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src));  \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                           \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src));  \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                           \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src));  \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//  accessing the source on a word boundary.
//

#define CopyUshort2(Dst,Src) {                          \
    *((USHORT2 *)(Dst)) = *((UNALIGNED USHORT2 *)(Src));\
    }


//
//  Following routines handle entry in and out of the filesystem.  They are
//  contained in CdData.c
//

NTSTATUS
CdFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

LONG
CdExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
CdProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

VOID
CdCompleteRequest (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    );

//
//  VOID
//  CdRaiseStatus (
//      IN PRIP_CONTEXT IrpContext,
//      IN NT_STATUS Status
//      );
//
//  VOID
//  CdNormalAndRaiseStatus (
//      IN PRIP_CONTEXT IrpContext,
//      IN NT_STATUS Status
//      );
//

#if 0
#define AssertVerifyDevice(C, S)                                                    \
    ASSERT( (C) == NULL ||                                                          \
            FlagOn( (C)->Flags, IRP_CONTEXT_FLAG_IN_FSP ) ||                        \
            !((S) == STATUS_VERIFY_REQUIRED &&                                      \
              IoGetDeviceToVerify( PsGetCurrentThread() ) == NULL ));

#define AssertVerifyDeviceIrp(I)                                                    \
    ASSERT( (I) == NULL ||                                                          \
            !(((I)->IoStatus.Status) == STATUS_VERIFY_REQUIRED &&                   \
              ((I)->Tail.Overlay.Thread == NULL ||                                  \
                IoGetDeviceToVerify( (I)->Tail.Overlay.Thread ) == NULL )));
#else
#define AssertVerifyDevice(C, S)
#define AssertVerifyDeviceIrp(I)
#endif

#define CdRaiseStatus(IC,S) {                               \
    AssertVerifyDevice(IC, S);                              \
    (IC)->ExceptionStatus = (S);                            \
    DebugBreakOnStatus( S );                                \
    ExRaiseStatus( (S) );                                   \
}

#define CdNormalizeAndRaiseStatus(IC,S) {                                           \
    AssertVerifyDevice(IC, S);                                                      \
    (IC)->ExceptionStatus = FsRtlNormalizeNtstatus((S),STATUS_UNEXPECTED_IO_ERROR); \
    ExRaiseStatus( (IC)->ExceptionStatus );                                         \
}

//
//  Following are the fast entry points.
//

BOOLEAN
CdFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastQueryNetworkInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  Following are the routines to handle the top level thread logic.
//

VOID
CdSetThreadContext (
    IN PIRP_CONTEXT IrpContext,
    IN PTHREAD_CONTEXT ThreadContext
    );

//
//  VOID
//  CdRestoreThreadContext (
//      IN PIRP_CONTEXT IrpContext
//      );
//

#define CdRestoreThreadContext(IC)                              \
    (IC)->ThreadContext->Cdfs = 0;                              \
    IoSetTopLevelIrp( (IC)->ThreadContext->SavedTopLevelIrp );  \
    (IC)->ThreadContext = NULL

ULONG
CdSerial32 (
    IN PCHAR Buffer,
    IN ULONG ByteCount
    );

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(I)   IoIsOperationSynchronous(I)

//
//  The following macro is used to set the fast i/o possible bits in the
//  FsRtl header.
//
//      FastIoIsNotPossible - If the Fcb is bad or there are oplocks on the file.
//
//      FastIoIsQuestionable - If there are file locks.
//
//      FastIoIsPossible - In all other cases.
//
//

#define CdIsFastIoPossible(F) ((BOOLEAN)                                            \
    ((((F)->Vcb->VcbCondition != VcbMounted ) ||                                    \
      !FsRtlOplockIsFastIoPossible( &(F)->Oplock )) ?                               \
                                                                                    \
     FastIoIsNotPossible :                                                          \
                                                                                    \
     ((((F)->FileLock != NULL) && FsRtlAreThereCurrentFileLocks( (F)->FileLock )) ? \
                                                                                    \
        FastIoIsQuestionable :                                                      \
                                                                                    \
        FastIoIsPossible))                                                          \
)


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
CdFspDispatch (                             //  implemented in FspDisp.c
    IN PIRP_CONTEXT IrpContext
    );

VOID
CdFspClose (                                //  implemented in Close.c
    IN PVCB Vcb OPTIONAL
    );

//
//  The following routines are the entry points for the different operations
//  based on the IrpSp major functions.
//

NTSTATUS
CdCommonCreate (                            //  Implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonClose (                             //  Implemented in Close.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonRead (                              //  Implemented in Read.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonQueryInfo (                         //  Implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonSetInfo (                           //  Implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonQueryVolInfo (                      //  Implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonDirControl (                        //  Implemented in DirCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonFsControl (                         //  Implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonDevControl (                        //  Implemented in DevCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonLockControl (                       //  Implemented in LockCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonCleanup (                           //  Implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonPnp (                               //  Implemented in Pnp.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }
#define try_leave(S) { S; leave; }

#endif // _CDPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\cddata.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdData.c

Abstract:

    This module declares the global data used by the Cdfs file system.

    This module also handles the dispath routines in the Fsd threads as well as
    handling the IrpContext and Irp through the exception path.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

#ifdef CD_SANITY
BOOLEAN CdTestTopLevel = TRUE;
BOOLEAN CdTestRaisedStatus = TRUE;
#endif

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CDDATA)

//
//  Global data structures
//

CD_DATA CdData;
FAST_IO_DISPATCH CdFastIoDispatch;

//
//  Reserved directory strings.
//

WCHAR CdUnicodeSelfArray[] = { L'.' };
WCHAR CdUnicodeParentArray[] = { L'.', L'.' };

UNICODE_STRING CdUnicodeDirectoryNames[] = {
    { 2, 2, CdUnicodeSelfArray},
    { 4, 4, CdUnicodeParentArray}
};

//
//  Volume descriptor identifier strings.
//

CHAR CdHsgId[] = { 'C', 'D', 'R', 'O', 'M' };
CHAR CdIsoId[] = { 'C', 'D', '0', '0', '1' };
CHAR CdXaId[] = { 'C', 'D', '-', 'X', 'A', '0', '0', '1' };

//
//  Volume label for audio disks.
//

WCHAR CdAudioLabel[] = { L'A', L'u', L'd', L'i', L'o', L' ', L'C', L'D' };
USHORT CdAudioLabelLength = sizeof( CdAudioLabel );

//
//  Pseudo file names for audio disks.
//

CHAR CdAudioFileName[] = { 'T', 'r', 'a', 'c', 'k', '0', '0', '.', 'c', 'd', 'a' };
UCHAR CdAudioFileNameLength = sizeof( CdAudioFileName );
ULONG CdAudioDirentSize = FIELD_OFFSET( RAW_DIRENT, FileId ) + sizeof( CdAudioFileName ) + sizeof( SYSTEM_USE_XA );
ULONG CdAudioDirentsPerSector = SECTOR_SIZE / (FIELD_OFFSET( RAW_DIRENT, FileId ) + sizeof( CdAudioFileName ) + sizeof( SYSTEM_USE_XA ));
ULONG CdAudioSystemUseOffset = FIELD_OFFSET( RAW_DIRENT, FileId ) + sizeof( CdAudioFileName );

//
//  Escape sequences for mounting Unicode volumes.
//

PCHAR CdJolietEscape[] = { "%/@", "%/C", "%/E" };

//
//  Audio Play Files consist completely of this header block.  These
//  files are readable in the root of any audio disc regardless of
//  the capabilities of the drive.
//
//  The "Unique Disk ID Number" is a calculated value consisting of
//  a combination of parameters, including the number of tracks and
//  the starting locations of those tracks.
//
//  Applications interpreting CDDA RIFF files should be advised that
//  additional RIFF file chunks may be added to this header in the
//  future in order to add information, such as the disk and song title.
//

LONG CdAudioPlayHeader[] = {
    0x46464952,                         // Chunk ID = 'RIFF'
    4 * 11 - 8,                         // Chunk Size = (file size - 8)
    0x41444443,                         // 'CDDA'
    0x20746d66,                         // 'fmt '
    24,                                 // Chunk Size (of 'fmt ' subchunk) = 24
    0x00000001,                         // WORD Format Tag, WORD Track Number
    0x00000000,                         // DWORD Unique Disk ID Number
    0x00000000,                         // DWORD Track Starting Sector (LBN)
    0x00000000,                         // DWORD Track Length (LBN count)
    0x00000000,                         // DWORD Track Starting Sector (MSF)
    0x00000000                          // DWORD Track Length (MSF)
};

//  Audio Philes begin with this header block to identify the data as a
//  PCM waveform.  AudioPhileHeader is coded as if it has no data included
//  in the waveform.  Data must be added in 2352-byte multiples.
//
//  Fields marked 'ADJUST' need to be adjusted based on the size of the
//  data: Add (nSectors*2352) to the DWORDs at offsets 1*4 and 10*4.
//
//  File Size of TRACK??.WAV = nSectors*2352 + sizeof(AudioPhileHeader)
//  RIFF('WAVE' fmt(1, 2, 44100, 176400, 16, 4) data( <CD Audio Raw Data> )
//
//  The number of sectors in a CD-XA CD-DA file is (DataLen/2048).
//  CDFS will expose these files to applications as if they were just
//  'WAVE' files, adjusting the file size so that the RIFF file is valid.
//
//  NT NOTE: We do not do any fidelity adjustment. These are presented as raw
//  2352 byte sectors - 95 has the glimmer of an idea to allow CDFS to expose
//  the CDXA CDDA data at different sampling rates in a virtual directory
//  structure, but we will never do that.
//

LONG CdXAAudioPhileHeader[] = {
    0x46464952,                         // Chunk ID = 'RIFF'
    -8,                                 // Chunk Size = (file size - 8) ADJUST1
    0x45564157,                         // 'WAVE'
    0x20746d66,                         // 'fmt '
    16,                                 // Chunk Size (of 'fmt ' subchunk) = 16
    0x00020001,                         // WORD Format Tag WORD nChannels
    44100,                              // DWORD nSamplesPerSecond
    2352 * 75,                          // DWORD nAvgBytesPerSec
    0x00100004,                         // WORD nBlockAlign WORD nBitsPerSample
    0x61746164,                         // 'data'
    -44                                 // <CD Audio Raw Data>          ADJUST2
};

//
//  XA Files begin with this RIFF header block to identify the data as
//  raw CD-XA sectors.  Data must be added in 2352-byte multiples.
//
//  This header is added to all CD-XA files which are marked as having
//  mode2form2 sectors.
//
//  Fields marked 'ADJUST' need to be adjusted based on the size of the
//  data: Add file size to the marked DWORDS.
//
//  File Size of TRACK??.WAV = nSectors*2352 + sizeof(XAFileHeader)
//
//  RIFF('CDXA' FMT(Owner, Attr, 'X', 'A', FileNum, 0) data ( <CDXA Raw Data> )
//

LONG CdXAFileHeader[] = {
    0x46464952,                         // Chunk ID = 'RIFF'
    -8,                                 // Chunk Size = (file size - 8) ADJUST
    0x41584443,                         // 'CDXA'
    0x20746d66,                         // 'fmt '
    16,                                 // Chunk Size (of CDXA chunk) = 16
    0,                                  // DWORD Owner ID
    0x41580000,                         // WORD Attributes
                                        // BYTE Signature byte 1 'X'
                                        // BYTE Signature byte 2 'A'
    0,                                  // BYTE File Number
    0,                                  // BYTE Reserved[7]
    0x61746164,                         // 'data'
    -44                                 // <CD-XA Raw Sectors>          ADJUST
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdFastIoCheckIfPossible)
#pragma alloc_text(PAGE, CdSerial32)
#endif


NTSTATUS
CdFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry to all of the Fsd dispatch points.

    Conceptually the Io routine will call this routine on all requests
    to the file system.  We case on the type of request and invoke the
    correct handler for this type of request.  There is an exception filter
    to catch any exceptions in the CDFS code as well as the CDFS process
    exception routine.

    This routine allocates and initializes the IrpContext for this request as
    well as updating the top-level thread context as necessary.  We may loop
    in this routine if we need to retry the request for any reason.  The
    status code STATUS_CANT_WAIT is used to indicate this.  Suppose the disk
    in the drive has changed.  An Fsd request will proceed normally until it
    recognizes this condition.  STATUS_VERIFY_REQUIRED is raised at that point
    and the exception code will handle the verify and either return
    STATUS_CANT_WAIT or STATUS_PENDING depending on whether the request was
    posted.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    THREAD_CONTEXT ThreadContext;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN Wait;

#ifdef CD_SANITY
    PVOID PreviousTopLevel;
#endif

    NTSTATUS Status;

    KIRQL SaveIrql = KeGetCurrentIrql();

    ASSERT_OPTIONAL_IRP( Irp );

    FsRtlEnterFileSystem();

#ifdef CD_SANITY
    PreviousTopLevel = IoGetTopLevelIrp();
#endif

    //
    //  Loop until this request has been completed or posted.
    //

    do {

        //
        //  Use a try-except to handle the exception cases.
        //

        try {

            //
            //  If the IrpContext is NULL then this is the first pass through
            //  this loop.
            //

            if (IrpContext == NULL) {

                //
                //  Decide if this request is waitable an allocate the IrpContext.
                //  If the file object in the stack location is NULL then this
                //  is a mount which is always waitable.  Otherwise we look at
                //  the file object flags.
                //

                if (IoGetCurrentIrpStackLocation( Irp )->FileObject == NULL) {

                    Wait = TRUE;

                } else {

                    Wait = CanFsdWait( Irp );
                }

                IrpContext = CdCreateIrpContext( Irp, Wait );

                //
                //  Update the thread context information.
                //

                CdSetThreadContext( IrpContext, &ThreadContext );

#ifdef CD_SANITY
                ASSERT( !CdTestTopLevel ||
                        SafeNodeType( IrpContext->TopLevel ) == CDFS_NTC_IRP_CONTEXT );
#endif

            //
            //  Otherwise cleanup the IrpContext for the retry.
            //

            } else {

                //
                //  Set the MORE_PROCESSING flag to make sure the IrpContext
                //  isn't inadvertently deleted here.  Then cleanup the
                //  IrpContext to perform the retry.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
                CdCleanupIrpContext( IrpContext, FALSE );
            }

            //
            //  Case on the major irp code.
            //

            switch (IrpContext->MajorFunction) {

            case IRP_MJ_CREATE :

                Status = CdCommonCreate( IrpContext, Irp );
                break;

            case IRP_MJ_CLOSE :

                Status = CdCommonClose( IrpContext, Irp );
                break;

            case IRP_MJ_READ :

                //
                //  If this is an Mdl complete request, don't go through
                //  common read.
                //

                if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                    Status = CdCompleteMdl( IrpContext, Irp );

                } else {

                    Status = CdCommonRead( IrpContext, Irp );
                }

                break;

            case IRP_MJ_QUERY_INFORMATION :

                Status = CdCommonQueryInfo( IrpContext, Irp );
                break;

            case IRP_MJ_SET_INFORMATION :

                Status = CdCommonSetInfo( IrpContext, Irp );
                break;

            case IRP_MJ_QUERY_VOLUME_INFORMATION :

                Status = CdCommonQueryVolInfo( IrpContext, Irp );
                break;

            case IRP_MJ_DIRECTORY_CONTROL :

                Status = CdCommonDirControl( IrpContext, Irp );
                break;

            case IRP_MJ_FILE_SYSTEM_CONTROL :

                Status = CdCommonFsControl( IrpContext, Irp );
                break;

            case IRP_MJ_DEVICE_CONTROL :

                Status = CdCommonDevControl( IrpContext, Irp );
                break;

            case IRP_MJ_LOCK_CONTROL :

                Status = CdCommonLockControl( IrpContext, Irp );
                break;

            case IRP_MJ_CLEANUP :

                Status = CdCommonCleanup( IrpContext, Irp );
                break;

            case IRP_MJ_PNP :

                Status = CdCommonPnp( IrpContext, Irp );
                break;

            default :

                Status = STATUS_INVALID_DEVICE_REQUEST;
                CdCompleteRequest( IrpContext, Irp, Status );
            }

        } except( CdExceptionFilter( IrpContext, GetExceptionInformation() )) {

            Status = CdProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT);

#ifdef CD_SANITY
    ASSERT( !CdTestTopLevel ||
            (PreviousTopLevel == IoGetTopLevelIrp()) );
#endif

    FsRtlExitFileSystem();

    ASSERT( SaveIrql == KeGetCurrentIrql( ));

    return Status;
}


LONG
CdExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide whether we will handle a raised exception
    status.  If CDFS explicitly raised an error then this status is already
    in the IrpContext.  We choose which is the correct status code and
    either indicate that we will handle the exception or bug-check the system.

Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;
    BOOLEAN TestStatus = TRUE;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );

    ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    //
    // If the exception is STATUS_IN_PAGE_ERROR, get the I/O error code
    // from the exception record.
    //

    if ((ExceptionCode == STATUS_IN_PAGE_ERROR) &&
        (ExceptionPointer->ExceptionRecord->NumberParameters >= 3)) {

        ExceptionCode =
            (NTSTATUS)ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
    }

    //
    //  If there is an Irp context then check which status code to use.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        if (IrpContext->ExceptionStatus == STATUS_SUCCESS) {

            //
            //  Store the real status into the IrpContext.
            //

            IrpContext->ExceptionStatus = ExceptionCode;

        } else {

            //
            //  No need to test the status code if we raised it ourselves.
            //

            TestStatus = FALSE;
        }
    }

    AssertVerifyDevice( IrpContext, IrpContext->ExceptionStatus );
    
    //
    //  Bug check if this status is not supported.
    //

    if (TestStatus && !FsRtlIsNtstatusExpected( ExceptionCode )) {

        CdBugCheck( (ULONG_PTR) ExceptionPointer->ExceptionRecord,
                    (ULONG_PTR) ExceptionPointer->ContextRecord,
                    (ULONG_PTR) ExceptionPointer->ExceptionRecord->ExceptionAddress );

    }

    return EXCEPTION_EXECUTE_HANDLER;
}


NTSTATUS
CdProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine processes an exception.  It either completes the request
    with the exception status in the IrpContext, sends this off to the Fsp
    workque or causes it to be retried in the current thread if a verification
    is needed.

    If the volume needs to be verified (STATUS_VERIFY_REQUIRED) and we can
    do the work in the current thread we will translate the status code
    to STATUS_CANT_WAIT to indicate that we need to retry the request.

Arguments:

    Irp - Supplies the Irp being processed

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    NTSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PDEVICE_OBJECT Device;
    PVPB Vpb;
    PETHREAD Thread;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    
    //
    //  If there is not an irp context, then complete the request with the
    //  current status code.
    //

    if (!ARGUMENT_PRESENT( IrpContext )) {

        CdCompleteRequest( NULL, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Get the real exception status from the IrpContext.
    //

    ExceptionCode = IrpContext->ExceptionStatus;

    //
    //  If we are not a top level request then we just complete the request
    //  with the current status code.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL )) {

        CdCompleteRequest( IrpContext, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Check if we are posting this request.  One of the following must be true
    //  if we are to post a request.
    //
    //      - Status code is STATUS_CANT_WAIT and the request is asynchronous
    //          or we are forcing this to be posted.
    //
    //      - Status code is STATUS_VERIFY_REQUIRED and we are at APC level
    //          or higher.  Can't wait for IO in the verify path in this case.
    //
    //  Set the MORE_PROCESSING flag in the IrpContext to keep if from being
    //  deleted if this is a retryable condition.
    //
    //
    //  Note that (children of) CdFsdPostRequest can raise (Mdl allocation).
    //

    try {
    
        if (ExceptionCode == STATUS_CANT_WAIT) {

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST )) {

                ExceptionCode = CdFsdPostRequest( IrpContext, Irp );
            }

        } else if (ExceptionCode == STATUS_VERIFY_REQUIRED) {

            if (KeGetCurrentIrql() >= APC_LEVEL) {

                ExceptionCode = CdFsdPostRequest( IrpContext, Irp );
            }
        }
    }
    except( CdExceptionFilter( IrpContext, GetExceptionInformation() ))  {
    
        ExceptionCode = GetExceptionCode();        
    }
    
    //
    //  If we posted the request or our caller will retry then just return here.
    //

    if ((ExceptionCode == STATUS_PENDING) ||
        (ExceptionCode == STATUS_CANT_WAIT)) {

        return ExceptionCode;
    }

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );

    //
    //  Store this error into the Irp for posting back to the Io system.
    //

    Irp->IoStatus.Status = ExceptionCode;

    if (IoIsErrorUserInduced( ExceptionCode )) {

        //
        //  Check for the various error conditions that can be caused by,
        //  and possibly resolved my the user.
        //

        if (ExceptionCode == STATUS_VERIFY_REQUIRED) {

            //
            //  Now we are at the top level file system entry point.
            //
            //  If we have already posted this request then the device to
            //  verify is in the original thread.  Find this via the Irp.
            //

            Device = IoGetDeviceToVerify( Irp->Tail.Overlay.Thread );
            IoSetDeviceToVerify( Irp->Tail.Overlay.Thread, NULL );
            
            //
            //  If there is no device in that location then check in the
            //  current thread.
            //

            if (Device == NULL) {

                Device = IoGetDeviceToVerify( PsGetCurrentThread() );
                IoSetDeviceToVerify( PsGetCurrentThread(), NULL );

                ASSERT( Device != NULL );

                //
                //  Let's not BugCheck just because the driver messes up.
                //

                if (Device == NULL) {

                    ExceptionCode = STATUS_DRIVER_INTERNAL_ERROR;

                    CdCompleteRequest( IrpContext, Irp, ExceptionCode );

                    return ExceptionCode;
                }
            }

            //
            //  CdPerformVerify() will do the right thing with the Irp.
            //  If we return STATUS_CANT_WAIT then the current thread
            //  can retry the request.
            //

            return CdPerformVerify( IrpContext, Irp, Device );
        }

        //
        //  The other user induced conditions generate an error unless
        //  they have been disabled for this request.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS )) {

            CdCompleteRequest( IrpContext, Irp, ExceptionCode );

            return ExceptionCode;

        } 
        //
        //  Generate a pop-up.
        //
        else {

            if (IoGetCurrentIrpStackLocation( Irp )->FileObject != NULL) {

                Vpb = IoGetCurrentIrpStackLocation( Irp )->FileObject->Vpb;

            } else {

                Vpb = NULL;
            }

            //
            //  The device to verify is either in my thread local storage
            //  or that of the thread that owns the Irp.
            //

            Thread = Irp->Tail.Overlay.Thread;
            Device = IoGetDeviceToVerify( Thread );

            if (Device == NULL) {

                Thread = PsGetCurrentThread();
                Device = IoGetDeviceToVerify( Thread );

                ASSERT( Device != NULL );

                //
                //  Let's not BugCheck just because the driver messes up.
                //

                if (Device == NULL) {

                    CdCompleteRequest( IrpContext, Irp, ExceptionCode );

                    return ExceptionCode;
                }
            }

            //
            //  This routine actually causes the pop-up.  It usually
            //  does this by queuing an APC to the callers thread,
            //  but in some cases it will complete the request immediately,
            //  so it is very important to IoMarkIrpPending() first.
            //

            IoMarkIrpPending( Irp );
            IoRaiseHardError( Irp, Vpb, Device );

            //
            //  We will be handing control back to the caller here, so
            //  reset the saved device object.
            //

            IoSetDeviceToVerify( Thread, NULL );

            //
            //  The Irp will be completed by Io or resubmitted.  In either
            //  case we must clean up the IrpContext here.
            //

            CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
            return STATUS_PENDING;
        }
    }

    //
    //  This is just a run of the mill error.
    //

    CdCompleteRequest( IrpContext, Irp, ExceptionCode );

    return ExceptionCode;
}


VOID
CdCompleteRequest (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine completes a Irp and cleans up the IrpContext.  Either or
    both of these may not be specified.

Arguments:

    Irp - Supplies the Irp being processed.

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_OPTIONAL_IRP( Irp );

    //
    //  Cleanup the IrpContext if passed in here.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        CdCleanupIrpContext( IrpContext, FALSE );
    }

    //
    //  If we have an Irp then complete the irp.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        //
        //  Clear the information field in case we have used this Irp
        //  internally.
        //

        if (NT_ERROR( Status ) &&
            FlagOn( Irp->Flags, IRP_INPUT_OPERATION )) {

            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;

        AssertVerifyDeviceIrp( Irp );
        
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
    }

    return;
}


VOID
CdSetThreadContext (
    IN PIRP_CONTEXT IrpContext,
    IN PTHREAD_CONTEXT ThreadContext
    )

/*++

Routine Description:

    This routine is called at each Fsd/Fsp entry point set up the IrpContext
    and thread local storage to track top level requests.  If there is
    not a Cdfs context in the thread local storage then we use the input one.
    Otherwise we use the one already there.  This routine also updates the
    IrpContext based on the state of the top-level context.

    If the TOP_LEVEL flag in the IrpContext is already set when we are called
    then we force this request to appear top level.

Arguments:

    ThreadContext - Address on stack for local storage if not already present.

    ForceTopLevel - We force this request to appear top level regardless of
        any previous stack value.

Return Value:

    None

--*/

{
    PTHREAD_CONTEXT CurrentThreadContext;
    ULONG_PTR StackTop;
    ULONG_PTR StackBottom;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Get the current top-level irp out of the thread storage.
    //  If NULL then this is the top-level request.
    //

    CurrentThreadContext = (PTHREAD_CONTEXT) IoGetTopLevelIrp();

    if (CurrentThreadContext == NULL) {

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL );
    }

    //
    //  Initialize the input context unless we are using the current
    //  thread context block.  We use the new block if our caller
    //  specified this or the existing block is invalid.
    //
    //  The following must be true for the current to be a valid Cdfs context.
    //
    //      Structure must lie within current stack.
    //      Address must be ULONG aligned.
    //      Cdfs signature must be present.
    //
    //  If this is not a valid Cdfs context then use the input thread
    //  context and store it in the top level context.
    //

    IoGetStackLimits( &StackTop, &StackBottom);

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL ) ||
        (((ULONG_PTR) CurrentThreadContext > StackBottom - sizeof( THREAD_CONTEXT )) ||
         ((ULONG_PTR) CurrentThreadContext <= StackTop) ||
         FlagOn( (ULONG_PTR) CurrentThreadContext, 0x3 ) ||
         (CurrentThreadContext->Cdfs != 0x53464443))) {

        ThreadContext->Cdfs = 0x53464443;
        ThreadContext->SavedTopLevelIrp = (PIRP) CurrentThreadContext;
        ThreadContext->TopLevelIrpContext = IrpContext;
        IoSetTopLevelIrp( (PIRP) ThreadContext );

        IrpContext->TopLevel = IrpContext;
        IrpContext->ThreadContext = ThreadContext;

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS );

    //
    //  Otherwise use the IrpContext in the thread context.
    //

    } else {

        IrpContext->TopLevel = CurrentThreadContext->TopLevelIrpContext;
    }

    return;
}


BOOLEAN
CdFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route.

--*/

{
    PFCB Fcb;
    TYPE_OF_OPEN TypeOfOpen;
    LARGE_INTEGER LargeLength;

    PAGED_CODE();

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if ((TypeOfOpen != UserFileOpen) || !CheckForReadOperation) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    LargeLength.QuadPart = Length;

    //
    //  Check whether the file locks will allow for fast io.
    //

    if ((Fcb->FileLock == NULL) ||
        FsRtlFastCheckLockForRead( Fcb->FileLock,
                                   FileOffset,
                                   &LargeLength,
                                   LockKey,
                                   FileObject,
                                   PsGetCurrentProcess() )) {

        return TRUE;
    }

    return FALSE;
}


ULONG
CdSerial32 (
    IN PCHAR Buffer,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine is called to generate a 32 bit serial number.  This is
    done by doing four separate checksums into an array of bytes and
    then treating the bytes as a ULONG.

Arguments:

    Buffer - Pointer to the buffer to generate the ID for.

    ByteCount - Number of bytes in the buffer.

Return Value:

    ULONG - The 32 bit serial number.

--*/

{
    union {
        UCHAR   Bytes[4];
        ULONG   SerialId;
    } Checksum;

    PAGED_CODE();

    //
    //  Initialize the serial number.
    //

    Checksum.SerialId = 0;

    //
    //  Continue while there are more bytes to use.
    //

    while (ByteCount--) {

        //
        //  Increment this sub-checksum.
        //

        Checksum.Bytes[ByteCount & 0x3] += *(Buffer++);
    }

    //
    //  Return the checksums as a ULONG.
    //

    return Checksum.SerialId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\cdinit.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Cdfs

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CDINIT)

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
CdUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CdInitializeGlobalData (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FileSystemDeviceObject
    );

NTSTATUS
CdShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CdUnload)
#pragma alloc_text(PAGE, CdShutdown)
#pragma alloc_text(INIT, CdInitializeGlobalData)
#endif


//
//  Local support routine
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Cdrom file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT CdfsFileSystemDeviceObject;

    //
    // Create the device object.
    //

    RtlInitUnicodeString( &UnicodeString, L"\\Cdfs" );

    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                             0,
                             FALSE,
                             &CdfsFileSystemDeviceObject );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }
    DriverObject->DriverUnload = CdUnload;
    //
    //  Note that because of the way data caching is done, we set neither
    //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    //  data is not in the cache, or the request is not buffered, we may,
    //  set up for Direct I/O by hand.
    //

    //
    //  Initialize the driver object with this driver's entry points.
    //
    //  NOTE - Each entry in the dispatch table must have an entry in
    //  the Fsp/Fsd dispatch switch statements.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                  =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   =
    DriverObject->MajorFunction[IRP_MJ_READ]                    =
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]       =
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]         =
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION]=
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]       =
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]     =
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          =
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL]            =
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 =
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = (PDRIVER_DISPATCH) CdFsdDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                = CdShutdown;

    DriverObject->FastIoDispatch = &CdFastIoDispatch;

    Status = IoRegisterShutdownNotification (CdfsFileSystemDeviceObject);
    if (!NT_SUCCESS (Status)) {
        IoDeleteDevice (CdfsFileSystemDeviceObject);
        return Status;
    }

    //
    //  Initialize the global data structures
    //

    Status = CdInitializeGlobalData( DriverObject, CdfsFileSystemDeviceObject );
    if (!NT_SUCCESS (Status)) {
        IoDeleteDevice (CdfsFileSystemDeviceObject);
        return Status;
    }

    //
    //  Register the file system as low priority with the I/O system.  This will cause
    //  CDFS to receive mount requests after a) other filesystems currently registered
    //  and b) other normal priority filesystems that may be registered later.
    //

    CdfsFileSystemDeviceObject->Flags |= DO_LOW_PRIORITY_FILESYSTEM;

    IoRegisterFileSystem( CdfsFileSystemDeviceObject );
    ObReferenceObject (CdfsFileSystemDeviceObject);

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}

NTSTATUS
CdShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the shutdown handler for CDFS.

Arguments:

    DeviceObject - Supplies the registered device object for CDFS.
    Irp - Shutdown IRP
    

Return Value:

    None.

--*/
{
    IoUnregisterFileSystem (DeviceObject);
    IoDeleteDevice (CdData.FileSystemDeviceObject);

    CdCompleteRequest( NULL, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


VOID
CdUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine unload routine for CDFS.

Arguments:

    DriverObject - Supplies the driver object for CDFS.

Return Value:

    None.

--*/
{
    PIRP_CONTEXT IrpContext;

    //
    // Free any IRP contexts
    //
    while (1) {
        IrpContext = (PIRP_CONTEXT) PopEntryList( &CdData.IrpContextList) ;
        if (IrpContext == NULL) {
            break;
        }
        ExFreePool (IrpContext);
    }

    IoFreeWorkItem (CdData.CloseItem);
    ExDeleteResourceLite( &CdData.DataResource );
    ObDereferenceObject (CdData.FileSystemDeviceObject);
}

//
//  Local support routine
//

NTSTATUS
CdInitializeGlobalData (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FileSystemDeviceObject
    )

/*++

Routine Description:

    This routine initializes the global cdfs data structures.

Arguments:

    DriverObject - Supplies the driver object for CDFS.

    FileSystemDeviceObject - Supplies the device object for CDFS.

Return Value:

    None.

--*/

{
    //
    //  Start by initializing the FastIoDispatch Table.
    //

    RtlZeroMemory( &CdFastIoDispatch, sizeof( FAST_IO_DISPATCH ));

    CdFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);
    CdFastIoDispatch.FastIoCheckIfPossible =   CdFastIoCheckIfPossible;  //  CheckForFastIo
    CdFastIoDispatch.FastIoRead =              FsRtlCopyRead;            //  Read
    CdFastIoDispatch.FastIoQueryBasicInfo =    CdFastQueryBasicInfo;     //  QueryBasicInfo
    CdFastIoDispatch.FastIoQueryStandardInfo = CdFastQueryStdInfo;       //  QueryStandardInfo
    CdFastIoDispatch.FastIoLock =              CdFastLock;               //  Lock
    CdFastIoDispatch.FastIoUnlockSingle =      CdFastUnlockSingle;       //  UnlockSingle
    CdFastIoDispatch.FastIoUnlockAll =         CdFastUnlockAll;          //  UnlockAll
    CdFastIoDispatch.FastIoUnlockAllByKey =    CdFastUnlockAllByKey;     //  UnlockAllByKey
    CdFastIoDispatch.AcquireFileForNtCreateSection =  CdAcquireForCreateSection;
    CdFastIoDispatch.ReleaseFileForNtCreateSection =  CdReleaseForCreateSection;
    CdFastIoDispatch.FastIoQueryNetworkOpenInfo =     CdFastQueryNetworkInfo;   //  QueryNetworkInfo

    //
    //  Initialize the CdData structure.
    //

    RtlZeroMemory( &CdData, sizeof( CD_DATA ));

    CdData.NodeTypeCode = CDFS_NTC_DATA_HEADER;
    CdData.NodeByteSize = sizeof( CD_DATA );

    CdData.DriverObject = DriverObject;
    CdData.FileSystemDeviceObject = FileSystemDeviceObject;

    InitializeListHead( &CdData.VcbQueue );

    ExInitializeResourceLite( &CdData.DataResource );

    //
    //  Initialize the cache manager callback routines
    //

    CdData.CacheManagerCallbacks.AcquireForLazyWrite  = &CdAcquireForCache;
    CdData.CacheManagerCallbacks.ReleaseFromLazyWrite = &CdReleaseFromCache;
    CdData.CacheManagerCallbacks.AcquireForReadAhead  = &CdAcquireForCache;
    CdData.CacheManagerCallbacks.ReleaseFromReadAhead = &CdReleaseFromCache;

    CdData.CacheManagerVolumeCallbacks.AcquireForLazyWrite  = &CdNoopAcquire;
    CdData.CacheManagerVolumeCallbacks.ReleaseFromLazyWrite = &CdNoopRelease;
    CdData.CacheManagerVolumeCallbacks.AcquireForReadAhead  = &CdNoopAcquire;
    CdData.CacheManagerVolumeCallbacks.ReleaseFromReadAhead = &CdNoopRelease;

    //
    //  Initialize the lock mutex and the async and delay close queues.
    //

    ExInitializeFastMutex( &CdData.CdDataMutex );
    InitializeListHead( &CdData.AsyncCloseQueue );
    InitializeListHead( &CdData.DelayedCloseQueue );

    CdData.CloseItem = IoAllocateWorkItem (FileSystemDeviceObject);
    if (CdData.CloseItem == NULL) {
        
        ExDeleteResourceLite( &CdData.DataResource );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    //  Do the initialization based on the system size.
    //

    switch (MmQuerySystemSize()) {

    case MmSmallSystem:

        CdData.IrpContextMaxDepth = 4;
        CdData.MaxDelayedCloseCount = 8;
        CdData.MinDelayedCloseCount = 2;
        break;

    case MmMediumSystem:

        CdData.IrpContextMaxDepth = 8;
        CdData.MaxDelayedCloseCount = 24;
        CdData.MinDelayedCloseCount = 6;
        break;

    case MmLargeSystem:

        CdData.IrpContextMaxDepth = 32;
        CdData.MaxDelayedCloseCount = 72;
        CdData.MinDelayedCloseCount = 18;
        break;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\cdstruc.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Cdfs file system.

    In-Memory structures:

        The global data structures with the CdDataRecord.  It contains a pointer
        to a File System Device object and a queue of Vcb's.  There is a Vcb for
        every currently or previously mounted volumes.  We may be in the process
        of tearing down the Vcb's which have been dismounted.  The Vcb's are
        allocated as an extension to a volume device object.

            +--------+
            | CdData |     +--------+
            |        | --> |FilSysDo|
            |        |     |        |
            |        | <+  +--------+
            +--------+  |
                        |
                        |  +--------+     +--------+
                        |  |VolDo   |     |VolDo   |
                        |  |        |     |        |
                        |  +--------+     +--------+
                        +> |Vcb     | <-> |Vcb     | <-> ...
                           |        |     |        |
                           +--------+     +--------+


        Each Vcb contains a table of all the Fcbs for the volume indexed by
        their FileId.  Each Vcb contains a pointer to the root directory of
        the volume.  Each directory Fcb contains a queue of child Fcb's for
        its children.  There can also be detached subtrees due to open operations
        by Id where the Fcb's are not connected to the root.

        The following diagram shows the root structure.

            +--------+     +--------+
            |  Vcb   |---->| Fcb    |-----------------------------------------------+
            |        |     |  Table |--------------------------------------------+  |                                   |
            |        |--+  |        |-----------------------------------------+  |  |                                   |
            +--------+  |  +--------+                                         |  |  |
                        |    |  |  |                                          |  |  |
                        |    |  |  +--------------------+                     |  |  |
                        |    V  +---------+             |                     |  |  |
                        |  +--------+     |             |                     |  |  |
                        |  |RootFcb |     V             V                     |  |  |
                        +->|        |   +--------+    +--------+              |  |  |
                           |        |-->|Child   |    |Child   |              |  |  |
                           +--------+   | Fcb    |<-->| Fcb    |<--> ...      |  |  |
                                        |        |    |        |              |  |  |
                                        +--------+    +--------+              |  |  |
                                                                              |  |  |
                          (Freestanding sub-tree)                             |  |  |
                          +--------+                                          |  |  |
                          |OpenById|<-----------------------------------------+  |  |
                          | Dir    |    +--------+                               |  |
                          |        |--->|OpenById|<------------------------------+  |
                          +--------+    | Child  |    +--------+                    |
                                        |  Dir   |--->|OpenById|<-------------------+
                                        +--------+    | Child  |
                                                      |  File  |
                                                      +--------+

        Attached to each Directory Fcb is a prefix table containing the names
        of children of this directory for which there is an Fcb.  Not all Fcb's
        will necessarily have an entry in this table.

            +--------+      +--------+
            |  Dir   |      | Prefix |
            |   Fcb  |----->|  Table |--------------------+
            |        |      |        |-------+            |
            +--------+      +--------+       |            |
                |              |             |            |
                |              |             |            |
                |              V             V            V
                |           +--------+    +--------+    +--------+    +--------+
                |           |  Fcb   |    |  Fcb   |    |  Fcb   |    |  Fcb   |
                +---------->|        |<-->|        |<-->|        |<-->|        |
                            |        |    |        |    |        |    |        |
                            +--------+    +--------+    +--------+    +--------+


        Each file object open on a CDROM volume contains two context pointers.  The
        first will point back to the Fcb for the file object.  The second, if present,
        points to a Ccb (ContextControlBlock) which contains the per-handle information.
        This includes the state of any directory enumeration.

          +--------+       +--------+    +--------+
          |  Fcb   |<------| File   |    |  Ccb   |
          |        |       |  Object|--->|        |
          |        |       |        |    |        |
          +--------+       +--------+    +--------+
            ^    ^
            |    |         +--------+    +--------+
            |    |         | File   |    |  Ccb   |
            |    +---------|  Object|--->|        |
            |              |        |    |        |
            |              +--------+    +--------+
            |
            |              +--------+
            |              |Stream  |
            +--------------| File   |
                           |  Object|
                           +--------+


    Synchronization:

        1. A resource in the CdData synchronizes access to the Vcb queue.  This
            is used during mount/verify/dismount operations.

        2. A resource in the Vcb is used to synchronize access to Vcb for
            open/close operations.  Typically acquired shared, it
            is acquired exclusively to lock out these operations.

        3. A second resource in the Vcb is used to synchronize all file operations.
            Typically acquired shared, it is acquired exclusively to lock
            out all file operations.  Acquiring both Vcb resources will lock
            the entire volume.

        4. A resource in the nonpaged Fcb will synchronize open/close operations
            on an Fcb.

        5. A fast mutex in the Vcb will protect access to the Fcb table and
            the open counts in the Vcb.  It is also used to modify the reference
            counts in all Fcbs.  This mutex cannot be acquired
            exclusely and is an end resource.

        6. A fast mutex in the Fcb will synchronize access to all Fcb fields
            which aren't synchronized in some other way.  A thread may acquire
            mutexes for multiple Fcb's as long as it works it way toward the
            root of the tree.  This mutex can also be acquired recursively.

        7. Normal locking order is CdData/Vcb/Fcb starting at any point in this
            chain.  The Vcb is required prior to acquiring resources for multiple
            files.  Shared ownership of the Vcb is sufficient in this case.

        8. Normal locking order when acquiring multiple Fcb's is from some
            starting Fcb and walking towards the root of tree.  Create typically
            walks down the tree.  In this case we will attempt to acquire the
            next node optimistically and if that fails we will reference
            the current node in the tree, release it and acquire the next node.
            At that point it will be safe to reacquire the parent node.

        9. Locking order for the Fcb (via the fast mutex) will be from leaf of
            tree back towards the root.  No other resource may be acquired
            after locking the Vcb (other than in-page reads).

       10. Cleanup operations only lock the Vcb and Fcb long enough to change the
            critical counts and share access fields.  No reason to synchronize
            otherwise.  None of the structures can go away from beneath us
            in this case.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDSTRUC_
#define _CDSTRUC_

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module

#define BYTE_COUNT_EMBEDDED_NAME        (32)


//
//  The CD_MCB is used to store the mapping of logical file offset to
//  logical disk offset.  NOTE - This package only deals with the
//  logical 2048 sectors.  Translating to 'raw' sectors happens in
//  software.  We will embed a single MCB_ENTRY in the Fcb since this
//  will be the typical case.
//

typedef struct _CD_MCB {

    //
    //  Size and current count of the Mcb entries.
    //

    ULONG MaximumEntryCount;
    ULONG CurrentEntryCount;

    //
    //  Pointer to the start of the Mcb entries.
    //

    struct _CD_MCB_ENTRY *McbArray;

} CD_MCB;
typedef CD_MCB *PCD_MCB;

typedef struct _CD_MCB_ENTRY {

    //
    //  Starting offset and number of bytes described by this entry.
    //  The Byte count is rounded to a logical block boundary if this is
    //  the last block.
    //

    LONGLONG DiskOffset;
    LONGLONG ByteCount;

    //
    //  Starting offset in the file of mapping described by this dirent.
    //

    LONGLONG FileOffset;

    //
    //  Data length and block length.  Data length is the length of each
    //  data block.  Total length is the length of each data block and
    //  the skip size.
    //

    LONGLONG DataBlockByteCount;
    LONGLONG TotalBlockByteCount;

} CD_MCB_ENTRY;
typedef CD_MCB_ENTRY *PCD_MCB_ENTRY;


//
//  Cd name structure.  The following structure is used to represent the
//  full Cdrom name.  This name can be stored in either Unicode or ANSI
//  format.
//

typedef struct _CD_NAME {

    //
    //  String containing name without the version number.
    //  The maximum length field for filename indicates the
    //  size of the buffer allocated for the two parts of the name.
    //

    UNICODE_STRING FileName;

    //
    //  String containging the version number.
    //

    UNICODE_STRING VersionString;

} CD_NAME;
typedef CD_NAME *PCD_NAME;

//
//  Following is the splay link structure for the prefix lookup.
//  The names can be in either Unicode string or Ansi string format.
//

typedef struct _NAME_LINK {

    RTL_SPLAY_LINKS Links;
    UNICODE_STRING FileName;

} NAME_LINK;
typedef NAME_LINK *PNAME_LINK;


//
//  Prefix entry.  There is one of these for each name in the prefix table.
//  An Fcb will have one of these embedded for the long name and an optional
//  pointer to the short name entry.
//

typedef struct _PREFIX_ENTRY {

    //
    //  Pointer to the Fcb for this entry.
    //

    struct _FCB *Fcb;

    //
    //  Flags field.  Used to indicate if the name is in the prefix table.
    //

    ULONG PrefixFlags;

    //
    //  Exact case name match.
    //

    NAME_LINK ExactCaseName;

    //
    //  Case-insensitive name link.
    //

    NAME_LINK IgnoreCaseName;

    WCHAR FileNameBuffer[ BYTE_COUNT_EMBEDDED_NAME ];

} PREFIX_ENTRY;
typedef PREFIX_ENTRY *PPREFIX_ENTRY;

#define PREFIX_FLAG_EXACT_CASE_IN_TREE              (0x00000001)
#define PREFIX_FLAG_IGNORE_CASE_IN_TREE             (0x00000002)


//
//  The CD_DATA record is the top record in the CDROM file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _CD_DATA {

    //
    //  The type and size of this record (must be CDFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  Vcb queue.
    //

    LIST_ENTRY VcbQueue;

    //
    //  The following fields are used to allocate IRP context structures
    //  using a lookaside list, and other fixed sized structures from a
    //  small cache.  We use the CdData mutex to protext these structures.
    //

    ULONG IrpContextDepth;
    ULONG IrpContextMaxDepth;
    SINGLE_LIST_ENTRY IrpContextList;

    //
    //  Filesystem device object for CDFS.
    //

    PDEVICE_OBJECT FileSystemDeviceObject;

    //
    //  Following are used to manage the async and delayed close queue.
    //
    //  FspCloseActive - Indicates whether there is a thread processing the
    //      two close queues.
    //  ReduceDelayedClose - Indicates that we have hit the upper threshold
    //      for the delayed close queue and need to reduce it to lower threshold.
    //
    //  AsyncCloseQueue - Queue of IrpContext waiting for async close operation.
    //  AsyncCloseCount - Number of entries on the async close queue.
    //
    //  DelayedCloseQueue - Queue of IrpContextLite waiting for delayed close
    //      operation.
    //  MaxDelayedCloseCount - Trigger delay close work at this threshold.
    //  MinDelayedCloseCount - Turn off delay close work at this threshold.
    //  DelayedCloseCount - Number of entries on the delayted close queue.
    //
    //  CloseItem - Workqueue item used to start FspClose thread.
    //

    LIST_ENTRY AsyncCloseQueue;
    ULONG AsyncCloseCount;
    BOOLEAN FspCloseActive;
    BOOLEAN ReduceDelayedClose;
    USHORT PadUshort;

    //
    //  The following fields describe the deferred close file objects.
    //

    LIST_ENTRY DelayedCloseQueue;
    ULONG DelayedCloseCount;
    ULONG MaxDelayedCloseCount;
    ULONG MinDelayedCloseCount;

    //
    //  Fast mutex used to lock the fields of this structure.
    //

    PVOID CdDataLockThread;
    FAST_MUTEX CdDataMutex;

    //
    //  A resource variable to control access to the global CDFS data record
    //

    ERESOURCE DataResource;

    //
    //  Cache manager call back structure, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerVolumeCallbacks;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    PIO_WORKITEM CloseItem;

} CD_DATA;
typedef CD_DATA *PCD_DATA;


//
//  The Vcb (Volume control block) record corresponds to every
//  volume mounted by the file system.  They are ordered in a queue off
//  of CdData.VcbQueue.
//
//  The Vcb will be in several conditions during its lifespan.
//
//      NotMounted - Disk is not currently mounted (i.e. removed
//          from system) but cleanup and close operations are
//          supported.
//
//      MountInProgress - State of the Vcb from the time it is
//          created until it is successfully mounted or the mount
//          fails.
//
//      Mounted - Volume is currently in the mounted state.
//
//      Invalid - User has invalidated the volume.  Only legal operations
//          are cleanup and close.
//
//      DismountInProgress - We have begun the process of tearing down the
//          Vcb.  It can be deleted when all the references to it
//          have gone away.
//

typedef enum _VCB_CONDITION {

    VcbNotMounted = 0,
    VcbMountInProgress,
    VcbMounted,
    VcbInvalid,
    VcbDismountInProgress

} VCB_CONDITION;

typedef struct _VCB {

    //
    //  The type and size of this record (must be CDFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Vpb for this volume.
    //

    PVPB Vpb;

    //
    //  Device object for the driver below us.
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  File object used to lock the volume.
    //

    PFILE_OBJECT VolumeLockFileObject;

    //
    //  Link into queue of Vcb's in the CdData structure.  We will create a union with
    //  a LONGLONG to force the Vcb to be quad-aligned.
    //

    union {

        LIST_ENTRY VcbLinks;
        LONGLONG Alignment;
    };

    //
    //  State flags and condition for the Vcb.
    //

    ULONG VcbState;
    VCB_CONDITION VcbCondition;

    //
    //  Various counts for this Vcb.
    //
    //      VcbCleanup - Open handles left on this system.
    //      VcbReference - Number of reasons this Vcb is still present.
    //      VcbUserReference - Number of user file objects still present.
    //

    ULONG VcbCleanup;
    ULONG VcbReference;
    ULONG VcbUserReference;

    //
    //  Fcb for the Volume Dasd file, root directory and the Path Table.
    //

    struct _FCB *VolumeDasdFcb;
    struct _FCB *RootIndexFcb;
    struct _FCB *PathTableFcb;

    //
    //  Location of current session and offset of volume descriptors.
    //

    ULONG BaseSector;
    ULONG VdSectorOffset;
    ULONG PrimaryVdSectorOffset;

    //
    //  Following is a sector from the last non-cached read of an XA file.
    //  Also the cooked offset on the disk.
    //

    PVOID XASector;
    LONGLONG XADiskOffset;

    //
    //  Vcb resource.  This is used to synchronize open/cleanup/close operations.
    //

    ERESOURCE VcbResource;

    //
    //  File resource.  This is used to synchronize all file operations except
    //  open/cleanup/close.
    //

    ERESOURCE FileResource;

    //
    //  Vcb fast mutex.  This is used to synchronize the fields in the Vcb
    //  when modified when the Vcb is not held exclusively.  Included here
    //  are the count fields and Fcb table.
    //
    //  We also use this to synchronize changes to the Fcb reference field.
    //

    FAST_MUTEX VcbMutex;
    PVOID VcbLockThread;

    //
    //  The following is used to synchronize the dir notify package.
    //

    PNOTIFY_SYNC NotifySync;

    //
    //  The following is the head of a list of notify Irps.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  Logical block size for this volume as well constant values
    //  associated with the block size.
    //

    ULONG BlockSize;
    ULONG BlockToSectorShift;
    ULONG BlockToByteShift;
    ULONG BlocksPerSector;
    ULONG BlockMask;
    ULONG BlockInverseMask;

    //
    //  Fcb table.  Synchronized with the Vcb fast mutex.
    //

    RTL_GENERIC_TABLE FcbTable;

    //
    //  Volume TOC.  Cache this information for quick lookup.
    //

    PCDROM_TOC CdromToc;
    ULONG TocLength;
    ULONG TrackCount;
    ULONG DiskFlags;

    //
    //  Block factor to determine last session information.
    //

    ULONG BlockFactor;

    //
    //  Media change count from device driver for bulletproof detection
    //  of media movement
    //

    ULONG MediaChangeCount;

    //
    //  For raw reads, CDFS must obey the port maximum transfer restrictions.
    //

    ULONG MaximumTransferRawSectors;
    ULONG MaximumPhysicalPages;

    //
    //  Preallocated VPB for swapout, so we are not forced to consider
    //  must succeed pool.
    //

    PVPB SwapVpb;

} VCB;
typedef VCB *PVCB;

#define VCB_STATE_HSG                               (0x00000001)
#define VCB_STATE_ISO                               (0x00000002)
#define VCB_STATE_JOLIET                            (0x00000004)
#define VCB_STATE_LOCKED                            (0x00000010)
#define VCB_STATE_REMOVABLE_MEDIA                   (0x00000020)
#define VCB_STATE_CDXA                              (0x00000040)
#define VCB_STATE_AUDIO_DISK                        (0x00000080)
#define VCB_STATE_NOTIFY_REMOUNT                    (0x00000100)
#define VCB_STATE_VPB_NOT_ON_DEVICE                 (0x00000200)


//
//  The Volume Device Object is an I/O system device object with a
//  workqueue and an VCB record appended to the end.  There are multiple
//  of these records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload
//  of work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;
typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;


//
//  The following two structures are the separate union structures for
//  data and index Fcb's.  The path table is actually the same structure
//  as the index Fcb since it uses the first few fields.
//

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

typedef struct _FCB_DATA {

    //
    //  The following field is used by the oplock module
    //  to maintain current oplock information.
    //

    OPLOCK Oplock;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //  A file lock is allocated as needed.
    //

    PFILE_LOCK FileLock;

} FCB_DATA;
typedef FCB_DATA *PFCB_DATA;

typedef struct _FCB_INDEX {

    //
    //  Internal stream file.
    //

    PFILE_OBJECT FileObject;

    //
    //  Offset of first entry in stream.  This is for case where directory
    //  or path table does not begin on a sector boundary.  This value is
    //  added to all offset values to determine the real offset.
    //

    ULONG StreamOffset;

    //
    //  List of child fcbs.
    //

    LIST_ENTRY FcbQueue;

    //
    //  Ordinal number for this directory.  Combine this with the path table offset
    //  in the FileId and you have a starting point in the path table.
    //

    ULONG Ordinal;

    //
    //  Children path table start.  This is the offset in the path table
    //  for the first child of the directory.  A value of zero indicates
    //  that we haven't found the first child yet.  If there are no child
    //  directories we will position at a point in the path table so that
    //  subsequent searches will fail quickly.
    //

    ULONG ChildPathTableOffset;
    ULONG ChildOrdinal;

    //
    //  Root of splay trees for exact and ignore case prefix trees.
    //

    PRTL_SPLAY_LINKS ExactCaseRoot;
    PRTL_SPLAY_LINKS IgnoreCaseRoot;

} FCB_INDEX;
typedef FCB_INDEX *PFCB_INDEX;

typedef struct _FCB_NONPAGED {

    //
    //  Type and size of this record must be CDFS_NTC_FCB_NONPAGED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to
    //  point to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  This is the resource structure for this Fcb.
    //

    ERESOURCE FcbResource;

    //
    //  This is the FastMutex for this Fcb.
    //

    FAST_MUTEX FcbMutex;

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

} FCB_NONPAGED;
typedef FCB_NONPAGED *PFCB_NONPAGED;

//
//  The Fcb/Dcb record corresponds to every open file and directory, and to
//  every directory on an opened path.
//

typedef struct _FCB {

    //
    //  The following field is used for fast I/O.  It contains the node
    //  type code and size, indicates if fast I/O is possible, contains
    //  allocation, file, and valid data size, a resource, and call back
    //  pointers for FastIoRead and FastMdlRead.
    //
    //
    //  Node type codes for the Fcb must be one of the following.
    //
    //      CDFS_NTC_FCB_PATH_TABLE
    //      CDFS_NTC_FCB_INDEX
    //      CDFS_NTC_FCB_DATA
    //

    //
    //  Common Fsrtl Header.  The named header is for the fieldoff.c output.  We
    //  use the unnamed header internally.
    //

    union{

        FSRTL_ADVANCED_FCB_HEADER Header;
        FSRTL_ADVANCED_FCB_HEADER;
    };

    //
    //  Vcb for this Fcb.
    //

    PVCB Vcb;

    //
    //  Parent Fcb for this Fcb.  This may be NULL if this file was opened
    //  by ID, also for the root Fcb.
    //

    struct _FCB *ParentFcb;

    //
    //  Links to the queue of Fcb's in the parent.
    //

    LIST_ENTRY FcbLinks;

    //
    //  FileId for this file.
    //

    FILE_ID FileId;

    //
    //  Counts on this Fcb.  Cleanup count represents the number of open handles
    //  on this Fcb.  Reference count represents the number of reasons this Fcb
    //  is still present.  It includes file objects, children Fcb and anyone
    //  who wants to prevent this Fcb from going away.  Cleanup count is synchronized
    //  with the FcbResource.  The reference count is synchronized with the
    //  VcbMutex.
    //

    ULONG FcbCleanup;
    ULONG FcbReference;
    ULONG FcbUserReference;

    //
    //  State flags for this Fcb.
    //

    ULONG FcbState;

    //
    //  NT style attributes for the Fcb.
    //

    ULONG FileAttributes;

    //
    //  CDXA attributes for this file.
    //

    USHORT XAAttributes;

    //
    //  File number from the system use area.
    //

    UCHAR XAFileNumber;

    //
    //  This is the thread and count for the thread which has locked this
    //  Fcb.
    //

    PVOID FcbLockThread;
    ULONG FcbLockCount;

    //
    //  Pointer to the Fcb non-paged structures.
    //

    PFCB_NONPAGED FcbNonpaged;

    //
    //  Share access structure.
    //

    SHARE_ACCESS ShareAccess;

    //
    //  Mcb for the on disk mapping and a single map entry.
    //

    CD_MCB_ENTRY McbEntry;
    CD_MCB Mcb;

    //
    //  Embed the prefix entry for the longname.  Store an optional pointer
    //  to a prefix structure for the short name.
    //

    PPREFIX_ENTRY ShortNamePrefix;
    PREFIX_ENTRY FileNamePrefix;

    //
    //  Time stamp for this file.
    //

    LONGLONG CreationTime;

    union{

        ULONG FcbType;
        FCB_DATA;
        FCB_INDEX;
    };

} FCB;
typedef FCB *PFCB;

#define FCB_STATE_INITIALIZED                   (0x00000001)
#define FCB_STATE_IN_FCB_TABLE                  (0x00000002)
#define FCB_STATE_MODE2FORM2_FILE               (0x00000004)
#define FCB_STATE_MODE2_FILE                    (0x00000008)
#define FCB_STATE_DA_FILE                       (0x00000010)

//
//  These file types are read as raw 2352 byte sectors
//

#define FCB_STATE_RAWSECTOR_MASK                ( FCB_STATE_MODE2FORM2_FILE | \
                                                  FCB_STATE_MODE2_FILE      | \
                                                  FCB_STATE_DA_FILE )

#define SIZEOF_FCB_DATA     \
    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_DATA ))

#define SIZEOF_FCB_INDEX    \
    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_INDEX ))


//
//  The Ccb record is allocated for every file object
//

typedef struct _CCB {

    //
    //  Type and size of this record (must be CDFS_NTC_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Flags.  Indicates flags to apply for the current open.
    //

    ULONG Flags;

    //
    //  Fcb for the file being opened.
    //

    PFCB Fcb;

    //
    //  We store state information in the Ccb for a directory
    //  enumeration on this handle.
    //

    //
    //  Offset in the directory stream to base the next enumeration.
    //

    ULONG CurrentDirentOffset;
    CD_NAME SearchExpression;

} CCB;
typedef CCB *PCCB;

#define CCB_FLAG_OPEN_BY_ID                     (0x00000001)
#define CCB_FLAG_OPEN_RELATIVE_BY_ID            (0x00000002)
#define CCB_FLAG_IGNORE_CASE                    (0x00000004)
#define CCB_FLAG_OPEN_WITH_VERSION              (0x00000008)
#define CCB_FLAG_DISMOUNT_ON_CLOSE              (0x00000010)

//
//  Following flags refer to index enumeration.
//

#define CCB_FLAG_ENUM_NAME_EXP_HAS_WILD         (0x00010000)
#define CCB_FLAG_ENUM_VERSION_EXP_HAS_WILD      (0x00020000)
#define CCB_FLAG_ENUM_MATCH_ALL                 (0x00040000)
#define CCB_FLAG_ENUM_VERSION_MATCH_ALL         (0x00080000)
#define CCB_FLAG_ENUM_RETURN_NEXT               (0x00100000)
#define CCB_FLAG_ENUM_INITIALIZED               (0x00200000)
#define CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY    (0x00400000)


//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the CdComplete
//  request routine
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be CDFS_NTC_IRP_CONTEXT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Originating Irp for the request.
    //

    PIRP Irp;

    //
    //  Vcb for this operation.  When this is NULL it means we were called
    //  with our filesystem device object instead of a volume device object.
    //  (Mount will fill this in once the Vcb is created)
    //

    PVCB Vcb;

    //
    //  Exception encountered during the request.  Any error raised explicitly by
    //  the file system will be stored here.  Any other error raised by the system
    //  is stored here after normalizing it.
    //

    NTSTATUS ExceptionStatus;

    //
    //  Flags for this request.
    //

    ULONG Flags;

    //
    //  Real device object.  This represents the physical device closest to the media.
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  Io context for a read request.
    //  Address of Fcb for teardown oplock in create case.
    //

    union {

        struct _CD_IO_CONTEXT *IoContext;
        PFCB *TeardownFcb;
    };

    //
    //  Top level irp context for this thread.
    //

    struct _IRP_CONTEXT *TopLevel;

    //
    //  Major and minor function codes.
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  Pointer to the top-level context if this IrpContext is responsible
    //  for cleaning it up.
    //

    struct _THREAD_CONTEXT *ThreadContext;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

#define IRP_CONTEXT_FLAG_ON_STACK               (0x00000001)
#define IRP_CONTEXT_FLAG_MORE_PROCESSING        (0x00000002)
#define IRP_CONTEXT_FLAG_WAIT                   (0x00000004)
#define IRP_CONTEXT_FLAG_FORCE_POST             (0x00000008)
#define IRP_CONTEXT_FLAG_TOP_LEVEL              (0x00000010)
#define IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS         (0x00000020)
#define IRP_CONTEXT_FLAG_IN_FSP                 (0x00000040)
#define IRP_CONTEXT_FLAG_IN_TEARDOWN            (0x00000080)
#define IRP_CONTEXT_FLAG_ALLOC_IO               (0x00000100)
#define IRP_CONTEXT_FLAG_DISABLE_POPUPS         (0x00000200)
#define IRP_CONTEXT_FLAG_FORCE_VERIFY           (0x00000400)

//
//  Flags used for create.
//

#define IRP_CONTEXT_FLAG_FULL_NAME              (0x10000000)
#define IRP_CONTEXT_FLAG_TRAIL_BACKSLASH        (0x20000000)

//
//  The following flags need to be cleared when a request is posted.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_POST (   \
    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \
    IRP_CONTEXT_FLAG_WAIT               |   \
    IRP_CONTEXT_FLAG_FORCE_POST         |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS     |   \
    IRP_CONTEXT_FLAG_IN_FSP             |   \
    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \
    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \
)

//
//  The following flags need to be cleared when a request is retried.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY (  \
    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \
    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \
    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \
)

//
//  The following flags are set each time through the Fsp loop.
//

#define IRP_CONTEXT_FSP_FLAGS (             \
    IRP_CONTEXT_FLAG_WAIT               |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS     |   \
    IRP_CONTEXT_FLAG_IN_FSP                 \
)


//
//  Following structure is used to queue a request to the delayed close queue.
//  This structure should be the minimum block allocation size.
//

typedef struct _IRP_CONTEXT_LITE {

    //
    //  Type and size of this record (must be CDFS_NTC_IRP_CONTEXT_LITE)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Fcb for the file object being closed.
    //

    PFCB Fcb;

    //
    //  List entry to attach to delayed close queue.
    //

    LIST_ENTRY DelayedCloseLinks;

    //
    //  User reference count for the file object being closed.
    //

    ULONG UserReference;

    //
    //  Real device object.  This represents the physical device closest to the media.
    //

    PDEVICE_OBJECT RealDevice;

} IRP_CONTEXT_LITE;
typedef IRP_CONTEXT_LITE *PIRP_CONTEXT_LITE;


//
//  Context structure for asynchronous I/O calls.  Most of these fields
//  are actually only required for the ReadMultiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _CD_IO_CONTEXT {

    //
    //  These two fields are used for multiple run Io
    //

    LONG IrpCount;
    PIRP MasterIrp;
    NTSTATUS Status;
    BOOLEAN AllocatedContext;

    union {

        //
        //  This element handles the asynchronous non-cached Io
        //

        struct {

            PERESOURCE Resource;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;
        };

        //
        //  and this element handles the synchronous non-cached Io.
        //

        KEVENT SyncEvent;
    };

} CD_IO_CONTEXT;
typedef CD_IO_CONTEXT *PCD_IO_CONTEXT;


//
//  Following structure is used to track the top level request.  Each Cdfs
//  Fsd and Fsp entry point will examine the top level irp location in the
//  thread local storage to determine if this request is top level and/or
//  top level Cdfs.  The top level Cdfs request will remember the previous
//  value and update that location with a stack location.  This location
//  can be accessed by recursive Cdfs entry points.
//

typedef struct _THREAD_CONTEXT {

    //
    //  CDFS signature.  Used to confirm structure on stack is valid.
    //

    ULONG Cdfs;

    //
    //  Previous value in top-level thread location.  We restore this
    //  when done.
    //

    PIRP SavedTopLevelIrp;

    //
    //  Top level Cdfs IrpContext.  Initial Cdfs entry point on stack
    //  will store the IrpContext for the request in this stack location.
    //

    PIRP_CONTEXT TopLevelIrpContext;

} THREAD_CONTEXT;
typedef THREAD_CONTEXT *PTHREAD_CONTEXT;


//
//  The following structure is used for enumerating the entries in the
//  path table.  We will always map this two sectors at a time so we don't
//  have to worry about entries which span sectors.  We move through
//  one sector at a time though.  We will unpin and remap after
//  crossing a sector boundary.
//
//  The only special case is where we span a cache view.  In that case
//  we will allocate a buffer and read both pieces into it.
//
//  This strategy takes advantage of the CC enhancement which allows
//  overlapping ranges.
//

typedef struct _PATH_ENUM_CONTEXT {

    //
    //  Pointer to the current sector and the offset of this sector to
    //  the beginning of the path table.  The Data pointer may be
    //  a pool block in the case where we cross a cache view
    //  boundary.  Also the length of the data for this block.
    //

    PVOID Data;
    ULONG BaseOffset;
    ULONG DataLength;

    //
    //  Bcb for the sector.  (We may actually have pinned two sectors)
    //  This will be NULL for the case where we needed to allocate a
    //  buffer in the case where we span a cache view.
    //

    PBCB Bcb;

    //
    //  Offset to current entry within the current data block.
    //

    ULONG DataOffset;

    //
    //  Did we allocate the buffer for the entry.
    //

    BOOLEAN AllocatedData;

    //
    //  End of Path Table.  This tells us whether the current data
    //  block includes the end of the path table.  This is the
    //  only block where we need to do a careful check about whether
    //  the path table entry fits into the buffer.
    //
    //  Also once we have reached the end of the path table we don't
    //  need to remap the data as we move into the final sector.
    //  We always look at the last two sectors together.
    //

    BOOLEAN LastDataBlock;

} PATH_ENUM_CONTEXT;
typedef PATH_ENUM_CONTEXT *PPATH_ENUM_CONTEXT;

#define VACB_MAPPING_MASK               (VACB_MAPPING_GRANULARITY - 1)
#define LAST_VACB_SECTOR_OFFSET         (VACB_MAPPING_GRANULARITY - SECTOR_SIZE)


//
//  Path Entry.  This is our representation of the on disk data.
//

typedef struct _PATH_ENTRY {

    //
    //  Directory number and offset.  This is the ordinal and the offset from
    //  the beginning of the path table stream for this entry.
    //
    //

    ULONG Ordinal;
    ULONG PathTableOffset;

    //
    //  Logical block Offset on the disk for this entry.  We already bias
    //  this by any Xar blocks.
    //

    ULONG DiskOffset;

    //
    //  Length of on-disk path table entry.
    //

    ULONG PathEntryLength;

    //
    //  Parent number.
    //

    ULONG ParentOrdinal;

    //
    //  DirName length and Id.  Typically the pointer here points to the raw on-disk
    //  bytes.  We will point to a fixed self entry if this is the root directory.
    //

    ULONG DirNameLen;
    PCHAR DirName;

    //
    //  Following are the flags used to cleanup this structure.
    //

    ULONG Flags;

    //
    //  The following is the filename string and version number strings.  We embed a buffer
    //  large enough to hold two 8.3 names.  One for exact case and one for case insensitive.
    //

    CD_NAME CdDirName;
    CD_NAME CdCaseDirName;

    WCHAR NameBuffer[BYTE_COUNT_EMBEDDED_NAME / sizeof( WCHAR ) * 2];

} PATH_ENTRY;
typedef PATH_ENTRY *PPATH_ENTRY;

#define PATH_ENTRY_FLAG_ALLOC_BUFFER            (0x00000001)


//
//  Compound path entry.  This structure combines the on-disk entries
//  with the in-memory structures.
//

typedef struct _COMPOUND_PATH_ENTRY {

    PATH_ENUM_CONTEXT PathContext;
    PATH_ENTRY PathEntry;

} COMPOUND_PATH_ENTRY;
typedef COMPOUND_PATH_ENTRY *PCOMPOUND_PATH_ENTRY;


//
//  The following is used for enumerating through a directory via the
//  dirents.
//

typedef struct _DIRENT_ENUM_CONTEXT {

    //
    //  Pointer the current sector and the offset of this sector within
    //  the directory file.  Also the data length of this pinned block.
    //

    PVOID Sector;
    ULONG BaseOffset;
    ULONG DataLength;

    //
    //  Bcb for the sector.
    //

    PBCB Bcb;

    //
    //  Offset to the current dirent within this sector.
    //

    ULONG SectorOffset;

    //
    //  Length to next dirent.  A zero indicates to move to the next sector.
    //

    ULONG NextDirentOffset;

} DIRENT_ENUM_CONTEXT;
typedef DIRENT_ENUM_CONTEXT *PDIRENT_ENUM_CONTEXT;


//
//  Following structure is used to smooth out the differences in the HSG, ISO
//  and Joliett directory entries.
//

typedef struct _DIRENT {

    //
    //  Offset in the Directory of this entry.  Note this includes
    //  any bytes added to the beginning of the directory to pad
    //  down to a sector boundary.
    //

    ULONG DirentOffset;

    ULONG DirentLength;

    //
    //  Starting offset on the disk including any Xar blocks.
    //

    ULONG StartingOffset;

    //
    //  DataLength of the data.  If not the last block then this should
    //  be an integral number of logical blocks.
    //

    ULONG DataLength;

    //
    //  The following field is the time stamp out of the directory entry.
    //  Use a pointer into the dirent for this.
    //

    PCHAR CdTime;

    //
    //  The following field is the dirent file flags field.
    //

    UCHAR DirentFlags;

    //
    //  Following field is a Cdfs flag field used to clean up this structure.
    //

    UCHAR Flags;

    //
    //  The following fields indicate the file unit size and interleave gap
    //  for interleaved files.  Each of these are in logical blocks.
    //

    ULONG FileUnitSize;
    ULONG InterleaveGapSize;

    //
    //  System use offset.  Zero value indicates no system use area.
    //

    ULONG SystemUseOffset;

    //
    //  CDXA attributes and file number for this file.
    //

    USHORT XAAttributes;
    UCHAR XAFileNumber;

    //
    //  Filename length and ID.  We copy the length (in bytes) and keep
    //  a pointer to the start of the name.
    //

    ULONG FileNameLen;
    PCHAR FileName;

    //
    //  The following are the filenames stored by name and version numbers.
    //  The fixed buffer here can hold two Unicode 8.3 names.  This allows
    //  us to upcase the name into a fixed buffer.
    //

    CD_NAME CdFileName;
    CD_NAME CdCaseFileName;

    //
    //  Data stream type.  Indicates if this is audio, XA mode2 form2 or cooked sectors.
    //

    XA_EXTENT_TYPE ExtentType;

    WCHAR NameBuffer[BYTE_COUNT_EMBEDDED_NAME / sizeof( WCHAR ) * 2];

} DIRENT;
typedef DIRENT *PDIRENT;

#define DIRENT_FLAG_ALLOC_BUFFER                (0x01)
#define DIRENT_FLAG_CONSTANT_ENTRY              (0x02)

#define DIRENT_FLAG_NOT_PERSISTENT              (0)


//
//  Following structure combines the on-disk information with the normalized
//  structure.
//

typedef struct _COMPOUND_DIRENT {

    DIRENT_ENUM_CONTEXT DirContext;
    DIRENT Dirent;

} COMPOUND_DIRENT;
typedef COMPOUND_DIRENT *PCOMPOUND_DIRENT;


//
//  The following structure is used to enumerate the files in a directory.
//  It contains three DirContext/Dirent pairs and then self pointers to
//  know which of these is begin used how.
//

typedef struct _FILE_ENUM_CONTEXT {

    //
    //  Pointers to the current compound dirents below.
    //
    //      PriorDirent - Initial dirent for the last file encountered.
    //      InitialDirent - Initial dirent for the current file.
    //      CurrentDirent - Second or later dirent for the current file.
    //

    PCOMPOUND_DIRENT PriorDirent;
    PCOMPOUND_DIRENT InitialDirent;
    PCOMPOUND_DIRENT CurrentDirent;

    //
    //  Flags indicating the state of the search.
    //

    ULONG Flags;

    //
    //  This is an accumulation of the file sizes of the different extents
    //  of a single file.
    //

    LONGLONG FileSize;

    //
    //  Short name for this file.
    //

    CD_NAME ShortName;
    WCHAR ShortNameBuffer[ BYTE_COUNT_8_DOT_3 / sizeof( WCHAR ) ];

    //
    //  Array of compound dirents.
    //

    COMPOUND_DIRENT Dirents[3];

} FILE_ENUM_CONTEXT;
typedef FILE_ENUM_CONTEXT *PFILE_ENUM_CONTEXT;

#define FILE_CONTEXT_MULTIPLE_DIRENTS       (0x00000001)


//
//  RIFF header.  Prepended to the data of a file containing XA sectors.
//  This is a hard-coded structure except that we bias the 'ChunkSize' and
//  'RawSectors' fields with the file size.  We also copy the attributes flag
//  from the system use area in the dirent.  We always initialize this
//  structure by copying the XAFileHeader.
//

typedef struct _RIFF_HEADER {

    ULONG ChunkId;
    LONG ChunkSize;
    ULONG SignatureCDXA;
    ULONG SignatureFMT;
    ULONG XAChunkSize;
    ULONG OwnerId;
    USHORT Attributes;
    USHORT SignatureXA;
    UCHAR FileNumber;
    UCHAR Reserved[7];
    ULONG SignatureData;
    ULONG RawSectors;

} RIFF_HEADER;
typedef RIFF_HEADER *PRIFF_HEADER;

//
//  Audio play header for CDDA tracks.
//

typedef struct _AUDIO_PLAY_HEADER {

    ULONG Chunk;
    ULONG ChunkSize;
    ULONG SignatureCDDA;
    ULONG SignatureFMT;
    ULONG FMTChunkSize;
    USHORT FormatTag;
    USHORT TrackNumber;
    ULONG DiskID;
    ULONG StartingSector;
    ULONG SectorCount;
    UCHAR TrackAddress[4];
    UCHAR TrackLength[4];

} AUDIO_PLAY_HEADER;
typedef AUDIO_PLAY_HEADER *PAUDIO_PLAY_HEADER;


//
//  Some macros for supporting the use of a Generic Table
//  containing all the FCB/DCBs and indexed by their FileId.
//
//  For directories:
//
//      The HighPart contains the path table offset of this directory in the
//      path table.
//
//      The LowPart contains zero except for the upper bit which is
//      set to indicate that this is a directory.
//
//  For files:
//
//      The HighPart contains the path table offset of the parent directory
//      in the path table.
//
//      The LowPart contains the byte offset of the dirent in the parent
//      directory file.
//
//  A directory is always entered into the Fcb Table as if it's
//  dirent offset was zero.  This enables any child to look in the FcbTable
//  for it's parent by searching with the same HighPart but with zero
//  as the value for LowPart.
//
//  The Id field is a LARGE_INTEGER where the High and Low parts can be
//  accessed separately.
//
//  The following macros are used to access the Fid fields.
//
//      CdQueryFidDirentOffset      - Accesses the Dirent offset field
//      CdQueryFidPathTableNumber   - Accesses the PathTable offset field
//      CdSetFidDirentOffset        - Sets the Dirent offset field
//      CdSetFidPathTableNumber     - Sets the PathTable ordinal field
//      CdFidIsDirectory            - Queries if directory bit is set
//      CdFidSetDirectory           - Sets directory bit
//

#define FID_DIR_MASK  0x80000000            // high order bit means directory.

#define CdQueryFidDirentOffset(I)           ((I).LowPart & ~FID_DIR_MASK)
#define CdQueryFidPathTableOffset(I)        ((I).HighPart)
#define CdSetFidDirentOffset(I,D)           ((I).LowPart = D)
#define CdSetFidPathTableOffset(I,P)        ((I).HighPart = P)
#define CdFidIsDirectory(I)                 FlagOn( (I).LowPart, FID_DIR_MASK )
#define CdFidSetDirectory(I)                SetFlag( (I).LowPart, FID_DIR_MASK )

#define CdSetFidFromParentAndDirent(I,F,D)  {                                           \
        CdSetFidPathTableOffset( (I), CdQueryFidPathTableOffset( (F)->FileId ));        \
        CdSetFidDirentOffset( (I), (D)->DirentOffset );                                 \
        if (FlagOn( (D)->DirentFlags, CD_ATTRIBUTE_DIRECTORY )) {                       \
            CdFidSetDirectory((I));                                                     \
        }                                                                               \
}

#endif // _CDSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\close.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Cdfs called by the
    Fsd/Fsp dispatch routines.

    The close operation interacts with both the async and delayed close queues
    in the CdData structure.  Since close may be called recursively we may
    violate the locking order in acquiring the Vcb or Fcb.  In this case
    we may move the request to the async close queue.  If this is the last
    reference on the Fcb and there is a chance the user may reopen this
    file again soon we would like to defer the close.  In this case we
    may move the request to the async close queue.

    Once we are past the decode file operation there is no need for the
    file object.  If we are moving the request to either of the work
    queues then we remember all of the information from the file object and
    complete the request with STATUS_SUCCESS.  The Io system can then
    reuse the file object and we can complete the request when convenient.

    The async close queue consists of requests which we would like to
    complete as soon as possible.  They are queued using the original
    IrpContext where some of the fields have been overwritten with
    information from the file object.  We will extract this information,
    cleanup the IrpContext and then call the close worker routine.

    The delayed close queue consists of requests which we would like to
    defer the close for.  We keep size of this list within a range
    determined by the size of the system.  We let it grow to some maximum
    value and then shrink to some minimum value.  We allocate a small
    structure which contains the key information from the file object
    and use this information along with an IrpContext on the stack
    to complete the request.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CLOSE)

//
//  Local support routines
//

BOOLEAN
CdCommonClosePrivate (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN FromFsd
    );

VOID
CdQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN DelayedClose
    );

PIRP_CONTEXT
CdRemoveClose (
    IN PVCB Vcb OPTIONAL
    );

VOID
CdCloseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonClose)
#pragma alloc_text(PAGE, CdCommonClosePrivate)
#pragma alloc_text(PAGE, CdQueueClose)
#pragma alloc_text(PAGE, CdRemoveClose)
#pragma alloc_text(PAGE, CdCloseWorker)
#endif


VOID
CdFspClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to process the close queues in the CdData.  If the
    Vcb is passed then we want to remove all of the closes for this Vcb.
    Otherwise we will do as many of the delayed closes as we need to do.

Arguments:

    Vcb - If specified then we are looking for all of the closes for the
        given Vcb.

Return Value:

    None

--*/

{
    PIRP_CONTEXT IrpContext;
    IRP_CONTEXT StackIrpContext;

    THREAD_CONTEXT ThreadContext;

    PFCB Fcb;
    ULONG UserReference;

    ULONG VcbHoldCount = 0;
    PVCB CurrentVcb = NULL;

    BOOLEAN PotentialVcbTeardown = FALSE;

    PAGED_CODE();

    FsRtlEnterFileSystem();

    //
    //  Continue processing until there are no more closes to process.
    //

    while (IrpContext = CdRemoveClose( Vcb )) {

        //
        //  If we don't have an IrpContext then use the one on the stack.
        //  Initialize it for this request.
        //

        if (SafeNodeType( IrpContext ) != CDFS_NTC_IRP_CONTEXT ) {

            //
            //  Update the local values from the IrpContextLite.
            //

            Fcb = ((PIRP_CONTEXT_LITE) IrpContext)->Fcb;
            UserReference = ((PIRP_CONTEXT_LITE) IrpContext)->UserReference;

            //
            //  Update the stack irp context with the values from the
            //  IrpContextLite.
            //

            CdInitializeStackIrpContext( &StackIrpContext,
                                         (PIRP_CONTEXT_LITE) IrpContext );

            //
            //  Free the IrpContextLite.
            //

            CdFreeIrpContextLite( (PIRP_CONTEXT_LITE) IrpContext );

            //
            //  Remember we have the IrpContext from the stack.
            //

            IrpContext = &StackIrpContext;

        //
        //  Otherwise cleanup the existing IrpContext.
        //

        } else {

            //
            //  Remember the Fcb and user reference count.
            //

            Fcb = (PFCB) IrpContext->Irp;
            IrpContext->Irp = NULL;

            UserReference = (ULONG) IrpContext->ExceptionStatus;
            IrpContext->ExceptionStatus = STATUS_SUCCESS;
        }

        //
        //  We have an IrpContext.  Now we need to set the top level thread
        //  context.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FSP_FLAGS );

        //
        //  If we were given a Vcb then there is a request on top of this.
        //

        if (ARGUMENT_PRESENT( Vcb )) {

            ClearFlag( IrpContext->Flags,
                       IRP_CONTEXT_FLAG_TOP_LEVEL | IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS );
        }

        CdSetThreadContext( IrpContext, &ThreadContext );

        //
        //  If we have hit the maximum number of requests to process without
        //  releasing the Vcb then release the Vcb now.  If we are holding
        //  a different Vcb to this one then release the previous Vcb.
        //
        //  In either case acquire the current Vcb.
        //
        //  We use the MinDelayedCloseCount from the CdData since it is
        //  a convenient value based on the system size.  Only thing we are trying
        //  to do here is prevent this routine starving other threads which
        //  may need this Vcb exclusively.
        //
        //  Note that the check for potential teardown below is unsafe.  We'll 
        //  repeat later within the cddata lock.
        //

        PotentialVcbTeardown = !ARGUMENT_PRESENT( Vcb ) &&
                               (Fcb->Vcb->VcbCondition != VcbMounted) &&
                               (Fcb->Vcb->VcbCondition != VcbMountInProgress) &&
                               (Fcb->Vcb->VcbCleanup == 0);

        if (PotentialVcbTeardown ||
            (VcbHoldCount > CdData.MinDelayedCloseCount) ||
            (Fcb->Vcb != CurrentVcb)) {

            if (CurrentVcb != NULL) {

                CdReleaseVcb( IrpContext, CurrentVcb );
            }

            if (PotentialVcbTeardown) {

                CdAcquireCdData( IrpContext );

                //
                //  Repeat the checks with global lock held.  The volume could have
                //  been remounted while we didn't hold the lock.
                //

                PotentialVcbTeardown = !ARGUMENT_PRESENT( Vcb ) &&
                                       (Fcb->Vcb->VcbCondition != VcbMounted) &&
                                       (Fcb->Vcb->VcbCondition != VcbMountInProgress) &&
                                       (Fcb->Vcb->VcbCleanup == 0);
                                
                if (!PotentialVcbTeardown)  {

                    CdReleaseCdData( IrpContext);
                }
            }

            CurrentVcb = Fcb->Vcb;
            CdAcquireVcbShared( IrpContext, CurrentVcb, FALSE );

            VcbHoldCount = 0;

        } else {

            VcbHoldCount += 1;
        }

        //
        //  Call our worker routine to perform the close operation.
        //

        CdCommonClosePrivate( IrpContext, CurrentVcb, Fcb, UserReference, FALSE );

        //
        //  If the reference count on this Vcb is below our residual reference
        //  then check if we should dismount the volume.
        //

        if (PotentialVcbTeardown) {

            CdReleaseVcb( IrpContext, CurrentVcb );
            CdCheckForDismount( IrpContext, CurrentVcb, FALSE );

            CurrentVcb = NULL;

            CdReleaseCdData( IrpContext );
            PotentialVcbTeardown = FALSE;
        }

        //
        //  Complete the current request to cleanup the IrpContext.
        //

        CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
    }

    //
    //  Release any Vcb we may still hold.
    //

    if (CurrentVcb != NULL) {

        CdReleaseVcb( IrpContext, CurrentVcb );

    }

    FsRtlExitFileSystem();
}


NTSTATUS
CdCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the Fsd entry for the close operation.  We decode the file
    object to find the CDFS structures and type of open.  We call our internal
    worker routine to perform the actual work.  If the work wasn't completed
    then we post to one of our worker queues.  The Ccb isn't needed after this
    point so we delete the Ccb and return STATUS_SUCCESS to our caller in all
    cases.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    STATUS_SUCCESS

--*/

{
    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;
    ULONG UserReference = 0;

    BOOLEAN PotentialVcbTeardown = FALSE;
    BOOLEAN ForceDismount = FALSE;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Decode the file object to get the type of open and Fcb/Ccb.
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext,
                                     IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                     &Fcb,
                                     &Ccb );

    //
    //  No work to do for unopened file objects.
    //

    if (TypeOfOpen == UnopenedFileObject) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    Vcb = Fcb->Vcb;

    //
    //  Clean up any CCB associated with this open.
    //
    
    if (Ccb != NULL) {

        UserReference = 1;

        //
        //  Was a FSCTL_DISMOUNT issued on this handle?  If so,  we need to
        //  force a dismount of the volume now.
        //
        
        ForceDismount = BooleanFlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE);

        //
        //  We can always deallocate the Ccb if present.
        //

        CdDeleteCcb( IrpContext, Ccb );
    }

    //
    //  If this is the last reference to a user file or directory on a 
    //  currently mounted volume, then post it to the delayed close queue.  Note
    //  that the VcbCondition check is unsafe,  but it doesn't really matter -
    //  we just might delay the volume teardown a little by posting this close.
    //

    if ((Vcb->VcbCondition == VcbMounted) &&
        (Fcb->FcbReference == 1) &&
        ((TypeOfOpen == UserFileOpen) ||
         (TypeOfOpen == UserDirectoryOpen))) {

        CdQueueClose( IrpContext, Fcb, UserReference, TRUE );
        IrpContext = NULL;

    //
    //  Otherwise try to process this close.  Post to the async close queue
    //  if we can't acquire all of the resources.
    //

    } else {

        //
        //  If we may be dismounting this volume then acquire the CdData
        //  resource.
        //
        //  Since we now must make volumes go away as soon as reasonable after
        //  the last user handles closes, key off of the cleanup count.  It is
        //  OK to do this more than neccesary.  Since this Fcb could be holding
        //  a number of other Fcbs (and thus their references), a simple check
        //  on reference count is not appropriate.
        //
        //  Do an unsafe check first to avoid taking the (global) cddata lock in the 
        //  common case.
        //

        if (((Vcb->VcbCleanup == 0) || ForceDismount) &&
            (Vcb->VcbCondition != VcbMounted))  {

            //
            //  Possible.  Acquire CdData to synchronise with the remount path,  and
            //  then repeat the tests.
            //
            //  Note that we must send the notification outside of any locks,  since 
            //  the worker that processes the notify could also be calling into our 
            //  pnp path which wants both CdData and VcbResource.  For a force dismount
            //  the volume will be marked invalid (no going back),  so we will definitely
            //  go ahead and dismount below.
            //

            if (ForceDismount)  {
            
                //
                //  Send notification.
                //
                
                FsRtlNotifyVolumeEvent( IoGetCurrentIrpStackLocation( Irp )->FileObject, 
                                        FSRTL_VOLUME_DISMOUNT );
            }
            
            CdAcquireCdData( IrpContext );

            if (((Vcb->VcbCleanup == 0) || ForceDismount) &&
                (Vcb->VcbCondition != VcbMounted) &&
                (Vcb->VcbCondition != VcbMountInProgress) &&
                FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS ))  {

                PotentialVcbTeardown = TRUE;
            }
            else {

                //
                //  We can't dismount this volume now,  there are other references or
                //  it's just been remounted.
                //

                CdReleaseCdData( IrpContext);
            }
        }

        if (ForceDismount)  {
        
            //
            //  Physically disconnect this Vcb from the device so a new mount can
            //  occur.  Vcb deletion cannot happen at this time since there is
            //  a handle on it associated with this very request,  but we'll call
            //  check for dismount again later anyway.
            //

            CdCheckForDismount( IrpContext, Vcb, TRUE );
        }
        
        //
        //  Call the worker routine to perform the actual work.  This routine
        //  should never raise except for a fatal error.
        //

        if (!CdCommonClosePrivate( IrpContext, Vcb, Fcb, UserReference, TRUE )) {

            //
            //  If we didn't complete the request then post the request as needed.
            //

            CdQueueClose( IrpContext, Fcb, UserReference, FALSE );
            IrpContext = NULL;

        //
        //  Check whether we should be dismounting the volume and then complete
        //  the request.
        //

        } else if (PotentialVcbTeardown) {

            CdCheckForDismount( IrpContext, Vcb, FALSE );
        }
    }

    //
    //  Always complete this request with STATUS_SUCCESS.
    //

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    if (PotentialVcbTeardown) {

        CdReleaseCdData( IrpContext );
    }

    //
    //  Always return STATUS_SUCCESS for closes.
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

BOOLEAN
CdCommonClosePrivate (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN FromFsd
    )

/*++

Routine Description:

    This is the worker routine for the close operation.  We can be called in
    an Fsd thread or from a worker Fsp thread.  If called from the Fsd thread
    then we acquire the resources without waiting.  Otherwise we know it is
    safe to wait.

    We check to see whether we should post this request to the delayed close
    queue.  If we are to process the close here then we acquire the Vcb and
    Fcb.  We will adjust the counts and call our teardown routine to see
    if any of the structures should go away.

Arguments:

    Vcb - Vcb for this volume.

    Fcb - Fcb for this request.

    UserReference - Number of user references for this file object.  This is
        zero for an internal stream.

    FromFsd - This request was called from an Fsd thread.  Indicates whether
        we should wait to acquire resources.

    DelayedClose - Address to store whether we should try to put this on
        the delayed close queue.  Ignored if this routine can process this
        close.

Return Value:

    BOOLEAN - TRUE if this thread processed the close, FALSE otherwise.

--*/

{
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Try to acquire the Vcb and Fcb.  If we can't acquire them then return
    //  and let our caller know he should post the request to the async
    //  queue.
    //

    if (CdAcquireVcbShared( IrpContext, Vcb, FromFsd )) {

        if (!CdAcquireFcbExclusive( IrpContext, Fcb, FromFsd )) {

            //
            //  We couldn't get the Fcb.  Release the Vcb and let our caller
            //  know to post this request.
            //

            CdReleaseVcb( IrpContext, Vcb );
            return FALSE;
        }

    //
    //  We didn't get the Vcb.  Let our caller know to post this request.
    //

    } else {

        return FALSE;
    }

    //
    //  Lock the Vcb and decrement the reference counts.
    //

    CdLockVcb( IrpContext, Vcb );
    CdDecrementReferenceCounts( IrpContext, Fcb, 1, UserReference );
    CdUnlockVcb( IrpContext, Vcb );

    //
    //  Call our teardown routine to see if this object can go away.
    //  If we don't remove the Fcb then release it.
    //

    CdTeardownStructures( IrpContext, Fcb, &RemovedFcb );

    if (!RemovedFcb) {

        CdReleaseFcb( IrpContext, Fcb );
    }

    //
    //  Release the Vcb and return to our caller.  Let him know we completed
    //  this request.
    //

    CdReleaseVcb( IrpContext, Vcb );

    return TRUE;
}

VOID
CdCloseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    Worker routine to call CsFspClose.

Arguments:

    DeviceObject - Filesystem registration device object

    Context - Callers context

Return Value:

    None

--*/

{
    CdFspClose (NULL);
}


VOID
CdQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN DelayedClose
    )

/*++

Routine Description:

    This routine is called to queue a request to either the async or delayed
    close queue.  For the delayed queue we need to allocate a smaller
    structure to contain the information about the file object.  We do
    that so we don't put the larger IrpContext structures into this long
    lived queue.  If we can allocate this structure then we put this
    on the async queue instead.

Arguments:

    Fcb - Fcb for this file object.

    UserReference - Number of user references for this file object.  This is
        zero for an internal stream.

    DelayedClose - Indicates whether this should go on the async or delayed
        close queue.

Return Value:

    None

--*/

{
    PIRP_CONTEXT_LITE IrpContextLite = NULL;
    BOOLEAN StartWorker = FALSE;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Start with the delayed queue request.  We can move this to the async
    //  queue if there is an allocation failure.
    //

    if (DelayedClose) {

        //
        //  Try to allocate non-paged pool for the IRP_CONTEXT_LITE.
        //

        IrpContextLite = CdCreateIrpContextLite( IrpContext );
    }

    //
    //  We want to clear the top level context in this thread if
    //  necessary.  Call our cleanup routine to do the work.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
    CdCleanupIrpContext( IrpContext, TRUE );

    //
    //  Synchronize with the CdData lock.
    //

    CdLockCdData();

    //
    //  If we have an IrpContext then put the request on the delayed close queue.
    //

    if (IrpContextLite != NULL) {

        //
        //  Initialize the IrpContextLite.
        //

        IrpContextLite->NodeTypeCode = CDFS_NTC_IRP_CONTEXT_LITE;
        IrpContextLite->NodeByteSize = sizeof( IRP_CONTEXT_LITE );
        IrpContextLite->Fcb = Fcb;
        IrpContextLite->UserReference = UserReference;
        IrpContextLite->RealDevice = IrpContext->RealDevice;

        //
        //  Add this to the delayed close list and increment
        //  the count.
        //

        InsertTailList( &CdData.DelayedCloseQueue,
                        &IrpContextLite->DelayedCloseLinks );

        CdData.DelayedCloseCount += 1;

        //
        //  If we are above our threshold then start the delayed
        //  close operation.
        //

        if (CdData.DelayedCloseCount > CdData.MaxDelayedCloseCount) {

            CdData.ReduceDelayedClose = TRUE;

            if (!CdData.FspCloseActive) {

                CdData.FspCloseActive = TRUE;
                StartWorker = TRUE;
            }
        }

        //
        //  Unlock the CdData.
        //

        CdUnlockCdData();

        //
        //  Cleanup the IrpContext.
        //

        CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    //
    //  Otherwise drop into the async case below.
    //

    } else {

        //
        //  Store the information about the file object into the IrpContext.
        //

        IrpContext->Irp = (PIRP) Fcb;
        IrpContext->ExceptionStatus = (NTSTATUS) UserReference;

        //
        //  Add this to the async close list and increment the count.
        //

        InsertTailList( &CdData.AsyncCloseQueue,
                        &IrpContext->WorkQueueItem.List );

        CdData.AsyncCloseCount += 1;

        //
        //  Remember to start the Fsp close thread if not currently started.
        //

        if (!CdData.FspCloseActive) {

            CdData.FspCloseActive = TRUE;

            StartWorker = TRUE;
        }

        //
        //  Unlock the CdData.
        //

        CdUnlockCdData();
    }

    //
    //  Start the FspClose thread if we need to.
    //

    if (StartWorker) {

        IoQueueWorkItem( CdData.CloseItem, CdCloseWorker, CriticalWorkQueue, NULL );
    }

    //
    //  Return to our caller.
    //

    return;
}


//
//  Local support routine
//

PIRP_CONTEXT
CdRemoveClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

Arguments:

    This routine is called to scan the async and delayed close queues looking
    for a suitable entry.  If the Vcb is specified then we scan both queues
    looking for an entry with the same Vcb.  Otherwise we will look in the
    async queue first for any close item.  If none found there then we look
    in the delayed close queue provided that we have triggered the delayed
    close operation.

Return Value:

    PIRP_CONTEXT - NULL if no work item found.  Otherwise it is the pointer to
        either the IrpContext or IrpContextLite for this request.

--*/

{
    PIRP_CONTEXT IrpContext = NULL;
    PIRP_CONTEXT NextIrpContext;
    PIRP_CONTEXT_LITE NextIrpContextLite;

    PLIST_ENTRY Entry;

    PAGED_CODE();

    ASSERT_OPTIONAL_VCB( Vcb );

    //
    //  Lock the CdData to perform the scan.
    //

    CdLockCdData();

    //
    //  First check the list of async closes.
    //

    Entry = CdData.AsyncCloseQueue.Flink;

    while (Entry != &CdData.AsyncCloseQueue) {

        //
        //  Extract the IrpContext.
        //

        NextIrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

        //
        //  If no Vcb was specified or this Vcb is for our volume
        //  then perform the close.
        //

        if (!ARGUMENT_PRESENT( Vcb ) || (NextIrpContext->Vcb == Vcb)) {

            RemoveEntryList( Entry );
            CdData.AsyncCloseCount -= 1;

            IrpContext = NextIrpContext;
            break;
        }

        //
        //  Move to the next entry.
        //

        Entry = Entry->Flink;
    }

    //
    //  If we didn't find anything look through the delayed close
    //  queue.
    //
    //  We will only check the delayed close queue if we were given
    //  a Vcb or the delayed close operation is active.
    //

    if ((IrpContext == NULL) &&
        (ARGUMENT_PRESENT( Vcb ) ||
         (CdData.ReduceDelayedClose &&
          (CdData.DelayedCloseCount > CdData.MinDelayedCloseCount)))) {

        Entry = CdData.DelayedCloseQueue.Flink;

        while (Entry != &CdData.DelayedCloseQueue) {

            //
            //  Extract the IrpContext.
            //

            NextIrpContextLite = CONTAINING_RECORD( Entry,
                                                    IRP_CONTEXT_LITE,
                                                    DelayedCloseLinks );

            //
            //  If no Vcb was specified or this Vcb is for our volume
            //  then perform the close.
            //

            if (!ARGUMENT_PRESENT( Vcb ) || (NextIrpContextLite->Fcb->Vcb == Vcb)) {

                RemoveEntryList( Entry );
                CdData.DelayedCloseCount -= 1;

                IrpContext = (PIRP_CONTEXT) NextIrpContextLite;
                break;
            }

            //
            //  Move to the next entry.
            //

            Entry = Entry->Flink;
        }
    }

    //
    //  If the Vcb wasn't specified and we couldn't find an entry
    //  then turn off the Fsp thread.
    //

    if (!ARGUMENT_PRESENT( Vcb ) && (IrpContext == NULL)) {

        CdData.FspCloseActive = FALSE;
        CdData.ReduceDelayedClose = FALSE;
    }

    //
    //  Unlock the CdData.
    //

    CdUnlockCdData();

    return IrpContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\create.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Cdfs called by the
    Fsd/Fsp dispatch routines.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CREATE)

//
//  Local support routines
//

NTSTATUS
CdNormalizeFileNames (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OpenByFileId,
    IN BOOLEAN IgnoreCase,
    IN TYPE_OF_OPEN RelatedTypeOfOpen,
    IN PCCB RelatedCcb OPTIONAL,
    IN PUNICODE_STRING RelatedFileName OPTIONAL,
    IN OUT PUNICODE_STRING FileName,
    IN OUT PCD_NAME RemainingName
    );

NTSTATUS
CdOpenByFileId (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb
    );

NTSTATUS
CdOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB *CurrentFcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN IgnoreCase,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
CdOpenDirectoryFromPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PCD_NAME DirName,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PPATH_ENTRY PathEntry,
    IN BOOLEAN PerformUserOpen,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
CdOpenFileFromFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PCD_NAME FileName,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PFILE_ENUM_CONTEXT FileContext,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
CdCompleteFcbOpen (
    IN PIRP_CONTEXT IrpContext,
    PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ULONG UserCcbFlags,
    IN ACCESS_MASK DesiredAccess
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonCreate)
#pragma alloc_text(PAGE, CdCompleteFcbOpen)
#pragma alloc_text(PAGE, CdNormalizeFileNames)
#pragma alloc_text(PAGE, CdOpenByFileId)
#pragma alloc_text(PAGE, CdOpenDirectoryFromPathEntry)
#pragma alloc_text(PAGE, CdOpenExistingFcb)
#pragma alloc_text(PAGE, CdOpenFileFromFileContext)
#endif


NTSTATUS
CdCommonCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for opening a file called by both the
    Fsp and Fsd threads.

    The file can be opened either by name or by file Id either with or without
    a relative name.  The file name field in the file object passed to this routine
    contains either a unicode string or a 64 bit value which is the file Id.
    If this is not a Joliet disk then we will convert the unicode name to
    an Oem string in this routine.  If there is a related file object with
    a name then we will already have converted that name to Oem.

    We will store the full name for the file in the file object on a successful
    open.  We will allocate a larger buffer if necessary and combine the
    related and file object names.  The only exception is the relative open
    when the related file object is for an OpenByFileId file.  If we need to
    allocate a buffer for a case insensitive name then we allocate it at
    the tail of the buffer we will store into the file object.  The upcased
    portion will begin immediately after the name defined by the FileName
    in the file object.

    Once we have the full name in the file object we don't want to split the
    name in the event of a retry.  We use a flag in the IrpContext to indicate
    that the name has been split.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - This is the status from this open operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFILE_OBJECT FileObject;

    COMPOUND_PATH_ENTRY CompoundPathEntry;
    BOOLEAN CleanupCompoundPathEntry = FALSE;

    FILE_ENUM_CONTEXT FileContext;
    BOOLEAN CleanupFileContext = FALSE;
    BOOLEAN FoundEntry;

    PVCB Vcb;

    BOOLEAN OpenByFileId;
    BOOLEAN IgnoreCase;
    ULONG CreateDisposition;

    BOOLEAN ShortNameMatch;
    ULONG ShortNameDirentOffset;

    BOOLEAN VolumeOpen = FALSE;

    //
    //  We will be acquiring and releasing file Fcb's as we move down the
    //  directory tree during opens.  At any time we need to know the deepest
    //  point we have traversed down in the tree in case we need to cleanup
    //  any structures created here.
    //
    //  CurrentFcb - represents this point.  If non-null it means we have
    //      acquired it and need to release it in finally clause.
    //
    //  NextFcb - represents the NextFcb to walk to but haven't acquired yet.
    //

    TYPE_OF_OPEN RelatedTypeOfOpen = UnopenedFileObject;
    PFILE_OBJECT RelatedFileObject;
    PCCB RelatedCcb = NULL;

    PFCB NextFcb;
    PFCB CurrentFcb = NULL;

    //
    //  During the open we need to combine the related file object name
    //  with the remaining name.  We also may need to upcase the file name
    //  in order to do a case-insensitive name comparison.  We also need
    //  to restore the name in the file object in the event that we retry
    //  the request.  We use the following string variables to manage the
    //  name.  We will can put these strings into either Unicode or Ansi
    //  form.
    //
    //  FileName - Pointer to name as currently stored in the file
    //      object.  We store the full name into the file object early in
    //      the open operation.
    //
    //  RelatedFileName - Pointer to the name in the related file object.
    //
    //  RemainingName - String containing remaining name to parse.
    //
    //  MatchingName - Address of name structure in FileContext which matched.
    //      We need this to know whether we matched the long or short name.
    //

    PUNICODE_STRING FileName;
    PUNICODE_STRING RelatedFileName = NULL;

    CD_NAME RemainingName;
    CD_NAME FinalName;
    PCD_NAME MatchingName;

    PAGED_CODE();

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get create parameters from the Irp.
    //

    OpenByFileId = BooleanFlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID );
    IgnoreCase = !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE );
    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    //
    //  Do some preliminary checks to make sure the operation is supported.
    //  We fail in the following cases immediately.
    //
    //      - Open a paging file.
    //      - Open a target directory.
    //      - Open a file with Eas.
    //      - Create a file.
    //

    if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE | SL_OPEN_TARGET_DIRECTORY) ||
        (IrpSp->Parameters.Create.EaLength != 0) ||
        (CreateDisposition == FILE_CREATE)) {

        CdCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Copy the Vcb to a local.  Assume the starting directory is the root.
    //

    Vcb = IrpContext->Vcb;
    NextFcb = Vcb->RootIndexFcb;

    //
    //  Reference our input parameters to make things easier
    //

    FileObject = IrpSp->FileObject;
    RelatedFileObject = NULL;

    FileName = &FileObject->FileName;

    //
    //  Set up the file object's Vpb pointer in case anything happens.
    //  This will allow us to get a reasonable pop-up.
    //

    if ((FileObject->RelatedFileObject != NULL) && !OpenByFileId) {

        RelatedFileObject = FileObject->RelatedFileObject;
        FileObject->Vpb = RelatedFileObject->Vpb;

        RelatedTypeOfOpen = CdDecodeFileObject( IrpContext, RelatedFileObject, &NextFcb, &RelatedCcb );

        //
        //  Fail the request if this is not a user file object.
        //

        if (RelatedTypeOfOpen < UserVolumeOpen) {

            CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Remember the name in the related file object.
        //

        RelatedFileName = &RelatedFileObject->FileName;
    }

    //
    //  If we haven't initialized the names then make sure the strings are valid.
    //  If this an OpenByFileId then verify the file id buffer.
    //
    //  After this routine returns we know that the full name is in the
    //  FileName buffer and the buffer will hold the upcased portion
    //  of the name yet to parse immediately after the full name in the
    //  buffer.  Any trailing backslash has been removed and the flag
    //  in the IrpContext will indicate whether we removed the
    //  backslash.
    //

    Status = CdNormalizeFileNames( IrpContext,
                                   Vcb,
                                   OpenByFileId,
                                   IgnoreCase,
                                   RelatedTypeOfOpen,
                                   RelatedCcb,
                                   RelatedFileName,
                                   FileName,
                                   &RemainingName );

    //
    //  Return the error code if not successful.
    //

    if (!NT_SUCCESS( Status )) {

        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  We want to acquire the Vcb.  Exclusively for a volume open, shared otherwise.
    //  The file name is empty for a volume open.
    //

    if ((FileName->Length == 0) &&
        (RelatedTypeOfOpen <= UserVolumeOpen) &&
        !OpenByFileId) {

        VolumeOpen = TRUE;
        CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    } else {

        CdAcquireVcbShared( IrpContext, Vcb, FALSE );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify that the Vcb is not in an unusable condition.  This routine
        //  will raise if not usable.
        //

        CdVerifyVcb( IrpContext, Vcb );

        //
        //  If the Vcb is locked then we cannot open another file
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) {

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If we are opening this file by FileId then process this immediately
        //  and exit.
        //

        if (OpenByFileId) {

            //
            //  We only allow Dasd opens of audio disks.  Fail this request at
            //  this point.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK )) {

                try_return( Status = STATUS_INVALID_DEVICE_REQUEST );
            }

            //
            //  The only create disposition we allow is OPEN.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {

                try_return( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  Make sure we can wait for this request.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            try_return( Status = CdOpenByFileId( IrpContext,
                                                 IrpSp,
                                                 Vcb,
                                                 &CurrentFcb ));
        }

        //
        //  If we are opening this volume Dasd then process this immediately
        //  and exit.
        //

        if (VolumeOpen) {

            //
            //  The only create disposition we allow is OPEN.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {

                try_return( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  If they wanted to open a directory, surprise.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                try_return( Status = STATUS_NOT_A_DIRECTORY );
            }

            //
            //  Acquire the Fcb first.
            //

            CurrentFcb = Vcb->VolumeDasdFcb;
            CdAcquireFcbExclusive( IrpContext, CurrentFcb, FALSE );

            try_return( Status = CdOpenExistingFcb( IrpContext,
                                                    IrpSp,
                                                    &CurrentFcb,
                                                    UserVolumeOpen,
                                                    FALSE,
                                                    NULL ));
        }

        //
        //  At this point CurrentFcb points to the deepest Fcb for this open
        //  in the tree.  Let's acquire this Fcb to keep it from being deleted
        //  beneath us.
        //

        CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
        CurrentFcb = NextFcb;

        //
        //  Do a prefix search if there is more of the name to parse.
        //

        if (RemainingName.FileName.Length != 0) {

            //
            //  Do the prefix search to find the longest matching name.
            //

            CdFindPrefix( IrpContext,
                          &CurrentFcb,
                          &RemainingName.FileName,
                          IgnoreCase );
        }

        //
        //  If the remaining name length is zero then we have found our
        //  target.
        //

        if (RemainingName.FileName.Length == 0) {

            //
            //  If this is a file so verify the user didn't want to open
            //  a directory.
            //

            if (SafeNodeType( CurrentFcb ) == CDFS_NTC_FCB_DATA) {

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH ) ||
                    FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_NOT_A_DIRECTORY );
                }

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_return( Status = STATUS_ACCESS_DENIED );
                }

                try_return( Status = CdOpenExistingFcb( IrpContext,
                                                        IrpSp,
                                                        &CurrentFcb,
                                                        UserFileOpen,
                                                        IgnoreCase,
                                                        RelatedCcb ));

            //
            //  This is a directory.  Verify the user didn't want to open
            //  as a file.
            //

            } else if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                try_return( Status = STATUS_FILE_IS_A_DIRECTORY );

            //
            //  Open the file as a directory.
            //

            } else {

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_return( Status = STATUS_ACCESS_DENIED );
                }

                try_return( Status = CdOpenExistingFcb( IrpContext,
                                                        IrpSp,
                                                        &CurrentFcb,
                                                        UserDirectoryOpen,
                                                        IgnoreCase,
                                                        RelatedCcb ));
            }
        }

        //
        //  We have more work to do.  We have a starting Fcb which we own shared.
        //  We also have the remaining name to parse.  Walk through the name
        //  component by component looking for the full name.
        //

        //
        //  Our starting Fcb better be a directory.
        //

        if (!FlagOn( CurrentFcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

            try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
        }

        //
        //  If we can't wait then post this request.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

            CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        //
        //  Make sure the final name has no version string.
        //

        FinalName.VersionString.Length = 0;

        while (TRUE) {

            ShortNameMatch = FALSE;

            //
            //  Split off the next component from the name.
            //

            CdDissectName( IrpContext,
                           &RemainingName.FileName,
                           &FinalName.FileName );

            //
            //  Go ahead and look this entry up in the path table.
            //

            CdInitializeCompoundPathEntry( IrpContext, &CompoundPathEntry );
            CleanupCompoundPathEntry = TRUE;

            FoundEntry = CdFindPathEntry( IrpContext,
                                          CurrentFcb,
                                          &FinalName,
                                          IgnoreCase,
                                          &CompoundPathEntry );

            //
            //  If we didn't find the entry then check if the current name
            //  is a possible short name.
            //

            if (!FoundEntry) {

                ShortNameDirentOffset = CdShortNameDirentOffset( IrpContext, &FinalName.FileName );

                //
                //  If there is an embedded short name offset then look for the
                //  matching long name in the directory.
                //

                if (ShortNameDirentOffset != MAXULONG) {

                    if (CleanupFileContext) {

                        CdCleanupFileContext( IrpContext, &FileContext );
                    }

                    CdInitializeFileContext( IrpContext, &FileContext );
                    CleanupFileContext = TRUE;

                    FoundEntry = CdFindFileByShortName( IrpContext,
                                                        CurrentFcb,
                                                        &FinalName,
                                                        IgnoreCase,
                                                        ShortNameDirentOffset,
                                                        &FileContext );

                    //
                    //  If we found an entry and it is a directory then look
                    //  this up in the path table.
                    //

                    if (FoundEntry) {

                        ShortNameMatch = TRUE;

                        if (FlagOn( FileContext.InitialDirent->Dirent.DirentFlags,
                                    CD_ATTRIBUTE_DIRECTORY )) {

                            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
                            CdInitializeCompoundPathEntry( IrpContext, &CompoundPathEntry );

                            FoundEntry = CdFindPathEntry( IrpContext,
                                                          CurrentFcb,
                                                          &FileContext.InitialDirent->Dirent.CdCaseFileName,
                                                          IgnoreCase,
                                                          &CompoundPathEntry );

                            //
                            //  We better find this entry.
                            //

                            if (!FoundEntry) {

                                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                            }

                            //
                            //  Upcase the name with the short name if case
                            //  insensitive.
                            //

                            if (IgnoreCase) {

                                CdUpcaseName( IrpContext, &FinalName, &FinalName );
                            }

                        //
                        //  We found a matching file.  If we are at the last
                        //  entry then break out of the loop and open the
                        //  file below.  Otherwise we return an error.
                        //

                        } else if (RemainingName.FileName.Length == 0) {

                            //
                            //  Break out of the loop.  We will process the dirent
                            //  below.
                            //

                            MatchingName = &FileContext.ShortName;
                            break;

                        } else {

                            try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                        }
                    }
                }

                //
                //  We didn't find the name in either the path table or as
                //  a short name in a directory.  If the remaining name
                //  length is zero then break out of the loop to search
                //  the directory.
                //

                if (!FoundEntry) {

                    if (RemainingName.FileName.Length == 0) {

                        break;

                    //
                    //  Otherwise this path could not be cracked.
                    //

                    } else {

                        try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                    }
                }
            }

            //
            //  If this is an ignore case open then copy the exact case
            //  in the file object name.  If it was a short name match then
            //  the name must be upcase already.
            //

            if (IgnoreCase && !ShortNameMatch) {

                RtlCopyMemory( FinalName.FileName.Buffer,
                               CompoundPathEntry.PathEntry.CdDirName.FileName.Buffer,
                               CompoundPathEntry.PathEntry.CdDirName.FileName.Length );
            }

            //
            //  If we have found the last component then open this as a directory
            //  and return to our caller.
            //

            if (RemainingName.FileName.Length == 0) {

                if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_FILE_IS_A_DIRECTORY );
                }

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_return( Status = STATUS_ACCESS_DENIED );
                }

                try_return( Status = CdOpenDirectoryFromPathEntry( IrpContext,
                                                                   IrpSp,
                                                                   Vcb,
                                                                   &CurrentFcb,
                                                                   &FinalName,
                                                                   IgnoreCase,
                                                                   ShortNameMatch,
                                                                   &CompoundPathEntry.PathEntry,
                                                                   TRUE,
                                                                   RelatedCcb ));
            }

            //
            //  Otherwise open an Fcb for this intermediate index Fcb.
            //

            CdOpenDirectoryFromPathEntry( IrpContext,
                                          IrpSp,
                                          Vcb,
                                          &CurrentFcb,
                                          &FinalName,
                                          IgnoreCase,
                                          ShortNameMatch,
                                          &CompoundPathEntry.PathEntry,
                                          FALSE,
                                          NULL );

            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
            CleanupCompoundPathEntry = FALSE;
        }

        //
        //  We need to scan the current directory for a matching file name
        //  if we don't already have one.
        //

        if (!FoundEntry) {

            if (CleanupFileContext) {

                CdCleanupFileContext( IrpContext, &FileContext );
            }

            CdInitializeFileContext( IrpContext, &FileContext );
            CleanupFileContext = TRUE;

            //
            //  Split our search name into separate components.
            //

            CdConvertNameToCdName( IrpContext, &FinalName );

            FoundEntry = CdFindFile( IrpContext,
                                     CurrentFcb,
                                     &FinalName,
                                     IgnoreCase,
                                     &FileContext,
                                     &MatchingName );
        }

        //
        //  If we didn't find a match then check if the name is invalid to
        //  determine which error code to return.
        //

        if (!FoundEntry) {

            if ((CreateDisposition == FILE_OPEN) ||
                (CreateDisposition == FILE_OVERWRITE)) {

                try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
            }

            //
            //  Any other operation return STATUS_ACCESS_DENIED.
            //

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If this is a directory then the disk is corrupt because it wasn't
        //  in the Path Table.
        //

        if (FlagOn( FileContext.InitialDirent->Dirent.Flags, CD_ATTRIBUTE_DIRECTORY )) {

            CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  Make sure our opener didn't want a directory.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH ) ||
            FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

            try_return( Status = STATUS_NOT_A_DIRECTORY );
        }

        //
        //  The only create disposition we allow is OPEN.
        //

        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If this is an ignore case open then copy the exact case
        //  in the file object name.  Any version portion should
        //  already be upcased.
        //

        if (IgnoreCase) {

            RtlCopyMemory( FinalName.FileName.Buffer,
                           MatchingName->FileName.Buffer,
                           MatchingName->FileName.Length );
        }

        //
        //  Open the file using the file context.  We already have the
        //  first and last dirents.
        //

        try_return( Status = CdOpenFileFromFileContext( IrpContext,
                                                        IrpSp,
                                                        Vcb,
                                                        &CurrentFcb,
                                                        &FinalName,
                                                        IgnoreCase,
                                                        (BOOLEAN) (MatchingName == &FileContext.ShortName),
                                                        &FileContext,
                                                        RelatedCcb ));

    try_exit:  NOTHING;
    } finally {

        //
        //  Cleanup the PathEntry if initialized.
        //

        if (CleanupCompoundPathEntry) {

            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
        }

        //
        //  Cleanup the FileContext if initialized.
        //

        if (CleanupFileContext) {

            CdCleanupFileContext( IrpContext, &FileContext );
        }

        //
        //  The result of this open could be success, pending or some error
        //  condition.
        //

        if (AbnormalTermination()) {


            //
            //  In the error path we start by calling our teardown routine if we
            //  have a CurrentFcb.
            //

            if (CurrentFcb != NULL) {

                BOOLEAN RemovedFcb;

                CdTeardownStructures( IrpContext, CurrentFcb, &RemovedFcb );

                if (RemovedFcb) {

                    CurrentFcb = NULL;
                }
            }

            //
            //  No need to complete the request.
            //

            IrpContext = NULL;
            Irp = NULL;

        //
        //  If we posted this request through the oplock package we need
        //  to show that there is no reason to complete the request.
        //

        } else if (Status == STATUS_PENDING) {

            IrpContext = NULL;
            Irp = NULL;
        }

        //
        //  Release the Current Fcb if still acquired.
        //

        if (CurrentFcb != NULL) {

            CdReleaseFcb( IrpContext, CurrentFcb );
        }

        //
        //  Release the Vcb.
        //

        CdReleaseVcb( IrpContext, Vcb );

        //
        //  Call our completion routine.  It will handle the case where either
        //  the Irp and/or IrpContext are gone.
        //

        CdCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdNormalizeFileNames (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OpenByFileId,
    IN BOOLEAN IgnoreCase,
    IN TYPE_OF_OPEN RelatedTypeOfOpen,
    IN PCCB RelatedCcb OPTIONAL,
    IN PUNICODE_STRING RelatedFileName OPTIONAL,
    IN OUT PUNICODE_STRING FileName,
    IN OUT PCD_NAME RemainingName
    )

/*++

Routine Description:

    This routine is called to store the full name and upcased name into the
    filename buffer.  We only upcase the portion yet to parse.  We also
    check for a trailing backslash and lead-in double backslashes.  This
    routine also verifies the mode of the related open against the name
    currently in the filename.

Arguments:

    Vcb - Vcb for this volume.

    OpenByFileId - Indicates if the filename should be a 64 bit FileId.

    IgnoreCase - Indicates if this open is a case-insensitive operation.

    RelatedTypeOfOpen - Indicates the type of the related file object.

    RelatedCcb - Ccb for the related open.  Ignored if no relative open.

    RelatedFileName - FileName buffer for related open.  Ignored if no
        relative open.

    FileName - FileName to update in this routine.  The name should
        either be a 64-bit FileId or a Unicode string.

    RemainingName - Name with the remaining portion of the name.  This
        will begin after the related name and any separator.  For a
        non-relative open we also step over the initial separator.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the names are OK, appropriate error code
        otherwise.

--*/

{
    ULONG RemainingNameLength;
    ULONG RelatedNameLength = 0;
    ULONG SeparatorLength = 0;

    ULONG BufferLength;

    UNICODE_STRING NewFileName;

    PAGED_CODE();

    //
    //  If this is the first pass then we need to build the full name and
    //  check for name compatibility.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FULL_NAME )) {

        //
        //  Deal with the regular file name case first.
        //

        if (!OpenByFileId) {

            //
            //  This is here because the Win32 layer can't avoid sending me double
            //  beginning backslashes.
            //
            
            if ((FileName->Length > sizeof( WCHAR )) &&
                (FileName->Buffer[1] == L'\\') &&
                (FileName->Buffer[0] == L'\\')) {

                //
                //  If there are still two beginning backslashes, the name is bogus.
                //

                if ((FileName->Length > 2 * sizeof( WCHAR )) &&
                    (FileName->Buffer[2] == L'\\')) {

                    return STATUS_OBJECT_NAME_INVALID;
                }

                //
                //  Slide the name down in the buffer.
                //

                FileName->Length -= sizeof( WCHAR );

                RtlMoveMemory( FileName->Buffer,
                               FileName->Buffer + 1,
                               FileName->Length );
            }

            //
            //  Check for a trailing backslash.  Don't strip off if only character
            //  in the full name or for relative opens where this is illegal.
            //

            if (((FileName->Length > sizeof( WCHAR)) ||
                 ((FileName->Length == sizeof( WCHAR )) && (RelatedTypeOfOpen == UserDirectoryOpen))) &&
                (FileName->Buffer[ (FileName->Length/2) - 1 ] == L'\\')) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH );
                FileName->Length -= sizeof( WCHAR );
            }

            //
            //  Remember the length we need for this portion of the name.
            //

            RemainingNameLength = FileName->Length;

            //
            //  If this is a related file object then we verify the compatibility
            //  of the name in the file object with the relative file object.
            //

            if (RelatedTypeOfOpen != UnopenedFileObject) {

                //
                //  If the filename length was zero then it must be legal.
                //  If there are characters then check with the related
                //  type of open.
                //

                if (FileName->Length != 0) {

                    //
                    //  The name length must always be zero for a volume open.
                    //

                    if (RelatedTypeOfOpen <= UserVolumeOpen) {

                        return STATUS_INVALID_PARAMETER;

                    //
                    //  The remaining name cannot begin with a backslash.
                    //

                    } else if (FileName->Buffer[0] == L'\\' ) {

                        return STATUS_INVALID_PARAMETER;

                    //
                    //  If the related file is a user file then there
                    //  is no file with this path.
                    //

                    } else if (RelatedTypeOfOpen == UserFileOpen) {

                        return STATUS_OBJECT_PATH_NOT_FOUND;
                    }
                }

                //
                //  Remember the length of the related name when building
                //  the full name.  We leave the RelatedNameLength and
                //  SeparatorLength at zero if the relative file is opened
                //  by Id.
                //

                if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    //
                    //  Add a separator if the name length is non-zero
                    //  unless the relative Fcb is at the root.
                    //

                    if ((FileName->Length != 0) &&
                        (RelatedCcb->Fcb != Vcb->RootIndexFcb)) {

                        SeparatorLength = sizeof( WCHAR );
                    }

                    RelatedNameLength = RelatedFileName->Length;
                }

            //
            //  The full name is already in the filename.  It must either
            //  be length 0 or begin with a backslash.
            //

            } else if (FileName->Length != 0) {

                if (FileName->Buffer[0] != L'\\') {

                    return STATUS_INVALID_PARAMETER;
                }

                //
                //  We will want to trim the leading backslash from the
                //  remaining name we return.
                //

                RemainingNameLength -= sizeof( WCHAR );
                SeparatorLength = sizeof( WCHAR );
            }

            //
            //  Now see if the buffer is large enough to hold the full name.
            //

            BufferLength = RelatedNameLength + SeparatorLength + RemainingNameLength;

            //
            //  Check for an overflow of the maximum filename size.
            //
            
            if (BufferLength > MAXUSHORT) {

                return STATUS_INVALID_PARAMETER;
            }
            
            //
            //  Now see if we need to allocate a new buffer.
            //

            if (FileName->MaximumLength < BufferLength) {

                NewFileName.Buffer = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                               BufferLength,
                                                               TAG_FILE_NAME );

                NewFileName.MaximumLength = (USHORT) BufferLength;

            } else {

                NewFileName.Buffer = FileName->Buffer;
                NewFileName.MaximumLength = FileName->MaximumLength;
            }

            //
            //  If there is a related name then we need to slide the remaining bytes up and
            //  insert the related name.  Otherwise the name is in the correct position
            //  already.
            //

            if (RelatedNameLength != 0) {

                //
                //  Store the remaining name in its correct position.
                //

                if (RemainingNameLength != 0) {

                    RtlMoveMemory( Add2Ptr( NewFileName.Buffer, RelatedNameLength + SeparatorLength, PVOID ),
                                   FileName->Buffer,
                                   RemainingNameLength );
                }

                RtlCopyMemory( NewFileName.Buffer,
                               RelatedFileName->Buffer,
                               RelatedNameLength );

                //
                //  Add the separator if needed.
                //

                if (SeparatorLength != 0) {

                    *(Add2Ptr( NewFileName.Buffer, RelatedNameLength, PWCHAR )) = L'\\';
                }

                //
                //  Update the filename value we got from the user.
                //

                if (NewFileName.Buffer != FileName->Buffer) {

                    if (FileName->Buffer != NULL) {

                        ExFreePool( FileName->Buffer );
                    }

                    FileName->Buffer = NewFileName.Buffer;
                    FileName->MaximumLength = NewFileName.MaximumLength;
                }

                //
                //  Copy the name length to the user's filename.
                //

                FileName->Length = (USHORT) (RelatedNameLength + SeparatorLength + RemainingNameLength);
            }

            //
            //  Now update the remaining name to parse.
            //

            RemainingName->FileName.MaximumLength =
            RemainingName->FileName.Length = (USHORT) RemainingNameLength;
            RemainingName->VersionString.Length = 0;

            RemainingName->FileName.Buffer = Add2Ptr( FileName->Buffer,
                                                      RelatedNameLength + SeparatorLength,
                                                      PWCHAR );

            //
            //  Upcase the name if necessary.
            //

            if (IgnoreCase && (RemainingNameLength != 0)) {

                CdUpcaseName( IrpContext,
                              RemainingName,
                              RemainingName );
            }

            //
            //  Do a quick check to make sure there are no wildcards.
            //

            if (FsRtlDoesNameContainWildCards( &RemainingName->FileName )) {

                return STATUS_OBJECT_NAME_INVALID;
            }

        //
        //  For the open by file Id case we verify the name really contains
        //  a 64 bit value.
        //

        } else {

            //
            //  Check for validity of the buffer.
            //

            if (FileName->Length != sizeof( FILE_ID )) {

                return STATUS_INVALID_PARAMETER;
            }
        }

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FULL_NAME );

    //
    //  If we are in the retry path then the full name is already in the
    //  file object name.  If this is a case-sensitive operation then
    //  we need to upcase the name from the end of any related file name already stored
    //  there.
    //

    } else {

        //
        //  Assume there is no relative name.
        //

        RemainingName->FileName = *FileName;
        RemainingName->VersionString.Length = 0;

        //
        //  Nothing to do if the name length is zero.
        //

        if (RemainingName->FileName.Length != 0) {

            //
            //  If there is a relative name then we need to walk past it.
            //

            if (RelatedTypeOfOpen != UnopenedFileObject) {

                //
                //  Nothing to walk past if the RelatedCcb is opened by FileId.
                //


                if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    //
                    //  Related file name is a proper prefix of the full name.
                    //  We step over the related name and if we are then
                    //  pointing at a separator character we step over that.
                    //

                    RemainingName->FileName.Buffer = Add2Ptr( RemainingName->FileName.Buffer,
                                                              RelatedFileName->Length,
                                                              PWCHAR );

                    RemainingName->FileName.Length -= RelatedFileName->Length;
                }
            }

            //
            //  If we are pointing at a separator character then step past that.
            //

            if (RemainingName->FileName.Length != 0) {

                if (*(RemainingName->FileName.Buffer) == L'\\') {

                    RemainingName->FileName.Buffer = Add2Ptr( RemainingName->FileName.Buffer,
                                                              sizeof( WCHAR ),
                                                              PWCHAR );

                    RemainingName->FileName.Length -= sizeof( WCHAR );
                }
            }
        }

        //
        //  Upcase the name if necessary.
        //

        if (IgnoreCase && (RemainingName->FileName.Length != 0)) {

            CdUpcaseName( IrpContext,
                          RemainingName,
                          RemainingName );
        }
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdOpenByFileId (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb
    )

/*++

Routine Description:

    This routine is called to open a file by the FileId.  The file Id is in
    the FileObject name buffer and has been verified to be 64 bits.

    We extract the Id number and then check to see whether we are opening a
    file or directory and compare that with the create options.  If this
    generates no error then optimistically look up the Fcb in the Fcb Table.

    If we don't find the Fcb then we need to carefully verify there is a file
    at this offset.  First check whether the Parent Fcb is in the table.  If
    not then lookup the parent at the path table offset given by file ID.

    If found then build the Fcb from this entry and store the new Fcb in the
    tree.

    We know have the parent Fcb.  Do a directory scan to find the dirent at
    the given offset in this stream.  This must point to the first entry
    of a valid file.

    Finally we call our worker routine to complete the open on this Fcb.

Arguments:

    IrpSp - Stack location within the create Irp.

    Vcb - Vcb for this volume.

    CurrentFcb - Address to store the Fcb for this open.  We only store the
        CurrentFcb here when we have acquired it so our caller knows to
        free or deallocate it.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_ACCESS_DENIED;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN Found;

    ULONG StreamOffset;

    NODE_TYPE_CODE NodeTypeCode;
    TYPE_OF_OPEN TypeOfOpen;

    FILE_ENUM_CONTEXT FileContext;
    BOOLEAN CleanupFileContext = FALSE;

    COMPOUND_PATH_ENTRY CompoundPathEntry;
    BOOLEAN CleanupCompoundPathEntry = FALSE;

    FILE_ID FileId;
    FILE_ID ParentFileId;

    PFCB NextFcb;

    PAGED_CODE();

    //
    //  Extract the FileId from the FileObject.
    //

    RtlCopyMemory( &FileId, IrpSp->FileObject->FileName.Buffer, sizeof( FILE_ID ));

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Go ahead and figure out the TypeOfOpen and NodeType.  We can
        //  get these from the input FileId.
        //

        if (CdFidIsDirectory( FileId )) {

            TypeOfOpen = UserDirectoryOpen;
            NodeTypeCode = CDFS_NTC_FCB_INDEX;

            //
            //  If the offset isn't zero then the file Id is bad.
            //

            if (CdQueryFidDirentOffset( FileId ) != 0) {

                try_return( Status = STATUS_INVALID_PARAMETER );
            }

        } else {

            TypeOfOpen = UserFileOpen;
            NodeTypeCode = CDFS_NTC_FCB_DATA;
        }

        //
        //  Acquire the Vcb and check if there is already an Fcb.
        //  If not we will need to carefully verify the Fcb.
        //  We will post the request if we don't find the Fcb and this
        //  request can't wait.
        //

        CdLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        NextFcb = CdLookupFcbTable( IrpContext, Vcb, FileId );

        if (NextFcb == NULL) {

            //
            //  Get the path table offset from the file id.
            //

            StreamOffset = CdQueryFidPathTableOffset( FileId );

            //
            //  Build the parent FileId for this and try looking it
            //  up in the PathTable.
            //

            CdSetFidDirentOffset( ParentFileId, 0 );
            CdSetFidPathTableOffset( ParentFileId, StreamOffset );
            CdFidSetDirectory( ParentFileId );

            NextFcb = CdLookupFcbTable( IrpContext, Vcb, ParentFileId );

            //
            //  If not present then walk through the PathTable to this point.
            //

            if (NextFcb == NULL) {

                CdUnlockVcb( IrpContext, Vcb );
                UnlockVcb = FALSE;

                //
                //  Check that the path table offset lies within the path
                //  table.
                //

                if (StreamOffset > Vcb->PathTableFcb->FileSize.LowPart) {

                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                CdInitializeCompoundPathEntry( IrpContext, &CompoundPathEntry );
                CleanupCompoundPathEntry = TRUE;

                //
                //  Start at the first entry in the PathTable.
                //

                CdLookupPathEntry( IrpContext,
                                   Vcb->PathTableFcb->StreamOffset,
                                   1,
                                   TRUE,
                                   &CompoundPathEntry );

                //
                //  Continue looking until we have passed our target offset.
                //

                while (TRUE) {

                    //
                    //  Move to the next entry.
                    //

                    Found = CdLookupNextPathEntry( IrpContext,
                                                   &CompoundPathEntry.PathContext,
                                                   &CompoundPathEntry.PathEntry );

                    //
                    //  If we didn't find the entry or are beyond it then the
                    //  input Id is invalid.
                    //

                    if (!Found ||
                        (CompoundPathEntry.PathEntry.PathTableOffset > StreamOffset)) {

                        try_return( Status = STATUS_INVALID_PARAMETER );
                    }
                }

                //
                //  If the FileId specified a directory then we have found
                //  the entry.  Make sure our caller wanted to open a directory.
                //

                if ((TypeOfOpen == UserDirectoryOpen) &&
                    FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_FILE_IS_A_DIRECTORY );
                }

                //
                //  Lock the Vcb and create the Fcb if necessary.
                //

                CdLockVcb( IrpContext, Vcb );
                UnlockVcb = TRUE;

                NextFcb = CdCreateFcb( IrpContext, ParentFileId, NodeTypeCode, &Found );

                //
                //  It's possible that someone got in here ahead of us.
                //

                if (!Found) {

                    CdInitializeFcbFromPathEntry( IrpContext,
                                                  NextFcb,
                                                  NULL,
                                                  &CompoundPathEntry.PathEntry );
                }

                //
                //  If the user wanted to open a directory then we have found
                //  it.  Store this Fcb into the CurrentFcb and skip the
                //  directory scan.
                //

                if (TypeOfOpen == UserDirectoryOpen) {

                    *CurrentFcb = NextFcb;
                    NextFcb = NULL;
                }
            }

            //
            //  Perform the directory scan if we don't already have our target.
            //

            if (NextFcb != NULL) {

                //
                //  Acquire the parent.  We currently own the Vcb lock so
                //  do this without waiting first.
                //

                if (!CdAcquireFcbExclusive( IrpContext,
                                            NextFcb,
                                            TRUE )) {

                    NextFcb->FcbReference += 1;
                    CdUnlockVcb( IrpContext, Vcb );

                    CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );

                    CdLockVcb( IrpContext, Vcb );
                    NextFcb->FcbReference -= 1;
                    CdUnlockVcb( IrpContext, Vcb );

                } else {

                    CdUnlockVcb( IrpContext, Vcb );
                }

                UnlockVcb = FALSE;

                //
                //  Set up the CurrentFcb pointers.  We know there was
                //  no previous parent in this case.
                //

                *CurrentFcb = NextFcb;

                //
                //  Calculate the offset in the stream.
                //

                StreamOffset = CdQueryFidDirentOffset( FileId );

                //
                //  Create the stream file if it doesn't exist.  This will update
                //  the Fcb with the size from the self entry.
                //

                if (NextFcb->FileObject == NULL) {

                    CdCreateInternalStream( IrpContext, Vcb, NextFcb );
                }

                //
                //  If our offset is beyond the end of the directory then the
                //  FileId is invalid.
                //

                if (StreamOffset > NextFcb->FileSize.LowPart) {

                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  Otherwise position ourselves at the self entry and walk
                //  through dirent by dirent until this location is found.
                //

                CdInitializeFileContext( IrpContext, &FileContext );
                CdLookupInitialFileDirent( IrpContext,
                                           NextFcb,
                                           &FileContext,
                                           NextFcb->StreamOffset );

                CleanupFileContext = TRUE;

                while (TRUE) {

                    //
                    //  Move to the first entry of the next file.
                    //

                    Found = CdLookupNextInitialFileDirent( IrpContext,
                                                           NextFcb,
                                                           &FileContext );

                    //
                    //  If we didn't find the entry or are beyond it then the
                    //  input Id is invalid.
                    //

                    if (!Found ||
                        (FileContext.InitialDirent->Dirent.DirentOffset > StreamOffset)) {

                        try_return( Status = STATUS_INVALID_PARAMETER );
                    }
                }

                //
                //  This better not be a directory.  Directory FileIds must
                //  refer to the self entry for directories.
                //

                if (FlagOn( FileContext.InitialDirent->Dirent.DirentFlags,
                            CD_ATTRIBUTE_DIRECTORY )) {

                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  Check that our caller wanted to open a file.
                //

                if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_NOT_A_DIRECTORY );
                }

                //
                //  Otherwise we want to collect all of the dirents for this file
                //  and create an Fcb with this.
                //

                CdLookupLastFileDirent( IrpContext, NextFcb, &FileContext );

                CdLockVcb( IrpContext, Vcb );
                UnlockVcb = TRUE;

                NextFcb = CdCreateFcb( IrpContext, FileId, NodeTypeCode, &Found );

                //
                //  It's possible that someone has since created this Fcb since we
                //  first checked.  If so then can simply use this.  Otherwise
                //  we need to initialize a new Fcb and attach it to our parent
                //  and insert it into the Fcb Table.
                //

                if (!Found) {

                    CdInitializeFcbFromFileContext( IrpContext,
                                                    NextFcb,
                                                    *CurrentFcb,
                                                    &FileContext );
                }
            }

        //
        //  We have the Fcb.  Check that the type of the file is compatible with
        //  the desired type of file to open.
        //

        } else {

            if (FlagOn( NextFcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_FILE_IS_A_DIRECTORY );
                }

            } else if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                try_return( Status = STATUS_NOT_A_DIRECTORY );
            }
        }

        //
        //  If we have a the previous Fcb and have inserted the next Fcb into
        //  the Fcb Table.  It is safe to release the current Fcb if present
        //  since it is referenced through the child Fcb.
        //

        if (*CurrentFcb != NULL) {

            CdReleaseFcb( IrpContext, *CurrentFcb );
        }

        //
        //  We now know the Fcb and currently hold the Vcb lock.
        //  Try to acquire this Fcb without waiting.  Otherwise we
        //  need to reference it, drop the Vcb, acquire the Fcb and
        //  then dereference the Fcb.
        //

        if (!CdAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;

            CdUnlockVcb( IrpContext, Vcb );

            CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );

            CdLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
            CdUnlockVcb( IrpContext, Vcb );

        } else {

            CdUnlockVcb( IrpContext, Vcb );
        }

        UnlockVcb = FALSE;

        //
        //  Move to this Fcb.
        //

        *CurrentFcb = NextFcb;

        //
        //  Check the requested access on this Fcb.
        //

        if (!CdIllegalFcbAccess( IrpContext,
                                 TypeOfOpen,
                                 IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

            //
            //  Call our worker routine to complete the open.
            //

            Status = CdCompleteFcbOpen( IrpContext,
                                        IrpSp,
                                        Vcb,
                                        CurrentFcb,
                                        TypeOfOpen,
                                        CCB_FLAG_OPEN_BY_ID,
                                        IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
        }

    try_exit:  NOTHING;
    } finally {

        if (UnlockVcb) {

            CdUnlockVcb( IrpContext, Vcb );
        }

        if (CleanupFileContext) {

            CdCleanupFileContext( IrpContext, &FileContext );
        }

        if (CleanupCompoundPathEntry) {

            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB *CurrentFcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN IgnoreCase,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open an Fcb which is already in the Fcb table.
    We will verify the access to the file and then call our worker routine
    to perform the final operations.

Arguments:

    IrpSp - Pointer to the stack location for this open.

    CurrentFcb - Address of Fcb to open.  We will clear this if the Fcb
        is released here.

    TypeOfOpen - Indicates whether we are opening a file, directory or volume.

    IgnoreCase - Indicates if this open is case-insensitive.

    RelatedCcb - Ccb for related file object if relative open.  We use
        this when setting the Ccb flags for this open.  It will tell
        us whether the name currently in the file object is relative or
        absolute.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;

    NTSTATUS Status = STATUS_ACCESS_DENIED;

    PAGED_CODE();

    //
    //  Check that the desired access is legal.
    //

    if (!CdIllegalFcbAccess( IrpContext,
                             TypeOfOpen,
                             IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        //
        //  Set the Ignore case.
        //

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Check the related Ccb to see if this was an OpenByFileId and
        //  whether there was a version.
        //

        if (ARGUMENT_PRESENT( RelatedCcb )) {

            SetFlag( CcbFlags, FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_WITH_VERSION ));


            if (FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

                SetFlag( CcbFlags, CCB_FLAG_OPEN_RELATIVE_BY_ID );
            }
        }

        //
        //  Call our worker routine to complete the open.
        //

        Status = CdCompleteFcbOpen( IrpContext,
                                    IrpSp,
                                    (*CurrentFcb)->Vcb,
                                    CurrentFcb,
                                    TypeOfOpen,
                                    CcbFlags,
                                    IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdOpenDirectoryFromPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PCD_NAME DirName,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PPATH_ENTRY PathEntry,
    IN BOOLEAN PerformUserOpen,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open a directory where the directory was found
    in the path table.  This routine is called in the case where this is the
    file to open for the user and where this is an intermediate node in the
    full path to open.

    We first check that the desired access is legal for a directory.  Then we
    construct the FileId for this and do a check to see if it is the Fcb
    Table.  It is always possible that either it was created since or simply
    wasn't in the prefix table at the time of the prefix table search.
    Initialize the Fcb and store into the FcbTable if not present.

    Next we will add this to the prefix table of our parent if needed.

    Once we know that the new Fcb has been initialized then we move our pointer
    in the tree down to this position.

    This routine does not own the Vcb lock on entry.  We must be sure to release
    it on exit.

Arguments:

    IrpSp - Stack location for this request.

    Vcb - Vcb for this volume.

    CurrentFcb - On input this is the parent of the Fcb to open.  On output we
        store the Fcb for the file being opened.

    DirName - This is always the exact name used to reach this file.

    IgnoreCase - Indicates the type of case match for the open.

    ShortNameMatch - Indicates if we are opening via the short name.

    PathEntry - Path entry for the entry found.

    PerformUserOpen - TRUE if we are to open this for a user, FALSE otherwise.

    RelatedCcb - RelatedCcb for relative file object used to make this open.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;
    FILE_ID FileId;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN FcbExisted;

    PFCB NextFcb;
    PFCB ParentFcb = NULL;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check for illegal access to this file.
    //

    if (PerformUserOpen &&
        CdIllegalFcbAccess( IrpContext,
                            UserDirectoryOpen,
                            IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        return STATUS_ACCESS_DENIED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Check the related Ccb to see if this was an OpenByFileId.
        //

        if (ARGUMENT_PRESENT( RelatedCcb ) &&
            FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

            CcbFlags = CCB_FLAG_OPEN_RELATIVE_BY_ID;
        }

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Build the file Id for this file.
        //

        FileId.QuadPart = 0;
        CdSetFidPathTableOffset( FileId, PathEntry->PathTableOffset );
        CdFidSetDirectory( FileId );

        //
        //  Lock the Vcb so we can examine the Fcb Table.
        //

        CdLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        //
        //  Get the Fcb for this directory.
        //

        NextFcb = CdCreateFcb( IrpContext, FileId, CDFS_NTC_FCB_INDEX, &FcbExisted );

        //
        //  If the Fcb was created here then initialize from the values in the
        //  path table entry.
        //

        if (!FcbExisted) {

            CdInitializeFcbFromPathEntry( IrpContext, NextFcb, *CurrentFcb, PathEntry );
        }

        //
        //  Now try to acquire the new Fcb without waiting.  We will reference
        //  the Fcb and retry with wait if unsuccessful.
        //

        if (!CdAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;

            CdUnlockVcb( IrpContext, Vcb );

            CdReleaseFcb( IrpContext, *CurrentFcb );
            CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
            CdAcquireFcbExclusive( IrpContext, *CurrentFcb, FALSE );

            CdLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
            CdUnlockVcb( IrpContext, Vcb );

        } else {

            //
            //  Unlock the Vcb and move down to this new Fcb.  Remember that we still
            //  own the parent however.
            //

            CdUnlockVcb( IrpContext, Vcb );
        }

        UnlockVcb = FALSE;

        ParentFcb = *CurrentFcb;
        *CurrentFcb = NextFcb;

        //
        //  Store this name into the prefix table for the parent.
        //

        if (ShortNameMatch) {

            //
            //  Make sure the exact case is always in the tree.
            //

            CdInsertPrefix( IrpContext,
                            NextFcb,
                            DirName,
                            FALSE,
                            TRUE,
                            ParentFcb );

            if (IgnoreCase) {

                CdInsertPrefix( IrpContext,
                                NextFcb,
                                DirName,
                                TRUE,
                                TRUE,
                                ParentFcb );
            }

        } else {

            //
            //  Make sure the exact case is always in the tree.
            //

            CdInsertPrefix( IrpContext,
                            NextFcb,
                            &PathEntry->CdDirName,
                            FALSE,
                            FALSE,
                            ParentFcb );

            if (IgnoreCase) {

                CdInsertPrefix( IrpContext,
                                NextFcb,
                                &PathEntry->CdCaseDirName,
                                TRUE,
                                FALSE,
                                ParentFcb );
            }
        }

        //
        //  Release the parent Fcb at this point.
        //

        CdReleaseFcb( IrpContext, ParentFcb );
        ParentFcb = NULL;

        //
        //  Call our worker routine to complete the open.
        //

        if (PerformUserOpen) {

            Status = CdCompleteFcbOpen( IrpContext,
                                        IrpSp,
                                        Vcb,
                                        CurrentFcb,
                                        UserDirectoryOpen,
                                        CcbFlags,
                                        IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
        }

    } finally {

        //
        //  Unlock the Vcb if held.
        //

        if (UnlockVcb) {

            CdUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Release the parent if held.
        //

        if (ParentFcb != NULL) {

            CdReleaseFcb( IrpContext, ParentFcb );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdOpenFileFromFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PCD_NAME FileName,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PFILE_ENUM_CONTEXT FileContext,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open a file where the file was found in a directory scan.
    This should only be for a file in the case since we will find the directories in the
    path table.

    We first check that the desired access is legal for this file.  Then we
    construct the FileId for this and do a check to see if it is the Fcb
    Table.  It is always possible that either it was created since or simply
    wasn't in the prefix table at the time of the prefix table search.
    Initialize the Fcb and store into the FcbTable if not present.

    Next we will add this to the prefix table of our parent if needed.

    Once we know that the new Fcb has been initialized then we move our pointer
    in the tree down to this position.

    This routine does not own the Vcb lock on entry.  We must be sure to release
    it on exit.

Arguments:

    IrpSp - Stack location for this request.

    Vcb - Vcb for the current volume.

    CurrentFcb - On input this is the parent of the Fcb to open.  On output we
        store the Fcb for the file being opened.

    FileName - This is always the exact name used to reach this file.

    IgnoreCase - Indicates the type of case of CaseName above.

    ShortNameMatch - Indicates if we are opening via the short name.

    FileContext - This is the context used to find the file.

    RelatedCcb - RelatedCcb for relative file object used to make this open.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;
    FILE_ID FileId;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN FcbExisted;

    PFCB NextFcb;
    PFCB ParentFcb = NULL;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check for illegal access to this file.
    //

    if (CdIllegalFcbAccess( IrpContext,
                            UserFileOpen,
                            IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        return STATUS_ACCESS_DENIED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Check if a version number was used to open this file.
        //

        if (FileName->VersionString.Length != 0) {

            SetFlag( CcbFlags, CCB_FLAG_OPEN_WITH_VERSION );
        }

        //
        //  Check the related Ccb to see if this was an OpenByFileId.
        //

        if (ARGUMENT_PRESENT( RelatedCcb ) &&
            FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

            SetFlag( CcbFlags, CCB_FLAG_OPEN_RELATIVE_BY_ID );
        }

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Build the file Id for this file.  We can use the path table offset from the
        //  parent and the directory offset from the dirent.
        //

        CdSetFidPathTableOffset( FileId, CdQueryFidPathTableOffset( (*CurrentFcb)->FileId ));
        CdSetFidDirentOffset( FileId, FileContext->InitialDirent->Dirent.DirentOffset );

        //
        //  Lock the Vcb so we can examine the Fcb Table.
        //

        CdLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        //
        //  Get the Fcb for this file.
        //

        NextFcb = CdCreateFcb( IrpContext, FileId, CDFS_NTC_FCB_DATA, &FcbExisted );

        //
        //  If the Fcb was created here then initialize from the values in the
        //  dirent.
        //

        if (!FcbExisted) {

            CdInitializeFcbFromFileContext( IrpContext,
                                            NextFcb,
                                            *CurrentFcb,
                                            FileContext );
        }

        //
        //  Now try to acquire the new Fcb without waiting.  We will reference
        //  the Fcb and retry with wait if unsuccessful.
        //

        if (!CdAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;

            CdUnlockVcb( IrpContext, Vcb );

            CdReleaseFcb( IrpContext, *CurrentFcb );
            CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
            CdAcquireFcbExclusive( IrpContext, *CurrentFcb, FALSE );

            CdLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
            CdUnlockVcb( IrpContext, Vcb );

        } else {

            //
            //  Unlock the Vcb and move down to this new Fcb.  Remember that we still
            //  own the parent however.
            //

            CdUnlockVcb( IrpContext, Vcb );
        }

        UnlockVcb = FALSE;

        ParentFcb = *CurrentFcb;
        *CurrentFcb = NextFcb;

        //
        //  Store this name into the prefix table for the parent.
        //


        if (ShortNameMatch) {

            //
            //  Make sure the exact case is always in the tree.
            //

            CdInsertPrefix( IrpContext,
                            NextFcb,
                            FileName,
                            FALSE,
                            TRUE,
                            ParentFcb );

            if (IgnoreCase) {

                CdInsertPrefix( IrpContext,
                                NextFcb,
                                FileName,
                                TRUE,
                                TRUE,
                                ParentFcb );
            }

        //
        //  Insert this into the prefix table if we found this without
        //  using a version string.
        //

        } else if (FileName->VersionString.Length == 0) {

            //
            //  Make sure the exact case is always in the tree.
            //

            CdInsertPrefix( IrpContext,
                            NextFcb,
                            &FileContext->InitialDirent->Dirent.CdFileName,
                            FALSE,
                            FALSE,
                            ParentFcb );

            if (IgnoreCase) {

                CdInsertPrefix( IrpContext,
                                NextFcb,
                                &FileContext->InitialDirent->Dirent.CdCaseFileName,
                                TRUE,
                                FALSE,
                                ParentFcb );
            }
        }

        //
        //  Release the parent Fcb at this point.
        //

        CdReleaseFcb( IrpContext, ParentFcb );
        ParentFcb = NULL;

        //
        //  Call our worker routine to complete the open.
        //

        Status = CdCompleteFcbOpen( IrpContext,
                                    IrpSp,
                                    Vcb,
                                    CurrentFcb,
                                    UserFileOpen,
                                    CcbFlags,
                                    IrpSp->Parameters.Create.SecurityContext->DesiredAccess );

    } finally {

        //
        //  Unlock the Vcb if held.
        //

        if (UnlockVcb) {

            CdUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Release the parent if held.
        //

        if (ParentFcb != NULL) {

            CdReleaseFcb( IrpContext, ParentFcb );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdCompleteFcbOpen (
    IN PIRP_CONTEXT IrpContext,
    PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ULONG UserCcbFlags,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This is the worker routine which takes an existing Fcb and completes
    the open.  We will do any necessary oplock checks and sharing checks.
    Finally we will create the Ccb and update the file object and any
    file object flags.

Arguments:

    IrpSp - Stack location for the current request.

    Vcb - Vcb for the current volume.

    CurrentFcb - Address of pointer to Fcb to open.  We clear this field if
        we release the resource for this file.

    TypeOfOpen - Type of open for this request.

    UserCcbFlags - Flags to OR into the Ccb flags.

    DesiredAccess - Desired access for this open.

Return Value:

    NTSTATUS - STATUS_SUCCESS if we complete this request, STATUS_PENDING if
        the oplock package takes the Irp or SHARING_VIOLATION if there is a
        sharing check conflict.

--*/

{
    NTSTATUS Status;
    NTSTATUS OplockStatus  = STATUS_SUCCESS;
    ULONG Information = FILE_OPENED;

    BOOLEAN LockVolume = FALSE;

    PFCB Fcb = *CurrentFcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Expand maximum allowed to something sensible for share access checking
    //

    if (MAXIMUM_ALLOWED == DesiredAccess)  {
    
        DesiredAccess = FILE_ALL_ACCESS & ~((TypeOfOpen != UserVolumeOpen ?
                                             (FILE_WRITE_ATTRIBUTES           |
                                              FILE_WRITE_DATA                 |
                                              FILE_WRITE_EA                   |
                                              FILE_ADD_FILE                   |                     
                                              FILE_ADD_SUBDIRECTORY           |
                                              FILE_APPEND_DATA) : 0)          |
                                            FILE_DELETE_CHILD                 |
                                            DELETE                            |
                                            WRITE_DAC );
    }

    //
    //  If this a volume open and the user wants to lock the volume then
    //  purge and lock the volume.
    //

    if ((TypeOfOpen <= UserVolumeOpen) &&
        !FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ )) {

        //
        //  If there are open handles then fail this immediately.
        //

        if (Vcb->VcbCleanup != 0) {

            return STATUS_SHARING_VIOLATION;
        }

        //
        //  If we can't wait then force this to be posted.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

            CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        LockVolume = TRUE;

        //
        //  Purge the volume and make sure all of the user references
        //  are gone.
        //

        Status = CdPurgeVolume( IrpContext, Vcb, FALSE );

        if (Status != STATUS_SUCCESS) {

            return Status;
        }

        //
        //  Now force all of the delayed close operations to go away.
        //

        CdFspClose( Vcb );

        if (Vcb->VcbUserReference > CDFS_RESIDUAL_USER_REFERENCE) {

            return STATUS_SHARING_VIOLATION;
        }
    }
    
    //
    //  If the Fcb already existed then we need to check the oplocks and
    //  the share access.
    //

    if (Fcb->FcbCleanup != 0) {

        //
        //  If this is a user file open then check whether there are any
        //  batch oplock.
        //

        if (TypeOfOpen == UserFileOpen) {

            //
            //  Store the address of the Fcb for a possible teardown into
            //  the IrpContext.  We will release this in the call to
            //  prepost the Irp.
            //

            IrpContext->TeardownFcb = CurrentFcb;

            if (FsRtlCurrentBatchOplock( &Fcb->Oplock )) {

                //
                //  We remember if a batch oplock break is underway for the
                //  case where the sharing check fails.
                //

                Information = FILE_OPBATCH_BREAK_UNDERWAY;

                OplockStatus = FsRtlCheckOplock( &Fcb->Oplock,
                                                 IrpContext->Irp,
                                                 IrpContext,
                                                 CdOplockComplete,
                                                 CdPrePostIrp );

                if (OplockStatus == STATUS_PENDING) {

                    return STATUS_PENDING;
                }
            }

            //
            //  Check the share access before breaking any exclusive oplocks.
            //

            Status = IoCheckShareAccess( DesiredAccess,
                                         IrpSp->Parameters.Create.ShareAccess,
                                         IrpSp->FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE );

            if (!NT_SUCCESS( Status )) {

                return Status;
            }

            //
            //  Now check that we can continue based on the oplock state of the
            //  file.
            //

            OplockStatus = FsRtlCheckOplock( &Fcb->Oplock,
                                             IrpContext->Irp,
                                             IrpContext,
                                             CdOplockComplete,
                                             CdPrePostIrp );

            if (OplockStatus == STATUS_PENDING) {

                return STATUS_PENDING;
            }

            IrpContext->TeardownFcb = NULL;

        //
        //  Otherwise just do the sharing check.
        //

        } else {

            Status = IoCheckShareAccess( DesiredAccess,
                                         IrpSp->Parameters.Create.ShareAccess,
                                         IrpSp->FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE );

            if (!NT_SUCCESS( Status )) {

                return Status;
            }
        }
    }

    //
    //  Create the Ccb now.
    //

    Ccb = CdCreateCcb( IrpContext, Fcb, UserCcbFlags );

    //
    //  Update the share access.
    //

    if (Fcb->FcbCleanup == 0) {

        IoSetShareAccess( DesiredAccess,
                          IrpSp->Parameters.Create.ShareAccess,
                          IrpSp->FileObject,
                          &Fcb->ShareAccess );

    } else {

        IoUpdateShareAccess( IrpSp->FileObject, &Fcb->ShareAccess );
    }

    //
    //  Set the file object type.
    //

    CdSetFileObject( IrpContext, IrpSp->FileObject, TypeOfOpen, Fcb, Ccb );

    //
    //  Set the appropriate cache flags for a user file object.
    //

    if (TypeOfOpen == UserFileOpen) {

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_INTERMEDIATE_BUFFERING )) {

            SetFlag( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );

        } else {

            SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
        }
    }

    //
    //  Update the open and cleanup counts.  Check the fast io state here.
    //

    CdLockVcb( IrpContext, Vcb );

    CdIncrementCleanupCounts( IrpContext, Fcb );
    CdIncrementReferenceCounts( IrpContext, Fcb, 1, 1 );

    if (LockVolume) {

        Vcb->VolumeLockFileObject = IrpSp->FileObject;
        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
    }

    CdUnlockVcb( IrpContext, Vcb );

    CdLockFcb( IrpContext, Fcb );

    if (TypeOfOpen == UserFileOpen) {

        Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );

    } else {

        Fcb->IsFastIoPossible = FastIoIsNotPossible;
    }

    CdUnlockFcb( IrpContext, Fcb );

    //
    //  Show that we opened the file.
    //

    IrpContext->Irp->IoStatus.Information = Information;

    //
    //  Point to the section object pointer in the non-paged Fcb.
    //

    IrpSp->FileObject->SectionObjectPointer = &Fcb->FcbNonpaged->SegmentObject;
    return OplockStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\cleanup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Cdfs called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CLEANUP)


NTSTATUS
CdCommonCleanup (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by both
    the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is closed.
    This is different than the Close operation which is invoked when the last
    reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the file/directory
    after a user is done with it.  The Fcb/Dcb remains around (because MM
    still has the file object referenced) but is now available for another
    user to open (i.e., as far as the user is concerned the is now closed).

    See close for a more complete description of what close does.

    We do no synchronization in this routine until we get to the point
    where we modify the counts, share access and volume lock field.

    We need to update the Fcb and Vcb to show that a user handle has been closed.
    The following structures and fields are affected.

    Vcb:

        VolumeLockFileObject - Did the user lock the volume with this file object.
        VcbState - Check if we are unlocking the volume here.
        VcbCleanup - Count of outstanding handles on the volume.
        DirNotifyQueue - If this file object has pending DirNotify Irps.

    Fcb:

        ShareAccess - If this is a user handle.
        FcbCleanup - Count of outstanding handles on this Fcb.
        Oplock - Any outstanding oplocks on this file object.
        FileLock - Any outstanding filelocks on this file object.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN SendUnlockNotification = FALSE;
    BOOLEAN AttemptTeardown;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    KIRQL SavedIrql;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get the file object out of the Irp and decode the type of open.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    TypeOfOpen = CdDecodeFileObject( IrpContext,
                                     FileObject,
                                     &Fcb,
                                     &Ccb );

    //
    //  No work here for either an UnopenedFile object or a StreamFileObject.
    //

    if (TypeOfOpen <= StreamFileOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    //
    //  Keep a local pointer to the Vcb.
    //

    Vcb = Fcb->Vcb;
    
    //
    //  Synchronise with reads while we set the cleanup complete 
    //  flag on this fileobject.  Once this flag is set,  any further
    //  reads will be rejected (CdVerifyFcbOperation)
    //

    CdAcquireFileExclusive( IrpContext, Fcb);

    //
    //  Set the flag in the FileObject to indicate that cleanup is complete.
    //

    SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

    CdReleaseFile( IrpContext, Fcb);
    
    //
    //  Acquire the current file.
    //

    CdAcquireFcbExclusive( IrpContext, Fcb, FALSE );
    
    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {
    
        //
        //  Case on the type of open that we are trying to cleanup.
        //

        switch (TypeOfOpen) {

        case UserDirectoryOpen:

            //
            //  Check if we need to complete any dir notify Irps on this file object.
            //

            FsRtlNotifyCleanup( Vcb->NotifySync,
                                &Vcb->DirNotifyList,
                                Ccb );

            break;

        case UserFileOpen:

            //
            //  Coordinate the cleanup operation with the oplock state.
            //  Oplock cleanup operations can always cleanup immediately so no
            //  need to check for STATUS_PENDING.
            //

            FsRtlCheckOplock( &Fcb->Oplock,
                              Irp,
                              IrpContext,
                              NULL,
                              NULL );

            //
            //  Unlock all outstanding file locks.
            //

            if (Fcb->FileLock != NULL) {

                FsRtlFastUnlockAll( Fcb->FileLock,
                                    FileObject,
                                    IoGetRequestorProcess( Irp ),
                                    NULL );
            }

            //
            //  Cleanup the cache map.
            //

            CcUninitializeCacheMap( FileObject, NULL, NULL );

            //
            //  Check the fast io state.
            //

            CdLockFcb( IrpContext, Fcb );
            Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
            CdUnlockFcb( IrpContext, Fcb );

            break;

        case UserVolumeOpen :

            break;

        default :

            CdBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  Now lock the Vcb in order to modify the fields in the in-memory
        //  structures.
        //

        CdLockVcb( IrpContext, Vcb );

        //
        //  Decrement the cleanup counts in the Vcb and Fcb.
        //

        CdDecrementCleanupCounts( IrpContext, Fcb );

        //
        //  If the cleanup count hit zero and the volume is not mounted, we
        //  will want to try to spark teardown.
        //

        AttemptTeardown = (Vcb->VcbCleanup == 0 && Vcb->VcbCondition == VcbNotMounted);

        //
        //  If this file object has locked the volume then perform the unlock operation.
        //  We do this regardless of explicit or implicit (no share DASD open) lock.
        //

        if (FileObject == Vcb->VolumeLockFileObject) {

            ASSERT( FlagOn( Vcb->VcbState, VCB_STATE_LOCKED));

            IoAcquireVpbSpinLock( &SavedIrql ); 

            ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED);
            ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED );
            Vcb->VolumeLockFileObject = NULL;
            SendUnlockNotification = TRUE;

            IoReleaseVpbSpinLock( SavedIrql );  
        }

        CdUnlockVcb( IrpContext, Vcb );

        //
        //  We must clean up the share access at this time, since we may not
        //  get a Close call for awhile if the file was mapped through this
        //  File Object.
        //

        IoRemoveShareAccess( FileObject, &Fcb->ShareAccess );

    } finally {

        CdReleaseFcb( IrpContext, Fcb );
        
        if (SendUnlockNotification) {
            
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
        }
    }

    //
    //  If appropriate, try to spark teardown by purging the volume.  Should
    //  this very fileobject we were cleaning up be the last reason for the
    //  volume to remain, teardown will commence on completion of this Irp.
    //
    
    if (AttemptTeardown) {

        CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

        try {
            
            CdPurgeVolume( IrpContext, Vcb, FALSE );

        } finally {

            CdReleaseVcb( IrpContext, Vcb );
        }
    }

    //
    //  If this is a normal termination then complete the request
    //

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\devctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the File System Device Control routines for Cdfs
    called by the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   04-Mar-1991

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_DEVCTRL)

//
//  Local support routines
//

NTSTATUS
CdDevCtrlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonDevControl)
#endif


NTSTATUS
CdCommonDevControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;

    PVOID TargetBuffer = NULL;

    PAGED_CODE();

    //
    //  Extract and decode the file object.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = CdDecodeFileObject( IrpContext,
                                     IrpSp->FileObject,
                                     &Fcb,
                                     &Ccb );

    //
    //  The only type of opens we accept are user volume opens.
    //

    if (TypeOfOpen != UserVolumeOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_READ_TOC) {

        //
        //  Verify the Vcb in this case to detect if the volume has changed.
        //

        CdVerifyVcb( IrpContext, Fcb->Vcb );

    //
    //  Handle the case of the disk type ourselves.
    //

    } else if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_DISK_TYPE) {

        //
        //  Verify the Vcb in this case to detect if the volume has changed.
        //

        CdVerifyVcb( IrpContext, Fcb->Vcb );

        //
        //  Check the size of the output buffer.
        //

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof( CDROM_DISK_DATA )) {

            CdCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  Copy the data from the Vcb.
        //

        ((PCDROM_DISK_DATA) Irp->AssociatedIrp.SystemBuffer)->DiskData = Fcb->Vcb->DiskFlags;

        Irp->IoStatus.Information = sizeof( CDROM_DISK_DATA );
        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get the next stack location, and copy over the stack parameter
    //  information.
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    *NextIrpSp = *IrpSp;

    //
    //  Set up the completion routine
    //

    IoSetCompletionRoutine( Irp,
                            CdDevCtrlCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );

    //
    //  Cleanup our Irp Context.  The driver has completed the Irp.
    //

    CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdDevCtrlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Add the hack-o-ramma to fix formats.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\dirctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routines for Cdfs called
    by the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_DIRCTRL)

//
//  Local support routines
//

NTSTATUS
CdQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN PCCB Ccb
    );

NTSTATUS
CdNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PCCB Ccb
    );

VOID
CdInitializeEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN OUT PCCB Ccb,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    OUT PBOOLEAN ReturnNextEntry,
    OUT PBOOLEAN ReturnSingleEntry,
    OUT PBOOLEAN InitialQuery
    );

BOOLEAN
CdEnumerateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    IN BOOLEAN ReturnNextEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonDirControl)
#pragma alloc_text(PAGE, CdEnumerateIndex)
#pragma alloc_text(PAGE, CdInitializeEnumeration)
#pragma alloc_text(PAGE, CdNotifyChangeDirectory)
#pragma alloc_text(PAGE, CdQueryDirectory)
#endif


NTSTATUS
CdCommonDirControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the entry point for the directory control operations.  These
    are directory enumerations and directory notify calls.  We verify the
    user's handle is for a directory and then call the appropriate routine.

Arguments:

    Irp - Irp for this request.

Return Value:

    NTSTATUS - Status returned from the lower level routines.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the user file object and fail this request if it is not
    //  a user directory.
    //

    if (CdDecodeFileObject( IrpContext,
                            IrpSp->FileObject,
                            &Fcb,
                            &Ccb ) != UserDirectoryOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_QUERY_DIRECTORY:

        Status = CdQueryDirectory( IrpContext, Irp, IrpSp, Fcb, Ccb );
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        Status = CdNotifyChangeDirectory( IrpContext, Irp, IrpSp, Ccb );
        break;

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routines
//

NTSTATUS
CdQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing of enqueuing the input Irp.  We store the state of the
    search in the Ccb.

Arguments:

    Irp - Supplies the Irp to process

    IrpSp - Stack location for this Irp.

    Fcb - Fcb for this directory.

    Ccb - Ccb for this directory open.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Information = 0;

    ULONG LastEntry = 0;
    ULONG NextEntry = 0;

    ULONG FileNameBytes;
    ULONG SeparatorBytes;
    ULONG VersionStringBytes;

    FILE_ENUM_CONTEXT FileContext;
    PDIRENT ThisDirent;
    BOOLEAN InitialQuery;
    BOOLEAN ReturnNextEntry;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN Found;
    BOOLEAN DoCcbUpdate = FALSE;

    PCHAR UserBuffer;
    ULONG BytesRemainingInBuffer;

    ULONG BaseLength;

    PFILE_BOTH_DIR_INFORMATION DirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;
    PFILE_ID_FULL_DIR_INFORMATION IdFullDirInfo;
    PFILE_ID_BOTH_DIR_INFORMATION IdBothDirInfo;

    PAGED_CODE();

    //
    //  Check if we support this search mode.  Also remember the size of the base part of
    //  each of these structures.
    //

    switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {

    case FileDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                   FileName[0] );
        break;

    case FileFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileNamesInformation:

        BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                   FileName[0] );
        break;

    case FileBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_INFO_CLASS );
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    //  Get the user buffer.
    //

    CdMapUserBuffer( IrpContext, &UserBuffer);

    //
    //  Initialize our search context.
    //

    CdInitializeFileContext( IrpContext, &FileContext );

    //
    //  Acquire the directory.
    //

    CdAcquireFileShared( IrpContext, Fcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Fcb is still good.
        //

        CdVerifyFcbOperation( IrpContext, Fcb );

        //
        //  Start by getting the initial state for the enumeration.  This will set up the Ccb with
        //  the initial search parameters and let us know the starting offset in the directory
        //  to search.
        //

        CdInitializeEnumeration( IrpContext,
                                 IrpSp,
                                 Fcb,
                                 Ccb,
                                 &FileContext,
                                 &ReturnNextEntry,
                                 &ReturnSingleEntry,
                                 &InitialQuery );

        //
        //  The current dirent is stored in the InitialDirent field.  We capture
        //  this here so that we have a valid restart point even if we don't
        //  find a single entry.
        //

        ThisDirent = &FileContext.InitialDirent->Dirent;

        //
        //  At this point we are about to enter our query loop.  We have
        //  determined the index into the directory file to begin the
        //  search.  LastEntry and NextEntry are used to index into the user
        //  buffer.  LastEntry is the last entry we've added, NextEntry is
        //  current one we're working on.  If NextEntry is non-zero, then
        //  at least one entry was added.
        //

        while (TRUE) {

            //
            //  If the user had requested only a single match and we have
            //  returned that, then we stop at this point.  We update the Ccb with
            //  the status based on the last entry returned.
            //

            if ((NextEntry != 0) && ReturnSingleEntry) {

                DoCcbUpdate = TRUE;
                try_leave( Status );
            }

            //
            //  We try to locate the next matching dirent.  Our search if based on a starting
            //  dirent offset, whether we should return the current or next entry, whether
            //  we should be doing a short name search and finally whether we should be
            //  checking for a version match.
            //

            Found = CdEnumerateIndex( IrpContext, Ccb, &FileContext, ReturnNextEntry );

            //
            //  Initialize the value for the next search.
            //

            ReturnNextEntry = TRUE;

            //
            //  If we didn't receive a dirent, then we are at the end of the
            //  directory.  If we have returned any files, we exit with
            //  success, otherwise we return STATUS_NO_MORE_FILES.
            //

            if (!Found) {

                if (NextEntry == 0) {

                    Status = STATUS_NO_MORE_FILES;

                    if (InitialQuery) {

                        Status = STATUS_NO_SUCH_FILE;
                    }
                }

                DoCcbUpdate = TRUE;
                try_leave( Status );
            }

            //
            //  Remember the dirent for the file we just found.
            //

            ThisDirent = &FileContext.InitialDirent->Dirent;

            //
            //  Here are the rules concerning filling up the buffer:
            //
            //  1.  The Io system garentees that there will always be
            //      enough room for at least one base record.
            //
            //  2.  If the full first record (including file name) cannot
            //      fit, as much of the name as possible is copied and
            //      STATUS_BUFFER_OVERFLOW is returned.
            //
            //  3.  If a subsequent record cannot completely fit into the
            //      buffer, none of it (as in 0 bytes) is copied, and
            //      STATUS_SUCCESS is returned.  A subsequent query will
            //      pick up with this record.
            //

            //
            //  Let's compute the number of bytes we need to transfer the current entry.
            //

            SeparatorBytes =
            VersionStringBytes = 0;

            //
            //  We can look directly at the dirent that we found.
            //

            FileNameBytes = ThisDirent->CdFileName.FileName.Length;

            //
            //  Compute the number of bytes for the version string if
            //  we will return this. Allow directories with illegal ";".
            //

            if (((Ccb->SearchExpression.VersionString.Length != 0) ||
                 (FlagOn(ThisDirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY))) &&
                (ThisDirent->CdFileName.VersionString.Length != 0)) {

                SeparatorBytes = 2;

                VersionStringBytes = ThisDirent->CdFileName.VersionString.Length;
            }

            //
            //  If the slot for the next entry would be beyond the length of the
            //  user's buffer just exit (we know we've returned at least one entry
            //  already). This will happen when we align the pointer past the end.
            //

            if (NextEntry > IrpSp->Parameters.QueryDirectory.Length) {

                ReturnNextEntry = FALSE;
                DoCcbUpdate = TRUE;
                try_leave( Status = STATUS_SUCCESS );
            }

            //
            //  Compute the number of bytes remaining in the buffer.  Round this
            //  down to a WCHAR boundary so we can copy full characters.
            //

            BytesRemainingInBuffer = IrpSp->Parameters.QueryDirectory.Length - NextEntry;
            ClearFlag( BytesRemainingInBuffer, 1 );

            //
            //  If this won't fit and we have returned a previous entry then just
            //  return STATUS_SUCCESS.
            //

            if ((BaseLength + FileNameBytes + SeparatorBytes + VersionStringBytes) > BytesRemainingInBuffer) {

                //
                //  If we already found an entry then just exit.
                //

                if (NextEntry != 0) {

                    ReturnNextEntry = FALSE;
                    DoCcbUpdate = TRUE;
                    try_leave( Status = STATUS_SUCCESS );
                }

                //
                //  Don't even try to return the version string if it doesn't all fit.
                //  Reduce the FileNameBytes to just fit in the buffer.
                //

                if ((BaseLength + FileNameBytes) > BytesRemainingInBuffer) {

                    FileNameBytes = BytesRemainingInBuffer - BaseLength;
                }

                //
                //  Don't return any version string bytes.
                //

                VersionStringBytes =
                SeparatorBytes = 0;

                //
                //  Use a status code of STATUS_BUFFER_OVERFLOW.  Also set
                //  ReturnSingleEntry so that we will exit the loop at the top.
                //

                Status = STATUS_BUFFER_OVERFLOW;
                ReturnSingleEntry = TRUE;
            }

            //
            //  Protect access to the user buffer with an exception handler.
            //  Since (at our request) IO doesn't buffer these requests, we have
            //  to guard against a user messing with the page protection and other
            //  such trickery.
            //
            
            try {
            
                //
                //  Zero and initialize the base part of the current entry.
                //

                RtlZeroMemory( Add2Ptr( UserBuffer, NextEntry, PVOID ),
                               BaseLength );
    
                //
                //  Now we have an entry to return to our caller.
                //  We'll case on the type of information requested and fill up
                //  the user buffer if everything fits.
                //

                switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {
    
                case FileBothDirectoryInformation:
                case FileFullDirectoryInformation:
                case FileIdBothDirectoryInformation:
                case FileIdFullDirectoryInformation:
                case FileDirectoryInformation:
    
                    DirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_BOTH_DIR_INFORMATION );
    
                    //
                    //  Use the create time for all the time stamps.
                    //
    
                    CdConvertCdTimeToNtTime( IrpContext,
                                             FileContext.InitialDirent->Dirent.CdTime,
                                             &DirInfo->CreationTime );
    
                    DirInfo->LastWriteTime = DirInfo->ChangeTime = DirInfo->CreationTime;
    
                    //
                    //  Set the attributes and sizes separately for directories and
                    //  files.
                    //
    
                    if (FlagOn( ThisDirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY )) {
    
                        DirInfo->EndOfFile.QuadPart = DirInfo->AllocationSize.QuadPart = 0;
    
                        SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
    
                    } else {
    
                        DirInfo->EndOfFile.QuadPart = FileContext.FileSize;
                        DirInfo->AllocationSize.QuadPart = LlSectorAlign( FileContext.FileSize );
                    }
    
                    //
                    //  All Cdrom files are readonly.  We also copy the existence
                    //  bit to the hidden attribute.
                    //
    
                    SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_READONLY );
    
                    if (FlagOn( ThisDirent->DirentFlags,
                                CD_ATTRIBUTE_HIDDEN )) {
    
                        SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
                    }
    
                    DirInfo->FileIndex = ThisDirent->DirentOffset;
    
                    DirInfo->FileNameLength = FileNameBytes + SeparatorBytes + VersionStringBytes;
    
                    break;
    
                case FileNamesInformation:
    
                    NamesInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_NAMES_INFORMATION );
    
                    NamesInfo->FileIndex = ThisDirent->DirentOffset;
    
                    NamesInfo->FileNameLength = FileNameBytes + SeparatorBytes + VersionStringBytes;
    
                    break;
                }

                //
                //  Fill in the FileId
                //

                switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {

                case FileIdBothDirectoryInformation:

                    IdBothDirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_ID_BOTH_DIR_INFORMATION );
                    CdSetFidFromParentAndDirent( IdBothDirInfo->FileId, Fcb, ThisDirent );
                    break;

                case FileIdFullDirectoryInformation:

                    IdFullDirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_ID_FULL_DIR_INFORMATION );
                    CdSetFidFromParentAndDirent( IdFullDirInfo->FileId, Fcb, ThisDirent );
                    break;

                default:
                    break;
                }
    
                //
                //  Now copy as much of the name as possible.  We also may have a version
                //  string to copy.
                //
    
                if (FileNameBytes != 0) {
    
                    //
                    //  This is a Unicode name, we can copy the bytes directly.
                    //
    
                    RtlCopyMemory( Add2Ptr( UserBuffer, NextEntry + BaseLength, PVOID ),
                                   ThisDirent->CdFileName.FileName.Buffer,
                                   FileNameBytes );
    
                    if (SeparatorBytes != 0) {
    
                        *(Add2Ptr( UserBuffer,
                                   NextEntry + BaseLength + FileNameBytes,
                                   PWCHAR )) = L';';
    
                        if (VersionStringBytes != 0) {
    
                            RtlCopyMemory( Add2Ptr( UserBuffer,
                                                    NextEntry + BaseLength + FileNameBytes + sizeof( WCHAR ),
                                                    PVOID ),
                                           ThisDirent->CdFileName.VersionString.Buffer,
                                           VersionStringBytes );
                        }
                    }
                }

                //
                //  Fill in the short name if we got STATUS_SUCCESS.  The short name
                //  may already be in the file context.  Otherwise we will check
                //  whether the long name is 8.3.  Special case the self and parent
                //  directory names.
                //

                if ((Status == STATUS_SUCCESS) &&
                    (IrpSp->Parameters.QueryDirectory.FileInformationClass == FileBothDirectoryInformation ||
                     IrpSp->Parameters.QueryDirectory.FileInformationClass == FileIdBothDirectoryInformation) &&
                    (Ccb->SearchExpression.VersionString.Length == 0) &&
                    !FlagOn( ThisDirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY )) {
    
                    //
                    //  If we already have the short name then copy into the user's buffer.
                    //
    
                    if (FileContext.ShortName.FileName.Length != 0) {
    
                        RtlCopyMemory( DirInfo->ShortName,
                                       FileContext.ShortName.FileName.Buffer,
                                       FileContext.ShortName.FileName.Length );
    
                        DirInfo->ShortNameLength = (CCHAR) FileContext.ShortName.FileName.Length;
    
                    //
                    //  If the short name length is currently zero then check if
                    //  the long name is not 8.3.  We can copy the short name in
                    //  unicode form directly into the caller's buffer.
                    //
    
                    } else {
    
                        if (!CdIs8dot3Name( IrpContext,
                                            ThisDirent->CdFileName.FileName )) {
    
                            CdGenerate8dot3Name( IrpContext,
                                                 &ThisDirent->CdCaseFileName.FileName,
                                                 ThisDirent->DirentOffset,
                                                 DirInfo->ShortName,
                                                 &FileContext.ShortName.FileName.Length );
    
                            DirInfo->ShortNameLength = (CCHAR) FileContext.ShortName.FileName.Length;
                        }
                    }
    
                }

                //
                //  Sum the total number of bytes for the information field.
                //

                FileNameBytes += SeparatorBytes + VersionStringBytes;

                //
                //  Update the information with the number of bytes stored in the
                //  buffer.  We quad-align the existing buffer to add any necessary
                //  pad bytes.
                //

                Information = NextEntry + BaseLength + FileNameBytes;

                //
                //  Go back to the previous entry and fill in the update to this entry.
                //

                *(Add2Ptr( UserBuffer, LastEntry, PULONG )) = NextEntry - LastEntry;

                //
                //  Set up our variables for the next dirent.
                //

                InitialQuery = FALSE;

                LastEntry = NextEntry;
                NextEntry = QuadAlign( Information );
            
            } except (EXCEPTION_EXECUTE_HANDLER) {

                  //
                  //  We had a problem filling in the user's buffer, so stop and
                  //  fail this request.  This is the only reason any exception
                  //  would have occured at this level.
                  //
                  
                  Information = 0;
                  try_leave( Status = GetExceptionCode());
            }
        }
        
        DoCcbUpdate = TRUE;

    } finally {

        //
        //  Cleanup our search context - *before* aquiring the FCB mutex exclusive,
        //  else can block on threads in cdcreateinternalstream/purge which 
        //  hold the FCB but are waiting for all maps in this stream to be released.
        //

        CdCleanupFileContext( IrpContext, &FileContext );

        //
        //  Now we can safely aqure the FCB mutex if we need to.
        //

        if (DoCcbUpdate && !NT_ERROR( Status )) {
        
            //
            //  Update the Ccb to show the current state of the enumeration.
            //

            CdLockFcb( IrpContext, Fcb );
            
            Ccb->CurrentDirentOffset = ThisDirent->DirentOffset;

            ClearFlag( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );

            if (ReturnNextEntry) {

                SetFlag( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
            }

            CdUnlockFcb( IrpContext, Fcb );
        }

        //
        //  Release the Fcb.
        //

        CdReleaseFile( IrpContext, Fcb );
    }

    //
    //  Complete the request here.
    //

    Irp->IoStatus.Information = Information;

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routines
//

NTSTATUS
CdNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing of enqueuing the input Irp.  Although there
    will never be a notify signalled on a CDROM disk we still support this call.

    We have already checked that this is not an OpenById handle.

Arguments:

    Irp - Supplies the Irp to process

    IrpSp - Io stack location for this request.

    Ccb - Handle to the directory being watched.

Return Value:

    NTSTATUS - STATUS_PENDING, any other error will raise.

--*/

{
    PAGED_CODE();

    //
    //  Always set the wait bit in the IrpContext so the initial wait can't fail.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  Acquire the Vcb shared.
    //

    CdAcquireVcbShared( IrpContext, IrpContext->Vcb, FALSE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Vcb.
        //

        CdVerifyVcb( IrpContext, IrpContext->Vcb );

        //
        //  Call the Fsrtl package to process the request.  We cast the
        //  unicode strings to ansi strings as the dir notify package
        //  only deals with memory matching.
        //

        FsRtlNotifyFullChangeDirectory( IrpContext->Vcb->NotifySync,
                                        &IrpContext->Vcb->DirNotifyList,
                                        Ccb,
                                        (PSTRING) &IrpSp->FileObject->FileName,
                                        BooleanFlagOn( IrpSp->Flags, SL_WATCH_TREE ),
                                        FALSE,
                                        IrpSp->Parameters.NotifyDirectory.CompletionFilter,
                                        Irp,
                                        NULL,
                                        NULL );

    } finally {

        //
        //  Release the Vcb.
        //

        CdReleaseVcb( IrpContext, IrpContext->Vcb );
    }

    //
    //  Cleanup the IrpContext.
    //

    CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return STATUS_PENDING;
}


//
//  Local support routine
//

VOID
CdInitializeEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN OUT PCCB Ccb,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    OUT PBOOLEAN ReturnNextEntry,
    OUT PBOOLEAN ReturnSingleEntry,
    OUT PBOOLEAN InitialQuery
    )

/*++

Routine Description:

    This routine is called to initialize the enumeration variables and structures.
    We look at the state of a previous enumeration from the Ccb as well as any
    input values from the user.  On exit we will position the FileContext at
    a file in the directory and let the caller know whether this entry or the
    next entry should be returned.

Arguments:

    IrpSp - Irp stack location for this request.

    Fcb - Fcb for this directory.

    Ccb - Ccb for the directory handle.

    FileContext - FileContext to use for this enumeration.

    ReturnNextEntry - Address to store whether we should return the entry at
        the FileContext position or the next entry.

    ReturnSingleEntry - Address to store whether we should only return
        a single entry.

    InitialQuery - Address to store whether this is the first enumeration
        query on this handle.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PUNICODE_STRING FileName;
    CD_NAME WildCardName;
    CD_NAME SearchExpression;

    ULONG CcbFlags;

    ULONG DirentOffset;
    ULONG LastDirentOffset;
    BOOLEAN KnownOffset;

    BOOLEAN Found;

    PAGED_CODE();

    //
    //  If this is the initial query then build a search expression from the input
    //  file name.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_ENUM_INITIALIZED )) {

        FileName = (PUNICODE_STRING) IrpSp->Parameters.QueryDirectory.FileName;

        CcbFlags = 0;

        //
        //  If the filename is not specified or is a single '*' then we will
        //  match all names.
        //

        if ((FileName == NULL) ||
            (FileName->Buffer == NULL) ||
            (FileName->Length == 0) ||
            ((FileName->Length == sizeof( WCHAR )) &&
             (FileName->Buffer[0] == L'*'))) {

            SetFlag( CcbFlags, CCB_FLAG_ENUM_MATCH_ALL );
            RtlZeroMemory( &SearchExpression, sizeof( SearchExpression ));

        //
        //  Otherwise build the CdName from the name in the stack location.
        //  This involves building both the name and version portions and
        //  checking for wild card characters.  We also upcase the string if
        //  this is a case-insensitive search.
        //

        } else {

            //
            //  Create a CdName to check for wild cards.
            //

            WildCardName.FileName = *FileName;

            CdConvertNameToCdName( IrpContext, &WildCardName );

            //
            //  The name better have at least one character.
            //

            if (WildCardName.FileName.Length == 0) {

                CdRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER );
            }

            //
            //  Check for wildcards in the separate components.
            //

            if (FsRtlDoesNameContainWildCards( &WildCardName.FileName)) {

                SetFlag( CcbFlags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD );
            }

            if ((WildCardName.VersionString.Length != 0) &&
                (FsRtlDoesNameContainWildCards( &WildCardName.VersionString ))) {

                SetFlag( CcbFlags, CCB_FLAG_ENUM_VERSION_EXP_HAS_WILD );

                //
                //  Check if this is a wild card only and match all version
                //  strings.
                //

                if ((WildCardName.VersionString.Length == sizeof( WCHAR )) &&
                    (WildCardName.VersionString.Buffer[0] == L'*')) {

                    SetFlag( CcbFlags, CCB_FLAG_ENUM_VERSION_MATCH_ALL );
                }
            }

            //
            //  Now create the search expression to store in the Ccb.
            //

            SearchExpression.FileName.Buffer = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                                         FileName->Length,
                                                                         TAG_ENUM_EXPRESSION );

            SearchExpression.FileName.MaximumLength = FileName->Length;

            //
            //  Either copy the name directly or perform the upcase.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE )) {

                Status = RtlUpcaseUnicodeString( (PUNICODE_STRING) &SearchExpression.FileName,
                                                 FileName,
                                                 FALSE );

                //
                //  This should never fail.
                //

                ASSERT( Status == STATUS_SUCCESS );

            } else {

                RtlCopyMemory( SearchExpression.FileName.Buffer,
                               FileName->Buffer,
                               FileName->Length );
            }

            //
            //  Now split into the separate name and version components.
            //

            SearchExpression.FileName.Length = WildCardName.FileName.Length;
            SearchExpression.VersionString.Length = WildCardName.VersionString.Length;
            SearchExpression.VersionString.MaximumLength = WildCardName.VersionString.MaximumLength;

            SearchExpression.VersionString.Buffer = Add2Ptr( SearchExpression.FileName.Buffer,
                                                             SearchExpression.FileName.Length + sizeof( WCHAR ),
                                                             PWCHAR );
        }

        //
        //  But we do not want to return the constant "." and ".." entries for
        //  the root directory, for consistency with the rest of Microsoft's
        //  filesystems.
        //

        if (Fcb == Fcb->Vcb->RootIndexFcb) {

            SetFlag( CcbFlags, CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY );
        }

        //
        //  Now lock the Fcb in order to update the Ccb with the inital
        //  enumeration values.
        //

        CdLockFcb( IrpContext, Fcb );

        //
        //  Check again that this is the initial search.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ENUM_INITIALIZED )) {

            //
            //  Update the values in the Ccb.
            //

            Ccb->CurrentDirentOffset = Fcb->StreamOffset;
            Ccb->SearchExpression = SearchExpression;

            //
            //  Set the appropriate flags in the Ccb.
            //

            SetFlag( Ccb->Flags, CcbFlags | CCB_FLAG_ENUM_INITIALIZED );

        //
        //  Otherwise cleanup any buffer allocated here.
        //

        } else {

            if (!FlagOn( CcbFlags, CCB_FLAG_ENUM_MATCH_ALL )) {

                ExFreePool( SearchExpression.FileName.Buffer );
            }
        }

    //
    //  Otherwise lock the Fcb so we can read the current enumeration values.
    //

    } else {

        CdLockFcb( IrpContext, Fcb );
    }

    //
    //  Capture the current state of the enumeration.
    //
    //  If the user specified an index then use his offset.  We always
    //  return the next entry in this case.
    //

    if (FlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED )) {

        KnownOffset = FALSE;
        DirentOffset = IrpSp->Parameters.QueryDirectory.FileIndex;
        *ReturnNextEntry = TRUE;

    //
    //  If we are restarting the scan then go from the self entry.
    //

    } else if (FlagOn( IrpSp->Flags, SL_RESTART_SCAN )) {

        KnownOffset = TRUE;
        DirentOffset = Fcb->StreamOffset;
        *ReturnNextEntry = FALSE;

    //
    //  Otherwise use the values from the Ccb.
    //

    } else {

        KnownOffset = TRUE;
        DirentOffset = Ccb->CurrentDirentOffset;
        *ReturnNextEntry = BooleanFlagOn( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
    }

    //
    //  Unlock the Fcb.
    //

    CdUnlockFcb( IrpContext, Fcb );

    //
    //  We have the starting offset in the directory and whether to return
    //  that entry or the next.  If we are at the beginning of the directory
    //  and are returning that entry, then tell our caller this is the
    //  initial query.
    //

    *InitialQuery = FALSE;

    if ((DirentOffset == Fcb->StreamOffset) &&
        !(*ReturnNextEntry)) {

        *InitialQuery = TRUE;
    }

    //
    //  If there is no file object then create it now.
    //

    if (Fcb->FileObject == NULL) {

        CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Determine the offset in the stream to position the FileContext and
    //  whether this offset is known to be a file offset.
    //
    //  If this offset is known to be safe then go ahead and position the
    //  file context.  This handles the cases where the offset is the beginning
    //  of the stream, the offset is from a previous search or this is the
    //  initial query.
    //

    if (KnownOffset) {

        CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, DirentOffset );

    //
    //  Otherwise we walk through the directory from the beginning until
    //  we reach the entry which contains this offset.
    //

    } else {

        LastDirentOffset = Fcb->StreamOffset;
        Found = TRUE;

        CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, LastDirentOffset );

        //
        //  If the requested offset is prior to the beginning offset in the stream
        //  then don't return the next entry.
        //

        if (DirentOffset < LastDirentOffset) {

            *ReturnNextEntry = FALSE;

        //
        //  Else look for the last entry which ends past the desired index.
        //

        } else {

            //
            //  Keep walking through the directory until we run out of
            //  entries or we find an entry which ends beyond the input
            //  index value.
            //

            do {

                //
                //  If we have passed the index value then exit.
                //

                if (FileContext->InitialDirent->Dirent.DirentOffset > DirentOffset) {

                    Found = FALSE;
                    break;
                }

                //
                //  Remember the current position in case we need to go back.
                //

                LastDirentOffset = FileContext->InitialDirent->Dirent.DirentOffset;

                //
                //  Exit if the next entry is beyond the desired index value.
                //

                if (LastDirentOffset + FileContext->InitialDirent->Dirent.DirentLength > DirentOffset) {

                    break;
                }

                Found = CdLookupNextInitialFileDirent( IrpContext, Fcb, FileContext );

            } while (Found);

            //
            //  If we didn't find the entry then go back to the last known entry.
            //  This can happen if the index lies in the unused range at the
            //  end of a sector.
            //

            if (!Found) {

                CdCleanupFileContext( IrpContext, FileContext );
                CdInitializeFileContext( IrpContext, FileContext );

                CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, LastDirentOffset );
            }
        }
    }

    //
    //  Only update the dirent name if we will need it for some reason.
    //  Don't update this name if we are returning the next entry and
    //  the search string has a version component.
    //

    FileContext->ShortName.FileName.Length = 0;

    if (!(*ReturnNextEntry) ||
        (Ccb->SearchExpression.VersionString.Length == 0)) {

        //
        //  Update the name in the dirent into filename and version components.
        //

        CdUpdateDirentName( IrpContext,
                            &FileContext->InitialDirent->Dirent,
                            FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
    }

    //
    //  Look at the flag in the IrpSp indicating whether to return just
    //  one entry.
    //

    *ReturnSingleEntry = FALSE;

    if (FlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY )) {

        *ReturnSingleEntry = TRUE;
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
CdEnumerateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    IN BOOLEAN ReturnNextEntry
    )

/*++

Routine Description:

    This routine is the worker routine for index enumeration.  We are positioned
    at some dirent in the directory and will either return the first match
    at that point or look to the next entry.  The Ccb contains details about
    the type of matching to do.  If the user didn't specify a version in
    his search string then we only return the first version of a sequence
    of files with versions.  We also don't return any associated files.

Arguments:

    Ccb - Ccb for this directory handle.

    FileContext - File context already positioned at some entry in the directory.

    ReturnNextEntry - Indicates if we are returning this entry or should start
        with the next entry.

Return Value:

    BOOLEAN - TRUE if next entry is found, FALSE otherwise.

--*/

{
    PDIRENT PreviousDirent = NULL;
    PDIRENT ThisDirent = &FileContext->InitialDirent->Dirent;

    BOOLEAN Found = FALSE;

    PAGED_CODE();

    //
    //  Loop until we find a match or exaust the directory.
    //

    while (TRUE) {

        //
        //  Move to the next entry unless we want to consider the current
        //  entry.
        //

        if (ReturnNextEntry) {

            if (!CdLookupNextInitialFileDirent( IrpContext, Ccb->Fcb, FileContext )) {

                break;
            }

            PreviousDirent = ThisDirent;
            ThisDirent = &FileContext->InitialDirent->Dirent;

            CdUpdateDirentName( IrpContext, ThisDirent, FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
        
        } else {

            ReturnNextEntry = TRUE;
        }

        //
        //  Don't bother if we have a constant entry and are ignoring them.
        //
        
        if (FlagOn( ThisDirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY ) &&
            FlagOn( Ccb->Flags, CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY )) {

            continue;
        }

        //
        //  Look at the current entry if it is not an associated file
        //  and the name doesn't match the previous file if the version
        //  name is not part of the search.
        //

        if (!FlagOn( ThisDirent->DirentFlags, CD_ATTRIBUTE_ASSOC )) {

            //
            //  Check if this entry matches the previous entry except
            //  for version number and whether we should return the
            //  entry in that case.  Go directly to the name comparison
            //  if:
            //
            //      There is no previous entry.
            //      The search expression has a version component.
            //      The name length doesn't match the length of the previous entry.
            //      The base name strings don't match.
            //

            if ((PreviousDirent == NULL) ||
                (Ccb->SearchExpression.VersionString.Length != 0) ||
                (PreviousDirent->CdCaseFileName.FileName.Length != ThisDirent->CdCaseFileName.FileName.Length) ||
                FlagOn( PreviousDirent->DirentFlags, CD_ATTRIBUTE_ASSOC ) ||
                !RtlEqualMemory( PreviousDirent->CdCaseFileName.FileName.Buffer,
                                 ThisDirent->CdCaseFileName.FileName.Buffer,
                                 ThisDirent->CdCaseFileName.FileName.Length )) {

                //
                //  If we match all names then return to our caller.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_ENUM_MATCH_ALL )) {

                    FileContext->ShortName.FileName.Length = 0;
                    Found = TRUE;
                    break;
                }

                //
                //  Check if the long name matches the search expression.
                //

                if (CdIsNameInExpression( IrpContext,
                                          &ThisDirent->CdCaseFileName,
                                          &Ccb->SearchExpression,
                                          Ccb->Flags,
                                          TRUE )) {

                    //
                    //  Let our caller know we found an entry.
                    //

                    Found = TRUE;
                    FileContext->ShortName.FileName.Length = 0;
                    break;
                }

                //
                //  The long name didn't match so we need to check for a
                //  possible short name match.  There is no match if the
                //  long name is 8dot3 or the search expression has a
                //  version component.  Special case the self and parent
                //  entries.
                //

                if ((Ccb->SearchExpression.VersionString.Length == 0) &&
                    !FlagOn( ThisDirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY ) &&
                    !CdIs8dot3Name( IrpContext,
                                    ThisDirent->CdFileName.FileName )) {

                    CdGenerate8dot3Name( IrpContext,
                                         &ThisDirent->CdCaseFileName.FileName,
                                         ThisDirent->DirentOffset,
                                         FileContext->ShortName.FileName.Buffer,
                                         &FileContext->ShortName.FileName.Length );

                    //
                    //  Check if this name matches.
                    //

                    if (CdIsNameInExpression( IrpContext,
                                              &FileContext->ShortName,
                                              &Ccb->SearchExpression,
                                              Ccb->Flags,
                                              FALSE )) {

                        //
                        //  Let our caller know we found an entry.
                        //

                        Found = TRUE;
                        break;
                    }
                }
            }
        }
    }

    //
    //  If we found the entry then make sure we walk through all of the
    //  file dirents.
    //

    if (Found) {

        CdLookupLastFileDirent( IrpContext, Ccb->Fcb, FileContext );
    }

    return Found;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\fieldoff.c ===
#include "CdProcs.h"
#include <stdio.h>

#define doit(a,b) { printf("%s %04lx %4lx %s\n", #a, FIELD_OFFSET(a,b), sizeof(d.b), #b); }

VOID
__cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    printf("<Record>  <offset>  <size>  <field>\n\n");
    {
        CD_MCB d;
        doit( CD_MCB, MaximumEntryCount );
        doit( CD_MCB, CurrentEntryCount );
        doit( CD_MCB, McbArray );
    }
    printf("\n");
    {
        CD_MCB_ENTRY d;
        doit( CD_MCB_ENTRY, DiskOffset );
        doit( CD_MCB_ENTRY, ByteCount );
        doit( CD_MCB_ENTRY, FileOffset );
        doit( CD_MCB_ENTRY, DataBlockByteCount );
        doit( CD_MCB_ENTRY, TotalBlockByteCount );
    }
    printf("\n");
    {
        CD_NAME d;
        doit( CD_NAME, FileName );
        doit( CD_NAME, VersionString );
    }
    printf("\n");
    {
        NAME_LINK d;
        doit( NAME_LINK, Links );
        doit( NAME_LINK, FileName );
    }
    printf("\n");
    {
        PREFIX_ENTRY d;
        doit( PREFIX_ENTRY, Fcb );
        doit( PREFIX_ENTRY, PrefixFlags );
        doit( PREFIX_ENTRY, ExactCaseName );
        doit( PREFIX_ENTRY, IgnoreCaseName );
        doit( PREFIX_ENTRY, FileNameBuffer );
    }
    printf("\n");
    {
        CD_DATA d;
        doit( CD_DATA, NodeTypeCode );
        doit( CD_DATA, NodeByteSize );
        doit( CD_DATA, DriverObject );
        doit( CD_DATA, VcbQueue );
        doit( CD_DATA, IrpContextDepth );
        doit( CD_DATA, IrpContextMaxDepth );
        doit( CD_DATA, IrpContextList );
        doit( CD_DATA, FileSystemDeviceObject );
        doit( CD_DATA, AsyncCloseQueue );
        doit( CD_DATA, AsyncCloseCount );
        doit( CD_DATA, FspCloseActive );
        doit( CD_DATA, ReduceDelayedClose );
        doit( CD_DATA, PadUshort );
        doit( CD_DATA, DelayedCloseQueue );
        doit( CD_DATA, DelayedCloseCount );
        doit( CD_DATA, MinDelayedCloseCount );
        doit( CD_DATA, MaxDelayedCloseCount );
        doit( CD_DATA, CdDataLockThread );
        doit( CD_DATA, CdDataMutex );
        doit( CD_DATA, DataResource );
        doit( CD_DATA, CacheManagerCallbacks );
        doit( CD_DATA, CacheManagerVolumeCallbacks );
        doit( CD_DATA, CloseItem );
    }
    printf("\n");
    {
        VCB d;
        doit( VCB, NodeTypeCode );
        doit( VCB, NodeByteSize );
        doit( VCB, Vpb );
        doit( VCB, TargetDeviceObject );
        doit( VCB, VolumeLockFileObject );
        doit( VCB, VcbLinks );
        doit( VCB, VcbState );
        doit( VCB, VcbCondition );
        doit( VCB, VcbCleanup );
        doit( VCB, VcbReference );
        doit( VCB, VcbUserReference );
        doit( VCB, VolumeDasdFcb );
        doit( VCB, RootIndexFcb );
        doit( VCB, PathTableFcb );
        doit( VCB, BaseSector );
        doit( VCB, VdSectorOffset );
        doit( VCB, PrimaryVdSectorOffset );
        doit( VCB, XASector );
        doit( VCB, XADiskOffset );
        doit( VCB, VcbResource );
        doit( VCB, FileResource );
        doit( VCB, VcbMutex );
        doit( VCB, VcbLockThread );
        doit( VCB, NotifySync );
        doit( VCB, DirNotifyList );
        doit( VCB, BlockSize );
        doit( VCB, BlockToSectorShift );
        doit( VCB, BlockToByteShift );
        doit( VCB, BlocksPerSector );
        doit( VCB, BlockMask );
        doit( VCB, BlockInverseMask );
        doit( VCB, FcbTable );
        doit( VCB, CdromToc );
        doit( VCB, TocLength );
        doit( VCB, TrackCount );
        doit( VCB, DiskFlags );
        doit( VCB, BlockFactor );
    }
    printf("\n");
    {
        VOLUME_DEVICE_OBJECT d;
        doit( VOLUME_DEVICE_OBJECT, DeviceObject );
        doit( VOLUME_DEVICE_OBJECT, PostedRequestCount );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueueCount );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueue );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueueSpinLock );
        doit( VOLUME_DEVICE_OBJECT, Vcb );
    }
    printf("\n");
    {
        FCB_DATA d;
        doit( FCB_DATA, Oplock );
        doit( FCB_DATA, FileLock );
    }
    printf("\n");
    {
        FCB_INDEX d;
        doit( FCB_INDEX, FileObject );
        doit( FCB_INDEX, StreamOffset );
        doit( FCB_INDEX, FcbQueue );
        doit( FCB_INDEX, Ordinal );
        doit( FCB_INDEX, ChildPathTableOffset );
        doit( FCB_INDEX, ChildOrdinal );
        doit( FCB_INDEX, ExactCaseRoot );
        doit( FCB_INDEX, IgnoreCaseRoot );
    }
    printf("\n");
    {
        FCB_NONPAGED d;
        doit( FCB_NONPAGED, NodeTypeCode );
        doit( FCB_NONPAGED, NodeByteSize );
        doit( FCB_NONPAGED, SegmentObject );
        doit( FCB_NONPAGED, FcbResource );
        doit( FCB_NONPAGED, FcbMutex );
    }
    printf("\n");
    {
        FCB d;
        doit( FCB, Header );
        doit( FCB, Vcb );
        doit( FCB, ParentFcb );
        doit( FCB, FcbLinks );
        doit( FCB, FileId );
        doit( FCB, FcbCleanup );
        doit( FCB, FcbReference );
        doit( FCB, FcbUserReference );
        doit( FCB, FcbState );
        doit( FCB, FileAttributes );
        doit( FCB, XAAttributes );
        doit( FCB, XAFileNumber );
        doit( FCB, FcbLockThread );
        doit( FCB, FcbLockCount );
        doit( FCB, FcbNonpaged );
        doit( FCB, ShareAccess );
        doit( FCB, McbEntry );
        doit( FCB, Mcb );
        doit( FCB, ShortNamePrefix );
        doit( FCB, FileNamePrefix );
        doit( FCB, CreationTime );
        doit( FCB, FcbType );
    }
    printf("\n");
    {
        CCB d;
        doit( CCB, NodeTypeCode );
        doit( CCB, NodeByteSize );
        doit( CCB, Flags );
        doit( CCB, Fcb );
        doit( CCB, CurrentDirentOffset );
        doit( CCB, SearchExpression );
    }
    printf("\n");
    {
        IRP_CONTEXT d;
        doit( IRP_CONTEXT, NodeTypeCode );
        doit( IRP_CONTEXT, NodeByteSize );
        doit( IRP_CONTEXT, Irp );
        doit( IRP_CONTEXT, Vcb );
        doit( IRP_CONTEXT, ExceptionStatus );
        doit( IRP_CONTEXT, Flags );
        doit( IRP_CONTEXT, RealDevice );
        doit( IRP_CONTEXT, IoContext );
        doit( IRP_CONTEXT, TeardownFcb );
        doit( IRP_CONTEXT, TopLevel );
        doit( IRP_CONTEXT, MajorFunction );
        doit( IRP_CONTEXT, MinorFunction );
        doit( IRP_CONTEXT, ThreadContext );
        doit( IRP_CONTEXT, WorkQueueItem );
    }
    printf("\n");
    {
        IRP_CONTEXT_LITE d;
        doit( IRP_CONTEXT_LITE, NodeTypeCode );
        doit( IRP_CONTEXT_LITE, NodeByteSize );
        doit( IRP_CONTEXT_LITE, Fcb );
        doit( IRP_CONTEXT_LITE, DelayedCloseLinks );
        doit( IRP_CONTEXT_LITE, UserReference );
        doit( IRP_CONTEXT_LITE, RealDevice );
    }
    printf("\n");
    {
        CD_IO_CONTEXT d;
        doit( CD_IO_CONTEXT, IrpCount );
        doit( CD_IO_CONTEXT, MasterIrp );
        doit( CD_IO_CONTEXT, Status );
        doit( CD_IO_CONTEXT, AllocatedContext );
        doit( CD_IO_CONTEXT, Resource );
        doit( CD_IO_CONTEXT, ResourceThreadId );
        doit( CD_IO_CONTEXT, SyncEvent );
    }
    printf("\n");
    {
        THREAD_CONTEXT d;
        doit( THREAD_CONTEXT, Cdfs );
        doit( THREAD_CONTEXT, SavedTopLevelIrp );
        doit( THREAD_CONTEXT, TopLevelIrpContext );
    }
    printf("\n");
    {
        PATH_ENUM_CONTEXT d;
        doit( PATH_ENUM_CONTEXT, Data );
        doit( PATH_ENUM_CONTEXT, BaseOffset );
        doit( PATH_ENUM_CONTEXT, DataLength );
        doit( PATH_ENUM_CONTEXT, Bcb );
        doit( PATH_ENUM_CONTEXT, DataOffset );
        doit( PATH_ENUM_CONTEXT, AllocatedData );
        doit( PATH_ENUM_CONTEXT, LastDataBlock );
    }
    printf("\n");
    {
        PATH_ENTRY d;
        doit( PATH_ENTRY, Ordinal );
        doit( PATH_ENTRY, PathTableOffset );
        doit( PATH_ENTRY, DiskOffset );
        doit( PATH_ENTRY, PathEntryLength );
        doit( PATH_ENTRY, ParentOrdinal );
        doit( PATH_ENTRY, DirNameLen );
        doit( PATH_ENTRY, DirName );
        doit( PATH_ENTRY, Flags );
        doit( PATH_ENTRY, CdDirName );
        doit( PATH_ENTRY, CdCaseDirName );
        doit( PATH_ENTRY, NameBuffer );
    }
    printf("\n");
    {
        COMPOUND_PATH_ENTRY d;
        doit( COMPOUND_PATH_ENTRY, PathContext );
        doit( COMPOUND_PATH_ENTRY, PathEntry );
    }
    printf("\n");
    {
        DIRENT_ENUM_CONTEXT d;
        doit( DIRENT_ENUM_CONTEXT, Sector );
        doit( DIRENT_ENUM_CONTEXT, BaseOffset );
        doit( DIRENT_ENUM_CONTEXT, DataLength );
        doit( DIRENT_ENUM_CONTEXT, Bcb );
        doit( DIRENT_ENUM_CONTEXT, SectorOffset );
        doit( DIRENT_ENUM_CONTEXT, NextDirentOffset );
    }
    printf("\n");
    {
        DIRENT d;
        doit( DIRENT, DirentOffset );
        doit( DIRENT, DirentLength );
        doit( DIRENT, StartingOffset );
        doit( DIRENT, DataLength );
        doit( DIRENT, CdTime );
        doit( DIRENT, DirentFlags );
        doit( DIRENT, Flags );
        doit( DIRENT, FileUnitSize );
        doit( DIRENT, InterleaveGapSize );
        doit( DIRENT, SystemUseOffset );
        doit( DIRENT, XAAttributes );
        doit( DIRENT, XAFileNumber );
        doit( DIRENT, FileNameLen );
        doit( DIRENT, FileName );
        doit( DIRENT, CdFileName );
        doit( DIRENT, CdCaseFileName );
        doit( DIRENT, ExtentType );
        doit( DIRENT, NameBuffer );
    }
    printf("\n");
    {
        COMPOUND_DIRENT d;
        doit( COMPOUND_DIRENT, DirContext );
        doit( COMPOUND_DIRENT, Dirent );
    }
    printf("\n");
    {
        FILE_ENUM_CONTEXT d;
        doit( FILE_ENUM_CONTEXT, PriorDirent );
        doit( FILE_ENUM_CONTEXT, InitialDirent );
        doit( FILE_ENUM_CONTEXT, CurrentDirent );
        doit( FILE_ENUM_CONTEXT, Flags );
        doit( FILE_ENUM_CONTEXT, FileSize );
        doit( FILE_ENUM_CONTEXT, ShortName );
        doit( FILE_ENUM_CONTEXT, ShortNameBuffer );
        doit( FILE_ENUM_CONTEXT, Dirents );
    }
    printf("\n");
    {
        RIFF_HEADER d;
        doit( RIFF_HEADER, ChunkId );
        doit( RIFF_HEADER, ChunkSize );
        doit( RIFF_HEADER, SignatureCDXA );
        doit( RIFF_HEADER, SignatureFMT );
        doit( RIFF_HEADER, XAChunkSize );
        doit( RIFF_HEADER, OwnerId );
        doit( RIFF_HEADER, Attributes );
        doit( RIFF_HEADER, SignatureXA );
        doit( RIFF_HEADER, FileNumber );
        doit( RIFF_HEADER, Reserved );
        doit( RIFF_HEADER, SignatureData );
        doit( RIFF_HEADER, RawSectors );
    }
    printf("\n");
    {
        AUDIO_PLAY_HEADER d;
        doit( AUDIO_PLAY_HEADER, Chunk );
        doit( AUDIO_PLAY_HEADER, ChunkSize );
        doit( AUDIO_PLAY_HEADER, SignatureCDDA );
        doit( AUDIO_PLAY_HEADER, SignatureFMT );
        doit( AUDIO_PLAY_HEADER, FMTChunkSize );
        doit( AUDIO_PLAY_HEADER, FormatTag );
        doit( AUDIO_PLAY_HEADER, TrackNumber );
        doit( AUDIO_PLAY_HEADER, DiskID );
        doit( AUDIO_PLAY_HEADER, StartingSector );
        doit( AUDIO_PLAY_HEADER, SectorCount );
        doit( AUDIO_PLAY_HEADER, TrackAddress );
        doit( AUDIO_PLAY_HEADER, TrackLength );
    }
    printf("\n");
    {
        RAW_ISO_VD d;
        doit( RAW_ISO_VD, DescType );
        doit( RAW_ISO_VD, StandardId );
        doit( RAW_ISO_VD, Version );
        doit( RAW_ISO_VD, VolumeFlags );
        doit( RAW_ISO_VD, SystemId );
        doit( RAW_ISO_VD, VolumeId );
        doit( RAW_ISO_VD, Reserved );
        doit( RAW_ISO_VD, VolSpaceI );
        doit( RAW_ISO_VD, VolSpaceM );
        doit( RAW_ISO_VD, CharSet );
        doit( RAW_ISO_VD, VolSetSizeI );
        doit( RAW_ISO_VD, VolSetSizeM );
        doit( RAW_ISO_VD, VolSeqNumI );
        doit( RAW_ISO_VD, VolSeqNumM );
        doit( RAW_ISO_VD, LogicalBlkSzI );
        doit( RAW_ISO_VD, LogicalBlkSzM );
        doit( RAW_ISO_VD, PathTableSzI );
        doit( RAW_ISO_VD, PathTableSzM );
        doit( RAW_ISO_VD, PathTabLocI );
        doit( RAW_ISO_VD, PathTabLocM );
        doit( RAW_ISO_VD, RootDe );
        doit( RAW_ISO_VD, VolSetId );
        doit( RAW_ISO_VD, PublId );
        doit( RAW_ISO_VD, PreparerId );
        doit( RAW_ISO_VD, AppId );
        doit( RAW_ISO_VD, Copyright );
        doit( RAW_ISO_VD, Abstract );
        doit( RAW_ISO_VD, Bibliograph );
        doit( RAW_ISO_VD, CreateDate );
        doit( RAW_ISO_VD, ModDate );
        doit( RAW_ISO_VD, ExpireDate );
        doit( RAW_ISO_VD, EffectDate );
        doit( RAW_ISO_VD, FileStructVer );
        doit( RAW_ISO_VD, Reserved3 );
        doit( RAW_ISO_VD, ResApp );
        doit( RAW_ISO_VD, Reserved4 );
    }
    printf("\n");
    {
        RAW_HSG_VD d;
        doit( RAW_HSG_VD, BlkNumI );
        doit( RAW_HSG_VD, BlkNumM );
        doit( RAW_HSG_VD, DescType );
        doit( RAW_HSG_VD, StandardId );
        doit( RAW_HSG_VD, Version );
        doit( RAW_HSG_VD, VolumeFlags );
        doit( RAW_HSG_VD, SystemId );
        doit( RAW_HSG_VD, VolumeId );
        doit( RAW_HSG_VD, Reserved );
        doit( RAW_HSG_VD, VolSpaceI );
        doit( RAW_HSG_VD, VolSpaceM );
        doit( RAW_HSG_VD, CharSet );
        doit( RAW_HSG_VD, VolSetSizeI );
        doit( RAW_HSG_VD, VolSetSizeM );
        doit( RAW_HSG_VD, VolSeqNumI );
        doit( RAW_HSG_VD, VolSeqNumM );
        doit( RAW_HSG_VD, LogicalBlkSzI );
        doit( RAW_HSG_VD, LogicalBlkSzM );
        doit( RAW_HSG_VD, PathTableSzI );
        doit( RAW_HSG_VD, PathTableSzM );
        doit( RAW_HSG_VD, PathTabLocI );
        doit( RAW_HSG_VD, PathTabLocM );
        doit( RAW_HSG_VD, RootDe );
        doit( RAW_HSG_VD, VolSetId );
        doit( RAW_HSG_VD, PublId );
        doit( RAW_HSG_VD, PreparerId );
        doit( RAW_HSG_VD, AppId );
        doit( RAW_HSG_VD, Copyright );
        doit( RAW_HSG_VD, Abstract );
        doit( RAW_HSG_VD, CreateDate );
        doit( RAW_HSG_VD, ModDate );
        doit( RAW_HSG_VD, ExpireDate );
        doit( RAW_HSG_VD, EffectDate );
        doit( RAW_HSG_VD, FileStructVer );
        doit( RAW_HSG_VD, Reserved3 );
        doit( RAW_HSG_VD, ResApp );
        doit( RAW_HSG_VD, Reserved4 );
    }
    printf("\n");
    {
        RAW_DIRENT d;
        doit( RAW_DIRENT, DirLen );
        doit( RAW_DIRENT, XarLen );
        doit( RAW_DIRENT, FileLoc );
        doit( RAW_DIRENT, FileLocMot );
        doit( RAW_DIRENT, DataLen );
        doit( RAW_DIRENT, DataLenMot );
        doit( RAW_DIRENT, RecordTime );
        doit( RAW_DIRENT, FlagsHSG );
        doit( RAW_DIRENT, FlagsISO );
        doit( RAW_DIRENT, IntLeaveSize );
        doit( RAW_DIRENT, IntLeaveSkip );
        doit( RAW_DIRENT, Vssn );
        doit( RAW_DIRENT, VssnMot );
        doit( RAW_DIRENT, FileIdLen );
        doit( RAW_DIRENT, FileId );
    }
    printf("\n");
    {
        RAW_PATH_ISO d;
        doit( RAW_PATH_ISO, DirIdLen );
        doit( RAW_PATH_ISO, XarLen );
        doit( RAW_PATH_ISO, DirLoc );
        doit( RAW_PATH_ISO, ParentNum );
        doit( RAW_PATH_ISO, DirId );
    }
    printf("\n");
    {
        RAW_PATH_HSG d;
        doit( RAW_PATH_HSG, DirLoc );
        doit( RAW_PATH_HSG, XarLen );
        doit( RAW_PATH_HSG, DirIdLen );
        doit( RAW_PATH_HSG, ParentNum );
        doit( RAW_PATH_HSG, DirId );
    }
    printf("\n");
    {
        SYSTEM_USE_XA d;
        doit( SYSTEM_USE_XA, OwnerId );
        doit( SYSTEM_USE_XA, Attributes );
        doit( SYSTEM_USE_XA, Signature );
        doit( SYSTEM_USE_XA, FileNumber );
        doit( SYSTEM_USE_XA, Reserved );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\deviosup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the low lever disk read/write support for Cdfs.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_DEVIOSUP)

//
//  Local structure definitions
//

//
//  An array of these structures is passed to CdMultipleAsync describing
//  a set of runs to execute in parallel.
//

typedef struct _IO_RUN {

    //
    //  Disk offset to read from and number of bytes to read.  These
    //  must be a multiple of 2048 and the disk offset is also a
    //  multiple of 2048.
    //

    LONGLONG DiskOffset;
    ULONG DiskByteCount;

    //
    //  Current position in user buffer.  This is the final destination for
    //  this portion of the Io transfer.
    //

    PVOID UserBuffer;

    //
    //  Buffer to perform the transfer to.  If this is the same as the
    //  user buffer above then we are using the user's buffer.  Otherwise
    //  we either allocated a temporary buffer or are using a different portion
    //  of the user's buffer.
    //
    //  TransferBuffer - Read full sectors into this location.  This can
    //      be a pointer into the user's buffer at the exact location the
    //      data should go.  It can also be an earlier point in the user's
    //      buffer if the complete I/O doesn't start on a sector boundary.
    //      It may also be a pointer into an allocated buffer.
    //
    //  TransferByteCount - Count of bytes to transfer to user's buffer.  A
    //      value of zero indicates that we did do the transfer into the
    //      user's buffer directly.
    //
    //  TransferBufferOffset - Offset in this buffer to begin the transfer
    //      to the user's buffer.
    //

    PVOID TransferBuffer;
    ULONG TransferByteCount;
    ULONG TransferBufferOffset;

    //
    //  This is the Mdl describing the locked pages in memory.  It may
    //  be allocated to describe the allocated buffer.  Or it may be
    //  the Mdl in the originating Irp.  The MdlOffset is the offset of
    //  the current buffer from the beginning of the buffer described by
    //  the Mdl below.  If the TransferMdl is not the same as the Mdl
    //  in the user's Irp then we know we have allocated it.
    //

    PMDL TransferMdl;
    PVOID TransferVirtualAddress;

    //
    //  Associated Irp used to perform the Io.
    //

    PIRP SavedIrp;

} IO_RUN;
typedef IO_RUN *PIO_RUN;

#define MAX_PARALLEL_IOS            5

//
//  Local support routines
//

BOOLEAN
CdPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount
    );

VOID
CdPrepareXABuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount
    );

BOOLEAN
CdFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_RUN IoRuns,
    IN ULONG RunCount,
    IN BOOLEAN FinalCleanup,
    IN BOOLEAN SaveXABuffer
    );

VOID
CdMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns
    );

VOID
CdMultipleXAAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns,
    IN PRAW_READ_INFO RawReads,
    IN TRACK_MODE_TYPE TrackMode
    );

VOID
CdSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    );

VOID
CdWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
CdMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
CdReadAudioSystemFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PVOID SystemBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCreateUserMdl)
#pragma alloc_text(PAGE, CdMultipleAsync)
#pragma alloc_text(PAGE, CdMultipleXAAsync)
#pragma alloc_text(PAGE, CdNonCachedRead)
#pragma alloc_text(PAGE, CdNonCachedXARead)
#pragma alloc_text(PAGE, CdFinishBuffers)
#pragma alloc_text(PAGE, CdPerformDevIoCtrl)
#pragma alloc_text(PAGE, CdPrepareBuffers)
#pragma alloc_text(PAGE, CdReadAudioSystemFile)
#pragma alloc_text(PAGE, CdReadSectors)
#pragma alloc_text(PAGE, CdSingleAsync)
#pragma alloc_text(PAGE, CdWaitSync)
#endif


__inline
TRACK_MODE_TYPE
CdFileTrackMode (
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine converts FCB XA file type flags to the track mode
    used by the device drivers.

Arguments:

    Fcb - Fcb representing the file to read.

Return Value:

    TrackMode of the file represented by the Fcb.

--*/
{
    ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE |
                                   FCB_STATE_MODE2_FILE |
                                   FCB_STATE_DA_FILE ));

    if (FlagOn( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE )) {

        return XAForm2;

    } else if (FlagOn( Fcb->FcbState, FCB_STATE_DA_FILE )) {

        return CDDA;

    }
    
    //
    //  FCB_STATE_MODE2_FILE
    //
        
    return YellowMode2;
}


NTSTATUS
CdNonCachedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached reads to 'cooked' sectors (2048 bytes
    per sector).  This is done by performing the following in a loop.

        Fill in the IoRuns array for the next block of Io.
        Send the Io to the device.
        Perform any cleanup on the Io runs array.

    We will not do async Io to any request that generates non-aligned Io.
    Also we will not perform async Io if it will exceed the size of our
    IoRuns array.  These should be the unusual cases but we will raise
    or return CANT_WAIT in this routine if we detect this case.

Arguments:

    Fcb - Fcb representing the file to read.

    StartingOffset - Logical offset in the file to read from.

    ByteCount - Number of bytes to read.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    IO_RUN IoRuns[MAX_PARALLEL_IOS];
    ULONG RunCount = 0;
    ULONG CleanupRunCount = 0;

    PVOID UserBuffer;
    ULONG UserBufferOffset = 0;
    LONGLONG CurrentOffset = StartingOffset;
    ULONG RemainingByteCount = ByteCount;
    ULONG ThisByteCount;

    BOOLEAN Unaligned;
    BOOLEAN FlushIoBuffers = FALSE;
    BOOLEAN FirstPass = TRUE;

    PAGED_CODE();

    //
    //  We want to make sure the user's buffer is locked in all cases.
    //

    if (IrpContext->Irp->MdlAddress == NULL) {

        CdCreateUserMdl( IrpContext, ByteCount, TRUE );
    }

    CdMapUserBuffer( IrpContext, &UserBuffer);

    //
    //  Special case the root directory and path table for a music volume.
    //

    if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_AUDIO_DISK ) &&
        ((SafeNodeType( Fcb ) == CDFS_NTC_FCB_INDEX) ||
         (SafeNodeType( Fcb ) == CDFS_NTC_FCB_PATH_TABLE))) {

        CdReadAudioSystemFile( IrpContext,
                               Fcb,
                               StartingOffset,
                               ByteCount,
                               UserBuffer );

        return STATUS_SUCCESS;
    }

    //
    //  Use a try-finally to perform the final cleanup.
    //

    try {

        //
        //  Loop while there are more bytes to transfer.
        //

        do {

            //
            //  Call prepare buffers to set up the next entries
            //  in the IoRuns array.  Remember if there are any
            //  unaligned entries.  This routine will raise CANT_WAIT 
            //  if there are unaligned entries for an async request.
            //

            RtlZeroMemory( IoRuns, sizeof( IoRuns ));

            Unaligned = CdPrepareBuffers( IrpContext,
                                          IrpContext->Irp,
                                          Fcb,
                                          UserBuffer,
                                          UserBufferOffset,
                                          CurrentOffset,
                                          RemainingByteCount,
                                          IoRuns,
                                          &CleanupRunCount,
                                          &ThisByteCount );


            RunCount = CleanupRunCount;

            //
            //  If this is an async request and there aren't enough entries
            //  in the Io array then post the request.
            //

            if ((ThisByteCount < RemainingByteCount) &&
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  If the entire Io is contained in a single run then
            //  we can pass the Io down to the driver.  Send the driver down
            //  and wait on the result if this is synchronous.
            //

            if ((RunCount == 1) && !Unaligned && FirstPass) {

                CdSingleAsync( IrpContext,
                               IoRuns[0].DiskOffset,
                               IoRuns[0].DiskByteCount );

                //
                //  No cleanup needed for the IoRuns array here.
                //

                CleanupRunCount = 0;

                //
                //  Wait if we are synchronous, otherwise return
                //

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                    CdWaitSync( IrpContext );

                    Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Our completion routine will free the Io context but
                //  we do want to return STATUS_PENDING.
                //

                } else {

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                    Status = STATUS_PENDING;
                }

                try_return( NOTHING );
            }

            //
            //  Otherwise we will perform multiple Io to read in the data.
            //

            CdMultipleAsync( IrpContext, RunCount, IoRuns );

            //
            //  If this is a synchronous request then perform any necessary
            //  post-processing.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                //
                //  Wait for the request to complete.
                //

                CdWaitSync( IrpContext );

                Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Exit this loop if there is an error.
                //

                if (!NT_SUCCESS( Status )) {

                    try_return( NOTHING );
                }

                //
                //  Perform post read operations on the IoRuns if
                //  necessary.
                //

                if (Unaligned &&
                    CdFinishBuffers( IrpContext, IoRuns, RunCount, FALSE, FALSE )) {

                    FlushIoBuffers = TRUE;
                }
                
                CleanupRunCount = 0;

                //
                //  Exit this loop if there are no more bytes to transfer
                //  or we have any error.
                //

                RemainingByteCount -= ThisByteCount;
                CurrentOffset += ThisByteCount;
                UserBuffer = Add2Ptr( UserBuffer, ThisByteCount, PVOID );
                UserBufferOffset += ThisByteCount;

            //
            //  Otherwise this is an asynchronous request.  Always return
            //  STATUS_PENDING.
            //

            } else {

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                CleanupRunCount = 0;
                try_return( Status = STATUS_PENDING );
                break;
            }

            FirstPass = FALSE;
        } while (RemainingByteCount != 0);

        //
        //  Flush the hardware cache if we performed any copy operations.
        //

        if (FlushIoBuffers) {

            KeFlushIoBuffers( IrpContext->Irp->MdlAddress, TRUE, FALSE );
        }

    try_exit:  NOTHING;
    } finally {

        //
        //  Perform final cleanup on the IoRuns if necessary.
        //

        if (CleanupRunCount != 0) {

            CdFinishBuffers( IrpContext, IoRuns, CleanupRunCount, TRUE, FALSE );
        }
    }

    return Status;
}


NTSTATUS
CdNonCachedXARead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached reads for 'raw' sectors (2352 bytes
    per sector).  We also prepend a hard-coded RIFF header of 44 bytes to the file.
    All of this is already reflected in the file size.

    We start by checking whether to prepend any portion of the RIFF header.  Then we check
    if the last raw sector read was from the beginning portion of this file, deallocating
    that buffer if necessary.  Finally we do the following in a loop.

        Fill the IoRuns array for the next block of Io.
        Send the Io to the device driver.
        Perform any cleanup necessary on the IoRuns array.

    We will not do any async request in this path.  The request would have been
    posted to a worker thread before getting to this point.

Arguments:

    Fcb - Fcb representing the file to read.

    StartingOffset - Logical offset in the file to read from.

    ByteCount - Number of bytes to read.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    RIFF_HEADER LocalRiffHeader;
    PRIFF_HEADER RiffHeader;

    RAW_READ_INFO RawReads[MAX_PARALLEL_IOS];
    IO_RUN IoRuns[MAX_PARALLEL_IOS];
    ULONG RunCount = 0;
    ULONG CleanupRunCount = 0;

    PVOID UserBuffer;
    ULONG UserBufferOffset = 0;
    LONGLONG CurrentOffset = StartingOffset;
    ULONG RemainingByteCount = ByteCount;
    ULONG ThisByteCount;

    BOOLEAN TryingYellowbookMode2 = FALSE;

    TRACK_MODE_TYPE TrackMode;

    PAGED_CODE();

    //
    //  We want to make sure the user's buffer is locked in all cases.
    //

    if (IrpContext->Irp->MdlAddress == NULL) {

        CdCreateUserMdl( IrpContext, ByteCount, TRUE );
    }

    //
    //  The byte count was rounded up to a logical sector boundary.  It has
    //  nothing to do with the raw sectors on disk.  Limit the remaining
    //  byte count to file size.
    //

    if (CurrentOffset + RemainingByteCount > Fcb->FileSize.QuadPart) {

        RemainingByteCount = (ULONG) (Fcb->FileSize.QuadPart - CurrentOffset);
    }

    CdMapUserBuffer( IrpContext, &UserBuffer);

    //
    //  Use a try-finally to perform the final cleanup.
    //

    try {

        //
        //  If the initial offset lies within the RIFF header then copy the
        //  necessary bytes to the user's buffer.
        //

        if (CurrentOffset < sizeof( RIFF_HEADER )) {

            //
            //  Copy the appropriate RIFF header.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_DA_FILE )) {

                //
                //  Create the pseudo entries for a music disk.
                //

                if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_AUDIO_DISK )) {

                    PAUDIO_PLAY_HEADER AudioPlayHeader;
                    PTRACK_DATA TrackData;
                    ULONG SectorCount;

                    AudioPlayHeader = (PAUDIO_PLAY_HEADER) &LocalRiffHeader;
                    TrackData = &Fcb->Vcb->CdromToc->TrackData[Fcb->XAFileNumber];

                    //
                    //  Copy the data header into our local buffer.
                    //

                    RtlCopyMemory( AudioPlayHeader,
                                   CdAudioPlayHeader,
                                   sizeof( AUDIO_PLAY_HEADER ));

                    //
                    //  Copy the serial number into the Id field.  Also
                    //  the track number in the TOC.
                    //

                    AudioPlayHeader->DiskID = Fcb->Vcb->Vpb->SerialNumber;
                    AudioPlayHeader->TrackNumber = TrackData->TrackNumber;

                    //
                    //  TOC contains MSF (Minute/Second/Frame) addresses.  This is very
                    //  arcane, and we wind up having to bias around by the size of the
                    //  leadins and other such silliness to find real live sector addrs.
                    //
                    //  One frame == One sector.
                    //  One second == 75 frames (winds up being a 44.1khz sample)
                    //

                    //
                    //  Fill in the address and length fields.
                    //

                    AudioPlayHeader->TrackAddress[2] = TrackData->Address[1];
                    AudioPlayHeader->TrackAddress[1] = TrackData->Address[2];
                    AudioPlayHeader->TrackAddress[0] = TrackData->Address[3];

                    AudioPlayHeader->StartingSector = TrackData->Address[3];
                    AudioPlayHeader->StartingSector += (TrackData->Address[2] * 75);
                    AudioPlayHeader->StartingSector += (TrackData->Address[1] * 60 * 75);

                    //
                    //  Subtract 2 seconds for the block number.
                    //

                    AudioPlayHeader->StartingSector -= 150;

                    //
                    //  Go to the next track and find the starting point.
                    //

                    TrackData = &Fcb->Vcb->CdromToc->TrackData[Fcb->XAFileNumber + 1];

                    AudioPlayHeader->SectorCount = TrackData->Address[3];
                    AudioPlayHeader->SectorCount += (TrackData->Address[2] * 75);
                    AudioPlayHeader->SectorCount += (TrackData->Address[1] * 60 * 75);

                    //
                    //  Bias the sector count by 2 seconds.
                    //  Check that the offset is at least two seconds.
                    //

                    if (AudioPlayHeader->SectorCount < 150) {

                        AudioPlayHeader->SectorCount = 0;

                    } else {

                        AudioPlayHeader->SectorCount -= 150;
                    }

                    //
                    //  Now compute the difference.  If there is an error then use
                    //  a length of zero.
                    //

                    if (AudioPlayHeader->SectorCount < AudioPlayHeader->StartingSector) {

                        AudioPlayHeader->SectorCount = 0;

                    } else {

                        AudioPlayHeader->SectorCount -= AudioPlayHeader->StartingSector;
                    }

                    //
                    //  Use the sector count to determine the MSF length.
                    //

                    SectorCount = AudioPlayHeader->SectorCount;

                    AudioPlayHeader->TrackLength[0] = (UCHAR) (SectorCount % 75);
                    SectorCount /= 75;

                    AudioPlayHeader->TrackLength[1] = (UCHAR) (SectorCount % 60);
                    SectorCount /= 60;

                    AudioPlayHeader->TrackLength[2] = (UCHAR) (SectorCount % 60);

                    ThisByteCount = sizeof( RIFF_HEADER ) - (ULONG) CurrentOffset;

                    RtlCopyMemory( UserBuffer,
                                   Add2Ptr( AudioPlayHeader,
                                            sizeof( RIFF_HEADER ) - ThisByteCount,
                                            PCHAR ),
                                   ThisByteCount );

                //
                //  CD-XA CDDA
                //

                } else {

                    //
                    //  The WAVE header format is actually much closer to an audio play
                    //  header in format but we only need to modify the filesize fields.
                    //

                    RiffHeader = &LocalRiffHeader;

                    //
                    //  Copy the data header into our local buffer and add the file size to it.
                    //

                    RtlCopyMemory( RiffHeader,
                                   CdXAAudioPhileHeader,
                                   sizeof( RIFF_HEADER ));

                    RiffHeader->ChunkSize += Fcb->FileSize.LowPart;
                    RiffHeader->RawSectors += Fcb->FileSize.LowPart;

                    ThisByteCount = sizeof( RIFF_HEADER ) - (ULONG) CurrentOffset;
                    RtlCopyMemory( UserBuffer,
                                   Add2Ptr( RiffHeader,
                                            sizeof( RIFF_HEADER ) - ThisByteCount,
                                            PCHAR ),
                                   ThisByteCount );
                }

            //
            //  CD-XA non-audio
            //
            
            } else { 
    
                ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_MODE2_FILE | FCB_STATE_MODE2FORM2_FILE ));

                RiffHeader = &LocalRiffHeader;

                //
                //  Copy the data header into our local buffer and add the file size to it.
                //

                RtlCopyMemory( RiffHeader,
                               CdXAFileHeader,
                               sizeof( RIFF_HEADER ));

                RiffHeader->ChunkSize += Fcb->FileSize.LowPart;
                RiffHeader->RawSectors += Fcb->FileSize.LowPart;

                RiffHeader->Attributes = (USHORT) Fcb->XAAttributes;
                RiffHeader->FileNumber = (UCHAR) Fcb->XAFileNumber;

                ThisByteCount = sizeof( RIFF_HEADER ) - (ULONG) CurrentOffset;
                RtlCopyMemory( UserBuffer,
                               Add2Ptr( RiffHeader,
                                        sizeof( RIFF_HEADER ) - ThisByteCount,
                                        PCHAR ),
                               ThisByteCount );
            }

            //
            //  Adjust the starting offset and byte count to reflect that
            //  we copied over the RIFF bytes.
            //

            UserBuffer = Add2Ptr( UserBuffer, ThisByteCount, PVOID );
            UserBufferOffset += ThisByteCount;
            CurrentOffset += ThisByteCount;
            RemainingByteCount -= ThisByteCount;
        }

        //
        //  Set up the appropriate trackmode
        //

        TrackMode = CdFileTrackMode(Fcb);

        //
        //  Loop while there are more bytes to transfer.
        //

        while (RemainingByteCount != 0) {

            //
            //  Call prepare buffers to set up the next entries
            //  in the IoRuns array.  Remember if there are any
            //  unaligned entries.  If we're just retrying the previous
            //  runs with a different track mode,  then don't do anything here.
            //

            if (!TryingYellowbookMode2)  {
            
                RtlZeroMemory( IoRuns, sizeof( IoRuns ));
                RtlZeroMemory( RawReads, sizeof( RawReads ));

                CdPrepareXABuffers( IrpContext,
                                    IrpContext->Irp,
                                    Fcb,
                                    UserBuffer,
                                    UserBufferOffset,
                                    CurrentOffset,
                                    RemainingByteCount,
                                    IoRuns,
                                    &CleanupRunCount,
                                    &ThisByteCount );
            }
            
            //
            //  Perform multiple Io to read in the data.  Note that
            //  there may be no Io to do if we were able to use an
            //  existing buffer from the Vcb.
            //

            if (CleanupRunCount != 0) {

                RunCount = CleanupRunCount;

                CdMultipleXAAsync( IrpContext,
                                   RunCount,
                                   IoRuns,
                                   RawReads,
                                   TrackMode );
                //
                //  Wait for the request to complete.
                //

                CdWaitSync( IrpContext );

                Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Exit this loop if there is an error.
                //

                if (!NT_SUCCESS( Status )) {

                    if (!TryingYellowbookMode2 && 
                        FlagOn( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE )) {

                        //
                        //  There are wacky cases where someone has mastered as CD-XA
                        //  but the sectors they claim are Mode2Form2 are really, according
                        //  to ATAPI devices, Yellowbook Mode2. We will try once more
                        //  with these. Kodak PHOTO-CD has been observed to do this.
                        //

                        TryingYellowbookMode2 = TRUE;
                        TrackMode = YellowMode2;
                        
                        //
                        //  Clear our 'cumulative' error status value
                        //
                        
                        IrpContext->IoContext->Status = STATUS_SUCCESS;

                        continue;
                    }

                    try_return( NOTHING );
                }
                
                CleanupRunCount = 0;
                
                if (TryingYellowbookMode2) {

                    //
                    //  We succesfully got data when we tried switching the trackmode,
                    //  so change the state of the FCB to remember that.
                    //

                    SetFlag( Fcb->FcbState, FCB_STATE_MODE2_FILE );
                    ClearFlag( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE );

                    TryingYellowbookMode2 = FALSE;
                }

                //
                //  Perform post read operations on the IoRuns if
                //  necessary.
                //

                CdFinishBuffers( IrpContext, IoRuns, RunCount, FALSE, TRUE );
            }

            //
            //  Adjust our loop variants.
            //

            RemainingByteCount -= ThisByteCount;
            CurrentOffset += ThisByteCount;
            UserBuffer = Add2Ptr( UserBuffer, ThisByteCount, PVOID );
            UserBufferOffset += ThisByteCount;
        }

        //
        //  Always flush the hardware cache.
        //

        KeFlushIoBuffers( IrpContext->Irp->MdlAddress, TRUE, FALSE );

    try_exit:  NOTHING;
    } finally {

        //
        //  Perform final cleanup on the IoRuns if necessary.
        //

        if (CleanupRunCount != 0) {

            CdFinishBuffers( IrpContext, IoRuns, CleanupRunCount, TRUE, FALSE );
        }
    }

    return Status;
}


BOOLEAN
CdReadSectors (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN BOOLEAN ReturnError,
    IN OUT PVOID Buffer,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine is called to transfer sectors from the disk to a
    specified buffer.  It is used for mount and volume verify operations.

    This routine is synchronous, it will not return until the operation
    is complete or until the operation fails.

    The routine allocates an IRP and then passes this IRP to a lower
    level driver.  Errors may occur in the allocation of this IRP or
    in the operation of the lower driver.

Arguments:

    StartingOffset - Logical offset on the disk to start the read.  This
        must be on a sector boundary, no check is made here.

    ByteCount - Number of bytes to read.  This is an integral number of
        2K sectors, no check is made here to confirm this.

    ReturnError - Indicates whether we should return TRUE or FALSE
        to indicate an error or raise an error condition.  This only applies
        to the result of the IO.  Any other error may cause a raise.

    Buffer - Buffer to transfer the disk data into.

    TargetDeviceObject - The device object for the volume to be read.

Return Value:

    BOOLEAN - Depending on 'RaiseOnError' flag above.  TRUE if operation
              succeeded, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    KEVENT  Event;
    PIRP Irp;

    PAGED_CODE();

    //
    //  Initialize the event.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Attempt to allocate the IRP.  If unsuccessful, raise
    //  STATUS_INSUFFICIENT_RESOURCES.
    //

    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        TargetDeviceObject,
                                        Buffer,
                                        ByteCount,
                                        (PLARGE_INTEGER) &StartingOffset,
                                        &Event,
                                        &IrpContext->Irp->IoStatus );

    if (Irp == NULL) {

        CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Ignore the change line (verify) for mount and verify requests
    //

    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    //
    //  Send the request down to the driver.  If an error occurs return
    //  it to the caller.
    //

    Status = IoCallDriver( TargetDeviceObject, Irp );

    //
    //  If the status was STATUS_PENDING then wait on the event.
    //

    if (Status == STATUS_PENDING) {

        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );

        //
        //  On a successful wait pull the status out of the IoStatus block.
        //

        if (NT_SUCCESS( Status )) {

            Status = IrpContext->Irp->IoStatus.Status;
        }
    }

    //
    //  Check whether we should raise in the error case.
    //

    if (!NT_SUCCESS( Status )) {

        if (!ReturnError) {

            CdNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  We don't raise, but return FALSE to indicate an error.
        //

        return FALSE;

    //
    //  The operation completed successfully.
    //

    } else {

        return TRUE;
    }
}


NTSTATUS
CdCreateUserMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BufferLength,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine locks the specified buffer for read access (we only write into
    the buffer).  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

    This routine is only called if there is not already an Mdl.

Arguments:

    BufferLength - Length of user buffer.

    RaiseOnError - Indicates if our caller wants this routine to raise on
        an error condition.

Return Value:

    NTSTATUS - Status from this routine.  Error status only returned if
        RaiseOnError is FALSE.

--*/

{
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
    PMDL Mdl;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( IrpContext->Irp );
    ASSERT( IrpContext->Irp->MdlAddress == NULL );

    //
    // Allocate the Mdl, and Raise if we fail.
    //

    Mdl = IoAllocateMdl( IrpContext->Irp->UserBuffer,
                         BufferLength,
                         FALSE,
                         FALSE,
                         IrpContext->Irp );

    if (Mdl != NULL) {

        //
        //  Now probe the buffer described by the Irp.  If we get an exception,
        //  deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl, IrpContext->Irp->RequestorMode, IoWriteAccess );

            Status = STATUS_SUCCESS;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            IrpContext->Irp->MdlAddress = NULL;

            if (!FsRtlIsNtstatusExpected( Status )) {

                Status = STATUS_INVALID_USER_BUFFER;
            }
        }
    }

    //
    //  Check if we are to raise or return
    //

    if (Status != STATUS_SUCCESS) {

        if (RaiseOnError) {

            CdRaiseStatus( IrpContext, Status );
        }
    }

    //
    //  Return the status code.
    //

    return Status;
}


NTSTATUS
CdPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform DevIoCtrl functions internally within
    the filesystem.  We take the status from the driver and return it to our
    caller.

Arguments:

    IoControlCode - Code to send to driver.

    Device - This is the device to send the request to.

    OutPutBuffer - Pointer to output buffer.

    OutputBufferLength - Length of output buffer above.

    InternalDeviceIoControl - Indicates if this is an internal or external
        Io control code.

    OverrideVerify - Indicates if we should tell the driver not to return
        STATUS_VERIFY_REQUIRED for mount and verify.

    Iosb - If specified, we return the results of the operation here.

Return Value:

    NTSTATUS - Status returned by next lower driver.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK LocalIosb;
    PIO_STATUS_BLOCK IosbToUse = &LocalIosb;

    PAGED_CODE();

    //
    //  Check if the user gave us an Iosb.
    //

    if (ARGUMENT_PRESENT( Iosb )) {

        IosbToUse = Iosb;
    }

    IosbToUse->Status = 0;
    IosbToUse->Information = 0;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IoControlCode,
                                         Device,
                                         NULL,
                                         0,
                                         OutputBuffer,
                                         OutputBufferLength,
                                         InternalDeviceIoControl,
                                         &Event,
                                         IosbToUse );

    if (Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (OverrideVerify) {

        SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    Status = IoCallDriver( Device, Irp );

    //
    //  We check for device not ready by first checking Status
    //  and then if status pending was returned, the Iosb status
    //  value.
    //

    if (Status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER)NULL );

        Status = IosbToUse->Status;
    }

    ASSERT( !(OverrideVerify && (STATUS_VERIFY_REQUIRED == Status)));

    return Status;
}


//
//  Local support routine
//

BOOLEAN
CdPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount
    )

/*++

Routine Description:

    This routine is the worker routine which looks up each run of an IO
    request and stores an entry for it in the IoRuns array.  If the run
    begins on an unaligned disk boundary then we will allocate a buffer
    and Mdl for the unaligned portion and put it in the IoRuns entry.

    This routine will raise CANT_WAIT if an unaligned transfer is encountered
    and this request can't wait.

Arguments:

    Irp - Originating Irp for this request.

    Fcb - This is the Fcb for this data stream.  It may be a file, directory,
        path table or the volume file.

    UserBuffer - Current position in the user's buffer.

    UserBufferOffset - Offset from the start of the original user buffer.

    StartingOffset - Offset in the stream to begin the read.

    ByteCount - Number of bytes to read.  We will fill the IoRuns array up
        to this point.  We will stop early if we exceed the maximum number
        of parallel Ios we support.

    IoRuns - Pointer to the IoRuns array.  The entire array is zeroes when
        this routine is called.

    RunCount - Number of entries in the IoRuns array filled here.

    ThisByteCount - Number of bytes described by the IoRun entries.  Will
        not exceed the ByteCount passed in.

Return Value:

    BOOLEAN - TRUE if one of the entries in an unaligned buffer (provided
        this is synchronous).  FALSE otherwise.

--*/

{
    BOOLEAN FoundUnaligned = FALSE;
    PIO_RUN ThisIoRun = IoRuns;

    //
    //  Following indicate where we are in the current transfer.  Current
    //  position in the file and number of bytes yet to transfer from
    //  this position.
    //

    ULONG RemainingByteCount = ByteCount;
    LONGLONG CurrentFileOffset = StartingOffset;

    //
    //  Following indicate the state of the user's buffer.  We have
    //  the destination of the next transfer and its offset in the
    //  buffer.  We also have the next available position in the buffer
    //  available for a scratch buffer.  We will align this up to a sector
    //  boundary.
    //

    PVOID CurrentUserBuffer = UserBuffer;
    ULONG CurrentUserBufferOffset = UserBufferOffset;

    PVOID ScratchUserBuffer = UserBuffer;
    ULONG ScratchUserBufferOffset = UserBufferOffset;

    //
    //  The following is the next contiguous bytes on the disk to
    //  transfer.  Read from the allocation package.
    //

    LONGLONG DiskOffset;
    ULONG CurrentByteCount;

    PAGED_CODE();

    //
    //  Initialize the RunCount and ByteCount.
    //

    *RunCount = 0;
    *ThisByteCount = 0;

    //
    //  Loop while there are more bytes to process or there are
    //  available entries in the IoRun array.
    //

    while (TRUE) {

        *RunCount += 1;

        //
        //  Initialize the current position in the IoRuns array.
        //  Find the user's buffer for this portion of the transfer.
        //

        ThisIoRun->UserBuffer = CurrentUserBuffer;

        //
        //  Find the allocation information for the current offset in the
        //  stream.
        //

        CdLookupAllocation( IrpContext,
                            Fcb,
                            CurrentFileOffset,
                            &DiskOffset,
                            &CurrentByteCount );

        //
        //  Limit ourselves to the data requested.
        //

        if (CurrentByteCount > RemainingByteCount) {

            CurrentByteCount = RemainingByteCount;
        }

        //
        //  Handle the case where this is an unaligned transfer.  The
        //  following must all be true for this to be an aligned transfer.
        //
        //      Disk offset on a 2048 byte boundary (Start of transfer)
        //
        //      Byte count is a multiple of 2048 (Length of transfer)
        //
        //      Current buffer offset is also on a 2048 byte boundary.
        //
        //  If the ByteCount is at least one sector then do the
        //  unaligned transfer only for the tail.  We can use the
        //  user's buffer for the aligned portion.
        //

        if (FlagOn( (ULONG) DiskOffset, SECTOR_MASK ) ||
            FlagOn( CurrentUserBufferOffset, SECTOR_MASK ) ||
            (FlagOn( (ULONG) CurrentByteCount, SECTOR_MASK ) &&
             (CurrentByteCount < SECTOR_SIZE))) {

            //
            //  If we can't wait then raise.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  Remember the offset and the number of bytes out of
            //  the transfer buffer to copy into the user's buffer.
            //  We will truncate the current read to end on a sector
            //  boundary.
            //

            ThisIoRun->TransferBufferOffset = SectorOffset( DiskOffset );

            //
            //  Make sure this transfer ends on a sector boundary.
            //

            ThisIoRun->DiskOffset = LlSectorTruncate( DiskOffset );

            //
            //  Check if we can use a free portion of the user's buffer.
            //  If we can copy the bytes to an earlier portion of the
            //  buffer then read into that location and slide the bytes
            //  up.
            //
            //  We can use the user's buffer if:
            //
            //      The temporary location in the buffer is before the
            //      final destination.
            //
            //      There is at least one sector of data to read.
            //

            if ((ScratchUserBufferOffset + ThisIoRun->TransferBufferOffset < CurrentUserBufferOffset) &&
                (ThisIoRun->TransferBufferOffset + CurrentByteCount >= SECTOR_SIZE)) {

                ThisIoRun->DiskByteCount = SectorTruncate( ThisIoRun->TransferBufferOffset + CurrentByteCount );
                CurrentByteCount = ThisIoRun->DiskByteCount - ThisIoRun->TransferBufferOffset;
                ThisIoRun->TransferByteCount = CurrentByteCount;

                //
                //  Point to the user's buffer and Mdl for this transfer.
                //

                ThisIoRun->TransferBuffer = ScratchUserBuffer;
                ThisIoRun->TransferMdl = Irp->MdlAddress;
                ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer,
                                                             ScratchUserBufferOffset,
                                                             PVOID );

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             ThisIoRun->DiskByteCount,
                                             PVOID );

                ScratchUserBufferOffset += ThisIoRun->DiskByteCount;

            //
            //  Otherwise we need to allocate an auxilary buffer for the next sector.
            //

            } else {

                //
                //  Read up to a page containing the partial data
                //

                ThisIoRun->DiskByteCount = SectorAlign( ThisIoRun->TransferBufferOffset + CurrentByteCount );

                if (ThisIoRun->DiskByteCount > PAGE_SIZE) {

                    ThisIoRun->DiskByteCount = PAGE_SIZE;
                }

                if (ThisIoRun->TransferBufferOffset + CurrentByteCount > ThisIoRun->DiskByteCount) {

                    CurrentByteCount = ThisIoRun->DiskByteCount - ThisIoRun->TransferBufferOffset;
                }

                ThisIoRun->TransferByteCount = CurrentByteCount;

                //
                //  Allocate a buffer for the non-aligned transfer.
                //

                ThisIoRun->TransferBuffer = FsRtlAllocatePoolWithTag( CdNonPagedPool, PAGE_SIZE, TAG_IO_BUFFER );

                //
                //  Allocate and build the Mdl to describe this buffer.
                //

                ThisIoRun->TransferMdl = IoAllocateMdl( ThisIoRun->TransferBuffer,
                                                        PAGE_SIZE,
                                                        FALSE,
                                                        FALSE,
                                                        NULL );

                ThisIoRun->TransferVirtualAddress = ThisIoRun->TransferBuffer;

                if (ThisIoRun->TransferMdl == NULL) {

                    IrpContext->Irp->IoStatus.Information = 0;
                    CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
                }

                MmBuildMdlForNonPagedPool( ThisIoRun->TransferMdl );
            }

            //
            //  Remember we found an unaligned transfer.
            //

            FoundUnaligned = TRUE;

        //
        //  Otherwise we use the buffer and Mdl from the original request.
        //

        } else {

            //
            //  Truncate the read length to a sector-aligned value.  We know
            //  the length must be at least one sector or we wouldn't be
            //  here now.
            //

            CurrentByteCount = SectorTruncate( CurrentByteCount );

            //
            //  Read these sectors from the disk.
            //

            ThisIoRun->DiskOffset = DiskOffset;
            ThisIoRun->DiskByteCount = CurrentByteCount;

            //
            //  Use the user's buffer and Mdl as our transfer buffer
            //  and Mdl.
            //

            ThisIoRun->TransferBuffer = CurrentUserBuffer;
            ThisIoRun->TransferMdl = Irp->MdlAddress;
            ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer,
                                                         CurrentUserBufferOffset,
                                                         PVOID );

            ScratchUserBuffer = Add2Ptr( CurrentUserBuffer,
                                         CurrentByteCount,
                                         PVOID );

            ScratchUserBufferOffset += CurrentByteCount;
        }

        //
        //  Update our position in the transfer and the RunCount and
        //  ByteCount for the user.
        //

        RemainingByteCount -= CurrentByteCount;

        //
        //  Break out if no more positions in the IoRuns array or
        //  we have all of the bytes accounted for.
        //

        *ThisByteCount += CurrentByteCount;

        if ((RemainingByteCount == 0) || (*RunCount == MAX_PARALLEL_IOS)) {

            break;
        }

        //
        //  Update our pointers for the user's buffer.
        //

        ThisIoRun += 1;
        CurrentUserBuffer = Add2Ptr( CurrentUserBuffer, CurrentByteCount, PVOID );
        CurrentUserBufferOffset += CurrentByteCount;
        CurrentFileOffset += CurrentByteCount;
    }

    return FoundUnaligned;
}


//
//  Local support routine
//

VOID
CdPrepareXABuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount
    )

/*++

Routine Description:

    This routine is the worker routine which looks up the individual runs
    of an IO request and stores an entry for it in the IoRuns array.  The
    worker routine is for XA files where we need to convert the raw offset
    in the file to logical cooked sectors.  We store one raw sector in
    the Vcb.  If the current read is to that sector then we can simply copy
    whatever bytes are needed from that sector.

Arguments:

    Irp - Originating Irp for this request.

    Fcb - This is the Fcb for this data stream.  It must be a data stream.

    UserBuffer - Current position in the user's buffer.

    UserBufferOffset - Offset of this buffer from the beginning of the user's
        buffer for the original request.

    StartingOffset - Offset in the stream to begin the read.

    ByteCount - Number of bytes to read.  We will fill the IoRuns array up
        to this point.  We will stop early if we exceed the maximum number
        of parallel Ios we support.

    IoRuns - Pointer to the IoRuns array.  The entire array is zeroes when
        this routine is called.

    RunCount - Number of entries in the IoRuns array filled here.

    ThisByteCount - Number of bytes described by the IoRun entries.  Will
        not exceed the ByteCount passed in.

Return Value:

    None

--*/

{
    PIO_RUN ThisIoRun = IoRuns;
    BOOLEAN PerformedCopy;

    //
    //  The following deal with where we are in the range of raw sectors.
    //  Note that we will bias the input file offset by the RIFF header
    //  to deal directly with the raw sectors.
    //

    ULONG RawSectorOffset;
    ULONG RemainingRawByteCount = ByteCount;
    LONGLONG CurrentRawOffset = StartingOffset - sizeof( RIFF_HEADER );

    //
    //  The following is the offset into the cooked sectors for the file.
    //

    LONGLONG CurrentCookedOffset;
    ULONG RemainingCookedByteCount;

    //
    //  Following indicate the state of the user's buffer.  We have
    //  the destination of the next transfer and its offset in the
    //  buffer.  We also have the next available position in the buffer
    //  available for a scratch buffer.
    //

    PVOID CurrentUserBuffer = UserBuffer;
    ULONG CurrentUserBufferOffset = UserBufferOffset;

    PVOID ScratchUserBuffer = UserBuffer;
    ULONG ScratchUserBufferOffset = UserBufferOffset;
    BOOLEAN RoundScratchBuffer = TRUE;

    //
    //  The following is the next contiguous bytes on the disk to
    //  transfer.  These are represented by cooked byte offset and length.
    //  We also compute the number of raw bytes in the current transfer.
    //

    LONGLONG DiskOffset;
    ULONG CurrentCookedByteCount;
    ULONG CurrentRawByteCount;

    PAGED_CODE();

    //
    //  We need to maintain our position as we walk through the sectors on the disk.
    //  We keep separate values for the cooked offset as well as the raw offset.
    //  These are initialized on sector boundaries and we move through these
    //  the file sector-by-sector.
    //
    //  Try to do 32-bit math.
    //

    if (((PLARGE_INTEGER) &CurrentRawOffset)->HighPart == 0) {

        CurrentRawOffset = (LONGLONG) ((ULONG) CurrentRawOffset / RAW_SECTOR_SIZE);

        CurrentCookedOffset = (LONGLONG) ((ULONG) CurrentRawOffset << SECTOR_SHIFT );

        CurrentRawOffset = (LONGLONG) ((ULONG) CurrentRawOffset * RAW_SECTOR_SIZE);

    //
    //  Otherwise we need to do 64-bit math (sigh).
    //

    } else {

        CurrentRawOffset /= RAW_SECTOR_SIZE;

        CurrentCookedOffset = CurrentRawOffset << SECTOR_SHIFT;

        CurrentRawOffset *= RAW_SECTOR_SIZE;
    }

    //
    //  Now compute the full number of sectors to be read.  Count all of the raw
    //  sectors that need to be read and convert to cooked bytes.
    //

    RawSectorOffset = (ULONG) ( StartingOffset - CurrentRawOffset) - sizeof( RIFF_HEADER );
    CurrentRawByteCount = (RawSectorOffset + RemainingRawByteCount + RAW_SECTOR_SIZE - 1) / RAW_SECTOR_SIZE;

    RemainingCookedByteCount = CurrentRawByteCount << SECTOR_SHIFT;

    //
    //  Initialize the RunCount and ByteCount.
    //

    *RunCount = 0;
    *ThisByteCount = 0;

    //
    //  Loop while there are more bytes to process or there are
    //  available entries in the IoRun array.
    //

    while (TRUE) {

        PerformedCopy = FALSE;
        *RunCount += 1;

        //
        //  Round the scratch buffer up to a sector boundary for alignment.
        //

        if (RoundScratchBuffer) {

            if (SectorOffset( ScratchUserBuffer ) != 0) {

                CurrentRawByteCount = SECTOR_SIZE - SectorOffset( ScratchUserBuffer );

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             CurrentRawByteCount,
                                             PVOID );

                ScratchUserBufferOffset += CurrentRawByteCount;
            }

            RoundScratchBuffer = FALSE;
        }

        //
        //  Initialize the current position in the IoRuns array.  Find the 
        //  eventual destination in the user's buffer for this portion of the transfer.
        //

        ThisIoRun->UserBuffer = CurrentUserBuffer;

        //
        //  Find the allocation information for the current offset in the
        //  stream.
        //

        CdLookupAllocation( IrpContext,
                            Fcb,
                            CurrentCookedOffset,
                            &DiskOffset,
                            &CurrentCookedByteCount );
        //
        //  Maybe we got lucky and this is the same sector as in the
        //  Vcb.
        //

        if (DiskOffset == Fcb->Vcb->XADiskOffset) {

            //
            //  We will perform safe synchronization.  Check again that
            //  this is the correct sector.
            //

            CdLockVcb( IrpContext, Fcb->Vcb );

            if ((DiskOffset == Fcb->Vcb->XADiskOffset) &&
                (Fcb->Vcb->XASector != NULL)) {

                //
                //  Copy any bytes we can from the current sector.
                //

                CurrentRawByteCount = RAW_SECTOR_SIZE - RawSectorOffset;

                //
                //  Check whether we don't go to the end of the sector.
                //

                if (CurrentRawByteCount > RemainingRawByteCount) {

                    CurrentRawByteCount = RemainingRawByteCount;
                }

                RtlCopyMemory( CurrentUserBuffer,
                               Add2Ptr( Fcb->Vcb->XASector, RawSectorOffset, PCHAR ),
                               CurrentRawByteCount );

                CdUnlockVcb( IrpContext, Fcb->Vcb );

                //
                //  Adjust the run count and pointer in the IoRuns array
                //  to show that we didn't use a position.
                //

                *RunCount -= 1;
                ThisIoRun -= 1;

                //
                //  Remember that we performed a copy operation and update
                //  the next available position in the scratch buffer.
                //

                PerformedCopy = TRUE;

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             CurrentRawByteCount,
                                             PVOID );

                ScratchUserBufferOffset += CurrentRawByteCount;

                CurrentCookedByteCount = SECTOR_SIZE;

                //
                //  Set the flag indicating we want to round the scratch buffer
                //  to a sector boundary.
                //
                
                RoundScratchBuffer = TRUE;

            } else {

                //
                //  The safe test showed no available buffer.  Drop down to common code to
                //  perform the Io.
                //

                CdUnlockVcb( IrpContext, Fcb->Vcb );
            }
        }

        //
        //  No work in this pass if we did a copy operation.
        //

        if (!PerformedCopy) {

            //
            //  Limit ourselves by the number of remaining cooked bytes.
            //

            if (CurrentCookedByteCount > RemainingCookedByteCount) {

                CurrentCookedByteCount = RemainingCookedByteCount;
            }

            ThisIoRun->DiskOffset = DiskOffset;
            ThisIoRun->TransferBufferOffset = RawSectorOffset;

            //
            //  We will always need to perform copy operations for XA files.
            //  We allocate an auxillary buffer to read the start of the
            //  transfer.  Then we can use a range of the user's buffer to
            //  perform the next range of the transfer.  Finally we may
            //  need to allocate a buffer for the tail of the transfer.
            //
            //  We can use the user's buffer (at the current scratch buffer) if the
            //  following are true:
            //
            //      If we are to store the beginning of the raw sector in the user's buffer.
            //      The current scratch buffer precedes the destination in the user's buffer 
            //          (and hence also lies within it)
            //      There are enough bytes remaining in the buffer for at least one
            //          raw sector.
            //

            if ((RawSectorOffset == 0) &&
                (ScratchUserBufferOffset <= CurrentUserBufferOffset) &&
                (CurrentUserBufferOffset - ScratchUserBufferOffset + RemainingRawByteCount >= RAW_SECTOR_SIZE)) {

                //
                //  We can use the scratch buffer.  We must ensure we don't send down reads
                //  greater than the device can handle, since the driver is unable to split
                //  raw requests.
                //

                if (CurrentCookedByteCount <= Fcb->Vcb->MaximumTransferRawSectors * SECTOR_SIZE) {

                    CurrentRawByteCount = (SectorAlign( CurrentCookedByteCount) >> SECTOR_SHIFT) * RAW_SECTOR_SIZE;
    
                } else {

                    CurrentCookedByteCount = Fcb->Vcb->MaximumTransferRawSectors * SECTOR_SIZE;
                    CurrentRawByteCount = Fcb->Vcb->MaximumTransferRawSectors * RAW_SECTOR_SIZE;
                }

                //
                //  Now make sure we are within the page transfer limit.
                //

                while (ADDRESS_AND_SIZE_TO_SPAN_PAGES(ScratchUserBuffer, RawSectorAlign( CurrentRawByteCount)) > 
                       Fcb->Vcb->MaximumPhysicalPages )  {

                    CurrentRawByteCount -= RAW_SECTOR_SIZE;
                    CurrentCookedByteCount -= SECTOR_SIZE;
                }

                //
                //  Trim the number of bytes to read if it won't fit into the current buffer. Take
                //  account of the fact that we must read in whole raw sector multiples.
                //

                while ( RawSectorAlign( CurrentRawByteCount) > 
                        (CurrentUserBufferOffset - ScratchUserBufferOffset + RemainingRawByteCount) )  {

                    CurrentRawByteCount -= RAW_SECTOR_SIZE;
                    CurrentCookedByteCount -= SECTOR_SIZE;
                }

                //
                //  Now trim the maximum number of raw bytes to the remaining bytes.
                //

                if (CurrentRawByteCount > RemainingRawByteCount) {

                    CurrentRawByteCount = RemainingRawByteCount;
                }
                
                //
                //  Update the IO run array.  We point to the scratch buffer as
                //  well as the buffer and Mdl in the original Irp.
                //

                ThisIoRun->DiskByteCount = SectorAlign( CurrentCookedByteCount);

                //
                //  Store the number of bytes which we actually care about from this transfer
                //
                
                ThisIoRun->TransferByteCount = CurrentRawByteCount;

                //
                //  Point to the user's buffer and Mdl for this transfer.
                //

                ThisIoRun->TransferBuffer = ScratchUserBuffer;
                ThisIoRun->TransferMdl = Irp->MdlAddress;
                ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer, 
                                                             ScratchUserBufferOffset,
                                                             PVOID);
                //
                //  Update the scratch buffer pointer.  Note that since the underlying
                //  driver stack will always transfer in multiples of raw sectors,
                //  we must round up here rather than simply advancing by the length of the
                //  of the data which we actually care about.
                //

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             RawSectorAlign( CurrentRawByteCount),
                                             PVOID );
                                             
                ScratchUserBufferOffset += RawSectorAlign( CurrentRawByteCount);;

                //
                //  Set the flag indicating we want to round the scratch buffer
                //  to a cooked sector boundary.
                //

                RoundScratchBuffer = TRUE;

            } else {

                //
                //  We need to determine the number of bytes to transfer and the
                //  offset into this page to begin the transfer.
                //
                //  We will transfer only one raw sector.
                //

                ThisIoRun->DiskByteCount = SECTOR_SIZE;

                CurrentCookedByteCount = SECTOR_SIZE;

                ThisIoRun->TransferByteCount = RAW_SECTOR_SIZE - RawSectorOffset;
                ThisIoRun->TransferBufferOffset = RawSectorOffset;

                if (ThisIoRun->TransferByteCount > RemainingRawByteCount) {

                    ThisIoRun->TransferByteCount = RemainingRawByteCount;
                }

                CurrentRawByteCount = ThisIoRun->TransferByteCount;

                //
                //  We need to allocate an auxillary buffer.  We will allocate
                //  a single page.  Then we will build an Mdl to describe the buffer.
                //

                ThisIoRun->TransferBuffer = FsRtlAllocatePoolWithTag( CdNonPagedPool, PAGE_SIZE, TAG_IO_BUFFER );

                //
                //  Allocate and build the Mdl to describe this buffer.
                //

                ThisIoRun->TransferMdl = IoAllocateMdl( ThisIoRun->TransferBuffer,
                                                        PAGE_SIZE,
                                                        FALSE,
                                                        FALSE,
                                                        NULL );

                ThisIoRun->TransferVirtualAddress = ThisIoRun->TransferBuffer;

                if (ThisIoRun->TransferMdl == NULL) {

                    IrpContext->Irp->IoStatus.Information = 0;
                    CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
                }

                MmBuildMdlForNonPagedPool( ThisIoRun->TransferMdl );
            }
        }

        //
        //  Update the byte count for our caller.
        //

        RemainingRawByteCount -= CurrentRawByteCount;
        *ThisByteCount += CurrentRawByteCount;

        //
        //  Break out if no more positions in the IoRuns array or
        //  we have all of the bytes accounted for.
        //

        if ((RemainingRawByteCount == 0) || (*RunCount == MAX_PARALLEL_IOS)) {

            break;
        }

        //
        //  Update our local pointers to allow for the current range of bytes.
        //

        ThisIoRun += 1;

        CurrentUserBuffer = Add2Ptr( CurrentUserBuffer, CurrentRawByteCount, PVOID );
        CurrentUserBufferOffset += CurrentRawByteCount;

        RawSectorOffset = 0;

        CurrentCookedOffset += CurrentCookedByteCount;
        RemainingCookedByteCount -= CurrentCookedByteCount;
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
CdFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_RUN IoRuns,
    IN ULONG RunCount,
    IN BOOLEAN FinalCleanup,
    IN BOOLEAN SaveXABuffer
    )

/*++

Routine Description:

    This routine is called to perform any data transferred required for
    unaligned Io or to perform the final cleanup of the IoRuns array.

    In all cases this is where we will deallocate any buffer and mdl
    allocated to perform the unaligned transfer.  If this is not the
    final cleanup then we also transfer the bytes to the user buffer
    and flush the hardware cache.

    We walk backwards through the run array because we may be shifting data
    in the user's buffer.  Typical case is where we allocated a buffer for
    the first part of a read and then used the user's buffer for the
    next section (but stored it at the beginning of the buffer.

Arguments:

    IoRuns - Pointer to the IoRuns array.

    RunCount - Number of entries in the IoRuns array filled here.

    FinalCleanup - Indicates if we should be deallocating temporary buffers
        (TRUE) or transferring bytes for a unaligned transfers and
        deallocating the buffers (FALSE).  Flush the system cache if
        transferring data.

    SaveXABuffer - TRUE if we should try to save an XA buffer, FALSE otherwise

Return Value:

    BOOLEAN - TRUE if this request needs the Io buffers to be flushed, FALSE otherwise.

--*/

{
    BOOLEAN FlushIoBuffers = FALSE;

    ULONG RemainingEntries = RunCount;
    PIO_RUN ThisIoRun = &IoRuns[RunCount - 1];
    PVCB Vcb;

    PAGED_CODE();

    //
    //  Walk through each entry in the IoRun array.
    //

    while (RemainingEntries != 0) {

        //
        //  We only need to deal with the case of an unaligned transfer.
        //

        if (ThisIoRun->TransferByteCount != 0) {

            //
            //  If not the final cleanup then transfer the data to the
            //  user's buffer and remember that we will need to flush
            //  the user's buffer to memory.
            //

            if (!FinalCleanup) {

                //
                //  If we are shifting in the user's buffer then use
                //  MoveMemory.
                //

                if (ThisIoRun->TransferMdl == IrpContext->Irp->MdlAddress) {

                    RtlMoveMemory( ThisIoRun->UserBuffer,
                                   Add2Ptr( ThisIoRun->TransferBuffer,
                                            ThisIoRun->TransferBufferOffset,
                                            PVOID ),
                                   ThisIoRun->TransferByteCount );

                } else {

                    RtlCopyMemory( ThisIoRun->UserBuffer,
                                   Add2Ptr( ThisIoRun->TransferBuffer,
                                            ThisIoRun->TransferBufferOffset,
                                            PVOID ),
                                   ThisIoRun->TransferByteCount );
                }

                FlushIoBuffers = TRUE;
            }

            //
            //  Free any Mdl we may have allocated.  If the Mdl isn't
            //  present then we must have failed during the allocation
            //  phase.
            //

            if (ThisIoRun->TransferMdl != IrpContext->Irp->MdlAddress) {

                if (ThisIoRun->TransferMdl != NULL) {

                    IoFreeMdl( ThisIoRun->TransferMdl );
                }

                //
                //  Now free any buffer we may have allocated.  If the Mdl
                //  doesn't match the original Mdl then free the buffer.
                //

                if (ThisIoRun->TransferBuffer != NULL) {

                    //
                    //  If this is the final buffer for an XA read then store this buffer
                    //  into the Vcb so that we will have it when reading any remaining
                    //  portion of this buffer.
                    //

                    if (SaveXABuffer) {

                        Vcb = IrpContext->Vcb;

                        CdLockVcb( IrpContext, Vcb );

                        if (Vcb->XASector != NULL) {

                            ExFreePool( Vcb->XASector );
                        }

                        Vcb->XASector = ThisIoRun->TransferBuffer;
                        Vcb->XADiskOffset = ThisIoRun->DiskOffset;

                        SaveXABuffer = FALSE;

                        CdUnlockVcb( IrpContext, Vcb );

                    //
                    //  Otherwise just free the buffer.
                    //

                    } else {

                        ExFreePool( ThisIoRun->TransferBuffer );
                    }
                }
            }
        }

        //
        //  Now handle the case where we failed in the process
        //  of allocating associated Irps and Mdls.
        //

        if (ThisIoRun->SavedIrp != NULL) {

            if (ThisIoRun->SavedIrp->MdlAddress != NULL) {

                IoFreeMdl( ThisIoRun->SavedIrp->MdlAddress );
            }

            IoFreeIrp( ThisIoRun->SavedIrp );
        }

        //
        //  Move to the previous IoRun entry.
        //

        ThisIoRun -= 1;
        RemainingEntries -= 1;
    }

    //
    //  If we copied any data then flush the Io buffers.
    //

    return FlushIoBuffers;
}


//
//  Local support routine
//

VOID
CdMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine should not
    be used if only one async request is needed, instead the single read
    async routines should be called.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    RunCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Offset and ByteCount for the
        separate requests.

Return Value:

    None.

--*/

{
    PIO_COMPLETION_ROUTINE CompletionRoutine;
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    PIRP Irp;
    PIRP MasterIrp;
    ULONG UnwindRunCount;

    PAGED_CODE();

    //
    //  Set up things according to whether this is truely async.
    //

    CompletionRoutine = CdMultiSyncCompletionRoutine;

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        CompletionRoutine = CdMultiAsyncCompletionRoutine;
    }

    //
    //  Initialize some local variables.
    //

    MasterIrp = IrpContext->Irp;

    //
    //  Itterate through the runs, doing everything that can fail.
    //  We let the cleanup in CdFinishBuffers clean up on error.
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount += 1) {

        //
        //  Create an associated IRP, making sure there is one stack entry for
        //  us, as well.
        //

        IoRuns[UnwindRunCount].SavedIrp =
        Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(IrpContext->Vcb->TargetDeviceObject->StackSize + 1) );

        if (Irp == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        // Allocate and build a partial Mdl for the request.
        //

        Mdl = IoAllocateMdl( IoRuns[UnwindRunCount].TransferVirtualAddress,
                             IoRuns[UnwindRunCount].DiskByteCount,
                             FALSE,
                             FALSE,
                             Irp );

        if (Mdl == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        IoBuildPartialMdl( IoRuns[UnwindRunCount].TransferMdl,
                           Mdl,
                           IoRuns[UnwindRunCount].TransferVirtualAddress,
                           IoRuns[UnwindRunCount].DiskByteCount );

        //
        //  Get the first IRP stack location in the associated Irp
        //

        IoSetNextIrpStackLocation( Irp );
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Setup the Stack location to describe our read.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;

        //
        // Set up the completion routine address in our stack frame.
        //

        IoSetCompletionRoutine( Irp,
                                CompletionRoutine,
                                IrpContext->IoContext,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location in the associated Irp for the disk
        //  driver beneath us.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Setup the Stack location to do a read from the disk driver.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;
    }

    //
    //  We only need to set the associated IRP count in the master irp to
    //  make it a master IRP.  But we set the count to one more than our
    //  caller requested, because we do not want the I/O system to complete
    //  the I/O.  We also set our own count.
    //

    IrpContext->IoContext->IrpCount = RunCount;
    IrpContext->IoContext->MasterIrp = MasterIrp;

    //
    //  We set the count in the master Irp to 1 since typically we
    //  will clean up the associated irps ourselves.  Setting this to one
    //  means completing the last associated Irp with SUCCESS (in the async
    //  case) will complete the master irp.
    //

    MasterIrp->AssociatedIrp.IrpCount = 1;

    //
    //  Now that all the dangerous work is done, issue the Io requests
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount++) {

        Irp = IoRuns[UnwindRunCount].SavedIrp;
        IoRuns[UnwindRunCount].SavedIrp = NULL;

        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be caught by our completion routines
        //  and dealt with as a normal IO error.
        //

        (VOID) IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );
    }

    return;
}


//
//  Local support routine
//

VOID
CdMultipleXAAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns,
    IN PRAW_READ_INFO RawReads,
    IN TRACK_MODE_TYPE TrackMode
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine is used to generate
    the associated Irps used to read raw sectors from the disk.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    RunCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Offset and ByteCount for the
        separate requests.

    RawReads - Supplies an array of structures to store in the Irps passed to the
        device driver to perform the low-level Io.

    TrackMode - Supplies the recording mode of sectors in these IoRuns

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    PIRP Irp;
    PIRP MasterIrp;
    ULONG UnwindRunCount;
    ULONG RawByteCount;

    PIO_RUN ThisIoRun = IoRuns;
    PRAW_READ_INFO ThisRawRead = RawReads;

    PAGED_CODE();

    //
    //  Initialize some local variables.
    //

    MasterIrp = IrpContext->Irp;

    //
    //  Itterate through the runs, doing everything that can fail.
    //  We let the cleanup in CdFinishBuffers clean up on error.
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount += 1, ThisIoRun += 1, ThisRawRead += 1) {

        //
        //  Create an associated IRP, making sure there is one stack entry for
        //  us, as well.
        //

        ThisIoRun->SavedIrp =
        Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(IrpContext->Vcb->TargetDeviceObject->StackSize + 1) );

        if (Irp == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }
        
        //
        //  Should have been passed a byte count of at least one sector, and 
        //  must be a multiple of sector size
        //
        
        ASSERT( ThisIoRun->DiskByteCount && !SectorOffset(ThisIoRun->DiskByteCount));

        RawByteCount = SectorsFromBytes( ThisIoRun->DiskByteCount) * RAW_SECTOR_SIZE;

        //
        // Allocate and build a partial Mdl for the request.
        //

        Mdl = IoAllocateMdl( ThisIoRun->TransferVirtualAddress,
                             RawByteCount,
                             FALSE,
                             FALSE,
                             Irp );

        if (Mdl == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        IoBuildPartialMdl( ThisIoRun->TransferMdl,
                           Mdl,
                           ThisIoRun->TransferVirtualAddress,
                           RawByteCount);
        //
        //  Get the first IRP stack location in the associated Irp
        //

        IoSetNextIrpStackLocation( Irp );
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Setup the Stack location to describe our read (using cooked values)
        //  These values won't be used for the raw read in any case.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = ThisIoRun->DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisIoRun->DiskOffset;

        //
        // Set up the completion routine address in our stack frame.
        //

        IoSetCompletionRoutine( Irp,
                                CdMultiSyncCompletionRoutine,
                                IrpContext->IoContext,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location in the associated Irp for the disk
        //  driver beneath us.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Setup the stack location to do a read of raw sectors at this location.
        //  Note that the storage stack always reads multiples of whole XA sectors.
        //

        ThisRawRead->DiskOffset.QuadPart = ThisIoRun->DiskOffset;
        ThisRawRead->SectorCount = ThisIoRun->DiskByteCount >> SECTOR_SHIFT;
        ThisRawRead->TrackMode = TrackMode;

        IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

        IrpSp->Parameters.DeviceIoControl.OutputBufferLength = ThisRawRead->SectorCount * RAW_SECTOR_SIZE;
        Irp->UserBuffer = ThisIoRun->TransferVirtualAddress;

        IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof( RAW_READ_INFO );
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = ThisRawRead;

        IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_CDROM_RAW_READ;
    }

    //
    //  We only need to set the associated IRP count in the master irp to
    //  make it a master IRP.  But we set the count to one more than our
    //  caller requested, because we do not want the I/O system to complete
    //  the I/O.  We also set our own count.
    //

    IrpContext->IoContext->IrpCount = RunCount;
    IrpContext->IoContext->MasterIrp = MasterIrp;

    //
    //  We set the count in the master Irp to 1 since typically we
    //  will clean up the associated irps ourselves.  Setting this to one
    //  means completing the last associated Irp with SUCCESS (in the async
    //  case) will complete the master irp.
    //

    MasterIrp->AssociatedIrp.IrpCount = 1;

    //
    //  Now that all the dangerous work is done, issue the Io requests
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount++) {

        Irp = IoRuns[UnwindRunCount].SavedIrp;
        IoRuns[UnwindRunCount].SavedIrp = NULL;

        //
        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be caught by our completion routines
        //  and dealt with as a normal IO error.
        //

        (VOID) IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );
    }

    return;
}


//
//  Local support routine
//

VOID
CdSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine reads one or more contiguous sectors from a device
    asynchronously, and is used if there is only one read necessary to
    complete the IRP.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    ByteOffset - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIO_COMPLETION_ROUTINE CompletionRoutine;

    PAGED_CODE();

    //
    //  Set up things according to whether this is truely async.
    //

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        CompletionRoutine = CdSingleSyncCompletionRoutine;

    } else {

        CompletionRoutine = CdSingleAsyncCompletionRoutine;
    }

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( IrpContext->Irp,
                            CompletionRoutine,
                            IrpContext->IoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( IrpContext->Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = IRP_MJ_READ;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = ByteOffset;

    //
    //  Issue the Io request
    //

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    (VOID)IoCallDriver( IrpContext->Vcb->TargetDeviceObject, IrpContext->Irp );

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

VOID
CdWaitSync (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine waits for one or more previously started I/O requests
    from the above routines, by simply waiting on the event.

Arguments:

Return Value:

    None

--*/

{
    PAGED_CODE();

    KeWaitForSingleObject( &IrpContext->IoContext->SyncEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    KeClearEvent( &IrpContext->IoContext->SyncEvent );

    return;
}


//
//  Local support routine
//

NTSTATUS
CdMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all synchronous reads
    started via CdMultipleAsynch.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
        Irp will no longer be accessible after this routine returns.)

    Context - The context parameter which was specified for all of
        the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    PCD_IO_CONTEXT IoContext = Context;

    AssertVerifyDeviceIrp( Irp );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        InterlockedExchange( &IoContext->Status, Irp->IoStatus.Status );
        IoContext->MasterIrp->IoStatus.Information = 0;
    }

    //
    //  We must do this here since IoCompleteRequest won't get a chance
    //  on this associated Irp.
    //

    IoFreeMdl( Irp->MdlAddress );
    IoFreeIrp( Irp );

    if (InterlockedDecrement( &IoContext->IrpCount ) == 0) {

        //
        //  Update the Master Irp with any error status from the associated Irps.
        //

        IoContext->MasterIrp->IoStatus.Status = IoContext->Status;
        KeSetEvent( &IoContext->SyncEvent, 0, FALSE );
    }

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//
//  Local support routine
//

NTSTATUS
CdMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads
    started via CdMultipleAsynch.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        and remember the error status in the Context.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
        Irp will no longer be accessible after this routine returns.)

    Context - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PCD_IO_CONTEXT IoContext = Context;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    AssertVerifyDeviceIrp( Irp );
    
    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        InterlockedExchange( &IoContext->Status, Irp->IoStatus.Status );
    }

    //
    //  Decrement IrpCount and see if it goes to zero.
    //

    if (InterlockedDecrement( &IoContext->IrpCount ) == 0) {

        //
        //  Mark the master Irp pending
        //

        IoMarkIrpPending( IoContext->MasterIrp );

        //
        //  Update the Master Irp with any error status from the associated Irps.
        //

        IoContext->MasterIrp->IoStatus.Status = IoContext->Status;

        //
        //  Update the information field with the correct value.
        //

        IoContext->MasterIrp->IoStatus.Information = 0;

        if (NT_SUCCESS( IoContext->MasterIrp->IoStatus.Status )) {

            IoContext->MasterIrp->IoStatus.Information = IoContext->RequestedByteCount;
        }

        //
        //  Now release the resource
        //

        ExReleaseResourceForThreadLite( IoContext->Resource,
                                    IoContext->ResourceThreadId );

        //
        //  and finally, free the context record.
        //

        CdFreeIoContext( IoContext );

        //
        //  Return success in this case.
        //

        return STATUS_SUCCESS;

    } else {

        //
        //  We need to cleanup the associated Irp and its Mdl.
        //

        IoFreeMdl( Irp->MdlAddress );
        IoFreeIrp( Irp );

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

NTSTATUS
CdSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all reads started via CdSingleAsynch.

    The completion routine has has the following responsibilities:

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Context - The context parameter which was specified in the call to
        CdSingleAsynch.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    AssertVerifyDeviceIrp( Irp );
    
    //
    //  Store the correct information field into the Irp.
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        Irp->IoStatus.Information = 0;
    }

    KeSetEvent( &((PCD_IO_CONTEXT)Context)->SyncEvent, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//
//  Local support routine
//

NTSTATUS
CdSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads
    started via CdSingleAsynch.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Context - The context parameter which was specified in the call to
        CdSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    AssertVerifyDeviceIrp( Irp );
    
    //
    //  Update the information field with the correct value for bytes read.
    //

    Irp->IoStatus.Information = 0;

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        Irp->IoStatus.Information = ((PCD_IO_CONTEXT) Context)->RequestedByteCount;
    }

    //
    //  Mark the Irp pending
    //

    IoMarkIrpPending( Irp );

    //
    //  Now release the resource
    //

    ExReleaseResourceForThreadLite( ((PCD_IO_CONTEXT) Context)->Resource,
                                ((PCD_IO_CONTEXT) Context)->ResourceThreadId );

    //
    //  and finally, free the context record.
    //

    CdFreeIoContext( (PCD_IO_CONTEXT) Context );
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

VOID
CdReadAudioSystemFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PVOID SystemBuffer
    )

/*++

Routine Description:

    This routine is called to read the pseudo root directory and path
    table for a music disk.  We build the individual elements on the
    stack and copy into the cache buffer.

Arguments:

    Fcb - Fcb representing the file to read.

    StartingOffset - Logical offset in the file to read from.

    ByteCount - Number of bytes to read.

    SystemBuffer - Pointer to buffer to fill in.  This will always be page
        aligned.

Return Value:

    None.

--*/

{
    PRAW_PATH_ISO RawPath;
    PRAW_DIRENT RawDirent;

    ULONG CurrentTrack;
    ULONG SectorOffset;
    ULONG EntryCount;
    UCHAR TrackOnes;
    UCHAR TrackTens;
    PTRACK_DATA ThisTrack;

    LONGLONG CurrentOffset;

    PVOID CurrentSector;

    PSYSTEM_USE_XA SystemUse;

    ULONG BytesToCopy;

    UCHAR LocalBuffer[FIELD_OFFSET( RAW_DIRENT, FileId ) + 12];

    PAGED_CODE();

    //
    //  If this is the path table then we just need a single entry.
    //

    if (SafeNodeType( Fcb ) == CDFS_NTC_FCB_PATH_TABLE) {

        //
        //  Sanity check that the offset is zero.
        //

        ASSERT( StartingOffset == 0 );

        //
        //  Store a pseudo path entry in our local buffer.
        //

        RawPath = (PRAW_PATH_ISO) LocalBuffer;

        RtlZeroMemory( RawPath, sizeof( LocalBuffer ));

        RawPath->DirIdLen = 1;
        RawPath->ParentNum = 1;
        RawPath->DirId[0] = '\0';

        //
        //  Now copy to the user's buffer.
        //

        BytesToCopy = FIELD_OFFSET( RAW_PATH_ISO, DirId ) + 2;

        if (BytesToCopy > ByteCount) {

            BytesToCopy = ByteCount;
        }

        RtlCopyMemory( SystemBuffer,
                       RawPath,
                       BytesToCopy );

    //
    //  We need to deal with the multiple sector case for the root directory.
    //

    } else {

        //
        //  Initialize the first track to return to our caller.
        //

        CurrentTrack = 0;

        //
        //  If the offset is zero then store the entries for the self and parent
        //  entries.
        //

        if (StartingOffset == 0) {

            RawDirent = SystemBuffer;

            //
            //  Clear all of the fields initially.
            //

            RtlZeroMemory( RawDirent, FIELD_OFFSET( RAW_DIRENT, FileId ));

            //
            //  Now fill in the interesting fields.
            //

            RawDirent->DirLen = FIELD_OFFSET( RAW_DIRENT, FileId ) + 1;
            RawDirent->FileIdLen = 1;
            RawDirent->FileId[0] = '\0';
            SetFlag( RawDirent->FlagsISO, CD_ATTRIBUTE_DIRECTORY );

            //
            //  Set the time stamp to be Jan 1, 1995
            //

            RawDirent->RecordTime[0] = 95;
            RawDirent->RecordTime[1] = 1;
            RawDirent->RecordTime[2] = 1;

            SectorOffset = RawDirent->DirLen;

            RawDirent = Add2Ptr( RawDirent, SectorOffset, PRAW_DIRENT );

            //
            //  Clear all of the fields initially.
            //

            RtlZeroMemory( RawDirent, FIELD_OFFSET( RAW_DIRENT, FileId ));

            //
            //  Now fill in the interesting fields.
            //

            RawDirent->DirLen = FIELD_OFFSET( RAW_DIRENT, FileId ) + 1;
            RawDirent->FileIdLen = 1;
            RawDirent->FileId[0] = '\1';
            SetFlag( RawDirent->FlagsISO, CD_ATTRIBUTE_DIRECTORY );

            //
            //  Set the time stamp to be Jan 1, 1995
            //

            RawDirent->RecordTime[0] = 95;
            RawDirent->RecordTime[1] = 1;
            RawDirent->RecordTime[2] = 1;

            SectorOffset += RawDirent->DirLen;
            EntryCount = 2;

        //
        //  Otherwise compute the starting track to write to the buffer.
        //

        } else {

            //
            //  Count the tracks in each preceding sector.
            //

            CurrentOffset = 0;

            do {

                CurrentTrack += CdAudioDirentsPerSector;
                CurrentOffset += SECTOR_SIZE;

            } while (CurrentOffset < StartingOffset);

            //
            //  Bias the track count to reflect the two default entries.
            //

            CurrentTrack -= 2;

            SectorOffset = 0;
            EntryCount = 0;
        }

        //
        //  We now know the first track to return as well as where we are in
        //  the current sector.  We will walk through sector by sector adding
        //  the entries for the separate tracks in the TOC.  We will zero
        //  any sectors or partial sectors without data.
        //

        CurrentSector = SystemBuffer;
        BytesToCopy = SECTOR_SIZE;

        //
        //  Loop for each sector.
        //

        do {

            //
            //  Add entries until we reach our threshold for each sector.
            //

            do {

                //
                //  If we are beyond the entries in the TOC then exit.
                //

                if (CurrentTrack >= IrpContext->Vcb->TrackCount) {

                    break;
                }

                ThisTrack = &IrpContext->Vcb->CdromToc->TrackData[CurrentTrack];

                //
                //  Point to the current position in the buffer.
                //

                RawDirent = Add2Ptr( CurrentSector, SectorOffset, PRAW_DIRENT );

                //
                //  Clear all of the fields initially.
                //

                RtlZeroMemory( RawDirent, CdAudioDirentSize );

                //
                //  Now fill in the interesting fields.
                //

                RawDirent->DirLen = (UCHAR) CdAudioDirentSize;
                RawDirent->FileIdLen = CdAudioFileNameLength;

                RtlCopyMemory( RawDirent->FileId,
                               CdAudioFileName,
                               CdAudioFileNameLength );

                //
                //  Set the time stamp to be Jan 1, 1995
                //

                RawDirent->RecordTime[0] = 95;
                RawDirent->RecordTime[1] = 1;
                RawDirent->RecordTime[2] = 1;

                //
                //  Now bias by the values in the TOC.
                //

                RawDirent->RecordTime[4] = ThisTrack->Address[1] % 60;
                RawDirent->RecordTime[5] = ThisTrack->Address[2] % 60;

                //
                //  Put the track number into the file name.
                //

                TrackTens = TrackOnes = ThisTrack->TrackNumber;

                TrackOnes = (TrackOnes % 10) + '0';

                TrackTens /= 10;
                TrackTens = (TrackTens % 10) + '0';

                RawDirent->FileId[AUDIO_NAME_TENS_OFFSET] = TrackTens;
                RawDirent->FileId[AUDIO_NAME_ONES_OFFSET] = TrackOnes;

                SystemUse = Add2Ptr( RawDirent, CdAudioSystemUseOffset, PSYSTEM_USE_XA );

                SystemUse->Attributes = SYSTEM_USE_XA_DA;
                SystemUse->Signature = SYSTEM_XA_SIGNATURE;

                //
                //  Store the track number as the file number.
                //

                SystemUse->FileNumber = (UCHAR) CurrentTrack;

                EntryCount += 1;
                SectorOffset += CdAudioDirentSize;
                CurrentTrack += 1;

            } while (EntryCount < CdAudioDirentsPerSector);

            //
            //  Zero the remaining portion of this buffer.
            //

            RtlZeroMemory( Add2Ptr( CurrentSector, SectorOffset, PVOID ),
                           SECTOR_SIZE - SectorOffset );

            //
            //  Prepare for the next sector.
            //

            EntryCount = 0;
            BytesToCopy += SECTOR_SIZE;
            SectorOffset = 0;
            CurrentSector = Add2Ptr( CurrentSector, SECTOR_SIZE, PVOID );

        } while (BytesToCopy <= ByteCount);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\dirsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DirSup.c

Abstract:

    This module implements the dirent support routines for Cdfs.

    Directories on a CD consist of a number of contiguous sectors on
    the disk.  File descriptors consist of one or more directory entries
    (dirents) within a directory.  Files may contain version numbers.  If
    present all like-named files will be ordered contiguously in the
    directory by decreasing version numbers.  We will only return the
    first of these on a directory query unless the user explicitly
    asks for version numbers.  Finally dirents will not span sector
    boundaries.  Unused bytes at the end of a sector will be zero
    filled.

    Directory sector:                                                   Offset
                                                                        2048
        +---------------------------------------------------------------+
        |            |          |          |           |          |     |
        | foo;4      | foo;4    | foo;3    |  hat      |  zebra   | Zero|
        |            |          |          |           |          | Fill|
        |            |  final   |  single  |           |          |     |
        |            |  extent  |   extent |           |          |     |
        +---------------------------------------------------------------+

    Dirent operations:

        - Position scan at known offset in directory.  Dirent at this
            offset must exist and is valid.  Used when scanning a directory
            from the beginning when the self entry is known to be valid.
            Used when positioning at the first dirent for an open
            file to scan the allocation information.  Used when resuming
            a directory enumeration from a valid directory entry.

        - Position scan at known offset in directory.  Dirent is known to
            start at this position but must be checked for validity.
            Used to read the self-directory entry.

        - Move to the next dirent within a directory.

        - Given a known starting dirent, collect all the dirents for
            that file.  Scan will finish positioned at the last dirent
            for the file.  We will accumulate the extent lengths to
            find the size of the file.

        - Given a known starting dirent, position the scan for the first
            dirent of the following file.  Used when not interested in
            all of the details for the current file and are looking for
            the next file.

        - Update a common dirent structure with the details of the on-disk
            structure.  This is used to smooth out the differences

        - Build the filename (name and version strings) out of the stream
            of bytes in the file name on disk.  For Joliet disks we will have
            to convert to little endian.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_DIRSUP)

//
//  Local macros
//

//
//  PRAW_DIRENT
//  CdRawDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIR_ENUM_CONTEXT DirContext
//      );
//

#define CdRawDirent(IC,DC)                                      \
    Add2Ptr( (DC)->Sector, (DC)->SectorOffset, PRAW_DIRENT )

//
//  Local support routines
//

ULONG
CdCheckRawDirentBounds (
    IN PIRP_CONTEXT IrpContext,
    IN PDIRENT_ENUM_CONTEXT DirContext
    );

XA_EXTENT_TYPE
CdCheckForXAExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PRAW_DIRENT RawDirent,
    IN OUT PDIRENT Dirent
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCheckForXAExtent)
#pragma alloc_text(PAGE, CdCheckRawDirentBounds)
#pragma alloc_text(PAGE, CdCleanupFileContext)
#pragma alloc_text(PAGE, CdFindFile)
#pragma alloc_text(PAGE, CdFindDirectory)
#pragma alloc_text(PAGE, CdFindFileByShortName)
#pragma alloc_text(PAGE, CdLookupDirent)
#pragma alloc_text(PAGE, CdLookupLastFileDirent)
#pragma alloc_text(PAGE, CdLookupNextDirent)
#pragma alloc_text(PAGE, CdLookupNextInitialFileDirent)
#pragma alloc_text(PAGE, CdUpdateDirentFromRawDirent)
#pragma alloc_text(PAGE, CdUpdateDirentName)
#endif


VOID
CdLookupDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG DirentOffset,
    OUT PDIRENT_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine is called to initiate a walk through a directory.  We will
    position ourselves in the directory at offset DirentOffset.  We know that
    a dirent begins at this boundary but may have to verify the dirent bounds.
    We will call this routine when looking up the first entry of a known
    file or verifying the self entry of a directory.

Arguments:

    Fcb - Fcb for the directory being traversed.

    DirentOffset - This is our target point in the directory.  We will map the
        page containing this entry and possibly verify the dirent bounds at
        this location.

    DirContext - This is the dirent context for this scan.  We update it with
        the location of the dirent we found.  This structure has been initialized
        outside of this call.

Return Value:

    None.

--*/

{
    LONGLONG BaseOffset;

    PAGED_CODE();

    //
    //  Initialize the offset of the first dirent we want to map.
    //

    DirContext->BaseOffset = SectorTruncate( DirentOffset );
    BaseOffset = DirContext->BaseOffset;

    DirContext->DataLength = SECTOR_SIZE;

    DirContext->SectorOffset = SectorOffset( DirentOffset );

    //
    //  Truncate the data length if we are at the end of the file.
    //

    if (DirContext->DataLength > (Fcb->FileSize.QuadPart - BaseOffset)) {

        DirContext->DataLength = (ULONG) (Fcb->FileSize.QuadPart - BaseOffset);
    }

    //
    //  Now map the data at this offset.
    //

    CcMapData( Fcb->FileObject,
               (PLARGE_INTEGER) &BaseOffset,
               DirContext->DataLength,
               TRUE,
               &DirContext->Bcb,
               &DirContext->Sector );

    //
    //  Verify the dirent bounds.
    //

    DirContext->NextDirentOffset = CdCheckRawDirentBounds( IrpContext,
                                                           DirContext );

    return;
}


BOOLEAN
CdLookupNextDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIRENT_ENUM_CONTEXT CurrentDirContext,
    OUT PDIRENT_ENUM_CONTEXT NextDirContext
    )

/*++

Routine Description:

    This routine is called to find the next dirent in the directory.  The
    current position is given and we look for the next.  We leave the context
    for the starting position untouched and update the context for the
    dirent we found.  The target context may already be initialized so we
    may already have the sector in memory.

    This routine will position the enumeration context for the next dirent and
    verify the dirent bounds.

    NOTE - This routine can be called with CurrentDirContext and NextDirContext
        pointing to the same enumeration context.

Arguments:

    Fcb - Fcb for the directory being traversed.

    CurrentDirContext - This is the dirent context for this scan.  We update
        it with the location of the dirent we found.  This is currently
        pointing to a dirent location.  The dirent bounds at this location
        have already been verified.

    NextDirContext - This is the dirent context to update with the dirent we
        find.  This may already point to a dirent so we need to check if
        we are in the same sector and unmap any buffer as necessary.

        This dirent is left in an indeterminant state if we don't find a dirent.

Return Value:

    BOOLEAN - TRUE if we find a location for the next dirent, FALSE otherwise.
        This routine can cause a raise if the directory is corrupt.

--*/

{
    LONGLONG CurrentBaseOffset = CurrentDirContext->BaseOffset;
    ULONG TempUlong;

    BOOLEAN FoundDirent = FALSE;

    PAGED_CODE();

    //
    //  Check if a different sector is mapped.  If so then move our target
    //  enumeration context to the same sector.
    //

    if ((CurrentDirContext->BaseOffset != NextDirContext->BaseOffset) ||
        (NextDirContext->Bcb == NULL)) {

        //
        //  Unpin the current target Bcb and map the next sector.
        //

        CdUnpinData( IrpContext, &NextDirContext->Bcb );

        CcMapData( Fcb->FileObject,
                   (PLARGE_INTEGER) &CurrentBaseOffset,
                   CurrentDirContext->DataLength,
                   TRUE,
                   &NextDirContext->Bcb,
                   &NextDirContext->Sector );

        //
        //  Copy the data length and sector offset.
        //

        NextDirContext->DataLength = CurrentDirContext->DataLength;
        NextDirContext->BaseOffset = CurrentDirContext->BaseOffset;
    }

    //
    //  Now move to the same offset in the sector.
    //

    NextDirContext->SectorOffset = CurrentDirContext->SectorOffset;

    //
    //  If the value is zero then unmap the current sector and set up
    //  the base offset to the beginning of the next sector.
    //

    if (CurrentDirContext->NextDirentOffset == 0) {

        CurrentBaseOffset = NextDirContext->BaseOffset + NextDirContext->DataLength;

        //
        //  Unmap the current sector.  We test the value of the Bcb in the
        //  loop below to see if we need to read in another sector.
        //

        CdUnpinData( IrpContext, &NextDirContext->Bcb );

    //
    //  There is another possible dirent in the current sector.  Update the
    //  enumeration context to reflect this.
    //

    } else {

        NextDirContext->SectorOffset += CurrentDirContext->NextDirentOffset;
    }

    //
    //  Now loop until we find the next possible dirent or walk off the directory.
    //

    while (TRUE) {

        //
        //  If we don't currently have a sector mapped then map the
        //  directory at the current offset.
        //

        if (NextDirContext->Bcb == NULL) {

            TempUlong = SECTOR_SIZE;

            if (TempUlong > (ULONG) (Fcb->FileSize.QuadPart - CurrentBaseOffset)) {

                TempUlong = (ULONG) (Fcb->FileSize.QuadPart - CurrentBaseOffset);

                //
                //  If the length is zero then there is no dirent.
                //

                if (TempUlong == 0) {

                    break;
                }
            }

            CcMapData( Fcb->FileObject,
                       (PLARGE_INTEGER) &CurrentBaseOffset,
                       TempUlong,
                       TRUE,
                       &NextDirContext->Bcb,
                       &NextDirContext->Sector );

            NextDirContext->BaseOffset = (ULONG) CurrentBaseOffset;
            NextDirContext->SectorOffset = 0;
            NextDirContext->DataLength = TempUlong;
        }

        //
        //  The CDFS spec allows for sectors in a directory to contain all zeroes.
        //  In this case we need to move to the next sector.  So look at the
        //  current potential dirent for a zero length.  Move to the next
        //  dirent if length is zero.
        //

        if (*((PCHAR) CdRawDirent( IrpContext, NextDirContext )) != 0) {

            FoundDirent = TRUE;
            break;
        }

        CurrentBaseOffset = NextDirContext->BaseOffset + NextDirContext->DataLength;
        CdUnpinData( IrpContext, &NextDirContext->Bcb );
    }

    //
    //  Check the dirent bounds if we found a dirent.
    //

    if (FoundDirent) {

        NextDirContext->NextDirentOffset = CdCheckRawDirentBounds( IrpContext,
                                                                   NextDirContext );
    }

    return FoundDirent;
}


VOID
CdUpdateDirentFromRawDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIRENT_ENUM_CONTEXT DirContext,
    IN OUT PDIRENT Dirent
    )

/*++

Routine Description:

    This routine is called to safely copy the data from the dirent on disk
    to the in-memory dirent.  The fields on disk are unaligned so we
    need to safely copy them to our structure.

Arguments:

    Fcb - Fcb for the directory being scanned.

    DirContext - Enumeration context for the raw disk dirent.

    Dirent - In-memory dirent to update.

Return Value:

    None.

--*/

{
    PRAW_DIRENT RawDirent = CdRawDirent( IrpContext, DirContext );

    PAGED_CODE();

    //
    //  Clear all of the current state flags except the flag indicating that
    //  we allocated a name string.
    //

    ClearFlag( Dirent->Flags, DIRENT_FLAG_NOT_PERSISTENT );

    //
    //  The dirent offset is the sum of the start of the sector and the
    //  sector offset.
    //

    Dirent->DirentOffset = DirContext->BaseOffset + DirContext->SectorOffset;

    //
    //  Copy the dirent length from the raw dirent.
    //

    Dirent->DirentLength = RawDirent->DirLen;

    //
    //  The starting offset on disk is computed by finding the starting
    //  logical block and stepping over the Xar block.
    //

    CopyUchar4( &Dirent->StartingOffset, RawDirent->FileLoc );

    Dirent->StartingOffset += RawDirent->XarLen;

    //
    //  Do a safe copy to get the data length.
    //

    CopyUchar4( &Dirent->DataLength, RawDirent->DataLen );

    //
    //  Save a pointer to the time stamps.
    //

    Dirent->CdTime = RawDirent->RecordTime;

    //
    //  Copy the dirent flags.
    //

    Dirent->DirentFlags = CdRawDirentFlags( IrpContext, RawDirent );

    //
    //  For both the file unit and interleave skip we want to take the
    //  logical block count.
    //

    Dirent->FileUnitSize =
    Dirent->InterleaveGapSize = 0;

    if (RawDirent->IntLeaveSize != 0) {

        Dirent->FileUnitSize = RawDirent->IntLeaveSize;
        Dirent->InterleaveGapSize = RawDirent->IntLeaveSkip;
    }

    //
    //  Get the name length and remember a pointer to the start of the
    //  name string.  We don't do any processing on the name at this
    //  point.
    //
    //  Check that the name length is non-zero.
    //

    if (RawDirent->FileIdLen == 0) {

        CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    Dirent->FileNameLen = RawDirent->FileIdLen;
    Dirent->FileName = RawDirent->FileId;

    //
    //  If there are any remaining bytes at the end of the dirent then
    //  there may be a system use area.  We protect ourselves from
    //  disks which don't pad the dirent entries correctly by using
    //  a fudge factor of one.  All system use areas must have a length
    //  greater than one.  Don't bother with the system use area
    //  if this is a directory.
    //

    Dirent->XAAttributes = 0;
    Dirent->XAFileNumber = 0;
    Dirent->ExtentType = Form1Data;
    Dirent->SystemUseOffset = 0;

    if (!FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY ) &&
        (Dirent->DirentLength > ((FIELD_OFFSET( RAW_DIRENT, FileId ) + Dirent->FileNameLen) + 1))) {

        Dirent->SystemUseOffset = WordAlign( FIELD_OFFSET( RAW_DIRENT, FileId ) + Dirent->FileNameLen );
    }

    return;
}


VOID
CdUpdateDirentName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDIRENT Dirent,
    IN ULONG IgnoreCase
    )

/*++

Routine Description:

    This routine is called to update the name in the dirent with the name
    from the disk.  We will look for the special case of the self and
    parent entries and also construct the Unicode name for the Joliet disk
    in order to work around the BigEndian on-disk structure.

Arguments:

    Dirent - Pointer to the in-memory dirent structure.

    IgnoreCase - TRUE if we should build the upcased version.  Otherwise we
        use the exact case name.

Return Value:

    None.

--*/

{
    UCHAR DirectoryValue;
    ULONG Length;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check if this is a self or parent entry.  There is no version number
    //  in these cases.  We use a fixed string for these.
    //
    //      Self-Entry - Length is 1, value is 0.
    //      Parent-Entry - Length is 1, value is 1.
    //

    if ((Dirent->FileNameLen == 1) &&
        FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY )) {

        DirectoryValue = *((PCHAR) Dirent->FileName);

        if ((DirectoryValue == 0) || (DirectoryValue == 1)) {

            //
            //  We should not have allocated a name by the time we see these cases.
            //  If we have, this means that the image is in violation of ISO 9660 7.6.2,
            //  which states that the ./.. entries must be the first two in the directory.
            //

            if (FlagOn( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER )) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            //
            //  Now use one of the hard coded directory names.
            //

            Dirent->CdFileName.FileName = CdUnicodeDirectoryNames[DirectoryValue];

            //
            //  Show that there is no version number.
            //

            Dirent->CdFileName.VersionString.Length = 0;

            //
            //  The case name is the same as the exact name.
            //

            Dirent->CdCaseFileName = Dirent->CdFileName;

            //
            //  Mark this as a constant value entry.
            //

            SetFlag( Dirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY );

            //
            //  Return now.
            //

            return;
        }
    }

    //
    //  Mark this as a non-constant value entry.
    //

    ClearFlag( Dirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY );

    //
    //  Compute how large a buffer we will need.  If this is an ignore
    //  case operation then we will want a double size buffer.  If the disk is not
    //  a Joliet disk then we might need two bytes for each byte in the name.
    //

    Length = Dirent->FileNameLen;

    if (IgnoreCase) {

        Length *= 2;
    }

    if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        Length *= sizeof( WCHAR );
    }

    //
    //  Now decide if we need to allocate a new buffer.  We will if
    //  this name won't fit in the embedded name buffer and it is
    //  larger than the current allocated buffer.  We always use the
    //  allocated buffer if present.
    //
    //  If we haven't allocated a buffer then use the embedded buffer if the data
    //  will fit.  This is the typical case.
    //

    if (!FlagOn( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER ) &&
        (Length <= sizeof( Dirent->NameBuffer ))) {

        Dirent->CdFileName.FileName.MaximumLength = sizeof( Dirent->NameBuffer );
        Dirent->CdFileName.FileName.Buffer = Dirent->NameBuffer;

    } else {

        //
        //  We need to use an allocated buffer.  Check if the current buffer
        //  is large enough.
        //

        if (Length > Dirent->CdFileName.FileName.MaximumLength) {

            //
            //  Free any allocated buffer.
            //

            if (FlagOn( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER )) {

                ExFreePool( Dirent->CdFileName.FileName.Buffer );
                ClearFlag( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER );
            }

            Dirent->CdFileName.FileName.Buffer = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                                            Length,
                                                                            TAG_DIRENT_NAME );

            SetFlag( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER );

            Dirent->CdFileName.FileName.MaximumLength = (USHORT) Length;
        }
    }

    //
    //  We now have a buffer for the name.  We need to either convert the on-disk bigendian
    //  to little endian or covert the name to Unicode.
    //

    if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        Status = RtlOemToUnicodeN( Dirent->CdFileName.FileName.Buffer,
                                   Dirent->CdFileName.FileName.MaximumLength,
                                   &Length,
                                   Dirent->FileName,
                                   Dirent->FileNameLen );

        ASSERT( Status == STATUS_SUCCESS );
        Dirent->CdFileName.FileName.Length = (USHORT) Length;

    } else {

        //
        //  Convert this string to little endian.
        //

        CdConvertBigToLittleEndian( IrpContext,
                                    Dirent->FileName,
                                    Dirent->FileNameLen,
                                    (PCHAR) Dirent->CdFileName.FileName.Buffer );

        Dirent->CdFileName.FileName.Length = (USHORT) Dirent->FileNameLen;
    }

    //
    //  Split the name into name and version strings.
    //

    CdConvertNameToCdName( IrpContext,
                           &Dirent->CdFileName );

    //
    //  The name length better be non-zero.
    //

    if (Dirent->CdFileName.FileName.Length == 0) {

        CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  If the filename ends with a period then back up one character.
    //

    if (Dirent->CdFileName.FileName.Buffer[(Dirent->CdFileName.FileName.Length - sizeof( WCHAR )) / 2] == L'.') {

        //
        //  Slide the version string down.
        //

        if (Dirent->CdFileName.VersionString.Length != 0) {

            PWCHAR NewVersion;

            //
            //  Start from the position currently containing the separator.
            //

            NewVersion = Add2Ptr( Dirent->CdFileName.FileName.Buffer,
                                  Dirent->CdFileName.FileName.Length,
                                  PWCHAR );

            //
            //  Now overwrite the period.
            //

            RtlMoveMemory( NewVersion - 1,
                           NewVersion,
                           Dirent->CdFileName.VersionString.Length + sizeof( WCHAR ));

            //
            //  Now point to the new version string.
            //

            Dirent->CdFileName.VersionString.Buffer = NewVersion;
        }

        //
        //  Shrink the filename length.
        //

        Dirent->CdFileName.FileName.Length -= sizeof( WCHAR );
    }

    //
    //  If this an exact case operation then use the filename exactly.
    //

    if (!IgnoreCase) {

        Dirent->CdCaseFileName = Dirent->CdFileName;

    //
    //  Otherwise perform our upcase operation.  We already have guaranteed the buffers are
    //  there.
    //

    } else {

        Dirent->CdCaseFileName.FileName.Buffer = Add2Ptr( Dirent->CdFileName.FileName.Buffer,
                                                          Dirent->CdFileName.FileName.MaximumLength / 2,
                                                          PWCHAR);

        Dirent->CdCaseFileName.FileName.MaximumLength = Dirent->CdFileName.FileName.MaximumLength / 2;

        CdUpcaseName( IrpContext,
                      &Dirent->CdFileName,
                      &Dirent->CdCaseFileName );
    }

    return;
}


BOOLEAN
CdFindFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    OUT PCD_NAME *MatchingName
    )

/*++

Routine Description:

    This routine is called to search a dirctory for a file matching the input
    name.  This name has been upcased at this point if this a case-insensitive
    search.  The name has been separated into separate name and version strings.
    We look for an exact match in the name and only consider the version if
    there is a version specified in the search name.

Arguments:

    Fcb - Fcb for the directory being scanned.

    Name - Name to search for.

    IgnoreCase - Indicates the case of the search.

    FileContext - File context to use for the search.  This has already been
        initialized.

    MatchingName - Pointer to buffer containing matching name.  We need this
        in case we don't match the name in the directory but match the
        short name instead.

Return Value:

    BOOLEAN - TRUE if matching entry is found, FALSE otherwise.

--*/

{
    PDIRENT Dirent;
    ULONG ShortNameDirentOffset;

    BOOLEAN Found = FALSE;

    PAGED_CODE();

    //
    //  Make sure there is a stream file for this Fcb.
    //

    if (Fcb->FileObject == NULL) {

        CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Check to see whether we need to check for a possible short name.
    //

    ShortNameDirentOffset = CdShortNameDirentOffset( IrpContext, &Name->FileName );

    //
    //  Position ourselves at the first entry.
    //

    CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, Fcb->StreamOffset );

    //
    //  Loop while there are more entries in this directory.
    //

    do {

        Dirent = &FileContext->InitialDirent->Dirent;

        //
        //  We only consider files which don't have the associated bit set.
        //  We also only look for files.  All directories would already
        //  have been found.
        //

        if (!FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_ASSOC | CD_ATTRIBUTE_DIRECTORY )) {

            //
            //  Update the name in the current dirent.
            //

            CdUpdateDirentName( IrpContext, Dirent, IgnoreCase );

            //
            //  Don't bother with constant entries.
            //

            if (FlagOn( Dirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY )) {

                continue;
            }

            //
            //  Now check whether we have a name match.
            //  We exit the loop if we have a match.
            //

            if (CdIsNameInExpression( IrpContext,
                                      &Dirent->CdCaseFileName,
                                      Name,
                                      0,
                                      TRUE )) {

                *MatchingName = &Dirent->CdCaseFileName;
                Found = TRUE;
                break;
            }

            //
            //  The names didn't match.  If the input name is a possible short
            //  name and we are at the correct offset in the directory then
            //  check if the short names match.
            //

            if (((Dirent->DirentOffset >> SHORT_NAME_SHIFT) == ShortNameDirentOffset) &&
                (Name->VersionString.Length == 0) &&
                !CdIs8dot3Name( IrpContext,
                                Dirent->CdFileName.FileName )) {

                //
                //  Create the short name and check for a match.
                //

                CdGenerate8dot3Name( IrpContext,
                                     &Dirent->CdCaseFileName.FileName,
                                     Dirent->DirentOffset,
                                     FileContext->ShortName.FileName.Buffer,
                                     &FileContext->ShortName.FileName.Length );

                //
                //  Now check whether we have a name match.
                //  We exit the loop if we have a match.
                //

                if (CdIsNameInExpression( IrpContext,
                                          &FileContext->ShortName,
                                          Name,
                                          0,
                                          FALSE )) {

                    *MatchingName = &FileContext->ShortName,
                    Found = TRUE;
                    break;
                }
            }
        }

        //
        //  Go to the next initial dirent for a file.
        //

    } while (CdLookupNextInitialFileDirent( IrpContext, Fcb, FileContext ));

    //
    //  If we find the file then collect all of the dirents.
    //

    if (Found) {

        CdLookupLastFileDirent( IrpContext, Fcb, FileContext );

    }

    return Found;
}


BOOLEAN
CdFindDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to search a dirctory for a directory matching the input
    name.  This name has been upcased at this point if this a case-insensitive
    search.  We look for an exact match in the name and do not look for shortname
    equivalents.

Arguments:

    Fcb - Fcb for the directory being scanned.

    Name - Name to search for.

    IgnoreCase - Indicates the case of the search.

    FileContext - File context to use for the search.  This has already been
        initialized.

Return Value:

    BOOLEAN - TRUE if matching entry is found, FALSE otherwise.

--*/

{
    PDIRENT Dirent;

    BOOLEAN Found = FALSE;

    PAGED_CODE();

    //
    //  Make sure there is a stream file for this Fcb.
    //

    if (Fcb->FileObject == NULL) {

        CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Position ourselves at the first entry.
    //

    CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, Fcb->StreamOffset );

    //
    //  Loop while there are more entries in this directory.
    //

    do {

        Dirent = &FileContext->InitialDirent->Dirent;

        //
        //  We only look for directories.  Directories cannot have the
        //  associated bit set.
        //

        if (FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY )) {

            //
            //  Update the name in the current dirent.
            //

            CdUpdateDirentName( IrpContext, Dirent, IgnoreCase );

            //
            //  Don't bother with constant entries.
            //

            if (FlagOn( Dirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY )) {

                continue;
            }

            //
            //  Now check whether we have a name match.
            //  We exit the loop if we have a match.
            //

            if (CdIsNameInExpression( IrpContext,
                                      &Dirent->CdCaseFileName,
                                      Name,
                                      0,
                                      TRUE )) {

                Found = TRUE;
                break;
            }
        }

        //
        //  Go to the next initial dirent.
        //

    } while (CdLookupNextInitialFileDirent( IrpContext, Fcb, FileContext ));

    return Found;
}


BOOLEAN
CdFindFileByShortName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN ULONG ShortNameDirentOffset,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to find the file name entry whose short name
    is defined by the input DirentOffset.  The dirent offset here is
    multiplied by 32 and we look for the dirent begins in this 32 byte offset in
    directory.  The minimum dirent length is 34 so we are guaranteed that only
    one dirent can begin in each 32 byte block in the directory.

Arguments:

    Fcb - Fcb for the directory being scanned.

    Name - Name we are trying to match.  We know this contains the tilde
        character followed by decimal characters.

    IgnoreCase - Indicates whether we need to upcase the long name and
        generated short name.

    ShortNameDirentOffset - This is the shifted value for the offset of the
        name in the directory.

    FileContext - This is the initialized file context to use for the search.

Return Value:

    BOOLEAN - TRUE if a matching name was found, FALSE otherwise.

--*/

{
    BOOLEAN Found = FALSE;
    PDIRENT Dirent;

    ULONG ThisShortNameDirentOffset;

    PAGED_CODE();

    //
    //  Make sure there is a stream file for this Fcb.
    //

    if (Fcb->FileObject == NULL) {

        CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Position ourselves at the start of the directory and update
    //
    //

    CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, Fcb->StreamOffset );

    //
    //  Loop until we have found the entry or are beyond this dirent.
    //

    do {

        //
        //  Compute the short name dirent offset for the current dirent.
        //

        Dirent = &FileContext->InitialDirent->Dirent;
        ThisShortNameDirentOffset = Dirent->DirentOffset >> SHORT_NAME_SHIFT;

        //
        //  If beyond the target then exit.
        //

        if (ThisShortNameDirentOffset > ShortNameDirentOffset) {

            break;
        }

        //
        //  If equal to the target then check if we have a name match.
        //  We will either match or fail here.
        //

        if (ThisShortNameDirentOffset == ShortNameDirentOffset) {

            //
            //  If this is an associated file then get out.
            //

            if (FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_ASSOC )) {

                break;
            }

            //
            //  Update the name in the dirent and check if it is not
            //  an 8.3 name.
            //

            CdUpdateDirentName( IrpContext, Dirent, IgnoreCase );

            if (CdIs8dot3Name( IrpContext,
                               Dirent->CdFileName.FileName )) {

                break;
            }

            //
            //  Generate the 8.3 name see if it matches our input name.
            //

            CdGenerate8dot3Name( IrpContext,
                                 &Dirent->CdCaseFileName.FileName,
                                 Dirent->DirentOffset,
                                 FileContext->ShortName.FileName.Buffer,
                                 &FileContext->ShortName.FileName.Length );

            //
            //  Check if this name matches.
            //

            if (CdIsNameInExpression( IrpContext,
                                      Name,
                                      &FileContext->ShortName,
                                      0,
                                      FALSE )) {

                //
                //  Let our caller know we found an entry.
                //

                Found = TRUE;
            }

            //
            //  Break out of the loop.
            //

            break;
        }

        //
        //  Continue until there are no more entries.
        //

    } while (CdLookupNextInitialFileDirent( IrpContext, Fcb, FileContext ));

    //
    //  If we find the file then collect all of the dirents.
    //

    if (Found) {

        CdLookupLastFileDirent( IrpContext, Fcb, FileContext );

    }

    return Found;
}


BOOLEAN
CdLookupNextInitialFileDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to walk through the directory until we find the
    first possible dirent for file.  We are positioned at some point described
    by the FileContext.  We will walk through any remaing dirents for the
    current file until we find the first dirent for some subsequent file.

    We can be called when we have found just one dirent for a file or all
    of them.  We first check the CurrentDirContext.  In the typical
    single-extent case this is unused.  Then we look to the InitialDirContext
    which must be initialized.

    This routine will save the initial DirContext to the PriorDirContext and
    clean up any existing DirContext for the Prior or Current positions in
    the enumeration context.

Arguments:

    Fcb - This is the directory to scan.

    FileContext - This is the file enumeration context.  It is currently pointing
        at some file in the directory.

Return Value:

--*/

{
    PRAW_DIRENT RawDirent;

    PDIRENT_ENUM_CONTEXT CurrentDirContext;
    PDIRENT_ENUM_CONTEXT TargetDirContext;
    PCOMPOUND_DIRENT TempDirent;

    BOOLEAN FoundDirent = FALSE;
    BOOLEAN FoundLastDirent;

    PAGED_CODE();

    //
    //  Start by saving the initial dirent of the current file as the
    //  previous file.
    //

    TempDirent = FileContext->PriorDirent;
    FileContext->PriorDirent = FileContext->InitialDirent;
    FileContext->InitialDirent = TempDirent;

    //
    //  We will use the initial dirent of the prior file unless the
    //  previous search returned multiple extents.
    //

    CurrentDirContext = &FileContext->PriorDirent->DirContext;

    if (FlagOn( FileContext->Flags, FILE_CONTEXT_MULTIPLE_DIRENTS )) {

        CurrentDirContext = &FileContext->CurrentDirent->DirContext;
    }

    //
    //  Clear all of the flags and file size for the next file.
    //

    FileContext->Flags = 0;
    FileContext->FileSize = 0;

    FileContext->ShortName.FileName.Length = 0;

    //
    //  We always want to store the result into the updated initial dirent
    //  context.
    //

    TargetDirContext = &FileContext->InitialDirent->DirContext;

    //
    //  Loop until we find the first dirent after the last dirent of the
    //  current file.  We may not be at the last dirent for the current file yet
    //  so we may walk forward looking for the last and then find the
    //  initial dirent for the next file after that.
    //

    while (TRUE) {

        //
        //  Remember if the last dirent we visited was the last dirent for
        //  a file.
        //

        RawDirent = CdRawDirent( IrpContext, CurrentDirContext );

        FoundLastDirent = !FlagOn( CdRawDirentFlags( IrpContext, RawDirent ), CD_ATTRIBUTE_MULTI );

        //
        //  Try to find another dirent.
        //

        FoundDirent = CdLookupNextDirent( IrpContext,
                                          Fcb,
                                          CurrentDirContext,
                                          TargetDirContext );

        //
        //  Exit the loop if no entry found.
        //

        if (!FoundDirent) {

            break;

        }

        //
        //  Update the in-memory dirent.
        //

        CdUpdateDirentFromRawDirent( IrpContext,
                                     Fcb,
                                     TargetDirContext,
                                     &FileContext->InitialDirent->Dirent );

        //
        //  Exit the loop if we had the end for the previous file.
        //

        if (FoundLastDirent) {

            break;
        }

        //
        //  Always use a single dirent from this point on.
        //

        CurrentDirContext = TargetDirContext;
    }

    return FoundDirent;
}


VOID
CdLookupLastFileDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called when we've found the matching initial dirent for
    a file.  Now we want to find all of the dirents for a file as well as
    compute the running total for the file size.

    We also go out to the system use area and check whether this is an
    XA sector.  In that case we will compute the real file size.

    The dirent in the initial compound dirent has been updated from the
    raw dirent when this routine is called.

Arguments:

    Fcb - Directory containing the entries for the file.

    FileContext - Enumeration context for this search.  It currently points
        to the first dirent of the file and the in-memory dirent has been
        updated.

Return Value:

    None.  This routine may raise STATUS_FILE_CORRUPT.

--*/

{
    XA_EXTENT_TYPE ExtentType;
    PCOMPOUND_DIRENT CurrentCompoundDirent;
    PDIRENT CurrentDirent;

    BOOLEAN FirstPass = TRUE;
    BOOLEAN FoundDirent;

    PAGED_CODE();

    //
    //  The current dirent to look at is the initial dirent for the file.
    //

    CurrentCompoundDirent = FileContext->InitialDirent;

    //
    //  Loop until we reach the last dirent for the file.
    //

    while (TRUE) {

        CurrentDirent = &CurrentCompoundDirent->Dirent;

        //
        //  Check if this extent has XA sectors.
        //

        if ((CurrentDirent->SystemUseOffset != 0) &&
            FlagOn( Fcb->Vcb->VcbState, VCB_STATE_CDXA ) &&
            CdCheckForXAExtent( IrpContext,
                                CdRawDirent( IrpContext, &CurrentCompoundDirent->DirContext ),
                                CurrentDirent )) {

            //
            //  Any previous dirent must describe XA sectors as well.
            //

            if (!FirstPass && (ExtentType != CurrentDirent->ExtentType)) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            //
            //  If there are XA sectors then the data on the disk must
            //  be correctly aligned on sectors and be an integral number of
            //  sectors.  Only an issue if the logical block size is not
            //  2048.
            //

            if (Fcb->Vcb->BlockSize != SECTOR_SIZE) {

                //
                //  We will do the following checks.
                //
                //      Data must start on a sector boundary.
                //      Data length must be integral number of sectors.
                //

                if ((SectorBlockOffset( Fcb->Vcb, CurrentDirent->StartingOffset ) != 0) ||
                    (SectorBlockOffset( Fcb->Vcb, CurrentDirent->DataLength ) != 0)) {

                    CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                }

                //
                //  If interleaved then both the file unit and interleave
                //  gap must be integral number of sectors.
                //

                if ((CurrentDirent->FileUnitSize != 0) &&
                    ((SectorBlockOffset( Fcb->Vcb, CurrentDirent->FileUnitSize ) != 0) ||
                     (SectorBlockOffset( Fcb->Vcb, CurrentDirent->InterleaveGapSize ) != 0))) {

                    CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                }
            }

            //
            //  If this is the first dirent then add the bytes for the RIFF
            //  header.
            //

            if (FirstPass) {

                FileContext->FileSize = sizeof( RIFF_HEADER );
            }

            //
            //  Add the size of the mode2-form2 sector for each sector
            //  we have here.
            //

            FileContext->FileSize += Int32x32To64( CurrentDirent->DataLength >> SECTOR_SHIFT,
                                                   XA_SECTOR_SIZE);

        } else {

            //
            //  This extent does not have XA sectors.  Any previous dirent
            //  better not have XA sectors.
            //

            if (!FirstPass && (ExtentType != CurrentDirent->ExtentType)) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            //
            //  Add these bytes to the file size.
            //

            FileContext->FileSize += CurrentDirent->DataLength;
        }

        //
        //  If we are at the last dirent then exit.
        //

        if (!FlagOn( CurrentDirent->DirentFlags, CD_ATTRIBUTE_MULTI )) {

            break;
        }

        //
        //  Remember the extent type of the current extent.
        //

        ExtentType = CurrentDirent->ExtentType;

        //
        //  Look for the next dirent of the file.
        //

        FoundDirent = CdLookupNextDirent( IrpContext,
                                          Fcb,
                                          &CurrentCompoundDirent->DirContext,
                                          &FileContext->CurrentDirent->DirContext );

        //
        //  If we didn't find the entry then this is a corrupt directory.
        //

        if (!FoundDirent) {

            CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Remember the dirent we just found.
        //

        CurrentCompoundDirent = FileContext->CurrentDirent;
        FirstPass = FALSE;

        //
        //  Look up all of the dirent information for the given dirent.
        //

        CdUpdateDirentFromRawDirent( IrpContext,
                                     Fcb,
                                     &CurrentCompoundDirent->DirContext,
                                     &CurrentCompoundDirent->Dirent );

        //
        //  Set flag to show there were multiple extents.
        //

        SetFlag( FileContext->Flags, FILE_CONTEXT_MULTIPLE_DIRENTS );
    }

    return;
}


VOID
CdCleanupFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to cleanup the enumeration context for a file
    search in a directory.  We will unpin any remaining Bcbs and free
    any allocated buffers.

Arguments:

    FileContext - Enumeration context for the file search.

Return Value:

    None.

--*/

{
    PCOMPOUND_DIRENT CurrentCompoundDirent;
    ULONG Count = 2;

    PAGED_CODE();

    //
    //  Cleanup the individual compound dirents.
    //

    do {

        CurrentCompoundDirent = &FileContext->Dirents[ Count ];
        CdCleanupDirContext( IrpContext, &CurrentCompoundDirent->DirContext );
        CdCleanupDirent( IrpContext, &CurrentCompoundDirent->Dirent );

    } while (Count--);

    return;
}


//
//  Local support routine
//

ULONG
CdCheckRawDirentBounds (
    IN PIRP_CONTEXT IrpContext,
    IN PDIRENT_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine takes a Dirent enumeration context and computes the offset
    to the next dirent.  A non-zero value indicates the offset within this
    sector.  A zero value indicates to move to the next sector.  If the
    current dirent does not fit within the sector then we will raise
    STATUS_CORRUPT.

Arguments:

    DirContext - Enumeration context indicating the current position in
        the sector.

Return Value:

    ULONG - Offset to the next dirent in this sector or zero if the
        next dirent is in the next sector.

    This routine will raise on a dirent which does not fit into the
    described data buffer.

--*/

{
    ULONG NextDirentOffset;
    PRAW_DIRENT RawDirent;

    PAGED_CODE();

    //
    //  We should always have at least a byte still available in the
    //  current buffer.
    //

    ASSERT( (DirContext->DataLength - DirContext->SectorOffset) >= 1 );

    //
    //  Get a pointer to the current dirent.
    //

    RawDirent = CdRawDirent( IrpContext, DirContext );

    //
    //  If the dirent length is non-zero then look at the current dirent.
    //

    if (RawDirent->DirLen != 0) {

        //
        //  Check the following bound for the dirent length.
        //
        //      - Fits in the available bytes in the sector.
        //      - Is at least the minimal dirent size.
        //      - Is large enough to hold the file name.
        //

        if ((RawDirent->DirLen > (DirContext->DataLength - DirContext->SectorOffset)) ||
            (RawDirent->DirLen < MIN_RAW_DIRENT_LEN) ||
            (RawDirent->DirLen < (MIN_RAW_DIRENT_LEN - 1 + RawDirent->FileIdLen))) {

            CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Copy the dirent length field.
        //

        NextDirentOffset = RawDirent->DirLen;

        //
        //  If we are exactly at the next sector then tell our caller by
        //  returning zero.
        //

        if (NextDirentOffset == (DirContext->DataLength - DirContext->SectorOffset)) {

            NextDirentOffset = 0;
        }

    } else {

        NextDirentOffset = 0;
    }

    return NextDirentOffset;
}


//
//  Local support routine
//

XA_EXTENT_TYPE
CdCheckForXAExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PRAW_DIRENT RawDirent,
    IN OUT PDIRENT Dirent
    )

/*++

Routine Description:

    This routine is called to scan through the system use area to test if
    the current dirent has the XA bit set.  The bit in the in-memory
    dirent will be set as appropriate.

Arguments:

    RawDirent - Pointer to the on-disk dirent.

    Dirent - Pointer to the in-memory dirent.  We will update this with the
        appropriate XA flag.

Return Value:

    XA_EXTENT_TYPE - Type of physical extent for this on disk dirent.

--*/

{
    XA_EXTENT_TYPE ExtentType = Form1Data;
    PSYSTEM_USE_XA SystemUseArea;

    PAGED_CODE();

    //
    //  Check if there is enough space for the XA system use area.
    //

    if (Dirent->DirentLength - Dirent->SystemUseOffset >= sizeof( SYSTEM_USE_XA )) {

        SystemUseArea = Add2Ptr( RawDirent, Dirent->SystemUseOffset, PSYSTEM_USE_XA );

        //
        //  Check for a valid signature.
        //

        if (SystemUseArea->Signature == SYSTEM_XA_SIGNATURE) {

            //
            //  Check for an audio track.
            //

            if (FlagOn( SystemUseArea->Attributes, SYSTEM_USE_XA_DA )) {

                ExtentType = CDAudio;

            } else if (FlagOn( SystemUseArea->Attributes, SYSTEM_USE_XA_FORM2 )) {

                //
                //  Check for XA data.  Note that a number of discs (video CDs)
                //  have files marked as type XA Mode 2 Form 1 (2048 bytes of 
                //  user data),  but actually record these sectors as Mode2 Form 2 
                //  (2352). We will fail to read these files,  since for M2F1,  
                //  a normal read CD command is issued (as per SCSI specs).
                //
                
                ExtentType = Mode2Form2Data;
            }

            Dirent->XAAttributes = SystemUseArea->Attributes;
            Dirent->XAFileNumber = SystemUseArea->FileNumber;
        }
    }

    Dirent->ExtentType = ExtentType;
    return ExtentType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\fileinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Cdfs called by
    the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_FILEINFO)

//
//  Local support routines
//

VOID
CdQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonQueryInfo)
#pragma alloc_text(PAGE, CdCommonSetInfo)
#pragma alloc_text(PAGE, CdFastQueryBasicInfo)
#pragma alloc_text(PAGE, CdFastQueryStdInfo)
#pragma alloc_text(PAGE, CdFastQueryNetworkInfo)
#pragma alloc_text(PAGE, CdQueryAlternateNameInfo)
#pragma alloc_text(PAGE, CdQueryBasicInfo)
#pragma alloc_text(PAGE, CdQueryEaInfo)
#pragma alloc_text(PAGE, CdQueryInternalInfo)
#pragma alloc_text(PAGE, CdQueryNameInfo)
#pragma alloc_text(PAGE, CdQueryNetworkInfo)
#pragma alloc_text(PAGE, CdQueryPositionInfo)
#pragma alloc_text(PAGE, CdQueryStandardInfo)
#endif


NTSTATUS
CdCommonQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query file information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for this operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_ALL_INFORMATION Buffer;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN ReleaseFcb = FALSE;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We only support query on file and directory handles.
        //

        switch (TypeOfOpen) {

        case UserDirectoryOpen :
        case UserFileOpen :

            //
            //  Acquire shared access to this file.  NOTE that this could be
            //  a recursive acquire,  if we already preacquired in
            //  CdAcquireForCreateSection().
            //

            CdAcquireFileShared( IrpContext, Fcb );
            ReleaseFcb = TRUE;

            //
            //  Make sure we have the correct sizes for a directory.
            //

            if (!FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED )) {

                ASSERT( TypeOfOpen == UserDirectoryOpen );
                CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
            }

            //
            //  Make sure the Fcb is in a usable condition.  This will raise
            //  an error condition if the volume is unusable
            //

            CdVerifyFcbOperation( IrpContext, Fcb );

            //
            //  Based on the information class we'll do different
            //  actions.  Each of hte procedures that we're calling fills
            //  up the output buffer, if possible.  They will raise the
            //  status STATUS_BUFFER_OVERFLOW for an insufficient buffer.
            //  This is considered a somewhat unusual case and is handled
            //  more cleanly with the exception mechanism rather than
            //  testing a return status value for each call.
            //

            switch (FileInformationClass) {

            case FileAllInformation:

                //
                //  We don't allow this operation on a file opened by file Id.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                //  In this case go ahead and call the individual routines to
                //  fill in the buffer.  Only the name routine will
                //  pointer to the output buffer and then call the
                //  individual routines to fill in the buffer.
                //

                Length -= (sizeof( FILE_ACCESS_INFORMATION ) +
                           sizeof( FILE_MODE_INFORMATION ) +
                           sizeof( FILE_ALIGNMENT_INFORMATION ));

                CdQueryBasicInfo( IrpContext, Fcb, &Buffer->BasicInformation, &Length );
                CdQueryStandardInfo( IrpContext, Fcb, &Buffer->StandardInformation, &Length );
                CdQueryInternalInfo( IrpContext, Fcb, &Buffer->InternalInformation, &Length );
                CdQueryEaInfo( IrpContext, Fcb, &Buffer->EaInformation, &Length );
                CdQueryPositionInfo( IrpContext, IrpSp->FileObject, &Buffer->PositionInformation, &Length );
                Status = CdQueryNameInfo( IrpContext, IrpSp->FileObject, &Buffer->NameInformation, &Length );

                break;

            case FileBasicInformation:

                CdQueryBasicInfo( IrpContext, Fcb, (PFILE_BASIC_INFORMATION) Buffer, &Length );
                break;

            case FileStandardInformation:

                CdQueryStandardInfo( IrpContext, Fcb, (PFILE_STANDARD_INFORMATION) Buffer, &Length );
                break;

            case FileInternalInformation:

                CdQueryInternalInfo( IrpContext, Fcb, (PFILE_INTERNAL_INFORMATION) Buffer, &Length );
                break;

            case FileEaInformation:

                CdQueryEaInfo( IrpContext, Fcb, (PFILE_EA_INFORMATION) Buffer, &Length );
                break;

            case FilePositionInformation:

                CdQueryPositionInfo( IrpContext, IrpSp->FileObject, (PFILE_POSITION_INFORMATION) Buffer, &Length );
                break;

            case FileNameInformation:

                //
                //  We don't allow this operation on a file opened by file Id.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = CdQueryNameInfo( IrpContext, IrpSp->FileObject, (PFILE_NAME_INFORMATION) Buffer, &Length );

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                }

                break;

            case FileAlternateNameInformation:

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = CdQueryAlternateNameInfo( IrpContext, Fcb, Ccb, (PFILE_NAME_INFORMATION) Buffer, &Length );

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                }

                break;

            case FileNetworkOpenInformation:

                CdQueryNetworkInfo( IrpContext, Fcb, (PFILE_NETWORK_OPEN_INFORMATION) Buffer, &Length );
                break;

            default :

                Status = STATUS_INVALID_PARAMETER;
            }

            break;

        default :

            Status = STATUS_INVALID_PARAMETER;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //  and then complete the request
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

    } finally {

        //
        //  Release the file.
        //

        if (ReleaseFcb) {

            CdReleaseFile( IrpContext, Fcb );
        }
    }

    //
    //  Complete the request if we didn't raise.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
CdCommonSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set file information called by both the
    fsd and fsp threads.  We only support operations which set the file position.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for this operation.

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFILE_POSITION_INFORMATION Buffer;

    PAGED_CODE();

    //
    //  Decode the file object
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  We only support a SetPositionInformation on a user file.
    //

    if ((TypeOfOpen != UserFileOpen) ||
        (IrpSp->Parameters.QueryFile.FileInformationClass != FilePositionInformation)) {

        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Acquire shared access to this file.
    //

    CdAcquireFileShared( IrpContext, Fcb );

    try {

        //
        //  Make sure the Fcb is in a usable condition.  This
        //  will raise an error condition if the fcb is unusable
        //

        CdVerifyFcbOperation( IrpContext, Fcb );

        Buffer = Irp->AssociatedIrp.SystemBuffer;

        //
        //  Check if the file does not use intermediate buffering.  If it
        //  does not use intermediate buffering then the new position we're
        //  supplied must be aligned properly for the device
        //

        if (FlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            ((Buffer->CurrentByteOffset.LowPart & IrpSp->DeviceObject->AlignmentRequirement) != 0)) {

            try_return( NOTHING );
        }

        //
        //  The input parameter is fine so set the current byte offset and
        //  complete the request
        //

        //
        //  Lock the Fcb to provide synchronization.
        //

        CdLockFcb( IrpContext, Fcb );
        IrpSp->FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;
        CdUnlockFcb( IrpContext, Fcb );

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        CdReleaseFile( IrpContext, Fcb );
    }

    //
    //  Complete the request if there was no raise.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


BOOLEAN
CdFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for basic file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    //
    //  We only support this request on user file or directory objects.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        ((TypeOfOpen != UserDirectoryOpen) || !FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED))) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (CdVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Fill in the input buffer from the Fcb fields.
            //

            Buffer->CreationTime.QuadPart =
            Buffer->LastWriteTime.QuadPart =
            Buffer->ChangeTime.QuadPart = Fcb->CreationTime;

            Buffer->LastAccessTime.QuadPart = 0;

            Buffer->FileAttributes = Fcb->FileAttributes;

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_BASIC_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


BOOLEAN
CdFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    //
    //  We only support this request on initialized user file or directory objects.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        ((TypeOfOpen != UserDirectoryOpen) || !FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED ))) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (CdVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Check whether this is a directory.
            //

            if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                Buffer->AllocationSize.QuadPart =
                Buffer->EndOfFile.QuadPart = 0;

                Buffer->Directory = TRUE;

            } else {

                Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
                Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;

                Buffer->Directory = FALSE;
            }

            Buffer->NumberOfLinks = 1;
            Buffer->DeletePending = FALSE;

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_STANDARD_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


BOOLEAN
CdFastQueryNetworkInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for network file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    //
    //  We only support this request on user file or directory objects.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        ((TypeOfOpen != UserDirectoryOpen) || !FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED))) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (CdVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Fill in the input buffer from the Fcb fields.
            //

            Buffer->CreationTime.QuadPart =
            Buffer->LastWriteTime.QuadPart =
            Buffer->ChangeTime.QuadPart = Fcb->CreationTime;

            Buffer->LastAccessTime.QuadPart = 0;

            Buffer->FileAttributes = Fcb->FileAttributes;

            //
            //  Check whether this is a directory.
            //

            if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                Buffer->AllocationSize.QuadPart =
                Buffer->EndOfFile.QuadPart = 0;

            } else {

                Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
                Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;
            }

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_NETWORK_OPEN_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


//
//  Local support routine
//

VOID
CdQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

 Description:

    This routine performs the query basic information function for Cdfs

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We only support creation, last modify and last write times on Cdfs.
    //

    Buffer->LastWriteTime.QuadPart =
    Buffer->CreationTime.QuadPart =
    Buffer->ChangeTime.QuadPart = Fcb->CreationTime;

    Buffer->LastAccessTime.QuadPart = 0;

    Buffer->FileAttributes = Fcb->FileAttributes;

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
CdQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length
    )
/*++

Routine Description:

    This routine performs the query standard information function for cdfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  There is only one link and delete is never pending on a Cdrom file.
    //

    Buffer->NumberOfLinks = 1;
    Buffer->DeletePending = FALSE;

    //
    //  We get the sizes from the header.  Return a size of zero
    //  for all directories.
    //

    if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

        Buffer->AllocationSize.QuadPart =
        Buffer->EndOfFile.QuadPart = 0;

        Buffer->Directory = TRUE;

    } else {

        Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;

        Buffer->Directory = FALSE;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
CdQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information function for cdfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Index number is the file Id number in the Fcb.
    //

    Buffer->IndexNumber = Fcb->FileId;
    *Length -= sizeof( FILE_INTERNAL_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
CdQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query Ea information function for cdfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  No Ea's on Cdfs volumes.
    //

    Buffer->EaSize = 0;
    *Length -= sizeof( FILE_EA_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
CdQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query position information function for cdfs.

Arguments:

    FileObject - Supplies the File object being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Get the current position found in the file object.
    //

    Buffer->CurrentByteOffset = FileObject->CurrentByteOffset;

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_POSITION_INFORMATION );

    return;
}


//
//  Local support routine
//

NTSTATUS
CdQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information function for cdfs.

Arguments:

    FileObject - Supplies the file object containing the name.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_BUFFER_OVERFLOW if the entire name can't be copied.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LengthToCopy;

    PAGED_CODE();

    ASSERT(*Length >= sizeof(ULONG));
    
    //
    //  Simply copy the name in the file object to the user's buffer.
    //

    //
    //  Place the size of the filename in the user's buffer and reduce the remaining
    //  size to match.
    //

    Buffer->FileNameLength = LengthToCopy = FileObject->FileName.Length;
    *Length -= sizeof(ULONG);

    if (LengthToCopy > *Length) {

        LengthToCopy = *Length;
        Status = STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory( Buffer->FileName, FileObject->FileName.Buffer, LengthToCopy );

    //
    //  Reduce the available bytes by the amount stored into this buffer.  In the overflow
    //  case, this simply drops to zero.  The returned filenamelength will indicate to the
    //  caller how much space is required.
    //

    *Length -= LengthToCopy;

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query alternate name information function.
    We lookup the dirent for this file and then check if there is a
    short name.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified.

    Ccb - Ccb for this open handle.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned.

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the whole name would fit into the user buffer,
               STATUS_OBJECT_NAME_NOT_FOUND if we can't return the name,
               STATUS_BUFFER_OVERFLOW otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    DIRENT_ENUM_CONTEXT DirContext;
    DIRENT Dirent;

    PUNICODE_STRING NameToUse;
    ULONG DirentOffset;

    COMPOUND_PATH_ENTRY CompoundPathEntry;
    FILE_ENUM_CONTEXT FileContext;

    PFCB ParentFcb;
    BOOLEAN ReleaseParentFcb = FALSE;

    BOOLEAN CleanupFileLookup = FALSE;
    BOOLEAN CleanupDirectoryLookup = FALSE;

    WCHAR ShortNameBuffer[ BYTE_COUNT_8_DOT_3 / 2 ];
    USHORT ShortNameLength;

    PAGED_CODE();

    //
    //  Initialize the buffer length to zero.
    //

    Buffer->FileNameLength = 0;

    //
    //  If this is the root or this file was opened using a version number then
    //  there is no short name.
    //

    if ((Fcb == Fcb->Vcb->RootIndexFcb) ||
        FlagOn( Ccb->Flags, CCB_FLAG_OPEN_WITH_VERSION)) {

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    //  Use a try-finally to cleanup the structures.
    //

    try {

        ParentFcb = Fcb->ParentFcb;
        CdAcquireFileShared( IrpContext, ParentFcb );
        ReleaseParentFcb = TRUE;
    
        //
        //  Do an unsafe test to see if we need to create a file object.
        //

        if (ParentFcb->FileObject == NULL) {

            CdCreateInternalStream( IrpContext, ParentFcb->Vcb, ParentFcb );
        }

        if (CdFidIsDirectory( Fcb->FileId)) {

            //
            //  Fcb is for a directory, so we need to dig the dirent from the parent.  In
            //  order to do this we need to get the name of the directory from its pathtable
            //  entry and then search in the parent for a matching dirent.
            //
            //  This could be optimized somewhat.
            //

            CdInitializeCompoundPathEntry( IrpContext, &CompoundPathEntry );
            CdInitializeFileContext( IrpContext, &FileContext );

            CleanupDirectoryLookup = TRUE;

            CdLookupPathEntry( IrpContext,
                               CdQueryFidPathTableOffset( Fcb->FileId ),
                               Fcb->Ordinal,
                               FALSE,
                               &CompoundPathEntry );

            CdUpdatePathEntryName( IrpContext, &CompoundPathEntry.PathEntry, TRUE );

            if (!CdFindDirectory( IrpContext,
                                  ParentFcb,
                                  &CompoundPathEntry.PathEntry.CdCaseDirName,
                                  TRUE,
                                  &FileContext )) {

                //
                //  If we failed to find the child directory by name in the parent
                //  something is quite wrong with this disc.
                //

                CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }

            NameToUse = &FileContext.InitialDirent->Dirent.CdCaseFileName.FileName;
            DirentOffset = FileContext.InitialDirent->Dirent.DirentOffset;
        
        } else {

            //
            //  Initialize the search dirent structures.
            //
        
            CdInitializeDirContext( IrpContext, &DirContext );
            CdInitializeDirent( IrpContext, &Dirent );
    
            CleanupFileLookup = TRUE;
        
            CdLookupDirent( IrpContext,
                            ParentFcb,
                            CdQueryFidDirentOffset( Fcb->FileId ),
                            &DirContext );
    
            CdUpdateDirentFromRawDirent( IrpContext,
                                         ParentFcb,
                                         &DirContext,
                                         &Dirent );

            //
            //  Now update the dirent name.
            //
    
            CdUpdateDirentName( IrpContext, &Dirent, TRUE );
    
            NameToUse = &Dirent.CdCaseFileName.FileName;
            DirentOffset = Dirent.DirentOffset;
        }

        //
        //  If the name is 8.3 then fail this request.
        //

        if (CdIs8dot3Name( IrpContext,
                           *NameToUse )) {


            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        CdGenerate8dot3Name( IrpContext,
                             NameToUse,
                             DirentOffset,
                             ShortNameBuffer,
                             &ShortNameLength );

        //
        //  We now have the short name.  We have left it in Unicode form so copy it directly.
        //

        Buffer->FileNameLength = ShortNameLength;

        if (Buffer->FileNameLength + sizeof( ULONG ) > *Length) {

            Buffer->FileNameLength = *Length - sizeof( ULONG );
            Status = STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory( Buffer->FileName, ShortNameBuffer, Buffer->FileNameLength );

    try_exit:  NOTHING;
    } finally {

        if (CleanupFileLookup) {

            CdCleanupDirContext( IrpContext, &DirContext );
            CdCleanupDirent( IrpContext, &Dirent );

        } else if (CleanupDirectoryLookup) {

            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
            CdCleanupFileContext( IrpContext, &FileContext );
        }

        if (ReleaseParentFcb) {

            CdReleaseFile( IrpContext, ParentFcb );
        }
    }

    //
    //  Reduce the available bytes by the amount stored into this buffer.
    //

    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

        *Length -= sizeof( ULONG ) + Buffer->FileNameLength;
    }

    return Status;
}


//
//  Local support routine
//

VOID
CdQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

 Description:

    This routine performs the query network open information function for Cdfs

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We only support creation, last modify and last write times on Cdfs.
    //

    Buffer->LastWriteTime.QuadPart =
    Buffer->CreationTime.QuadPart =
    Buffer->ChangeTime.QuadPart = Fcb->CreationTime;

    Buffer->LastAccessTime.QuadPart = 0;

    Buffer->FileAttributes = Fcb->FileAttributes;

    //
    //  We get the sizes from the header.  Return a size of zero
    //  for all directories.
    //

    if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

        Buffer->AllocationSize.QuadPart =
        Buffer->EndOfFile.QuadPart = 0;

    } else {

        Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_NETWORK_OPEN_INFORMATION );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\filobsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Cdfs File object support routines.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_FILOBSUP)

//
//  Local constants.
//

#define TYPE_OF_OPEN_MASK               (0x00000007)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdDecodeFileObject)
#pragma alloc_text(PAGE, CdFastDecodeFileObject)
#pragma alloc_text(PAGE, CdSetFileObject)
#endif


VOID
CdSetFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PFCB Fcb OPTIONAL,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine will initialize the FileObject context fields based on the
    input type and data structures.

Arguments:

    FileObject - Supplies the file object pointer being initialized.

    TypeOfOpen - Sets the type of open.

    Fcb - Fcb for this file object.  Ignored for UnopenedFileObject.

    Ccb - Ccb for the handle corresponding to this file object.  Will not
        be present for stream file objects.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  We only have values 0 to 7 available so make sure we didn't
    //  inadvertantly add a new type.
    //

    ASSERTMSG( "FileObject types exceed available bits\n", BeyondValidType <= 8 );

    //
    //  Setting a file object to type UnopenedFileObject means just
    //  clearing all of the context fields.  All the other input
    //

    if (TypeOfOpen == UnopenedFileObject) {

        FileObject->FsContext =
        FileObject->FsContext2 = NULL;

        return;
    }

    //
    //  Check that the 3 low-order bits of the Ccb are clear.
    //

    ASSERTMSG( "Ccb is not quad-aligned\n", !FlagOn( ((ULONG_PTR) Ccb), TYPE_OF_OPEN_MASK ));

    //
    //  We will or the type of open into the low order bits of FsContext2
    //  along with the Ccb value.
    //  The Fcb is stored into the FsContext field.
    //

    FileObject->FsContext = Fcb;
    FileObject->FsContext2 = Ccb;

    SetFlag( ((ULONG_PTR) FileObject->FsContext2), TypeOfOpen );

    //
    //  Set the Vpb field in the file object.
    //

    FileObject->Vpb = Fcb->Vcb->Vpb;

    return;
}



TYPE_OF_OPEN
CdDecodeFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PCCB *Ccb
    )

/*++

Routine Description:

    This routine takes a file object and extracts the Fcb and Ccb (possibly NULL)
    and returns the type of open.

Arguments:

    FileObject - Supplies the file object pointer being initialized.

    Fcb - Address to store the Fcb contained in the file object.

    Ccb - Address to store the Ccb contained in the file object.

Return Value:

    TYPE_OF_OPEN - Indicates the type of file object.

--*/

{
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    //
    //  If this is an unopened file object then return NULL for the
    //  Fcb/Ccb.  Don't trust any other values in the file object.
    //

    TypeOfOpen = (TYPE_OF_OPEN) FlagOn( (ULONG_PTR) FileObject->FsContext2,
                                        TYPE_OF_OPEN_MASK );

    if (TypeOfOpen == UnopenedFileObject) {

        *Fcb = NULL;
        *Ccb = NULL;

    } else {

        //
        //  The Fcb is pointed to by the FsContext field.  The Ccb is in
        //  FsContext2 (after clearing the low three bits).  The low three
        //  bits are the file object type.
        //

        *Fcb = FileObject->FsContext;
        *Ccb = FileObject->FsContext2;

        ClearFlag( (ULONG_PTR) *Ccb, TYPE_OF_OPEN_MASK );
    }

    //
    //  Now return the type of open.
    //

    return TypeOfOpen;
}


TYPE_OF_OPEN
CdFastDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by Cdfs and does a quick decode operation.  It will only return
    a non null value if the file object is a user file open

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    Fcb - Address to store Fcb if this is a user file object.  NULL
        otherwise.

Return Value:

    TYPE_OF_OPEN - type of open of this file object.

--*/

{
    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    //
    //  The Fcb is in the FsContext field.  The type of open is in the low
    //  bits of the Ccb.
    //

    *Fcb = FileObject->FsContext;

    return (TYPE_OF_OPEN)
            FlagOn( (ULONG_PTR) FileObject->FsContext2, TYPE_OF_OPEN_MASK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\fsctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Cdfs called
    by the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_FSCTRL)

//
//  Local constants
//

BOOLEAN CdDisable = FALSE;

//
//  Local support routines
//

NTSTATUS
CdUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
CdReMountOldVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB OldVcb,
    IN PVCB NewVcb,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo
    );

NTSTATUS
CdMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

CdIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdInvalidateVolumes (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
CdScanForDismountedVcb (
    IN PIRP_CONTEXT IrpContext
    );

BOOLEAN
CdFindPrimaryVd (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PCHAR RawIsoVd,
    IN ULONG BlockFactor,
    IN BOOLEAN ReturnOnError,
    IN BOOLEAN VerifyVolume
    );

BOOLEAN
CdIsRemount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PVCB *OldVcb
    );

VOID
CdFindActiveVolDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PCHAR RawIsoVd,
    IN BOOLEAN VerifyVolume
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonFsControl)
#pragma alloc_text(PAGE, CdDismountVolume)
#pragma alloc_text(PAGE, CdFindActiveVolDescriptor)
#pragma alloc_text(PAGE, CdFindPrimaryVd)
#pragma alloc_text(PAGE, CdIsPathnameValid)
#pragma alloc_text(PAGE, CdIsRemount)
#pragma alloc_text(PAGE, CdIsVolumeDirty)
#pragma alloc_text(PAGE, CdIsVolumeMounted)
#pragma alloc_text(PAGE, CdLockVolume)
#pragma alloc_text(PAGE, CdMountVolume)
#pragma alloc_text(PAGE, CdOplockRequest)
#pragma alloc_text(PAGE, CdScanForDismountedVcb)
#pragma alloc_text(PAGE, CdUnlockVolume)
#pragma alloc_text(PAGE, CdUserFsctl)
#pragma alloc_text(PAGE, CdVerifyVolume)
#endif


//
//  Local support routine
//

NTSTATUS
CdLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual lock volume operation.  It will be called
    by anyone wishing to try to protect the volume for a long duration.  PNP
    operations are such a user.
    
    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.
    
    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KIRQL SavedIrql;
    NTSTATUS FinalStatus = (FileObject? STATUS_ACCESS_DENIED: STATUS_DEVICE_BUSY);
    ULONG RemainingUserReferences = (FileObject? 1: 0);

    //
    //  The cleanup count for the volume only reflects the fileobject that
    //  will lock the volume.  Otherwise, we must fail the request.
    //
    //  Since the only cleanup is for the provided fileobject, we will try
    //  to get rid of all of the other user references.  If there is only one
    //  remaining after the purge then we can allow the volume to be locked.
    //
    
    CdPurgeVolume( IrpContext, Vcb, FALSE );

    //
    //  Now back out of our synchronization and wait for the lazy writer
    //  to finish off any lazy closes that could have been outstanding.
    //
    //  Since we purged, we know that the lazy writer will issue all
    //  possible lazy closes in the next tick - if we hadn't, an otherwise
    //  unopened file with a large amount of dirty data could have hung
    //  around for a while as the data trickled out to the disk.
    //
    //  This is even more important now since we send notification to
    //  alert other folks that this style of check is about to happen so
    //  that they can close their handles.  We don't want to enter a fast
    //  race with the lazy writer tearing down his references to the file.
    //

    CdReleaseVcb( IrpContext, Vcb );

    Status = CcWaitForCurrentLazyWriterActivity();

    //
    //  This is intentional. If we were able to get the Vcb before, just
    //  wait for it and take advantage of knowing that it is OK to leave
    //  the flag up.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    
    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    CdFspClose( Vcb );

    //
    //  If the volume is already explicitly locked then fail.  We use the
    //  Vpb locked flag as an 'explicit lock' flag in the same way as Fat.
    //

    IoAcquireVpbSpinLock( &SavedIrql ); 
        
    if (!FlagOn( Vcb->Vpb->Flags, VPB_LOCKED ) && 
        (Vcb->VcbCleanup == RemainingUserReferences) &&
        (Vcb->VcbUserReference == CDFS_RESIDUAL_USER_REFERENCE + RemainingUserReferences))  {

        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        SetFlag( Vcb->Vpb->Flags, VPB_LOCKED);
        Vcb->VolumeLockFileObject = FileObject;
        FinalStatus = STATUS_SUCCESS;
    }
    
    IoReleaseVpbSpinLock( SavedIrql );  
    
    return FinalStatus;
}


NTSTATUS
CdUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual unlock volume operation. 
    
    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.
    
    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation
    
    Attempting to remove a system lock that did not exist is OK.

--*/

{
    NTSTATUS Status = STATUS_NOT_LOCKED;
    KIRQL SavedIrql;

    //
    //  Note that we check the VPB_LOCKED flag here rather than the Vcb
    //  lock flag.  The Vpb flag is only set for an explicit lock request,  not
    //  for the implicit lock obtained on a volume open with zero share mode.
    //
    
    IoAcquireVpbSpinLock( &SavedIrql ); 
 
    if (FlagOn(Vcb->Vpb->Flags, VPB_LOCKED) && 
        (FileObject == Vcb->VolumeLockFileObject))  {

        ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED);
        Vcb->VolumeLockFileObject = NULL;
        Status = STATUS_SUCCESS;
    }
    
    IoReleaseVpbSpinLock( SavedIrql );  

    return Status;
}


NTSTATUS
CdCommonFsControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_USER_FS_REQUEST:

        Status = CdUserFsctl( IrpContext, Irp );
        break;

    case IRP_MN_MOUNT_VOLUME:

        Status = CdMountVolume( IrpContext, Irp );
        break;

    case IRP_MN_VERIFY_VOLUME:

        Status = CdVerifyVolume( IrpContext, Irp );
        break;

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  Case on the control code.
    //

    switch ( IrpSp->Parameters.FileSystemControl.FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1 :
    case FSCTL_REQUEST_OPLOCK_LEVEL_2 :
    case FSCTL_REQUEST_BATCH_OPLOCK :
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_NOTIFY :
    case FSCTL_OPLOCK_BREAK_ACK_NO_2 :
    case FSCTL_REQUEST_FILTER_OPLOCK :

        Status = CdOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_LOCK_VOLUME :

        Status = CdLockVolume( IrpContext, Irp );
        break;

    case FSCTL_UNLOCK_VOLUME :

        Status = CdUnlockVolume( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME :

        Status = CdDismountVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_DIRTY :

        Status = CdIsVolumeDirty( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_MOUNTED :

        Status = CdIsVolumeMounted( IrpContext, Irp );
        break;

    case FSCTL_IS_PATHNAME_VALID :

        Status = CdIsPathnameValid( IrpContext, Irp );
        break;

    case FSCTL_INVALIDATE_VOLUMES :

        Status = CdInvalidateVolumes( IrpContext, Irp );
        break;


    //
    //  We don't support any of the known or unknown requests.
    //

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


VOID
CdReMountOldVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB OldVcb,
    IN PVCB NewVcb,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo
    )
{
    KIRQL SavedIrql;
    
    ObDereferenceObject( OldVcb->TargetDeviceObject );

    IoAcquireVpbSpinLock( &SavedIrql );

    NewVcb->Vpb->RealDevice->Vpb = OldVcb->Vpb;
    
    OldVcb->Vpb->RealDevice = NewVcb->Vpb->RealDevice;
    OldVcb->TargetDeviceObject = DeviceObjectWeTalkTo;
    
    CdUpdateVcbCondition( OldVcb, VcbMounted);
    CdUpdateMediaChangeCount( OldVcb, NewVcb->MediaChangeCount);

    ClearFlag( OldVcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE);

    IoReleaseVpbSpinLock( SavedIrql );
}


//
//  Local support routine
//

NTSTATUS
CdMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the mount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

    Its job is to verify that the volume denoted in the IRP is a Cdrom volume,
    and create the VCB and root DCB structures.  The algorithm it
    uses is essentially as follows:

    1. Create a new Vcb Structure, and initialize it enough to do I/O
       through the on-disk volume descriptors.

    2. Read the disk and check if it is a Cdrom volume.

    3. If it is not a Cdrom volume then delete the Vcb and
       complete the IRP back with an appropriate status.

    4. Check if the volume was previously mounted and if it was then do a
       remount operation.  This involves deleting the VCB, hook in the
       old VCB, and complete the IRP.

    5. Otherwise create a Vcb and root DCB for each valid volume descriptor.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PVOLUME_DEVICE_OBJECT VolDo = NULL;
    PVCB Vcb = NULL;
    PVCB OldVcb;
    
    BOOLEAN FoundPvd = FALSE;
    BOOLEAN SetDoVerifyOnFail;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT DeviceObjectWeTalkTo = IrpSp->Parameters.MountVolume.DeviceObject;
    PVPB Vpb = IrpSp->Parameters.MountVolume.Vpb;

    PFILE_OBJECT FileObjectToNotify = NULL;

    ULONG BlockFactor;
    DISK_GEOMETRY DiskGeometry;

    IO_SCSI_CAPABILITIES Capabilities;

    IO_STATUS_BLOCK Iosb;

    PCHAR RawIsoVd = NULL;

    PCDROM_TOC CdromToc = NULL;
    ULONG TocLength = 0;
    ULONG TocTrackCount = 0;
    ULONG TocDiskFlags = 0;
    ULONG MediaChangeCount = 0;

    PAGED_CODE();

    //
    //  Check that we are talking to a Cdrom device.  This request should
    //  always be waitable.
    //

    ASSERT( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM );
    ASSERT( FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

    //
    //  Update the real device in the IrpContext from the Vpb.  There was no available
    //  file object when the IrpContext was created.
    //

    IrpContext->RealDevice = Vpb->RealDevice;

    SetDoVerifyOnFail = CdRealDevNeedsVerify( IrpContext->RealDevice);

    //
    //  Check if we have disabled the mount process.
    //

    if (CdDisable) {

        CdCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Do a CheckVerify here to lift the MediaChange ticker from the driver
    //

    Status = CdPerformDevIoCtrl( IrpContext,
                                 IOCTL_CDROM_CHECK_VERIFY,
                                 DeviceObjectWeTalkTo,
                                 &MediaChangeCount,
                                 sizeof(ULONG),
                                 FALSE,
                                 TRUE,
                                 &Iosb );

    if (!NT_SUCCESS( Status )) {
        
        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }
    
    if (Iosb.Information != sizeof(ULONG)) {

        //
        //  Be safe about the count in case the driver didn't fill it in
        //

        MediaChangeCount = 0;
    }

    //
    //  Now let's make Jeff delirious and call to get the disk geometry.  This
    //  will fix the case where the first change line is swallowed.
    //

    Status = CdPerformDevIoCtrl( IrpContext,
                                 IOCTL_CDROM_GET_DRIVE_GEOMETRY,
                                 DeviceObjectWeTalkTo,
                                 &DiskGeometry,
                                 sizeof( DISK_GEOMETRY ),
                                 FALSE,
                                 TRUE,
                                 NULL );

    //
    //  Return insufficient sources to our caller.
    //

    if (Status == STATUS_INSUFFICIENT_RESOURCES) {

        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Now check the block factor for addressing the volume descriptors.
    //  If the call for the disk geometry failed then assume there is one
    //  block per sector.
    //

    BlockFactor = 1;

    if (NT_SUCCESS( Status ) &&
        (DiskGeometry.BytesPerSector != 0) &&
        (DiskGeometry.BytesPerSector < SECTOR_SIZE)) {

        BlockFactor = SECTOR_SIZE / DiskGeometry.BytesPerSector;
    }

    //
    //  Acquire the global resource to do mount operations.
    //

    CdAcquireCdData( IrpContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Allocate a buffer to query the TOC.
        //

        CdromToc = FsRtlAllocatePoolWithTag( CdPagedPool,
                                             sizeof( CDROM_TOC ),
                                             TAG_CDROM_TOC );

        RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

        //
        //  Do a quick check to see if there any Vcb's which can be removed.
        //

        CdScanForDismountedVcb( IrpContext );

        //
        //  Get our device object and alignment requirement.
        //

        Status = IoCreateDevice( CdData.DriverObject,
                                 sizeof( VOLUME_DEVICE_OBJECT ) - sizeof( DEVICE_OBJECT ),
                                 NULL,
                                 FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                                 0,
                                 FALSE,
                                 (PDEVICE_OBJECT *) &VolDo );

        if (!NT_SUCCESS( Status )) { try_leave( Status ); }

        //
        //  Our alignment requirement is the larger of the processor alignment requirement
        //  already in the volume device object and that in the DeviceObjectWeTalkTo
        //

        if (DeviceObjectWeTalkTo->AlignmentRequirement > VolDo->DeviceObject.AlignmentRequirement) {

            VolDo->DeviceObject.AlignmentRequirement = DeviceObjectWeTalkTo->AlignmentRequirement;
        }

        //
        //  We must initialize the stack size in our device object before
        //  the following reads, because the I/O system has not done it yet.
        //

        ((PDEVICE_OBJECT) VolDo)->StackSize = (CCHAR) (DeviceObjectWeTalkTo->StackSize + 1);

        ClearFlag( VolDo->DeviceObject.Flags, DO_DEVICE_INITIALIZING );

        //
        //  Initialize the overflow queue for the volume
        //

        VolDo->OverflowQueueCount = 0;
        InitializeListHead( &VolDo->OverflowQueue );

        VolDo->PostedRequestCount = 0;
        KeInitializeSpinLock( &VolDo->OverflowQueueSpinLock );

        //
        //  Let's query for the Toc now and handle any error we get from this operation.
        //

        Status = CdProcessToc( IrpContext,
                               DeviceObjectWeTalkTo,
                               CdromToc,
                               &TocLength,
                               &TocTrackCount,
                               &TocDiskFlags );

        //
        //  If we failed to read the TOC, then bail out.  Probably blank media.
        //

        if (Status != STATUS_SUCCESS)  { 

            try_leave( Status ); 
        }

        //
        //  Now before we can initialize the Vcb we need to set up the
        //  device object field in the VPB to point to our new volume device
        //  object.
        //

        Vpb->DeviceObject = (PDEVICE_OBJECT) VolDo;

        //
        //  Initialize the Vcb.  This routine will raise on an allocation
        //  failure.
        //

        CdInitializeVcb( IrpContext,
                         &VolDo->Vcb,
                         DeviceObjectWeTalkTo,
                         Vpb,
                         CdromToc,
                         TocLength,
                         TocTrackCount,
                         TocDiskFlags,
                         BlockFactor,
                         MediaChangeCount );

        //
        //  Show that we initialized the Vcb and can cleanup with the Vcb.
        //

        Vcb = &VolDo->Vcb;
        VolDo = NULL;
        Vpb = NULL;
        CdromToc = NULL;

        //
        //  Store the Vcb in the IrpContext as we didn't have one before.
        //

        IrpContext->Vcb = Vcb;

        CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

        //
        //  Let's reference the Vpb to make sure we are the one to
        //  have the last dereference.
        //

        Vcb->Vpb->ReferenceCount += 1;

        //
        //  Clear the verify bit for the start of mount.
        //

        CdMarkRealDevVerifyOk( Vcb->Vpb->RealDevice);

        if (!FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK))  {
            
            //
            //  Allocate a buffer to read in the volume descriptors.  We allocate a full
            //  page to make sure we don't hit any alignment problems.
            //

            RawIsoVd = FsRtlAllocatePoolWithTag( CdNonPagedPool,
                                                 ROUND_TO_PAGES( SECTOR_SIZE ),
                                                 TAG_VOL_DESC );

            //
            //  Try to find the primary volume descriptor.
            //

            FoundPvd = CdFindPrimaryVd(   IrpContext,
                                          Vcb,
                                          RawIsoVd,
                                          BlockFactor,
                                          TRUE,
                                          FALSE );

            if (!FoundPvd)  {

                //
                //  We failed to find a valid VD in the data track,  but there were also
                //  audio tracks on this disc,  so we'll try to mount it as an audio CD.
                //  Since we're always last in the mount order,  we won't be preventing
                //  any other FS from trying to mount the data track.  However if the 
                //  data track was at the start of the disc,  then we abort,  to avoid
                //  having to filter it from our synthesised directory listing later.  We
                //  already filtered off any data track at the end.
                //

                if (!(TocDiskFlags & CDROM_DISK_AUDIO_TRACK) ||
                     BooleanFlagOn( Vcb->CdromToc->TrackData[0].Control, TOC_DATA_TRACK))  {
                
                    try_leave( Status = STATUS_UNRECOGNIZED_VOLUME);
                }

                SetFlag( Vcb->VcbState, VCB_STATE_AUDIO_DISK | VCB_STATE_CDXA );

                ExFreePool( RawIsoVd );
                RawIsoVd = NULL;
            }
        }
        
        //
        //  Look and see if there is a secondary volume descriptor we want to
        //  use.
        //

        if (FoundPvd) {

            //
            //  Store the primary volume descriptor in the second half of
            //  RawIsoVd.  Then if our search for a secondary fails we can
            //  recover this immediately.
            //

            RtlCopyMemory( Add2Ptr( RawIsoVd, SECTOR_SIZE, PVOID ),
                           RawIsoVd,
                           SECTOR_SIZE );

            //
            //  We have the initial volume descriptor.  Locate a secondary
            //  volume descriptor if present.
            //

            CdFindActiveVolDescriptor( IrpContext,
                                       Vcb,
                                       RawIsoVd,
                                       FALSE);
        }

        //
        //  Check if this is a remount operation.  If so then clean up
        //  the data structures passed in and created here.
        //

        if (CdIsRemount( IrpContext, Vcb, &OldVcb )) {

            KIRQL SavedIrql;

            ASSERT( NULL != OldVcb->SwapVpb );

            //
            //  Link the old Vcb to point to the new device object that we
            //  should be talking to, dereferencing the previous.  Call a 
            //  nonpaged routine to do this since we take the Vpb spinlock.
            //

            CdReMountOldVcb( IrpContext, 
                             OldVcb, 
                             Vcb, 
                             DeviceObjectWeTalkTo);

            //
            //  See if we will need to provide notification of the remount.  This is the readonly
            //  filesystem's form of dismount/mount notification - we promise that whenever a
            //  volume is "dismounted", that a mount notification will occur when it is revalidated.
            //  Note that we do not send mount on normal remounts - that would duplicate the media
            //  arrival notification of the device driver.
            //
    
            if (FlagOn( OldVcb->VcbState, VCB_STATE_NOTIFY_REMOUNT )) {
    
                ClearFlag( OldVcb->VcbState, VCB_STATE_NOTIFY_REMOUNT );
                
                FileObjectToNotify = OldVcb->RootIndexFcb->FileObject;
                ObReferenceObject( FileObjectToNotify );
            }
            
            try_leave( Status = STATUS_SUCCESS );
        }

        //
        //  This is a new mount.  Go ahead and initialize the
        //  Vcb from the volume descriptor.
        //

        CdUpdateVcbFromVolDescriptor( IrpContext,
                                      Vcb,
                                      RawIsoVd );

        //
        //  Drop an extra reference on the root dir file so we'll be able to send
        //  notification.
        //

        if (Vcb->RootIndexFcb) {

            FileObjectToNotify = Vcb->RootIndexFcb->FileObject;
            ObReferenceObject( FileObjectToNotify );
        }

        //
        //  Now check the maximum transfer limits on the device in case we
        //  get raw reads on this volume.
        //

        Status = CdPerformDevIoCtrl( IrpContext,
                                     IOCTL_SCSI_GET_CAPABILITIES,
                                     DeviceObjectWeTalkTo,
                                     &Capabilities,
                                     sizeof( IO_SCSI_CAPABILITIES ),
                                     FALSE,
                                     TRUE,
                                     NULL );

        if (NT_SUCCESS(Status)) {

            Vcb->MaximumTransferRawSectors = Capabilities.MaximumTransferLength / RAW_SECTOR_SIZE;
            Vcb->MaximumPhysicalPages = Capabilities.MaximumPhysicalPages;

        } else {

            //
            //  This should never happen, but we can safely assume 64k and 16 pages.
            //

            Vcb->MaximumTransferRawSectors = (64 * 1024) / RAW_SECTOR_SIZE;
            Vcb->MaximumPhysicalPages = 16;
        }

        //
        //  The new mount is complete.  Remove the additional references on this
        //  Vcb and the device we are mounted on top of.
        //

        Vcb->VcbReference -= CDFS_RESIDUAL_REFERENCE;
        ASSERT( Vcb->VcbReference == CDFS_RESIDUAL_REFERENCE );

        ObDereferenceObject( Vcb->TargetDeviceObject );

        CdUpdateVcbCondition( Vcb, VcbMounted);

        CdReleaseVcb( IrpContext, Vcb );
        Vcb = NULL;

        Status = STATUS_SUCCESS;

    } finally {

        //
        //  Free the TOC buffer if not in the Vcb.
        //

        if (CdromToc != NULL) {

            ExFreePool( CdromToc );
        }

        //
        //  Free the sector buffer if allocated.
        //

        if (RawIsoVd != NULL) {

            ExFreePool( RawIsoVd );
        }

        //
        //  If we are not mounting the device,  then set the verify bit again.
        //
        
        if ((AbnormalTermination() || (Status != STATUS_SUCCESS)) && 
            SetDoVerifyOnFail)  {

            CdMarkRealDevForVerify( IrpContext->RealDevice);
        }

        //
        //  If we didn't complete the mount then cleanup any remaining structures.
        //

        if (Vpb != NULL) { Vpb->DeviceObject = NULL; }

        if (Vcb != NULL) {

            //
            //  Make sure there is no Vcb in the IrpContext since it could go away
            //

            IrpContext->Vcb = NULL;

            Vcb->VcbReference -= CDFS_RESIDUAL_REFERENCE;

            if (CdDismountVcb( IrpContext, Vcb )) {

                CdReleaseVcb( IrpContext, Vcb );
            }

        } else if (VolDo != NULL) {

            IoDeleteDevice( (PDEVICE_OBJECT) VolDo );
        }

        //
        //  Release the global resource.
        //

        CdReleaseCdData( IrpContext );
    }

    //
    //  Now send mount notification.
    //
    
    if (FileObjectToNotify) {

        FsRtlNotifyVolumeEvent( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( FileObjectToNotify );
    }

    //
    //  Complete the request if no exception.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the verify volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PVPB Vpb = IrpSp->Parameters.VerifyVolume.Vpb;
    PVCB Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->Parameters.VerifyVolume.DeviceObject)->Vcb;

    PCHAR RawIsoVd = NULL;

    PCDROM_TOC CdromToc = NULL;
    ULONG TocLength = 0;
    ULONG TocTrackCount = 0;
    ULONG TocDiskFlags = 0;

    ULONG MediaChangeCount = Vcb->MediaChangeCount;

    PFILE_OBJECT FileObjectToNotify = NULL;

    BOOLEAN ReturnError;
    BOOLEAN ReleaseVcb;

    IO_STATUS_BLOCK Iosb;

    STRING AnsiLabel;
    UNICODE_STRING UnicodeLabel;

    WCHAR VolumeLabel[ VOLUME_ID_LENGTH ];
    ULONG VolumeLabelLength;

    ULONG Index;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  We check that we are talking to a Cdrom device.
    //

    ASSERT( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM );
    ASSERT( FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

    //
    //  Update the real device in the IrpContext from the Vpb.  There was no available
    //  file object when the IrpContext was created.
    //

    IrpContext->RealDevice = Vpb->RealDevice;

    //
    //  Acquire the global resource to synchronise against mounts and teardown,
    //  finally clause releases.
    //

    CdAcquireCdData( IrpContext );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    ReleaseVcb = TRUE;

    try {

        //
        //  Verify that there is a disk here.
        //

        Status = CdPerformDevIoCtrl( IrpContext,
                                     IOCTL_CDROM_CHECK_VERIFY,
                                     Vcb->TargetDeviceObject,
                                     &MediaChangeCount,
                                     sizeof(ULONG),
                                     FALSE,
                                     TRUE,
                                     &Iosb );

        if (!NT_SUCCESS( Status )) {

            //
            //  If we will allow a raw mount then return WRONG_VOLUME to
            //  allow the volume to be mounted by raw.
            //

            if (FlagOn( IrpSp->Flags, SL_ALLOW_RAW_MOUNT )) {

                Status = STATUS_WRONG_VOLUME;
            }

            try_return( Status );
        }
        
        if (Iosb.Information != sizeof(ULONG)) {

            //
            //  Be safe about the count in case the driver didn't fill it in
            //

            MediaChangeCount = 0;
        }

        //
        //  Verify that the device actually saw a change. If the driver does not
        //  support the MCC, then we must verify the volume in any case.
        //

        if (MediaChangeCount == 0 ||
            (Vcb->MediaChangeCount != MediaChangeCount)) {

            //
            //  Allocate a buffer to query the TOC.
            //

            CdromToc = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                 sizeof( CDROM_TOC ),
                                                 TAG_CDROM_TOC );

            RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

            //
            //  Let's query for the Toc now and handle any error we get from this operation.
            //

            Status = CdProcessToc( IrpContext,
                                   Vcb->TargetDeviceObject,
                                   CdromToc,
                                   &TocLength,
                                   &TocTrackCount,
                                   &TocDiskFlags );

            //
            //  If we failed to read the TOC,  then give up now.  Drives will fail
            //  a TOC read on,  for example,  erased CD-RW media.
            //

            if (Status != STATUS_SUCCESS) {

                //
                //  For any errors other than no media and not ready,  commute the
                //  status to ensure that the current VPB is kicked off the device
                //  below - there is probably blank media in the drive,  since we got
                //  further than the check verify.
                //

                if (!CdIsRawDevice( IrpContext, Status )) {

                    Status = STATUS_WRONG_VOLUME;
                }

                try_return( Status );

            //
            //  We got a TOC.  Verify that it matches the previous Toc.
            //

            } else if ((Vcb->TocLength != TocLength) ||
                       (Vcb->TrackCount != TocTrackCount) ||
                       (Vcb->DiskFlags != TocDiskFlags) ||
                       !RtlEqualMemory( CdromToc,
                                        Vcb->CdromToc,
                                        TocLength )) {

                try_return( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  If the disk to verify is an audio disk then we already have a
            //  match.  Otherwise we need to check the volume descriptor.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK )) {

                //
                //  Allocate a buffer for the sector buffer.
                //

                RawIsoVd = FsRtlAllocatePoolWithTag( CdNonPagedPool,
                                                     ROUND_TO_PAGES( 2 * SECTOR_SIZE ),
                                                     TAG_VOL_DESC );

                //
                //  Read the primary volume descriptor for this volume.  If we
                //  get an io error and this verify was a the result of DASD open,
                //  commute the Io error to STATUS_WRONG_VOLUME.  Note that if we currently
                //  expect a music disk then this request should fail.
                //

                ReturnError = FALSE;

                if (FlagOn( IrpSp->Flags, SL_ALLOW_RAW_MOUNT )) {

                    ReturnError = TRUE;
                }

                if (!CdFindPrimaryVd( IrpContext,
                                      Vcb,
                                      RawIsoVd,
                                      Vcb->BlockFactor,
                                      ReturnError,
                                      TRUE )) {

                    //
                    //  If the previous Vcb did not represent a raw disk
                    //  then show this volume was dismounted.
                    //

                    try_return( Status = STATUS_WRONG_VOLUME );

                } 
                else {

                    //
                    //  Look for a supplementary VD.
                    //
                    //  Store the primary volume descriptor in the second half of
                    //  RawIsoVd.  Then if our search for a secondary fails we can
                    //  recover this immediately.
                    //

                    RtlCopyMemory( Add2Ptr( RawIsoVd, SECTOR_SIZE, PVOID ),
                                   RawIsoVd,
                                   SECTOR_SIZE );

                    //
                    //  We have the initial volume descriptor.  Locate a secondary
                    //  volume descriptor if present.
                    //

                    CdFindActiveVolDescriptor( IrpContext,
                                               Vcb,
                                               RawIsoVd,
                                               TRUE);
                    //
                    //  Compare the serial numbers.  If they don't match, set the
                    //  status to wrong volume.
                    //

                    if (Vpb->SerialNumber != CdSerial32( RawIsoVd, SECTOR_SIZE )) {

                        try_return( Status = STATUS_WRONG_VOLUME );
                    }

                    //
                    //  Verify the volume labels.
                    //

                    if (!FlagOn( Vcb->VcbState, VCB_STATE_JOLIET )) {

                        //
                        //  Compute the length of the volume name
                        //

                        AnsiLabel.Buffer = CdRvdVolId( RawIsoVd, Vcb->VcbState );
                        AnsiLabel.MaximumLength = AnsiLabel.Length = VOLUME_ID_LENGTH;

                        UnicodeLabel.MaximumLength = VOLUME_ID_LENGTH * sizeof( WCHAR );
                        UnicodeLabel.Buffer = VolumeLabel;

                        //
                        //  Convert this to unicode.  If we get any error then use a name
                        //  length of zero.
                        //

                        VolumeLabelLength = 0;

                        if (NT_SUCCESS( RtlOemStringToCountedUnicodeString( &UnicodeLabel,
                                                                            &AnsiLabel,
                                                                            FALSE ))) {

                            VolumeLabelLength = UnicodeLabel.Length;
                        }

                    //
                    //  We need to convert from big-endian to little endian.
                    //

                    } else {

                        CdConvertBigToLittleEndian( IrpContext,
                                                    CdRvdVolId( RawIsoVd, Vcb->VcbState ),
                                                    VOLUME_ID_LENGTH,
                                                    (PCHAR) VolumeLabel );

                        VolumeLabelLength = VOLUME_ID_LENGTH;
                    }

                    //
                    //  Strip the trailing spaces or zeroes from the name.
                    //

                    Index = VolumeLabelLength / sizeof( WCHAR );

                    while (Index > 0) {

                        if ((VolumeLabel[ Index - 1 ] != L'\0') &&
                            (VolumeLabel[ Index - 1 ] != L' ')) {

                            break;
                        }

                        Index -= 1;
                    }

                    //
                    //  Now set the final length for the name.
                    //

                    VolumeLabelLength = (USHORT) (Index * sizeof( WCHAR ));

                    //
                    //  Now check that the label matches.
                    //
                    if ((Vpb->VolumeLabelLength != VolumeLabelLength) ||
                        !RtlEqualMemory( Vpb->VolumeLabel,
                                         VolumeLabel,
                                         VolumeLabelLength )) {

                        try_return( Status = STATUS_WRONG_VOLUME );
                    }
                }
            }
        }

        //
        //  The volume is OK, clear the verify bit.
        //

        CdUpdateVcbCondition( Vcb, VcbMounted);

        CdMarkRealDevVerifyOk( Vpb->RealDevice);

        //
        //  See if we will need to provide notification of the remount.  This is the readonly
        //  filesystem's form of dismount/mount notification.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_NOTIFY_REMOUNT )) {

            ClearFlag( Vcb->VcbState, VCB_STATE_NOTIFY_REMOUNT );
            
            FileObjectToNotify = Vcb->RootIndexFcb->FileObject;
            ObReferenceObject( FileObjectToNotify );
        }
        
    try_exit: NOTHING;

        //
        //  Update the media change count to note that we have verified the volume
        //  at this value - regardless of the outcome.
        //

        CdUpdateMediaChangeCount( Vcb, MediaChangeCount);

        //
        //  If we got the wrong volume then free any remaining XA sector in
        //  the current Vcb.  Also mark the Vcb as not mounted.
        //

        if (Status == STATUS_WRONG_VOLUME) {

            CdUpdateVcbCondition( Vcb, VcbNotMounted);

            if (Vcb->XASector != NULL) {

                ExFreePool( Vcb->XASector );
                Vcb->XASector = 0;
                Vcb->XADiskOffset = 0;
            }

            //
            //  Now, if there are no user handles to the volume, try to spark
            //  teardown by purging the volume.
            //

            if (Vcb->VcbCleanup == 0) {

                if (NT_SUCCESS( CdPurgeVolume( IrpContext, Vcb, FALSE ))) {
                    
                    ReleaseVcb = CdCheckForDismount( IrpContext, Vcb, FALSE );
                }
            }
        }

    } finally {

        //
        //  Free the TOC buffer if allocated.
        //

        if (CdromToc != NULL) {

            ExFreePool( CdromToc );
        }

        if (RawIsoVd != NULL) {

            ExFreePool( RawIsoVd );
        }

        if (ReleaseVcb) {
            
            CdReleaseVcb( IrpContext, Vcb );
        }

        CdReleaseCdData( IrpContext );
    }

    //
    //  Now send mount notification.
    //
    
    if (FileObjectToNotify) {

        FsRtlNotifyVolumeEvent( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( FileObjectToNotify );
    }
    
    //
    //  Complete the request if no exception.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine to handle oplock requests made via the
    NtFsControlFile call.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb;
    PCCB Ccb;

    ULONG OplockCount = 0;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  We only permit oplock requests on files.
    //

    if (CdDecodeFileObject( IrpContext,
                            IrpSp->FileObject,
                            &Fcb,
                            &Ccb ) != UserFileOpen ) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make this a waitable Irpcontext so we don't fail to acquire
    //  the resources.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

    //
    //  Switch on the function control code.  We grab the Fcb exclusively
    //  for oplock requests, shared for oplock break acknowledgement.
    //

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1 :
    case FSCTL_REQUEST_OPLOCK_LEVEL_2 :
    case FSCTL_REQUEST_BATCH_OPLOCK :
    case FSCTL_REQUEST_FILTER_OPLOCK :

        CdAcquireFcbExclusive( IrpContext, Fcb, FALSE );

        if (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {

            if (Fcb->FileLock != NULL) {

                OplockCount = (ULONG) FsRtlAreThereCurrentFileLocks( Fcb->FileLock );
            }

        } else {

            OplockCount = Fcb->FcbCleanup;
        }

        break;

    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        CdAcquireFcbShared( IrpContext, Fcb, FALSE );
        break;

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Use a try finally to free the Fcb.
    //

    try {

        //
        //  Verify the Fcb.
        //

        CdVerifyFcbOperation( IrpContext, Fcb );

        //
        //  Call the FsRtl routine to grant/acknowledge oplock.
        //

        Status = FsRtlOplockFsctrl( &Fcb->Oplock,
                                    Irp,
                                    OplockCount );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        CdLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
        CdUnlockFcb( IrpContext, Fcb );

        //
        //  The oplock package will complete the Irp.
        //

        Irp = NULL;

    } finally {

        //
        //  Release all of our resources
        //

        CdReleaseFcb( IrpContext, Fcb );
    }

    //
    //  Complete the request if there was no exception.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Send our notification so that folks that like to hold handles on
    //  volumes can get out of the way.
    //

    FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK );

    //
    //  Acquire exclusive access to the Vcb.
    //

    Vcb = Fcb->Vcb;
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    try {

        //
        //  Verify the Vcb.
        //

        CdVerifyVcb( IrpContext, Vcb );

        Status = CdLockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );

    } finally {

        //
        //  Release the Vcb.
        //

        CdReleaseVcb( IrpContext, Vcb );
        
        if (AbnormalTermination() || !NT_SUCCESS( Status )) {

            FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }
    }

    //
    //  Complete the request if there haven't been any exceptions.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen ) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Vcb.
    //

    Vcb = Fcb->Vcb;

    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  We won't check for a valid Vcb for this request.  An unlock will always
    //  succeed on a locked volume.
    //

    Status = CdUnlockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );

    //
    //  Release all of our resources
    //

    CdReleaseVcb( IrpContext, Vcb );

    //
    //  Send notification that the volume is avaliable.
    //

    if (NT_SUCCESS( Status )) {

        FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_UNLOCK );
    }

    //
    //  Complete the request if there haven't been any exceptions.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}



//
//  Local support routine
//

NTSTATUS
CdDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the dismount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.  We only dismount a volume which
    has been locked.  The intent here is that someone has locked the volume (they are the
    only remaining handle).  We set the verify bit here and the user will close his handle.
    We will dismount a volume with no user's handles in the verify path.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    if (CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen ) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Vcb,  and take the global resource to
    //  sync. against mounts,  verifies etc.
    //

    Vcb = Fcb->Vcb;

    CdAcquireCdData( IrpContext );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Mark the volume as needs to be verified, but only do it if
    //  the vcb is locked by this handle and the volume is currently mounted.
    //

    if (Vcb->VcbCondition != VcbMounted) {

        Status = STATUS_VOLUME_DISMOUNTED;

    } else {

        //
        //  Invalidate the volume right now.
        //
        //  The intent here is to make every subsequent operation
        //  on the volume fail and grease the rails toward dismount.
        //  By definition there is no going back from a SURPRISE.
        //
            
        CdLockVcb( IrpContext, Vcb );
        
        if (Vcb->VcbCondition != VcbDismountInProgress) {
        
            CdUpdateVcbCondition( Vcb, VcbInvalid);
        }
        
        CdUnlockVcb( IrpContext, Vcb );

        //
        //  Set flag to tell the close path that we want to force dismount
        //  the volume when this handle is closed.
        //
        
        SetFlag( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE);
        
        Status = STATUS_SUCCESS;
    }

    //
    //  Release all of our resources
    //

    CdReleaseVcb( IrpContext, Vcb );
    CdReleaseCdData( IrpContext);

    //
    //  Complete the request if there haven't been any exceptions.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

CdIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently dirty.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PULONG VolumeState;
    
    //
    //  Get the current stack location and extract the output
    //  buffer information.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        VolumeState = Irp->AssociatedIrp.SystemBuffer;

    } else {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the volume isn't dirty.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ULONG)) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *VolumeState = 0;

    //
    //  Decode the file object
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    if (TypeOfOpen != UserVolumeOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (Fcb->Vcb->VcbCondition != VcbMounted) {

        CdCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Now set up to return the clean state.  CDs obviously can never be dirty
    //  but we want to make sure we have enforced the full semantics of this call.
    //
    
    Irp->IoStatus.Information = sizeof( ULONG );

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently mounted.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object.
    //

    CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    if (Fcb != NULL) {

        //
        //  Disable PopUps, we want to return any error.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS );

        //
        //  Verify the Vcb.  This will raise in the error condition.
        //

        CdVerifyVcb( IrpContext, Fcb->Vcb );
    }

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if pathname is a valid CDFS pathname.
    We always succeed this request.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    None

--*/

{
    PAGED_CODE();

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdInvalidateVolumes (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine searches for all the volumes mounted on the same real device
    of the current DASD handle, and marks them all bad.  The only operation
    that can be done on such handles is cleanup and close.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    KIRQL SavedIrql;

    LUID TcbPrivilege = {SE_TCB_PRIVILEGE, 0};

    HANDLE Handle;

    PVCB Vcb;

    PLIST_ENTRY Links;

    PFILE_OBJECT FileToMarkBad;
    PDEVICE_OBJECT DeviceToMarkBad;

    //
    //  Check for the correct security access.
    //  The caller must have the SeTcbPrivilege.
    //

    if (!SeSinglePrivilegeCheck( TcbPrivilege, Irp->RequestorMode )) {

        CdCompleteRequest( IrpContext, Irp, STATUS_PRIVILEGE_NOT_HELD );

        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  Try to get a pointer to the device object from the handle passed in.
    //

#if defined(_WIN64)
    if (IoIs32bitProcess( Irp )) {
        
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof( UINT32 )) {

            CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        Handle = (HANDLE) LongToHandle( *((PUINT32) Irp->AssociatedIrp.SystemBuffer) );
    
    } else {
#endif
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof( HANDLE )) {

            CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }
        Handle = *((PHANDLE) Irp->AssociatedIrp.SystemBuffer);
#if defined(_WIN64)
    }
#endif

    Status = ObReferenceObjectByHandle( Handle,
                                        0,
                                        *IoFileObjectType,
                                        KernelMode,
                                        &FileToMarkBad,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Grab the DeviceObject from the FileObject.
    //

    DeviceToMarkBad = FileToMarkBad->DeviceObject;

    //
    //  We only needed the device object involved, not a reference to the file.
    //

    ObDereferenceObject( FileToMarkBad );

    //
    //  Make sure this request can wait.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

    //
    //  Synchronise with pnp/mount/verify paths.
    //
    
    CdAcquireCdData( IrpContext );

    //
    //  Nothing can go wrong now.
    //

    //
    //  Now walk through all the mounted Vcb's looking for candidates to
    //  mark invalid.
    //
    //  On volumes we mark invalid, check for dismount possibility (which is
    //  why we have to get the next link so early).
    //

    Links = CdData.VcbQueue.Flink;

    while (Links != &CdData.VcbQueue) {

        Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks);

        Links = Links->Flink;

        //
        //  If we get a match, mark the volume Bad, and also check to
        //  see if the volume should go away.
        //

        CdLockVcb( IrpContext, Vcb );

        if (Vcb->Vpb->RealDevice == DeviceToMarkBad) {

            //
            //  Take the VPB spinlock,  and look to see if this volume is the 
            //  one currently mounted on the actual device.  If it is,  pull it 
            //  off immediately.
            //
            
            IoAcquireVpbSpinLock( &SavedIrql );

            if (DeviceToMarkBad->Vpb == Vcb->Vpb)  {
            
                PVPB NewVpb = Vcb->SwapVpb;

                ASSERT( FlagOn( Vcb->Vpb->Flags, VPB_MOUNTED));
                ASSERT( NULL != NewVpb);

                RtlZeroMemory( NewVpb, sizeof( VPB ) );

                NewVpb->Type = IO_TYPE_VPB;
                NewVpb->Size = sizeof( VPB );
                NewVpb->RealDevice = DeviceToMarkBad;
                NewVpb->Flags = FlagOn( DeviceToMarkBad->Vpb->Flags, VPB_REMOVE_PENDING );

                DeviceToMarkBad->Vpb = NewVpb;
                Vcb->SwapVpb = NULL;
            }

            IoReleaseVpbSpinLock( SavedIrql );

            if (Vcb->VcbCondition != VcbDismountInProgress) {
                
                CdUpdateVcbCondition( Vcb, VcbInvalid);
            }

            CdUnlockVcb( IrpContext, Vcb );

            CdPurgeVolume( IrpContext, Vcb, FALSE );

            CdCheckForDismount( IrpContext, Vcb, FALSE );

        } else {

            CdUnlockVcb( IrpContext, Vcb );
        }
    }

    CdReleaseCdData( IrpContext );

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

VOID
CdScanForDismountedVcb (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine walks through the list of Vcb's looking for any which may
    now be deleted.  They may have been left on the list because there were
    outstanding references.

Arguments:

Return Value:

    None

--*/

{
    PVCB Vcb;
    PLIST_ENTRY Links;

    PAGED_CODE();

    //
    //  Walk through all of the Vcb's attached to the global data.
    //

    Links = CdData.VcbQueue.Flink;

    while (Links != &CdData.VcbQueue) {

        Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks );

        //
        //  Move to the next link now since the current Vcb may be deleted.
        //

        Links = Links->Flink;

        //
        //  If dismount is already underway then check if this Vcb can
        //  go away.
        //

        if ((Vcb->VcbCondition == VcbDismountInProgress) ||
            (Vcb->VcbCondition == VcbInvalid) ||
            ((Vcb->VcbCondition == VcbNotMounted) && (Vcb->VcbReference <= CDFS_RESIDUAL_REFERENCE))) {

            CdCheckForDismount( IrpContext, Vcb, FALSE );
        }
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
CdFindPrimaryVd (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PCHAR RawIsoVd,
    IN ULONG BlockFactor,
    IN BOOLEAN ReturnOnError,
    IN BOOLEAN VerifyVolume
    )

/*++

Routine Description:

    This routine is called to walk through the volume descriptors looking
    for a primary volume descriptor.  When/if a primary is found a 32-bit
    serial number is generated and stored into the Vpb.  We also store the
    location of the primary volume descriptor in the Vcb.

Arguments:

    Vcb - Pointer to the VCB for the volume.

    RawIsoVd - Pointer to a sector buffer which will contain the primary
               volume descriptor on exit, if successful.

    BlockFactor - Block factor used by the current device for the TableOfContents.

    ReturnOnError - Indicates that we should raise on I/O errors rather than
        returning a FALSE value.

    VerifyVolume - Indicates if we were called from the verify path.  We
        do a few things different in this path.  We don't update the Vcb in
        the verify path.

Return Value:

    BOOLEAN - TRUE if a valid primary volume descriptor found, FALSE
              otherwise.

--*/

{
    NTSTATUS Status;
    ULONG ThisPass = 1;
    BOOLEAN FoundVd = FALSE;

    ULONG BaseSector;
    ULONG SectorOffset;

    PCDROM_TOC CdromToc;

    ULONG VolumeFlags;

    PAGED_CODE();

    //
    //  If there are no data tracks, don't even bother hunting for descriptors.
    //
    //  This explicitly breaks various non-BlueBook compliant CDs that scribble
    //  an ISO filesystem on media claiming only audio tracks.  Since these
    //  disks can cause serious problems in some CDROM units, fail fast.  I admit
    //  that it is possible that someone can still record the descriptors in the
    //  audio track, record a data track (but fail to record descriptors there)
    //  and still have the disk work.  As this form of error worked in NT 4.0, and
    //  since these disks really do exist, I don't want to change them.
    //
    //  If we wished to support all such media (we don't), it would be neccesary
    //  to clear this flag on finding ISO or HSG descriptors below.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_AUDIO_DISK)) {

        return FALSE;
    }
    
    //
    //  We will make at most two passes through the volume descriptor sequence.
    //
    //  On the first pass we will query for the last session.  Using this
    //  as a starting offset we will attempt to mount the volume.  On any failure
    //  we will go to the second pass and try without using any multi-session
    //  information.
    //
    //  On the second pass we will start offset from sector zero.
    //

    while (!FoundVd && (ThisPass <= 2)) {

        //
        //  If we aren't at pass 1 then we start at sector 0.  Otherwise we
        //  try to look up the multi-session information.
        //

        BaseSector = 0;

        if (ThisPass == 1) {

            CdromToc = NULL;

            //
            //  Check for whether this device supports XA and multi-session.
            //

            try {

                //
                //  Allocate a buffer for the last session information.
                //

                CdromToc = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                     sizeof( CDROM_TOC ),
                                                     TAG_CDROM_TOC );

                RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

                //
                //  Query the last session information from the driver.
                //

                Status = CdPerformDevIoCtrl( IrpContext,
                                             IOCTL_CDROM_GET_LAST_SESSION,
                                             Vcb->TargetDeviceObject,
                                             CdromToc,
                                             sizeof( CDROM_TOC ),
                                             FALSE,
                                             TRUE,
                                             NULL );

                //
                //  Raise an exception if there was an allocation failure.
                //

                if (Status == STATUS_INSUFFICIENT_RESOURCES) {

                    CdRaiseStatus( IrpContext, Status );
                }

                //
                //  We don't handle any errors yet.  We will hit that below
                //  as we try to scan the disk.  If we have last session information
                //  then modify the base sector.
                //

                if (NT_SUCCESS( Status ) &&
                    (CdromToc->FirstTrack != CdromToc->LastTrack)) {

                    PCHAR Source, Dest;
                    ULONG Count;

                    Count = 4;

                    //
                    //  The track address is BigEndian, we need to flip the bytes.
                    //

                    Source = (PUCHAR) &CdromToc->TrackData[0].Address[3];
                    Dest = (PUCHAR) &BaseSector;

                    do {

                        *Dest++ = *Source--;

                    } while (--Count);

                    //
                    //  Now adjust the base sector by the block factor of the
                    //  device.
                    //

                    BaseSector /= BlockFactor;

                //
                //  Make this look like the second pass since we are only using the
                //  first session.  No reason to retry on error.
                //

                } else {

                    ThisPass += 1;
                }

            } finally {

                if (CdromToc != NULL) { ExFreePool( CdromToc ); }
            }
        }

        //
        //  Compute the starting sector offset from the start of the session.
        //

        SectorOffset = FIRST_VD_SECTOR;

        //
        //  Start by assuming we have neither Hsg or Iso volumes.
        //

        VolumeFlags = 0;

        //
        //  Loop until either error encountered, primary volume descriptor is
        //  found or a terminal volume descriptor is found.
        //

        while (TRUE) {

            //
            //  Attempt to read the desired sector. Exit directly if operation
            //  not completed.
            //
            //  If this is pass 1 we will ignore errors in read sectors and just
            //  go to the next pass.
            //

            if (!CdReadSectors( IrpContext,
                                LlBytesFromSectors( BaseSector + SectorOffset ),
                                SECTOR_SIZE,
                                (BOOLEAN) ((ThisPass == 1) || ReturnOnError),
                                RawIsoVd,
                                Vcb->TargetDeviceObject )) {

                break;
            }

            //
            //  Check if either an ISO or HSG volume.
            //

            if (RtlEqualMemory( CdIsoId,
                                CdRvdId( RawIsoVd, VCB_STATE_ISO ),
                                VOL_ID_LEN )) {

                SetFlag( VolumeFlags, VCB_STATE_ISO );

            } else if (RtlEqualMemory( CdHsgId,
                                       CdRvdId( RawIsoVd, VCB_STATE_HSG ),
                                       VOL_ID_LEN )) {

                SetFlag( VolumeFlags, VCB_STATE_HSG );

            //
            //  We have neither so break out of the loop.
            //

            } else {

                 break;
            }

            //
            //  Break out if the version number is incorrect or this is
            //  a terminator.
            //

            if ((CdRvdVersion( RawIsoVd, VolumeFlags ) != VERSION_1) ||
                (CdRvdDescType( RawIsoVd, VolumeFlags ) == VD_TERMINATOR)) {

                break;
            }

            //
            //  If this is a primary volume descriptor then our search is over.
            //

            if (CdRvdDescType( RawIsoVd, VolumeFlags ) == VD_PRIMARY) {

                //
                //  If we are not in the verify path then initialize the
                //  fields in the Vcb with basic information from this
                //  descriptor.
                //

                if (!VerifyVolume) {

                    //
                    //  Set the flag for the volume type.
                    //

                    SetFlag( Vcb->VcbState, VolumeFlags );

                    //
                    //  Store the base sector and sector offset for the
                    //  primary volume descriptor.
                    //

                    Vcb->BaseSector = BaseSector;
                    Vcb->VdSectorOffset = SectorOffset;
                    Vcb->PrimaryVdSectorOffset = SectorOffset;
                }

                FoundVd = TRUE;
                break;
            }

            //
            //  Indicate that we're at the next sector.
            //

            SectorOffset += 1;
        }

        ThisPass += 1;
    }

    return FoundVd;
}


//
//  Local support routine
//

BOOLEAN
CdIsRemount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PVCB *OldVcb
    )
/*++

Routine Description:

    This routine walks through the links of the Vcb chain in the global
    data structure.  The remount condition is met when the following
    conditions are all met:

        If the new Vcb is a device only Mvcb and there is a previous
        device only Mvcb.

        Otherwise following conditions must be matched.

            1 - The 32 serial in the current VPB matches that in a previous
                VPB.

            2 - The volume label in the Vpb matches that in the previous
                Vpb.

            3 - The system pointer to the real device object in the current
                VPB matches that in the same previous VPB.

            4 - Finally the previous Vcb cannot be invalid or have a dismount
                underway.

    If a VPB is found which matches these conditions, then the address of
    the VCB for that VPB is returned via the pointer Vcb.

    Skip over the current Vcb.

Arguments:

    Vcb - This is the Vcb we are checking for a remount.

    OldVcb -  A pointer to the address to store the address for the Vcb
              for the volume if this is a remount.  (This is a pointer to
              a pointer)

Return Value:

    BOOLEAN - TRUE if this is in fact a remount, FALSE otherwise.

--*/

{
    PLIST_ENTRY Link;

    PVPB Vpb = Vcb->Vpb;
    PVPB OldVpb;

    BOOLEAN Remount = FALSE;

    PAGED_CODE();

    //
    //  Check whether we are looking for a device only Mvcb.
    //

    for (Link = CdData.VcbQueue.Flink;
         Link != &CdData.VcbQueue;
         Link = Link->Flink) {

        *OldVcb = CONTAINING_RECORD( Link, VCB, VcbLinks );

        //
        //  Skip ourselves.
        //

        if (Vcb == *OldVcb) { continue; }

        //
        //  Look at the Vpb and state of the previous Vcb.
        //

        OldVpb = (*OldVcb)->Vpb;

        if ((OldVpb != Vpb) &&
            (OldVpb->RealDevice == Vpb->RealDevice) &&
            ((*OldVcb)->VcbCondition == VcbNotMounted)) {

            //
            //  If the current disk is a raw disk then it can match a previous music or
            //  raw disk.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK)) {

                if (FlagOn( (*OldVcb)->VcbState, VCB_STATE_AUDIO_DISK )) {

                    //
                    //  If we have both TOC then fail the remount if the lengths
                    //  are different or they don't match.
                    //

                    if ((Vcb->TocLength != (*OldVcb)->TocLength) ||
                        ((Vcb->TocLength != 0) &&
                         !RtlEqualMemory( Vcb->CdromToc,
                                          (*OldVcb)->CdromToc,
                                          Vcb->TocLength ))) {

                        continue;
                    }

                    Remount = TRUE;
                    break;
                }

            //
            //  The current disk is not a raw disk.  Go ahead and compare
            //  serial numbers and volume label.
            //

            } else if ((OldVpb->SerialNumber == Vpb->SerialNumber) &&
                       (Vpb->VolumeLabelLength == OldVpb->VolumeLabelLength) &&
                       (RtlEqualMemory( OldVpb->VolumeLabel,
                                        Vpb->VolumeLabel,
                                        Vpb->VolumeLabelLength ))) {

                //
                //  Remember the old mvcb.  Then set the return value to
                //  TRUE and break.
                //

                Remount = TRUE;
                break;
            }
        }
    }

    return Remount;
}


//
//  Local support routine
//

VOID
CdFindActiveVolDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PCHAR RawIsoVd,
    IN BOOLEAN VerifyVolume
    )

/*++

Routine Description:

    This routine is called to search for a valid secondary volume descriptor that
    we will support.  Right now we only support Joliet escape sequences for
    the secondary descriptor.

    If we don't find the secondary descriptor then we will reread the primary.

    This routine will update the serial number and volume label in the Vpb.

Arguments:

    Vcb - This is the Vcb for the volume being mounted.

    RawIsoVd - Sector buffer used to read the volume descriptors from the disks, but
               on input should contain the PVD (ISO) in the SECOND 'sector' of the
               buffer.

    VerifyVolume - indicates we are being called by the verify path, and should
                   not modify the Vcb fields.

Return Value:

    None

--*/

{
    BOOLEAN FoundSecondaryVd = FALSE;
    ULONG SectorOffset = FIRST_VD_SECTOR;

    ULONG Length;

    ULONG Index;

    PAGED_CODE();

    //
    //  We only look for secondary volume descriptors on an Iso disk.
    //

    if ((FlagOn( Vcb->VcbState, VCB_STATE_ISO) || VerifyVolume)) {

        //
        //  Scan the volume descriptors from the beginning looking for a valid
        //  secondary or a terminator.
        //

        SectorOffset = FIRST_VD_SECTOR;

        while (TRUE) {

            //
            //  Read the next sector.  We should never have an error in this
            //  path.
            //

            CdReadSectors( IrpContext,
                           LlBytesFromSectors( Vcb->BaseSector + SectorOffset ),
                           SECTOR_SIZE,
                           FALSE,
                           RawIsoVd,
                           Vcb->TargetDeviceObject );

            //
            //  Break out if the version number or standard Id is incorrect.
            //  Also break out if this is a terminator.
            //

            if (!RtlEqualMemory( CdIsoId, CdRvdId( RawIsoVd, VCB_STATE_JOLIET ), VOL_ID_LEN ) ||
                (CdRvdVersion( RawIsoVd, VCB_STATE_JOLIET ) != VERSION_1) ||
                (CdRvdDescType( RawIsoVd, VCB_STATE_JOLIET ) == VD_TERMINATOR)) {

                break;
            }

            //
            //  We have a match if this is a secondary descriptor with a matching
            //  escape sequence.
            //

            if ((CdRvdDescType( RawIsoVd, VCB_STATE_JOLIET ) == VD_SECONDARY) &&
                (RtlEqualMemory( CdRvdEsc( RawIsoVd, VCB_STATE_JOLIET ),
                                 CdJolietEscape[0],
                                 ESC_SEQ_LEN ) ||
                 RtlEqualMemory( CdRvdEsc( RawIsoVd, VCB_STATE_JOLIET ),
                                 CdJolietEscape[1],
                                 ESC_SEQ_LEN ) ||
                 RtlEqualMemory( CdRvdEsc( RawIsoVd, VCB_STATE_JOLIET ),
                                 CdJolietEscape[2],
                                 ESC_SEQ_LEN ))) {

                if (!VerifyVolume)  {
                        
                    //
                    //  Update the Vcb with the new volume descriptor.
                    //

                    ClearFlag( Vcb->VcbState, VCB_STATE_ISO );
                    SetFlag( Vcb->VcbState, VCB_STATE_JOLIET );

                    Vcb->VdSectorOffset = SectorOffset;
                }
                
                FoundSecondaryVd = TRUE;
                break;
            }

            //
            //  Otherwise move on to the next sector.
            //

            SectorOffset += 1;
        }

        //
        //  If we didn't find the secondary then recover the original volume
        //  descriptor stored in the second half of the RawIsoVd.
        //

        if (!FoundSecondaryVd) {

            RtlCopyMemory( RawIsoVd,
                           Add2Ptr( RawIsoVd, SECTOR_SIZE, PVOID ),
                           SECTOR_SIZE );
        }
    }

    //
    //  If we're in the verify path,  our work is done,  since we don't want
    //  to update any Vcb/Vpb values.
    //
    
    if (VerifyVolume)  {

        return;
    }
        
    //
    //  Compute the serial number and volume label from the volume descriptor.
    //

    Vcb->Vpb->SerialNumber = CdSerial32( RawIsoVd, SECTOR_SIZE );

    //
    //  Make sure the CD label will fit in the Vpb.
    //

    ASSERT( VOLUME_ID_LENGTH * sizeof( WCHAR ) <= MAXIMUM_VOLUME_LABEL_LENGTH );

    //
    //  If this is not a Unicode label we must convert it to unicode.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_JOLIET )) {

        //
        //  Convert the label to unicode.  If we get any error then use a name
        //  length of zero.
        //

        Vcb->Vpb->VolumeLabelLength = 0;

        if (NT_SUCCESS( RtlOemToUnicodeN( &Vcb->Vpb->VolumeLabel[0],
                                          MAXIMUM_VOLUME_LABEL_LENGTH,
                                          &Length,
                                          CdRvdVolId( RawIsoVd, Vcb->VcbState ),
                                          VOLUME_ID_LENGTH ))) {

            Vcb->Vpb->VolumeLabelLength = (USHORT) Length;
        }

    //
    //  We need to convert from big-endian to little endian.
    //

    } else {

        CdConvertBigToLittleEndian( IrpContext,
                                    CdRvdVolId( RawIsoVd, Vcb->VcbState ),
                                    VOLUME_ID_LENGTH,
                                    (PCHAR) Vcb->Vpb->VolumeLabel );

        Vcb->Vpb->VolumeLabelLength = VOLUME_ID_LENGTH * sizeof( WCHAR );
    }

    //
    //  Strip the trailing spaces or zeroes from the name.
    //

    Index = Vcb->Vpb->VolumeLabelLength / sizeof( WCHAR );

    while (Index > 0) {

        if ((Vcb->Vpb->VolumeLabel[ Index - 1 ] != L'\0') &&
            (Vcb->Vpb->VolumeLabel[ Index - 1 ] != L' ')) {

            break;
        }

        Index -= 1;
    }

    //
    //  Now set the final length for the name.
    //

    Vcb->Vpb->VolumeLabelLength = (USHORT) (Index * sizeof( WCHAR ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\fspdisp.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the Cdfs
    Fsp

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   02-Jan-1991

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_FSPDISP)


VOID
CdFspDispatch (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:

    IrpContext - IrpContext for a request to process.

Return Value:

    None

--*/

{
    THREAD_CONTEXT ThreadContext;
    NTSTATUS Status;

    PIRP Irp = IrpContext->Irp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVOLUME_DEVICE_OBJECT VolDo = NULL;

    //
    //  If this request has an associated volume device object, remember it.
    //

    if (IrpSp->FileObject != NULL) {

        VolDo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                   VOLUME_DEVICE_OBJECT,
                                   DeviceObject );
    }

    //
    //  Now case on the function code.  For each major function code,
    //  either call the appropriate worker routine.  This routine that
    //  we call is responsible for completing the IRP, and not us.
    //  That way the routine can complete the IRP and then continue
    //  post processing as required.  For example, a read can be
    //  satisfied right away and then read can be done.
    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble.
    //

    while ( TRUE ) {

        //
        //  Set all the flags indicating we are in the Fsp.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FSP_FLAGS );

        FsRtlEnterFileSystem();

        CdSetThreadContext( IrpContext, &ThreadContext );

        while (TRUE) {

            try {

                //
                //  Reinitialize for the next try at completing this
                //  request.
                //

                Status =
                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                //
                //  Initialize the Io status field in the Irp.
                //

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;

                //
                //  Case on the major irp code.
                //

                switch (IrpContext->MajorFunction) {

                case IRP_MJ_CREATE :

                    CdCommonCreate( IrpContext, Irp );
                    break;

                case IRP_MJ_CLOSE :

                    ASSERT( FALSE );
                    break;

                case IRP_MJ_READ :

                    CdCommonRead( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_INFORMATION :

                    CdCommonQueryInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_INFORMATION :

                    CdCommonSetInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_VOLUME_INFORMATION :

                    CdCommonQueryVolInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_DIRECTORY_CONTROL :

                    CdCommonDirControl( IrpContext, Irp );
                    break;

                case IRP_MJ_FILE_SYSTEM_CONTROL :

                    CdCommonFsControl( IrpContext, Irp );
                    break;

                case IRP_MJ_DEVICE_CONTROL :

                    CdCommonDevControl( IrpContext, Irp );
                    break;

                case IRP_MJ_LOCK_CONTROL :

                    CdCommonLockControl( IrpContext, Irp );
                    break;

                case IRP_MJ_CLEANUP :

                    CdCommonCleanup( IrpContext, Irp );
                    break;

                case IRP_MJ_PNP :

                    ASSERT( FALSE );
                    CdCommonPnp( IrpContext, Irp );
                    break;

                default :

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    CdCompleteRequest( IrpContext, Irp, Status );
                }

            } except( CdExceptionFilter( IrpContext, GetExceptionInformation() )) {

                Status = CdProcessException( IrpContext, Irp, GetExceptionCode() );
            }

            //
            //  Break out of the loop if we didn't get CANT_WAIT.
            //

            if (Status != STATUS_CANT_WAIT) { break; }

            //
            //  We are retrying this request.  Cleanup the IrpContext for the retry.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
            CdCleanupIrpContext( IrpContext, FALSE );
        }

        FsRtlExitFileSystem();

        //
        //  If there are any entries on this volume's overflow queue, service
        //  them.
        //

        if (VolDo != NULL) {

            KIRQL SavedIrql;
            PVOID Entry = NULL;

            //
            //  We have a volume device object so see if there is any work
            //  left to do in its overflow queue.
            //

            KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );

            if (VolDo->OverflowQueueCount > 0) {

                //
                //  There is overflow work to do in this volume so we'll
                //  decrement the Overflow count, dequeue the IRP, and release
                //  the Event
                //

                VolDo->OverflowQueueCount -= 1;

                Entry = RemoveHeadList( &VolDo->OverflowQueue );
            }

            KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );

            //
            //  There wasn't an entry, break out of the loop and return to
            //  the Ex Worker thread.
            //

            if (Entry == NULL) { break; }

            //
            //  Extract the IrpContext , Irp, set wait to TRUE, and loop.
            //

            IrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

            Irp = IrpContext->Irp;
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            continue;
        }

        break;
    }

    //
    //  Decrement the PostedRequestCount if there was a volume device object.
    //

    if (VolDo) {

        InterlockedDecrement( &VolDo->PostedRequestCount );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\lockctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the Lock Control routines for Cdfs called
    by the Fsd/Fsp dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_LOCKCTRL)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonLockControl)
#pragma alloc_text(PAGE, CdFastLock)
#pragma alloc_text(PAGE, CdFastUnlockAll)
#pragma alloc_text(PAGE, CdFastUnlockAllByKey)
#pragma alloc_text(PAGE, CdFastUnlockSingle)
#endif


NTSTATUS
CdCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Lock Control called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Extract and decode the type of file object we're being asked to process
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != UserFileOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We check whether we can proceed based on the state of the file oplocks.
    //  This call might post the irp for us.
    //

    Status = FsRtlCheckOplock( &Fcb->Oplock,
                               Irp,
                               IrpContext,
                               CdOplockComplete,
                               NULL );

    //
    //  If we don't get success then the oplock package completed the request.
    //

    if (Status != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Verify the Fcb.
    //

    CdVerifyFcbOperation( IrpContext, Fcb );

    //
    //  If we don't have a file lock, then get one now.
    //

    if (Fcb->FileLock == NULL) { CdCreateFileLock( IrpContext, Fcb, TRUE ); }

    //
    //  Now call the FsRtl routine to do the actual processing of the
    //  Lock request
    //

    Status = FsRtlProcessFileLock( Fcb->FileLock, Irp, NULL );

    //
    //  Set the flag indicating if Fast I/O is possible
    //

    CdLockFcb( IrpContext, Fcb );
    Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
    CdUnlockFcb( IrpContext, Fcb );

    //
    //  Complete the request.
    //

    CdCompleteRequest( IrpContext, NULL, Status );
    return Status;
}


BOOLEAN
CdFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast lock call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    IoStatus - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;

    PFCB Fcb;
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!CdVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    FsRtlEnterFileSystem();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !CdCreateFileLock( NULL, Fcb, FALSE )) {

            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to perform the lock request.
        //

        if (Results = FsRtlFastLock( Fcb->FileLock,
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     ProcessId,
                                     Key,
                                     FailImmediately,
                                     ExclusiveLock,
                                     IoStatus,
                                     NULL,
                                     FALSE )) {

            //
            //  Set the flag indicating if Fast I/O is questionable.  We
            //  only change this flag if the current state is possible.
            //  Retest again after synchronizing on the header.
            //

            if (Fcb->IsFastIoPossible == FastIoIsPossible) {

                CdLockFcb( NULL, Fcb );
                Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
                CdUnlockFcb( NULL, Fcb );
            }
        }

    try_exit:  NOTHING;
    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
CdFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock single call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!CdVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !CdCreateFileLock( NULL, Fcb, FALSE )) {

            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockSingle( Fcb->FileLock,
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  ProcessId,
                                                  Key,
                                                  NULL,
                                                  FALSE );

        //
        //  Set the flag indicating if Fast I/O is possible.  We are
        //  only concerned if there are no longer any filelocks on this
        //  file.
        //

        if (!FsRtlAreThereCurrentFileLocks( Fcb->FileLock ) &&
            (Fcb->IsFastIoPossible != FastIoIsPossible)) {

            CdLockFcb( IrpContext, Fcb );
            Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
            CdUnlockFcb( IrpContext, Fcb );
        }

    try_exit:  NOTHING;
    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
CdFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!CdVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !CdCreateFileLock( NULL, Fcb, FALSE )) {

            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAll( Fcb->FileLock,
                                               FileObject,
                                               ProcessId,
                                               NULL );


        //
        //  Set the flag indicating if Fast I/O is possible
        //

        CdLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
        CdUnlockFcb( IrpContext, Fcb );

    try_exit:  NOTHING;
    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
CdFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all by key call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!CdVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !CdCreateFileLock( NULL, Fcb, FALSE )) {

            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAllByKey( Fcb->FileLock,
                                                    FileObject,
                                                    ProcessId,
                                                    Key,
                                                    NULL );


        //
        //  Set the flag indicating if Fast I/O is possible
        //

        CdLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
        CdUnlockFcb( IrpContext, Fcb );

    try_exit:  NOTHING;
    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\nodetype.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDNODETYPE_
#define _CDNODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

#define CDFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0301)
#define CDFS_NTC_VCB                    ((NODE_TYPE_CODE)0x0302)
#define CDFS_NTC_FCB_PATH_TABLE         ((NODE_TYPE_CODE)0x0303)
#define CDFS_NTC_FCB_INDEX              ((NODE_TYPE_CODE)0x0304)
#define CDFS_NTC_FCB_DATA               ((NODE_TYPE_CODE)0x0305)
#define CDFS_NTC_FCB_NONPAGED           ((NODE_TYPE_CODE)0x0306)
#define CDFS_NTC_CCB                    ((NODE_TYPE_CODE)0x0307)
#define CDFS_NTC_IRP_CONTEXT            ((NODE_TYPE_CODE)0x0308)
#define CDFS_NTC_IRP_CONTEXT_LITE       ((NODE_TYPE_CODE)0x0309)

typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#ifndef NodeType
#define NodeType(P) ((P) != NULL ? (*((PNODE_TYPE_CODE)(P))) : NTC_UNDEFINED)
#endif
#ifndef SafeNodeType
#define SafeNodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))
#endif

//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  CDFS_BUG_CHECK_ values defined below and then use CdBugCheck to bugcheck
//  the system.
//

#define CDFS_BUG_CHECK_ACCHKSUP          (0x00010000)
#define CDFS_BUG_CHECK_ALLOCSUP          (0x00020000)
#define CDFS_BUG_CHECK_CACHESUP          (0x00030000)
#define CDFS_BUG_CHECK_CDDATA            (0x00040000)
#define CDFS_BUG_CHECK_CDINIT            (0x00050000)
#define CDFS_BUG_CHECK_CLEANUP           (0x00060000)
#define CDFS_BUG_CHECK_CLOSE             (0x00070000)
#define CDFS_BUG_CHECK_CREATE            (0x00080000)
#define CDFS_BUG_CHECK_DEVCTRL           (0x00090000)
#define CDFS_BUG_CHECK_DEVIOSUP          (0x000a0000)
#define CDFS_BUG_CHECK_DIRCTRL           (0x000b0000)
#define CDFS_BUG_CHECK_DIRSUP            (0x000c0000)
#define CDFS_BUG_CHECK_FILEINFO          (0x000d0000)
#define CDFS_BUG_CHECK_FILOBSUP          (0x000e0000)
#define CDFS_BUG_CHECK_FSCTRL            (0x000f0000)
#define CDFS_BUG_CHECK_FSPDISP           (0x00100000)
#define CDFS_BUG_CHECK_LOCKCTRL          (0x00110000)
#define CDFS_BUG_CHECK_NAMESUP           (0x00120000)
#define CDFS_BUG_CHECK_PATHSUP           (0x00130000)
#define CDFS_BUG_CHECK_PNP               (0x00140000)
#define CDFS_BUG_CHECK_PREFXSUP          (0x00150000)
#define CDFS_BUG_CHECK_READ              (0x00160000)
#define CDFS_BUG_CHECK_RESRCSUP          (0x00170000)
#define CDFS_BUG_CHECK_STRUCSUP          (0x00180000)
#define CDFS_BUG_CHECK_TIMESUP           (0x00190000)
#define CDFS_BUG_CHECK_VERFYSUP          (0x001a0000)
#define CDFS_BUG_CHECK_VOLINFO           (0x001b0000)
#define CDFS_BUG_CHECK_WORKQUE           (0x001c0000)

#define CdBugCheck(A,B,C) { KeBugCheckEx(CDFS_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\pathsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    PathSup.c

Abstract:

    This module implements the Path Table support routines for Cdfs.

    The path table on a CDROM is a condensed summary of the entire
    directory structure.  It is stored on a number of contiguous sectors
    on the disk.  Each directory on the disk has an entry in the path
    table.  The entries are aligned on USHORT boundaries and MAY span
    sector boundaries.  The entries are stored as a breadth-first search.

    The first entry in the table contains the entry for the root.  The
    next entries will consist of the contents of the root directory.  The
    next entries will consist of the all the directories at the next level
    of the tree.  The children of a given directory will be grouped together.

    The directories are assigned ordinal numbers based on their position in
    the path table.  The root dirctory is assigned ordinal value 1.

    Path table sectors:

      Ordinal     1        2        3             4       5        6
                                         +-----------+
                                         | Spanning  |
                                         | Sectors   |
              +----------------------------+  +------------------------+
              |        |        |        | |  |      |         |       |
      DirName |  \     |   a    |    b   |c|  |   c  |    d    |   e   |
              |        |        |        | |  |      |         |       |
      Parent #|  1     |   1    |    1   | |  |   2  |    2    |   3   |
              +----------------------------+  +------------------------+

    Directory Tree:

                                            \ (root)

                                          /   \
                                         /     \
                                        a       b

                                      /   \       \
                                     /     \       \
                                    c       d       e

    Path Table Entries:

        - Position scan at known offset in the path table.  Path Entry at
            this offset must exist and is known to be valid.  Used when
            scanning for the children of a given directory.

        - Position scan at known offset in the path table.  Path Entry is
            known to start at this location but the bounds must be checked
            for validity.

        - Move to next path entry in the table.

        - Update a common path entry structure with the details of the
            on-disk structure.  This is used to smooth out the differences
            in the on-disk structures.

        - Update the filename in the in-memory path entry with the bytes
            off the disk.  For Joliet disks we will have
            to convert to little endian.  We assume that directories
            don't have version numbers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_PATHSUP)

//
//  Local macros
//

//
//  PRAW_PATH_ENTRY
//  CdRawPathEntry (
//      IN PIRP_CONTEXT IrpContext,
//      IN PPATH_ENUM_CONTEXT PathContext
//      );
//

#define CdRawPathEntry(IC, PC)      \
    Add2Ptr( (PC)->Data, (PC)->DataOffset, PRAW_PATH_ENTRY )

//
//  Local support routines
//

VOID
CdMapPathTableBlock (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG BaseOffset,
    IN OUT PPATH_ENUM_CONTEXT PathContext
    );

BOOLEAN
CdUpdatePathEntryFromRawPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG Ordinal,
    IN BOOLEAN VerifyBounds,
    IN PPATH_ENUM_CONTEXT PathContext,
    OUT PPATH_ENTRY PathEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdFindPathEntry)
#pragma alloc_text(PAGE, CdLookupPathEntry)
#pragma alloc_text(PAGE, CdLookupNextPathEntry)
#pragma alloc_text(PAGE, CdMapPathTableBlock)
#pragma alloc_text(PAGE, CdUpdatePathEntryFromRawPathEntry)
#pragma alloc_text(PAGE, CdUpdatePathEntryName)
#endif


VOID
CdLookupPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG PathEntryOffset,
    IN ULONG Ordinal,
    IN BOOLEAN VerifyBounds,
    IN OUT PCOMPOUND_PATH_ENTRY CompoundPathEntry
    )

/*++

Routine Description:

    This routine is called to initiate a walk through a path table.  We are
    looking for a path table entry at location PathEntryOffset.

Arguments:

    PathEntryOffset - This is our target point in the Path Table.  We know that
        a path entry must begin at this point although we may have to verify
        the bounds.

    Ordinal - Ordinal number for the directory at the PathEntryOffset above.

    VerifyBounds - Indicates whether we need to check the validity of
        this entry.

    CompoundPathEntry - PathEnumeration context and in-memory path entry.  This
        has been initialized outside of this call.

Return Value:

    None.

--*/

{
    PPATH_ENUM_CONTEXT PathContext = &CompoundPathEntry->PathContext;
    LONGLONG CurrentBaseOffset;

    PAGED_CODE();

    //
    //  Compute the starting base and starting path table offset.
    //

    CurrentBaseOffset = SectorTruncate( PathEntryOffset );

    //
    //  Map the next block in the Path Table.
    //

    CdMapPathTableBlock( IrpContext,
                         IrpContext->Vcb->PathTableFcb,
                         CurrentBaseOffset,
                         PathContext );

    //
    //  Set up our current offset into the Path Context.
    //

    PathContext->DataOffset = PathEntryOffset - PathContext->BaseOffset;

    //
    //  Update the in-memory structure for this path entry.
    //

    (VOID) CdUpdatePathEntryFromRawPathEntry( IrpContext,
                                              Ordinal,
                                              VerifyBounds,
                                              &CompoundPathEntry->PathContext,
                                              &CompoundPathEntry->PathEntry );
}


BOOLEAN
CdLookupNextPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PPATH_ENUM_CONTEXT PathContext,
    IN OUT PPATH_ENTRY PathEntry
    )

/*++

Routine Description:

    This routine is called to move to the next path table entry.  We know
    the offset and the length of the current entry.  We start by computing
    the offset of the next entry and determine if it is contained in the
    table.  Then we check to see if we need to move to the next sector in
    the path table.  We always map two sectors at a time so we don't
    have to deal with any path entries which span sectors.  We move to
    the next sector if we are in the second sector of the current mapped
    data block.

    We look up the next entry and update the path entry structure with
    the values out of the raw sector but don't update the CdName structure.

Arguments:

    PathContext - Enumeration context for this scan of the path table.

    PathEntry - In-memory representation of the on-disk path table entry.

Return Value:

    BOOLEAN - TRUE if another entry is found, FALSE otherwise.
        This routine may raise on error.

--*/

{
    LONGLONG CurrentBaseOffset;

    PAGED_CODE();

    //
    //  Get the offset of the next path entry within the current
    //  data block.
    //

    PathContext->DataOffset += PathEntry->PathEntryLength;

    //
    //  If we are in the last data block then check if we are beyond the
    //  end of the file.
    //

    if (PathContext->LastDataBlock) {

        if (PathContext->DataOffset >= PathContext->DataLength) {

            return FALSE;
        }

    //
    //  If we are not in the last data block of the path table and
    //  this offset is in the second sector then move to the next
    //  data block.
    //

    } else if (PathContext->DataOffset >= SECTOR_SIZE) {

        CurrentBaseOffset = PathContext->BaseOffset + SECTOR_SIZE;

        CdMapPathTableBlock( IrpContext,
                             IrpContext->Vcb->PathTableFcb,
                             CurrentBaseOffset,
                             PathContext );

        //
        //  Set up our current offset into the Path Context.
        //

        PathContext->DataOffset -= SECTOR_SIZE;
    }

    //
    //  Now update the path entry with the values from the on-disk
    //  structure.
    //
        
    return CdUpdatePathEntryFromRawPathEntry( IrpContext,
                                              PathEntry->Ordinal + 1,
                                              TRUE,
                                              PathContext,
                                              PathEntry );
}


BOOLEAN
CdFindPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN PCD_NAME DirName,
    IN BOOLEAN IgnoreCase,
    IN OUT PCOMPOUND_PATH_ENTRY CompoundPathEntry
    )

/*++

Routine Description:

    This routine will walk through the path table looking for a matching entry for DirName
    among the child directories of the ParentFcb.

Arguments:

    ParentFcb - This is the directory we are examining.  We know the ordinal and path table
        offset for this directory in the path table.  If this is the first scan for this
        Fcb we will update the first child offset for this directory in the path table.

    DirName - This is the name we are searching for.  This name will not contain wildcard
        characters.  The name will also not have a version string.

    IgnoreCase - Indicates if this search is exact or ignore case.

    CompoundPathEntry - Complete path table enumeration structure.  We will have initialized
        it for the search on entry.  This will be positioned at the matching name if found.

Return Value:

    BOOLEAN - TRUE if matching entry found, FALSE otherwise.

--*/

{
    BOOLEAN Found = FALSE;
    BOOLEAN UpdateChildOffset = TRUE;

    ULONG StartingOffset;
    ULONG StartingOrdinal;

    PAGED_CODE();

    //
    //  Position ourselves at either the first child or at the directory itself.
    //  Lock the Fcb to get this value and remember whether to update with the first
    //  child.
    //

    StartingOffset = CdQueryFidPathTableOffset( ParentFcb->FileId );
    StartingOrdinal = ParentFcb->Ordinal;

	//
	//  ISO 9660 9.4.4 restricts the backpointer from child to parent in a
	//  pathtable entry to 16bits. Although we internally store ordinals
	//  as 32bit values, it is impossible to search for the children of a
	//  directory whose ordinal value is greater than MAXUSHORT. Media that
	//  could induce such a search is illegal.
	//
	//  Note that it is not illegal to have more than MAXUSHORT directories.
	//

	if (ParentFcb->Ordinal > MAXUSHORT) {

		CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
	}

    CdLockFcb( IrpContext, ParentFcb );

    if (ParentFcb->ChildPathTableOffset != 0) {

        StartingOffset = ParentFcb->ChildPathTableOffset;
        StartingOrdinal = ParentFcb->ChildOrdinal;
        UpdateChildOffset = FALSE;

    } else if (ParentFcb == ParentFcb->Vcb->RootIndexFcb) {

        UpdateChildOffset = FALSE;
    }

    CdUnlockFcb( IrpContext, ParentFcb );

    CdLookupPathEntry( IrpContext, StartingOffset, StartingOrdinal, FALSE, CompoundPathEntry );

    //
    //  Loop until we find a match or are beyond the children for this directory.
    //

    do {

        //
        //  If we are beyond this directory then return FALSE.
        //

        if (CompoundPathEntry->PathEntry.ParentOrdinal > ParentFcb->Ordinal) {

            //
            //  Update the Fcb with the offsets for the children in the path table.
            //

            if (UpdateChildOffset) {

                CdLockFcb( IrpContext, ParentFcb );

                ParentFcb->ChildPathTableOffset = StartingOffset;
                ParentFcb->ChildOrdinal = StartingOrdinal;

                CdUnlockFcb( IrpContext, ParentFcb );
            }

            break;
        }

        //
        //  If we are within the children of this directory then check for a match.
        //

        if (CompoundPathEntry->PathEntry.ParentOrdinal == ParentFcb->Ordinal) {

            //
            //  Update the child offset if not yet done.
            //

            if (UpdateChildOffset) {

                CdLockFcb( IrpContext, ParentFcb );

                ParentFcb->ChildPathTableOffset = CompoundPathEntry->PathEntry.PathTableOffset;
                ParentFcb->ChildOrdinal = CompoundPathEntry->PathEntry.Ordinal;

                CdUnlockFcb( IrpContext, ParentFcb );

                UpdateChildOffset = FALSE;
            }

            //
            //  Update the name in the path entry.
            //

            CdUpdatePathEntryName( IrpContext, &CompoundPathEntry->PathEntry, IgnoreCase );

            //
            //  Now compare the names for an exact match.
            //

            if (CdIsNameInExpression( IrpContext,
                                      &CompoundPathEntry->PathEntry.CdCaseDirName,
                                      DirName,
                                      0,
                                      FALSE )) {

                //
                //  Let our caller know we have a match.
                //

                Found = TRUE;
                break;
            }
        }

        //
        //  Go to the next entry in the path table.  Remember the current position
        //  in the event we update the Fcb.
        //

        StartingOffset = CompoundPathEntry->PathEntry.PathTableOffset;
        StartingOrdinal = CompoundPathEntry->PathEntry.Ordinal;

    } while (CdLookupNextPathEntry( IrpContext,
                                    &CompoundPathEntry->PathContext,
                                    &CompoundPathEntry->PathEntry ));

    return Found;
}


//
//  Local support routine
//

VOID
CdMapPathTableBlock (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG BaseOffset,
    IN OUT PPATH_ENUM_CONTEXT PathContext
    )

/*++

Routine Description:

    This routine is called to map (or allocate and copy) the next
    data block in the path table.  We check if the next block will
    span a view boundary and allocate an auxilary buffer in that case.

Arguments:

    Fcb - This is the Fcb for the Path Table.

    BaseOffset - Offset of the first sector to map.  This will be on a
        sector boundary.

    PathContext - Enumeration context to update in this routine.

Return Value:

    None.

--*/

{
    ULONG CurrentLength;
    ULONG SectorSize;
    ULONG DataOffset;
    ULONG PassCount;
    PVOID Sector;

    PAGED_CODE();

    //
    //  Map the new block and set the enumeration context to this
    //  point.  Allocate an auxilary buffer if necessary.
    //

    CurrentLength = 2 * SECTOR_SIZE;

    if (CurrentLength >= (ULONG) (Fcb->FileSize.QuadPart - BaseOffset)) {

        CurrentLength = (ULONG) (Fcb->FileSize.QuadPart - BaseOffset);

        //
        //  We know this is the last data block for this
        //  path table.
        //

        PathContext->LastDataBlock = TRUE;
    }

    //
    //  Set context values.
    //

    PathContext->BaseOffset = (ULONG) BaseOffset;
    PathContext->DataLength = CurrentLength;

    //
    //  Drop the previous sector's mapping
    //

    CdUnpinData( IrpContext, &PathContext->Bcb );

    //
    //  Check if spanning a view section.  The following must
    //  be true before we take this step.
    //
    //      Data length is more than one sector.
    //      Starting offset must be one sector before the
    //          cache manager VACB boundary.
    //

    if ((CurrentLength > SECTOR_SIZE) &&
        (FlagOn( ((ULONG) BaseOffset), VACB_MAPPING_MASK ) == LAST_VACB_SECTOR_OFFSET )) {

        //
        //  Map each sector individually and store into an auxilary
        //  buffer.
        //

        SectorSize = SECTOR_SIZE;
        DataOffset = 0;
        PassCount = 2;

        PathContext->Data = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                      CurrentLength,
                                                      TAG_SPANNING_PATH_TABLE );
        PathContext->AllocatedData = TRUE;

        while (PassCount--) {

            CcMapData( Fcb->FileObject,
                       (PLARGE_INTEGER) &BaseOffset,
                       SectorSize,
                       TRUE,
                       &PathContext->Bcb,
                       &Sector );

            RtlCopyMemory( Add2Ptr( PathContext->Data, DataOffset, PVOID ),
                           Sector,
                           SectorSize );

            CdUnpinData( IrpContext, &PathContext->Bcb );

            BaseOffset += SECTOR_SIZE;
            SectorSize = CurrentLength - SECTOR_SIZE;
            DataOffset = SECTOR_SIZE;
        }

    //
    //  Otherwise we can just map the data into the cache.
    //

    } else {

        //
        //  There is a slight chance that we have allocated an
        //  auxilary buffer on the previous sector.
        //

        if (PathContext->AllocatedData) {

            ExFreePool( PathContext->Data );
            PathContext->AllocatedData = FALSE;
        }

        CcMapData( Fcb->FileObject,
                   (PLARGE_INTEGER) &BaseOffset,
                   CurrentLength,
                   TRUE,
                   &PathContext->Bcb,
                   &PathContext->Data );
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
CdUpdatePathEntryFromRawPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG Ordinal,
    IN BOOLEAN VerifyBounds,
    IN PPATH_ENUM_CONTEXT PathContext,
    OUT PPATH_ENTRY PathEntry
    )

/*++

Routine Description:

    This routine is called to update the in-memory Path Entry from the on-disk
    path entry.  We also do a careful check of the bounds if requested and we
    are in the last data block of the path table.

Arguments:

    Ordinal - Ordinal number for this directory.

    VerifyBounds - Check that the current raw Path Entry actually fits
        within the data block.

    PathContext - Current path table enumeration context.

    PathEntry - Pointer to the in-memory path entry structure.

Return Value:

    TRUE  if updated ok,  
    FALSE if we've hit the end of the pathtable - zero name length && PT size is a multiple
          of blocksize.  This is a workaround for some Video CDs.  Win 9x works around this.

    This routine may raise.

--*/

{
    PRAW_PATH_ENTRY RawPathEntry = CdRawPathEntry( IrpContext, PathContext );
    ULONG RemainingDataLength;

    PAGED_CODE();
    
    //
    //  Check for a name length of zero.  This is the first byte of the record,
    //  and there must be at least one byte remaining in the buffer else we 
    //  wouldn't be here (caller would have spotted buffer end).
    //
    
    PathEntry->DirNameLen = CdRawPathIdLen( IrpContext, RawPathEntry );
    
    if (0 == PathEntry->DirNameLen) {

        //
        //  If we are in the last block,  and the path table size (ie last block) is a 
        //  multiple of block size,  then we will consider this the end of the path table
        //  rather than raising an error.  Workaround for NTI Cd Maker video CDs which
        //  round path table length to blocksize multiple.  In all other cases we consider
        //  a zero length name to be corruption.
        //
        
        if ( PathContext->LastDataBlock && 
             (0 == BlockOffset( IrpContext->Vcb, PathContext->DataLength)))  {
        
            return FALSE;
        }
        
        CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
    }

    //
    //  Check if we should verify the path entry.  If we are not in the last
    //  data block then there is nothing to check.
    //
    
    if (PathContext->LastDataBlock && VerifyBounds) {

        //
        //  Quick check to see if the maximum size is still available.  This
        //  will handle most cases and we don't need to access any of the
        //  fields.
        //

        RemainingDataLength = PathContext->DataLength - PathContext->DataOffset;

        if (RemainingDataLength < sizeof( RAW_PATH_ENTRY )) {

            //
            //  Make sure the remaining bytes hold the path table entries.
            //  Do the following checks.
            //
            //      - A minimal path table entry will fit (and then check)
            //      - This path table entry (with dir name) will fit.
            //

            if ((RemainingDataLength < MIN_RAW_PATH_ENTRY_LEN) ||
                (RemainingDataLength < (ULONG) (CdRawPathIdLen( IrpContext, RawPathEntry ) + MIN_RAW_PATH_ENTRY_LEN - 1))) {

                CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }
        }
    }

    //
    //  The ordinal number of this directory is passed in.
    //  Compute the path table offset of this entry.
    //

    PathEntry->Ordinal = Ordinal;
    PathEntry->PathTableOffset = PathContext->BaseOffset + PathContext->DataOffset;

    //
    //  We know we can safely access all of the fields of the raw path table at
    //  this point.
    
    //
    //  Bias the disk offset by the number of logical blocks
    //

    CopyUchar4( &PathEntry->DiskOffset, CdRawPathLoc( IrpContext, RawPathEntry ));

    PathEntry->DiskOffset += CdRawPathXar( IrpContext, RawPathEntry );

    CopyUchar2( &PathEntry->ParentOrdinal, &RawPathEntry->ParentNum );

    PathEntry->PathEntryLength = PathEntry->DirNameLen + MIN_RAW_PATH_ENTRY_LEN - 1;

    //
    //  Align the path entry length on a ushort boundary.
    //

    PathEntry->PathEntryLength = WordAlign( PathEntry->PathEntryLength );

    PathEntry->DirName = RawPathEntry->DirId;

    return TRUE;
}


//
//  Local support routine
//

VOID
CdUpdatePathEntryName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PPATH_ENTRY PathEntry,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine will store the directory name into the CdName in the
    path entry.  If this is a Joliet name then we will make sure we have
    an allocated buffer and need to convert from big endian to little
    endian.  We also correctly update the case name.  If this operation is ignore
    case then we need an auxilary buffer for the name.

    For an Ansi disk we can use the name from the disk for the exact case.  We only
    need to allocate a buffer for the ignore case name.  The on-disk representation of
    a Unicode name is useless for us.  In this case we will need a name buffer for
    both names.  We store a buffer in the PathEntry which can hold two 8.3 unicode
    names.  This means we will almost never need to allocate a buffer in the Ansi case
    (we only need one buffer and already have 48 characters).

Arguments:

    PathEntry - Pointer to a path entry structure.  We have already updated
        this path entry with the values from the raw path entry.

Return Value:

    None.

--*/

{
    ULONG Length;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check if this is a self entry.  We use a fixed string for this.
    //
    //      Self-Entry - Length is 1, value is 0.
    //

    if ((*PathEntry->DirName == 0) &&
        (PathEntry->DirNameLen == 1)) {

        //
        //  There should be no allocated buffers.
        //

        ASSERT( !FlagOn( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER ));

        //
        //  Now use one of the hard coded directory names.
        //

        PathEntry->CdDirName.FileName = CdUnicodeDirectoryNames[0];

        //
        //  Show that there is no version number.
        //

        PathEntry->CdDirName.VersionString.Length = 0;

        //
        //  The case name is identical.
        //

        PathEntry->CdCaseDirName = PathEntry->CdDirName;

        //
        //  Return now.
        //

        return;
    }

    //
    //  Compute how large a buffer we will need.  If this is an ignore
    //  case operation then we will want a double size buffer.  If the disk is not
    //  a Joliet disk then we might need two bytes for each byte in the name.
    //

    Length = PathEntry->DirNameLen;

    if (IgnoreCase) {

        Length *= 2;
    }

    if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        Length *= sizeof( WCHAR );
    }

    //
    //  Now decide if we need to allocate a new buffer.  We will if
    //  this name won't fit in the embedded name buffer and it is
    //  larger than the current allocated buffer.  We always use the
    //  allocated buffer if present.
    //
    //  If we haven't allocated a buffer then use the embedded buffer if the data
    //  will fit.  This is the typical case.
    //

    if (!FlagOn( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER ) &&
        (Length <= sizeof( PathEntry->NameBuffer ))) {

        PathEntry->CdDirName.FileName.MaximumLength = sizeof( PathEntry->NameBuffer );
        PathEntry->CdDirName.FileName.Buffer = PathEntry->NameBuffer;

    } else {

        //
        //  We need to use an allocated buffer.  Check if the current buffer
        //  is large enough.
        //

        if (Length > PathEntry->CdDirName.FileName.MaximumLength) {

            //
            //  Free any allocated buffer.
            //

            if (FlagOn( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER )) {

                ExFreePool( PathEntry->CdDirName.FileName.Buffer );
                ClearFlag( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER );
            }

            PathEntry->CdDirName.FileName.Buffer = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                                             Length,
                                                                             TAG_PATH_ENTRY_NAME );

            SetFlag( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER );

            PathEntry->CdDirName.FileName.MaximumLength = (USHORT) Length;
        }
    }

    //
    //  We now have a buffer for the name.  We need to either convert the on-disk bigendian
    //  to little endian or covert the name to Unicode.
    //

    if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        Status = RtlOemToUnicodeN( PathEntry->CdDirName.FileName.Buffer,
                                   PathEntry->CdDirName.FileName.MaximumLength,
                                   &Length,
                                   PathEntry->DirName,
                                   PathEntry->DirNameLen );

        ASSERT( Status == STATUS_SUCCESS );
        PathEntry->CdDirName.FileName.Length = (USHORT) Length;

    } else {

        //
        //  Convert this string to little endian.
        //

        CdConvertBigToLittleEndian( IrpContext,
                                    PathEntry->DirName,
                                    PathEntry->DirNameLen,
                                    (PCHAR) PathEntry->CdDirName.FileName.Buffer );

        PathEntry->CdDirName.FileName.Length = (USHORT) PathEntry->DirNameLen;
    }

    //
    //  There is no version string.
    //

    PathEntry->CdDirName.VersionString.Length =
    PathEntry->CdCaseDirName.VersionString.Length = 0;

    //
    //  If the name string ends with a period then knock off the last
    //  character.
    //

    if (PathEntry->CdDirName.FileName.Buffer[(PathEntry->CdDirName.FileName.Length - sizeof( WCHAR )) / 2] == L'.') {

        //
        //  Shrink the filename length.
        //

        PathEntry->CdDirName.FileName.Length -= sizeof( WCHAR );
    }

    //
    //  Update the case name buffer if necessary.  If this is an exact case
    //  operation then just copy the exact case string.
    //

    if (IgnoreCase) {

        PathEntry->CdCaseDirName.FileName.Buffer = Add2Ptr( PathEntry->CdDirName.FileName.Buffer,
                                                            PathEntry->CdDirName.FileName.MaximumLength / 2,
                                                            PWCHAR);

        PathEntry->CdCaseDirName.FileName.MaximumLength = PathEntry->CdDirName.FileName.MaximumLength / 2;

        CdUpcaseName( IrpContext,
                      &PathEntry->CdDirName,
                      &PathEntry->CdCaseDirName );

    } else {

        PathEntry->CdCaseDirName = PathEntry->CdDirName;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\namesup.c ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    NameSup.c

Abstract:

    This module implements the Cdfs Name support routines

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_NAMESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdConvertBigToLittleEndian)
#pragma alloc_text(PAGE, CdConvertNameToCdName)
#pragma alloc_text(PAGE, CdDissectName)
#pragma alloc_text(PAGE, CdGenerate8dot3Name)
#pragma alloc_text(PAGE, CdFullCompareNames)
#pragma alloc_text(PAGE, CdIs8dot3Name)
#pragma alloc_text(PAGE, CdIsNameInExpression)
#pragma alloc_text(PAGE, CdShortNameDirentOffset)
#pragma alloc_text(PAGE, CdUpcaseName)
#endif


VOID
CdConvertNameToCdName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PCD_NAME CdName
    )

/*++

Routine Description:

    This routine is called to convert a string of bytes into a CdName.

    The full name is already in the CdName structure in the FileName field.
    We split this into the filename and version strings.

Arguments:

    CdName - Pointer to CdName structure to update.

Return Value:

    None.

--*/

{
    ULONG NameLength = 0;
    PWCHAR CurrentCharacter = CdName->FileName.Buffer;

    PAGED_CODE();

    //
    //  Look for a separator character.
    //

    while ((NameLength < CdName->FileName.Length) &&
           (*CurrentCharacter != L';')) {

        CurrentCharacter += 1;
        NameLength += 2;
    }

    //
    //  If there is at least one more character after a possible separator then it
    //  and all following characters are part of the version string.
    //

    CdName->VersionString.Length = 0;
    if (NameLength + sizeof( WCHAR ) < CdName->FileName.Length) {

        CdName->VersionString.MaximumLength =
        CdName->VersionString.Length = (USHORT) (CdName->FileName.Length - NameLength - sizeof( WCHAR ));
        CdName->VersionString.Buffer = Add2Ptr( CdName->FileName.Buffer,
                                                NameLength + sizeof( WCHAR ),
                                                PWCHAR );
    }

    //
    //  Now update the filename portion of the name.
    //

    CdName->FileName.Length = (USHORT) NameLength;

    return;
}


VOID
CdConvertBigToLittleEndian (
    IN PIRP_CONTEXT IrpContext,
    IN PCHAR BigEndian,
    IN ULONG ByteCount,
    OUT PCHAR LittleEndian
    )

/*++

Routine Description:

    This routine is called to convert a unicode string in big endian to
    little endian.  We start by copying all of the source bytes except
    the first.  This will put the low order bytes in the correct position.
    We then copy each high order byte in its correct position.

Arguments:

    BigEndian - Pointer to the string of big endian characters.

    ByteCount - Number of unicode characters in this string.

    LittleEndian - Pointer to array to store the little endian characters.

Return Value:

    None.

--*/

{
    ULONG RemainingByteCount = ByteCount;

    PCHAR Source = BigEndian;
    PCHAR Destination = LittleEndian;

    PAGED_CODE();

    //
    //  If the byte count isn't an even number then the disk is corrupt.
    //

    if (FlagOn( ByteCount, 1 )) {

        CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
    }

    //
    //  Start by copy the low-order bytes into the correct position.  Do
    //  this by skipping the first byte in the BigEndian string.
    //

    RtlCopyMemory( Destination,
                   Source + 1,
                   RemainingByteCount - 1 );

    //
    //  Now move the high-order bytes into position.
    //

    Destination += 1;

    while (RemainingByteCount != 0) {

        *Destination = *Source;

        Source += 2;
        Destination += 2;

        RemainingByteCount -= 2;
    }

    return;
}


VOID
CdUpcaseName (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_NAME Name,
    IN OUT PCD_NAME UpcaseName
    )

/*++

Routine Description:

    This routine is called to upcase a CdName structure.  We will do both
    the filename and version strings.

Arguments:

    Name - This is the mixed case version of the name.

    UpcaseName - This is the destination for the upcase operation.

Return Value:

    None.  This routine will raise all errors.

--*/

{
    NTSTATUS Status;
    PVOID NewBuffer;

    PAGED_CODE();

    //
    //  If the name structures are different then initialize the different components.
    //

    if (Name != UpcaseName) {

        //
        //  Initialize the version string portion of the name.
        //

        UpcaseName->VersionString.Length = 0;

        if (Name->VersionString.Length != 0) {

            UpcaseName->VersionString.MaximumLength =
            UpcaseName->VersionString.Length = Name->VersionString.Length;

            //
            //  Initially set the buffer to point to where we need to insert
            //  the separator.
            //

            UpcaseName->VersionString.Buffer = Add2Ptr( UpcaseName->FileName.Buffer,
                                                        Name->FileName.Length,
                                                        PWCHAR );

            //
            //  We are currently pointing to the location to store the separator.
            //  Store the ';' and then move to the next character to
            //  copy the data.
            //

            *(UpcaseName->VersionString.Buffer) = L';';

            UpcaseName->VersionString.Buffer += 1;
        }
    }

    //
    //  Upcase the string using the correct upcase routine.
    //

    Status = RtlUpcaseUnicodeString( &UpcaseName->FileName,
                                     &Name->FileName,
                                     FALSE );

    //
    //  This should never fail.
    //

    ASSERT( Status == STATUS_SUCCESS );

    if (Name->VersionString.Length != 0) {

        Status = RtlUpcaseUnicodeString( &UpcaseName->VersionString,
                                         &Name->VersionString,
                                         FALSE );

        //
        //  This should never fail.
        //

        ASSERT( Status == STATUS_SUCCESS );
    }

    return;
}


VOID
CdDissectName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PUNICODE_STRING FinalName
    )

/*++

Routine Description:

    This routine is called to strip off leading components of the name strings.  We search
    for either the end of the string or separating characters.  The input remaining
    name strings should have neither a trailing or leading backslash.

Arguments:

    RemainingName - Remaining name.

    FinalName - Location to store next component of name.

Return Value:

    None.

--*/

{
    ULONG NameLength;
    PWCHAR NextWchar;

    PAGED_CODE();

    //
    //  Find the offset of the next component separators.
    //

    for (NameLength = 0, NextWchar = RemainingName->Buffer;
         (NameLength < RemainingName->Length) && (*NextWchar != L'\\');
         NameLength += sizeof( WCHAR) , NextWchar += 1);

    //
    //  Adjust all the strings by this amount.
    //

    FinalName->Buffer = RemainingName->Buffer;

    FinalName->MaximumLength = FinalName->Length = (USHORT) NameLength;

    //
    //  If this is the last component then set the RemainingName lengths to zero.
    //

    if (NameLength == RemainingName->Length) {

        RemainingName->Length = 0;

    //
    //  Otherwise we adjust the string by this amount plus the separating character.
    //

    } else {

        RemainingName->MaximumLength -= (USHORT) (NameLength + sizeof( WCHAR ));
        RemainingName->Length -= (USHORT) (NameLength + sizeof( WCHAR ));
        RemainingName->Buffer = Add2Ptr( RemainingName->Buffer,
                                         NameLength + sizeof( WCHAR ),
                                         PWCHAR );
    }

    return;
}


BOOLEAN
CdIs8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING FileName
    )

/*++

Routine Description:

    This routine checks if the name follows the 8.3 name conventions.  We check for
    the name length and whether the characters are valid.

Arguments:

    FileName - String of bytes containing the name.

Return Value:

    BOOLEAN - TRUE if this name is a legal 8.3 name, FALSE otherwise.

--*/

{
    CHAR DbcsNameBuffer[ BYTE_COUNT_8_DOT_3 ];
    STRING DbcsName;

    PWCHAR NextWchar;
    ULONG Count;

    ULONG DotCount = 0;
    BOOLEAN LastCharDot = FALSE;

    PAGED_CODE();

    //
    //  The length must be less than 24 bytes.
    //

    ASSERT( FileName.Length != 0 );
    if (FileName.Length > BYTE_COUNT_8_DOT_3) {

        return FALSE;
    }

    //
    //  Walk though and check for a space character.
    //

    NextWchar = FileName.Buffer;
    Count = 0;

    do {

        //
        //  No spaces allowed.
        //

        if (*NextWchar == L' ') { return FALSE; }

        if (*NextWchar == L'.') {

            //
            //  Not an 8.3 name if more than 1 dot or more than 8 characters
            //  remaining.  (It is legal for the dot to be in the ninth
            //  position)
            //

            if ((DotCount > 0) ||
                (Count > 8 * sizeof( WCHAR ))) {

                return FALSE;
            }

            DotCount += 1;
            LastCharDot = TRUE;

        } else {

            LastCharDot = FALSE;
        }

        Count += 2;
        NextWchar += 1;

    } while (Count < FileName.Length);

    //
    //  Go ahead and truncate the dot if at the end.
    //

    if (LastCharDot) {

        FileName.Length -= sizeof( WCHAR );
    }

    //
    //  Create an Oem name to use to check for a valid short name.
    //

    DbcsName.MaximumLength = BYTE_COUNT_8_DOT_3;
    DbcsName.Buffer = DbcsNameBuffer;

    if (!NT_SUCCESS( RtlUnicodeStringToCountedOemString( &DbcsName,
                                                         &FileName,
                                                         FALSE ))) {

        return FALSE;
    }

    //
    //  We have now initialized the Oem string.  Call the FsRtl package to check for a
    //  valid FAT name.
    //

    return FsRtlIsFatDbcsLegal( DbcsName, FALSE, FALSE, FALSE );
}


VOID
CdGenerate8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING FileName,
    IN ULONG DirentOffset,
    OUT PWCHAR ShortFileName,
    OUT PUSHORT ShortByteCount
    )

/*++

Routine Description:

    This routine is called to generate a short name from the given long name.  We will
    generate a short name from the given long name.

    We go through the following steps to make this conversion.

        1 - Generate the generic short name.  This will also be in unicode format.

        2 - Build the string representation of the dirent offset.

        3 - Build the biased short name string by combining the generic short name with
            the dirent offset string.

        4 - Copy the final unicode string back to our caller's buffer.

Arguments:

    FileName - String of bytes containing the name.

    DirentOffset - Offset in the directory for this filename.  We incorporate the offset into
        the short name by dividing this by 32 and prepending a tilde character to the
        digit character.  We then append this to the base of the generated short name.

    ShortFileName - Pointer to the buffer to store the short name into.

    ShortByteCount - Address to store the number of bytes in the short name.

Return Value:

    None.

--*/

{
    UNICODE_STRING ShortName;
    UNICODE_STRING BiasedShortName;
    WCHAR ShortNameBuffer[ BYTE_COUNT_8_DOT_3 / sizeof( WCHAR ) ];
    WCHAR BiasedShortNameBuffer[ BYTE_COUNT_8_DOT_3 / sizeof( WCHAR ) ];

    GENERATE_NAME_CONTEXT NameContext;

    ULONG BiasedDirentOffset;

    ULONG MaximumBaseBytes;
    ULONG BaseNameOffset;

    PWCHAR NextWchar;
    WCHAR ThisWchar;
    USHORT Length;

    BOOLEAN FoundTilde = FALSE;

    OEM_STRING OemName;
    USHORT OemNameOffset = 0;
    BOOLEAN OverflowBuffer = FALSE;

    PAGED_CODE();

    //
    //  Initialize the short string to use the input buffer.
    //

    ShortName.Buffer = ShortNameBuffer;
    ShortName.MaximumLength = BYTE_COUNT_8_DOT_3;

    //
    //  Initialize the name context.
    //

    RtlZeroMemory( &NameContext, sizeof( GENERATE_NAME_CONTEXT ));

    //
    //  We now have the unicode name for the input string.  Go ahead and generate
    //  the short name.
    //

    RtlGenerate8dot3Name( FileName, TRUE, &NameContext, &ShortName );

    //
    //  We now have the generic short name.  We want incorporate the dirent offset
    //  into the name in order to reduce the chance of name conflicts.  We will use
    //  a tilde character followed by a character representation of the dirent offset.
    //  This will be the hexadecimal representation of the dirent offset in the directory.
    //  It is actuall this offset divided by 32 since we don't need the full
    //  granularity.
    //

    BiasedDirentOffset = DirentOffset >> SHORT_NAME_SHIFT;

    //
    //  Point to a local buffer to store the offset string.  We start
    //  at the end of the buffer and work backwards.
    //

    NextWchar = Add2Ptr( BiasedShortNameBuffer,
                         BYTE_COUNT_8_DOT_3,
                         PWCHAR );

    BiasedShortName.MaximumLength = BYTE_COUNT_8_DOT_3;

    //
    //  Generate an OEM version of the string so that we can check for double
    //  byte characters.
    //
    
    RtlUnicodeStringToOemString(&OemName, &ShortName, TRUE);
    
    Length = 0;

    //
    //  Now add the characters for the dirent offset.  We need to start
    //  from the least significant digit and work backwards.
    //

    do {

        NextWchar -= 1;

        ThisWchar = (WCHAR) (BiasedDirentOffset & 0x0000000f);

        //
        //  Store in the next character.  Bias against either '0' or 'A'
        //

        if (ThisWchar <= 9) {

            *NextWchar = ThisWchar + L'0';

        } else {

            *NextWchar = ThisWchar + L'A' - 0xA;
        }

        Length += sizeof( WCHAR );

        //
        //  Shift out the low 4 bits of the offset.
        //

        BiasedDirentOffset >>= 4;

    } while (BiasedDirentOffset != 0);

    //
    //  Now store in the tilde character.
    //

    NextWchar -= 1;
    *NextWchar = L'~';
    Length += sizeof( WCHAR );

    //
    //  Set the length of this string.
    //

    BiasedShortName.Length = Length;
    BiasedShortName.Buffer = NextWchar;

    //
    //  Figure out the maximum number of characters we can copy of the base
    //  name.  We subract the number of characters in the dirent string from 8.
    //  We will copy this many characters or stop when we reach a '.' character
    //  or a '~' character in the name.
    //

    MaximumBaseBytes = 16 - Length;

    BaseNameOffset = 0;

    //
    //  Keep copying from the base name until we hit a '.', '~'  or the end of
    //  the short name.
    //

    NextWchar = ShortFileName;
    Length = 0;

    while ((BaseNameOffset < ShortName.Length) &&
           (ShortName.Buffer[BaseNameOffset / 2] != L'.')) {

        //
        //  Remember if we found a tilde character in the short name,
        //  so we don't copy it or anything following it.
        //

        if (ShortName.Buffer[BaseNameOffset / 2] == L'~') {

            FoundTilde = TRUE;
        }

        //
        // We need to consider the DBCS code page,  because Unicode characters
        // may use 2 bytes as DBCS characters.
        //

        if (FsRtlIsLeadDbcsCharacter(OemName.Buffer[OemNameOffset])) {

            OemNameOffset += 2;

            if ((OemNameOffset + (BiasedShortName.Length / sizeof(WCHAR))) > 8)  {
            
                OverflowBuffer = TRUE;
            }
        }
        else  {
        
            OemNameOffset++;
        }

        //
        //  Only copy the bytes if we still have space for the dirent string.
        //

        if (!FoundTilde && !OverflowBuffer && (BaseNameOffset < MaximumBaseBytes)) {

            *NextWchar = ShortName.Buffer[BaseNameOffset / 2];
            Length += sizeof( WCHAR );
            NextWchar += 1;
        }

        BaseNameOffset += 2;
    }

    RtlFreeOemString(&OemName);

    //
    //  Now copy the dirent string into the biased name buffer.
    //

    RtlCopyMemory( NextWchar,
                   BiasedShortName.Buffer,
                   BiasedShortName.Length );

    Length += BiasedShortName.Length;
    NextWchar += (BiasedShortName.Length / sizeof( WCHAR ));

    //
    //  Now copy any remaining bytes over to the biased short name.
    //

    if (BaseNameOffset != ShortName.Length) {

        RtlCopyMemory( NextWchar,
                       &ShortName.Buffer[BaseNameOffset / 2],
                       ShortName.Length - BaseNameOffset );

        Length += (ShortName.Length - (USHORT) BaseNameOffset);
    }

    //
    //  The final short name is stored in the user's buffer.
    //

    *ShortByteCount = Length;

    return;
}


BOOLEAN
CdIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_NAME CurrentName,
    IN PCD_NAME SearchExpression,
    IN ULONG  WildcardFlags,
    IN BOOLEAN CheckVersion
    )

/*++

Routine Description:

    This routine will compare two CdName strings.  We assume that if this
    is to be a case-insensitive search then they are already upcased.

    We compare the filename portions of the name and if they match we
    compare the version strings if requested.

Arguments:

    CurrentName - Filename from the disk.

    SearchExpression - Filename expression to use for match.

    WildcardFlags - Flags field which indicates which parts of the
        search expression might have wildcards.  These flags are the
        same as in the Ccb flags field.

    CheckVersion - Indicates whether we should check both the name and the
        version strings or just the name.

Return Value:

    BOOLEAN - TRUE if the expressions match, FALSE otherwise.

--*/

{
    BOOLEAN Match = TRUE;
    PAGED_CODE();

    //
    //  If there are wildcards in the expression then we call the
    //  appropriate FsRtlRoutine.
    //

    if (FlagOn( WildcardFlags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD )) {

        Match = FsRtlIsNameInExpression( &SearchExpression->FileName,
                                         &CurrentName->FileName,
                                         FALSE,
                                         NULL );

    //
    //  Otherwise do a direct memory comparison for the name string.
    //

    } else {

        if ((CurrentName->FileName.Length != SearchExpression->FileName.Length) ||
            (!RtlEqualMemory( CurrentName->FileName.Buffer,
                              SearchExpression->FileName.Buffer,
                              CurrentName->FileName.Length ))) {

            Match = FALSE;
        }
    }

    //
    //  Check the version numbers if requested by the user and we have a
    //  match on the name and the version number is present.
    //

    if (Match && CheckVersion && SearchExpression->VersionString.Length &&
        !FlagOn( WildcardFlags, CCB_FLAG_ENUM_VERSION_MATCH_ALL )) {

        //
        //  If there are wildcards in the expression then call the
        //  appropriate search expression.
        //

        if (FlagOn( WildcardFlags, CCB_FLAG_ENUM_VERSION_EXP_HAS_WILD )) {

            Match = FsRtlIsNameInExpression( &SearchExpression->VersionString,
                                             &CurrentName->VersionString,
                                             FALSE,
                                             NULL );

        //
        //  Otherwise do a direct memory comparison for the name string.
        //

        } else {

            if ((CurrentName->VersionString.Length != SearchExpression->VersionString.Length) ||
                (!RtlEqualMemory( CurrentName->VersionString.Buffer,
                                  SearchExpression->VersionString.Buffer,
                                  CurrentName->VersionString.Length ))) {

                Match = FALSE;
            }
        }
    }

    return Match;
}


ULONG
CdShortNameDirentOffset (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine is called to examine a name to see if the dirent offset string is contained.
    This consists of a tilde character followed by the offset represented as a hexadecimal
    characters.  We don't do any other checks to see if this is a short name.  We
    catch that later outside this routine.

Arguments:

    Name - This is the CdName to examine.

Return Value:

    ULONG - MAXULONG if there is no valid dirent offset string embedded, otherwise the
        convert the value to numeric form.

--*/

{
    ULONG ResultOffset = MAXULONG;
    ULONG RemainingByteCount = Name->Length;

    BOOLEAN FoundTilde = FALSE;

    PWCHAR NextWchar;

    PAGED_CODE();

    //
    //  Walk through the name until we either reach the end of the name
    //  or find a tilde character.
    //

    for (NextWchar = Name->Buffer;
         RemainingByteCount != 0;
         NextWchar += 1, RemainingByteCount -= sizeof( WCHAR )) {

        //
        //  Check if this is a dot.  Stop constructing any string if
        //  we found a dot.
        //

        if (*NextWchar == L'.') {

            break;
        }

        //
        //  If we already found a tilde then check this character as a
        //  valid character.  It must be a digit or A to F.
        //

        if (FoundTilde) {

            if ((*NextWchar < L'0') ||
                (*NextWchar > L'F') ||
                ((*NextWchar > L'9') && (*NextWchar < 'A'))) {

                ResultOffset = MAXULONG;
                break;
            }

            //
            //  Shift the result by 4 bits and add in this new character.
            //

            ResultOffset <<= 4;

            if (*NextWchar < L'A') {

                ResultOffset += *NextWchar - L'0';

            } else {

                ResultOffset += (*NextWchar - L'A') + 10;
            }

            continue;
        }

        //
        //  If this is a tilde then start building the dirent string.
        //

        if (*NextWchar == L'~') {

            FoundTilde = TRUE;
            ResultOffset = 0;
        }
    }

    return ResultOffset;
}


//
//  Local support routine
//

FSRTL_COMPARISON_RESULT
CdFullCompareNames (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    )

/*++

Routine Description:

    This function compares two names as fast as possible.  Note that since
    this comparison is case sensitive we can do a direct memory comparison.

Arguments:

    NameA & NameB - The names to compare.

Return Value:

    COMPARISON - returns

        LessThan    if NameA < NameB lexicalgraphically,
        GreaterThan if NameA > NameB lexicalgraphically,
        EqualTo     if NameA is equal to NameB

--*/

{
    SIZE_T i;
    ULONG MinLength = NameA->Length;
    FSRTL_COMPARISON_RESULT Result = LessThan;

    PAGED_CODE();

    //
    //  Figure out the minimum of the two lengths
    //

    if (NameA->Length > NameB->Length) {

        MinLength = NameB->Length;
        Result = GreaterThan;

    } else if (NameA->Length == NameB->Length) {

        Result = EqualTo;
    }

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty, less than, and greater than
    //

    i = RtlCompareMemory( NameA->Buffer, NameB->Buffer, MinLength );

    if (i < MinLength) {

        //
        //  We know the offset of the first character which is different.
        //

        return ((NameA->Buffer[ i / 2 ] < NameB->Buffer[ i / 2 ]) ?
                 LessThan :
                 GreaterThan);
    }

    //
    //  The names match up to the length of the shorter string.
    //  The shorter string lexically appears first.
    //

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\pnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    Pnp.c

Abstract:

    This module implements the Plug and Play routines for CDFS called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Jul-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_PNP)

NTSTATUS
CdPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
CdPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
CdPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
CdPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
CdPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonPnp)
#pragma alloc_text(PAGE, CdPnpCancelRemove)
#pragma alloc_text(PAGE, CdPnpQueryRemove)
#pragma alloc_text(PAGE, CdPnpRemove)
#pragma alloc_text(PAGE, CdPnpSurpriseRemove)
#endif


NTSTATUS
CdCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing PnP operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    
    PIO_STACK_LOCATION IrpSp;

    PVOLUME_DEVICE_OBJECT OurDeviceObject;
    PVCB Vcb;

    //
    //  Get the current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Find our Vcb.  This is tricky since we have no file object in the Irp.
    //

    OurDeviceObject = (PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject;

    //
    //  Make sure this device object really is big enough to be a volume device
    //  object.  If it isn't, we need to get out before we try to reference some
    //  field that takes us past the end of an ordinary device object.
    //
    
    if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
        NodeType( &OurDeviceObject->Vcb ) != CDFS_NTC_VCB) {
        
        //
        //  We were called with something we don't understand.
        //
        
        Status = STATUS_INVALID_PARAMETER;
        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Force all PnP operations to be synchronous.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    Vcb = &OurDeviceObject->Vcb;

    //
    //  Case on the minor code.
    //
    
    switch ( IrpSp->MinorFunction ) {

        case IRP_MN_QUERY_REMOVE_DEVICE:
            
            Status = CdPnpQueryRemove( IrpContext, Irp, Vcb );
            break;
        
        case IRP_MN_SURPRISE_REMOVAL:
        
            Status = CdPnpSurpriseRemove( IrpContext, Irp, Vcb );
            break;

        case IRP_MN_REMOVE_DEVICE:

            Status = CdPnpRemove( IrpContext, Irp, Vcb );
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
    
            Status = CdPnpCancelRemove( IrpContext, Irp, Vcb );
            break;

        default:
    
            //
            //  Just pass the IRP on.  As we do not need to be in the
            //  way on return, ellide ourselves out of the stack.
            //
            
            IoSkipCurrentIrpStackLocation( Irp );
    
            Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);
            
            //
            //  Cleanup our Irp Context.  The driver has completed the Irp.
            //
        
            CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
            
            break;
    }
        
    return Status;
}


NTSTATUS
CdPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP query remove operation.  The filesystem
    is responsible for answering whether there are any reasons it sees
    that the volume can not go away (and the device removed).  Initiation
    of the dismount begins when we answer yes to this question.
    
    Query will be followed by a Cancel or Remove.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being queried.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;

    //
    //  Having said yes to a QUERY, any communication with the
    //  underlying storage stack is undefined (and may block)
    //  until the bounding CANCEL or REMOVE is sent.
    //

    //
    //  Acquire the global resource so that we can try to vaporize
    //  the volume, and the vcb resource itself.
    //
    
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    Status = CdLockVolumeInternal( IrpContext, Vcb, NULL );

    CdReleaseVcb( IrpContext, Vcb );
    CdAcquireCdData( IrpContext );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    
    if (NT_SUCCESS( Status )) {

        //
        //  We need to pass this down before starting the dismount, which
        //  could disconnect us immediately from the stack.
        //
        
        //
        //  Get the next stack location, and copy over the stack location
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        //  Set up the completion routine
        //
    
        KeInitializeEvent( &Event, NotificationEvent, FALSE );
        IoSetCompletionRoutine( Irp,
                                CdPnpCompletionRoutine,
                                &Event,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Send the request and wait.
        //

        Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

        if (Status == STATUS_PENDING) {

            KeWaitForSingleObject( &Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = Irp->IoStatus.Status;
        }

        //
        //  Now if no one below us failed already, initiate the dismount
        //  on this volume, make it go away.  PnP needs to see our internal
        //  streams close and drop their references to the target device.
        //
        //  Since we were able to lock the volume, we are guaranteed to
        //  move this volume into dismount state and disconnect it from
        //  the underlying storage stack.  The force on our part is actually
        //  unnecesary, though complete.
        //
        //  What is not strictly guaranteed, though, is that the closes
        //  for the metadata streams take effect synchronously underneath
        //  of this call.  This would leave references on the target device
        //  even though we are disconnected!
        //

        if (NT_SUCCESS( Status )) {
            
            VcbPresent = CdCheckForDismount( IrpContext, Vcb, TRUE );
    
            ASSERT( !VcbPresent || Vcb->VcbCondition == VcbDismountInProgress );
        }
    }
    
    //
    //  Release the Vcb if it could still remain.
    //
    //  Note: if everything else succeeded and the Vcb is persistent because the
    //  internal streams did not vaporize, we really need to pend this IRP off on
    //  the side until the dismount is completed.  I can't think of a reasonable
    //  case (in CDFS) where this would actually happen, though it might still need
    //  to be implemented.
    //
    //  The reason this is the case is that handles/fileobjects place a reference
    //  on the device objects they overly.  In the filesystem case, these references
    //  are on our target devices.  PnP correcly thinks that if references remain
    //  on the device objects in the stack that someone has a handle, and that this
    //  counts as a reason to not succeed the query - even though every interrogated
    //  driver thinks that it is OK.
    //
    
    ASSERT( !(NT_SUCCESS( Status ) && VcbPresent && Vcb->VcbReference != 0));
    
    if (VcbPresent) {

        CdReleaseVcb( IrpContext, Vcb );
    }

    CdReleaseCdData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP if neccesary.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
CdPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP remove operation.  This is our notification
    that the underlying storage device for the volume we have is gone, and
    an excellent indication that the volume will never reappear. The filesystem
    is responsible for initiation or completion the dismount.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;
    
    //
    //  REMOVE - a storage device is now gone.  We either got
    //  QUERY'd and said yes OR got a SURPRISE OR a storage
    //  stack failed to spin back up from a sleep/stop state
    //  (the only case in which this will be the first warning).
    //
    //  Note that it is entirely unlikely that we will be around
    //  for a REMOVE in the first two cases, as we try to intiate
    //  dismount.
    //
    
    //
    //  Acquire the global resource so that we can try to vaporize
    //  the volume, and the vcb resource itself.
    //
    
    CdAcquireCdData( IrpContext );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  The device will be going away.  Remove our lock and find
    //  out if we ever had one in the first place.
    //

    Status = CdUnlockVolumeInternal( IrpContext, Vcb, NULL );

    //
    //  If the volume had not been locked, we must invalidate the
    //  volume to ensure it goes away properly.  The remove will
    //  succeed.
    //

    if (!NT_SUCCESS( Status )) {

        CdLockVcb( IrpContext, Vcb );
        
        if (Vcb->VcbCondition != VcbDismountInProgress) {
            
            CdUpdateVcbCondition( Vcb, VcbInvalid);
        }
        
        CdUnlockVcb( IrpContext, Vcb );
        
        Status = STATUS_SUCCESS;
    }
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            CdPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }

    //
    //  Now make our dismount happen.  This may not vaporize the
    //  Vcb, of course, since there could be any number of handles
    //  outstanding if we were not preceeded by a QUERY.
    //
    //  PnP will take care of disconnecting this stack if we
    //  couldn't get off of it immediately.
    //

    VcbPresent = CdCheckForDismount( IrpContext, Vcb, TRUE );

    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        CdReleaseVcb( IrpContext, Vcb );
    }

    CdReleaseCdData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
CdPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP surprise remove operation.  This is another
    type of notification that the underlying storage device for the volume we
    have is gone, and is excellent indication that the volume will never reappear.
    The filesystem is responsible for initiation or completion the dismount.
    
    For the most part, only "real" drivers care about the distinction of a
    surprise remove, which is a result of our noticing that a user (usually)
    physically reached into the machine and pulled something out.
    
    Surprise will be followed by a Remove when all references have been shut down.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;
    
    //
    //  SURPRISE - a device was physically yanked away without
    //  any warning.  This means external forces.
    //
    
    CdAcquireCdData( IrpContext );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
        
    //
    //  Invalidate the volume right now.
    //
    //  The intent here is to make every subsequent operation
    //  on the volume fail and grease the rails toward dismount.
    //  By definition there is no going back from a SURPRISE.
    //
        
    CdLockVcb( IrpContext, Vcb );
    
    if (Vcb->VcbCondition != VcbDismountInProgress) {
        
        CdUpdateVcbCondition( Vcb, VcbInvalid);
    }
    
    CdUnlockVcb( IrpContext, Vcb );
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            CdPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }
    
    //
    //  Now make our dismount happen.  This may not vaporize the
    //  Vcb, of course, since there could be any number of handles
    //  outstanding since this is an out of band notification.
    //

    VcbPresent = CdCheckForDismount( IrpContext, Vcb, TRUE );
    
    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        CdReleaseVcb( IrpContext, Vcb );
    }

    CdReleaseCdData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
CdPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP cancel remove operation.  This is our
    notification that a previously proposed remove (query) was eventually
    vetoed by a component.  The filesystem is responsible for cleaning up
    and getting ready for more IO.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    //
    //  CANCEL - a previous QUERY has been rescinded as a result
    //  of someone vetoing.  Since PnP cannot figure out who may
    //  have gotten the QUERY (think about it: stacked drivers),
    //  we must expect to deal with getting a CANCEL without having
    //  seen the QUERY.
    //
    //  For CDFS, this is quite easy.  In fact, we can't get a
    //  CANCEL if the underlying drivers succeeded the QUERY since
    //  we disconnect the Vpb on our dismount initiation.  This is
    //  actually pretty important because if PnP could get to us
    //  after the disconnect we'd be thoroughly unsynchronized
    //  with respect to the Vcb getting torn apart - merely referencing
    //  the volume device object is insufficient to keep us intact.
    //
    
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    
    //
    //  Unlock the volume.  This is benign if we never had seen
    //  a QUERY.
    //

    (VOID) CdUnlockVolumeInternal( IrpContext, Vcb, NULL );

    CdReleaseVcb( IrpContext, Vcb );

    //
    //  Send the request.  The underlying driver will complete the
    //  IRP.  Since we don't need to be in the way, simply ellide
    //  ourselves out of the IRP stack.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )
{
    PKEVENT Event = (PKEVENT) Contxt;

    KeSetEvent( Event, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\prefxsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Cdfs Prefix support routines

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   07-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_PREFXSUP)

//
//  Local support routines.
//

PNAME_LINK
CdFindNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    );

BOOLEAN
CdInsertNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PNAME_LINK NameLink
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdFindNameLink)
#pragma alloc_text(PAGE, CdFindPrefix)
#pragma alloc_text(PAGE, CdInsertNameLink)
#pragma alloc_text(PAGE, CdInsertPrefix)
#pragma alloc_text(PAGE, CdRemovePrefix)
#endif


VOID
CdInsertPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PFCB ParentFcb
    )

/*++

Routine Description:

    This routine inserts the names in the given Lcb into the links for the
    parent.

Arguments:

    Fcb - This is the Fcb whose name is being inserted into the tree.

    Name - This is the name for the component.  The IgnoreCase flag tells
        us which entry this belongs to.

    IgnoreCase - Indicates if we should insert the case-insensitive name.

    ShortNameMatch - Indicates if this is the short name.

    ParentFcb - This is the ParentFcb.  The prefix tree is attached to this.

Return Value:

    None.

--*/

{
    ULONG PrefixFlags;
    PNAME_LINK NameLink;
    PPREFIX_ENTRY PrefixEntry;
    PRTL_SPLAY_LINKS *TreeRoot;

    PWCHAR NameBuffer;

    PAGED_CODE();

    //
    //  Check if we need to allocate a prefix entry for the short name.
    //  If we can't allocate one then fail quietly.  We don't have to
    //  insert the name.
    //

    PrefixEntry = &Fcb->FileNamePrefix;

    if (ShortNameMatch) {

        if (Fcb->ShortNamePrefix == NULL) {

            Fcb->ShortNamePrefix = ExAllocatePoolWithTag( CdPagedPool,
                                                          sizeof( PREFIX_ENTRY ),
                                                          TAG_PREFIX_ENTRY );

            if (Fcb->ShortNamePrefix == NULL) { return; }

            RtlZeroMemory( Fcb->ShortNamePrefix, sizeof( PREFIX_ENTRY ));
        }

        PrefixEntry = Fcb->ShortNamePrefix;
    }

    //
    //  Capture the local variables for the separate cases.
    //

    if (IgnoreCase) {

        PrefixFlags = PREFIX_FLAG_IGNORE_CASE_IN_TREE;
        NameLink = &PrefixEntry->IgnoreCaseName;
        TreeRoot = &ParentFcb->IgnoreCaseRoot;

    } else {

        PrefixFlags = PREFIX_FLAG_EXACT_CASE_IN_TREE;
        NameLink = &PrefixEntry->ExactCaseName;
        TreeRoot = &ParentFcb->ExactCaseRoot;
    }

    //
    //  If neither name is in the tree then check whether we have a buffer for this
    //  name
    //

    if (!FlagOn( PrefixEntry->PrefixFlags,
                 PREFIX_FLAG_EXACT_CASE_IN_TREE | PREFIX_FLAG_IGNORE_CASE_IN_TREE )) {

        //
        //  Allocate a new buffer if the embedded buffer is too small.
        //

        NameBuffer = PrefixEntry->FileNameBuffer;

        if (Name->FileName.Length > BYTE_COUNT_EMBEDDED_NAME) {

            NameBuffer = ExAllocatePoolWithTag( CdPagedPool,
                                                Name->FileName.Length * 2,
                                                TAG_PREFIX_NAME );

            //
            //  Exit if no name buffer.
            //

            if (NameBuffer == NULL) { return; }
        }

        //
        //  Split the buffer and fill in the separate components.
        //

        PrefixEntry->ExactCaseName.FileName.Buffer = NameBuffer;
        PrefixEntry->IgnoreCaseName.FileName.Buffer = Add2Ptr( NameBuffer,
                                                               Name->FileName.Length,
                                                               PWCHAR );

        PrefixEntry->IgnoreCaseName.FileName.MaximumLength =
        PrefixEntry->IgnoreCaseName.FileName.Length =
        PrefixEntry->ExactCaseName.FileName.MaximumLength =
        PrefixEntry->ExactCaseName.FileName.Length = Name->FileName.Length;
    }

    //
    //  Only insert the name if not already present.
    //

    if (!FlagOn( PrefixEntry->PrefixFlags, PrefixFlags )) {

        //
        //  Initialize the name in the prefix entry.
        //

        RtlCopyMemory( NameLink->FileName.Buffer,
                       Name->FileName.Buffer,
                       Name->FileName.Length );

        CdInsertNameLink( IrpContext,
                          TreeRoot,
                          NameLink );

        PrefixEntry->Fcb = Fcb;
        SetFlag( PrefixEntry->PrefixFlags, PrefixFlags );
    }

    return;
}


VOID
CdRemovePrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to remove all of the previx entries of a
    given Fcb from its parent Fcb.

Arguments:

    Fcb - Fcb whose entries are to be removed.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Start with the short name prefix entry.
    //

    if (Fcb->ShortNamePrefix != NULL) {

        if (FlagOn( Fcb->ShortNamePrefix->PrefixFlags, PREFIX_FLAG_IGNORE_CASE_IN_TREE )) {

            Fcb->ParentFcb->IgnoreCaseRoot = RtlDelete( &Fcb->ShortNamePrefix->IgnoreCaseName.Links );
        }

        if (FlagOn( Fcb->ShortNamePrefix->PrefixFlags, PREFIX_FLAG_EXACT_CASE_IN_TREE )) {

            Fcb->ParentFcb->ExactCaseRoot = RtlDelete( &Fcb->ShortNamePrefix->ExactCaseName.Links );
        }

        ClearFlag( Fcb->ShortNamePrefix->PrefixFlags,
                   PREFIX_FLAG_IGNORE_CASE_IN_TREE | PREFIX_FLAG_EXACT_CASE_IN_TREE );
    }

    //
    //  Now do the long name prefix entries.
    //

    if (FlagOn( Fcb->FileNamePrefix.PrefixFlags, PREFIX_FLAG_IGNORE_CASE_IN_TREE )) {

        Fcb->ParentFcb->IgnoreCaseRoot = RtlDelete( &Fcb->FileNamePrefix.IgnoreCaseName.Links );
    }

    if (FlagOn( Fcb->FileNamePrefix.PrefixFlags, PREFIX_FLAG_EXACT_CASE_IN_TREE )) {

        Fcb->ParentFcb->ExactCaseRoot = RtlDelete( &Fcb->FileNamePrefix.ExactCaseName.Links );
    }

    ClearFlag( Fcb->FileNamePrefix.PrefixFlags,
               PREFIX_FLAG_IGNORE_CASE_IN_TREE | PREFIX_FLAG_EXACT_CASE_IN_TREE );

    //
    //  Deallocate any buffer we may have allocated.
    //

    if ((Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer != (PWCHAR) &Fcb->FileNamePrefix.FileNameBuffer) &&
        (Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer != NULL)) {

        ExFreePool( Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer );
        Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer = NULL;
    }

    return;
}


VOID
CdFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *CurrentFcb,
    IN OUT PUNICODE_STRING RemainingName,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine begins from the given CurrentFcb and walks through all of
    components of the name looking for the longest match in the prefix
    splay trees.  The search is relative to the starting Fcb so the
    full name may not begin with a '\'.  On return this routine will
    update Current Fcb with the lowest point it has travelled in the
    tree.  It will also hold only that resource on return and it must
    hold that resource.

Arguments:

    CurrentFcb - Address to store the lowest Fcb we find on this search.
        On return we will have acquired this Fcb.  On entry this is the
        Fcb to examine.

    RemainingName - Supplies a buffer to store the exact case of the name being
        searched for.  Initially will contain the upcase name based on the
        IgnoreCase flag.

    IgnoreCase - Indicates if we are doing a case-insensitive compare.

Return Value:

    None

--*/

{
    UNICODE_STRING LocalRemainingName;

    UNICODE_STRING FinalName;

    PNAME_LINK NameLink;
    PPREFIX_ENTRY PrefixEntry;

    PAGED_CODE();

    //
    //  Make a local copy of the input strings.
    //

    LocalRemainingName = *RemainingName;

    //
    //  Loop until we find the longest matching prefix.
    //

    while (TRUE) {

        //
        //  If there are no characters left or we are not at an IndexFcb then
        //  return immediately.
        //

        if ((LocalRemainingName.Length == 0) ||
            (SafeNodeType( *CurrentFcb ) != CDFS_NTC_FCB_INDEX)) {

            return;
        }

        //
        //  Split off the next component from the name.
        //

        CdDissectName( IrpContext,
                       &LocalRemainingName,
                       &FinalName );

        //
        //  Check if this name is in the splay tree for this Scb.
        //

        if (IgnoreCase) {

            NameLink = CdFindNameLink( IrpContext,
                                       &(*CurrentFcb)->IgnoreCaseRoot,
                                       &FinalName );

            //
            //  Get the prefix entry from this NameLink.  Don't access any
            //  fields within it until we verify we have a name link.
            //

            PrefixEntry = (PPREFIX_ENTRY) CONTAINING_RECORD( NameLink,
                                                             PREFIX_ENTRY,
                                                             IgnoreCaseName );

        } else {

            NameLink = CdFindNameLink( IrpContext,
                                       &(*CurrentFcb)->ExactCaseRoot,
                                       &FinalName );

            PrefixEntry = (PPREFIX_ENTRY) CONTAINING_RECORD( NameLink,
                                                             PREFIX_ENTRY,
                                                             ExactCaseName );
        }

        //
        //  If we didn't find a match then exit.
        //

        if (NameLink == NULL) { return; }

        //
        //  If this is a case-insensitive match then copy the exact case of the name into
        //  the input buffer.
        //

        if (IgnoreCase) {

            RtlCopyMemory( FinalName.Buffer,
                           PrefixEntry->ExactCaseName.FileName.Buffer,
                           PrefixEntry->ExactCaseName.FileName.Length );
        }

        //
        //  Update the caller's remaining name string to reflect the fact that we found
        //  a match.
        //

        *RemainingName = LocalRemainingName;

        //
        //  Move down to the next component in the tree.  Acquire without waiting.
        //  If this fails then lock the Fcb to reference this Fcb and then drop
        //  the parent and acquire the child.
        //

        if (!CdAcquireFcbExclusive( IrpContext, PrefixEntry->Fcb, TRUE )) {

            //
            //  If we can't wait then raise CANT_WAIT.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            CdLockVcb( IrpContext, IrpContext->Vcb );
            PrefixEntry->Fcb->FcbReference += 1;
            CdUnlockVcb( IrpContext, IrpContext->Vcb );

            CdReleaseFcb( IrpContext, *CurrentFcb );
            CdAcquireFcbExclusive( IrpContext, PrefixEntry->Fcb, FALSE );

            CdLockVcb( IrpContext, IrpContext->Vcb );
            PrefixEntry->Fcb->FcbReference -= 1;
            CdUnlockVcb( IrpContext, IrpContext->Vcb );

        } else {

            CdReleaseFcb( IrpContext, *CurrentFcb );
        }

        *CurrentFcb = PrefixEntry->Fcb;
    }
}


//
//  Local support routine
//

PNAME_LINK
CdFindNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine searches through a splay link tree looking for a match for the
    input name.  If we find the corresponding name we will rebalance the
    tree.

Arguments:

    RootNode - Supplies the parent to search.

    Name - This is the name to search for.  Note if we are doing a case
        insensitive search the name would have been upcased already.

Return Value:

    PNAME_LINK - The name link found or NULL if there is no match.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PNAME_LINK Node;
    PRTL_SPLAY_LINKS Links;

    PAGED_CODE();

    Links = *RootNode;

    while (Links != NULL) {

        Node = CONTAINING_RECORD( Links, NAME_LINK, Links );

        //
        //  Compare the prefix in the tree with the full name
        //

        Comparison = CdFullCompareNames( IrpContext, &Node->FileName, Name );

        //
        //  See if they don't match
        //

        if (Comparison == GreaterThan) {

            //
            //  The prefix is greater than the full name
            //  so we go down the left child
            //

            Links = RtlLeftChild( Links );

            //
            //  And continue searching down this tree
            //

        } else if (Comparison == LessThan) {

            //
            //  The prefix is less than the full name
            //  so we go down the right child
            //

            Links = RtlRightChild( Links );

            //
            //  And continue searching down this tree
            //

        } else {

            //
            //  We found it.
            //
            //  Splay the tree and save the new root.
            //

            *RootNode = RtlSplay( Links );

            return Node;
        }
    }

    //
    //  We didn't find the Link.
    //

    return NULL;
}


//
//  Local support routine
//

BOOLEAN
CdInsertNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PNAME_LINK NameLink
    )

/*++

Routine Description:

    This routine will insert a name in the splay tree pointed to
    by RootNode.

    The name could already exist in this tree for a case-insensitive tree.
    In that case we simply return FALSE and do nothing.

Arguments:

    RootNode - Supplies a pointer to the table.

    NameLink - Contains the new link to enter.

Return Value:

    BOOLEAN - TRUE if the name is inserted, FALSE otherwise.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PNAME_LINK Node;

    PAGED_CODE();

    RtlInitializeSplayLinks( &NameLink->Links );

    //
    //  If we are the first entry in the tree, just become the root.
    //

    if (*RootNode == NULL) {

        *RootNode = &NameLink->Links;

        return TRUE;
    }

    Node = CONTAINING_RECORD( *RootNode, NAME_LINK, Links );

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert.
        //

        Comparison = CdFullCompareNames( IrpContext, &Node->FileName, &NameLink->FileName );

        //
        //  If we found the entry, return immediately.
        //

        if (Comparison == EqualTo) { return FALSE; }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == GreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild( &Node->Links ) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                RtlInsertAsLeftChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild( &Node->Links ),
                                          NAME_LINK,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases as less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild( &Node->Links ) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                RtlInsertAsRightChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild( &Node->Links ),
                                          NAME_LINK,
                                          Links );
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\read.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Read called by the
    Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_READ)

//
//  VOID
//  SafeZeroMemory (
//      IN PUCHAR At,
//      IN ULONG ByteCount
//      );
//

//
//  This macro just puts a nice little try-except around RtlZeroMemory
//

#define SafeZeroMemory(IC,AT,BYTE_COUNT) {                  \
    try {                                                   \
        RtlZeroMemory( (AT), (BYTE_COUNT) );                \
    } except( EXCEPTION_EXECUTE_HANDLER ) {                 \
         CdRaiseStatus( IC, STATUS_INVALID_USER_BUFFER );   \
    }                                                       \
}

//
// Read ahead amount used for normal data files
//

#define READ_AHEAD_GRANULARITY           (0x10000)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonRead)
#endif


NTSTATUS
CdCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common entry point for NtReadFile calls.  For synchronous requests,
    CommonRead will complete the request in the current thread.  If not
    synchronous the request will be passed to the Fsp if there is a need to
    block.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The result of this operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN Wait;
    ULONG PagingIo;
    ULONG SynchronousIo;
    ULONG NonCachedIo;
    PVOID UserBuffer;

    LONGLONG StartingOffset;
    LONGLONG ByteRange;
    ULONG ByteCount;
    ULONG ReadByteCount;
    ULONG OriginalByteCount;

    PVOID SystemBuffer;

    BOOLEAN ReleaseFile = TRUE;

    CD_IO_CONTEXT LocalIoContext;

    PAGED_CODE();

    //
    //  If this is a zero length read then return SUCCESS immediately.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Decode the file object and verify we support read on this.  It
    //  must be a user file, stream file or volume file (for a data disk).
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    if ((TypeOfOpen == UnopenedFileObject) ||
        (TypeOfOpen == UserDirectoryOpen)) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Examine our input parameters to determine if this is noncached and/or
    //  a paging io operation.
    //

    Wait = BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    PagingIo = FlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = FlagOn( Irp->Flags, IRP_NOCACHE );
    SynchronousIo = FlagOn( IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO );


    //
    //  Extract the range of the Io.
    //

    StartingOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    OriginalByteCount = ByteCount = IrpSp->Parameters.Read.Length;

    ByteRange = StartingOffset + ByteCount;

    //
    //  Make sure that Dasd access is always non-cached.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        NonCachedIo = TRUE;
    }

    //
    //  Acquire the file shared to perform the read.  If we are doing paging IO,
    //  it may be the case that we would have a deadlock imminent because we may
    //  block on shared access, so starve out any exclusive waiters.  This requires
    //  a degree of caution - we believe that any paging IO bursts will recede and
    //  allow the exclusive waiter in.
    //

    if (PagingIo) {

        CdAcquireFileSharedStarveExclusive( IrpContext, Fcb );
    
    } else {
        
        CdAcquireFileShared( IrpContext, Fcb );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Fcb.  Allow reads if this is a DASD handle that is 
        //  dismounting the volume.
        //

        if ((TypeOfOpen != UserVolumeOpen) || (NULL == Ccb) ||
            !FlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE))  {
        
            CdVerifyFcbOperation( IrpContext, Fcb );
        }

        //
        //  If this is a non-cached then check whether we need to post this
        //  request if this thread can't block.
        //

        if (!Wait && NonCachedIo) {

            //
            //  XA requests must always be waitable.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_RAWSECTOR_MASK )) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );
                try_return( Status = STATUS_CANT_WAIT );
            }
        }

        //
        //  If this is a user request then verify the oplock and filelock state.
        //

        if (TypeOfOpen == UserFileOpen) {

            //
            //  We check whether we can proceed
            //  based on the state of the file oplocks.
            //

            Status = FsRtlCheckOplock( &Fcb->Oplock,
                                       Irp,
                                       IrpContext,
                                       CdOplockComplete,
                                       CdPrePostIrp );

            //
            //  If the result is not STATUS_SUCCESS then the Irp was completed
            //  elsewhere.
            //

            if (Status != STATUS_SUCCESS) {

                Irp = NULL;
                IrpContext = NULL;

                try_return( NOTHING );
            }

            if (!PagingIo &&
                (Fcb->FileLock != NULL) &&
                !FsRtlCheckLockForReadAccess( Fcb->FileLock, Irp )) {

                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
            }
        }

        //
        //  Complete the request if it begins beyond the end of file.
        //

        if (StartingOffset >= Fcb->FileSize.QuadPart) {

            try_return( Status = STATUS_END_OF_FILE );
        }

        //
        //  Truncate the read if it extends beyond the end of the file.
        //

        if (ByteRange > Fcb->FileSize.QuadPart) {

            ByteCount = (ULONG) (Fcb->FileSize.QuadPart - StartingOffset);
            ByteRange = Fcb->FileSize.QuadPart;
        }

        //
        //  Handle the non-cached read first.
        //

        if (NonCachedIo) {

            //
            //  If we have an unaligned transfer then post this request if
            //  we can't wait.  Unaligned means that the starting offset
            //  is not on a sector boundary or the read is not integral
            //  sectors.
            //

            ReadByteCount = BlockAlign( Fcb->Vcb, ByteCount );

            if (SectorOffset( StartingOffset ) ||
                SectorOffset( ReadByteCount ) ||
                (ReadByteCount > OriginalByteCount)) {

                if (!Wait) {

                    CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
                }

                //
                //  Make sure we don't overwrite the buffer.
                //

                ReadByteCount = ByteCount;
            }

            //
            //  Initialize the IoContext for the read.
            //  If there is a context pointer, we need to make sure it was
            //  allocated and not a stale stack pointer.
            //

            if (IrpContext->IoContext == NULL ||
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

                //
                //  If we can wait, use the context on the stack.  Otherwise
                //  we need to allocate one.
                //

                if (Wait) {

                    IrpContext->IoContext = &LocalIoContext;
                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

                } else {

                    IrpContext->IoContext = CdAllocateIoContext();
                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                }
            }

            RtlZeroMemory( IrpContext->IoContext, sizeof( CD_IO_CONTEXT ));

            //
            //  Store whether we allocated this context structure in the structure
            //  itself.
            //

            IrpContext->IoContext->AllocatedContext =
                BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

            if (Wait) {

                KeInitializeEvent( &IrpContext->IoContext->SyncEvent,
                                   NotificationEvent,
                                   FALSE );

            } else {

                IrpContext->IoContext->ResourceThreadId = ExGetCurrentResourceThread();
                IrpContext->IoContext->Resource = Fcb->Resource;
                IrpContext->IoContext->RequestedByteCount = ByteCount;
            }

            Irp->IoStatus.Information = ReadByteCount;

            //
            //  Call one of the NonCacheIo routines to perform the actual
            //  read.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_RAWSECTOR_MASK )) {

                Status = CdNonCachedXARead( IrpContext, Fcb, StartingOffset, ReadByteCount );

            } else {

                Status = CdNonCachedRead( IrpContext, Fcb, StartingOffset, ReadByteCount );
            }

            //
            //  Don't complete this request now if STATUS_PENDING was returned.
            //

            if (Status == STATUS_PENDING) {

                Irp = NULL;
                ReleaseFile = FALSE;

            //
            //  Test is we should zero part of the buffer or update the
            //  synchronous file position.
            //

            } else {

                //
                //  Convert any unknown error code to IO_ERROR.
                //

                if (!NT_SUCCESS( Status )) {

                    //
                    //  Set the information field to zero.
                    //

                    Irp->IoStatus.Information = 0;

                    //
                    //  Raise if this is a user induced error.
                    //

                    if (IoIsErrorUserInduced( Status )) {

                        CdRaiseStatus( IrpContext, Status );
                    }

                    Status = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR );

                //
                //  Check if there is any portion of the user's buffer to zero.
                //

                } else if (ReadByteCount != ByteCount) {

                    CdMapUserBuffer( IrpContext, &UserBuffer);
                    
                    SafeZeroMemory( IrpContext,
                                    Add2Ptr( UserBuffer,
                                             ByteCount,
                                             PVOID ),
                                    ReadByteCount - ByteCount );

                    Irp->IoStatus.Information = ByteCount;
                }

                //
                //  Update the file position if this is a synchronous request.
                //

                if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

                    IrpSp->FileObject->CurrentByteOffset.QuadPart = ByteRange;
                }
            }

            try_return( NOTHING );
        }

        //
        //  Handle the cached case.  Start by initializing the private
        //  cache map.
        //

        if (IrpSp->FileObject->PrivateCacheMap == NULL) {

            //
            //  Now initialize the cache map.
            //

            CcInitializeCacheMap( IrpSp->FileObject,
                                  (PCC_FILE_SIZES) &Fcb->AllocationSize,
                                  FALSE,
                                  &CdData.CacheManagerCallbacks,
                                  Fcb );

            CcSetReadAheadGranularity( IrpSp->FileObject, READ_AHEAD_GRANULARITY );
        }

        //
        //  Read from the cache if this is not an Mdl read.
        //

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            //
            // If we are in the Fsp now because we had to wait earlier,
            // we must map the user buffer, otherwise we can use the
            // user's buffer directly.
            //

            CdMapUserBuffer( IrpContext, &SystemBuffer );

            //
            // Now try to do the copy.
            //

            if (!CcCopyRead( IrpSp->FileObject,
                             (PLARGE_INTEGER) &StartingOffset,
                             ByteCount,
                             Wait,
                             SystemBuffer,
                             &Irp->IoStatus )) {

                try_return( Status = STATUS_CANT_WAIT );
            }

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                CdNormalizeAndRaiseStatus( IrpContext, Irp->IoStatus.Status );
            }

        //
        //  Otherwise perform the MdlRead operation.
        //

        } else {

            CcMdlRead( IrpSp->FileObject,
                       (PLARGE_INTEGER) &StartingOffset,
                       ByteCount,
                       &Irp->MdlAddress,
                       &Irp->IoStatus );

            Status = Irp->IoStatus.Status;
        }

        //
        //  Update the current file position in the user file object.
        //

        if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

            IrpSp->FileObject->CurrentByteOffset.QuadPart = ByteRange;
        }

    try_exit:  NOTHING;
    } finally {

        //
        //  Release the Fcb.
        //

        if (ReleaseFile) {

            CdReleaseFile( IrpContext, Fcb );
        }
    }

    //
    //  Post the request if we got CANT_WAIT.
    //

    if (Status == STATUS_CANT_WAIT) {

        Status = CdFsdPostRequest( IrpContext, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        CdCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\resrcsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Cdfs Resource acquisition routines

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_RESRCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdAcquireForCache)
#pragma alloc_text(PAGE, CdAcquireForCreateSection)
#pragma alloc_text(PAGE, CdAcquireResource)
#pragma alloc_text(PAGE, CdNoopAcquire)
#pragma alloc_text(PAGE, CdNoopRelease)
#pragma alloc_text(PAGE, CdReleaseForCreateSection)
#pragma alloc_text(PAGE, CdReleaseFromCache)
#endif


BOOLEAN
CdAcquireResource (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE Resource,
    IN BOOLEAN IgnoreWait,
    IN TYPE_OF_ACQUIRE Type
    )

/*++

Routine Description:

    This is the single routine used to acquire file system resources.  It
    looks at the IgnoreWait flag to determine whether to try to acquire the
    resource without waiting.  Returning TRUE/FALSE to indicate success or
    failure.  Otherwise it is driven by the WAIT flag in the IrpContext and
    will raise CANT_WAIT on a failure.

Arguments:

    Resource - This is the resource to try and acquire.

    IgnoreWait - If TRUE then this routine will not wait to acquire the
        resource and will return a boolean indicating whether the resource was
        acquired.  Otherwise we use the flag in the IrpContext and raise
        if the resource is not acquired.

    Type - Indicates how we should try to get the resource.

Return Value:

    BOOLEAN - TRUE if the resource is acquired.  FALSE if not acquired and
        IgnoreWait is specified.  Otherwise we raise CANT_WAIT.

--*/

{
    BOOLEAN Wait = FALSE;
    BOOLEAN Acquired;
    PAGED_CODE();

    //
    //  We look first at the IgnoreWait flag, next at the flag in the Irp
    //  Context to decide how to acquire this resource.
    //

    if (!IgnoreWait && FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        Wait = TRUE;
    }

    //
    //  Attempt to acquire the resource either shared or exclusively.
    //

    switch (Type) {
        case AcquireExclusive:
        
            Acquired = ExAcquireResourceExclusiveLite( Resource, Wait );
            break;

        case AcquireShared:
            
            Acquired = ExAcquireResourceSharedLite( Resource, Wait );
            break;

        case AcquireSharedStarveExclusive:
            
            Acquired = ExAcquireSharedStarveExclusive( Resource, Wait );
            break;

        default:
        	Acquired = FALSE;
            ASSERT( FALSE );
    }

    //
    //  If not acquired and the user didn't specifiy IgnoreWait then
    //  raise CANT_WAIT.
    //

    if (!Acquired && !IgnoreWait) {

        CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    return Acquired;
}


BOOLEAN
CdAcquireForCache (
    IN PFCB Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer for synchronization.

Arguments:

    Fcb -  The pointer supplied as context to the cache initialization
           routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IoGetTopLevelIrp() == NULL);
    IoSetTopLevelIrp((PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    return ExAcquireResourceSharedLite( Fcb->Resource, Wait );
}


VOID
CdReleaseFromCache (
    IN PFCB Fcb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a virtual file.  It is subsequently called by the Lazy Writer to release
    a resource acquired above.

Arguments:

    Fcb -  The pointer supplied as context to the cache initialization
           routine.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);
    IoSetTopLevelIrp( NULL );
    
    ExReleaseResourceLite( Fcb->Resource );
}


BOOLEAN
CdNoopAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Vcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    TRUE

--*/

{
    PAGED_CODE();
    return TRUE;
}


VOID
CdNoopRelease (
    IN PVOID Fcb
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Vcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    PAGED_CODE();
}


VOID
CdAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This is the callback routine for MM to use to acquire the file exclusively.

Arguments:

    FileObject - File object for a Cdfs stream.

Return Value:

    None

--*/

{
    PAGED_CODE();

    
    //
    //  Get the Fcb resource exclusively.
    //

    ExAcquireResourceExclusiveLite( &((PFCB) FileObject->FsContext)->FcbNonpaged->FcbResource,
                                TRUE );
                                
    //
    //  Take the File resource shared.  We need this later on when MM calls 
    //  QueryStandardInfo to get the file size.  
    //
    //  If we don't use StarveExclusive,  then we can get wedged behind an 
    //  exclusive waiter who is waiting on someone else holding it shared in the 
    //  read->initializecachemap path (which calls createsection) who is in turn 
    //  waiting on us to finish the create section.
    //

    ExAcquireSharedStarveExclusive( ((PFCB) FileObject->FsContext)->Resource,
                                    TRUE );
}


VOID
CdReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This is the callback routine for MM to use to release a file acquired with
    the AcquireForCreateSection call above.

Arguments:

    FileObject - File object for a Cdfs stream.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Release the resources.
    //

    ExReleaseResourceLite( &((PFCB) FileObject->FsContext)->FcbNonpaged->FcbResource );
    ExReleaseResourceLite( ((PFCB) FileObject->FsContext)->Resource);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\volinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Cdfs called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_VOLINFO)

//
//  Local support routines
//

NTSTATUS
CdQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonQueryVolInfo)
#pragma alloc_text(PAGE, CdQueryFsAttributeInfo)
#pragma alloc_text(PAGE, CdQueryFsDeviceInfo)
#pragma alloc_text(PAGE, CdQueryFsSizeInfo)
#pragma alloc_text(PAGE, CdQueryFsVolumeInfo)
#endif


NTSTATUS
CdCommonQueryVolInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG Length;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;

    //
    //  Decode the file object and fail if this an unopened file object.
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    if (TypeOfOpen == UnopenedFileObject) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the Vcb for this volume.
    //

    CdAcquireVcbShared( IrpContext, Fcb->Vcb, FALSE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Vcb.
        //

        CdVerifyVcb( IrpContext, Fcb->Vcb );

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling fills up the output buffer
        //  if possible and returns true if it successfully filled the buffer
        //  and false if it couldn't wait for any I/O to complete.
        //

        switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsSizeInformation:

            Status = CdQueryFsSizeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsVolumeInformation:

            Status = CdQueryFsVolumeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsDeviceInformation:

            Status = CdQueryFsDeviceInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsAttributeInformation:

            Status = CdQueryFsAttributeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

    } finally {

        //
        //  Release the Vcb.
        //

        CdReleaseVcb( IrpContext, Fcb->Vcb );
    }

    //
    //  Complete the request if we didn't raise.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Fill in the data from the Vcb.
    //

    Buffer->VolumeCreationTime = *((PLARGE_INTEGER) &Vcb->VolumeDasdFcb->CreationTime);
    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;

    Buffer->SupportsObjects = FALSE;

    *Length -= FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] );

    //
    //  Check if the buffer we're given is long enough
    //

    if (*Length >= (ULONG) Vcb->Vpb->VolumeLabelLength) {

        BytesToCopy = Vcb->Vpb->VolumeLabelLength;

    } else {

        BytesToCopy = *Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = BytesToCopy;

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->VolumeLabel[0],
                       &Vcb->Vpb->VolumeLabel[0],
                       BytesToCopy );
    }

    *Length -= BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume size call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Fill in the output buffer.
    //

    Buffer->TotalAllocationUnits.QuadPart = LlSectorsFromBytes( Vcb->VolumeDasdFcb->AllocationSize.QuadPart );

    Buffer->AvailableAllocationUnits.QuadPart = 0;
    Buffer->SectorsPerAllocationUnit = 1;
    Buffer->BytesPerSector = SECTOR_SIZE;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Update the output buffer.
    //

    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;
    Buffer->DeviceType = FILE_DEVICE_CD_ROM;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_DEVICE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Fill out the fixed portion of the buffer.
    //

    Buffer->FileSystemAttributes = FILE_CASE_SENSITIVE_SEARCH |
				   FILE_READ_ONLY_VOLUME;

    if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        SetFlag( Buffer->FileSystemAttributes, FILE_UNICODE_ON_DISK );

        Buffer->MaximumComponentNameLength = 110;

    } else {

        Buffer->MaximumComponentNameLength = 221;
    }

    *Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName );

    //
    //  Make sure we can copy full unicode characters.
    //

    ClearFlag( *Length, 1 );

    //
    //  Determine how much of the file system name will fit.
    //

    if (*Length >= 8) {

        BytesToCopy = 8;

    } else {

        BytesToCopy = *Length;
        Status = STATUS_BUFFER_OVERFLOW;
    }

    *Length -= BytesToCopy;

    //
    //  Do the file system name.
    //

    Buffer->FileSystemNameLength = BytesToCopy;

    RtlCopyMemory( &Buffer->FileSystemName[0], L"CDFS", BytesToCopy );

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\verfysup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements the Cdfs Verification routines.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_VERFYSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdVerifyFcbOperation)
#pragma alloc_text(PAGE, CdVerifyVcb)
#endif


NTSTATUS
CdPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceToVerify
    )

/*++

Routine Description:

    This routines performs an IoVerifyVolume operation and takes the
    appropriate action.  If the verify is successful then we send the originating
    Irp off to an Ex Worker Thread.  This routine is called from the exception handler.

    No file system resources are held when this routine is called.

Arguments:

    Irp - The irp to send off after all is well and done.

    Device - The real device needing verification.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Check if this Irp has a status of Verify required and if it does
    //  then call the I/O system to do a verify.
    //
    //  Skip the IoVerifyVolume if this is a mount or verify request
    //  itself.  Trying a recursive mount will cause a deadlock with
    //  the DeviceObject->DeviceLock.
    //

    if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
        ((IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME) ||
         (IrpContext->MinorFunction == IRP_MN_VERIFY_VOLUME))) {

        return CdFsdPostRequest( IrpContext, Irp );
    }

    //
    //  Extract a pointer to the Vcb from the VolumeDeviceObject.
    //  Note that since we have specifically excluded mount,
    //  requests, we know that IrpSp->DeviceObject is indeed a
    //  volume device object.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    Vcb = &CONTAINING_RECORD( IrpSp->DeviceObject,
                              VOLUME_DEVICE_OBJECT,
                              DeviceObject )->Vcb;
    try {

        BOOLEAN AllowRawMount = FALSE;

        //
        //  We will allow Raw to mount this volume if we were doing a
        //  an absolute DASD open.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
            (IrpSp->FileObject->FileName.Length == 0) &&
            (IrpSp->FileObject->RelatedFileObject == NULL)) {

            AllowRawMount = TRUE;
        }

        //
        //  Send down the verify FSCTL.  Note that this is sent to the
        //  currently mounted volume,  which may not be this one.
        //

        Status = IoVerifyVolume( DeviceToVerify, AllowRawMount );

        //
        //  Acquire the Vcb so we're working with a stable VcbCondition.
        //
        
        CdAcquireVcbShared( IrpContext, Vcb, FALSE);
        
        //
        //  If the verify operation completed it will return
        //  either STATUS_SUCCESS or STATUS_WRONG_VOLUME, exactly.
        //
        //  If CdVerifyVolume encountered an error during
        //  processing, it will return that error.  If we got
        //  STATUS_WRONG_VOLUME from the verify, and our volume
        //  is now mounted, commute the status to STATUS_SUCCESS.
        //

        if ((Status == STATUS_WRONG_VOLUME) &&
            (Vcb->VcbCondition == VcbMounted)) {

            Status = STATUS_SUCCESS;
        }
        else if ((STATUS_SUCCESS == Status) && (Vcb->VcbCondition != VcbMounted))  {

            //
            //  If the verify succeeded,  but our volume is not mounted,
            //  then some other volume is on the device. 
            //

            Status = STATUS_WRONG_VOLUME;
        } 
        
        //
        //  Do a quick unprotected check here.  The routine will do
        //  a safe check.  After here we can release the resource.
        //  Note that if the volume really went away, we will be taking
        //  the Reparse path.
        //

        //
        //  If the device might need to go away then call our dismount routine.
        //

        if (((Vcb->VcbCondition == VcbNotMounted) ||
             (Vcb->VcbCondition == VcbInvalid) ||
             (Vcb->VcbCondition == VcbDismountInProgress)) &&
            (Vcb->VcbReference <= CDFS_RESIDUAL_REFERENCE)) {

            CdReleaseVcb( IrpContext, Vcb);

            CdAcquireCdData( IrpContext );
            CdCheckForDismount( IrpContext, Vcb, FALSE );
            CdReleaseCdData( IrpContext );
        }
        else {

            CdReleaseVcb( IrpContext, Vcb);
        }

        //
        //  If this is a create and the verify succeeded then complete the
        //  request with a REPARSE status.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
            (IrpSp->FileObject->RelatedFileObject == NULL) &&
            ((Status == STATUS_SUCCESS) || (Status == STATUS_WRONG_VOLUME))) {

            Irp->IoStatus.Information = IO_REMOUNT;

            CdCompleteRequest( IrpContext, Irp, STATUS_REPARSE );
            Status = STATUS_REPARSE;
            Irp = NULL;
            IrpContext = NULL;

        //
        //  If there is still an error to process then call the Io system
        //  for a popup.
        //

        } else if ((Irp != NULL) && !NT_SUCCESS( Status )) {

            //
            //  Fill in the device object if required.
            //
            
            if (IoIsErrorUserInduced( Status ) ) {

                IoSetHardErrorOrVerifyDevice( Irp, DeviceToVerify );
            }

            CdNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  If there is still an Irp, send it off to an Ex Worker thread.
        //

        if (IrpContext != NULL) {

            Status = CdFsdPostRequest( IrpContext, Irp );
        }

    } except(CdExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the verify or raised
        //  an error ourselves.  So we'll abort the I/O request with
        //  the error status that we get back from the execption code.
        //

        Status = CdProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    return Status;
}


BOOLEAN
CdCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN Force
    )

/*++

Routine Description:

    This routine is called to check if a volume is ready for dismount.  This
    occurs when only file system references are left on the volume.

    If the dismount is not currently underway and the user reference count
    has gone to zero then we can begin the dismount.

    If the dismount is in progress and there are no references left on the
    volume (we check the Vpb for outstanding references as well to catch
    any create calls dispatched to the file system) then we can delete
    the Vcb.

Arguments:

    Vcb - Vcb for the volume to try to dismount.
    
    Force - Whether we will force this volume to be dismounted.

Return Value:

    BOOLEAN - True if the Vcb was not gone by the time this function finished,
        False if it was deleted.
        
    This is only a trustworthy indication to the caller if it had the vcb
    exclusive itself.

--*/

{
    BOOLEAN UnlockVcb = TRUE;
    BOOLEAN VcbPresent = TRUE;
    KIRQL SavedIrql;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    ASSERT_EXCLUSIVE_CDDATA;

    //
    //  Acquire and lock this Vcb to check the dismount state.
    //

    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Lets get rid of any pending closes for this volume.
    //

    CdFspClose( Vcb );

    CdLockVcb( IrpContext, Vcb );

    //
    //  If the dismount is not already underway then check if the
    //  user reference count has gone to zero or we are being forced
    //  to disconnect.  If so start the teardown on the Vcb.
    //

    if (Vcb->VcbCondition != VcbDismountInProgress) {

        if (Vcb->VcbUserReference <= CDFS_RESIDUAL_USER_REFERENCE || Force) {

            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;
            VcbPresent = CdDismountVcb( IrpContext, Vcb );
        }

    //
    //  If the teardown is underway and there are absolutely no references
    //  remaining then delete the Vcb.  References here include the
    //  references in the Vcb and Vpb.
    //

    } else if (Vcb->VcbReference == 0) {

        IoAcquireVpbSpinLock( &SavedIrql );

        //
        //  If there are no file objects and no reference counts in the
        //  Vpb we can delete the Vcb.  Don't forget that we have the
        //  last reference in the Vpb.
        //

        if (Vcb->Vpb->ReferenceCount == 1) {

            IoReleaseVpbSpinLock( SavedIrql );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;
            CdDeleteVcb( IrpContext, Vcb );
            VcbPresent = FALSE;

        } else {

            IoReleaseVpbSpinLock( SavedIrql );
        }
    }

    //
    //  Unlock the Vcb if still held.
    //

    if (UnlockVcb) {

        CdUnlockVcb( IrpContext, Vcb );
    }

    //
    //  Release any resources still acquired.
    //

    if (VcbPresent) {

        CdReleaseVcb( IrpContext, Vcb );
    }

    return VcbPresent;
}


BOOLEAN
CdMarkDevForVerifyIfVcbMounted(
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks to see if the specified Vcb is currently mounted on
    the device or not.  If it is,  it sets the verify flag on the device, if
    not then the state is noted in the Vcb.

Arguments:

    Vcb - This is the volume to check.

Return Value:

    TRUE if the device has been marked for verify here,  FALSE otherwise.

--*/

{
    BOOLEAN Marked = FALSE;
    KIRQL SavedIrql;

    IoAcquireVpbSpinLock( &SavedIrql );
    
    if (Vcb->Vpb->RealDevice->Vpb == Vcb->Vpb)  {

        CdMarkRealDevForVerify( Vcb->Vpb->RealDevice);
        Marked = TRUE;
    }
    else {

        //
        //  Flag this to avoid the VPB spinlock in future passes.
        //
        
        SetFlag( Vcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE);
    }
    
    IoReleaseVpbSpinLock( SavedIrql );

    return Marked;
}


VOID
CdVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks that the current Vcb is valid and currently mounted
    on the device.  It will raise on an error condition.

    We check whether the volume needs verification and the current state
    of the Vcb.

Arguments:

    Vcb - This is the volume to verify.

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK Iosb;
    ULONG MediaChangeCount = 0;
    BOOLEAN ForceVerify = FALSE;
    BOOLEAN DevMarkedForVerify;
    KIRQL SavedIrql;

    PAGED_CODE();

    //
    //  Fail immediately if the volume is in the progress of being dismounted
    //  or has been marked invalid.
    //

    if ((Vcb->VcbCondition == VcbInvalid) ||
        ((Vcb->VcbCondition == VcbDismountInProgress) && 
         (IrpContext->MajorFunction != IRP_MJ_CREATE))) {

        CdRaiseStatus( IrpContext, STATUS_FILE_INVALID );
    }
    
    if (FlagOn( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA ))  {
        
        //
        //  Capture the real device verify state.
        //
        
        DevMarkedForVerify = CdRealDevNeedsVerify( Vcb->Vpb->RealDevice);

        //
        //  If the media is removable and the verify volume flag in the
        //  device object is not set then we want to ping the device
        //  to see if it needs to be verified.
        //

        if (Vcb->VcbCondition != VcbMountInProgress) {

            Status = CdPerformDevIoCtrl( IrpContext,
                                         IOCTL_CDROM_CHECK_VERIFY,
                                         Vcb->TargetDeviceObject,
                                         &MediaChangeCount,
                                         sizeof(ULONG),
                                         FALSE,
                                         FALSE,
                                         &Iosb );

            if (Iosb.Information != sizeof(ULONG)) {
        
                //
                //  Be safe about the count in case the driver didn't fill it in
                //
        
                MediaChangeCount = 0;
            }

            //
            //  There are four cases when we want to do a verify.  These are the
            //  first three.
            //
            //  1. We are mounted,  and the device has become empty
            //  2. The device has returned verify required (=> DO_VERIFY_VOL flag is
            //     set, but could be due to hardware condition)
            //  3. Media change count doesn't match the one in the Vcb
            //
            
            if (((Vcb->VcbCondition == VcbMounted) &&
                 CdIsRawDevice( IrpContext, Status )) 
                ||
                (Status == STATUS_VERIFY_REQUIRED)
                ||
                (NT_SUCCESS(Status) &&
                 (Vcb->MediaChangeCount != MediaChangeCount))) {

                //
                //  If we are currently the volume on the device then it is our
                //  responsibility to set the verify flag.  If we're not on the device,
                //  then we shouldn't touch the flag.
                //

                if (!FlagOn( Vcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE) &&
                    !DevMarkedForVerify)  {

                    DevMarkedForVerify = CdMarkDevForVerifyIfVcbMounted( Vcb);
                }

                ForceVerify = TRUE;

                //
                //  NOTE that we no longer update the media change count here. We
                //  do so only when we've actually completed a verify at a particular
                //  change count value.
                //
            }
        }

        //
        //  This is the 4th verify case.
        //
        //  We ALWAYS force CREATE requests on unmounted volumes through the 
        //  verify path.  These requests could have been in limbo between
        //  IoCheckMountedVpb and us when a verify/mount took place and caused
        //  a completely different fs/volume to be mounted.  In this case the
        //  checks above may not have caught the condition,  since we may already
        //  have verified (wrong volume) and decided that we have nothing to do.
        //  We want the requests to be re routed to the currently mounted volume,
        //  since they were directed at the 'drive',  not our volume.
        //

        if (NT_SUCCESS( Status) && !ForceVerify && 
            (IrpContext->MajorFunction == IRP_MJ_CREATE))  {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->Irp);

            ForceVerify = (IrpSp->FileObject->RelatedFileObject == NULL) &&
                          ((Vcb->VcbCondition == VcbDismountInProgress) ||
                           (Vcb->VcbCondition == VcbNotMounted));

            //
            //  Note that we don't touch the device verify flag here.  If required
            //  it would have been caught and set by the first set of checks.
            //
        }

        //
        //  Raise the verify / error if neccessary.
        //
        
        if (ForceVerify || !NT_SUCCESS( Status)) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp,
                                          Vcb->Vpb->RealDevice );
           
            CdRaiseStatus( IrpContext, ForceVerify ? STATUS_VERIFY_REQUIRED : Status);
        }
    }

    //
    //  Based on the condition of the Vcb we'll either return to our
    //  caller or raise an error condition
    //

    switch (Vcb->VcbCondition) {

    case VcbNotMounted:

        IoSetHardErrorOrVerifyDevice( IrpContext->Irp, Vcb->Vpb->RealDevice );

        CdRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );
        break;

    case VcbInvalid:
    case VcbDismountInProgress :

        CdRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        break;
    }
}


BOOLEAN
CdVerifyFcbOperation (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to verify that the state of the Fcb is valid
    to allow the current operation to continue.  We use the state of the
    Vcb, target device and type of operation to determine this.

Arguments:

    IrpContext - IrpContext for the request.  If not present then we
        were called from the fast IO path.

    Fcb - Fcb to perform the request on.

Return Value:

    BOOLEAN - TRUE if the request can continue, FALSE otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVCB Vcb = Fcb->Vcb;
    PDEVICE_OBJECT RealDevice = Vcb->Vpb->RealDevice;
    PIRP Irp;

    PAGED_CODE();
    
    //
    //  Check that the fileobject has not been cleaned up.
    //
    
    if ( ARGUMENT_PRESENT( IrpContext ))  {

        PFILE_OBJECT FileObject;

        Irp = IrpContext->Irp;
        FileObject = IoGetCurrentIrpStackLocation( Irp)->FileObject;
        
        if ( FileObject && FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE))  {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Following FAT,  we allow certain operations even on cleaned up
            //  file objects.  Everything else,  we fail.
            //
            
            if ( (FlagOn(Irp->Flags, IRP_PAGING_IO)) ||
                 (IrpSp->MajorFunction == IRP_MJ_CLOSE ) ||
                 (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
                 ( (IrpSp->MajorFunction == IRP_MJ_READ) &&
                   FlagOn(IrpSp->MinorFunction, IRP_MN_COMPLETE) ) ) {

                NOTHING;

            } else {

                CdRaiseStatus( IrpContext, STATUS_FILE_CLOSED );
            }
        }
    }

    //
    //  Fail immediately if the volume is in the progress of being dismounted
    //  or has been marked invalid.
    //

    if ((Vcb->VcbCondition == VcbInvalid) ||
        (Vcb->VcbCondition == VcbDismountInProgress)) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            CdRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        }

        return FALSE;
    }

    //
    //  Always fail if the volume needs to be verified.
    //

    if (CdRealDevNeedsVerify( RealDevice)) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp,
                                          RealDevice );

            CdRaiseStatus( IrpContext, STATUS_VERIFY_REQUIRED );
        }

        return FALSE;

    //
    //
    //  All operations are allowed on mounted.
    //

    } else if ((Vcb->VcbCondition == VcbMounted) ||
               (Vcb->VcbCondition == VcbMountInProgress)) {

        return TRUE;

    //
    //  Fail all requests for fast Io on other Vcb conditions.
    //

    } else if (!ARGUMENT_PRESENT( IrpContext )) {

        return FALSE;

    //
    //  The remaining case is VcbNotMounted.
    //  Mark the device to be verified and raise WRONG_VOLUME.
    //

    } else if (Vcb->VcbCondition == VcbNotMounted) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp, RealDevice );
            CdRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );
        }

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
CdDismountVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called when all of the user references to a volume are
    gone.  We will initiate all of the teardown any system resources.

    If all of the references to this volume are gone at the end of this routine
    then we will complete the teardown of this Vcb and mark the current Vpb
    as not mounted.  Otherwise we will allocated a new Vpb for this device
    and keep the current Vpb attached to the Vcb.

Arguments:

    Vcb - Vcb for the volume to dismount.

Return Value:

    BOOLEAN - TRUE if we didn't delete the Vcb, FALSE otherwise.

--*/

{
    PVPB OldVpb;
    BOOLEAN VcbPresent = TRUE;
    KIRQL SavedIrql;

    BOOLEAN FinalReference;

    ASSERT_EXCLUSIVE_CDDATA;
    ASSERT_EXCLUSIVE_VCB( Vcb );

    CdLockVcb( IrpContext, Vcb );

    //
    //  We should only take this path once.
    //

    ASSERT( Vcb->VcbCondition != VcbDismountInProgress );

    //
    //  Mark the Vcb as DismountInProgress.
    //

    Vcb->VcbCondition = VcbDismountInProgress;

    if (Vcb->XASector != NULL) {

        ExFreePool( Vcb->XASector );
        Vcb->XASector = 0;
        Vcb->XADiskOffset = 0;
    }

    //
    //  Remove our reference to the internal Fcb's.  The Fcb's will then
    //  be removed in the purge path below.
    //

    if (Vcb->RootIndexFcb != NULL) {

        Vcb->RootIndexFcb->FcbReference -= 1;
        Vcb->RootIndexFcb->FcbUserReference -= 1;
    }

    if (Vcb->PathTableFcb != NULL) {

        Vcb->PathTableFcb->FcbReference -= 1;
        Vcb->PathTableFcb->FcbUserReference -= 1;
    }

    if (Vcb->VolumeDasdFcb != NULL) {

        Vcb->VolumeDasdFcb->FcbReference -= 1;
        Vcb->VolumeDasdFcb->FcbUserReference -= 1;
    }

    CdUnlockVcb( IrpContext, Vcb );

    //
    //  Purge the volume.
    //

    CdPurgeVolume( IrpContext, Vcb, TRUE );

    //
    //  Empty the delayed and async close queues.
    //

    CdFspClose( Vcb );

    OldVpb = Vcb->Vpb;

    //
    //  Remove the mount volume reference.
    //

    CdLockVcb( IrpContext, Vcb );
    Vcb->VcbReference -= 1;

    //
    //  Acquire the Vpb spinlock to check for Vpb references.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    //
    //  Remember if this is the last reference on this Vcb.  We incremented
    //  the count on the Vpb earlier so we get one last crack it.  If our
    //  reference has gone to zero but the vpb reference count is greater
    //  than zero then the Io system will be responsible for deleting the
    //  Vpb.
    //

    FinalReference = (BOOLEAN) ((Vcb->VcbReference == 0) &&
                                (OldVpb->ReferenceCount == 1));

    //
    //  There is a reference count in the Vpb and in the Vcb.  We have
    //  incremented the reference count in the Vpb to make sure that
    //  we have last crack at it.  If this is a failed mount then we
    //  want to return the Vpb to the IO system to use for the next
    //  mount request.
    //

    if (OldVpb->RealDevice->Vpb == OldVpb) {

        //
        //  If not the final reference then swap out the Vpb.  We must
        //  preserve the REMOVE_PENDING flag so that the device is
        //  not remounted in the middle of a PnP remove operation.
        //

        if (!FinalReference) {

            ASSERT( Vcb->SwapVpb != NULL );

            Vcb->SwapVpb->Type = IO_TYPE_VPB;
            Vcb->SwapVpb->Size = sizeof( VPB );
            Vcb->SwapVpb->RealDevice = OldVpb->RealDevice;

            Vcb->SwapVpb->RealDevice->Vpb = Vcb->SwapVpb;

            Vcb->SwapVpb->Flags = FlagOn( OldVpb->Flags, VPB_REMOVE_PENDING );

            IoReleaseVpbSpinLock( SavedIrql );

            //
            //  Indicate we used up the swap.
            //

            Vcb->SwapVpb = NULL;            

            CdUnlockVcb( IrpContext, Vcb );

        //
        //  We want to leave the Vpb for the IO system.  Mark it
        //  as being not mounted.  Go ahead and delete the Vcb as
        //  well.
        //

        } else {

            //
            //  Make sure to remove the last reference on the Vpb.
            //

            OldVpb->ReferenceCount -= 1;

            OldVpb->DeviceObject = NULL;
            ClearFlag( Vcb->Vpb->Flags, VPB_MOUNTED );
            ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );

            //
            //  Clear the Vpb flag so we know not to delete it.
            //

            Vcb->Vpb = NULL;

            IoReleaseVpbSpinLock( SavedIrql );
            CdUnlockVcb( IrpContext, Vcb );
            CdDeleteVcb( IrpContext, Vcb );
            VcbPresent = FALSE;
        }

    //
    //  Someone has already swapped in a new Vpb.  If this is the final reference
    //  then the file system is responsible for deleting the Vpb.
    //

    } else if (FinalReference) {

        //
        //  Make sure to remove the last reference on the Vpb.
        //

        OldVpb->ReferenceCount -= 1;

        IoReleaseVpbSpinLock( SavedIrql );
        CdUnlockVcb( IrpContext, Vcb );
        CdDeleteVcb( IrpContext, Vcb );
        VcbPresent = FALSE;

    //
    //  The current Vpb is no longer the Vpb for the device (the IO system
    //  has already allocated a new one).  We leave our reference in the
    //  Vpb and will be responsible for deleting it at a later time.
    //

    } else {

        IoReleaseVpbSpinLock( SavedIrql );
        CdUnlockVcb( IrpContext, Vcb );
    }

    //
    //  Let our caller know whether the Vcb is still present.
    //

    return VcbPresent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\strucsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Cdfs in-memory data structure manipulation
    routines

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_STRUCSUP)

//
//  Local macros
//

//
//  PFCB
//  CdAllocateFcbData (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdDeallocateFcbData (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  PFCB
//  CdAllocateFcbIndex (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdDeallocateFcbIndex (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  PFCB_NONPAGED
//  CdAllocateFcbNonpaged (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdDeallocateFcbNonpaged (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB_NONPAGED FcbNonpaged
//      );
//
//  PCCB
//  CdAllocateCcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdDeallocateCcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCCB Ccb
//      );
//

#define CdAllocateFcbData(IC) \
    FsRtlAllocatePoolWithTag( CdPagedPool, SIZEOF_FCB_DATA, TAG_FCB_DATA )

#define CdDeallocateFcbData(IC,F) \
    ExFreePool( F )

#define CdAllocateFcbIndex(IC) \
    FsRtlAllocatePoolWithTag( CdPagedPool, SIZEOF_FCB_INDEX, TAG_FCB_INDEX )

#define CdDeallocateFcbIndex(IC,F) \
    ExFreePool( F )

#define CdAllocateFcbNonpaged(IC) \
    ExAllocatePoolWithTag( CdNonPagedPool, sizeof( FCB_NONPAGED ), TAG_FCB_NONPAGED )

#define CdDeallocateFcbNonpaged(IC,FNP) \
    ExFreePool( FNP )

#define CdAllocateCcb(IC) \
    FsRtlAllocatePoolWithTag( CdPagedPool, sizeof( CCB ), TAG_CCB )

#define CdDeallocateCcb(IC,C) \
    ExFreePool( C )

//
//  Local structures
//

typedef struct _FCB_TABLE_ELEMENT {

    FILE_ID FileId;
    PFCB Fcb;

} FCB_TABLE_ELEMENT, *PFCB_TABLE_ELEMENT;

//
//  Local macros
//

//
//  VOID
//  CdInsertFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdDeleteFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//


#define CdInsertFcbTable(IC,F) {                                    \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.Fcb = (F);                                                 \
    _Key.FileId = (F)->FileId;                                      \
    RtlInsertElementGenericTable( &(F)->Vcb->FcbTable,              \
                                  &_Key,                            \
                                  sizeof( FCB_TABLE_ELEMENT ),      \
                                  NULL );                           \
}

#define CdDeleteFcbTable(IC,F) {                                    \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.FileId = (F)->FileId;                                      \
    RtlDeleteElementGenericTable( &(F)->Vcb->FcbTable, &_Key );     \
}

//
//  Local support routines
//

VOID
CdDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

PFCB_NONPAGED
CdCreateFcbNonpaged (
    IN PIRP_CONTEXT IrpContext
    );

VOID
CdDeleteFcbNonpaged (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB_NONPAGED FcbNonpaged
    );

RTL_GENERIC_COMPARE_RESULTS
CdFcbTableCompare (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Fid1,
    IN PVOID Fid2
    );

PVOID
CdAllocateFcbTable (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN CLONG ByteSize
    );

VOID
CdDeallocateFcbTable (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Buffer
    );

ULONG
CdTocSerial (
    IN PIRP_CONTEXT IrpContext,
    IN PCDROM_TOC CdromToc
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdAllocateFcbTable)
#pragma alloc_text(PAGE, CdCleanupIrpContext)
#pragma alloc_text(PAGE, CdCreateCcb)
#pragma alloc_text(PAGE, CdCreateFcb)
#pragma alloc_text(PAGE, CdCreateFcbNonpaged)
#pragma alloc_text(PAGE, CdCreateFileLock)
#pragma alloc_text(PAGE, CdCreateIrpContext)
#pragma alloc_text(PAGE, CdDeallocateFcbTable)
#pragma alloc_text(PAGE, CdDeleteCcb)
#pragma alloc_text(PAGE, CdDeleteFcb)
#pragma alloc_text(PAGE, CdDeleteFcbNonpaged)
#pragma alloc_text(PAGE, CdDeleteFileLock)
#pragma alloc_text(PAGE, CdDeleteVcb)
#pragma alloc_text(PAGE, CdFcbTableCompare)
#pragma alloc_text(PAGE, CdGetNextFcb)
#pragma alloc_text(PAGE, CdInitializeFcbFromFileContext)
#pragma alloc_text(PAGE, CdInitializeFcbFromPathEntry)
#pragma alloc_text(PAGE, CdInitializeStackIrpContext)
#pragma alloc_text(PAGE, CdInitializeVcb)
#pragma alloc_text(PAGE, CdLookupFcbTable)
#pragma alloc_text(PAGE, CdProcessToc)
#pragma alloc_text(PAGE, CdTeardownStructures)
#pragma alloc_text(PAGE, CdTocSerial)
#pragma alloc_text(PAGE, CdUpdateVcbFromVolDescriptor)
#endif


VOID
CdInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PCDROM_TOC CdromToc,
    IN ULONG TocLength,
    IN ULONG TocTrackCount,
    IN ULONG TocDiskFlags,
    IN ULONG BlockFactor,
    IN ULONG MediaChangeCount
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

    CdromToc - Buffer to hold table of contents.  NULL if TOC command not
        supported.

    TocLength - Byte count length of TOC.  We use this as the TOC length to
        return on a user query.

    TocTrackCount - Count of tracks in TOC.  Used to create pseudo files for
        audio disks.

    TocDiskFlags - Flag field to indicate the type of tracks on the disk.

    BlockFactor - Used to decode any multi-session information.

    MediaChangeCount - Initial media change count of the target device

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  We start by first zeroing out all of the VCB, this will guarantee
    //  that any stale data is wiped clean.
    //

    RtlZeroMemory( Vcb, sizeof( VCB ));

    //
    //  Set the proper node type code and node byte size.
    //

    Vcb->NodeTypeCode = CDFS_NTC_VCB;
    Vcb->NodeByteSize = sizeof( VCB );

    //
    //  Initialize the DirNotify structs.  FsRtlNotifyInitializeSync can raise.
    //

    InitializeListHead( &Vcb->DirNotifyList );
    FsRtlNotifyInitializeSync( &Vcb->NotifySync );
    
    //
    //  Pick up a VPB right now so we know we can pull this filesystem stack
    //  off of the storage stack on demand.  This can raise - if it does,  
    //  uninitialize the notify structures before returning.
    //
    
    try  {

        Vcb->SwapVpb = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                 sizeof( VPB ),
                                                 TAG_VPB );
    }
    finally {

        if (AbnormalTermination())  {
        
            FsRtlNotifyUninitializeSync( &Vcb->NotifySync );
        }
    }

    //
    //  Nothing beyond this point should raise.
    //

    RtlZeroMemory( Vcb->SwapVpb, sizeof( VPB ) );
    
    //
    //  Initialize the resource variable for the Vcb and files.
    //

    ExInitializeResourceLite( &Vcb->VcbResource );
    ExInitializeResourceLite( &Vcb->FileResource );
    ExInitializeFastMutex( &Vcb->VcbMutex );

    //
    //  Insert this Vcb record on the CdData.VcbQueue.
    //

    InsertHeadList( &CdData.VcbQueue, &Vcb->VcbLinks );

    //
    //  Set the Target Device Object and Vpb fields, referencing the
    //  Target device for the mount.
    //

    ObReferenceObject( TargetDeviceObject );
    Vcb->TargetDeviceObject = TargetDeviceObject;
    Vcb->Vpb = Vpb;

    //
    //  Set the removable media flag based on the real device's
    //  characteristics
    //

    if (FlagOn( Vpb->RealDevice->Characteristics, FILE_REMOVABLE_MEDIA )) {

        SetFlag( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA );
    }

    //
    //  Initialize the generic Fcb Table.
    //

    RtlInitializeGenericTable( &Vcb->FcbTable,
                               (PRTL_GENERIC_COMPARE_ROUTINE) CdFcbTableCompare,
                               (PRTL_GENERIC_ALLOCATE_ROUTINE) CdAllocateFcbTable,
                               (PRTL_GENERIC_FREE_ROUTINE) CdDeallocateFcbTable,
                               NULL );

    //
    //  Show that we have a mount in progress.
    //

    CdUpdateVcbCondition( Vcb, VcbMountInProgress);

    //
    //  Refererence the Vcb for two reasons.  The first is a reference
    //  that prevents the Vcb from going away on the last close unless
    //  dismount has already occurred.  The second is to make sure
    //  we don't go into the dismount path on any error during mount
    //  until we get to the Mount cleanup.
    //

    Vcb->VcbReference = 1 + CDFS_RESIDUAL_REFERENCE;

    //
    //  Update the TOC information in the Vcb.
    //

    Vcb->CdromToc = CdromToc;
    Vcb->TocLength = TocLength;
    Vcb->TrackCount = TocTrackCount;
    Vcb->DiskFlags = TocDiskFlags;

    //
    //  If this disk contains audio tracks only then set the audio flag.
    //

    if (TocDiskFlags == CDROM_DISK_AUDIO_TRACK) {

        SetFlag( Vcb->VcbState, VCB_STATE_AUDIO_DISK | VCB_STATE_CDXA );
    }

    //
    //  Set the block factor.
    //

    Vcb->BlockFactor = BlockFactor;

    //
    //  Set the media change count on the device
    //

    CdUpdateMediaChangeCount( Vcb, MediaChangeCount);
}


VOID
CdUpdateVcbFromVolDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PCHAR RawIsoVd OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform the final initialization of a Vcb from the
    volume descriptor on the disk.

Arguments:

    Vcb - Vcb for the volume being mounted.  We have already set the flags for the
        type of descriptor.

    RawIsoVd - If specified this is the volume descriptor to use to mount the
        volume.  Not specified for a raw disk.

Return Value:

    None

--*/

{
    ULONG Shift;
    ULONG StartingBlock;
    ULONG ByteCount;

    LONGLONG FileId = 0;

    PRAW_DIRENT RawDirent;
    PATH_ENTRY PathEntry;
    PCD_MCB_ENTRY McbEntry;

    BOOLEAN UnlockVcb = FALSE;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Copy the block size and compute the various block masks.
        //  Block size must not be larger than the sector size.  We will
        //  use a default of the CD physical sector size if we are not
        //  on a data-full disc.
        //
        //  This must always be set.
        //

        Vcb->BlockSize = ( ARGUMENT_PRESENT( RawIsoVd ) ?
                            CdRvdBlkSz( RawIsoVd, Vcb->VcbState ) :
                            SECTOR_SIZE );

        if ((Vcb->BlockSize > SECTOR_SIZE) || (0 == Vcb->BlockSize))  {

            CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
        }

        Vcb->BlocksPerSector = SECTOR_SIZE / Vcb->BlockSize;
        Vcb->BlockMask = Vcb->BlockSize - 1;
        Vcb->BlockInverseMask = ~Vcb->BlockMask;

        //
        //  Initialize the BlockToSectorShift and BlockToByte by assuming
        //  the block size is the same as the sector size.  Shift the
        //  blocks per sectors until it goes to zero.
        //

        Vcb->BlockToSectorShift = 0;
        Vcb->BlockToByteShift = SECTOR_SHIFT;

        Shift = Vcb->BlocksPerSector - 1;

        while (Shift != 0) {

            Vcb->BlockToSectorShift += 1;
            Vcb->BlockToByteShift -= 1;

            Shift >>= 1;
        }

        //
        //  If there is a volume descriptor then do the internal Fcb's and
        //  other Vcb fields.
        //

        if (ARGUMENT_PRESENT( RawIsoVd )) {

            //
            //  Create the path table Fcb and refererence it and the Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;

            Vcb->PathTableFcb = CdCreateFcb( IrpContext,
                                             *((PFILE_ID) &FileId),
                                             CDFS_NTC_FCB_PATH_TABLE,
                                             NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->PathTableFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  Compute the stream offset and size of this path table.
            //

            StartingBlock = CdRvdPtLoc( RawIsoVd, Vcb->VcbState );

            ByteCount = CdRvdPtSz( RawIsoVd, Vcb->VcbState );

            Vcb->PathTableFcb->StreamOffset = BytesFromBlocks( Vcb,
                                                               SectorBlockOffset( Vcb, StartingBlock ));

            Vcb->PathTableFcb->FileSize.QuadPart = (LONGLONG) (Vcb->PathTableFcb->StreamOffset +
                                                               ByteCount);

            Vcb->PathTableFcb->ValidDataLength.QuadPart = Vcb->PathTableFcb->FileSize.QuadPart;

            Vcb->PathTableFcb->AllocationSize.QuadPart = LlSectorAlign( Vcb->PathTableFcb->FileSize.QuadPart );

            //
            //  Now add the mapping information.
            //

            CdLockFcb( IrpContext, Vcb->PathTableFcb );

            CdAddInitialAllocation( IrpContext,
                                    Vcb->PathTableFcb,
                                    StartingBlock,
                                    Vcb->PathTableFcb->AllocationSize.QuadPart );

            CdUnlockFcb( IrpContext, Vcb->PathTableFcb );

            //
            //  Point to the file resource.
            //

            Vcb->PathTableFcb->Resource = &Vcb->FileResource;

            //
            //  Mark the Fcb as initialized and create the stream file for this.
            //

            SetFlag( Vcb->PathTableFcb->FcbState, FCB_STATE_INITIALIZED );

            CdCreateInternalStream( IrpContext, Vcb, Vcb->PathTableFcb );

            //
            //  Create the root index and reference it in the Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;
            Vcb->RootIndexFcb = CdCreateFcb( IrpContext,
                                             *((PFILE_ID) &FileId),
                                             CDFS_NTC_FCB_INDEX,
                                             NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->RootIndexFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  Create the File id by hand for this Fcb.
            //

            CdSetFidPathTableOffset( Vcb->RootIndexFcb->FileId, Vcb->PathTableFcb->StreamOffset );
            CdFidSetDirectory( Vcb->RootIndexFcb->FileId );

            //
            //  Create a pseudo path table entry so we can call the initialization
            //  routine for the directory.
            //

            RawDirent = (PRAW_DIRENT) CdRvdDirent( RawIsoVd, Vcb->VcbState );

            CopyUchar4( &PathEntry.DiskOffset, RawDirent->FileLoc );

            PathEntry.DiskOffset += RawDirent->XarLen;
            PathEntry.Ordinal = 1;
            PathEntry.PathTableOffset = Vcb->PathTableFcb->StreamOffset;

            CdInitializeFcbFromPathEntry( IrpContext,
                                          Vcb->RootIndexFcb,
                                          NULL,
                                          &PathEntry );

            //
            //  Create the stream file for the root directory.
            //

            CdCreateInternalStream( IrpContext, Vcb, Vcb->RootIndexFcb );

            //
            //  Now do the volume dasd Fcb.  Create this and reference it in the
            //  Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;

            Vcb->VolumeDasdFcb = CdCreateFcb( IrpContext,
                                              *((PFILE_ID) &FileId),
                                              CDFS_NTC_FCB_DATA,
                                              NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->VolumeDasdFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  The file size is the full disk.
            //

            StartingBlock = CdRvdVolSz( RawIsoVd, Vcb->VcbState );

            Vcb->VolumeDasdFcb->FileSize.QuadPart = LlBytesFromBlocks( Vcb, StartingBlock );

            Vcb->VolumeDasdFcb->AllocationSize.QuadPart =
            Vcb->VolumeDasdFcb->ValidDataLength.QuadPart = Vcb->VolumeDasdFcb->FileSize.QuadPart;

            //
            //  Now add the extent representing the volume 'by hand'.
            //

            CdLockFcb( IrpContext, Vcb->VolumeDasdFcb );

            McbEntry = Vcb->VolumeDasdFcb->Mcb.McbArray;

            McbEntry->FileOffset = 
            McbEntry->DiskOffset = 0;
            
            McbEntry->ByteCount = Vcb->VolumeDasdFcb->AllocationSize.QuadPart;
            
            McbEntry->DataBlockByteCount =
            McbEntry->TotalBlockByteCount = McbEntry->ByteCount;
            
            Vcb->VolumeDasdFcb->Mcb.CurrentEntryCount = 1;
    
            CdUnlockFcb( IrpContext, Vcb->VolumeDasdFcb );

            //
            //  Point to the file resource.
            //

            Vcb->VolumeDasdFcb->Resource = &Vcb->FileResource;

            Vcb->VolumeDasdFcb->FileAttributes = FILE_ATTRIBUTE_READONLY;

            //
            //  Mark the Fcb as initialized.
            //

            SetFlag( Vcb->VolumeDasdFcb->FcbState, FCB_STATE_INITIALIZED );

            //
            //  Check and see if this is an XA disk.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_ISO | VCB_STATE_JOLIET)
                && RtlEqualMemory( CdXaId,
                                   Add2Ptr( RawIsoVd, 0x400, PCHAR ),
                                   8 )) {

                SetFlag( Vcb->VcbState, VCB_STATE_CDXA );
            }

        //
        //  If this is a music disk then we want to mock this disk to make it
        //  look like ISO disk.  We will create a pseudo root directory in
        //  that case.
        //

        } else if (FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK )) {

            ULONG RootDirectorySize;

            //
            //  Create the path table Fcb and refererence it and the Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;

            Vcb->PathTableFcb = CdCreateFcb( IrpContext,
                                             *((PFILE_ID) &FileId),
                                             CDFS_NTC_FCB_PATH_TABLE,
                                             NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->PathTableFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  We only create a pseudo entry for the root.
            //

            Vcb->PathTableFcb->FileSize.QuadPart = (LONGLONG) (FIELD_OFFSET( RAW_PATH_ISO, DirId ) + 2);

            Vcb->PathTableFcb->ValidDataLength.QuadPart = Vcb->PathTableFcb->FileSize.QuadPart;

            Vcb->PathTableFcb->AllocationSize.QuadPart = LlSectorAlign( Vcb->PathTableFcb->FileSize.QuadPart );

            //
            //  Point to the file resource.
            //

            Vcb->PathTableFcb->Resource = &Vcb->FileResource;

            //
            //  Mark the Fcb as initialized and create the stream file for this.
            //

            SetFlag( Vcb->PathTableFcb->FcbState, FCB_STATE_INITIALIZED );

            CdCreateInternalStream( IrpContext, Vcb, Vcb->PathTableFcb );

            //
            //  Create the root index and reference it in the Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;
            Vcb->RootIndexFcb = CdCreateFcb( IrpContext,
                                             *((PFILE_ID) &FileId),
                                             CDFS_NTC_FCB_INDEX,
                                             NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->RootIndexFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  Create the File id by hand for this Fcb.
            //

            CdSetFidPathTableOffset( Vcb->RootIndexFcb->FileId, Vcb->PathTableFcb->StreamOffset );
            CdFidSetDirectory( Vcb->RootIndexFcb->FileId );

            //
            //  Create a pseudo path table entry so we can call the initialization
            //  routine for the directory.
            //

            RtlZeroMemory( &PathEntry, sizeof( PATH_ENTRY ));


            PathEntry.Ordinal = 1;
            PathEntry.PathTableOffset = Vcb->PathTableFcb->StreamOffset;

            CdInitializeFcbFromPathEntry( IrpContext,
                                          Vcb->RootIndexFcb,
                                          NULL,
                                          &PathEntry );

            //
            //  Set the sizes by hand for this Fcb.  It should have an entry for each track plus an
            //  entry for the root and parent.
            //

            RootDirectorySize = (Vcb->TrackCount + 2) * CdAudioDirentSize;
            RootDirectorySize = SectorAlign( RootDirectorySize );

            Vcb->RootIndexFcb->AllocationSize.QuadPart =
            Vcb->RootIndexFcb->ValidDataLength.QuadPart =
            Vcb->RootIndexFcb->FileSize.QuadPart = RootDirectorySize;

            SetFlag( Vcb->RootIndexFcb->FcbState, FCB_STATE_INITIALIZED );

            //
            //  Create the stream file for the root directory.
            //

            CdCreateInternalStream( IrpContext, Vcb, Vcb->RootIndexFcb );

            //
            //  Now do the volume dasd Fcb.  Create this and reference it in the
            //  Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;

            Vcb->VolumeDasdFcb = CdCreateFcb( IrpContext,
                                              *((PFILE_ID) &FileId),
                                              CDFS_NTC_FCB_DATA,
                                              NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->VolumeDasdFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  We won't allow raw reads on this Fcb so leave the size at
            //  zero.
            //

            //
            //  Point to the file resource.
            //

            Vcb->VolumeDasdFcb->Resource = &Vcb->FileResource;

            Vcb->VolumeDasdFcb->FileAttributes = FILE_ATTRIBUTE_READONLY;

            //
            //  Mark the Fcb as initialized.
            //

            SetFlag( Vcb->VolumeDasdFcb->FcbState, FCB_STATE_INITIALIZED );

            //
            //  We will store a hard-coded name in the Vpb and use the toc as
            //  the serial number.
            //

            Vcb->Vpb->VolumeLabelLength = CdAudioLabelLength;

            RtlCopyMemory( Vcb->Vpb->VolumeLabel,
                           CdAudioLabel,
                           CdAudioLabelLength );

            //
            //  Find the serial number for the audio disk.
            //

            Vcb->Vpb->SerialNumber = CdTocSerial( IrpContext, Vcb->CdromToc );

            //
            //  Set the ISO bit so we know how to treat the names.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_ISO );
        }
        
    } finally {

        if (UnlockVcb) { CdUnlockVcb( IrpContext, Vcb ); }
    }
}


VOID
CdDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to delete a Vcb which failed mount or has been
    dismounted.  The dismount code should have already removed all of the
    open Fcb's.  We do nothing here but clean up other auxilary structures.

Arguments:

    Vcb - Vcb to delete.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_EXCLUSIVE_CDDATA;
    ASSERT_EXCLUSIVE_VCB( Vcb );

    //
    //  Chuck the backpocket Vpb we kept just in case.
    //

    if (Vcb->SwapVpb) {

        ExFreePool( Vcb->SwapVpb );
    }
    
    //
    //  If there is a Vpb then we must delete it ourselves.
    //

    if (Vcb->Vpb != NULL) {

        ExFreePool( Vcb->Vpb );
    }

    //
    //  Dereference our target if we haven't already done so.
    //

    if (Vcb->TargetDeviceObject != NULL) {
    
        ObDereferenceObject( Vcb->TargetDeviceObject );
    }

    //
    //  Delete the XA Sector if allocated.
    //

    if (Vcb->XASector != NULL) {

        ExFreePool( Vcb->XASector );
    }

    //
    //  Remove this entry from the global queue.
    //

    RemoveEntryList( &Vcb->VcbLinks );

    //
    //  Delete the Vcb and File resources.
    //

    ExDeleteResourceLite( &Vcb->VcbResource );
    ExDeleteResourceLite( &Vcb->FileResource );

    //
    //  Delete the TOC if present.
    //

    if (Vcb->CdromToc != NULL) {

        ExFreePool( Vcb->CdromToc );
    }

    //
    //  Uninitialize the notify structures.
    //

    if (Vcb->NotifySync != NULL) {

        FsRtlNotifyUninitializeSync( &Vcb->NotifySync );
    }

    //
    //  Now delete the volume device object.
    //

    IoDeleteDevice( (PDEVICE_OBJECT) CONTAINING_RECORD( Vcb,
                                                        VOLUME_DEVICE_OBJECT,
                                                        Vcb ));

    return;
}


PFCB
CdCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_ID FileId,
    IN NODE_TYPE_CODE NodeTypeCode,
    OUT PBOOLEAN FcbExisted OPTIONAL
    )

/*++

Routine Description:

    This routine is called to find the Fcb for the given FileId.  We will
    look this up first in the Fcb table and if not found we will create
    an Fcb.  We don't initialize it or insert it into the FcbTable in this
    routine.

    This routine is called while the Vcb is locked.

Arguments:

    FileId - This is the Id for the target Fcb.

    NodeTypeCode - Node type for this Fcb if we need to create.

    FcbExisted - If specified, we store whether the Fcb existed.

Return Value:

    PFCB - The Fcb found in the table or created if needed.

--*/

{
    PFCB NewFcb;
    BOOLEAN LocalFcbExisted;

    PAGED_CODE();

    //
    //  Use the local boolean if one was not passed in.
    //

    if (!ARGUMENT_PRESENT( FcbExisted )) {

        FcbExisted = &LocalFcbExisted;
    }

    //
    //  Maybe this is already in the table.
    //

    NewFcb = CdLookupFcbTable( IrpContext, IrpContext->Vcb, FileId );

    //
    //  If not then create the Fcb is requested by our caller.
    //

    if (NewFcb == NULL) {

        //
        //  Allocate and initialize the structure depending on the
        //  type code.
        //

        switch (NodeTypeCode) {

        case CDFS_NTC_FCB_PATH_TABLE:
        case CDFS_NTC_FCB_INDEX:

            NewFcb = CdAllocateFcbIndex( IrpContext );

            RtlZeroMemory( NewFcb, SIZEOF_FCB_INDEX );

            NewFcb->NodeByteSize = SIZEOF_FCB_INDEX;

            InitializeListHead( &NewFcb->FcbQueue );

            break;

        case CDFS_NTC_FCB_DATA :

            NewFcb = CdAllocateFcbData( IrpContext );

            RtlZeroMemory( NewFcb, SIZEOF_FCB_DATA );

            NewFcb->NodeByteSize = SIZEOF_FCB_DATA;

            break;

        default:

            CdBugCheck( 0, 0, 0 );
        }

        //
        //  Now do the common initialization.
        //

        NewFcb->NodeTypeCode = NodeTypeCode;

        NewFcb->Vcb = IrpContext->Vcb;
        NewFcb->FileId = FileId;

        CdInitializeMcb( IrpContext, NewFcb );

        //
        //  Now create the non-paged section object.
        //

        NewFcb->FcbNonpaged = CdCreateFcbNonpaged( IrpContext );

        //
        //  Deallocate the Fcb and raise if the allocation failed.
        //

        if (NewFcb->FcbNonpaged == NULL) {

            ExFreePool( NewFcb );

            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        *FcbExisted = FALSE;

        //
        //  Initialize Advanced FCB Header fields
        //

        ExInitializeFastMutex( &NewFcb->FcbNonpaged->AdvancedFcbHeaderMutex );
        FsRtlSetupAdvancedHeader( &NewFcb->Header, 
                                  &NewFcb->FcbNonpaged->AdvancedFcbHeaderMutex );
    } else {

        *FcbExisted = TRUE;
    }

    return NewFcb;
}


VOID
CdInitializeFcbFromPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PPATH_ENTRY PathEntry
    )

/*++

Routine Description:

    This routine is called to initialize an Fcb for a directory from
    the path entry.  Since we only have a starting point for the directory,
    not the length, we can only speculate on the sizes.

    The general initialization is performed in CdCreateFcb.

Arguments:

    Fcb - Newly created Fcb for this stream.

    ParentFcb - Parent Fcb for this stream.  It may not be present.

    PathEntry - PathEntry for this Fcb in the Path Table.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Fill in the Index specific fields of the Fcb.
    //

    Fcb->StreamOffset = BytesFromBlocks( Fcb->Vcb,
                                         SectorBlockOffset( Fcb->Vcb, PathEntry->DiskOffset ));

    Fcb->Ordinal = PathEntry->Ordinal;

    //
    //  Initialize the common header in the Fcb.  The node type is already
    //  present.
    //

    Fcb->Resource = &Fcb->Vcb->FileResource;

    //
    //  Always set the sizes to one sector until we read the self-entry.
    //

    Fcb->AllocationSize.QuadPart =
    Fcb->FileSize.QuadPart =
    Fcb->ValidDataLength.QuadPart = SECTOR_SIZE;

    CdAddInitialAllocation( IrpContext,
                            Fcb,
                            PathEntry->DiskOffset,
                            SECTOR_SIZE );
    //
    //  State flags for this Fcb.
    //

    SetFlag( Fcb->FileAttributes,
             FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY );

    //
    //  Link into the other in-memory structures and into the Fcb table.
    //

    if (ParentFcb != NULL) {

        Fcb->ParentFcb = ParentFcb;

        InsertTailList( &ParentFcb->FcbQueue, &Fcb->FcbLinks );

        CdIncrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );
    }

    CdInsertFcbTable( IrpContext, Fcb );
    SetFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );

    return;
}


VOID
CdInitializeFcbFromFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb,
    IN PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to initialize an Fcb for a file from
    the file context.  We have looked up all of the dirents for this
    stream and have the full file size.  We will load the all of the allocation
    for the file into the Mcb now.

    The general initialization is performed in CdCreateFcb.

Arguments:

    Fcb - Newly created Fcb for this stream.

    ParentFcb - Parent Fcb for this stream.

    FileContext - FileContext for the file.

Return Value:

    None

--*/

{
    PDIRENT ThisDirent = &FileContext->InitialDirent->Dirent;
    PCOMPOUND_DIRENT CurrentCompoundDirent;

    LONGLONG CurrentFileOffset;
    ULONG CurrentMcbEntryOffset;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    CdLockFcb( IrpContext, Fcb );

    try {

        //
        //  Initialize the common header in the Fcb.  The node type is already
        //  present.
        //

        Fcb->Resource = &IrpContext->Vcb->FileResource;

        //
        //  Allocation occurs in block-sized units.
        //

        Fcb->FileSize.QuadPart =
        Fcb->ValidDataLength.QuadPart = FileContext->FileSize;

        Fcb->AllocationSize.QuadPart = LlBlockAlign( Fcb->Vcb, FileContext->FileSize );

        //
        //  Set the flags from the dirent.  We always start with the read-only bit.
        //

        SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_READONLY );
        if (FlagOn( ThisDirent->DirentFlags, CD_ATTRIBUTE_HIDDEN )) {

            SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
        }

        //
        //  Convert the time to NT time.
        //

        CdConvertCdTimeToNtTime( IrpContext,
                                 ThisDirent->CdTime,
                                 (PLARGE_INTEGER) &Fcb->CreationTime );

        //
        //  Set the flag indicating the type of extent.
        //

        if (ThisDirent->ExtentType != Form1Data) {

            if (ThisDirent->ExtentType == Mode2Form2Data) {

                SetFlag( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE );

            } else {

                SetFlag( Fcb->FcbState, FCB_STATE_DA_FILE );
            }

            Fcb->XAAttributes = ThisDirent->XAAttributes;
            Fcb->XAFileNumber = ThisDirent->XAFileNumber;
        }

        //
        //  Read through all of the dirents for the file until we find the last
        //  and add the allocation into the Mcb.
        //

        CurrentCompoundDirent = FileContext->InitialDirent;
        CurrentFileOffset = 0;
        CurrentMcbEntryOffset = 0;

        while (TRUE) {

            CdAddAllocationFromDirent( IrpContext,
                                       Fcb,
                                       CurrentMcbEntryOffset,
                                       CurrentFileOffset,
                                       &CurrentCompoundDirent->Dirent );

            //
            //  Break out if we are at the last dirent.
            //

            if (!FlagOn( CurrentCompoundDirent->Dirent.DirentFlags, CD_ATTRIBUTE_MULTI )) {

                break;
            }

            CurrentFileOffset += CurrentCompoundDirent->Dirent.DataLength;
            CurrentMcbEntryOffset += 1;

            //
            //  We better be able to find the next dirent.
            //

            if (!CdLookupNextDirent( IrpContext,
                                     ParentFcb,
                                     &CurrentCompoundDirent->DirContext,
                                     &FileContext->CurrentDirent->DirContext )) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            CurrentCompoundDirent = FileContext->CurrentDirent;

            CdUpdateDirentFromRawDirent( IrpContext,
                                         ParentFcb,
                                         &CurrentCompoundDirent->DirContext,
                                         &CurrentCompoundDirent->Dirent );
        }

        //
        //  Show that the Fcb is initialized.
        //

        SetFlag( Fcb->FcbState, FCB_STATE_INITIALIZED );

        //
        //  Link into the other in-memory structures and into the Fcb table.
        //

        Fcb->ParentFcb = ParentFcb;

        InsertTailList( &ParentFcb->FcbQueue, &Fcb->FcbLinks );

        CdIncrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );

        CdInsertFcbTable( IrpContext, Fcb );
        SetFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );

    } finally {

        CdUnlockFcb( IrpContext, Fcb );
    }

    return;
}


PCCB
CdCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine is called to allocate and initialize the Ccb structure.

Arguments:

    Fcb - This is the Fcb for the file being opened.

    Flags - User flags to set in this Ccb.

Return Value:

    PCCB - Pointer to the created Ccb.

--*/

{
    PCCB NewCcb;
    PAGED_CODE();

    //
    //  Allocate and initialize the structure.
    //

    NewCcb = CdAllocateCcb( IrpContext );

    RtlZeroMemory( NewCcb, sizeof( CCB ));

    //
    //  Set the proper node type code and node byte size
    //

    NewCcb->NodeTypeCode = CDFS_NTC_CCB;
    NewCcb->NodeByteSize = sizeof( CCB );

    //
    //  Set the initial value for the flags and Fcb
    //

    NewCcb->Flags = Flags;
    NewCcb->Fcb = Fcb;

    return NewCcb;
}


VOID
CdDeleteCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    )
/*++

Routine Description:

    This routine is called to cleanup and deallocate a Ccb structure.

Arguments:

    Ccb - This is the Ccb to delete.

Return Value:

    None

--*/

{
    PAGED_CODE();

    if (Ccb->SearchExpression.FileName.Buffer != NULL) {

        ExFreePool( Ccb->SearchExpression.FileName.Buffer );
    }

    CdDeallocateCcb( IrpContext, Ccb );
    return;
}


BOOLEAN
CdCreateFileLock (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine is called when we want to attach a file lock structure to the
    given Fcb.  It is possible the file lock is already attached.

    This routine is sometimes called from the fast path and sometimes in the
    Irp-based path.  We don't want to raise in the fast path, just return FALSE.

Arguments:

    Fcb - This is the Fcb to create the file lock for.

    RaiseOnError - If TRUE, we will raise on an allocation failure.  Otherwise we
        return FALSE on an allocation failure.

Return Value:

    BOOLEAN - TRUE if the Fcb has a filelock, FALSE otherwise.

--*/

{
    BOOLEAN Result = TRUE;
    PFILE_LOCK FileLock;

    PAGED_CODE();

    //
    //  Lock the Fcb and check if there is really any work to do.
    //

    CdLockFcb( IrpContext, Fcb );

    if (Fcb->FileLock != NULL) {

        CdUnlockFcb( IrpContext, Fcb );
        return TRUE;
    }

    Fcb->FileLock = FileLock =
        FsRtlAllocateFileLock( NULL, NULL );

    CdUnlockFcb( IrpContext, Fcb );

    //
    //  Return or raise as appropriate.
    //

    if (FileLock == NULL) {
         
        if (RaiseOnError) {

            ASSERT( ARGUMENT_PRESENT( IrpContext ));

            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        Result = FALSE;
    }

    return Result;
}


PIRP_CONTEXT
CdCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine is called to initialize an IrpContext for the current
    CDFS request.  We allocate the structure and then initialize it from
    the given Irp.

Arguments:

    Irp - Irp for this request.

    Wait - TRUE if this request is synchronous, FALSE otherwise.

Return Value:

    PIRP_CONTEXT - Allocated IrpContext.

--*/

{
    PIRP_CONTEXT NewIrpContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  The only operations a filesystem device object should ever receive
    //  are create/teardown of fsdo handles and operations which do not
    //  occur in the context of fileobjects (i.e., mount).
    //

    if (IrpSp->DeviceObject == CdData.FileSystemDeviceObject) {

        if (IrpSp->FileObject != NULL &&
            IrpSp->MajorFunction != IRP_MJ_CREATE &&
            IrpSp->MajorFunction != IRP_MJ_CLEANUP &&
            IrpSp->MajorFunction != IRP_MJ_CLOSE) {

            ExRaiseStatus( STATUS_INVALID_DEVICE_REQUEST );
        }

        ASSERT( IrpSp->FileObject != NULL ||
                
                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST &&
                 IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_INVALIDATE_VOLUMES) ||
                
                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME ) ||

                IrpSp->MajorFunction == IRP_MJ_SHUTDOWN );
    }

    //
    //  Look in our lookaside list for an IrpContext.
    //

    if (CdData.IrpContextDepth) {

        CdLockCdData();
        NewIrpContext = (PIRP_CONTEXT) PopEntryList( &CdData.IrpContextList );
        if (NewIrpContext != NULL) {

            CdData.IrpContextDepth--;
        }

        CdUnlockCdData();
    }

    if (NewIrpContext == NULL) {

        //
        //  We didn't get it from our private list so allocate it from pool.
        //

        NewIrpContext = FsRtlAllocatePoolWithTag( NonPagedPool, sizeof( IRP_CONTEXT ), TAG_IRP_CONTEXT );
    }

    RtlZeroMemory( NewIrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    NewIrpContext->NodeTypeCode = CDFS_NTC_IRP_CONTEXT;
    NewIrpContext->NodeByteSize = sizeof( IRP_CONTEXT );

    //
    //  Set the originating Irp field
    //

    NewIrpContext->Irp = Irp;

    //
    //  Copy RealDevice for workque algorithms.  We will update this in the Mount or
    //  Verify since they have no file objects to use here.
    //

    if (IrpSp->FileObject != NULL) {

        NewIrpContext->RealDevice = IrpSp->FileObject->DeviceObject;
    }

    //
    //  Locate the volume device object and Vcb that we are trying to access.
    //  This may be our filesystem device object.  In that case don't initialize
    //  the Vcb field.
    //

    if (IrpSp->DeviceObject != CdData.FileSystemDeviceObject) {

        NewIrpContext->Vcb =  &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;
    
    }

    //
    //  Major/Minor Function codes
    //

    NewIrpContext->MajorFunction = IrpSp->MajorFunction;
    NewIrpContext->MinorFunction = IrpSp->MinorFunction;

    //
    //  Set the wait parameter
    //

    if (Wait) {

        SetFlag( NewIrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    } else {

        SetFlag( NewIrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );
    }

    //
    //  return and tell the caller
    //

    return NewIrpContext;
}


VOID
CdCleanupIrpContext (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Post
    )

/*++

Routine Description:

    This routine is called to cleanup and possibly deallocate the Irp Context.
    If the request is being posted or this Irp Context is possibly on the
    stack then we only cleanup any auxilary structures.

Arguments:

    Post - TRUE if we are posting this request, FALSE if we are deleting
        or retrying this in the current thread.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  If we aren't doing more processing then deallocate this as appropriate.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING)) {

        //
        //  If this context is the top level CDFS context then we need to
        //  restore the top level thread context.
        //

        if (IrpContext->ThreadContext != NULL) {

            CdRestoreThreadContext( IrpContext );
        }

        //
        //  Deallocate the Io context if allocated.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

            CdFreeIoContext( IrpContext->IoContext );
        }

        //
        //  Deallocate the IrpContext if not from the stack.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ON_STACK )) {

            if (CdData.IrpContextDepth < CdData.IrpContextMaxDepth) {

                CdLockCdData();

                PushEntryList( &CdData.IrpContextList, (PSINGLE_LIST_ENTRY) IrpContext );
                CdData.IrpContextDepth++;

                CdUnlockCdData();

            } else {

                //
                //  We couldn't add this to our lookaside list so free it to
                //  pool.
                //

                ExFreePool( IrpContext );
            }
        }

    //
    //  Clear the appropriate flags.
    //

    } else if (Post) {

        //
        //  If this context is the top level CDFS context then we need to
        //  restore the top level thread context.
        //

        if (IrpContext->ThreadContext != NULL) {

            CdRestoreThreadContext( IrpContext );
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_POST );

    } else {

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY );
    }

    return;
}


VOID
CdInitializeStackIrpContext (
    OUT PIRP_CONTEXT IrpContext,
    IN PIRP_CONTEXT_LITE IrpContextLite
    )

/*++

Routine Description:

    This routine is called to initialize an IrpContext for the current
    CDFS request.  The IrpContext is on the stack and we need to initialize
    it for the current request.  The request is a close operation.

Arguments:

    IrpContext - IrpContext to initialize.

    IrpContextLite - Structure containing the details of this request.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Zero and then initialize the structure.
    //

    RtlZeroMemory( IrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    IrpContext->NodeTypeCode = CDFS_NTC_IRP_CONTEXT;
    IrpContext->NodeByteSize = sizeof( IRP_CONTEXT );

    //
    //  Note that this is from the stack.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ON_STACK );

    //
    //  Copy RealDevice for workque algorithms.
    //

    IrpContext->RealDevice = IrpContextLite->RealDevice;

    //
    //  The Vcb is found in the Fcb.
    //

    IrpContext->Vcb = IrpContextLite->Fcb->Vcb;

    //
    //  Major/Minor Function codes
    //

    IrpContext->MajorFunction = IRP_MJ_CLOSE;

    //
    //  Set the wait parameter
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    return;
}


VOID
CdTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB StartingFcb,
    OUT PBOOLEAN RemovedStartingFcb
    )

/*++

Routine Description:

    This routine is used to walk from some starting point in the Fcb tree towards
    the root.  It will remove the Fcb and continue walking up the tree until
    it finds a point where we can't remove an Fcb.

    We look at the following fields in the Fcb to determine whether we can
    remove this.

        1 - Handle count must be zero.
        2 - If directory then only the only reference can be for a stream file.
        3 - Reference count must either be zero or go to zero here.

    We return immediately if we are recursively entering this routine.

Arguments:

    StartingFcb - This is the Fcb node in the tree to begin with.  This Fcb
        must currently be acquired exclusively.

    RemovedStartingFcb - Address to store whether we removed the starting Fcb.

Return Value:

    None

--*/

{
    PVCB Vcb = StartingFcb->Vcb;
    PFCB CurrentFcb = StartingFcb;
    BOOLEAN AcquiredCurrentFcb = FALSE;
    PFCB ParentFcb;

    PAGED_CODE();

    *RemovedStartingFcb = FALSE;

    //
    //  If this is a recursive call to TearDownStructures we return immediately
    //  doing no operation.
    //

    if (FlagOn( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN )) {

        return;
    }

    SetFlag( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN );

    //
    //  Use a try-finally to safely clear the top-level field.
    //

    try {

        //
        //  Loop until we find an Fcb we can't remove.
        //

        do {

            //
            //  See if there is an internal stream we should delete.
            //  Only do this if it is the last reference on the Fcb.
            //

            if ((SafeNodeType( CurrentFcb ) != CDFS_NTC_FCB_DATA) &&
                (CurrentFcb->FcbUserReference == 0) &&
                (CurrentFcb->FileObject != NULL)) {

                //
                //  Go ahead and delete the stream file object.
                //

                CdDeleteInternalStream( IrpContext, CurrentFcb );
            }

            //
            //  If the reference count is non-zero then break.
            //

            if (CurrentFcb->FcbReference != 0) {

                break;
            }

            //
            //  It looks like we have a candidate for removal here.  We
            //  will need to acquire the parent, if present, in order to
            //  remove this from the parent prefix table.
            //

            ParentFcb = CurrentFcb->ParentFcb;

            if (ParentFcb != NULL) {

                CdAcquireFcbExclusive( IrpContext, ParentFcb, FALSE );
            }

            //
            //  Now lock the vcb.
            //

            CdLockVcb( IrpContext, Vcb );

            //
            //  Final check to see if the reference count is still zero.
            //

            if (CurrentFcb->FcbReference != 0) {

                CdUnlockVcb( IrpContext, Vcb );

                if (ParentFcb != NULL) {

                    CdReleaseFcb( IrpContext, ParentFcb );
                }

                break;
            }

            //
            //  If there is a parent then do the necessary cleanup for the parent.
            //

            if (ParentFcb != NULL) {

                CdRemovePrefix( IrpContext, CurrentFcb );
                RemoveEntryList( &CurrentFcb->FcbLinks );

                CdDecrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );
            }

            if (FlagOn( CurrentFcb->FcbState, FCB_STATE_IN_FCB_TABLE )) {

                CdDeleteFcbTable( IrpContext, CurrentFcb );
                ClearFlag( CurrentFcb->FcbState, FCB_STATE_IN_FCB_TABLE );

            }

            //
            //  Unlock the Vcb but hold the parent in order to walk up
            //  the tree.
            //

            CdUnlockVcb( IrpContext, Vcb );
            CdDeleteFcb( IrpContext, CurrentFcb );

            //
            //  Move to the parent Fcb.
            //

            CurrentFcb = ParentFcb;
            AcquiredCurrentFcb = TRUE;

        } while (CurrentFcb != NULL);

    } finally {

        //
        //  Release the current Fcb if we have acquired it.
        //

        if (AcquiredCurrentFcb && (CurrentFcb != NULL)) {

            CdReleaseFcb( IrpContext, CurrentFcb );
        }

        //
        //  Clear the teardown flag.
        //

        ClearFlag( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN );
    }

    *RemovedStartingFcb = (CurrentFcb != StartingFcb);
    return;
}


PFCB
CdLookupFcbTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_ID FileId
    )

/*++

Routine Description:

    This routine will look through the Fcb table looking for a matching
    entry.

Arguments:

    Vcb - Vcb for this volume.

    FileId - This is the key value to use for the search.

Return Value:

    PFCB - A pointer to the matching entry or NULL otherwise.

--*/

{
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Hit;
    PFCB ReturnFcb = NULL;

    PAGED_CODE();

    Key.FileId = FileId;

    Hit = (PFCB_TABLE_ELEMENT) RtlLookupElementGenericTable( &Vcb->FcbTable, &Key );

    if (Hit != NULL) {

        ReturnFcb = Hit->Fcb;
    }

    return ReturnFcb;

    UNREFERENCED_PARAMETER( IrpContext );
}


PFCB
CdGetNextFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    This routine will enumerate through all of the Fcb's in the Fcb table.

Arguments:

    Vcb - Vcb for this volume.

    RestartKey - This value is used by the table package to maintain
        its position in the enumeration.  It is initialized to NULL
        for the first search.

Return Value:

    PFCB - A pointer to the next fcb or NULL if the enumeration is
        completed

--*/

{
    PFCB Fcb;

    PAGED_CODE();

    Fcb = (PFCB) RtlEnumerateGenericTableWithoutSplaying( &Vcb->FcbTable, RestartKey );

    if (Fcb != NULL) {

        Fcb = ((PFCB_TABLE_ELEMENT)(Fcb))->Fcb;
    }

    return Fcb;
}


NTSTATUS
CdProcessToc (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PCDROM_TOC CdromToc,
    IN OUT PULONG Length,
    OUT PULONG TrackCount,
    OUT PULONG DiskFlags
    )

/*++

Routine Description:

    This routine is called to verify and process the TOC for this disk.
    We hide a data track for a CD+ volume.

Arguments:

    TargetDeviceObject - Device object to send TOC request to.

    CdromToc - Pointer to TOC structure.

    Length - On input this is the length of the TOC.  On return is the TOC
        length we will show to the user.

    TrackCount - This is the count of tracks for the TOC.  We use this
        when creating a pseudo directory for a music disk.

    DiskFlags - We return flags indicating what we know about this disk.

Return Value:

    NTSTATUS - The result of trying to read the TOC.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    ULONG CurrentTrack;
    ULONG LocalTrackCount;
    ULONG LocalTocLength;

    union {

        UCHAR BigEndian[2];
        USHORT Length;

    } BiasedTocLength;

    PTRACK_DATA Track;

    PAGED_CODE();

    //
    //  Go ahead and read the table of contents
    //

    Status = CdPerformDevIoCtrl( IrpContext,
                                 IOCTL_CDROM_READ_TOC,
                                 TargetDeviceObject,
                                 CdromToc,
                                 sizeof( CDROM_TOC ),
                                 FALSE,
                                 TRUE,
                                 &Iosb );

    //
    //  Nothing to process if this request fails.
    //

    if (Status != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Get the number of tracks and stated size of this structure.
    //

    CurrentTrack = 0;
    LocalTrackCount = CdromToc->LastTrack - CdromToc->FirstTrack + 1;
    LocalTocLength = PtrOffset( CdromToc, &CdromToc->TrackData[LocalTrackCount + 1] );

    //
    //  Get out if there is an immediate problem with the TOC.
    //

    if ((LocalTocLength > Iosb.Information) ||
        (CdromToc->FirstTrack > CdromToc->LastTrack)) {

        Status = STATUS_DISK_CORRUPT_ERROR;
        return Status;
    }

    //
    //  Walk through the individual tracks.  Stop at the first data track after
    //  any lead-in audio tracks.
    //

    do {

        //
        //  Get the next track.
        //

        Track = &CdromToc->TrackData[CurrentTrack];

        //
        //  If this is a data track then check if we have only seen audio tracks
        //  to this point.
        //

        if (FlagOn( Track->Control, TOC_DATA_TRACK )) {

            //
            //  If we have only seen audio tracks then assume this is a
            //  CD+ disk.  Hide the current data track and only return
            //  the previous audio tracks.  Set the disk type to be mixed
            //  data/audio.
            //

            if (FlagOn( *DiskFlags, CDROM_DISK_AUDIO_TRACK ) &&
                !FlagOn( *DiskFlags, CDROM_DISK_DATA_TRACK )) {

                //
                //  Remove one track from the TOC.
                //

                CdromToc->LastTrack -= 1;

                //
                //  Knock 2.5 minutes off the current track to
                //  hide the final leadin.
                //

                Track->Address[1] -= 2;
                Track->Address[2] += 30;

                if (Track->Address[2] < 60) {

                    Track->Address[1] -= 1;

                } else {

                    Track->Address[2] -= 60;
                }

                Track->TrackNumber = TOC_LAST_TRACK;

                //
                //  Set the disk type to mixed data/audio.
                //

                SetFlag( *DiskFlags, CDROM_DISK_DATA_TRACK );

                break;
            }

            //
            //  Set the flag to indicate data tracks present.
            //

            SetFlag( *DiskFlags, CDROM_DISK_DATA_TRACK );

        //
        //  If this is a audio track then set the flag indicating audio
        //  tracks.
        //

        } else {

            SetFlag( *DiskFlags, CDROM_DISK_AUDIO_TRACK );
        }

        //
        //  Set our index for the next track.
        //

        CurrentTrack += 1;

    } while (CurrentTrack < LocalTrackCount);

    //
    //  Set the length to point just past the last track we looked at.
    //

    *TrackCount = CurrentTrack;
    *Length = PtrOffset( CdromToc, &CdromToc->TrackData[CurrentTrack + 1] );
    BiasedTocLength.Length = (USHORT) *Length - 2;

    CdromToc->Length[0] = BiasedTocLength.BigEndian[1];
    CdromToc->Length[1] = BiasedTocLength.BigEndian[0];

    return Status;
}


//
//  Local support routine
//

VOID
CdDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to cleanup and deallocate an Fcb.  We know there
    are no references remaining.  We cleanup any auxilary structures and
    deallocate this Fcb.

Arguments:

    Fcb - This is the Fcb to deallcoate.

Return Value:

    None

--*/

{
    PVCB Vcb = NULL;
    PAGED_CODE();

    //
    //  Sanity check the counts.
    //

    ASSERT( Fcb->FcbCleanup == 0 );
    ASSERT( Fcb->FcbReference == 0 );

    //
    //  Release any Filter Context structures associated with this FCB
    //

    FsRtlTeardownPerStreamContexts( &Fcb->Header );

    //
    //  Start with the common structures.
    //

    CdUninitializeMcb( IrpContext, Fcb );

    CdDeleteFcbNonpaged( IrpContext, Fcb->FcbNonpaged );

    //
    //  Check if we need to deallocate the prefix name buffer.
    //

    if ((Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer != (PWCHAR) Fcb->FileNamePrefix.FileNameBuffer) &&
        (Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer != NULL)) {

        ExFreePool( Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer );
    }

    //
    //  Now look at the short name prefix.
    //

    if (Fcb->ShortNamePrefix != NULL) {

        ExFreePool( Fcb->ShortNamePrefix );
    }

    //
    //  Now do the type specific structures.
    //

    switch (Fcb->NodeTypeCode) {

    case CDFS_NTC_FCB_PATH_TABLE:
    case CDFS_NTC_FCB_INDEX:

        ASSERT( Fcb->FileObject == NULL );
        ASSERT( IsListEmpty( &Fcb->FcbQueue ));

        if (Fcb == Fcb->Vcb->RootIndexFcb) {

            Vcb = Fcb->Vcb;
            Vcb->RootIndexFcb = NULL;

        } else if (Fcb == Fcb->Vcb->PathTableFcb) {

            Vcb = Fcb->Vcb;
            Vcb->PathTableFcb = NULL;
        }

        CdDeallocateFcbIndex( IrpContext, Fcb );
        break;

    case CDFS_NTC_FCB_DATA :

        if (Fcb->FileLock != NULL) {

            FsRtlFreeFileLock( Fcb->FileLock );
        }

        FsRtlUninitializeOplock( &Fcb->Oplock );

        if (Fcb == Fcb->Vcb->VolumeDasdFcb) {

            Vcb = Fcb->Vcb;
            Vcb->VolumeDasdFcb = NULL;
        }

        CdDeallocateFcbData( IrpContext, Fcb );
    }

    //
    //  Decrement the Vcb reference count if this is a system
    //  Fcb.
    //

    if (Vcb != NULL) {

        InterlockedDecrement( &Vcb->VcbReference );
        InterlockedDecrement( &Vcb->VcbUserReference );
    }

    return;
}


//
//  Local support routine
//

PFCB_NONPAGED
CdCreateFcbNonpaged (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to create and initialize the non-paged portion
    of an Fcb.

Arguments:

Return Value:

    PFCB_NONPAGED - Pointer to the created nonpaged Fcb.  NULL if not created.

--*/

{
    PFCB_NONPAGED FcbNonpaged;

    PAGED_CODE();

    //
    //  Allocate the non-paged pool and initialize the various
    //  synchronization objects.
    //

    FcbNonpaged = CdAllocateFcbNonpaged( IrpContext );

    if (FcbNonpaged != NULL) {

        RtlZeroMemory( FcbNonpaged, sizeof( FCB_NONPAGED ));

        FcbNonpaged->NodeTypeCode = CDFS_NTC_FCB_NONPAGED;
        FcbNonpaged->NodeByteSize = sizeof( FCB_NONPAGED );

        ExInitializeResourceLite( &FcbNonpaged->FcbResource );
        ExInitializeFastMutex( &FcbNonpaged->FcbMutex );
    }

    return FcbNonpaged;
}


//
//  Local support routine
//

VOID
CdDeleteFcbNonpaged (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB_NONPAGED FcbNonpaged
    )

/*++

Routine Description:

    This routine is called to cleanup the non-paged portion of an Fcb.

Arguments:

    FcbNonpaged - Structure to clean up.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ExDeleteResourceLite( &FcbNonpaged->FcbResource );

    CdDeallocateFcbNonpaged( IrpContext, FcbNonpaged );

    return;
}


//
//  Local support routine
//

RTL_GENERIC_COMPARE_RESULTS
CdFcbTableCompare (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Fid1,
    IN PVOID Fid2
    )

/*++

Routine Description:

    This routine is the Cdfs compare routine called by the generic table package.
    If will compare the two File Id values and return a comparison result.

Arguments:

    FcbTable - This is the table being searched.

    Fid1 - First key value.

    Fid2 - Second key value.

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/

{
    FILE_ID Id1, Id2;
    PAGED_CODE();

    Id1 = *((FILE_ID UNALIGNED *) Fid1);
    Id2 = *((FILE_ID UNALIGNED *) Fid2);

    if (Id1.QuadPart < Id2.QuadPart) {

        return GenericLessThan;

    } else if (Id1.QuadPart > Id2.QuadPart) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }

    UNREFERENCED_PARAMETER( FcbTable );
}


//
//  Local support routine
//

PVOID
CdAllocateFcbTable (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    FcbTable - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    PAGED_CODE();

    return( FsRtlAllocatePoolWithTag( CdPagedPool, ByteSize, TAG_FCB_TABLE ));
}


//
//  Local support routine
//

VOID
CdDeallocateFcbTable (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine that deallocates memory

Arguments:

    FcbTable - Supplies the generic table being used

    Buffer - Supplies the buffer being deallocated

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool( Buffer );

    return;
    UNREFERENCED_PARAMETER( FcbTable );
}


//
//  Local support routine
//

ULONG
CdTocSerial (
    IN PIRP_CONTEXT IrpContext,
    IN PCDROM_TOC CdromToc
    )

/*++

Routine Description:

    This routine is called to generate a serial number for an audio disk.
    The number is based on the starting positions of the tracks.
    The following algorithm is used.

    If the number of tracks is <= 2 then initialize the serial number to the
    leadout block number.

    Then add the starting address of each track (use 0x00mmssff format).

Arguments:

    CdromToc - Valid table of contents to use for track information.

Return Value:

    ULONG - 32 bit serial number based on TOC.

--*/

{
    ULONG SerialNumber = 0;
    PTRACK_DATA ThisTrack;
    PTRACK_DATA LastTrack;

    PAGED_CODE();

    //
    //  Check if there are two tracks or fewer.
    //

    LastTrack = &CdromToc->TrackData[ CdromToc->LastTrack - CdromToc->FirstTrack + 1];
    ThisTrack = &CdromToc->TrackData[0];

    if (CdromToc->LastTrack - CdromToc->FirstTrack <= 1) {

        SerialNumber = (((LastTrack->Address[1] * 60) + LastTrack->Address[2]) * 75) + LastTrack->Address[3];

        SerialNumber -= (((ThisTrack->Address[1] * 60) + ThisTrack->Address[2]) * 75) + ThisTrack->Address[3];
    }

    //
    //  Now find the starting offset of each track and add to the serial number.
    //

    while (ThisTrack != LastTrack) {

        SerialNumber += (ThisTrack->Address[1] << 16);
        SerialNumber += (ThisTrack->Address[2] << 8);
        SerialNumber += ThisTrack->Address[3];
        ThisTrack += 1;
    }

    return SerialNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\sources.inc ===
#
# This sources file is included in every sources file for this
#  project

!if ("$(DS_BUILD)" != "")
# INCLUDES=$(INCLUDES);$(BASEDIR)\private\ds\src\inc
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\cdfs\workque.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    WorkQue.c

Abstract:

    This module implements the Work queue routines for the Cdfs File
    system.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_WORKQUE)

//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (2)

//
//  Local support routines
//

VOID
CdAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdFsdPostRequest)
#pragma alloc_text(PAGE, CdOplockComplete)
#pragma alloc_text(PAGE, CdPrePostIrp)
#endif


NTSTATUS
CdFsdPostRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enqueues the request packet specified by IrpContext to the
    work queue associated with the FileSystemDeviceObject.  This is a FSD
    routine.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp.

    Irp - I/O Request Packet.

Return Value:

    STATUS_PENDING

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Posting is a three step operation.  First lock down any buffers
    //  in the Irp.  Next cleanup the IrpContext for the post and finally
    //  add this to a workque.
    //

    CdPrePostIrp( IrpContext, Irp );

    CdAddToWorkque( IrpContext, Irp );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}


VOID
CdPrePostIrp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Case on the type of the operation.
    //

    switch (IrpContext->MajorFunction) {

    case IRP_MJ_CREATE :

        //
        //  If called from the oplock package then there is an
        //  Fcb to possibly teardown.  We will call the teardown
        //  routine and release the Fcb if still present.  The cleanup
        //  code in create will know not to release this Fcb because
        //  we will clear the pointer.
        //

        if ((IrpContext->TeardownFcb != NULL) &&
            *(IrpContext->TeardownFcb) != NULL) {

            CdTeardownStructures( IrpContext, *(IrpContext->TeardownFcb), &RemovedFcb );

            if (!RemovedFcb) {

                CdReleaseFcb( IrpContext, *(IrpContext->TeardownFcb) );
            }

            *(IrpContext->TeardownFcb) = NULL;
            IrpContext->TeardownFcb = NULL;
        }

        break;

    //
    //  We need to lock the user's buffer, unless this is an MDL-read,
    //  in which case there is no user buffer.
    //

    case IRP_MJ_READ :

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            CdLockUserBuffer( IrpContext, IrpSp->Parameters.Read.Length );
        }

        break;

    //
    //  We also need to check whether this is a query file operation.
    //

    case IRP_MJ_DIRECTORY_CONTROL :

        if (IrpContext->MinorFunction == IRP_MN_QUERY_DIRECTORY) {

            CdLockUserBuffer( IrpContext, IrpSp->Parameters.QueryDirectory.Length );
        }

        break;
    }

    //
    //  Cleanup the IrpContext for the post.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
    CdCleanupIrpContext( IrpContext, TRUE );

    //
    //  Mark the Irp to show that we've already returned pending to the user.
    //

    IoMarkIrpPending( Irp );

    return;
}


VOID
CdOplockComplete (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the oplock package when an oplock break has
    completed, allowing an Irp to resume execution.  If the status in
    the Irp is STATUS_SUCCESS, then we queue the Irp to the Fsp queue.
    Otherwise we complete the Irp with the status in the Irp.

    If we are completing due to an error then check if there is any
    cleanup to do.

Arguments:

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    //
    //  Check on the return value in the Irp.  If success then we
    //  are to post this request.
    //

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        //
        //  Check if there is any cleanup work to do.
        //

        switch (IrpContext->MajorFunction) {

        case IRP_MJ_CREATE :

            //
            //  If called from the oplock package then there is an
            //  Fcb to possibly teardown.  We will call the teardown
            //  routine and release the Fcb if still present.  The cleanup
            //  code in create will know not to release this Fcb because
            //  we will clear the pointer.
            //

            if (IrpContext->TeardownFcb != NULL) {

                CdTeardownStructures( IrpContext, *(IrpContext->TeardownFcb), &RemovedFcb );

                if (!RemovedFcb) {

                    CdReleaseFcb( IrpContext, *(IrpContext->TeardownFcb) );
                }

                *(IrpContext->TeardownFcb) = NULL;
                IrpContext->TeardownFcb = NULL;
            }

            break;
        }

        //
        //  Insert the Irp context in the workqueue.
        //

        CdAddToWorkque( IrpContext, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        CdCompleteRequest( IrpContext, Irp, Irp->IoStatus.Status );
    }

    return;
}


//
//  Local support routine
//

VOID
CdAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PVOLUME_DEVICE_OBJECT Vdo;
    KIRQL SavedIrql;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Check if this request has an associated file object, and thus volume
    //  device object.
    //

    if (IrpSp->FileObject != NULL) {


        Vdo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                 VOLUME_DEVICE_OBJECT,
                                 DeviceObject );

        //
        //  Check to see if this request should be sent to the overflow
        //  queue.  If not, then send it off to an exworker thread.
        //

        KeAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );

        if (Vdo->PostedRequestCount > FSP_PER_DEVICE_THRESHOLD) {

            //
            //  We cannot currently respond to this IRP so we'll just enqueue it
            //  to the overflow queue on the volume.
            //

            InsertTailList( &Vdo->OverflowQueue,
                            &IrpContext->WorkQueueItem.List );

            Vdo->OverflowQueueCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

            return;

        } else {

            //
            //  We are going to send this Irp to an ex worker thread so up
            //  the count.
            //

            Vdo->PostedRequestCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );
        }
    }

    //
    //  Send it off.....
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          CdFspDispatch,
                          IrpContext );

    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsinit\dfsinit.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       dfsinit.c
//
//  Contents:   Code to force dfs volume initialization and validation
//
//  Classes:
//
//  Functions:  main
//
//  History:    March 24, 1994          Milans Created
//
//-----------------------------------------------------------------------------

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <dfsfsctl.h>

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle,
    IN      PUNICODE_STRING DfsName OPTIONAL);

NTSTATUS
DfsInitLocalPartitions();

//+----------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

void _cdecl main(
    int argc,
    char *argv[])
{
    NTSTATUS Status;

    Status = DfsInitLocalPartitions();

}

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle,
    IN      PUNICODE_STRING DfsName OPTIONAL
)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING LocalDfsName;

    RtlInitUnicodeString( &LocalDfsName, DFS_SERVER_NAME );

    InitializeObjectAttributes(
        &objectAttributes,
        &LocalDfsName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0
    );

    if (NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;

}


NTSTATUS
DfsInitLocalPartitions()
{
    NTSTATUS        status;
    HANDLE          dfsHandle;
    IO_STATUS_BLOCK ioStatus;
    WCHAR           wszBuffer[128];

    status = DfsOpen(&dfsHandle, NULL);

    if(NT_SUCCESS(status)) {

        status = NtFsControlFile(
            dfsHandle,
            NULL,       // Event,
            NULL,       // ApcRoutine,
            NULL,       // ApcContext,
            &ioStatus,
            FSCTL_DFS_INIT_LOCAL_PARTITIONS,
            NULL,
            0,
            NULL,
            0);

        NtClose( dfsHandle );

    }

    return( status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\debug\debug.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              30-Dec-95   BruceFo     More cleanup, make suitable for DFS
//                                      project. Get rid of Win4 naming.
//
//----------------------------------------------------------------------------

#if DBG == 1

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>

#include "debug.h"

//////////////////////////////////////////////////////////////////////////////
// global variables. These could be local, but we want debuggers to be able
// to get at them. Use extern "C" to make them easier to find.

extern "C"
{
unsigned long DebugInfoLevel = DEF_INFOLEVEL;
unsigned long DebugInfoMask = 0xffffffff;
unsigned long DebugAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
}

//////////////////////////////////////////////////////////////////////////////
// local variables

static BOOL s_fCritSecInit = FALSE;
static BOOL s_fInfoLevelInit = FALSE;
static CRITICAL_SECTION s_csDebugPrint;
static CRITICAL_SECTION s_csMessageBuf;
static char g_szMessageBuf[2000];        // this is the message buffer

//////////////////////////////////////////////////////////////////////////////
// local functions

static int DebugInternalvprintf(const char *format, va_list arglist);
static int DebugInternalprintf(const char *format, ...);
static void DebugAssertInternalprintf(char const *pszfmt, ...);
static int PopUpError(char const* pszMsg, int iLine, char const* pszFile);

//////////////////////////////////////////////////////////////////////////////

static int DebugInternalvprintf(const char* format, va_list arglist)
{
    int ret;
    EnterCriticalSection(&s_csMessageBuf);
    ret = vsprintf(g_szMessageBuf, format, arglist);
    OutputDebugStringA(g_szMessageBuf);
    LeaveCriticalSection(&s_csMessageBuf);
    return ret;
}

static int DebugInternalprintf(const char* format, ...)
{
    int ret;
    va_list va;
    va_start(va, format);
    ret = DebugInternalvprintf(format, va);
    va_end(va);
    return ret;
}

static void DebugAssertInternalprintf(char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);
    Debugvprintf(DEB_FORCE, "Assert", pszfmt, va);
    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   DebugAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void DEBUGAPI
DebugAssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
    if (DebugAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();
        DebugAssertInternalprintf("%s File: %s Line: %u, thread id %d\n",
            szMessage, szFile, iLine, tid);
    }

    if (DebugAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);
        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (DebugAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}


//+------------------------------------------------------------
// Function:    DebugSetInfoLevel
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetInfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul = DebugInfoLevel;
    DebugInfoLevel = ulNewLevel;
    return ul;
}


//+------------------------------------------------------------
// Function:    DebugSetInfoMask
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetInfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul = DebugInfoMask;
    DebugInfoMask = ulNewMask;
    return ul;
}


//+------------------------------------------------------------
// Function:    DebugSetAssertLevel
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//-------------------------------------------------------------
unsigned long DEBUGAPI
DebugSetAssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul = DebugAssertLevel;
    DebugAssertLevel = ulNewLevel;
    return ul;
}


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

static int PopUpError(char const* szMsg, int iLine, char const* szFile)
{
    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char* pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);

    id = MessageBoxA(NULL,
                     szMsg,
                     szAssertCaption,
                     MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(NULL,
                             szMsg,
                             szAssertCaption,
                             MB_SETFOREGROUND
                                | MB_SERVICE_NOTIFICATION
                                | MB_TASKMODAL
                                | MB_ICONEXCLAMATION
                                | MB_OKCANCEL);
        }
    }

    return id;
}


//+------------------------------------------------------------
// Function:    Debugvprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void DEBUGAPI
Debugvprintf(
    unsigned long ulCompMask,
    char const *  pszComp,
    char const *  ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | DebugInfoLevel) & DebugInfoMask))
    {
        EnterCriticalSection(&s_csDebugPrint);

        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((DebugInfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                DebugInternalprintf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            DebugInternalvprintf(ppszfmt, pargs);
        }

        if (DebugInfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                printf("%d.%03d> %s: ", pid, tid, pszComp);
            }
            vprintf(ppszfmt, pargs);
        }

        LeaveCriticalSection(&s_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define DEBUGKEY "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Debug"

//+----------------------------------------------------------------------------
// Function:    DebugCheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void DEBUGAPI
DebugCheckInit(char * pInfoLevelString, unsigned long * pulInfoLevel)
{
    if (s_fInfoLevelInit) return;
    if (!s_fCritSecInit) DebugInitialize();
    HKEY hKey;
    LONG lRet = RegOpenKeyExA(HKEY_LOCAL_MACHINE, DEBUGKEY, 0, KEY_READ, &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(unsigned long);
        lRet = RegQueryValueExA(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);
        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = DEF_INFOLEVEL;
        }
        RegCloseKey(hKey);
    }
    s_fInfoLevelInit = TRUE;
}

//+----------------------------------------------------------------------------
// Function:    DebugInitialize
//
// Synopsis:    Performs debugging library initialization
//
//-----------------------------------------------------------------------------

void DebugInitialize(void)
{
    if (s_fCritSecInit) return;
    InitializeCriticalSection(&s_csMessageBuf);
    InitializeCriticalSection(&s_csDebugPrint);
    s_fCritSecInit = TRUE;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\h\dfsmcli.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfsmcli.c
//
//  Contents:   Client side helper functions for Dfs Manager
//              Administration RPC interface.
//
//  Functions:  DfsBindToDfsManager
//
//  History:    12-27-95        Milans Created.
//
//-----------------------------------------------------------------------------

#ifndef _DFSM_CLIENT_
#define _DFSM_CLIENT_

#ifdef __cplusplus
extern "C" {
#endif

//+----------------------------------------------------------------------------
//
//  Function:   DfsBindToDfsManager
//
//  Synopsis:   Binds to the Dfs Manager's Admin RPC interface.
//
//  Arguments:  [pwszEntryPath] -- The EntryPath of the volume that needs to
//                      be administered.
//
//  Returns:    TRUE if success, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsBindToDfsManager(
    LPCWSTR pwszEntryPath);

#ifdef __cplusplus
}
#endif

#endif // _DFSM_CLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\debug\debug.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       debug.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              30-Dec-95   BruceFo     More cleanup, make suitable for DFS
//                                      project. Get rid of Win4 naming.
//
//  NOTE: you must call the DebugInitialize() API before calling any other
//  APIs!
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>      // for vsprintf
#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)
#define UNREFERENCED_PARM(x)    (x)

#if DBG == 1

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#ifndef DEBUGAPI
    #define DEBUGAPI __stdcall
#endif

//
// The following APIs are public and may be called
//

void DEBUGAPI
DebugInitialize(
    void);

unsigned long DEBUGAPI
DebugSetInfoLevel(
    unsigned long ulNewLevel);

unsigned long DEBUGAPI
DebugSetInfoMask(
    unsigned long ulNewMask);

unsigned long DEBUGAPI
DebugSetAssertLevel(
    unsigned long ulNewLevel);

//
// The following APIs should never be called directly. They will be called
// via macros defined herein.
//

void DEBUGAPI
Debugvprintf(
    unsigned long ulCompMask,
    char const *pszComp,
    char const *ppszfmt,
    va_list ArgList);

void DEBUGAPI
DebugAssertEx(
    char const *pszFile,
    int iLine,
    char const *pszMsg);

void DEBUGAPI
DebugCheckInit(
    char* pInfoLevelString,
    unsigned long* InfoLevel);

//
// Public assertion macros
//

#define DebugAssert(x) (void)((x) || (DebugAssertEx(__FILE__, __LINE__, #x),0))
#define DebugVerify(x) DebugAssert(x)

//
// Debug print macros
//

#define DEB_ERROR               0x00000001      // exported error paths
#define DEB_WARN                0x00000002      // exported warnings
#define DEB_TRACE               0x00000004      // exported trace messages

#define DEB_DBGOUT              0x00000010      // Output to debugger
#define DEB_STDOUT              0x00000020      // Output to stdout

#define DEB_IERROR              0x00000100      // internal error paths
#define DEB_IWARN               0x00000200      // internal warnings
#define DEB_ITRACE              0x00000400      // internal trace messages

#define DEB_USER1               0x00010000      // User defined
#define DEB_USER2               0x00020000      // User defined
#define DEB_USER3               0x00040000      // User defined
#define DEB_USER4               0x00080000      // User defined
#define DEB_USER5               0x00100000      // User defined
#define DEB_USER6               0x00200000      // User defined
#define DEB_USER7               0x00400000      // User defined
#define DEB_USER8               0x00800000      // User defined
#define DEB_USER9               0x01000000      // User defined
#define DEB_USER10              0x02000000      // User defined
#define DEB_USER11              0x04000000      // User defined
#define DEB_USER12              0x08000000      // User defined
#define DEB_USER13              0x10000000      // User defined
#define DEB_USER14              0x20000000      // User defined
#define DEB_USER15              0x40000000      // User defined

#define DEB_NOCOMPNAME          0x80000000      // suppress component name

#define DEB_FORCE               0x7fffffff      // force message

#define ASSRT_MESSAGE           0x00000001      // Output a message
#define ASSRT_BREAK             0x00000002      // Int 3 on assertion
#define ASSRT_POPUP             0x00000004      // And popup message

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------

#ifndef DEF_INFOLEVEL
    #define DEF_INFOLEVEL 0
#endif

#ifdef __cplusplus

    #define DECLARE_INFOLEVEL(comp) \
        extern "C" unsigned long comp##InfoLevel = DEF_INFOLEVEL; \
        extern "C" char* comp##InfoLevelString = #comp;

    #define DECLARE_DEBUG(comp) \
        extern "C" unsigned long comp##InfoLevel;\
        extern "C" char* comp##InfoLevelString;\
        __inline void\
        comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...)\
        {\
            DebugCheckInit(comp##InfoLevelString, &comp##InfoLevel);\
            if (comp##InfoLevel & fDebugMask)\
            {\
                va_list va;\
                va_start(va, pszfmt);\
                Debugvprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
                va_end(va);\
            }\
        }\
        class comp##CDbgTrace\
        {\
        private:\
            unsigned long _ulFlags;\
            char const * const _pszName;\
        public:\
            comp##CDbgTrace(unsigned long ulFlags, char const * const pszName)\
            : _ulFlags(ulFlags), _pszName(pszName)\
            {\
                comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
            }\
            ~comp##CDbgTrace()\
            {\
                comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
            }\
        };

#else  // ! __cplusplus

    #define DECLARE_INFOLEVEL(comp) \
        extern unsigned long comp##InfoLevel = DEF_INFOLEVEL; \
        extern char* comp##InfoLevelString = #comp;

    #define DECLARE_DEBUG(comp) \
        extern unsigned long comp##InfoLevel;\
        extern char *comp##InfoLevelString;\
        __inline void\
        comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...)\
        {\
            DebugCheckInit(comp##InfoLevelString, &comp##InfoLevel);\
            if (comp##InfoLevel & fDebugMask)\
            {\
                va_list va;\
                va_start(va, pszfmt);\
                Debugvprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
                va_end(va);\
            }\
        }

#endif // ! __cplusplus

#else // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

#define DebugInitialize()

#define DebugAssert(x)  NULL
#define DebugVerify(x)  (x)

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\h\dfsmsrv.h ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfsmsrv.h
//
//  Contents:   Server side helper functions for Dfs Manager.
//
//  Classes:
//
//  Functions:  DfsManager --
//
//  History:    12-28-95        Milans Created
//
//-----------------------------------------------------------------------------

#ifndef _DFSM_SERVER_
#define _DFSM_SERVER_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define DFS_MANAGER_SERVER      0x1
#define DFS_MANAGER_FTDFS       0x2

//+----------------------------------------------------------------------------
//
//  Function:   DfsInitGlobals
//
//  Synopsis:   Initializes the Dfs Manager globals. This is to be used for
//              setup purposes only - it must be called before calling
//              DfsManagerCreateVolumeObject.
//
//  Arguments:  [wszDomain] -- Name of dfs root for which this Dfs Manager
//                      is being initialized.
//              [dwType] -- Type of Dfs Manager being initialized -
//                          DFS_MANAGER_SERVER or DFS_MANAGER_DOMAIN_DC
//
//  Returns:    [ERROR_SUCCESS] -- If init succeeded.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory initializing global variables
//
//-----------------------------------------------------------------------------

DWORD
DfsInitGlobals(
    LPWSTR wszDomain,
    DWORD dwType);

//+----------------------------------------------------------------------------
//
//  Function:   DfsManager
//
//  Synopsis:   Entry point for Dfs Manager.
//
//  Arguments:  [wszDomain] -- Name of dfs root for which this Dfs Manager
//                      is being instantiated.
//              [dwType] -- Type of Dfs Manager being instantiated -
//                          DFS_MANAGER_SERVER or DFS_MANAGER_DOMAIN_DC
//
//  Returns:    [ERROR_SUCCESS] -- If Dfs Manager started correctly.
//
//              [ERROR_OUTOFMEMORY] -- If globals could not be allocated.
//
//              Win32 error from reading the Dfs Volume Objects.
//
//              Win32 error from registering the RPC interface.
//
//              Win32 error from creating the knowledge sync thread.
//
//-----------------------------------------------------------------------------

DWORD
DfsManager(
    LPWSTR wszDomain,
    DWORD dwType);

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerCreateVolumeObject
//
//  Synopsis:   Bootstrap routine to create a volume object directly (ie,
//              without having to call DfsCreateChildVolume on a parent
//              volume)
//
//  Arguments:  [pwszObjectName] -- Name of the volume object.
//              [pwszPrefix] -- Entry Path of dfs volume.
//              [pwszServer] -- Name of server.
//              [pwszShare] -- Name of share.
//              [pwszComment] -- Comment for dfs volume.
//              [guidVolume] -- Id of dfs volume.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerCreateVolumeObject(
    IN LPWSTR   pwszObjectName,
    IN LPWSTR   pwszPrefix,
    IN LPWSTR   pwszServer,
    IN LPWSTR   pwszShare,
    IN LPWSTR   pwszComment,
    IN GUID     *guidVolume);

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerAddService
//
//  Synopsis:   Bootstrap routine for adding a service to an existing volume
//              object. Used to set up additional root servers in an FTDfs
//              setup.
//
//  Arguments:  [pwszFullObjectName] -- Name of the volume object.
//              [pwszServer] -- Name of server to add.
//              [pwszShare] -- Name of share.
//              [guidVolume] -- On successful return, id of volume.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerAddService(
    IN LPWSTR pwszFullObjectName,
    IN LPWSTR pwszServer,
    IN LPWSTR pwszShare,
    OUT GUID  *guidVolume);

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerRemoveService
//
//  Synopsis:   Bootstrap routine for removing a service from an existing
//              volume object. Used to remove root servers in an FTDfs
//              setup.
//
//  Arguments:  [pwszFullObjectName] -- Name of the volume object.
//              [pwszServer] -- Name of server to remove.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerRemoveService(
    IN LPWSTR pwszFullObjectName,
    IN LPWSTR pwszServer);

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerRemoveServiceForced
//
//  Synopsis:   Routine for removing a service from an existing
//              volume object. Used to remove root servers in an FTDfs
//              setup, even if the root is not available.
//
//  Arguments:  [pwszServer] -- Name of server to remove.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerRemoveServiceForced(
    IN LPWSTR pwszServer);

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerHandleKnowledgeInconsistency
//
//  Synopsis:   Routine to handle knowledge inconsistencies being reported by
//              Dfs clients.
//
//  Arguments:  [pBuffer] -- Pointer to marshalled Volume Verify Arg
//              [cbBuffer] -- size in bytes of pBuffer
//
//  Returns:    [STATUS_SUCCESS] -- Knowledge inconsistency fixed.
//
//              [STATUS_UNSUCCESSFUL] -- Unable to fix Knowledge inconsistency.
//                      Problem has been logged to event log.
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsManagerHandleKnowledgeInconsistency(
    PBYTE pBuffer,
    ULONG cbBuffer);

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerValidateLocalVolumes
//
//  Synopsis:   Validates the relation info of all local volumes with the
//              Dfs Root server
//
//  Arguments:  None
//
//  Returns:    TRUE if validation attempt succeeded, FALSE if could not
//              validate all local volumes
//
//-----------------------------------------------------------------------------

BOOLEAN
DfsManagerValidateLocalVolumes();

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerSetDCName
//
//  Synopsis:   Sets the DC we should first attempt to connect to.
//
//  Arguments:  [pwszDCName] -- Name of the DC
//
//  Returns:    ERROR_SUCCESS
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerSetDcName(
    IN LPWSTR pwszDCName);

VOID
LogWriteMessage(
    ULONG UniqueErrorCode,
    DWORD dwErr,
    ULONG nStrings,
    LPCWSTR *pwStr);


#ifdef __cplusplus
}
#endif

#endif // _DFSM_SERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\cldpstor.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       CLdpStor.hxx
//
//  Contents:   Implementation of classes derived from CStorage and
//              CEnumStorage that use an LDAP DS for persistent storage.
//
//              In addition to providing this, this class
//              maintains a global mapping from the Prefix property to
//              "object name" in an instance of CStorageDirectory. Thus, given
//              a Prefix, one can find the object path.
//
//              Note that this map from Prefix to object path has the
//              following restrictions:
//
//              o At process start time, all objects are "read in" and their
//                ReadIdProps() method called. This is needed to populate the
//                map.
//
//              o When a new object is created, its SetIdProps() method must
//                be called before it can be located via the map.
//
//              o Maps are many to 1 - many EntryPaths may map to the same
//                object. At no point in time can one try to map the same
//                EntryPath to many objects.
//
//  Classes:    CLdap
//              CLdapStorage
//              CLdapEnumDirectory
//
//  Functions:
//
//  History:    12-19-95        Milans created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <ntldap.h>

#include "marshal.hxx"
#include "winldap.h"
#include "dsgetdc.h"
#include "setup.hxx"
#include "ftsup.hxx"
#include "dfsmwml.h"
#include "cldap.hxx"
 
//
// Helper function prototypes
//

DWORD
GetDcName(
    IN LPCSTR DomainName OPTIONAL,
    IN DWORD RetryCount,
    OUT LPWSTR *DCName);

DWORD
GetConfigurationDN(
    LPWSTR *pwszDN);

DWORD
InitializeVolumeObject(
    PWSTR       pwszVolName,
    BOOLEAN     bInitVol,
    BOOLEAN     SyncRemoteServerName=FALSE);


INIT_LDAP_OBJECT_MARSHAL_INFO();
INIT_LDAP_PKT_MARSHAL_INFO();
INIT_LDAP_DFS_VOLUME_PROPERTIES_MARSHAL_INFO();

DWORD
ProcessSiteTable(
    PBYTE pData,
    ULONG cbData,
    ULONG Count,
    PUNICODE_STRING pustr);

extern PLDAP  pLdapConnection;

extern HANDLE hSyncEvent;


extern "C"
DWORD
DfsGetFtServersFromDs(
    PLDAP pLDAP,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR **List
    );


//
// The global instance of CLdap
//

CLdap *pDfsmLdap = NULL;


//+----------------------------------------------------------------------------
//
//  Function:   CLdap::CLdap
//
//  Synopsis:   Constructor for CLdap - Initializes the private Object table.
//
//  Arguments:  [wszDfsName] -- Name of the fault tolerant Dfs. Looks like
//                      "NtBuilds".
//              [pdwErr] -- On return, the result of initializing the instance
//
//  Returns:    Result returned in pdwErr argument:
//
//              [ERROR_SUCCESS] -- Successfully initialized
//
//              [ERROR_INSUFFICIENT_RESOURCES] -- Out of memory.
//
//-----------------------------------------------------------------------------

CLdap::CLdap(
    IN LPWSTR wszDfsName,
    OUT LPDWORD pdwErr)
{
    DWORD dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CLdap::+CLdap(0x%x)\n",
        this));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::CLdap()\n");
#endif

    _fDirty = FALSE;
    _cEntries = 0;
    _cRef = 0;
    ZeroMemory( &_ObjectTableId, sizeof(GUID) );
    _wszDfsName = NULL;
    _wszObjectDN = NULL;
    _cEntriesAllocated = 0;
    _ldapPkt.cLdapObjects = 0;
    _ldapPkt.rgldapObjects = NULL;
    _pBuffer = NULL;
    _RemoteServerList = NULL;

    if (pLdapConnection != NULL) {
        if (DfsSvcLdap)
            DbgPrint("CLdap::Cldap:ldap_unbind(pLdapConnection)\n");
        ldap_unbind(pLdapConnection);
    }
    pLdapConnection = NULL;

    if (!DfsInitializeUnicodePrefix(&_ObjectTable))
        dwErr = ERROR_OUTOFMEMORY;

    if (dwErr == ERROR_SUCCESS) {

        _wszDfsName = new WCHAR [ wcslen(wszDfsName) + 1 ];

        if (_wszDfsName != NULL)
            wcscpy(_wszDfsName, wszDfsName);
        else
            dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr == ERROR_SUCCESS)
        dwErr = GetConfigurationDN( &_wszObjectDN);

    *pdwErr = dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::~CLdap
//
//  Synopsis:   Destructor for CLdap - Deallocates the Object table and
//              deletes all the Object entries.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdap::~CLdap()
{
    PLDAP_OBJECT p;
    PNAME_PAGE pNamePage;
    PNAME_PAGE pNextPage;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CLdap::~CLdap(0x%x)\n",
        this));

    ASSERT( _cRef == 0 );

    _DestroyObjectTable();

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::~CLdap()\n");
#endif

    //
    // We destroy pages as we walk the list, so
    // we need to save the pNextPage before the deallocation.
    //
    for (pNamePage = _ObjectTable.NamePageList.pFirstPage;
            pNamePage != NULL;
                pNamePage = pNextPage
    ) {
        pNextPage = pNamePage->pNextPage;
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("CLdap::~CLdap:Releasing NamePage@0x%x\n", pNamePage);
#endif
        free(pNamePage);
    }

    if (_ldapPkt.rgldapObjects != NULL)
        delete [] _ldapPkt.rgldapObjects;

    if (_pBuffer != NULL)
        delete [] _pBuffer;

    if (_wszDfsName != NULL)
        delete [] _wszDfsName;

    if (_wszObjectDN != NULL)
        delete [] _wszObjectDN;

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::AddRef
//
//  Synopsis:   Increases the ref count on the in-memory Pkt. If the
//              refcount is going from 0 to 1, an attempt is made to refresh
//              the in-memory Pkt from the Ldap server.
//
//  Arguments:  None
//
//  Returns:
//
//-----------------------------------------------------------------------------


DWORD
CLdap::AddRef(BOOLEAN SyncRemoteServerName=FALSE)
{
    DWORD dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::AddRef()\n"));

    _cRef++;

    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("CLdap::AddRef: %d\n", _cRef);

    if (_cRef == 1) {
        dwErr = DfspConnectToLdapServer();
        if (dwErr == ERROR_SUCCESS && !_IsObjectTableUpToDate()) {
            dwErr = _ReadObjectTable();
            if (pDfsmStorageDirectory != NULL)
                delete pDfsmStorageDirectory;
            if (pDfsmSites != NULL) 
                delete pDfsmSites;
            pDfsmSites = new CSites(LDAP_VOLUMES_DIR SITE_ROOT, &dwErr);
            pDfsmStorageDirectory = new CStorageDirectory( &dwErr );
            DfsmMarkStalePktEntries();
            DfsmInitLocalPartitions();
            InitializeVolumeObject( DOMAIN_ROOT_VOL, TRUE, SyncRemoteServerName);
            DfsmFlushStalePktEntries();
            DfsmPktFlushCache();
        }
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::AddRef() exit %d\n", dwErr));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::Release
//
//  Synopsis:   Decrease the ref count on the in-memory Pkt. If the
//              refcount is going from 1 to 0, then attempt to flush the
//              Pkt to the ldap server, if something has changed.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

DWORD
CLdap::Release()
{
    DWORD dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::Release()\n"));

    if (_cRef > 0)
        _cRef--;

    if (DfsSvcVerbose & 0x80000000)
        DbgPrint("CLdap::Release: %d\n", _cRef);

    if (_cRef == 0)
        dwErr = Flush();

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::Release() exit\n"));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::Flush
//
//  Synopsis:   Flush the Pkt to the ldap server, if something has changed
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

DWORD
CLdap::Flush()
{
    DWORD dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::Flush()\n"));

    if (_fDirty) {
        dwErr = DfspConnectToLdapServer();
        if (dwErr == ERROR_SUCCESS) {
            dwErr = _FlushObjectTable();
            if (dwErr == ERROR_SUCCESS)
                _fDirty = FALSE;
        }
 
        if(dwErr != ERROR_SUCCESS) {
            //
            // Reset dfs
            //
            
            SetEvent(hSyncEvent);

        }
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::Flush() exit\n"));

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::CreateObject
//
//  Synopsis:   Creates a new object in the in-memory Pkt.
//
//  Arguments:  [wszObjectName] -- Name of object to create.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully created the object.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition.
//
//              [ERROR_ALREADY_EXISTS] -- An object with the given name
//                      already exists
//
//-----------------------------------------------------------------------------

DWORD CLdap::CreateObject(
    IN LPCWSTR wszObjectName)
{
    DWORD dwErr = ERROR_SUCCESS;
    PLDAP_OBJECT p;
    UNICODE_STRING ustrObject, ustrRemaining;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::CreateObject(%ws)\n", wszObjectName);
#endif

    RtlInitUnicodeString( &ustrObject, wszObjectName );

    p = (PLDAP_OBJECT) DfsFindUnicodePrefix(
                            &_ObjectTable,
                            &ustrObject,
                            &ustrRemaining );

    if (p == NULL || ustrRemaining.Length != 0) {

        p = (PLDAP_OBJECT) new BYTE [ sizeof(LDAP_OBJECT) +
                                        (wcslen(wszObjectName) + 1) *
                                            sizeof(WCHAR) ];

        if (p != NULL) {

            UNICODE_STRING ustrObjectName;

            RtlInitUnicodeString(&ustrObjectName, wszObjectName);

            p->wszObjectName = (PWCHAR) (p+1);

            wcscpy(p->wszObjectName, wszObjectName);

            p->cbObjectData = 0;

            p->pObjectData = NULL;

            if (DfsInsertUnicodePrefix(&_ObjectTable, &ustrObjectName, p)) {

                _cEntries++;

            } else {

                dwErr = ERROR_OUTOFMEMORY;

                delete p;

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_ALREADY_EXISTS;

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::CreateObject returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::DeleteObject
//
//  Synopsis:   Deletes an object from the in-memory Pkt.
//
//  Arguments:  [wszObjectName] -- Name of object to delete.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully created the object.
//
//              [ERROR_FILE_NOT_FOUND] -- Object not found in the Object Table
//
//-----------------------------------------------------------------------------

DWORD
CLdap::DeleteObject(
    IN LPWSTR wszObjectName)
{
    DWORD dwErr = ERROR_SUCCESS;
    PLDAP_OBJECT p;
    UNICODE_STRING ustrObject, ustrRemaining;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::DeleteObject(%ws)\n", wszObjectName);
#endif

    RtlInitUnicodeString( &ustrObject, wszObjectName );

    p = (PLDAP_OBJECT) DfsFindUnicodePrefix(
                            &_ObjectTable,
                            &ustrObject,
                            &ustrRemaining );

    if (p != NULL && ustrRemaining.Length == 0) {

        DfsRemoveUnicodePrefix( &_ObjectTable, &ustrObject );

        if (p->pObjectData != NULL)
            delete p->pObjectData;

        delete p;

        _cEntries--;

        dwErr = ERROR_SUCCESS;

    } else {

        dwErr = ERROR_FILE_NOT_FOUND;

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::DeleteObject returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::GetData
//
//  Synopsis:   Reads the data associated with an Object.
//
//  Arguments:  [wszObjectName] -- Name of Object.
//              [pcbObjectSize] -- Size of object data
//              [ppObjectData] -- On successful return, points to a newly
//                      allocated buffer containing the object data. Caller
//                      must free with the delete operator.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning object.
//
//              [ERROR_FILE_NOT_FOUND] -- Unable to find the named object.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition
//
//-----------------------------------------------------------------------------

DWORD CLdap::GetData(
    IN LPCWSTR wszObjectName,
    OUT LPDWORD pcbObjectSize,
    OUT PCHAR  *ppObjectData)
{
    DWORD dwErr;
    PLDAP_OBJECT p;
    UNICODE_STRING ustrObject, ustrRemaining;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::GetData(%ws,%d)\n", wszObjectName, *pcbObjectSize);
#endif

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::GetData(%ws)\n", wszObjectName));

    RtlInitUnicodeString( &ustrObject, wszObjectName );

    p = (PLDAP_OBJECT) DfsFindUnicodePrefix(
                            &_ObjectTable,
                            &ustrObject,
                            &ustrRemaining);

    if (p != NULL && ustrRemaining.Length == 0) {

        if (p->cbObjectData != 0) {

            *ppObjectData = new CHAR [p->cbObjectData];

            if (*ppObjectData != NULL) {

#if DBG
                if (DfsSvcVerbose)
                    DbgPrint("  CopyMemory(%d bytes)\n", p->cbObjectData);
#endif

                CopyMemory( *ppObjectData, p->pObjectData, p->cbObjectData );

                *pcbObjectSize = p->cbObjectData;

                dwErr = ERROR_SUCCESS;

            } else {

                dwErr = ERROR_OUTOFMEMORY;
            }

        } else {

            *pcbObjectSize = 0;

            *ppObjectData = NULL;

            dwErr = ERROR_SUCCESS;

        }

    } else {

        dwErr = ERROR_FILE_NOT_FOUND;

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::GetData exit %d\n", dwErr));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::GetData returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::PutData
//
//  Synopsis:   Updates the data associated with an object.
//
//  Arguments:  [wszObjectName] -- Name of Object.
//              [cbObjectSize] -- Size of object data
//              [pObjectData] -- Points to the buffer allocated for the
//                      object data.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning object.
//
//              [ERROR_FILE_NOT_FOUND] -- Unable to find the named object.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition
//
//-----------------------------------------------------------------------------

DWORD CLdap::PutData(
    IN LPWSTR wszObjectName,
    IN DWORD cbObjectSize,
    IN PCHAR pObjectData)
{

    DWORD dwErr = ERROR_SUCCESS;
    PLDAP_OBJECT p;
    UNICODE_STRING ustrObject, ustrRemaining;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::PutData(%ws,%d)\n", wszObjectName, cbObjectSize);
#endif

    RtlInitUnicodeString( &ustrObject, wszObjectName );

    p = (PLDAP_OBJECT) DfsFindUnicodePrefix(
                            &_ObjectTable,
                            &ustrObject,
                            &ustrRemaining);

    if (p != NULL && ustrRemaining.Length == 0) {

        if (p->cbObjectData >= cbObjectSize) {

            CopyMemory( p->pObjectData, pObjectData, cbObjectSize );

            p->cbObjectData = cbObjectSize;

        } else {

            if (p->pObjectData != NULL) {

                delete p->pObjectData;

                p->pObjectData = NULL;

                p->cbObjectData = 0;

            }

            p->pObjectData = new CHAR [cbObjectSize];

            if (p->pObjectData != NULL) {

                p->cbObjectData = cbObjectSize;

                CopyMemory( p->pObjectData, pObjectData, cbObjectSize );

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }


        }

    } else {

        dwErr = ERROR_FILE_NOT_FOUND;

    }

    if (!_fDirty && dwErr == ERROR_SUCCESS)
        _fDirty = TRUE;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::PutData returning %d\n", dwErr);
#endif

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::NextChild
//
//  Synopsis:   Given the name of an object, this method can be used to
//              enumerate the children of the object.
//
//  Arguments:  [wszObjectName] -- Name of child to enumerate
//              [ppCookie] -- On first call, *ppCookie should be NULL. On
//                      subsequent calls, call with the value returned by
//                      the previous call.
//
//  Returns:    Pointer to name of child if successful, NULL otherwise.
//
//-----------------------------------------------------------------------------

LPWSTR
CLdap::NextChild(
    IN LPWSTR wszObjectName,
    OUT PVOID *ppCookie)
{
    PLDAP_OBJECT pldapObject;
    UNICODE_STRING ustrObjectName;

    RtlInitUnicodeString(&ustrObjectName, wszObjectName);

    pldapObject = (PLDAP_OBJECT) DfsNextUnicodePrefixChild(
                                    &_ObjectTable,
                                    &ustrObjectName,
                                    ppCookie);

    if (pldapObject != NULL) {

        return( pldapObject->wszObjectName );

    } else {

        return( NULL );
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DfspConnectToLdapServer
//
//  Synopsis:   Connects to an Ldap server for the domain.
//
//  Arguments:  None
//
//  Returns:    Win32 result of attempt to connect
//
//-----------------------------------------------------------------------------

DWORD
DfspConnectToLdapServer()
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD cConnectRetry;
    LPWSTR ObjName = NULL;
    LPWSTR DcName = NULL;

    if (pLdapConnection != NULL)
        return dwErr;

    //
    // pLdapConnection is NULL
    //

    if (pwszDSMachineName != NULL) {
        dwErr = DfspLdapOpen(pwszDSMachineName, &pLdapConnection, &ObjName);
        DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR, 
                              DfspConnectToLdapServer_ERROR_DfspLdapOpen,
                              LOGSTATUS(dwErr));
        if (dwErr == ERROR_SUCCESS)
            goto Cleanup;
    }

    //
    // pLdapConnection is NULL
    //   AND we have no preconceived idea of a DC to go to.
    //
    for (cConnectRetry = 0;
            (cConnectRetry < 5) && (pLdapConnection == NULL);
                cConnectRetry++) {

        if (ObjName != NULL) {
            free(ObjName);
            ObjName = NULL;
        }
        if (DcName != NULL) {
            delete [] DcName;
            DcName = NULL;
        }

        dwErr = GetDcName( NULL, cConnectRetry, &DcName );


        if (DfsSvcLdap)
            DbgPrint("DfspConnectToLdapServer:%ws\n", &DcName[2]);

        if (dwErr == ERROR_SUCCESS)
            dwErr = DfspLdapOpen(&DcName[2], &pLdapConnection, &ObjName);

        if (DfsSvcLdap)
            DbgPrint("DfspConnectToLdapServer returned %d\n", dwErr);

        if (pLdapConnection == NULL) {
            if (DfsSvcLdap)
                DbgPrint("DfspConnectToLdapServer:sleep 15s\n");
            Sleep( 15 * 1000 );
        }

    }

Cleanup:

    if (ObjName != NULL)
        free(ObjName);

    if (DcName != NULL)
        delete [] DcName;

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::_IsObjectTableUpToDate
//
//  Synopsis:   Returns true if the in-memory copy of the Pkt is the same as
//              the one on the DS.
//
//  Arguments:  None
//
//  Returns:    TRUE if we are up-to-date with the DS, FALSE otherwise
//
//-----------------------------------------------------------------------------

BOOLEAN
CLdap::_IsObjectTableUpToDate()
{
    DWORD ldapErr;
    DWORD dwErr = ERROR_SUCCESS;
    PLDAPMessage pldapMsg = NULL;
    PLDAPMessage pldapEntry;
    LPWSTR rgszAttr[2];
    PLDAP_BERVAL *rgldapPktId;
    BOOLEAN fEqual = FALSE;
    int i;
    LPWSTR *newRemoteServerList = NULL;
    BOOLEAN ListsMatch = TRUE;

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::_IsObjectTableUpToDate()\n"));


    dwErr = DfsGetFtServersFromDs(pLdapConnection, NULL, _wszDfsName, &newRemoteServerList);

    if(dwErr != ERROR_SUCCESS) {
        goto exit;
    }

    if(_RemoteServerList) {
        i = 0;
        while(newRemoteServerList[i]) {
            if(!_RemoteServerList[i]) {
                ListsMatch = FALSE;
                break; //we've reached the end of one list
            } else if(wcscmp(newRemoteServerList[i], _RemoteServerList[i]) != 0) {
                ListsMatch = FALSE;
            }
            i++;
        }
        NetApiBufferFree(_RemoteServerList);
    }
    _RemoteServerList = newRemoteServerList;

    if(!ListsMatch) {
        goto exit;
    }

    rgszAttr[0] = L"pKTGuid";
    rgszAttr[1] = NULL;

    if (DfsSvcLdap)
        DbgPrint("CLdap::_IsObjectTableUpToDate:ldap_search(%ws)\n", rgszAttr[0]);

    ldapErr = ldap_search_sW(
                    pLdapConnection,            // LDAP connection
                    _wszObjectDN,                 // search DN
                    LDAP_SCOPE_BASE,             // search base
                    L"(objectClass=*)",           // Filter
                    rgszAttr,                    // Attributes
                    0,                           // Read Attributes and Value
                    &pldapMsg);                  // LDAP message

    DFSM_TRACE_ERROR_HIGH(ldapErr, ALL_ERROR, 
                          _IsObjectTableUpToDate_Error_ldap_search_sW,
                          LOGULONG(ldapErr));

    if (ldapErr == LDAP_SUCCESS) {

        pldapEntry = ldap_first_entry(
                        pLdapConnection,
                        pldapMsg);

        if (pldapEntry != NULL) {

            rgldapPktId = ldap_get_values_len(
                                pLdapConnection,
                                pldapEntry,
                                "pKTGuid");

            if (rgldapPktId != NULL) {

                if ((rgldapPktId[0]->bv_len == sizeof(GUID)) &&
                        RtlCompareMemory(
                            rgldapPktId[0]->bv_val,
                                &_ObjectTableId,
                                    sizeof(GUID)) == sizeof(GUID)) {

                    //
                    // We have an up-to-date Pkt
                    //

                    fEqual = TRUE;

                }

                ldap_value_free_len( rgldapPktId );

            }

        }

    }

exit:
    if (pldapMsg != NULL)
        ldap_msgfree(pldapMsg);

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::_IsObjectTableUpToDate() exit %d\n", fEqual));

    return( fEqual );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::_ReadObjectTable
//
//  Synopsis:   Reads the entire table of object data from the DS sever and
//              populates the in-memory prefix table with it.
//
//              Assumes that we have already connected to the DS server.
//
//  Arguments:  None
//
//  Returns:    Win32 error from reading DS data
//
//-----------------------------------------------------------------------------

DWORD
CLdap::_ReadObjectTable()
{

    DWORD ldapErr;
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS status;
    PLDAPMessage pldapMsg = NULL;
    PLDAPMessage pldapEntry;
    LPWSTR rgszAttr[3];
    PLDAP_BERVAL *rgldapPktBlob, pldapPktBlob;
    MARSHAL_BUFFER marshalBuffer;
    LDAP_PKT ldapPkt;
    ULONG i;

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::_ReadObjectTable()\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::_ReadObjectTable()\n");
#endif

    rgszAttr[0] = L"pKT";
    rgszAttr[1] = L"pKTGuid";
    rgszAttr[2] = NULL;


#if DBG
        if (DfsSvcVerbose)
            DbgPrint("Reading BLOB...\n");
#endif

    if (DfsSvcLdap)
        DbgPrint("CLdap::_ReadObjectTable:ldap_search(%ws and %ws)]\n", rgszAttr[0], rgszAttr[1]);

    ldapErr = ldap_search_sW(
                    pLdapConnection,            // LDAP connection
                    _wszObjectDN,                 // search DN
                    LDAP_SCOPE_BASE,             // search base
                    L"(objectClass=*)",           // Filter
                    rgszAttr,                    // Attributes
                    0,                           // Read Attributes and Value
                    &pldapMsg);                  // LDAP message

    DFSM_TRACE_ERROR_HIGH(ldapErr, ALL_ERROR, 
                          _ReadObjectTable_Error_ldap_search_sW,
                          LOGULONG(ldapErr));

    if (ldapErr == LDAP_SUCCESS) {

        pldapEntry = ldap_first_entry(
                        pLdapConnection,
                        pldapMsg);

        if (pldapEntry != NULL) {

            rgldapPktBlob = ldap_get_values_len(
                                pLdapConnection,
                                pldapEntry,
                                "pKT");

            if (rgldapPktBlob != NULL) {

                pldapPktBlob = rgldapPktBlob[0];

                if (pldapPktBlob->bv_len > sizeof(DWORD)) {

#if DBG
                    if (DfsSvcVerbose)
                        DbgPrint("Got BLOB of %d bytes\n", pldapPktBlob->bv_len);
#endif

                    MarshalBufferInitialize(
                        &marshalBuffer,
                        pldapPktBlob->bv_len - sizeof(DWORD),
                        pldapPktBlob->bv_val + sizeof(DWORD));

                    status = DfsRtlGet(&marshalBuffer, &MiLdapPkt, &ldapPkt);

                    //
                    // Cool, we now have a list of all the LDAP_OBJECT records. Go
                    // through each and insert it into the prefix table. Clean
                    // up the current _ObjectTable if needed
                    //

                    _DestroyObjectTable();
                    if (pDfsmStorageDirectory != NULL) {
                        delete pDfsmStorageDirectory;
                        pDfsmStorageDirectory = NULL;
                    }
                    if (pDfsmSites != NULL) {
                        delete pDfsmSites;
                        pDfsmSites = NULL;
                    }

                    if (NT_SUCCESS(status)) {

                        for (i = 0;
                                (i < ldapPkt.cLdapObjects) &&
                                    (dwErr == ERROR_SUCCESS);
                                        i++) {

                            dwErr = _InsertLdapObject(&ldapPkt.rgldapObjects[i]);

                            MarshalBufferFree(ldapPkt.rgldapObjects[i].wszObjectName);

                            MarshalBufferFree(ldapPkt.rgldapObjects[i].pObjectData);

                        }

                        //
                        // In case we errored out of the loop above, clean up the
                        // rest of the unmarshalled ldap objects
                        //

                        if (dwErr == ERROR_SUCCESS) {

                            _cEntries = ldapPkt.cLdapObjects;

                            _fDirty = FALSE;

                        } else {

                            for (; i < ldapPkt.cLdapObjects; i++) {

                                MarshalBufferFree(ldapPkt.rgldapObjects[i].wszObjectName);

                                MarshalBufferFree(ldapPkt.rgldapObjects[i].pObjectData);

                            }
                        }

                        //
                        // Free up the enclosing ldapPkt that we unmarshalled
                        //

                        MarshalBufferFree(ldapPkt.rgldapObjects);

                    } else {

                        dwErr = ERROR_INTERNAL_DB_CORRUPTION;

                    }

                } else if (pldapPktBlob->bv_len != sizeof(DWORD)) {

                    dwErr = ERROR_INTERNAL_DB_CORRUPTION;
                }

                //
                // Free up the ldap buffers used to retrieve the pkt
                //

                ldap_value_free_len( rgldapPktBlob );

                //
                // If successful so far, retrieve the pkt id
                //

                if (dwErr == ERROR_SUCCESS) {

                    rgldapPktBlob = ldap_get_values_len(
                                        pLdapConnection,
                                        pldapEntry,
                                        "pKTGuid");

                    if (rgldapPktBlob != NULL) {

                        pldapPktBlob = rgldapPktBlob[0];

                        if (pldapPktBlob->bv_len == sizeof(GUID)) {

                            CopyMemory(
                                &_ObjectTableId,
                                pldapPktBlob->bv_val,
                                sizeof(GUID));

                        } else {

                            dwErr = ERROR_INTERNAL_DB_CORRUPTION;

                        }

                        ldap_value_free_len( rgldapPktBlob );

                    } else {

                        //
                        //  why would ldap fail the ldap_get_values_len call?
                        //

                        IDfsVolInlineDebOut((
                            DEB_ERROR,
                            "ldap_get_values_len for %ws:%ws failed\n",
                            _wszObjectDN,
                            L"pKTGuid",
                            ldapErr));


                        dwErr = ERROR_OUTOFMEMORY;

                    }

                }

            } else {

                //
                // why would ldap fail the ldap_get_values_len call?
                //

                IDfsVolInlineDebOut((
                    DEB_ERROR,
                    "ldap_get_values_len for %ws:%ws failed\n",
                    _wszObjectDN,
                    L"pKT",
                    ldapErr));

                dwErr = ERROR_OUTOFMEMORY;

            }

        } else {

            //
            // why would ldap fail the ldap_first_entry call?
            //

            IDfsVolInlineDebOut((
                DEB_ERROR,
                "ldap_first_entry for %ws:%ws failed\n",
                _wszObjectDN,
                L"pKT",
                ldapErr));

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        IDfsVolInlineDebOut((
            DEB_ERROR,
            "ldap_search_s for %ws failed with ldap error %x\n",
            _wszObjectDN,
            ldapErr));

        dwErr = LdapMapErrorToWin32(ldapErr);

    }

    if (pldapMsg != NULL)
        ldap_msgfree( pldapMsg );

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::_ReadObjectTable() exit\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::_ReadObjectTable exit %d\n", dwErr);
#endif
    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::_FlushObjectTable
//
//  Synopsis:   Routine to marshall all the LDAP_OBJECTS resident in the
//              in-memory prefix table into a single blob and store it in
//              the DS.
//
//  Arguments:  None
//
//  Returns:    [ERROR_SUCCESS] -- Successfully flushed Pkt to DS.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition
//
//-----------------------------------------------------------------------------

DWORD
CLdap::_FlushObjectTable()
{

    DWORD ldapErr;
    DWORD dwErr = ERROR_SUCCESS, i, cbPkt;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    MARSHAL_BUFFER marshalBuffer;

    GUID idNewPkt;
    LDAP_BERVAL ldapVal, ldapIdVal;
    PLDAP_BERVAL rgldapVals[2], rgldapIdVals[2];
    LDAPModW ldapMod, ldapIdMod;
    PLDAPModW rgldapMods[3];

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::_FlushObjectTable()\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::_FlushObjectTable()\n");
#endif

    LDAPControlW    LazyCommitControl =
                    {
                        LDAP_SERVER_LAZY_COMMIT_OID_W,  // the control
                        { 0, NULL},                     // no associated data
                        FALSE                           // control isn't mandatory
                    };

    PLDAPControlW   ServerControls[2] =
                    {
                        &LazyCommitControl,
                        NULL
                    };
    //
    // No one should call _FlushObjectTable if the _ObjectTable is empty!
    //
    if( _cEntries == 0 )
        return ERROR_INVALID_PARAMETER;

    //
    // Allocate array of pointers to ldap objects if needed, or the current
    // one is too small.
    //
    if (_cEntries >= _cEntriesAllocated) {
        if (_ldapPkt.rgldapObjects != NULL)
            delete [] _ldapPkt.rgldapObjects;
        _ldapPkt.rgldapObjects = NULL;
        _cEntriesAllocated = 0;
    }
    if (_ldapPkt.rgldapObjects == NULL) {
        _ldapPkt.rgldapObjects = new LDAP_OBJECT [(_cEntries + 1) * 2];
        if (_ldapPkt.rgldapObjects == NULL) {
            _ldapPkt.rgldapObjects = new LDAP_OBJECT [_cEntries + 1];
            if (_ldapPkt.rgldapObjects == NULL) {
                dwErr = ERROR_OUTOFMEMORY;
                goto Cleanup;
            } else {
                _cEntriesAllocated = _cEntries + 1;
            }
        } else {
            _cEntriesAllocated = (_cEntries + 1) * 2;
        }
    }
    _ldapPkt.cLdapObjects = _cEntries;
    _ldapPkt.rgldapObjects[0] =
            *((PLDAP_OBJECT) DfsNextUnicodePrefix(&_ObjectTable, TRUE));
    for (i = 1; i < _cEntries; i++) {
        _ldapPkt.rgldapObjects[i] =
            *((PLDAP_OBJECT) DfsNextUnicodePrefix(&_ObjectTable, FALSE));
    }
    //
    // We now have an LDAP_PKT structure, lets marshal it and store
    // it in the DS.
    //
    cbPkt = 0;
DoMarshall:
    if (_pBuffer == NULL) {
        NtStatus = DfsRtlSize(&MiLdapPkt, &_ldapPkt, &cbPkt);
        if (cbPkt == 0 || !NT_SUCCESS(NtStatus)) {
            dwErr = RtlNtStatusToDosError(NtStatus);
            goto Cleanup;
        }
        _pBuffer = new BYTE [ sizeof(DWORD) + (2 * cbPkt) ];
        if (_pBuffer == NULL) {
            _pBuffer = new BYTE [ sizeof(DWORD) + cbPkt ];
            if (_pBuffer == NULL) {
                dwErr = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }
        }
    }
    *((LPDWORD) _pBuffer) = 1;
    MarshalBufferInitialize(
        &marshalBuffer,
        cbPkt,
        _pBuffer + sizeof(DWORD));
    NtStatus = DfsRtlPut(&marshalBuffer, &MiLdapPkt, &_ldapPkt);
    if (!NT_SUCCESS(NtStatus) && cbPkt == 0) {
        if (_pBuffer != NULL)
            delete [] _pBuffer;
        _pBuffer = NULL;
        goto DoMarshall;
    }
    //
    // We have a serialized blob to put into the DS.
    //
    UuidCreate( &idNewPkt );

    ldapIdVal.bv_len = sizeof(GUID);
    ldapIdVal.bv_val = (PCHAR) &idNewPkt;
    rgldapIdVals[0] = &ldapIdVal;
    rgldapIdVals[1] = NULL;

    ldapIdMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    ldapIdMod.mod_type = L"pKTGuid";
    ldapIdMod.mod_vals.modv_bvals = rgldapIdVals;

    ldapVal.bv_len = cbPkt + sizeof(DWORD);
    ldapVal.bv_val = (PCHAR) _pBuffer;
    rgldapVals[0] = &ldapVal;
    rgldapVals[1] = NULL;

    ldapMod.mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    ldapMod.mod_type = L"pKT";
    ldapMod.mod_vals.modv_bvals = rgldapVals;

    rgldapMods[0] = &ldapMod;
    rgldapMods[1] = &ldapIdMod;
    rgldapMods[2] = NULL;
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("Writing BLOB of %d bytes\n", cbPkt);
#endif
    if (DfsSvcLdap)
        DbgPrint("FlushObjectTable:ldap_modify(%ws) using 0x%x\n",
                        L"pKTGuid and pKT",
                        pLdapConnection);

    ldapErr = ldap_modify_ext_sW(
                pLdapConnection,
                _wszObjectDN,
                rgldapMods,
                (PLDAPControlW *) &ServerControls,
                NULL);
    DFSM_TRACE_ERROR_HIGH(ldapErr, ALL_ERROR,
                          _FlushObjectTable_Error_ldap_modify_ext_sW,
                          LOGULONG(ldapErr));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("ldap_modify_sW returned 0x%x(%d)\n", ldapErr, ldapErr);
#endif

    CopyMemory( &_ObjectTableId, &idNewPkt, sizeof(GUID) );
    if (ldapErr != LDAP_SUCCESS) {
        dwErr = LdapMapErrorToWin32(ldapErr);
    }

Cleanup:

    IDfsVolInlineDebOut((DEB_TRACE, "CLdap::_FlushObjectTable() exit\n"));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::_FlushObjectTable() exit %d\n", dwErr);
#endif
    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::_InsertLdapObject
//
//  Synopsis:   Helper routine for _ReadObjectTable(). This routine inserts
//              a single LDAP_OBJECT into the internal prefix table, so that
//              it can be looked up etc.
//
//              This routine duplicates the passed in LDAP_OBJECT.
//
//  Arguments:  [pldapObject] -- The object to duplicate and insert into the
//                      prefix table.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully inserted object.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory error.
//
//              [ERROR_ALREADY_EXISTS] -- The LDAP_OBJECT to be inserted
//                      already exists in the prefix table.
//
//-----------------------------------------------------------------------------

DWORD
CLdap::_InsertLdapObject(
    PLDAP_OBJECT pldapObject)
{
    DWORD dwErr;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::InsertLdapObject(%ws)\n", pldapObject->wszObjectName);
#endif

    dwErr = CreateObject( pldapObject->wszObjectName );

    if (dwErr == ERROR_SUCCESS) {

        dwErr = PutData(
                    pldapObject->wszObjectName,
                    pldapObject->cbObjectData,
                    pldapObject->pObjectData);

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::InsertLdapObject returning %d\n", dwErr);
#endif

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdap::_DestroyObjectTable
//
//  Synopsis:   Destroys all the entries in the _ObjectTable
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
CLdap::_DestroyObjectTable()
{

    PLDAP_OBJECT p;
    BOOLEAN Restart, Success;
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CLdap::_DestroyObjectTable()\n");
#endif

    p = (PLDAP_OBJECT) DfsNextUnicodePrefix( &_ObjectTable, TRUE );

    while (p != NULL) {

        UNICODE_STRING ustrObjectName;

        RtlInitUnicodeString(&ustrObjectName, p->wszObjectName);
        Success = DfsRemoveUnicodePrefix( &_ObjectTable, &ustrObjectName );
        if (Success == TRUE) {
          Restart = TRUE;
          delete p->pObjectData;
          delete p;
        }
        else {
          Restart = FALSE;
        }

        p = (PLDAP_OBJECT) DfsNextUnicodePrefix( &_ObjectTable, Restart );
    }



}

//+----------------------------------------------------------------------------
//
//  Function:   InitializeLdapStorage
//
//  Synopsis:   Initializes a global CLdap object, pDfsmLdap, that is used
//              by the CLdapStorage instances to store and retrieve properties
//
//  Arguments:  [wszDfsName] -- Name of the Dfs to initialize
//
//  Notes:      NOTE THAT THE ABOVE TWO STRINGS ARE ASCII STRINGS, NOT
//              UNICODE.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully initialized Ldap storage.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory situation
//
//              [ERROR_ALREADY_INITIALIZED] -- Ldap storage is already
//                      initialized
//
//-----------------------------------------------------------------------------

DWORD
InitializeLdapStorage(
    LPWSTR wszDfsName)
{
    DWORD dwErr;

    if (pDfsmLdap == NULL) {

        pDfsmLdap = new CLdap( wszDfsName, &dwErr );

        if (pDfsmLdap != NULL) {

            if (dwErr != ERROR_SUCCESS) {

                delete pDfsmLdap;

                pDfsmLdap = NULL;

            } else {

                pDfsmLdap->AddRef();
                pDfsmLdap->Release();

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_ALREADY_INITIALIZED;

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   UnInitializeLdapStorage
//
//  Synopsis:   UnInitializes a global CLdap object, pDfsmLdap, that is used
//              by the CLdapStorage instances to store and retrieve properties
//
//  Arguments:  None
//
//-----------------------------------------------------------------------------

VOID
UnInitializeLdapStorage(
    void )
{

    if (pDfsmLdap != NULL) {

        pDfsmLdap->Release();
        delete pDfsmLdap;
        pDfsmLdap = NULL;
        if (pLdapConnection != NULL) {
            if (DfsSvcLdap)
                DbgPrint("UnitializeLdapStorage:ldap_unbind()\n");
            ldap_unbind(pLdapConnection);
            pLdapConnection = NULL;
        }

    }

}


//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::CLdapStorage
//
//  Synopsis:   Constructor for a CLdapStorage object.
//
//  Arguments:  [lpwszFileName] -- Full Name of "storage object".
//
//              [pdwErr] -- If the constructor fails, this variable is set to
//                      an appropriate error.
//
//  Returns:    Nothing, but note the error return in pdwErr out parameter.
//
//-----------------------------------------------------------------------------

CLdapStorage::CLdapStorage(
    LPCWSTR lpwszFileName,
    LPDWORD pdwErr) :
        CStorage(lpwszFileName)
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS status;
    DWORD cbDataBuffer;
    PCHAR pDataBuffer;
    MARSHAL_BUFFER marshalBuffer;

    IDfsVolInlineDebOut((DEB_TRACE, "CLdapStorage::CLdapStorage(%ws)\n", lpwszFileName));
    IDfsVolInlineDebOut((
        DEB_TRACE, "CLdapStorage::+CLdapStorage(0x%x)\n",
        this));

    ZeroMemory(&_VolProps, sizeof(_VolProps));

    _wszFileName = NULL;

    //
    // Add a reference to the global CLdap object. Do this first so it can
    // initialize anything it needs to satisfy read/write requests.
    //

    pDfsmLdap->AddRef();

    //
    // Get the data from the Dfsm Ldap layer.
    //

    dwErr = pDfsmLdap->GetData(lpwszFileName, &cbDataBuffer, &pDataBuffer);

    if (dwErr == ERROR_SUCCESS && cbDataBuffer > 0) {

        MarshalBufferInitialize(&marshalBuffer, cbDataBuffer, pDataBuffer);

        status = DfsRtlGet(&marshalBuffer, &MiVolumeProperties, &_VolProps);

        _VolProps.dwTimeout = GTimeout;

        if (
            (marshalBuffer.Current < marshalBuffer.Last)
                &&
            (marshalBuffer.Last - marshalBuffer.Current) == sizeof(ULONG)
        ) {

            DfsRtlGetUlong(&marshalBuffer, &_VolProps.dwTimeout);

        }


        delete [] pDataBuffer;

        if (!NT_SUCCESS(status)) {

            dwErr = ERROR_INTERNAL_DB_CORRUPTION;

        }

    }

    if (dwErr == ERROR_SUCCESS) {

        _wszFileName = new WCHAR [wcslen(lpwszFileName) + 1];

        if (_wszFileName != NULL)
            wcscpy(_wszFileName, lpwszFileName);
        else
            dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr == ERROR_SUCCESS && _VolProps.wszPrefix != NULL) {

        dwErr = pDfsmStorageDirectory->_InsertIfNeeded(
                _VolProps.wszPrefix,
                _wszFileName);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CLdapStorage::CLdapStorage exit %d\n", dwErr));

    *pdwErr = dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::~CLdapStorage
//
//  Synopsis:   Destructor for CLdapStorage object
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdapStorage::~CLdapStorage()
{

    IDfsVolInlineDebOut((
        DEB_TRACE, "CLdapStorage::~CLdapStorage(0x%x)\n",
        this));

    if (_wszFileName != NULL)
        delete [] _wszFileName;

    if (_VolProps.wszPrefix != NULL)
        MarshalBufferFree( _VolProps.wszPrefix );

    if (_VolProps.wszShortPrefix != NULL)
        MarshalBufferFree( _VolProps.wszShortPrefix );

    if (_VolProps.wszComment != NULL)
        MarshalBufferFree( _VolProps.wszComment );

    if (_VolProps.pSvc != NULL)
        MarshalBufferFree( _VolProps.pSvc );

    if (_VolProps.pRecovery != NULL)
        MarshalBufferFree( _VolProps.pRecovery );

    pDfsmLdap->Release();

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::DestroyElement
//
//  Synopsis:   Destroys a CLdapStorage *child* of this object.
//
//  Arguments:  [lpwszChildName] -- Name of child to delete, relative to
//                      this object's name.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully deleted child
//
//              [ERROR_FILE_NOT_FOUND] -- No child found with given name.
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::DestroyElement(
    LPCWSTR lpwszChildName)
{
    DWORD dwErr;
    PWCHAR pwszFullChildName;

    pwszFullChildName = new WCHAR [
                                wcslen(_wszFileName) +
                                1 +
                                wcslen(lpwszChildName) +
                                1 ];

    if (pwszFullChildName != NULL) {

        wcscpy(pwszFullChildName, _wszFileName);
        wcscat(pwszFullChildName, UNICODE_PATH_SEP_STR);
        wcscat(pwszFullChildName, lpwszChildName);

        dwErr = pDfsmLdap->DeleteObject( pwszFullChildName );

        delete [] pwszFullChildName;

    } else {

        dwErr = ERROR_OUTOFMEMORY;
    }

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::GetEnumDirectory
//
//  Synopsis:   Returns an enumerator for the children of this ldap storage
//              structure.
//
//  Arguments:  [ppRegDir] -- On successful return, pointer to a
//                      CEnumDirectory instance.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning CEnumDirectory
//                      instance.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory situation
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::GetEnumDirectory(
    CEnumDirectory **ppRegDir)
{
    DWORD dwErr = ERROR_SUCCESS;
    CLdapEnumDirectory *pLdapRegDir;

    *ppRegDir = NULL;

    pLdapRegDir = new CLdapEnumDirectory( _wszFileName, &dwErr );

    if (pLdapRegDir != NULL) {

        if (dwErr != ERROR_SUCCESS) {

            delete pLdapRegDir;

        } else {

            *ppRegDir = (CEnumDirectory *) pLdapRegDir;

        }

    } else {

        dwErr = ERROR_OUTOFMEMORY;
    }

    return(dwErr);
}


//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::SetVersionProps
//
//  Synopsis:   Sets the version property set of this object
//
//  Arguments:  [ulVersion] -- The version to set.
//
//  Returns:    [ERROR_SUCCESS] -- If successfully set the property.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory.
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::SetVersionProps(
    ULONG ulVersion)
{
    DWORD dwErr;

    _VolProps.dwVersion = ulVersion;

    dwErr = _FlushProperties();

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::GetVersionProps
//
//  Synopsis:   Returns the stored version property
//
//  Arguments:  [pulVersion] -- Holds the current version property.
//
//  Returns:    [ERROR_SUCCESS] -- Always succeeds.
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::GetVersionProps(
    PULONG pulVersion)
{
    *pulVersion = _VolProps.dwVersion;

    return( ERROR_SUCCESS );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::SetIdProps
//
//  Synopsis:   Sets the ID properties
//
//  Arguments:  [dwType] -- The volume Type
//              [dwState] -- The volume State
//              [pwszPrefix] -- The volume prefix
//              [pwszShortPath] -- The volume 8.3 prefix
//              [idVolume] -- The volume guid
//              [pwszComment] -- The volume comment
//              [dwTimeout] -- The volume timeout
//              [ftPrefix] -- The modification time of prefix
//              [ftState] -- The modification time of state
//              [ftComment] -- The modification time of comment
//
//  Returns:    [ERROR_SUCCESS] -- Successfully modified properties
//
//              [ERROR_OUTOFMEMORY] -- Out of memory condition
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::SetIdProps(
    ULONG dwType,
    ULONG dwState,
    LPWSTR pwszPrefix,
    LPWSTR pwszShortPath,
    GUID   idVolume,
    LPWSTR  pwszComment,
    ULONG  dwTimeout,
    FILETIME ftPrefix,
    FILETIME ftState,
    FILETIME ftComment)
{
    DWORD dwErr = ERROR_SUCCESS;
    DFS_VOLUME_PROPERTIES newProps;

    newProps = _VolProps;

    newProps.idVolume = idVolume;
    newProps.dwType = dwType;
    newProps.dwState = dwState;
    newProps.ftPrefix = ftPrefix;
    newProps.ftState = ftState;
    newProps.ftComment = ftComment;

    newProps.wszPrefix = NULL;
    newProps.wszShortPrefix = NULL;
    newProps.wszComment = NULL;

    newProps.dwTimeout = dwTimeout;

    newProps.wszPrefix = (PWCHAR) MarshalBufferAllocate(
                                    (wcslen(pwszPrefix) + 1) *
                                        sizeof(WCHAR));
    if (newProps.wszPrefix != NULL) {
        wcscpy(newProps.wszPrefix, pwszPrefix);
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

    if (dwErr == ERROR_SUCCESS) {

        newProps.wszShortPrefix =
            (PWCHAR) MarshalBufferAllocate(
                (wcslen(pwszShortPath) + 1) * sizeof(WCHAR));
        if (newProps.wszShortPrefix != NULL)
            wcscpy(newProps.wszShortPrefix, pwszShortPath);
        else
            dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr == ERROR_SUCCESS) {

        newProps.wszComment =
            (PWCHAR) MarshalBufferAllocate(
                (wcslen(pwszComment) + 1) * sizeof(WCHAR));
        if (newProps.wszComment != NULL)
            wcscpy(newProps.wszComment, pwszComment);
        else
            dwErr = ERROR_OUTOFMEMORY;
    }

    //
    // The prefix might have changed; update the Prefix->ObjectName map if
    // necessary.
    //

    if (dwErr == ERROR_SUCCESS &&
            ((_VolProps.wszPrefix == NULL) ||
                (_wcsicmp(newProps.wszPrefix, _VolProps.wszPrefix) != 0)) ) {

        dwErr = pDfsmStorageDirectory->_InsertIfNeeded(
                    newProps.wszPrefix,
                    _wszFileName);

        if (dwErr == ERROR_SUCCESS && _VolProps.wszPrefix != NULL) {

            pDfsmStorageDirectory->_Delete( _VolProps.wszPrefix );

        }

   }

   if (dwErr == ERROR_SUCCESS) {

        if (_VolProps.wszPrefix)
            MarshalBufferFree(_VolProps.wszPrefix);

        if (_VolProps.wszShortPrefix)
            MarshalBufferFree(_VolProps.wszShortPrefix);

        if (_VolProps.wszComment)
            MarshalBufferFree(_VolProps.wszComment);

        _VolProps = newProps;

        dwErr = _FlushProperties();

    } else {

        //
        // Cleanup as much as we allocated for the new props
        //

        if (newProps.wszPrefix)
            MarshalBufferFree(newProps.wszPrefix);

        if (newProps.wszShortPrefix)
            MarshalBufferFree(newProps.wszShortPrefix);

        if (newProps.wszComment)
            MarshalBufferFree(newProps.wszComment);

    }

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::GetIdProps
//
//  Synopsis:   Retrieves the ID properties
//
//  Arguments:  [pdwType] -- Type of Volume
//              [pdwState] -- State of Volume
//              [ppwszPrefix] -- Prefix of volume
//              [ppwszShortPath] -- Short prefix of volume
//              [pidVolume] -- Guid of volume.
//              [ppwszComment] -- Comment associated with volume
//              [pdwTimeout] -- Timeout of volume
//              [pftPrefix] -- Modification time of prefix
//              [pftState] -- Modification time of state
//              [pftComment] -- Modification time of comment
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning ID properties.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory situation.
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::GetIdProps(
    LPDWORD pdwType,
    LPDWORD pdwState,
    LPWSTR  *ppwszPrefix,
    LPWSTR  *ppwszShortPath,
    GUID    *pidVolume,
    LPWSTR  *ppwszComment,
    LPDWORD  pdwTimeout,
    FILETIME *pftPrefix,
    FILETIME *pftState,
    FILETIME *pftComment)
{
    DWORD dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CLdapStorage::GetIdProps()\n"));

    #define GIP_DUPLICATE_STRING(dwErr, src, dest)          \
        if ((src) != NULL)                                  \
            (*(dest)) = new WCHAR [ wcslen(src) + 1 ];      \
        else                                                \
            (*(dest)) = new WCHAR [1];                      \
                                                            \
        if (*(dest) != NULL)                                \
            if ((src) != NULL)                              \
                wcscpy( *(dest), (src) );                   \
            else                                            \
                (*(dest))[0] = UNICODE_NULL;                \
        else                                                \
            dwErr = ERROR_OUTOFMEMORY;

    GIP_DUPLICATE_STRING(dwErr, _VolProps.wszPrefix, ppwszPrefix);

    if (dwErr == ERROR_SUCCESS) {
        GIP_DUPLICATE_STRING(dwErr, _VolProps.wszShortPrefix, ppwszShortPath);
    }

    if (dwErr == ERROR_SUCCESS) {
        GIP_DUPLICATE_STRING(dwErr, _VolProps.wszComment, ppwszComment);
    }

    if (dwErr == ERROR_SUCCESS) {

        *pdwType = _VolProps.dwType;
        *pdwState = _VolProps.dwState;
        *pidVolume = _VolProps.idVolume;
        *pdwTimeout = _VolProps.dwTimeout;

        *pftPrefix = _VolProps.ftPrefix;
        *pftState = _VolProps.ftState;
        *pftComment = _VolProps.ftComment;

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CLdapStorage::GetIdProps() exit\n"));

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::SetSvcProps
//
//  Synopsis:   Sets the service property of the volume object
//
//  Arguments:  [pSvc] -- The service property
//              [cbSvc] -- Length in bytes of the service property
//
//  Returns:    [ERROR_SUCCESS] -- Successfully set the service property
//
//              [ERROR_OUTOFMEMORY] -- Out of memory situation
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::SetSvcProps(
    PBYTE pSvc,
    ULONG cbSvc)
{
    DWORD dwErr = ERROR_SUCCESS;
    PBYTE pNewBuffer;

    pNewBuffer = (PBYTE) MarshalBufferAllocate( cbSvc );

    if (pNewBuffer != NULL) {

        CopyMemory( pNewBuffer, pSvc, cbSvc );

        if (_VolProps.pSvc != NULL)
            MarshalBufferFree( _VolProps.pSvc );

        _VolProps.pSvc = pNewBuffer;

        _VolProps.cbSvc = cbSvc;

        dwErr = _FlushProperties();

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::GetSvcProps
//
//  Synopsis:   Retrieves the service property from this volume object
//
//  Arguments:  [ppSvc] -- On successful return, points to allocated svc buffer
//              [pcbSvc] -- On successful return, size in bytes of *ppSvc
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning svc property.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory situation.
//
//              [ERROR_FILE_NOT_FOUND] -- Svc property not set.
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::GetSvcProps(
    PBYTE *ppSvc,
    LPDWORD pcbSvc)
{
    DWORD dwErr = ERROR_SUCCESS;
    PBYTE pNewBuffer;

    if (_VolProps.cbSvc != 0) {

        pNewBuffer = new BYTE [_VolProps.cbSvc];

        if (pNewBuffer != NULL) {

            CopyMemory( pNewBuffer, _VolProps.pSvc, _VolProps.cbSvc );

            *ppSvc = pNewBuffer;

            *pcbSvc = _VolProps.cbSvc;

            dwErr = ERROR_SUCCESS;

        } else {

            *ppSvc = NULL;

            *pcbSvc = 0;

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_FILE_NOT_FOUND;
    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::SetRecoveryProps
//
//  Synopsis:   Sets the recovery property of the volume object
//
//  Arguments:  [pRecovery] -- The recovery property
//              [cbRecovery] -- Length in bytes of the recovery property
//
//  Returns:    [ERROR_SUCCESS] -- Successfully set the recovery property
//
//              [ERROR_OUTOFMEMORY] -- Out of memory situation
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::SetRecoveryProps(
    PBYTE pRecovery,
    ULONG cbRecovery)
{
    DWORD dwErr = ERROR_SUCCESS;
    PBYTE pNewBuffer;

    pNewBuffer = (PBYTE) MarshalBufferAllocate( cbRecovery );

    if (pNewBuffer != NULL) {

        CopyMemory( pNewBuffer, pRecovery, cbRecovery );

        if (_VolProps.pRecovery != NULL)
            MarshalBufferFree( _VolProps.pRecovery );

        _VolProps.pRecovery = pNewBuffer;

        _VolProps.cbRecovery = cbRecovery;

        dwErr = _FlushProperties();

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::GetRecoveryProps
//
//  Synopsis:   Retrieves the recovery property from this volume object
//
//  Arguments:  [ppRecovery] -- On successful return, points to allocated Recovery buffer
//              [pcbRecovery] -- On successful return, size in bytes of *ppRecovery
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning Recovery property.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory situation.
//
//              [ERROR_FILE_NOT_FOUND] -- Recovery property not set.
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::GetRecoveryProps(
    PBYTE *ppRecovery,
    LPDWORD pcbRecovery)
{
    DWORD dwErr = ERROR_SUCCESS;
    PBYTE pNewBuffer;

    if (_VolProps.cbRecovery != 0) {

        pNewBuffer = new BYTE [_VolProps.cbRecovery];

        if (pNewBuffer != NULL) {

            CopyMemory( pNewBuffer, _VolProps.pRecovery, _VolProps.cbRecovery );

            *ppRecovery = pNewBuffer;

            *pcbRecovery = _VolProps.cbRecovery;

            dwErr = ERROR_SUCCESS;

        } else {

            *ppRecovery = NULL;

            *pcbRecovery = 0;

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_FILE_NOT_FOUND;
    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapStorage::_FlushProperties
//
//  Synopsis:   Helper function to marshal the volume properties and store
//              them in the LDAP agent.
//
//  Arguments:  None - uses the member _VolProps.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully flushed properties.
//
//              [ERROR_OUTOFMEMORY] -- Out of memory situation.
//
//              Error from CLdap::PutData()
//
//-----------------------------------------------------------------------------

DWORD
CLdapStorage::_FlushProperties()
{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS status;
    MARSHAL_BUFFER marshalBuffer;
    ULONG cbBuffer;
    PCHAR pBuffer;

    cbBuffer = 0;

    status = DfsRtlSize(&MiVolumeProperties, &_VolProps, &cbBuffer);

    ASSERT(NT_SUCCESS(status));

    if (!NT_SUCCESS(status)) {

        dwErr =  ERROR_INVALID_DATA;

        goto exit_with_error;

    }

    cbBuffer += sizeof(ULONG);

    pBuffer = new CHAR [cbBuffer];

    if (pBuffer != NULL) {

        MarshalBufferInitialize(
            &marshalBuffer,
            cbBuffer,
            pBuffer);

        status = DfsRtlPut(&marshalBuffer, &MiVolumeProperties, &_VolProps);

        DfsRtlPutUlong(&marshalBuffer, &_VolProps.dwTimeout);

        ASSERT(NT_SUCCESS(status));

        if (!NT_SUCCESS(status)) {

            dwErr =  ERROR_INVALID_DATA;

            delete [] pBuffer;

            goto exit_with_error;
        }

        dwErr = pDfsmLdap->PutData(_wszFileName, cbBuffer, pBuffer);

        delete [] pBuffer;

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

exit_with_error:

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapEnumDirectory::CLdapEnumDirectory
//
//  Synopsis:   Enumerator over ldap objects in the global CLdap object
//
//  Arguments:  [wszFileName] -- The ldap object whose children we are to
//                      enumerate.
//
//              [pdwErr] -- Result of construction
//
//  Returns:    Nothing, but note the result code returned in the pdwErr
//              parameter.
//
//-----------------------------------------------------------------------------

CLdapEnumDirectory::CLdapEnumDirectory(
    LPWSTR wszFileName,
    LPDWORD pdwErr)
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CLdapEnumDirectory::+CLdapEnumDirectory(0x%x)\n",
        this));

    _pCookie = NULL;

    _wszFileName = new WCHAR [ wcslen(wszFileName) + 1 ];

    if (_wszFileName != NULL) {

        wcscpy( _wszFileName, wszFileName );

        *pdwErr = ERROR_SUCCESS;

    } else {

        *pdwErr = ERROR_OUTOFMEMORY;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapEnumDirectory::~CLdapEnumDirectory
//
//  Synopsis:   Destructor for ldap object directory enumerator
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CLdapEnumDirectory::~CLdapEnumDirectory()
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CLdapEnumDirectory::~CLdapEnumDirectory(0x%x)\n",
        this));

    if (_wszFileName != NULL)
        delete [] _wszFileName;
}

//+----------------------------------------------------------------------------
//
//  Function:   CLdapEnumDirectory::Next
//
//  Synopsis:   Enumerates the next child of _wszFileName
//
//  Arguments:  [rgelt] -- Pointer to STATDIR structure. Only the name
//                      of the child relative to this storage is returned.
//              [pcFetched] -- Set to 1 if a child name is successfully
//                      retrieved, 0 if an error occurs or if no more
//                      children.
//
//  Returns:    [ERROR_SUCCESS] -- Operation succeeded. If no more children
//                      are available, ERROR_SUCCESS is returned and
//                      *pcFetched is set to 0.
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate room for child name.
//
//-----------------------------------------------------------------------------

DWORD
CLdapEnumDirectory::Next(
    DFSMSTATDIR *rgelt,
    PULONG pcFetched)
{
    DWORD dwErr = ERROR_SUCCESS;
    LPWSTR wszFullChildName;

    wszFullChildName = pDfsmLdap->NextChild( _wszFileName, &_pCookie );

    if (wszFullChildName != NULL) {

        rgelt->pwcsName = new WCHAR [wcslen(wszFullChildName) + 1];

        if (rgelt->pwcsName != NULL) {

            wcscpy(
                rgelt->pwcsName,
                &wszFullChildName[ wcslen(_wszFileName) + 1 ]);

            *pcFetched = 1;

            dwErr = ERROR_SUCCESS;

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        *pcFetched = 0;

        dwErr = ERROR_SUCCESS;

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsmCreateLdapStorage
//
//  Synopsis:   Given a "file name", creates and returns a CLdapStorage over
//              it.
//
//  Arguments:  [lpwszFileName] -- Name of file to create.
//              [ppDfsmStorage] -- On successful return, holds pointer to
//                      new CLdapStorage object. This object must be deleted
//                      by calling its Release() method.
//
//  Returns:    S_OK if successful.
//
//              E_OUTOFMEMORY if unable to allocate memory.
//
//              DWORD_FROM_WIN32 of Win32 error returned by RegCreateKey()
//
//-----------------------------------------------------------------------------

DWORD
DfsmCreateLdapStorage(
    IN LPCWSTR lpwszFileName,
    OUT CStorage **ppDfsmStorage)
{
    DWORD dwErr;
    HKEY  hkey;

    dwErr = pDfsmLdap->CreateObject(lpwszFileName);

    if (dwErr == ERROR_SUCCESS) {

        dwErr = DfsmOpenLdapStorage( lpwszFileName, ppDfsmStorage );

    }

    return( dwErr );

}

static DWORD GetDCFlags[] = {
        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED,

        DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED |
            DS_FORCE_REDISCOVERY
     };

//+----------------------------------------------------------------------------
//
//  Function:   GetDCName
//
//  Synopsis:   Stub function that returns the "address" of a DC.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
GetDcName(
    IN LPCSTR DomainName OPTIONAL,
    IN DWORD RetryCount,
    OUT LPWSTR *DCName)
{
    DWORD dwErr, cRetryCount;
    PDOMAIN_CONTROLLER_INFO pDCInfo;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DsGetDcName(%d)\n", RetryCount);
#endif

    cRetryCount = RetryCount % (sizeof(GetDCFlags) / sizeof(GetDCFlags[1]));

    dwErr = DsGetDcName(
                NULL,                            // Computer to remote to
                NULL,                            // Domain - use local domain
                NULL,                            // Domain Guid
                NULL,                            // Site Guid
                GetDCFlags[cRetryCount],         // Flags
                &pDCInfo);

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DsGetDcName returned %d\n", dwErr);
#endif

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR, GetDcName_Error_GetDcName,
			  LOGULONG(dwErr)
			  );

    if (dwErr == ERROR_SUCCESS) {

        (*DCName) = new WCHAR [ wcslen(pDCInfo->DomainControllerName) + 1 ];

        if ((*DCName) != NULL) {
            wcscpy(*DCName, pDCInfo->DomainControllerName);
        } else {
            dwErr = ERROR_OUTOFMEMORY;
        }

        NetApiBufferFree( pDCInfo );

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DsGetDcName DC [%ws]\n", *DCName);
#endif

    } else {

        IDfsVolInlineDebOut((DEB_TRACE, "DsGetDcName failed %d\n", dwErr));
    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("GetDcName returning %d\n", dwErr);
#endif

    return( dwErr );
}


//+----------------------------------------------------------------------------
//
//  Function:   GetConfigurationDN
//
//  Synopsis:   This routine computes the DN of the metadata container object in the DS
//
//  Arguments:  [pwszDN] -- On return, points to allocated string containing
//                      DN of megadata container. Caller should free using
//                      delete
//
//  Returns:    Win32 error from ldap or memory allocation functions.
//
//-----------------------------------------------------------------------------

DWORD
GetConfigurationDN(
    LPWSTR *pwszDN)
{
    DWORD dwErr;
    HKEY hkey;
    WCHAR wszConfigDN[ MAX_PATH ];
    DWORD dwType, cbConfigDN;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbConfigDN = sizeof(wszConfigDN);

        dwErr = RegQueryValueEx(
                    hkey,
                    FTDFS_DN_VALUE_NAME,
                    NULL,
                    &dwType,
                    (PBYTE) wszConfigDN,
                    &cbConfigDN);

        if (dwErr == ERROR_SUCCESS) {

            *pwszDN = new WCHAR [ wcslen(wszConfigDN) + 1 ];

            if ((*pwszDN) != NULL) {

                wcscpy( (*pwszDN), wszConfigDN);

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

        }

        RegCloseKey( hkey );

    }

    return( dwErr );

}

DWORD
LdapCreateObject(
    LPWSTR ObjectName)
{
    DWORD dwErr;

    pDfsmLdap->AddRef();

    dwErr = pDfsmLdap->CreateObject(ObjectName);

    pDfsmLdap->Release();

    return dwErr;
}

DWORD
LdapGetData(
    LPWSTR ObjectName,
    PULONG pcBytes,
    PCHAR *ppData)
{
    DWORD dwErr;

    pDfsmLdap->AddRef();

    dwErr = pDfsmLdap->GetData(
                        ObjectName,
                        pcBytes,
                        ppData);

    pDfsmLdap->Release();

    return dwErr;
}

DWORD
LdapPutData(
    LPWSTR ObjectName,
    ULONG cBytes,
    PCHAR pData)
{
    DWORD dwErr;

    pDfsmLdap->AddRef();

    dwErr = pDfsmLdap->PutData(
                        ObjectName,
                        cBytes,
                        pData);

    pDfsmLdap->Release();

    return dwErr;
}

DWORD
LdapFlushTable(void)
{
    DWORD dwErr = ERROR_SUCCESS;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("LdapFlushTable()\n");
#endif
    if (pDfsmLdap != NULL) {
        dwErr = pDfsmLdap->Flush();
    }
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("LdapFlushTable returning %d\n", dwErr);
#endif
    return dwErr;
}

DWORD
LdapIncrementBlob(BOOLEAN SyncRemoteServerName)
{
    DWORD dwErr = ERROR_SUCCESS;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("LdapIncrementBlob()\n");
#endif
    if (pDfsmLdap != NULL) {
        dwErr = pDfsmLdap->AddRef(SyncRemoteServerName);
    }
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("LdapIncrementBlob returning %d\n", dwErr);
#endif
    return dwErr;
}

DWORD
LdapDecrementBlob(void)
{
    DWORD dwErr = ERROR_SUCCESS;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("LdapDecrementBlob()\n");
#endif
    if (pDfsmLdap != NULL) {
        dwErr = pDfsmLdap->Release();
    }
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("LdapDecrementBlob returning %d\n", dwErr);
#endif
    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsLoadSiteTableFromDs
//
//  Synopsis:   Given the name of an FTDfs and a list of servers, this routine
//              goes throught the FtDFS blob and primes the dfs site table with
//              the site information for each servername passed in.
//
//  Arguments:  [pldap] -- ldap to use
//              [wszFTDfsName] -- Name of FTDfs
//              [Count] -- number of server names in pustr
//              [pustr] -- pointer to array of UNICODE_STRINGS, each a server we
//                          want site information on.
//
//  Returns:    Win32 error from ldap or memory allocation functions.
//
//-----------------------------------------------------------------------------

extern "C" DWORD
DfsLoadSiteTableFromDs(
    PLDAP pldap,
    LPWSTR wszFTDfsName,
    ULONG Count,
    PUNICODE_STRING pustr)
{
    NTSTATUS NtStatus;
    DWORD dwErr;
    DWORD i, j;
    DWORD cObj;

    PLDAPMessage pMsg = NULL;
    MARSHAL_BUFFER marshalBuffer;
    LDAP_PKT ldapPkt;
    PLDAP_OBJECT pldapObject;

    WCHAR wszFtDfsConfigDN[MAX_PATH+1];
    LPWSTR wszDCName = NULL;
    LPWSTR wszDfsConfigDN = NULL;

    BOOLEAN bUnbindNeeded = FALSE;

    LPWSTR rgAttrs[5];

    if (pldap == NULL) {

        if (pwszDSMachineName != NULL) {

            dwErr = DfspLdapOpen(pwszDSMachineName, &pldap, &wszDfsConfigDN);

        } else {

            dwErr = GetDcName( NULL, 1, &wszDCName );

            if (dwErr == ERROR_SUCCESS) {
                dwErr = DfspLdapOpen(&wszDCName[2], &pldap, &wszDfsConfigDN);
                delete [] wszDCName;
            }

        }

        if (dwErr != ERROR_SUCCESS) {

            goto Cleanup;

        }

        bUnbindNeeded = TRUE;

    } else {

        //
        // We've been given the ldap connection, just need the name of the dfs
        // configuration obj.
        //

        dwErr = DfspLdapOpen(NULL, &pldap, &wszDfsConfigDN);

        if (dwErr != ERROR_SUCCESS) {

            IDfsVolInlineDebOut((DEB_ERROR, "Unable to find Configuration naming context\n", 0));

            goto Cleanup;

        }

    }

    wsprintf(
        wszFtDfsConfigDN,
        L"CN=%ws,%ws",
        wszFTDfsName,
        wszDfsConfigDN);

    rgAttrs[0] = L"pKT";
    rgAttrs[1] = NULL;

    if (DfsSvcLdap)
        DbgPrint("CLdap::DfsLoadSiteTableFromDs:ldap_search(%ws)\n", rgAttrs[0]);

    dwErr = ldap_search_sW(
                pldap,
                wszFtDfsConfigDN,
                LDAP_SCOPE_BASE,
                L"(objectClass=*)",
                rgAttrs,
                0,
                &pMsg);

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR, 
                          DfsLoadSiteTableFromDs_Error_ldap_search_sW,
                          LOGULONG(dwErr));

    if (dwErr == LDAP_SUCCESS) {

        PLDAP_BERVAL *rgldapPktBlob, pldapPktBlob;

        dwErr = ERROR_SUCCESS;

        rgldapPktBlob = ldap_get_values_lenW(
                            pldap,
                            pMsg,
                            L"pKT");

        if((rgldapPktBlob != NULL) && (*rgldapPktBlob != NULL)) {

            pldapPktBlob = rgldapPktBlob[0];

            if (pldapPktBlob->bv_len > sizeof(DWORD)) {

                MarshalBufferInitialize(
                    &marshalBuffer,
                    pldapPktBlob->bv_len - sizeof(DWORD),
                    pldapPktBlob->bv_val + sizeof(DWORD));

                NtStatus = DfsRtlGet(&marshalBuffer, &MiLdapPkt, &ldapPkt);

                if (NT_SUCCESS(NtStatus)) {

                    for (cObj = 0; cObj < ldapPkt.cLdapObjects; cObj++) {

                        pldapObject = &ldapPkt.rgldapObjects[cObj];

                        if (wcscmp(pldapObject->wszObjectName, L"\\siteroot") == 0) {
                            ProcessSiteTable(
                                (PBYTE)pldapObject->pObjectData,
                                pldapObject->cbObjectData,
                                Count,
                                pustr);
                        }

                        MarshalBufferFree(pldapObject->wszObjectName);
                        MarshalBufferFree(pldapObject->pObjectData);

                    }

                }

                MarshalBufferFree(ldapPkt.rgldapObjects);

            }

            ldap_value_free_len(rgldapPktBlob);

        } else {

            dwErr = ERROR_UNEXP_NET_ERR;

        }

        ldap_msgfree(pMsg);

    } else {

        dwErr = LdapMapErrorToWin32(dwErr);

    }

Cleanup:

    if( pldap != NULL && bUnbindNeeded == TRUE && pldap != pLdapConnection) {
        if (DfsSvcLdap)
            DbgPrint("DfsLoadSiteTableFromDs:ldap_unbind\n");
        ldap_unbind(pldap);
    }

    if (wszDfsConfigDN != NULL) {
        free(wszDfsConfigDN);
    }

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   ProcessSiteTable
//
//  Synopsis:   Unmarshalls a site table and uses a list of servers to prime the
//              site table.
//
//  Arguments:  [pBuffer] -- Buffer with site table
//              [cbBuffer] -- size of the buffer
//              [cServers] -- number of names in the pustrServers array
//              [pustrServers] -- pointer to array of UNICODE_STRING server names.
//
//  Returns:    Win32 error from ldap or memory allocation functions.
//
//-----------------------------------------------------------------------------

DWORD
ProcessSiteTable(
    PBYTE pBuffer,
    ULONG cbBuffer,
    ULONG cServers,
    PUNICODE_STRING pustrServers)
{
    NTSTATUS NtStatus;
    DWORD dwErr;
    ULONG cObjects = 0;
    ULONG cbThisObj;
    ULONG i;
    ULONG j;
    PDFSM_SITE_ENTRY pSiteInfo;
    MARSHAL_BUFFER marshalBuffer;
    UNICODE_STRING ServerName1;
    UNICODE_STRING ServerName2;
    GUID guid;

    IDfsVolInlineDebOut((DEB_TRACE, "ProcessSiteTable()\n", 0));

    dwErr = ERROR_SUCCESS;


    if (dwErr == ERROR_SUCCESS && cbBuffer >= sizeof(ULONG)) {

        //
        // Unmarshall all the objects (NET_DFS_SITENAME_INFO's) in the buffer
        //

        MarshalBufferInitialize(
          &marshalBuffer,
          cbBuffer,
          pBuffer);

        DfsRtlGetGuid(&marshalBuffer, &guid);
        DfsRtlGetUlong(&marshalBuffer, &cObjects);

        //
        // Examine each object (a DFSM_SITE_ENTRY)
        //

        for (i = 0; i < cObjects; i++) {

            pSiteInfo = (PDFSM_SITE_ENTRY) new BYTE [cbBuffer-sizeof(ULONG)];

            if (pSiteInfo != NULL) {

                NtStatus = DfsRtlGet(&marshalBuffer,&MiDfsmSiteEntry, pSiteInfo);

                if (NT_SUCCESS(NtStatus)) {

                    RtlInitUnicodeString(&ServerName1, pSiteInfo->ServerName);

                    //
                    // Compare the ServerName of this Site entry with the list of
                    // servers passed in.  If we match, prime the dfs driver with
                    // the site info for this server.
                    //

                    for (j = 0; j < cServers; j++) {

                        //
                        // Get the server from \\server\share
                        //

                        DfsServerFromPath(&pustrServers[j], &ServerName2);

                        if (RtlCompareUnicodeString(&ServerName1,&ServerName2,TRUE) == 0) {

                            IDfsVolInlineDebOut((DEB_TRACE,
                                "DfsSentUpDate(%ws,%d)\n",
                                pSiteInfo->ServerName,
                                pSiteInfo->Info.cSites));

                            DfsSendUpdate(
                                pSiteInfo->ServerName,
                                pSiteInfo->Info.cSites,
                                &pSiteInfo->Info.Site[0]);
                        }

                    }

                    //
                    // The unmarshalling routines allocate buffers; we need to
                    // free them.
                    //

                    for (j = 0; j < pSiteInfo->Info.cSites; j++) {
                        MarshalBufferFree(pSiteInfo->Info.Site[j].SiteName);
                    }

                    MarshalBufferFree(pSiteInfo->ServerName);

                }

                delete [] pSiteInfo;

            }

        }

    }

    IDfsVolInlineDebOut((DEB_TRACE, "ProcessSiteTable exit dwErr=%d\n", dwErr));

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsServerFromPath
//
//  Synopsis:   Helper routine to extract the servername from a pathname.
//              ex: \microsoft\dfs will return 'microsoft'.
//
//  Arguments:  [PathName] -- PathName to search
//              [ServerName] -- Name of server in that pathname
//
//-----------------------------------------------------------------------------

VOID
DfsServerFromPath(
    PUNICODE_STRING PathName,
    PUNICODE_STRING ServerName)
{
    ULONG i;

    *ServerName = *PathName;

    while (ServerName->Buffer[0] == L'\\' && ServerName->Length > 0) {

        ServerName->Buffer++;
        ServerName->Length -= sizeof(WCHAR);
        ServerName->MaximumLength -= sizeof(WCHAR);

    }

    for (i = 0;
            ServerName->Buffer[i] != L'\\' && i < ServerName->Length/sizeof(WCHAR);
                i++
    ) {

        /* NOTHING */

    }

    if (i < ServerName->Length/sizeof(WCHAR)) {

        ServerName->Length = (USHORT) (i * sizeof(WCHAR));

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsGetFtServersFromDs
//
//  Synopsis:   This API returns a vector of \\server\share combinations which
//  form the root of a Fault Tolerant DFS.  This  null-terminated vector should be
//  freed by the caller with NetApiBufferFree().
//
//  If pLDAP is supplied, we assume that this is the handle to the DS server
//  holding the configuration data.  Else, we use wszDomainName to locate the
//  proper DS server.
//
//  wszDfsName is the name of the fault tolerant DFS for which individual servers
//  are to be discovered.
//
//+----------------------------------------------------------------------------
extern "C"
DWORD
DfsGetFtServersFromDs(
    PLDAP pLDAP,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR **List
    )
{
    BOOLEAN bUnbindNeeded = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS status;
    PWCHAR attrs[2];
    LDAPMessage *pMsg = NULL;
    LDAPMessage *pEntry = NULL;
    WCHAR *pAttr = NULL;
    WCHAR **rpValues = NULL;
    WCHAR **allValues = NULL;
    WCHAR ***rpValuesToFree = NULL;
    INT cValues = 0;
    INT i;
    LPWSTR FtDfsDN = NULL;
    LPWSTR DfsConfigDN = NULL;
    DWORD len;
    USHORT cChar;
    PWCHAR *resultVector;
    ULONG cBytes;
    BOOLEAN GettingNames = FALSE;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetFtServersFromDs(0x%x,%ws,%ws)\n",
                pLDAP,
                wszDomainName,
                wszDfsName);
#endif

    if (List == NULL) {
        dwErr =  ERROR_INVALID_PARAMETER;
        goto AllDone;
    }

    *List = NULL;

    if (!ARGUMENT_PRESENT(pLDAP)) {

        DOMAIN_CONTROLLER_INFO *pInfo = NULL;
        ULONG dsAdditionalFlags = 0;
        ULONG retry;

        for (retry = 0; pLDAP == NULL && retry < 2; retry++) {

            //
            // Find a DC for the given domain.
            //
            dwErr = DsGetDcName(
                        NULL,                       // computer name
                        wszDomainName,              // DNS domain name
                        NULL,                       // domain guid
                        NULL,                       // site guid
                        DS_DIRECTORY_SERVICE_REQUIRED |
                            DS_IP_REQUIRED |
                            dsAdditionalFlags,
                        &pInfo);

	    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR, DfsGetFtServersFromDs_Error_DsGetDcName,
				 LOGWSTR(wszDomainName)
				 LOGULONG(dwErr)
				 );

            if (dwErr != ERROR_SUCCESS)
                goto AllDone;

            //
            // DomainControllerName is prefixed with "\\" so
            // aditionally ensure there's some useful data there.
            //

            if (DS_INET_ADDRESS != pInfo->DomainControllerAddressType ||
                 (cChar = (USHORT)wcslen(pInfo->DomainName)) < 3) {

                NetApiBufferFree(pInfo);
                dwErr = ERROR_NO_SUCH_DOMAIN;
                goto AllDone;
            }

            //
            // Try to connect to the DS server on the DC
            //

            dwErr = DfspLdapOpen(&pInfo->DomainControllerName[2], &pLDAP, &DfsConfigDN);

            NetApiBufferFree(pInfo);

        }

        if (dwErr != ERROR_SUCCESS)
            goto AllDone;

        bUnbindNeeded = TRUE;

    } else {

        //
        // We've been given an ldap connection, just need the name of the dfs
        // configuration object
        //

        dwErr = DfspLdapOpen(NULL, &pLDAP, &DfsConfigDN);

        if (dwErr != ERROR_SUCCESS) {

            goto Cleanup;

        }

    }

    if (ARGUMENT_PRESENT(wszDfsName)) {

        //
        // Looks good.  Allocate enough memory to hold the DN of the
        // DFS configuration data for the fault tolerant DFS in question
        //

        len = (DWORD)(3 * sizeof(WCHAR) +
                (wcslen(wszDfsName) + 1) * sizeof(WCHAR) +
                    (wcslen(DfsConfigDN) + 1) * sizeof(WCHAR));

        dwErr = NetApiBufferAllocate(len, (PVOID *)&FtDfsDN);

        if (dwErr != ERROR_SUCCESS) {
            goto Cleanup;
        }

        //
        // Construct the DN for the FtDfs obj
        //

        RtlZeroMemory(FtDfsDN, len);
        wcscpy(FtDfsDN, L"CN=");
        wcscat(FtDfsDN, wszDfsName);
        wcscat(FtDfsDN, L",");
        wcscat(FtDfsDN, DfsConfigDN);

        //
        // Now see if we can get at the 'remoteServerName' property of this object.
        //  This property holds the names of the servers hosting this DFS
        //

        pLDAP->ld_sizelimit = 0;
        pLDAP->ld_timelimit= 0;
        pLDAP->ld_deref = LDAP_DEREF_NEVER;

        ldap_msgfree(pMsg);
        pMsg = NULL;

        attrs[0] = L"remoteServerName";
        attrs[1] = NULL;

        if (DfsSvcLdap)
            DbgPrint("DfsGetFtServersFromDs:ldap_search(%ws)\n", attrs[0]);

        dwErr = ldap_search_sW(
                            pLDAP,
                            FtDfsDN,
                            LDAP_SCOPE_BASE,
                            L"(objectClass=*)",
                            attrs,
                            0,
                            &pMsg);

        DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                              DfsGetFtServersFromDs_Error_ldap_search_sW,
                              LOGULONG(dwErr));

        if (dwErr != LDAP_SUCCESS) {

            dwErr = LdapMapErrorToWin32(dwErr);
            goto Cleanup;

        }

        dwErr = ERROR_SUCCESS;

        //
        // Make sure the result is reasonable
        //
        if (ldap_count_entries(pLDAP, pMsg) == 0 ||
            (pEntry = ldap_first_entry(pLDAP, pMsg)) == NULL ||
            (rpValues = ldap_get_valuesW(pLDAP, pEntry, attrs[0])) == NULL ||
            rpValues[0][0] == L'\0'
        ) {

            dwErr = ERROR_UNEXP_NET_ERR;
            goto Cleanup;
        }

        //
        // The result is reasonable, just point allValues to rpValues
        //

        allValues = rpValues;

    } else {

        //
        // The caller is trying to retrieve the names of all the FT DFSs in the domain
        //

        GettingNames = TRUE;

        //
        // Now see if we can enumerate the objects below this one.  The names
        //   of these objects will be the different FT dfs's available
        //
        pLDAP->ld_sizelimit = 0;
        pLDAP->ld_timelimit= 0;
        pLDAP->ld_deref = LDAP_DEREF_NEVER;

        attrs[0] = L"CN";
        attrs[1] = NULL;

        if (DfsSvcLdap)
            DbgPrint("DfsGetFtServersFromDs:ldap_search(%ws)\n", attrs[0]);

        dwErr = ldap_search_sW(
                            pLDAP,
                            DfsConfigDN,
                            LDAP_SCOPE_ONELEVEL,
                            L"(objectClass=fTDfs)",
                            attrs,
                            0,
                            &pMsg);

        DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR,
                              DfsGetFtServersFromDs_Error_ldap_search_sW_2,
                              LOGULONG(dwErr));

        if (dwErr != LDAP_SUCCESS) {

            dwErr = LdapMapErrorToWin32(dwErr);
            goto Cleanup;

        }

        dwErr = ERROR_SUCCESS;

        //
        // Make sure the result is reasonable
        //
        if (
            ((cValues = ldap_count_entries(pLDAP, pMsg)) == 0) ||
             (pEntry = ldap_first_entry(pLDAP, pMsg)) == NULL
        ) {
            dwErr = ERROR_UNEXP_NET_ERR;
            goto Cleanup;
        }

        //
        // The search for all FTDfs's returns multiple entries, each with
        // one value for the object's CN. Coalesce these into a single array.
        //

        dwErr = NetApiBufferAllocate(2 * (cValues + 1) * sizeof(PWSTR), (PVOID *)&allValues);

        if (dwErr != ERROR_SUCCESS) {
            goto Cleanup;
        }

        rpValuesToFree = (WCHAR ***) &allValues[cValues + 1];

        for (i = 0; (i < cValues) && (dwErr == ERROR_SUCCESS); i++) {

            rpValues = ldap_get_valuesW(pLDAP, pEntry, attrs[0]);
            rpValuesToFree[i] = rpValues;
            //
            // Sanity check
            //
            if (ldap_count_valuesW(rpValues) == 0 || rpValues[0][0] == L'\0') {
                dwErr = ERROR_UNEXP_NET_ERR;
            } else {
                allValues[i] = rpValues[0];
                pEntry = ldap_next_entry(pLDAP, pEntry);
            }

        }

        if (dwErr == ERROR_SUCCESS) {
            allValues[i] = NULL;
            rpValuesToFree[i] = NULL;
        } else {
            goto Cleanup;
        }

    }

    if (dwErr != ERROR_SUCCESS) {
        goto Cleanup;
    }

    //
    // Now we need to allocate the memory to hold this vector and return the results.
    //
    // First see how much space we need
    //

    for (i = len = cValues = 0; allValues[i]; i++) {
        if (*allValues[i] == UNICODE_PATH_SEP || GettingNames == TRUE) {
            len += sizeof(LPWSTR) + (wcslen(allValues[i]) + 1) * sizeof(WCHAR);
            cValues++;
        }
    }
    len += sizeof(LPWSTR);

    dwErr = NetApiBufferAllocate(len, (PVOID *)&resultVector);

    if (dwErr == ERROR_SUCCESS) {

        LPWSTR pstr = (LPWSTR)((PCHAR)resultVector + (cValues + 1) * sizeof(LPWSTR));
        ULONG slen;

        RtlZeroMemory(resultVector, len);

        len -= (cValues+1) * sizeof(LPWSTR);

        for (i = cValues = 0; allValues[i] && len >= sizeof(WCHAR); i++) {
            if (*allValues[i] == UNICODE_PATH_SEP || GettingNames == TRUE) {
                resultVector[cValues] = pstr;
                wcscpy(pstr, allValues[i]);
                slen = wcslen(allValues[i]);
                pstr += slen + 1;
                len -= (slen + 1) * sizeof(WCHAR);
                cValues++;
            }
        }

    } else {

        dwErr = ERROR_OUTOFMEMORY;
        goto Cleanup;

    }

    *List = resultVector;

Cleanup:

    if (ARGUMENT_PRESENT(wszDfsName)) {
        if (rpValues != NULL) {
            ldap_value_freeW(rpValues);
        }
    } else {
        if (rpValuesToFree != NULL) {
            for (i = 0; rpValuesToFree[i] != NULL; i++) {
                ldap_value_freeW(rpValuesToFree[i]);
            }
        }
        if (allValues != NULL) {
            NetApiBufferFree(allValues);
        }
    }

    if (pMsg != NULL) {
        ldap_msgfree(pMsg);
    }

    if (FtDfsDN != NULL) {
        NetApiBufferFree(FtDfsDN);
    }

    if (DfsConfigDN != NULL) {
        free(DfsConfigDN);
    }

    if (pLDAP != NULL && bUnbindNeeded == TRUE && pLDAP != pLdapConnection) {
        if (DfsSvcLdap)
            DbgPrint("DfsGetFtServersFromDs:ldap_unbind\n");
        ldap_unbind(pLDAP);
    }

AllDone:

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsGetFtServersFromDs returning %d\n", dwErr);
#endif

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\csites.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation
//
//  File:       csites.cxx
//
//  Contents:   This module contains the functions which deal with the site table
//
//  History:    02-Dec-1997     JHarper Created.
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dfsmsrv.h"
#include "csites.hxx"
#include "marshal.hxx"

INIT_DFS_SITENAME_INFO_MARSHAL_INFO();
INIT_DFS_SITELIST_INFO_MARSHAL_INFO()
INIT_DFSM_SITE_ENTRY_MARSHAL_INFO();

NTSTATUS
DfsSendDelete(
    LPWSTR ServerName);


//+----------------------------------------------------------------------------
//
//  Function:   CSites::CSites
//
//  Synopsis:   Constructor for CSites - Initializes, but does not load, the site table
//
//  Arguments:  [pwszFileName] -- Name of the folder/LDAP_OBJECT to use
//              [pdwErr] -- On return, the result of initializing the instance
//
//  Returns:    Result returned in pdwErr argument:
//
//              [ERROR_SUCCESS] -- Successfully initialized
//
//              [ERROR_OUTOFMEMORY] -- Out of memory.
//
//-----------------------------------------------------------------------------

CSites::CSites(
            LPWSTR pwszFileName,
            LPDWORD pdwErr)
{
    DWORD dwErr = 0;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CSites::+CSites(0x%x)\n",
        this));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("+++CSites::CSites @0x%x\n", this);
#endif

    _cRef = 0;
    _fDirty = FALSE;
    RtlZeroMemory(&_SiteTableGuid, sizeof(GUID));
    InitializeListHead(&_SiteTableHead);

    _pwszFileName = new WCHAR [wcslen(pwszFileName) + 1];

    if (_pwszFileName != NULL) {
        wcscpy(_pwszFileName, pwszFileName);
    } else {
        dwErr = ERROR_OUTOFMEMORY;
    }

    *pdwErr = dwErr;
}


//+----------------------------------------------------------------------------
//
//  Function:   CSites::~CSites
//
//  Synopsis:   Destructor for CSites - Deallocates the CSites object
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CSites::~CSites()
{
    PLIST_ENTRY pListHead;
    PDFSM_SITE_ENTRY pSiteInfo;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CSites::~CSites(0x%x)\n",
        this));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("---CSites::~CSites @0x%x\n", this);
#endif

    ASSERT (_cRef == 0);

    if (_pwszFileName) {
        delete [] _pwszFileName;
    }

    //
    // Delete the linked list of SiteInfo's
    //

    pListHead = &_SiteTableHead;

    while (pListHead->Flink != pListHead) {
        pSiteInfo = CONTAINING_RECORD(pListHead->Flink, DFSM_SITE_ENTRY, Link);
        RemoveEntryList(pListHead->Flink);
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CSites::~CSites: deleting SiteInfo@0x%x\n", pSiteInfo);
#endif
        delete [] pSiteInfo;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::AddRef
//
//  Synopsis:   Increases the ref count on the in-memory site table. If the
//              refcount is going from 0 to 1, an attempt is made to refresh
//              the in-memory site table from storage.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
CSites::AddRef()
{
    DWORD dwErr = 0;

    IDfsVolInlineDebOut((DEB_TRACE, "CSites::AddRef()\n"));

    _cRef++;

    if (_cRef == 1) {

        dwErr = _ReadSiteTable();

        _fDirty = FALSE;

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::Release
//
//  Synopsis:   Decrease the ref count on the in-memory site table. If the
//              refcount is going from 1 to 0, then attempt to flush the
//              table to storage, if something has changed.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID
CSites::Release()
{

    IDfsVolInlineDebOut((DEB_TRACE, "CSites::Release()\n"));

    ASSERT (_cRef > 0);

    _cRef--;

    if (_cRef == 0) {

        if (_fDirty == TRUE) {

            _WriteSiteTable();

            _fDirty = FALSE;

        }

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::AddOrUpdateSiteInfo
//
//  Synopsis:   Adds or updates an entry in the site table.
//
//  Arguments:  [pServerName] -- Server name to update
//              [SiteCount] -- Number of entries in pSites
//              [pSites] -- pointer to array of site information.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully updated the table
//
//-----------------------------------------------------------------------------

DWORD
CSites::AddOrUpdateSiteInfo(
            LPWSTR pServerName,
            ULONG SiteCount,
            PDFS_SITENAME_INFO pSites)
{
    PDFSM_SITE_ENTRY pSiteInfo;
    PDFSM_SITE_ENTRY pExistingInfo;
    DWORD dwErr;
    ULONG i;

    IDfsVolInlineDebOut((DEB_TRACE, "CSites::AddOrUpdateSiteInfo(%ws)\n", pServerName));

    dwErr = _AllocateSiteInfo(
                  pServerName,
                  SiteCount,
                  pSites,
                  &pSiteInfo);

    if (dwErr == ERROR_SUCCESS) {
        //
        // Only put the new entry in if it supercedes one there,
        // or is a new entry.
        // 
        pExistingInfo = LookupSiteInfo(pServerName);
        if (pExistingInfo != NULL) {
            if (_CompareEntries(pSiteInfo,pExistingInfo) == TRUE ) {
                //
                // Same info - no update needed
                //
                delete [] pSiteInfo;
            } else {
                //
                // Remove the existing entry
                //
                RemoveEntryList(&pExistingInfo->Link);
                delete [] pExistingInfo;
                //
                // Put the new one in
                //
                DfsSendUpdate(pServerName,SiteCount,pSites);
                InsertHeadList(&_SiteTableHead, &pSiteInfo->Link);
                _fDirty = TRUE;
            }
        } else {
            //
            // Not in table - put it in
            //
            DfsSendUpdate(pServerName,SiteCount,pSites);
            InsertHeadList(&_SiteTableHead, &pSiteInfo->Link);
            _fDirty = TRUE;
        }
    }
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::LookupSiteInfo
//
//  Synopsis:   Finds a site table entry
//
//  Arguments:  [pServerName] -- Server name to look up
//
//  Returns:    [NULL] -- No entry found
//              [PDFSM_SITE_ENTRY] -- pointer to found entry
//
//-----------------------------------------------------------------------------

PDFSM_SITE_ENTRY
CSites::LookupSiteInfo(
            LPWSTR pServerName)
{
    PLIST_ENTRY pListHead, pLink;
    PDFSM_SITE_ENTRY pSiteInfo;

    IDfsVolInlineDebOut((DEB_TRACE, "CSites::LookupSiteInfo(%ws)\n", pServerName));

    pListHead = &_SiteTableHead;

    if (pListHead->Flink == pListHead) {      // list empty
        return NULL;
    }

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteInfo = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
        if (_wcsicmp(pSiteInfo->ServerName,pServerName) == 0) {
            //
            // If this was marked for delete, it isn't any more.
            //
            pSiteInfo->Flags &= ~DFSM_SITE_ENTRY_DELETE_PENDING;
            return pSiteInfo;
        }
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::_AllocateSiteInfo, private
//
//  Synopsis:   Creates a DFSM_SITE_ENTRY struct, as one contiguous chunk of memory
//
//  Arguments:  [pServerName] -- Server name
//              [SiteCount] -- Number of entries in pSites
//              [pSites] -- pointer to array of site information.
//              [ppSiteInfo] -- pointer to pointer for the results
//
//  Returns:    [ERROR_SUCCESS] -- Successfully allocated and filled in the structure
//              [ERROR_OUTOFMEMORY] -- Couldn't allocate needed memory
//
//-----------------------------------------------------------------------------

DWORD
CSites::_AllocateSiteInfo(
          PWSTR pServerName,
          ULONG SiteCount,
          PDFS_SITENAME_INFO pSites,
          PDFSM_SITE_ENTRY *ppSiteInfo)
{
    PDFSM_SITE_ENTRY pSiteInfo;
    WCHAR *wCp;
    ULONG i;
    ULONG Size = 0;

    IDfsVolInlineDebOut((DEB_TRACE, "CSites::_AllocateSiteInfo(%ws)\n", pServerName));

    //
    // Calculate the size chunk of mem we'll need
    //

    Size = FIELD_OFFSET(DFSM_SITE_ENTRY,Info.Site[SiteCount]);

    //
    // Add space for server name
    //

    Size += (wcslen(pServerName) + 1) * sizeof(WCHAR);

    //
    // And space for all the sitenames
    //
    for (i = 0; i < SiteCount; i++) {
        if (pSites[i].SiteName != NULL) {
            Size += (wcslen(pSites[i].SiteName) + 1) * sizeof(WCHAR);
        } else {
            Size += sizeof(WCHAR);
        }
    }

    pSiteInfo = (PDFSM_SITE_ENTRY) new CHAR [Size];

    if (pSiteInfo == NULL) {
        *ppSiteInfo = NULL;
        return ERROR_OUTOFMEMORY;
    }

    RtlZeroMemory(pSiteInfo, Size);

    //
    // Marshal the info into the buffer
    //
    pSiteInfo->Flags = 0;
    pSiteInfo->Info.cSites = SiteCount;

    wCp = (WCHAR *) &pSiteInfo->Info.Site[SiteCount];
    pSiteInfo->ServerName = wCp;
    wcscpy(wCp, pServerName);
    wCp += wcslen(pServerName) + 1;

    for (i = 0; i < SiteCount; i++) {
        pSiteInfo->Info.Site[i].SiteFlags = pSites[i].SiteFlags;
        pSiteInfo->Info.Site[i].SiteName = wCp;
        if (pSites[i].SiteName != NULL) {
            wcscpy(wCp, pSites[i].SiteName);
            wCp += wcslen(pSites[i].SiteName) + 1;
        } else {
            *wCp++ = UNICODE_NULL;
        }
    }

    *ppSiteInfo = pSiteInfo;

    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::_ReadSiteTable,private
//
//  Synopsis:   Loads the site table from storage
//
//              First we check if the GUID has changed.  If it hasn't, we abort the
//              load - the existing table is good.
// 
//              If the table is different (the GUID is different), we merge the new
//              data in with the old.  This allows us to track which entries need to
//              be updated, which need to be deleted, and which haven't changed.  The
//              process is done in three steps:
//
//              Step 1: Go through the table, marking all the entries DELETE_PENDING
//              Step 2: Load the new entries.  As they are loaded, the updated entries'
//                      DELETE_PENDING bit(s) are turned off.
//              Step 3: Go though the table again, removing any entries that still
//                      have the DELETE_PENDING bit on, and issuing an FSCTL to dfs.sys
//                      to have it remove the entry from its table.
//
//  Arguments:  None
//
//  Returns:    [ERROR_SUCCESS] -- Successfully loaded the table
//              [ERROR_OUTOFMEMORY] -- Not enough memory
//              [other] -- returned from LdapGetData/RegGetData/DfsRtlXXX
//
//-----------------------------------------------------------------------------

DWORD
CSites::_ReadSiteTable()
{
    DWORD dwErr;
    DWORD cbBuffer;
    PBYTE pBuffer = NULL;
    PBYTE bp;
    ULONG cObjects = 0;
    ULONG i;
    ULONG j;
    PDFSM_SITE_ENTRY pSiteInfo;
    MARSHAL_BUFFER marshalBuffer;
    GUID TempGuid;

    IDfsVolInlineDebOut((DEB_TRACE, "CSites::_ReadSiteTable()\n"));

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {

        dwErr = LdapGetData(
                    _pwszFileName,
                    &cbBuffer,
                    (PCHAR *)&pBuffer);

    } else {

        dwErr = RegGetData(
                    _pwszFileName,
                    SITE_VALUE_NAME,
                    &cbBuffer,
                    &pBuffer);

    }

    if (dwErr == ERROR_SUCCESS && cbBuffer >= sizeof(ULONG) + sizeof(GUID)) {

        //
        // Unmarshal all the objects (DFS_SITENAME_INFO's) in the buffer
        //
        //
        // We marshal into a temporary buffer, big enough to hold whatever is
        // in the buffer.
        //

	pSiteInfo = (PDFSM_SITE_ENTRY) new BYTE [cbBuffer + sizeof(DFSM_SITE_ENTRY)];

        if (pSiteInfo == NULL) {

            dwErr = ERROR_OUTOFMEMORY;

        }

        if (dwErr == ERROR_SUCCESS) {

            MarshalBufferInitialize(
              &marshalBuffer,
              cbBuffer,
              pBuffer);

            DfsRtlGetGuid(&marshalBuffer, &TempGuid);

            //
            // If the Guid hasn't changed, we abort the load.
            //

            if (RtlCompareMemory(&TempGuid, &_SiteTableGuid, sizeof(GUID)) == sizeof(GUID)) {

                delete [] pSiteInfo;
                delete [] pBuffer;
                goto NoLoadNecessary;

            }

            //
            // Ok, we're committed to loading this (supposedly different) version
            // of the site table.  Mark all the existing entries DFSM_SITE_ENTRY_DELETE_PENDING.
            //

            MarkEntriesForMerge();

            //
            // Grab the Guid
            //

            RtlCopyMemory(&_SiteTableGuid, &TempGuid, sizeof(GUID));

            //
            // Get number of entries we'll be loading
            //

            DfsRtlGetUlong(&marshalBuffer, &cObjects);

            //
            // Now unmarshal each object/entry
            //

            for (j = 0; dwErr == ERROR_SUCCESS && j < cObjects; j++) {

                dwErr = DfsRtlGet(&marshalBuffer,&MiDfsmSiteEntry, pSiteInfo);

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // And put it in the site table
                    //

                    AddOrUpdateSiteInfo(
                        pSiteInfo->ServerName,
                        pSiteInfo->Info.cSites,
                        &pSiteInfo->Info.Site[0]);

                    //
                    // The unmarshalling routines allocate buffers; we need to
                    // free them.
                    //

                    for (i = 0; i < pSiteInfo->Info.cSites; i++) {
                        MarshalBufferFree(pSiteInfo->Info.Site[i].SiteName);
                    }

                    MarshalBufferFree(pSiteInfo->ServerName);

                }

                //
                // Now sync up the PKT in dfs.sys with this table
                //
                SyncPktSiteTable();

            }

            delete [] pSiteInfo;

        }

    }

    if (pBuffer != NULL) {

        delete [] pBuffer;

    }

NoLoadNecessary:

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::_WriteSiteTable,private
//
//  Synopsis:   Writes the site table to storage
//
//  Arguments:  None
//
//  Returns:    [ERROR_SUCCESS] -- Successfully write the table
//              [ERROR_OUTOFMEMORY] -- Not enough memory
//              [other] -- returned from LdapGetData/RegGetData/DfsRtlXXX
//
//-----------------------------------------------------------------------------

DWORD
CSites::_WriteSiteTable()
{   
    DWORD dwErr;
    DWORD cbBuffer;
    PBYTE pBuffer;
    ULONG cObjects;
    ULONG i;
    PLIST_ENTRY pListHead, pLink;
    PDFSM_SITE_ENTRY pSiteInfo;
    MARSHAL_BUFFER marshalBuffer;

    IDfsVolInlineDebOut((DEB_TRACE, "CSites::_WriteSiteTable()\n"));

    //
    // Create a new Guid
    //

    UuidCreate(&_SiteTableGuid);

    //
    // The cObjects count
    //
    cbBuffer = sizeof(ULONG) + sizeof(GUID);

    //
    // Add up the number of entries we need to store, and the total size of all
    // of them.
    //
    cObjects = 0;
    pListHead = &_SiteTableHead;
    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteInfo = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
        DfsRtlSize(&MiDfsmSiteEntry, pSiteInfo, &cbBuffer);
        cObjects++;
    }

    //
    // Get a buffer big enough
    //

    pBuffer = new BYTE [cbBuffer];

    if (pBuffer == NULL) {

        return ERROR_OUTOFMEMORY;

    }

    //
    // Put the guid, then the object count in the beginning of the buffer
    //

    MarshalBufferInitialize(
          &marshalBuffer,
          cbBuffer,
          pBuffer);

    DfsRtlPutGuid(&marshalBuffer, &_SiteTableGuid);
    DfsRtlPutUlong(&marshalBuffer, &cObjects);

    //
    // Walk the linked list of objects, marshalling them into the buffer.
    //
    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteInfo = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
        DfsRtlPut(&marshalBuffer,&MiDfsmSiteEntry, pSiteInfo);
    }

    //
    // Push out to storage
    //
    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {

        dwErr = LdapPutData(
                    _pwszFileName,
                    cbBuffer,
                    (PCHAR)pBuffer);

    } else {

        dwErr = RegPutData(
                    _pwszFileName,
                    SITE_VALUE_NAME,
                    cbBuffer,
                    pBuffer);

    }

    //
    // ...and free the marshal buffer we created.
    //
    delete [] pBuffer;

    return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::_CompareEntries,private
//
//  Synopsis:   Compare two site table entries - case insensitive, and allows the site
//              lists to be in different order.
//
//  Arguments:  None
//
//  Returns:    [TRUE] -- The entries are essentially identical
//              [FALSE] -- The entries differ in some important way
//
//-----------------------------------------------------------------------------

BOOLEAN
CSites::_CompareEntries(
    PDFSM_SITE_ENTRY pDfsmInfo1,
    PDFSM_SITE_ENTRY pDfsmInfo2)
{
    ULONG i;
    ULONG j;
    BOOLEAN fFound;

    //
    // cSites has to be the same
    //

    if (pDfsmInfo1->Info.cSites != pDfsmInfo2->Info.cSites) {
        goto ReturnFalse;
    }

    //
    // Server name has to be identical (why are we calling this
    // if they aren't?)
    //
    if (_wcsicmp(pDfsmInfo1->ServerName,pDfsmInfo2->ServerName) != 0) {
        goto ReturnFalse;
    }

    //
    // Check that every Site in pDfsmInfo1 is in pDfsmSiteInfo2
    //
    for (i = 0; i < pDfsmInfo1->Info.cSites; i++) {
        fFound = FALSE;
        for (j = 0; fFound == FALSE && j < pDfsmInfo2->Info.cSites; j++) {
            if (_wcsicmp(
                    pDfsmInfo1->Info.Site[i].SiteName,
                    pDfsmInfo2->Info.Site[j].SiteName) == 0) {
                fFound = TRUE;
            }
        }
        if (fFound == FALSE) {
            goto ReturnFalse;
        }
    }
    
    //
    // ...and check that every site in pDfsmInfo2 is in pDfsmInfo1
    //
    for (i = 0; i < pDfsmInfo2->Info.cSites; i++) {
        fFound = FALSE;
        for (j = 0; fFound == FALSE && j < pDfsmInfo1->Info.cSites; j++) {
            if (_wcsicmp(
                    pDfsmInfo2->Info.Site[i].SiteName,
                    pDfsmInfo1->Info.Site[j].SiteName) == 0) {
                fFound = TRUE;
            }
        }
        if (fFound == FALSE) {
            goto ReturnFalse;
        }
    }

    return TRUE;

ReturnFalse:

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::MarkEntriesForMerge
//
//  Synopsis:   Mark all entries in preparation for a merge.
//              (1)  Mark all entries with delete_pending on
//              (2)  Load a new table - duplicate entries remove the delete_pending bit
//              (3)  Call SyncPktSiteTable(), which will bring the PKT in dfs.sys up to date,
//                   by deleting delete_pending entries
//
//  Arguments:  None
//
//  Returns:    nothing
//
//-----------------------------------------------------------------------------

VOID
CSites::MarkEntriesForMerge()
{
    PLIST_ENTRY pListHead, pLink;
    PDFSM_SITE_ENTRY pSiteInfo;
    ULONG i;

    pListHead = &_SiteTableHead;

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteInfo = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
        pSiteInfo->Flags |= DFSM_SITE_ENTRY_DELETE_PENDING;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::SyncPktSiteTable
//
//  Synopsis:   Step 3 of a table merge.  Walk the table, removing any entries
//              with the DFSM_SITE_ENTRY_DELETE_PENDING (and telling dfs.sys
//              to do so)
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

VOID
CSites::SyncPktSiteTable()
{
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pLink;
    PLIST_ENTRY pNext;
    PDFSM_SITE_ENTRY pSiteInfo;

    IDfsVolInlineDebOut((DEB_TRACE, "CSites::SyncPktSiteTable()\n"));
    
    pListHead = &_SiteTableHead;

    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pNext) {

        //
        // Save next in case we delete this one
        //
        pNext = pLink->Flink;

        pSiteInfo = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);

        if ((pSiteInfo->Flags & DFSM_SITE_ENTRY_DELETE_PENDING) != 0) {
            //
            // call dfs.sys with the update
            //
            DfsSendDelete(pSiteInfo->ServerName);
            RemoveEntryList(pLink);
            delete [] pSiteInfo;
            _fDirty = TRUE;
        }
    }
    IDfsVolInlineDebOut((DEB_TRACE, "CSites::SyncPktSiteTable exit\n"));
}

//+----------------------------------------------------------------------------
//
//  Function:   CSites::_DumpSiteTable
//
//  Synopsis:   Spill dfs's guts about site table entries.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------
VOID
CSites::_DumpSiteTable()
{
    PLIST_ENTRY pListHead, pLink;
    PDFSM_SITE_ENTRY pSiteInfo;
    ULONG i;

    pListHead = &_SiteTableHead;

    //
    // Print them (for debugging)
    //
    for (pLink = pListHead->Flink; pLink != pListHead; pLink = pLink->Flink) {
        pSiteInfo = CONTAINING_RECORD(pLink, DFSM_SITE_ENTRY, Link);
        DbgPrint("\tpSiteInfo(%ws)\n", pSiteInfo->ServerName);
        for (i = 0; i < pSiteInfo->Info.cSites; i++) {
            DbgPrint("\t\t%02d:%ws\n", i, pSiteInfo->Info.Site[i].SiteName);
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsSendDelete, private
//
//  Synopsis:   Send a DFS_DELETE_SITE_ARG down to dfs.sys
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsSendDelete(
    LPWSTR ServerName)
{
    ULONG size;
    DWORD dwErr;
    PDFS_DELETE_SITE_INFO_ARG arg;

    size = sizeof(DFS_DELETE_SITE_INFO_ARG) +
                wcslen(ServerName) * sizeof(WCHAR);

    arg = (PDFS_DELETE_SITE_INFO_ARG) new CHAR [size];

    if (arg == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    arg->ServerName.Buffer = (WCHAR *) &arg[1];
    arg->ServerName.Length = wcslen(ServerName) * sizeof(WCHAR);
    arg->ServerName.MaximumLength = arg->ServerName.Length;
    RtlCopyMemory(arg->ServerName.Buffer, ServerName, arg->ServerName.Length);

    LPWSTR_TO_OFFSET(arg->ServerName.Buffer,arg);

    dwErr = DfsDeleteSiteEntry((PCHAR)arg, size);

    delete [] arg;

    return dwErr;
}


//+----------------------------------------------------------------------------
//
//  Function:   DfsSendUpdate, private
//
//  Synopsis:   Send a DFS_CREATE_SITE_ARG down to dfs.sys
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

NTSTATUS
DfsSendUpdate(
    LPWSTR ServerName,
    ULONG SiteCount,
    PDFS_SITENAME_INFO pSites)
{
    ULONG size;
    DWORD dwErr;
    ULONG i;
    PDFS_CREATE_SITE_INFO_ARG arg;
    WCHAR *wCp;

    size = FIELD_OFFSET(DFS_CREATE_SITE_INFO_ARG,SiteName[SiteCount]) +
                wcslen(ServerName) * sizeof(WCHAR);

    for (i = 0; i < SiteCount; i++) {
        size += wcslen(pSites[i].SiteName) * sizeof(WCHAR);
    }

    arg = (PDFS_CREATE_SITE_INFO_ARG) new CHAR [size];

    if (arg == NULL) {
        return ERROR_OUTOFMEMORY;
    }

    wCp = (WCHAR *)(&arg->SiteName[SiteCount]);

    arg->ServerName.Buffer = wCp;
    wCp += wcslen(ServerName);
    arg->ServerName.Length = wcslen(ServerName) * sizeof(WCHAR);
    arg->ServerName.MaximumLength = arg->ServerName.Length;
    RtlCopyMemory(arg->ServerName.Buffer, ServerName, arg->ServerName.Length);
    LPWSTR_TO_OFFSET(arg->ServerName.Buffer,arg);
    arg->SiteCount = SiteCount;

    for (i = 0; i < SiteCount; i++) {
        arg->SiteName[i].Buffer = wCp;
        wCp += wcslen(pSites[i].SiteName);
        arg->SiteName[i].Length = wcslen(pSites[i].SiteName) * sizeof(WCHAR);
        arg->SiteName[i].MaximumLength = arg->SiteName[i].Length;
        RtlCopyMemory(arg->SiteName[i].Buffer, pSites[i].SiteName, arg->SiteName[i].Length);
        LPWSTR_TO_OFFSET(arg->SiteName[i].Buffer,arg);
    }

    dwErr = DfsCreateSiteEntry((PCHAR)arg, size);

    delete [] arg;

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\cregstor.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation
//
//  File:       CRegStor.cxx
//
//  Contents:   Implementation of classes derived from CStorage and
//              CEnumStorage that use the NT Registry for persistent storage.
//
//              In addition to providing this, this class
//              maintains a global mapping from the Prefix property to
//              "object name" in an object directory. Thus, given an
//              Prefix, one can find the object path.
//
//              Note that this map from Prefix to object path has the
//              following restrictions:
//
//              o At process start time, all objects are "read in" and their
//                ReadIdProps() method called. This is needed to populate the
//                map.
//
//              o When a new object is created, its SetIdProps() method must
//                be called before it can be located via the map.
//
//              o Maps are many to 1 - many EntryPaths may map to the same
//                object. At no point in time can one try to map the same
//                EntryPath to many objects.
//
//  Classes:    CRegStorage
//
//  Functions:
//
//  History:    12-19-95        Milans created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "cregstor.hxx"
#include "recon.hxx"                             // For DFS_ID_PROPS
#include "marshal.hxx"                           // For MiDfsIdProps

INIT_FILE_TIME_INFO()                            // Initialize some needed
INIT_DFS_ID_PROPS_INFO()                         // marshalling infos

#define VERSION_PROPS        L"Version"
#define ID_PROPS             L"ID"
#define SVC_PROPS            L"Svc"
#define RECOVERY_PROPS       L"Recovery"

DWORD
DfsmQueryValue(
    HKEY hkey,
    LPWSTR wszValueName,
    DWORD dwExpectedType,
    DWORD dwExpectedSize,
    PBYTE pBuffer,
    LPDWORD cbBuffer);

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::CRegStorage
//
//  Synopsis:   Constructor for CRegStorage object. Opens the key given by
//              the name and makes a copy of the name.
//
//  Arguments:  [pwszFileName] -- Name of subkey to open.
//              [pdwErr] -- If the constructor fails, this value is set to an
//                      appropriate error code.
//
//  Returns:    Nothing. However, if an error occurs, the error code is
//              returned via the pdwErr argument
//
//-----------------------------------------------------------------------------

CRegStorage::CRegStorage(
    LPCWSTR     lpwszFileName,
    DWORD       *pdwErr) :
        CStorage(lpwszFileName),
        _pwszPrefix(NULL),
        _wszFileName(NULL),
        _hKey(NULL)
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CRegStorage::+CRegStorage(0x%x)\n",
        this));

    *pdwErr = RegOpenKey( HKEY_LOCAL_MACHINE, lpwszFileName, &_hKey );

    if (*pdwErr == ERROR_SUCCESS) {

        _wszFileName = new WCHAR[ wcslen(lpwszFileName) + 1];

        if (_wszFileName != NULL) {

            wcscpy( _wszFileName, lpwszFileName );

        } else {

            *pdwErr = ERROR_OUTOFMEMORY;

            RegCloseKey( _hKey );

            _hKey = NULL;

        }

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::~CRegStorage
//
//  Synopsis:   Destructor for CRegStorage object.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CRegStorage::~CRegStorage()
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CRegStorage::~CRegStorage(0x%x)\n",
        this));

    if (_hKey != NULL)
        RegCloseKey( _hKey );

    if (_wszFileName != NULL)
        delete [] _wszFileName;

    if (_pwszPrefix != NULL)
        delete [] _pwszPrefix;

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::DestroyElement
//
//  Synopsis:   Deletes a child key
//
//  Arguments:  [lpwszChildName] -- Name of child key to delete
//
//  Returns:    Result of trying to delete the child key
//
//-----------------------------------------------------------------------------

DWORD CRegStorage::DestroyElement(
    IN LPCWSTR lpwszChildName)
{
    DWORD dwErr;

    dwErr = RegDeleteKey( _hKey, lpwszChildName );

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::GetEnumDirectory
//
//  Synopsis:   Returns an enumerator for the child keys of this CRegStorage
//              object.
//
//  Arguments:  [ppRegDir] -- If successful, ppRegDir is set to point to an
//                      object of class CRegEnumDirectory.
//
//  Returns:    S_OK if successful.
//
//              ERROR_OUTOFMEMORY if unable to allocate memory for new object.
//
//              DWORD_FROM_WIN32 of error set by DuplicateHandle
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::GetEnumDirectory(
    CEnumDirectory **ppRegDir)
{

    DWORD dwErr;
    CRegEnumDirectory *pRegDir;

    pRegDir = new CRegEnumDirectory( _hKey, &dwErr );

    if (pRegDir == NULL) {

        dwErr = ERROR_OUTOFMEMORY;

    } else if (dwErr) {

        pRegDir->Release();

        pRegDir = NULL;

    }

    *ppRegDir = (CEnumDirectory *) pRegDir;

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::SetVersionProps
//
//  Synopsis:   Sets the version property set of a Dfs Manager volume object.
//
//  Arguments:  [ulVersion] -- The version number to set.
//
//  Returns:    [S_OK] -- If property set.
//
//              DWORD_FROM_WIN32 of RegSetValue.
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::SetVersionProps(
    IN ULONG ulVersion)
{
    DWORD dwErr;

    dwErr = RegSetValueEx(
                _hKey,
                VERSION_PROPS,
                NULL,
                REG_DWORD,
                (LPBYTE) &ulVersion,
                sizeof(ulVersion));

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::GetVersionProps
//
//  Synopsis:   Retrieves the version property set of a Dfs Manager volume
//              object.
//
//  Arguments:  [pulVersion] -- On successful return, contains the value
//                      of the Version property.
//
//  Returns:    [S_OK] -- If successful.
//
//              DWORD from DfsmQueryValue
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::GetVersionProps(
    PULONG pulVersion)
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cbSize;

    cbSize = sizeof(*pulVersion);

    dwErr = DfsmQueryValue(
            _hKey,
            VERSION_PROPS,
            REG_DWORD,
            sizeof(DWORD),
            (LPBYTE) pulVersion,
            &cbSize);

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::SetIdProps
//
//  Synopsis:   Sets the ID properties of a Dfs Manager volume object. Also
//              updates the CRegStorageDirectory to add a mapping from
//              the prefix to this object name, if necessary.
//
//              The pseudo algorithm is:
//
//                Phase 1
//                  Add mapping of prefix to DfsmStorageDirectory if needed.
//                Phase 2
//                  Update the ID props in the registry.
//                Phase 3
//                  if (success)
//                      delete mapping of old prefix, if any, from Directory
//                  else
//                      delete mapping of new prefix from directory
//
//              This algorithm assumes that deleting a prefix mapping from
//              the directory is guaranteed to succeed. Based on this
//              assumption, we can maintain a guaranteed consistency between
//              DfsmStorageDirectory and the ID property stored in the
//              registry.
//
//  Arguments:
//
//  Returns:    [S_OK] -- If successful.
//
//              [ERROR_OUTOFMEMORY] -- If unable to allocate memory for
//                      internal use.
//
//              [ERROR_INVALID_PARAMETER] -- If unable to parse the passed in
//                      parameters.
//
//              DWORD_FROM_WIN32 of RegSetValueEx return code.
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::SetIdProps(
    ULONG dwType,
    ULONG dwState,
    LPWSTR pwszPrefix,
    LPWSTR pwszShortPath,
    GUID   idVolume,
    LPWSTR  pwszComment,
    ULONG dwTimeout,
    FILETIME ftPrefix,
    FILETIME ftState,
    FILETIME ftComment)
{
    DWORD dwErr;
    NTSTATUS status;
    DFS_ID_PROPS idProps;
    MARSHAL_BUFFER marshalBuffer;
    PBYTE pBuffer;
    ULONG cbBuffer;
    LPWSTR pwszOldPrefix = NULL;
    BOOLEAN fRegisteredNewPrefix = FALSE;

    //
    // Phase 1.
    // First, update the CRegStorageDirectory if needed.
    //

    if ((_pwszPrefix) != NULL && (_wcsicmp(_pwszPrefix, pwszPrefix) != 0)) {

        //
        // Our prefix changed. At this point, we'll only register the
        // new prefix, leaving the old prefix in place. This will aid
        // rollback if necessary.
        //

        pwszOldPrefix = _pwszPrefix;

        _pwszPrefix = NULL;

    }

    if (_pwszPrefix == NULL) {

        ASSERT(pwszPrefix != NULL);

        _pwszPrefix = new WCHAR [ wcslen(pwszPrefix) + 1 ];

        if (_pwszPrefix != NULL) {

            wcscpy( _pwszPrefix, pwszPrefix );

            dwErr = pDfsmStorageDirectory->_InsertIfNeeded(
                        _pwszPrefix,
                        _wszFileName);

            ASSERT( dwErr != NERR_DfsInconsistent );

            if (dwErr == ERROR_SUCCESS)
                fRegisteredNewPrefix = TRUE;

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

        if (dwErr != ERROR_SUCCESS)
            goto Cleanup;

    }

    //
    // Phase 2.
    // Next, try to update the registry with the new ID props. Note that
    // we do not persist the first component (machine name) of the prefix
    //

    idProps.wszPrefix = wcschr( &pwszPrefix[1], UNICODE_PATH_SEP );
    idProps.wszShortPath = wcschr( &pwszShortPath[1], UNICODE_PATH_SEP );
    idProps.idVolume = idVolume;
    idProps.dwState = dwState;
    idProps.dwType = dwType;
    idProps.wszComment = pwszComment;
    idProps.dwTimeout = dwTimeout;
    idProps.ftEntryPath = ftPrefix;
    idProps.ftState = ftState;
    idProps.ftComment = ftComment;

    cbBuffer = 0;

    status = DfsRtlSize( &MiDfsIdProps, &idProps, &cbBuffer );

    if (NT_SUCCESS(status)) {

        //
        // Add extra bytes for the timeout, which will go at the end
        //

        cbBuffer += sizeof(ULONG);

        pBuffer = new BYTE [cbBuffer];

        if (pBuffer != NULL) {

            MarshalBufferInitialize( &marshalBuffer, cbBuffer, pBuffer);

            status = DfsRtlPut( &marshalBuffer, &MiDfsIdProps, &idProps );

            if (NT_SUCCESS(status)) {

                DfsRtlPutUlong(&marshalBuffer, &dwTimeout);

                dwErr = RegSetValueEx(
                            _hKey,
                            ID_PROPS,
                            NULL,
                            REG_BINARY,
                            pBuffer,
                            cbBuffer);

            } else {

                dwErr = ERROR_INVALID_PARAMETER;

            }

            delete [] pBuffer;

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_INVALID_PARAMETER;

    }

Cleanup:

    //
    // Phase 3.
    // Lastly, either delete any old prefix from DfsmStorageRegistry, or
    // rollback any changes made to DfsmStorageRegistry if needed.
    //

    if (dwErr == ERROR_SUCCESS) {

        //
        // The entire operation was successful. See if we need to delete any
        // old prefix mapping in DfsmStorageDirectory
        //

        if (pwszOldPrefix != NULL) {

            DWORD dwErrDelete;

            dwErrDelete = pDfsmStorageDirectory->_Delete( pwszOldPrefix );

            ASSERT( dwErrDelete == ERROR_SUCCESS );

            delete [] pwszOldPrefix;

        }

    } else {

        //
        // An error occured somewhere along the line. Delete any new prefix
        // mapping that may have been made, and restore the original
        // _pwszPrefix if necessary.
        //

        if (fRegisteredNewPrefix) {

            DWORD dwErrDelete;

            dwErrDelete = pDfsmStorageDirectory->_Delete( _pwszPrefix );

            ASSERT( dwErrDelete == ERROR_SUCCESS );

        }

        if (pwszOldPrefix != NULL) {

            if (_pwszPrefix != NULL) {

                delete [] _pwszPrefix;

            }

            _pwszPrefix = pwszOldPrefix;

        }
    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::GetIdProps
//
//  Synopsis:   Retrieves the Id Properties of a Dfs Manager volume object.
//              Also, if this is the first time that the ID Props are being
//              read, a mapping from the retrieved prefix to the object name
//              is registered in DfsmStorageDirectory.
//
//  Arguments:
//
//  Returns:    [S_OK] -- Successfully retrieved the properties.
//
//              [DFS_E_VOLUME_OBJECT_CORRUPT] -- The stored properties could
//                      not be parsed properly.
//
//              [DFS_E_INCONSISTENT] -- Another volume object seems to have
//                      the same prefix!
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate memory for properties
//                      or other uses.
//
//              DWORD from DfsmQueryValue
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::GetIdProps(
    PULONG pdwType,
    PULONG pdwState,
    LPWSTR *ppwszPrefix,
    LPWSTR *ppwszShortPath,
    GUID   *pidVolume,
    LPWSTR  *ppwszComment,
    PULONG pdwTimeout,
    FILETIME *pftPrefix,
    FILETIME *pftState,
    FILETIME *pftComment)
{
    DWORD dwErr;
    NTSTATUS status;
    DWORD dwUnused, dwType, cbBuffer;
    ULONG dwTimeout;
    PBYTE pBuffer;
    MARSHAL_BUFFER marshalBuffer;
    DFS_ID_PROPS idProps;

    *ppwszPrefix = NULL;

    *ppwszComment = NULL;

    dwErr = RegQueryInfoKey(
                _hKey,                          // Key
                NULL,                            // Class string
                NULL,                            // Size of class string
                NULL,                            // Reserved
                &dwUnused,                       // # of subkeys
                &dwUnused,                       // max size of subkey name
                &dwUnused,                       // max size of class name
                &dwUnused,                       // # of values
                &dwUnused,                       // max size of value name
                &cbBuffer,                       // max size of value data,
                NULL,                            // security descriptor
                NULL);                           // Last write time

    if (dwErr == ERROR_SUCCESS) {

        pBuffer = new BYTE [cbBuffer];

        if (pBuffer != NULL) {

            dwErr = DfsmQueryValue(
                    _hKey,
                    ID_PROPS,
                    REG_BINARY,
                    0,
                    pBuffer,
                    &cbBuffer);

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

        if (dwErr == ERROR_SUCCESS) {

            MarshalBufferInitialize(&marshalBuffer, cbBuffer, pBuffer);

            status = DfsRtlGet(&marshalBuffer, &MiDfsIdProps, &idProps);

            if (NT_SUCCESS(status)) {

                #define GIP_DUPLICATE_STRING(dwErr, src, dest)          \
                    if ((src) != NULL)                                  \
                        (*(dest)) = new WCHAR [ wcslen(src) + 1 ];      \
                    else                                                \
                        (*(dest)) = new WCHAR [1];                      \
                                                                        \
                    if (*(dest) != NULL)                                \
                        if ((src) != NULL)                              \
                            wcscpy( *(dest), (src) );                   \
                        else                                            \
                            (*(dest))[0] = UNICODE_NULL;                \
                    else                                                \
                        dwErr = ERROR_OUTOFMEMORY;

                #define GIP_DUPLICATE_PREFIX(dwErr, src, dest)          \
                    (*(dest)) = new WCHAR [ 1 +                         \
                                    wcslen(pwszDfsRootName) +           \
                                        ((src) ? wcslen(src) : 0) +     \
                                            1];                         \
                    if ((*(dest)) != NULL) {                            \
                        wcscpy( *(dest), UNICODE_PATH_SEP_STR );        \
                        wcscat( *(dest), pwszDfsRootName );             \
                        if (src)                                        \
                            wcscat( *(dest), (src) );                   \
                    } else {                                            \
                        dwErr = ERROR_OUTOFMEMORY;                      \
                    }

                if (pwszDfsRootName != NULL) {

                    GIP_DUPLICATE_PREFIX( dwErr, idProps.wszPrefix, ppwszPrefix );

                    if (dwErr == ERROR_SUCCESS) {

                        GIP_DUPLICATE_PREFIX(
                            dwErr,
                            idProps.wszShortPath,
                            ppwszShortPath );

                    }

                } else {

                    dwErr = ERROR_INVALID_NAME;

                }

                if (dwErr == ERROR_SUCCESS) {

                    GIP_DUPLICATE_STRING(
                        dwErr,
                        idProps.wszComment,
                        ppwszComment);

                }
                
                //
                // There are two possible versions of the blob.  One has the timeout
                // after all the other stuff, the other doesn't.
                // So, if there are sizeof(ULONG) bytes left in the blob,
                // assume it is the timeout.  Otherwise this is an old
                // version of the blob, and the timeout isn't here, so we set it to
                // the global value.

                idProps.dwTimeout = GTimeout;

                if (
                    (marshalBuffer.Current < marshalBuffer.Last)
                        &&
                    (marshalBuffer.Last - marshalBuffer.Current) == sizeof(ULONG)
                ) {

                    DfsRtlGetUlong(&marshalBuffer, &idProps.dwTimeout);

                }

                if (dwErr == ERROR_SUCCESS) {

                    *pdwType = idProps.dwType;
                    *pdwState = idProps.dwState;
                    *pidVolume = idProps.idVolume;
                    *pdwTimeout = idProps.dwTimeout;
                    *pftPrefix = idProps.ftEntryPath;
                    *pftState = idProps.ftState;
                    *pftComment = idProps.ftComment;

                }

                if (dwErr == ERROR_SUCCESS) {

                    if (_pwszPrefix != NULL) {

                        delete [] _pwszPrefix;

                    }

                    _pwszPrefix = new WCHAR[ wcslen(*ppwszPrefix) + 1];

                    if (_pwszPrefix != NULL) {

                        wcscpy( _pwszPrefix, *ppwszPrefix );

                        dwErr = pDfsmStorageDirectory->_InsertIfNeeded(
                                _pwszPrefix,
                                _wszFileName);

                    } else {

                        dwErr = ERROR_OUTOFMEMORY;

                    }

                }

                if (dwErr != ERROR_SUCCESS) {

                    if (*ppwszPrefix != NULL) {
                        delete [] *ppwszPrefix;
                        *ppwszPrefix = NULL;
                    }

                    if (*ppwszShortPath != NULL) {
                        delete [] *ppwszShortPath;
                        *ppwszShortPath = NULL;
                    }

                    if (*ppwszComment != NULL) {
                        delete [] *ppwszComment;
                        *ppwszComment = NULL;
                    }

                }

                if (idProps.wszPrefix != NULL)
                    MarshalBufferFree(idProps.wszPrefix);

                if (idProps.wszShortPath != NULL)
                    MarshalBufferFree(idProps.wszShortPath);

                if (idProps.wszComment != NULL)
                    MarshalBufferFree(idProps.wszComment);

            } else {

                if (status == STATUS_INSUFFICIENT_RESOURCES) {

                    dwErr = ERROR_OUTOFMEMORY;

                } else {

                    dwErr = NERR_DfsInternalCorruption;

                }

            }

        }

        if (pBuffer != NULL) {

            delete [] pBuffer;

        }

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::SetSvcProps
//
//  Synopsis:   Sets the Svc properties of a Dfs Manager volume object
//
//  Arguments:  [pBuffer] -- Svc argument buffer
//              [cbBuffer] -- Size of Svc argument buffer
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::SetSvcProps(
    PBYTE pSvc,
    ULONG cbSvc)
{
    return( SetBlobProp( SVC_PROPS, pSvc, cbSvc ) );
}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::GetSvcProps
//
//  Synopsis:   Retrieves the Svc properties of a Dfs Manager volume
//              object.
//
//  Arguments:  [ppSvc] -- On successful return, points to a buffer
//                      allocated to hold the Svc property.
//              [pcbSvc] -- On successful return, size in bytes of
//                      Svc buffer.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::GetSvcProps(
    PBYTE *ppSvc,
    PULONG pcbSvc)
{
    return( GetBlobProp( SVC_PROPS, ppSvc, pcbSvc ) );
}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::SetRecoveryProps
//
//  Synopsis:   Sets the recovery properties of a Dfs Manager volume object
//
//  Arguments:  [pBuffer] -- Recovery argument buffer
//              [cbBuffer] -- Size of recovery argument buffer
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::SetRecoveryProps(
    PBYTE pRecovery,
    ULONG cbRecovery)
{
    return( SetBlobProp( RECOVERY_PROPS, pRecovery, cbRecovery ) );
}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::GetRecoveryProps
//
//  Synopsis:   Retrieves the recovery properties of a Dfs Manager volume
//              object.
//
//  Arguments:  [ppRecovery] -- On successful return, points to a buffer
//                      allocated to hold the recovery property.
//              [pcbRecovery] -- On successful return, size in bytes of
//                      recovery buffer.
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::GetRecoveryProps(
    PBYTE *ppRecovery,
    PULONG pcbRecovery)
{
    return( GetBlobProp( RECOVERY_PROPS, ppRecovery, pcbRecovery ) );

}


//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::SetBlobProp
//
//  Synopsis:   Sets a property of type Binary in a Dfs Manager volume object
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::SetBlobProp(
    LPWSTR wszProperty,
    PBYTE pBlob,
    ULONG cbBlob)
{
    DWORD dwErr;

    dwErr = RegSetValueEx(
                _hKey,
                wszProperty,
                NULL,
                REG_BINARY,
                pBlob,
                cbBlob);

    return ( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CRegStorage::GetBlobProp
//
//  Synopsis:   Retrieves a property of type Binary from the
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
CRegStorage::GetBlobProp(
    LPWSTR wszProperty,
    PBYTE  *ppBuffer,
    PULONG pcbBuffer)
{
    DWORD dwErr, dwUnused;

    dwErr = RegQueryInfoKey(
                _hKey,                           // Key
                NULL,                            // Class string
                NULL,                            // Size of class string
                NULL,                            // Reserved
                &dwUnused,                       // # of subkeys
                &dwUnused,                       // max size of subkey name
                &dwUnused,                       // max size of class name
                &dwUnused,                       // # of values
                &dwUnused,                       // max size of value name
                pcbBuffer,                       // max size of value data,
                NULL,                            // security descriptor
                NULL);                           // Last write time

    if (dwErr == ERROR_SUCCESS) {

        *ppBuffer = new BYTE [*pcbBuffer];

        if (*ppBuffer != NULL) {

            dwErr = DfsmQueryValue(
                        _hKey,
                        wszProperty,
                        REG_BINARY,
                        0,
                        *ppBuffer,
                        pcbBuffer);

            if (dwErr) {

                delete [] *ppBuffer;

                *ppBuffer = NULL;

                *pcbBuffer = 0;

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegEnumDirectory::CRegEnumDirectory
//
//  Synopsis:   Constructor for an object of class CRegEnumDirectory.
//
//  Arguments:  [hKey] -- The registry key over which this enumerator is being
//                      instantiated. This handle will be duplicated.
//
//              [pdwErr] -- Error code if error occurs during construction.
//                      Win32 error of result of DuplicateHandle call.
//
//  Returns:    Nothing. See comment on [pdwErr]
//
//-----------------------------------------------------------------------------

CRegEnumDirectory::CRegEnumDirectory(
    HKEY hKey,
    DWORD *pdwErr)
{
    BOOL fResult;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CRegEnumDirectory::+CRegEnumDirectory(0x%x)\n",
        this));

    fResult = DuplicateHandle(
                    GetCurrentProcess(),         // Source Process
                    (HANDLE) hKey,               // Source Handle
                    GetCurrentProcess(),         // Target Process
                    (HANDLE *) &_hKey,          // Target Handle
                    0,                           // Desired Access - ignored
                    FALSE,                       // Non inheritable
                    DUPLICATE_SAME_ACCESS);      // Options - set to
                                                 // DUPLICATE_SAME_ACCESS,
                                                 // causes Desired Access to
                                                 // be ignored.

    if (!fResult) {

        *pdwErr = GetLastError();

        _hKey = NULL;

    } else {

        *pdwErr = ERROR_SUCCESS;

    }

    _iNext = 0;

}

//+----------------------------------------------------------------------------
//
//  Function:   CRegEnumDirectory::~CRegEnumDirectory
//
//  Synopsis:   Destructor for an object of class CRegEnumDirectory
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------

CRegEnumDirectory::~CRegEnumDirectory()
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CRegEnumDirectory::~CRegEnumDirectory(0x%x)\n",
        this));

    if (_hKey != NULL) {

        CloseHandle( _hKey );

    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CRegEnumDirectory::Next
//
//  Synopsis:   Returns the next child of this directory.
//
//  Arguments:  [rgelt] -- Pointer to STATDIR structure. Only the name
//                      of the child relative to this storage is returned.
//              [pcFetched] -- Set to 1 if a child name is successfully
//                      retrieved, 0 if an error occurs or if no more
//                      children.
//
//  Returns:    [ERROR_SUCCESS] -- Operation succeeded. If no more children
//                      are available, ERROR_SUCCESS is returned and
//                      *pcFetched is set to 0.
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate room for child name.
//
//-----------------------------------------------------------------------------

DWORD
CRegEnumDirectory::Next(
    DFSMSTATDIR *rgelt,
    PULONG pcFetched)
{
    DWORD  dwErr;
    LPWSTR lpwszChildName;

    ZeroMemory( rgelt, sizeof(DFSMSTATDIR) );

    lpwszChildName = new WCHAR[ MAX_PATH + 1 ];

    if (lpwszChildName != NULL) {

        dwErr = RegEnumKey(
                    _hKey,
                    _iNext,
                    lpwszChildName,
                    (MAX_PATH + 1) );

        if (dwErr == ERROR_SUCCESS) {

            rgelt->pwcsName = lpwszChildName;

            *pcFetched = 1;

            _iNext++;

        } else {

            delete [] lpwszChildName;

            *pcFetched = 0;

            if (dwErr == ERROR_NO_MORE_ITEMS)
                dwErr = ERROR_SUCCESS;

        }

    } else {

        dwErr = ERROR_OUTOFMEMORY;

    }

    return( dwErr );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsmQueryValue
//
//  Synopsis:   Helper function that calls RegQueryValueEx and verifies that
//              the returned type is equal to the expected type.
//
//  Arguments:  [hkey] -- Handle to key
//              [wszValueName] -- Name of value to read
//              [dwExpectedType] -- Expected type of value
//              [dwExpectedSize] -- Expected size of read in value. If
//                      this is nonzero, this routine will return an error
//                      if the read-in size is not equal to expected size.
//                      If this is 0, no checking is performed.
//              [pBuffer] -- To receive the value data
//              [pcbBuffer] -- On call, size of pBuffer. On successful return,
//                      the size of data read in
//
//  Returns:    [ERROR_SUCCESS] -- Successfully read the value data.
//
//              [DFS_E_VOLUME_OBJECT_CORRUPT] -- If read-in type did not
//                      match dwExpectedType, or if dwExpectedSize was
//                      nonzero and the read-in size did not match it.
//
//              DWORD_FROM_WIN32 of RegQueryValueEx return code.
//
//-----------------------------------------------------------------------------

DWORD
DfsmQueryValue(
    HKEY hkey,
    LPWSTR wszValueName,
    DWORD dwExpectedType,
    DWORD dwExpectedSize,
    PBYTE pBuffer,
    LPDWORD pcbBuffer)
{
    DWORD dwErr;
    DWORD dwType;

    dwErr = RegQueryValueEx(
                hkey,
                wszValueName,
                NULL,
                &dwType,
                pBuffer,
                pcbBuffer);

    if (dwErr == ERROR_SUCCESS) {

        if (dwExpectedType != dwType) {

            dwErr = NERR_DfsInternalCorruption;

        } else if (dwExpectedSize != 0 && dwExpectedSize != *pcbBuffer) {

            dwErr = NERR_DfsInternalCorruption;

        } else {

            dwErr = ERROR_SUCCESS;

        }

    }

    return( dwErr );
}

DWORD
RegCreateObject(
    IN LPWSTR lpwszFileName)
{
    DWORD dwErr;
    HKEY  hkey;

    dwErr = RegCreateKey(HKEY_LOCAL_MACHINE, lpwszFileName, &hkey);

    if (dwErr == ERROR_SUCCESS) {

        RegCloseKey( hkey );

    }

    return( dwErr );

}

DWORD
RegPutData(
    IN LPWSTR lpwszFileName,
    IN LPWSTR lpwszProperty,
    IN DWORD cBytes,
    IN PBYTE pData)
{
    DWORD dwErr;
    HKEY hKey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, lpwszFileName, &hKey );

    if (dwErr == ERROR_SUCCESS) {

        dwErr = RegSetValueEx(
                    hKey,
                    lpwszProperty,
                    NULL,
                    REG_BINARY,
                    pData,
                    cBytes);

        RegCloseKey( hKey );

    }

    return ( dwErr );

}

DWORD
RegGetData(
    IN LPWSTR lpwszFileName,
    IN LPWSTR lpwszProperty,
    OUT PDWORD pcbBuffer,
    OUT PBYTE *ppBuffer)
{
    DWORD dwErr;
    DWORD dwUnused;
    HKEY hKey;
    PBYTE pBuffer;
    DWORD cbBuffer;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, lpwszFileName, &hKey );

    if (dwErr == ERROR_SUCCESS) {

        dwErr = RegQueryInfoKey(
                    hKey,                            // Key
                    NULL,                            // Class string
                    NULL,                            // Size of class string
                    NULL,                            // Reserved
                    &dwUnused,                       // # of subkeys
                    &dwUnused,                       // max size of subkey name
                    &dwUnused,                       // max size of class name
                    &dwUnused,                       // # of values
                    &dwUnused,                       // max size of value name
                    &cbBuffer,                       // max size of value data,
                    NULL,                            // security descriptor
                    NULL);                           // Last write time

        if (dwErr == ERROR_SUCCESS) {

            pBuffer = new BYTE [cbBuffer];

            if (pBuffer != NULL) {

                dwErr = DfsmQueryValue(
                            hKey,
                            lpwszProperty,
                            REG_BINARY,
                            0,
                            pBuffer,
                            &cbBuffer);

                if (dwErr != ERROR_SUCCESS) {

                    delete [] pBuffer;

                }

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

        }

        RegCloseKey(hKey);

    }

    if (dwErr == ERROR_SUCCESS) {

        *pcbBuffer = cbBuffer;
        *ppBuffer = pBuffer;

    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\cstorage.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       cstorage.cxx
//
//  Contents:   Implementation of CStorageDirectory class. This implementation
//              provides a basic mechanism to create, delete, and lookup
//              Prefix -> Storage Object Name mappings.
//
//  Classes:    CStorageDirectory
//
//  Functions:
//
//  History:    Sept 18, 1996   Milans Created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "dfsmsrv.h"


//+----------------------------------------------------------------------------
//
//  Function:   CStorageDirectory::CStorageDirectory
//
//  Synopsis:   Constructor for CStorageDirectory
//
//-----------------------------------------------------------------------------
CStorageDirectory::CStorageDirectory(
    DWORD *pdwErr)
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CStorageDirectory::+CStorageDirectory(0x%x)\n",
        this));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CStorageDirectory::CStorageDirectory()\n");
#endif
    if (!DfsInitializeUnicodePrefix(&_PrefixTable)) {
        *pdwErr = ERROR_OUTOFMEMORY;
    } else {
        *pdwErr = ERROR_SUCCESS;
    }
    _cEntries = 0;
}


//+----------------------------------------------------------------------------
//
//  Function:   CStorageDirectory::~CStorageDirectory
//
//  Synopsis:   Destructor for CStorageDirectory
//
//-----------------------------------------------------------------------------
CStorageDirectory::~CStorageDirectory()
{
    PNAME_PAGE pNamePage;
    PNAME_PAGE pNextPage;
    LPWSTR wszObject, wszPrefix;
    UNICODE_STRING TempString;
    BOOLEAN Restart, Success;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CStorageDirectory::~CStorageDirectory(0x%x)\n",
        this));
#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CStorageDirectory::~CStorageDirectory()\n");
#endif

    wszObject = (LPWSTR) DfsNextUnicodePrefix( &_PrefixTable, TRUE );

    while (wszObject != NULL) {

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("CStorageDirectory::~CStorageDirectory:deleting object@0x%x\n", wszObject);
#endif
	wszPrefix = wszObject + wcslen(wszObject) + 1;

        RtlInitUnicodeString(&TempString, wszPrefix );
        Success = DfsRemoveUnicodePrefix( &_PrefixTable, &TempString );
	if (Success == TRUE) {
	  delete [] wszObject;
	  Restart = TRUE;
	}
	else {
	  Restart = FALSE;
	}

        wszObject = (LPWSTR) DfsNextUnicodePrefix( &_PrefixTable, Restart );
    }



    for (pNamePage = _PrefixTable.NamePageList.pFirstPage;
            pNamePage;
                pNamePage = pNextPage
    ) {
        pNextPage = pNamePage->pNextPage;
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("CStorageDirectory::~CStorageDirectory: Releasing NamePage@0x%x\n", pNamePage);
#endif
        free(pNamePage);
    }

}


//+----------------------------------------------------------------------------
//
//  Function:   CStorageDirectory::GetObjectForPrefix
//
//  Synopsis:   Given a prefix, returns the name of the Dfs Manager volume
//              object which describes the volume.
//
//  Arguments:  [wszPrefix] -- The prefix (ie, EntryPath) to look up.
//              [fExactMatchRequired] -- wszPrefix must match exactly with
//                      the EntryPath property of the returned volume object.
//              [pwszObject] -- Name of the volume object that describes the
//                      EntryPath. Memory for this is allocated via new
//              [pcbMatchedLength] -- On successful return, contains the
//                      number of BYTES of wszPrefix that matched an entry
//                      in the directory.
//
//  Returns:    [S_OK] -- Successfully found name of volume object.
//
//              [DFS_E_NO_SUCH_VOLUME] -- Unable to find volume for given
//                      wszPrefix.
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate memory for the object
//                      name.
//
//-----------------------------------------------------------------------------

DWORD
CStorageDirectory::GetObjectForPrefix(
    LPCWSTR wszPrefix,
    const BOOLEAN fExactMatchRequired,
    LPWSTR *pwszObject,
    LPDWORD pcbMatchedLength)
{
    UNICODE_STRING ustrPrefix, ustrRem;
    LPWSTR wszObject;
    DWORD dwErr;

    *pwszObject = NULL;

    RtlInitUnicodeString( &ustrPrefix, wszPrefix );

    ustrRem.Length = ustrRem.MaximumLength = 0;
    ustrRem.Buffer = NULL;

    wszObject = (LPWSTR) DfsFindUnicodePrefix(
                            &_PrefixTable,
                            &ustrPrefix,
                            &ustrRem);

    if (wszObject == NULL || (fExactMatchRequired && ustrRem.Length != 0)) {

        dwErr = NERR_DfsNoSuchVolume;

    } else {

        *pwszObject = new WCHAR [wcslen(wszObject) + 1];

        if (*pwszObject != NULL) {

            wcscpy(*pwszObject, wszObject);

            *pcbMatchedLength = ustrPrefix.Length - ustrRem.Length;

            dwErr = ERROR_SUCCESS;

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CStorageDirectory::GetObjectByIndex
//
//  Synopsis:   Returns the i'th object name in the directory.
//
//  Arguments:  [iStart] -- The 0 based index of the object name to return.
//                      If this value is ~0, the "next" object name is
//                      returned.
//
//              [pwszObject] -- On successful return, a pointer to the
//                      buffer containing the object name is returned here.
//                      Memory is allocated via new.
//
//  Returns:    [ERROR_SUCCESS] -- Successfully returning ith object.
//
//              [ERROR_NO_MORE_ITEMS] -- No more entries
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate memory.
//
//-----------------------------------------------------------------------------

DWORD
CStorageDirectory::GetObjectByIndex(
    DWORD iStart,
    LPWSTR *pwszObject)
{
    DWORD dwErr;
    DWORD i;
    LPWSTR wszNextObject;

    //
    // position ourselves
    //

    if (iStart == ~0) {

        wszNextObject = (LPWSTR) DfsNextUnicodePrefix(&_PrefixTable, FALSE);

    } else {

        wszNextObject = (LPWSTR) DfsNextUnicodePrefix(&_PrefixTable, TRUE);

        for (i = 0; (i < iStart) && (wszNextObject != NULL); i++) {

            wszNextObject = (LPWSTR) DfsNextUnicodePrefix(
                                        &_PrefixTable,
                                        FALSE);

        }

    }

    if (wszNextObject != NULL) {

        *pwszObject = new WCHAR[ wcslen(wszNextObject) + 1 ];

        if (*pwszObject != NULL) {

            wcscpy( *pwszObject, wszNextObject );

            dwErr = ERROR_SUCCESS;

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    } else {

        dwErr = ERROR_NO_MORE_ITEMS;

    }

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CStorageDirectory::_InsertIfNeeded
//
//  Synopsis:   Associates a given prefix with the given object name,
//              iff no mapping already exists.
//
//  Arguments:  [wszPrefix] -- The prefix to associate with.
//              [wszObject] -- The object name to associate.
//
//  Returns:    [ERROR_SUCCESS] -- If successfully inserted, or mapping was already
//                      known.
//
//              [NERR_DfsInconsistent] -- Found another object that already
//                      maps to the given prefix.
//
//              [ERROR_OUTOFMEMORY] -- Unable to allocate memory.
//
//-----------------------------------------------------------------------------



DWORD
CStorageDirectory::_InsertIfNeeded(
    LPCWSTR wszPrefix,
    LPCWSTR wszObject)
{
    DWORD dwErr;
    UNICODE_STRING ustrPrefix, ustrRem;
    LPWSTR wszExistingObject, wszInsertObject, wszInsertPrefix;

    ustrRem.Length = ustrRem.MaximumLength = 0;
    ustrRem.Buffer = NULL;

    RtlInitUnicodeString( &ustrPrefix, wszPrefix );

    wszExistingObject = (LPWSTR) DfsFindUnicodePrefix(
                                    &_PrefixTable,
                                    &ustrPrefix,
                                    &ustrRem);

    if (wszExistingObject != NULL && ustrRem.Length == 0) {

        //
        // Found existing mapping - see if its for the same object
        //

        if (_wcsicmp(wszExistingObject, wszObject) == 0) {

            dwErr = ERROR_SUCCESS;

        } else {

            dwErr = NERR_DfsInconsistent;

        }

    } else {

        wszInsertObject = new WCHAR [ wcslen(wszObject) + 1 + wcslen(wszPrefix) + 1];

        if (wszInsertObject != NULL) {

            wcscpy( wszInsertObject, wszObject );

	    wszInsertPrefix = wszInsertObject + wcslen(wszObject) + 1;
	    wcscpy(wszInsertPrefix, wszPrefix);

            if (DfsInsertUnicodePrefix(
                    &_PrefixTable, &ustrPrefix, (PVOID) wszInsertObject)) {
                dwErr = ERROR_SUCCESS;

                _cEntries++;

            } else {

                delete [] wszInsertObject;

                dwErr = ERROR_OUTOFMEMORY;
            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   CStorageDirectory::_Delete
//
//  Synopsis:   Deletes an association between the given prefix and its
//              object path.
//
//  Arguments:  [wszPrefix] -- The prefix to remove
//
//  Returns:    [ERROR_SUCCESS] -- successfully deleted association.
//
//              [NERR_DfsNoSuchVolume] -- Unable to find an association for
//                      the prefix.
//
//              [NERR_DfsInconsistent] -- Found the prefix, but unable to
//                      delete. This should never happen! Asserts on checked
//                      builds
//
//-----------------------------------------------------------------------------

DWORD
CStorageDirectory::_Delete(
    LPWSTR wszPrefix)
{
    DWORD dwErr;
    UNICODE_STRING ustrPrefix, ustrRem;
    LPWSTR wszObject;

    ustrRem.Length = ustrRem.MaximumLength = 0;
    ustrRem.Buffer = NULL;

    RtlInitUnicodeString( &ustrPrefix, wszPrefix );

    wszObject = (LPWSTR) DfsFindUnicodePrefix(
                            &_PrefixTable,
                            &ustrPrefix,
                            &ustrRem );

    if (wszObject != NULL && ustrRem.Length == 0) {

        if (DfsRemoveUnicodePrefix( &_PrefixTable, &ustrPrefix )) {

            delete [] wszObject;

            _cEntries--;

            dwErr = ERROR_SUCCESS;

        } else {

            dwErr = NERR_DfsInconsistent;

            ASSERT( FALSE && "Unexpected error removing prefix!\n" );

        }

    } else {

        dwErr = NERR_DfsNoSuchVolume;

    }

    return( dwErr );

}

DWORD
DfsmOpenStorage(
    IN LPCWSTR lpwszFileName,
    OUT CStorage **ppDfsmStorage)
{
    DWORD dwErr;

    IDfsVolInlineDebOut((DEB_TRACE, "DfsmOpenStorage(%ws)\n", lpwszFileName));

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {
        dwErr = DfsmOpenLdapStorage(lpwszFileName, ppDfsmStorage);
    } else {
        dwErr = DfsmOpenRegStorage(lpwszFileName, ppDfsmStorage);
    }

    IDfsVolInlineDebOut((DEB_TRACE, "DfsmOpenStorage() exit\n"));

    return( dwErr );
}

DWORD
DfsmCreateStorage(
    IN LPCWSTR lpwszFileName,
    OUT CStorage **ppDfsmStorage)
{
    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {
        return( DfsmCreateLdapStorage(lpwszFileName, ppDfsmStorage) );
    } else {
        return( DfsmCreateRegStorage(lpwszFileName, ppDfsmStorage) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\crecover.cxx ===
//+-------------------------------------------------------------------------
//
//  File:       crecover.cxx
//
//  Contents:   Implementation for the CRecover support class.
//
//  History:    09-Mar-93       SudK            Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include "crecover.hxx"

//+------------------------------------------------------------------------
//
// Method:      CRecover::CRecover
//
// Synopsis:    The Constructor for this Class. This constructor sets the
//              Operation Stage and Operation in its private section to 0.
//              No persistent storage operations are done here.
//
// Arguments:   [iprop] --      The IProperty instance. Without this it does not
//                              make sense to instantiate this class.
//
// Returns:     Nothing.
//
// History:     09-Mar-1993     SudK    Created.
//
//-------------------------------------------------------------------------
CRecover::CRecover(void)
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CRecover::+CRecover(0x%x)\n",
        this));

    _Operation = 0;
    _OperStage = 0;
    _RecoveryState = 0;
    _RecoveryBuffer = _ulongBuffer;
    _pPSStg = NULL;

}


//+------------------------------------------------------------------------
//
// Method:      CRecover::~CRecover
//
// Synopsis:    The Destructor.
//
// Arguments:   None
//
// Returns:     It does nothing actually except to deallocate any memory.
//
// History:     09-Mar-1993     SudK    Created.
//
//-------------------------------------------------------------------------
CRecover::~CRecover(void)
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CRecover::~CRecover(0x%x)\n",
        this));

    if (_RecoveryBuffer != _ulongBuffer)
        delete [] _RecoveryBuffer;

    if (_pPSStg != NULL)
        _pPSStg->Release();
}

//+------------------------------------------------------------------------
//
// Method:      CRecover::Initialise
//
// Synopsis:    Set the IProperty interface. This should not be called twice!!
//
// Arguments:   [pPSStg] -- The IPropertySetStg from here we get to Props
//
// Returns:     Nothing.
//
// History:     09-Mar-1993     SudK    Created.
//
//-------------------------------------------------------------------------
VOID
CRecover::Initialize(
    CStorage *pPSStg)
{
    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::Initialize()\n"));

    ASSERT(_pPSStg == NULL);

    if (_pPSStg != NULL)
        _pPSStg->Release();

    _pPSStg = pPSStg;
    _pPSStg->AddRef();

    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::Initialize() exit\n"));
}


//+------------------------------------------------------------------------
//
// Method:      CRecover::SetOperationStart
//
// Synopsis:    Used when one is about to start an operation. Takes Operation
//              Code and any recovery arg if necessary.
//
// Arguments:   [Operation] --  The operation code for which this class is
//                              being instantiated.
//              [RecoverySvc]-- The Recovery Svc if any associated with this
//                              Operation.
//
// Returns:     Nothing. If it cant set properties it will throw an exception.
//
// Notes:       Caller should take care of freeing the Service passed in.
//
// History:     09-Mar-1993     SudK    Created.
//
//-------------------------------------------------------------------------
DWORD
CRecover::SetOperationStart(ULONG fOperation, CDfsService *pRecoverySvc)
{
    ULONG       size;
    DWORD dwErr = ERROR_SUCCESS;
    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetOperationStart()\n"));

    //
    // There could be a recovery buffer from a previous different operation.
    // So we need to get rid of it and create an appropriate sized one again.
    //
    if (_RecoveryBuffer != _ulongBuffer)        {
        delete [] _RecoveryBuffer;
        _RecoveryBuffer = _ulongBuffer;
    }
    //
    // Set the private section variables first.
    //
    _Operation = fOperation;
    _OperStage = DFS_OPER_STAGE_START;

    //
    // Create the RecoverState and the RecoverySvc in private section.
    //
    _RecoveryState = DFS_COMPOSE_RECOVERY_STATE(_Operation, _OperStage);

    //
    // Let us figure out the marshalled buffer for the Service and create it.
    //
    if (pRecoverySvc != NULL)   {
        size = pRecoverySvc->GetMarshalSize();

        _RecoveryBuffer = new BYTE[size + sizeof(ULONG)]; 
        if (_RecoveryBuffer == NULL) {
            dwErr = ERROR_OUTOFMEMORY;
            return dwErr;
	}
 
        _PutULong(_RecoveryBuffer, size);

        pRecoverySvc->Serialize(_RecoveryBuffer + sizeof(ULONG), size);
    }
    else        {
        //
        // In this case also we add a BLOB but however, this is only an Empty
        // BLOB. So this is easy to handle.
        //
        _PutULong(_RecoveryBuffer, 0);
    }

    SetRecoveryProps(_RecoveryState, _RecoveryBuffer, FALSE);

    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetOperationStart() exit\n"));

    return dwErr;
}


//+------------------------------------------------------------------------
//
// Method:      CRecover::SetDefaultProps
//
// Synopsis:    This method sets null recovery props to start.
//
// Arguments:   None
//
// Returns:     Nothing.
//
// Notes:       This may throw an exception. Failure of this is truly an
//              appropriate time to throw an exception.
//
// History:     12-21-1993      SudK    Created.
//
//-------------------------------------------------------------------------
VOID
CRecover::SetDefaultProps(void)
{
    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetDefaultProps()\n"));

    _RecoveryState = DFS_RECOVERY_STATE_NONE;
    _Operation = 0;
    _OperStage = 0;

    _PutULong(_RecoveryBuffer, 0);
    SetRecoveryProps(_RecoveryState, _RecoveryBuffer, TRUE);

    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetDefaultProps() exit\n"));
}

//+------------------------------------------------------------------------
//
// Method:      CRecover::SetOperationDone
//
// Synopsis:    This method deletes all recovery properties to signify end of
//              the Operation that was in progress.
//
// Arguments:   [Operation] -- The Operation Code.
//
// Returns:     Nothing.
//
// Notes:       This may throw an exception. Failure of this is truly an
//              appropriate time to throw an exception.
//
// History:     09-Mar-1993     SudK    Created.
//
//-------------------------------------------------------------------------
VOID
CRecover::SetOperationDone(void)
{
    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetOperationDone()\n"));

    _RecoveryState = DFS_RECOVERY_STATE_NONE;
    _Operation = 0;
    _OperStage = 0;

    _PutULong(_RecoveryBuffer, 0);
    SetRecoveryProps(_RecoveryState, _RecoveryBuffer, FALSE);

    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetOperationDone() exit\n"));
}

//+------------------------------------------------------------------------
//
// Method:      CRecover::SetOperStage
//
// Synopsis:    This methods sets the operation stage in its private section
//              and at the same time updates the VolumeObject.
//
// Arguments:   [OperStage] -- Operation Stage.
//
// Returns:     Nothing. It throws an exception if it has any problems.
//
// History:     09-Mar-1993     SudK    Created.
//
//-------------------------------------------------------------------------
VOID
CRecover::SetOperStage(ULONG OperStage)
{
    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetOperStage()\n"));

    _OperStage = OperStage;
    _RecoveryState = DFS_COMPOSE_RECOVERY_STATE(_Operation, _OperStage);

    SetRecoveryProps(_RecoveryState, _RecoveryBuffer, FALSE);

    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetOperStage() exit\n"));
}


//+------------------------------------------------------------------------
//
// Method:      CRecover::SetRecoveryProps
//
// Synopsis:    This method interacts with the actual property interface
//              to set the recovery properties.
//
// Arguments:   [RecoveryState] --      Recovery State.
//              [RecoveryBuffer] --     Recovery Argument if any.
//              [bCreate] --            Whether to create Propset or not.
//
// Returns:     Nothing. Will throw exception if anything goes wrong.
//
// Notes:       Caller must free the buffer that he passed in.
//
// History:     09-Mar-1993     SudK    Created.
//
//-------------------------------------------------------------------------
VOID
CRecover::SetRecoveryProps(
    ULONG RecoveryState,
    PBYTE RecoveryBuffer,
    BOOLEAN bCreate
)
{
    DWORD       dwErr;
    DWORD       cbSize;

    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetRecoveryProps()\n"));

    _GetULong(RecoveryBuffer, cbSize);
    _PutULong(RecoveryBuffer, RecoveryState);

    dwErr = _pPSStg->SetRecoveryProps(RecoveryBuffer, cbSize+sizeof(ULONG));

    _PutULong(RecoveryBuffer, cbSize);

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((
            DEB_ERROR, "Unable to Set RecoveryProperties %08lx\n",dwErr));

        RaiseException ( dwErr, 0, 0, 0 );        
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CRecover::SetRecoveryProps() exit\n"));
}



//+-------------------------------------------------------------------------
//
//  Method:   CRecover::GetRecoveryProps, private
//
//  Synopsis: Get the recovery related properties off the volume object.
//
//  Arguments:[RecoveryState] -- The RecoveryState is returned here.
//            [ppRecoverySvc] -- If there is a recovery Svc it is returned here.
//
//  Returns:
//
//  History:  09-Feb-1993       SudK    Created.
//
//--------------------------------------------------------------------------
DWORD
CRecover :: GetRecoveryProps(
    ULONG  *RecoveryState,
    CDfsService **ppRecoverySvc
)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PBYTE               buffer, svcBuffer;
    ULONG               size;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetRecoveryProps()\n"));

    //
    // Initialize all the arguments to NULL
    //

    *RecoveryState = 0;
    *ppRecoverySvc = NULL;

    dwErr = _pPSStg->GetRecoveryProps( &buffer, &size );

    if (dwErr != ERROR_SUCCESS)     {
        IDfsVolInlineDebOut((
            DEB_ERROR, "Unable to read recovery Props %08lx\n", dwErr));
        SetOperationDone();
        return(dwErr);
    }

    //
    // First let us extract the RecoveryState property.
    //
    _GetULong(buffer, (*RecoveryState));

    //
    // Next let us extract the RecoveryArg property.
    //

    svcBuffer = buffer + sizeof(ULONG);
    size -= sizeof(ULONG);

    //
    // Now that we have a buffer we have to create a service out of this.
    // If the buffer is of size Zero we will just return back a NULL ptr.
    //
    if (size != 0)      {
        dwErr = CDfsService::DeSerialize(svcBuffer, size, ppRecoverySvc);
        if (dwErr != ERROR_SUCCESS) {
            IDfsVolInlineDebOut((
                DEB_ERROR, "Failed %d to unmarshall RecoverySvc\n", dwErr));
            *ppRecoverySvc = NULL;
        }
    }

    delete [] buffer;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::GetRecoveryProps() exit\n"));

    return dwErr;
}



#if (DBG == 1) || (_CT_TEST_HOOK == 1)
INIT_RECOVERY_BREAK_INFO()
//+-------------------------------------------------------------------------
//
//  Function: DfsSetRecoveryBreakPoint
//
//  Synopsis: Sets the globals that determine when a recovery break point
//            is activated
//
//  Arguments:[pBuffer]         --  Marshalled buffer
//            [cbSize]          --  Size of the marhalled buffer
//
//  Returns:  STATUS_SUCCESS    --  Success
//
//--------------------------------------------------------------------------
NTSTATUS DfsSetRecoveryBreakPoint(PBYTE pBuffer,
                                  ULONG cbSize)
{
    NTSTATUS            Status;
    MARSHAL_BUFFER      marshalBuffer;

    MarshalBufferFree(gRecoveryBkptInfo.pwszApiBreak);

    MarshalBufferInitialize(&marshalBuffer, cbSize, pBuffer);

    Status = DfsRtlGet(&marshalBuffer, &MiRecoveryBkpt, &gRecoveryBkptInfo);

    return(Status);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\cdfsvol.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       cdfsvol.cxx
//
//  Contents:   Class to abstract a Dfs Volume object and all the
//              administration operations that can be performed on a
//              volume object.
//
//  Classes:    CDfsVolume
//
//  Functions:
//
//  History:    05/10/93        Sudk Created.
//              12/19/95        Milans Ported to NT.
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <cguid.h>
#include "cdfsvol.hxx"
#include "cldap.hxx"

extern "C" {
#include <winldap.h>
#include <dsgetdc.h>
}
#include "setup.hxx"

const GUID CLSID_CDfsVolume = {
  0xd9918520, 0xb074, 0x11cd, { 0x47, 0x94, 0x26, 0x8a, 0x82, 0x6b, 0x00, 0x00 }
};

extern "C"
DWORD
DfsGetFtServersFromDs(
    PLDAP pLDAP,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR **List);

extern CLdap *pDfsmLdap;

//---------------------------------------------------------------------------
//
// Class CDfsVolume Member Function Implementations
//
//---------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Function:  CDfsVolume::CDfsVolume
//
//  Synopsis:  Constructor
//
//--------------------------------------------------------------------------
CDfsVolume::CDfsVolume()
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsVolume::+CDfsVolume(0x%x)\n",
        this));

    _pStorage         = NULL;

    _pwzFileName = _FileNameBuffer;
    _pwszParentName = _ParentNameBuffer;
    _dwRotRegistration = NULL;
    memset(&_peid, 0, sizeof(DFS_PKT_ENTRY_ID));
    _peid.Prefix.Buffer = _EntryPathBuffer;
    _peid.ShortPrefix.Buffer = _ShortPathBuffer;
    _pRecoverySvc = NULL;
    _Deleted = TRUE;
    _State = DFS_VOLUME_STATE_OK;
    _Timeout = GTimeout;
    _pwszComment = NULL;
    memset( &_ftEntryPath, 0, sizeof(FILETIME));
    memset( &_ftState, 0, sizeof(FILETIME));
    memset( &_ftComment, 0, sizeof(FILETIME));

}

//+-------------------------------------------------------------------------
//
//  Function:  CDfsVolume::~CDfsVolume
//
//  Synopsis:  Destructor
//
//--------------------------------------------------------------------------
CDfsVolume::~CDfsVolume()
{
    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsVolume::~CDfsVolume(0x%x)\n",
        this));

#if DBG
    if (DfsSvcVerbose & 0x80000000) {
        DbgPrint("CDfsVolume::~CDfsVolume @0x%x\n", this);
        DbgPrint("              _DfsSvcList@0x%x\n", &_DfsSvcList);
    }
#endif

    if (_pStorage != NULL)
        _pStorage->Release();

    if (_pwzFileName != NULL && _pwzFileName != _FileNameBuffer)
        delete [] _pwzFileName;

    if (_pwszParentName != NULL && _pwszParentName != _ParentNameBuffer)
        delete [] _pwszParentName;

    if (_peid.Prefix.Buffer != NULL && _peid.Prefix.Buffer != _EntryPathBuffer)
        delete [] _peid.Prefix.Buffer;

    if (_peid.ShortPrefix.Buffer != NULL && _peid.ShortPrefix.Buffer != _ShortPathBuffer) {
        delete [] _peid.ShortPrefix.Buffer;
    }

    if (_pwszComment != NULL)
        delete [] _pwszComment;

    if (_pRecoverySvc != NULL)
        delete _pRecoverySvc;

}

//+-------------------------------------------------------------------------
// IPersist Methods
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:  CDfsVolume::GetClassID
//
//  Synopsis:  Return classid - This is the implementation for both the
//             IPersistStorage and IPersistFile Interfaces.
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_CDfsVolume;
    return(ERROR_SUCCESS);
}

//+-------------------------------------------------------------------------
// IPersistStorage Methods
//--------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   GetNameFromStorage
//
//  Synopsis:   Given an IStorage, this routine computes the name of the
//              object.
//
//  Arguments:  [pstg] -- The storage whose name is to be computed
//              [ppwszName] -- Points to a buffer containing the name
//              [wszBuffer] -- The buffer to use if name is <= MAX_PATH
//
//  Returns:    ERROR_SUCCESS if successful
//              ERROR_OUTOFMEMORY if out of memory
//              NERR_DfsInternalError if any other error
//
//-----------------------------------------------------------------------------

DWORD
GetNameFromStorage(
    CStorage *pstg,
    LPWSTR *ppwszName,
    WCHAR wszBuffer[])
{
    DWORD dwErr;
    ULONG cLen;
    LPWSTR pwszName = NULL;
    DFSMSTATSTG statstg;

    ZeroMemory( &statstg, sizeof(statstg) );

    dwErr = pstg->Stat( &statstg, STATFLAG_DEFAULT );

    if (dwErr == ERROR_SUCCESS) {

        cLen = 2 + wcslen( statstg.pwcsName ) + 1;

        if (cLen > MAX_PATH) {

            pwszName = new WCHAR[ cLen ];

            if (pwszName == NULL) {

                IDfsVolInlineDebOut((
                    DEB_ERROR, "Unable to allocate %d bytes\n",
                    cLen * sizeof(WCHAR)));

                dwErr = ERROR_OUTOFMEMORY;

            } else {

                wcscpy( pwszName, statstg.pwcsName );

                *ppwszName = pwszName;

            }

        } else {                                 // Use given buffer

            pwszName = wszBuffer;

            wcscpy( pwszName, statstg.pwcsName );

            *ppwszName = pwszName;

        }

        delete [] statstg.pwcsName;

    } else {

        IDfsVolInlineDebOut((
            DEB_ERROR, "Error %08lx getting storage stats\n", dwErr ));

        dwErr = NERR_DfsInternalError;

    }

    return( dwErr );

}

//+-------------------------------------------------------------------------
//
//  Function:  CDfsVolume::InitNew
//
//  Synopsis:  InitNew is only called by the reconciler when a new
//             volume object is created as a result of a reconciliation.
//             We simply create all the appropriate property sets so that
//             the volume object reconciler can reconcile the property sets
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::InitNew(CStorage *pStg)
{

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::InitNew()\n"));

    DWORD dwErr;

    ASSERT( _pStorage == NULL );

    //
    // Save and AddRef the storage so it wont go away from us.
    //

    _pStorage = pStg;

    _pStorage->AddRef();

    //
    // First thing we do now is to setup the Class ID.
    //

    dwErr = _pStorage->SetClass(CLSID_CDfsVolume);

    //
    // Next, we Initialize the property sets.
    //

    if (dwErr == ERROR_SUCCESS)
        dwErr = SetVersion( TRUE );

    if (dwErr == ERROR_SUCCESS) {

        _Recover.Initialize(_pStorage);

        _Recover.SetDefaultProps();

    }

    if (dwErr == ERROR_SUCCESS)
        dwErr = _DfsSvcList.SetNullSvcList( _pStorage );

    //
    // Need to initialize our _pwzFileName member
    //

    if (dwErr == ERROR_SUCCESS) {

        ASSERT( _pwzFileName == _FileNameBuffer );

        dwErr = GetNameFromStorage(
                _pStorage,
                &_pwzFileName,
                _FileNameBuffer );

    }

    if (dwErr == ERROR_SUCCESS) {

        _Deleted = FALSE;

        IDfsVolInlineDebOut((
            DEB_TRACE, "Volume Object [%ws] successfully inited\n",
            _pwzFileName));

    }

    return( dwErr );

}

//+-------------------------------------------------------------------------
//
//  Function:   CDfsVolume::Save
//
//  Synopsis:   Saves the persistent state of the object. We really don't need
//              to support this. It really makes no sense to support this?
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::Save(
    CStorage *pStgSave,
    BOOL fSameAsLoad)
{
    return(ERROR_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:  CDfsVolume::Load
//
//  Synopsis:  Loads a DfsVolume and the components it contains from
//             storage.
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::Load(
    CStorage *pStg)
{
    DWORD dwErr = ERROR_SUCCESS;


    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::Load()\n"));

    ASSERT(_pStorage == NULL);
    _pStorage = pStg;
    _pStorage->AddRef();

    if (dwErr == ERROR_SUCCESS)
        dwErr = GetVersion( &_Version );

    //
    // Out here we are passing in the _pPSStorage. The called people will
    // Addref and release this _pStorage on their own.
    //
    if (dwErr == ERROR_SUCCESS)      {

        _Recover.Initialize(_pStorage);

        dwErr = _DfsSvcList.InitializeServiceList(_pStorage);

    }

    if (dwErr == ERROR_SUCCESS)      {

        dwErr = GetIdProps( &_EntryType,
                    &_peid.Prefix.Buffer,
                    &_peid.ShortPrefix.Buffer,
                    &_pwszComment,
                    &_peid.Uid,
                    &_State,
                    &_Timeout,
                    &_ftEntryPath,
                    &_ftState,
                    &_ftComment);

    }

    if (dwErr == ERROR_SUCCESS)      {

        _peid.Prefix.Length = wcslen(_peid.Prefix.Buffer) * sizeof(WCHAR);
        _peid.Prefix.MaximumLength = _peid.Prefix.Length + sizeof(WCHAR);

        _peid.ShortPrefix.Length = wcslen(_peid.ShortPrefix.Buffer) * sizeof(WCHAR);
        _peid.ShortPrefix.MaximumLength = _peid.ShortPrefix.Length + sizeof(WCHAR);

        dwErr = _Recover.GetRecoveryProps(&_RecoveryState, &_pRecoverySvc);
        if (dwErr != ERROR_SUCCESS)     {

            IDfsVolInlineDebOut((DEB_ERROR,
                            "CouldNot read RecoveryProps off Stg %08lx\n",
                            dwErr));

            _RecoveryState = DFS_RECOVERY_STATE_NONE;
            _pRecoverySvc = NULL;
            dwErr = ERROR_SUCCESS;
        }
    }

    if (dwErr == ERROR_SUCCESS) {
        _Deleted = FALSE;
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::Load() exit\n"));

    return( dwErr );
};

//+-------------------------------------------------------------------------
// IPersistFile Methods
//--------------------------------------------------------------------------

DWORD
CDfsVolume::Load(LPCWSTR pwszFileName, DWORD grfMode)
{
    DWORD dwErr;

    dwErr = LoadNoRegister( pwszFileName, grfMode );

    return( dwErr );
}

//+-------------------------------------------------------------------------
//
//  Function:   CDfsVolume::LoadNoRegister
//
//  Synopsis:   Load the DfsVolume from a volume object. This is where all the
//              initialization takes place.
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::LoadNoRegister(
    LPCWSTR pwszFileName,
    DWORD grfMode)
{
    DWORD dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsVolume::LoadNoRegister(%ws)\n", pwszFileName));

    dwErr = DfsmOpenStorage(
                pwszFileName,
                (CStorage FAR* FAR*)&_pStorage);

    if (dwErr == ERROR_SUCCESS) {

        ULONG uLen = wcslen(pwszFileName);

        if (uLen > MAX_PATH)
            _pwzFileName = new WCHAR[(uLen+1)];
        else
            _pwzFileName = _FileNameBuffer;


        if (_pwzFileName == NULL)
            dwErr = ERROR_OUTOFMEMORY;
        else
            wcscpy(_pwzFileName, pwszFileName);

    } else {

        IDfsVolInlineDebOut((
            DEB_TRACE, "Unable to open %ws, %08lx\n", pwszFileName, dwErr));

    }

    //
    // Before we do anything, lets see if the volume object is current.
    //

    if (dwErr == ERROR_SUCCESS)
        dwErr = UpgradeObject();


    if (dwErr == ERROR_SUCCESS)
        dwErr = GetVersion( &_Version );

    if (dwErr == ERROR_SUCCESS)      {
        //
        // Out here we are passing in the _pPSStorage. The called people
        // will Addref and release this _pStorage on their own.
        //
        _Recover.Initialize(_pStorage);

        dwErr = _DfsSvcList.InitializeServiceList(_pStorage);

    }

    if (dwErr == ERROR_SUCCESS)      {

        dwErr = GetIdProps( &_EntryType,
                    &(_peid.Prefix.Buffer),
                    &(_peid.ShortPrefix.Buffer),
                    &_pwszComment,
                    &(_peid.Uid),
                    &_State,
                    &_Timeout,
                    &_ftEntryPath,
                    &_ftState,
                    &_ftComment);

    }

    if (dwErr == ERROR_SUCCESS)      {
        _peid.Prefix.Length = wcslen(_peid.Prefix.Buffer) * sizeof(WCHAR);
        _peid.Prefix.MaximumLength = _peid.Prefix.Length + sizeof(WCHAR);

        _peid.ShortPrefix.Length = wcslen(_peid.ShortPrefix.Buffer) * sizeof(WCHAR);
        _peid.ShortPrefix.MaximumLength = _peid.ShortPrefix.Length + sizeof(WCHAR);

        dwErr = _Recover.GetRecoveryProps(&_RecoveryState, &_pRecoverySvc);
        if (dwErr != ERROR_SUCCESS)     {

            IDfsVolInlineDebOut((DEB_ERROR,
                            "CouldNot read RecoveryProps off %ws\n",
                            _pwzFileName));
            IDfsVolInlineDebOut((DEB_ERROR,"\tError = %08lx\n",dwErr));

            _RecoveryState = DFS_RECOVERY_STATE_NONE;
            _pRecoverySvc = NULL;
            dwErr = ERROR_SUCCESS;
        }
    }


    if (dwErr == ERROR_SUCCESS) {
        _Deleted = FALSE;
    }


    IDfsVolInlineDebOut((
        DEB_TRACE, "CDfsVolume::LoadNoRegister() exit\n"));
    return( dwErr );
}

//+-------------------------------------------------------------------------
//
//  Function:  CDfsVolume::Save
//
//  Synopsis:  Not Implemented
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::Save(LPCWSTR pwzFileName, BOOL fRemember)
{
    DWORD dwErr = ERROR_SUCCESS;

    return( dwErr );
}



DWORD
CDfsVolume::SyncWithRemoteServerNameInDs(void)
{
    DWORD InfoSize = 0;
    DWORD dwError = NO_ERROR;
    DFS_INFO_3 DfsInfo;
    BOOLEAN Found = FALSE;;
    PDFSM_ROOT_LIST pRootList = NULL;
    DFS_REPLICA_INFO *pReplicaInfo = NULL;
    WCHAR* ServerShare = NULL;
    DWORD Length = 0;
    WCHAR* DcName = NULL;
    DWORD i,j;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    LPWSTR *pList = NULL;
    WCHAR wszFtDfsName[MAX_PATH+1];
    ULONG start = 0;
    ULONG end = 0;
    CDfsService *pService;
    LPWSTR DfsName = NULL;


    RtlZeroMemory(wszFtDfsName, sizeof(wszFtDfsName));
    RtlCopyMemory(wszFtDfsName, _peid.Prefix.Buffer, _peid.Prefix.Length);
    
    //	
    // Extract the ftdfs name from the DfsInfo.EntryPath
    //

    for (DfsName = &wszFtDfsName[1];
	 *DfsName != UNICODE_PATH_SEP && *DfsName != UNICODE_NULL;
	 DfsName++) {

	NOTHING;

    }

    if (*DfsName == UNICODE_PATH_SEP)
	    DfsName++;


    if(dwError == ERROR_SUCCESS) {
	dwError = DfsGetFtServersFromDs(
	    NULL,
	    NULL,
	    DfsName,
	    &pList
	    );
    }

    if(dwError == ERROR_SUCCESS) {
	pService=_DfsSvcList.GetFirstService();
	while(pService) {
	    Found = FALSE;
	    for(j=0;pList[j]!=NULL;j++) {
		Length = sizeof(WCHAR) * 2; // whackwhack
		Length += sizeof(WCHAR) * wcslen(pService->GetServiceName()); // server
		Length += sizeof(WCHAR); // whack
		Length += sizeof(WCHAR) * wcslen(pService->GetShareName()); // share
		Length += sizeof(WCHAR); // terminating null
		ServerShare = (WCHAR *)malloc(Length);
		if(ServerShare == NULL) {
		    dwError = ERROR_NOT_ENOUGH_MEMORY;
		    goto exit;
		}
		wcscpy(ServerShare, L"\\\\");
		wcscat(ServerShare, pService->GetServiceName());
		wcscat(ServerShare, L"\\");
		wcscat(ServerShare, pService->GetShareName());
		if(wcscmp(ServerShare, pList[j]) == 0) {
		    Found = TRUE;
		    break;
		}
		free(ServerShare);
		ServerShare = NULL;
	    }
	    if(!Found) {
		// after we delete the service we can no longer get the next in the list,
		// so we grab it first.
		CDfsService *NextService = _DfsSvcList.GetNextService(pService);
		dwError = _DfsSvcList.DeleteService(pService, FALSE);
		if(dwError != ERROR_SUCCESS) {
		    break;
		}
		pService = NextService;
	    } else {
		pService=_DfsSvcList.GetNextService(pService);
	    }
	}
    }

exit:

    if(pList) {
	NetApiBufferFree(pList);
    }


    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\dfsminit.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1995, Microsoft Corporation
//
//  File:       dfsminit.cxx
//
//  Contents:   Initialization code for Dfs Manager service.
//
//  Classes:
//
//  Functions:  DfsManager --
//              DfsInitGlobals --
//              InitializeDfsManager --
//              InitializeVolumeObject --
//              DfsHandleKnowledgeInconsistency --
//
//-----------------------------------------------------------------------------

//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <dfsfsctl.h>
//#include <windows.h>

#include <headers.hxx>
#pragma hdrstop

#include <dfsfsctl.h>                            // For EA_NAME_OPENIFJP

#include <dfsmsrv.h>                             // For public function
#include <clusapi.h>
#include <resapi.h>
#include <winldap.h>
#include "cdfsvol.hxx"                           //     prototypes
#include "localvol.hxx"
#include "security.hxx"
#include "dsgetdc.h"
#include "setup.hxx"
#include "dfsmwml.h"

extern "C"
DWORD
DfsGetFtServersFromDs(
    PLDAP pLDAP,
    LPWSTR wszDomainName,
    LPWSTR wszDfsName,
    LPWSTR **List);

DWORD
DfspGetPdc(void);

//
// Debug variables
//

//WMILIB_REG_STRUCT   DfsRtlWmiReg;
///GUID DfsmRtlTraceGuid = { // 08fbc600-67ac-4ae4-9f22-c51a4f82f6c9
//    0x08fbc600, 0x67ac, 0x4ae4,
//    {
//        0x9f, 0x22, 0xc5, 0x1a, 0x4f, 0x82, 0xf6, 0xc9
//    }
//};

//WML_DATA wml;


DECLARE_INFOLEVEL(IDfsVol)

//
// Global variables.
//

CRITICAL_SECTION        globalCritSec;
ULONG   ulDfsManagerType;
WCHAR   wszComputerName[MAX_PATH];
LPWSTR  pwszComputerName = NULL;
WCHAR   wszDomainName[MAX_PATH];
LPWSTR  pwszDomainName = NULL;
WCHAR   wszDfsRootName[MAX_PATH];
LPWSTR  pwszDfsRootName = NULL;
WCHAR   wszDSMachineName[MAX_PATH];
LPWSTR  pwszDSMachineName = NULL;

//
// Contains the name of the FtDfs, if we are an FtDfs root
//
WCHAR   wszFtDfsName[MAX_PATH];
LPWSTR  pwszFtDfsName = NULL;

//
// If an FtDfs, this is the ldap connection we're using
//
PLDAP  pLdapConnection = NULL;

ULONG   GTimeout = 0;

extern "C" {
ULONG   DfsSvcVerbose = 0;
ULONG   DfsSvcLdap = 0;
ULONG   DfsEventLog = 0;
ULONG   DfsDnsConfig = 0;
}

BOOLEAN NetDfsInitDone = FALSE;

HANDLE hSyncThread = NULL;
HANDLE hSyncEvent = NULL;
HANDLE hFrsSyncEvent = NULL;
DWORD dwFrsSyncIntervalInMs = 1000 * 60;  // 1 minute by default
DWORD dwSyncIntervalInMs = 1000 * 60 * 60;  // 1 hour by default
DWORD dwSyncThreadId;

ULONG DcLockIntervalInMs = 1000 * 60 * 60 * 2; // 2 hours by default

CStorageDirectory *pDfsmStorageDirectory = NULL;
CSites *pDfsmSites = NULL;

#if (DBG == 1) || (_CT_TEST_HOOK == 1)
RECOVERY_BREAK_POINT gRecoveryBkptInfo;
#endif

//
// The name of the Dfs configuration container
//
WCHAR DfsConfigContainer[] = L"CN=Dfs-Configuration,CN=System";
LPWSTR gConfigurationDN = NULL;

//
// Useful EA Buffer for opening Junction Points
//

CHAR EaBuffer[ sizeof(FILE_FULL_EA_INFORMATION) + sizeof(EA_NAME_OPENIFJP) ];
PFILE_FULL_EA_INFORMATION pOpenIfJPEa = (PFILE_FULL_EA_INFORMATION) EaBuffer;
ULONG cbOpenIfJPEa = sizeof(EaBuffer);


DWORD
InitializeVolumeObject(
    PWSTR       pwszVolName,
    BOOLEAN     bInitVol,
    BOOLEAN     SyncRemoteServerName=FALSE);

DWORD
InitializeDfsManager(void);

DWORD
InitializeNetDfsInterface(void);

DWORD
DfsManagerStartDSSync();

DWORD
DfsManagerDSSyncThread(
    PVOID Context);

DWORD
GetSyncInterval();

ULONG
GetDcLockInterval();

DWORD
GetEntryTimeout();

VOID
GetDebugSwitches();

VOID
GetEventLogSwitches();

VOID
GetConfigSwitches();

DWORD
DfspGetFtDfsName();

//+----------------------------------------------------------------------------
//
//  Function:   DfsManager
//
//  Synopsis:   Entry procedure for the main Dfs Manager service thread.
//              Initializes the Dfs Manager structures, creates the RPC
//              threads that will wait around listening for admin operation
//              calls, and lastly, creates a thread to monitor Knowledge
//              Sync calls from the driver.
//
//  Arguments:  [wszRootName] -- Name of dfs root for which this Dfs Manager
//                      is being instantiated.
//              [dwType] -- Type of Dfs Manager being instantiated -
//                          DFS_MANAGER_SERVER or DFS_MANAGER_FTDFS
//
//  Returns:    [ERROR_SUCCESS] -- If Dfs Manager started correctly.
//
//              [ERROR_OUTOFMEMORY] -- If globals could not be allocated.
//
//              Error from reading the Dfs Volume Objects.
//
//              Win32 error from registering the RPC interface.
//
//              Win32 error from creating the knowledge sync thread.
//
//-----------------------------------------------------------------------------

DWORD
DfsManager(
    LPWSTR wszRootName,
    DWORD dwType)
{
    HANDLE hthreadSync;
    DWORD idThread;
    DWORD dwErr = ERROR_SUCCESS;
    HKEY hkey;
    DFS_NAME_CONVENTION NameType;

    //
    // Initialize the global data structures of Dfs Manager...
    //

    IDfsVolInlineDebOut((DEB_TRACE, "DfsManager(%ws,0x%x)\n", wszRootName, dwType));

    if (dwType == DFS_MANAGER_FTDFS) {
        dwErr = DfsInitGlobals(wszRootName, dwType);
    } else {
        NameType = DFS_NAMETYPE_EITHER;
        dwErr = GetDomAndComputerName(NULL, wszComputerName, &NameType);
        dwErr = DfsInitGlobals(wszComputerName, dwType);
    }

    if (dwErr != ERROR_SUCCESS) {
        IDfsVolInlineDebOut((DEB_ERROR, "DfsInitGlobals failed %08lx\n", dwErr));
        return(dwErr);
    }

    //
    // Initialize the NetDfs RPC interface...
    //

    dwErr = InitializeNetDfsInterface();

    if (dwErr != ERROR_SUCCESS) {
        IDfsVolInlineDebOut((DEB_ERROR, "InitializeNetDfsInterface failed %08lx\n", dwErr));
        return dwErr;
    }

    //
    // Read in all the Dfs volume objects and initialize them
    //

    ENTER_DFSM_OPERATION;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );
    if (dwErr == ERROR_SUCCESS) {
        RegCloseKey( hkey );
        DfsmStopDfs();
        DfsmResetPkt();
        DfsmInitLocalPartitions();
        DfsmMarkStalePktEntries();
        InitializeVolumeObject( DOMAIN_ROOT_VOL, TRUE, (ulDfsManagerType == DFS_MANAGER_FTDFS)?TRUE:FALSE );
        DfsmFlushStalePktEntries();
    }
    DfsmStartDfs();
    DfsmPktFlushCache();

    EXIT_DFSM_OPERATION;

    if (dwErr != ERROR_SUCCESS)
    {
        IDfsVolInlineDebOut((DEB_ERROR, "InitializeDfsManager failed %08lx\n", dwErr));
        return dwErr;
    }

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {

        //
        // Start the thread that does the DS sync
        //

        dwErr = DfsManagerStartDSSync();

        if (dwErr != ERROR_SUCCESS) {
            IDfsVolInlineDebOut((DEB_ERROR, "DfsManagerStartDSSync failed %08lx\n", dwErr));
            return(dwErr);
        }

    }

    IDfsVolInlineDebOut((DEB_TRACE, "DfsManager exit\n"));

    return ERROR_SUCCESS;

} // DfsManager

DWORD
ClusCallBackFunction(
    HRESOURCE hSelf,
    HRESOURCE hResource,
    LPVOID lpNull)
{
    DWORD Value = 0;
    DWORD dwStatus = ERROR_INVALID_HANDLE;
    HKEY hKey = NULL;
    HKEY hParamKey = NULL;
    WCHAR wszClusterName[MAX_PATH];
    ULONG cSize = MAX_PATH;

    hKey = GetClusterResourceKey(hResource, KEY_READ);

    if (hKey != NULL) {
        dwStatus = ClusterRegOpenKey( hKey, L"Parameters", KEY_READ, &hParamKey );
        DFSM_TRACE_ERROR_HIGH(dwStatus, ALL_ERROR, ClusCallBackFunction_Error_ClusterRegOpenKey,
                                LOGSTATUS(dwStatus));
    }

    if (dwStatus != ERROR_SUCCESS)
        goto ExitWithStatus;

    ResUtilGetDwordValue(hParamKey, L"IsDfsRoot", &Value, 0);
    if (Value == 1
            &&
        GetClusterResourceNetworkName(hResource, wszClusterName, &cSize) == TRUE
    ) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("ClusCallBackFunction: ClusterName = [%ws]\n", wszClusterName);
#endif
        wcscpy(wszDfsRootName, wszClusterName);
        wcscpy(wszComputerName, wszClusterName);
    } else {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("ClusCallBackFunction: Not a root on a cluster.\n");
#endif
    }

ExitWithStatus:
    if (hKey != NULL)
        ClusterRegCloseKey(hKey);
    if (hParamKey != NULL)
        ClusterRegCloseKey(hParamKey);
    return dwStatus;
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsInitGlobals
//
//  Synopsis:   Initialize the Dfs Manager globals.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

extern "C" DWORD
DfsInitGlobals(
    LPWSTR pwszRootName,
    DWORD dwType)
{
    static BOOLEAN fInitDone = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    ULONG ulSize = MAX_PATH*sizeof(WCHAR);
    DFS_NAME_CONVENTION NameType;

    IDfsVolInlineDebOut((DEB_TRACE, "DfsInitGlobals(%ws, %x)\n", pwszRootName, dwType));

    //
    // Only do init once.
    //

    if ( !fInitDone ) {

        DebugInitialize();

#if DBG
        GetDebugSwitches();
        if (DfsSvcVerbose)
            DbgPrint("DfsInitGlobals(%ws,%d)\n", pwszRootName, dwType);
#endif
        GetEventLogSwitches();
        GetConfigSwitches();

        pwszDSMachineName = NULL;

        GTimeout = GetEntryTimeout();

        DcLockIntervalInMs = GetDcLockInterval();

        ulDfsManagerType = dwType;

        pOpenIfJPEa->NextEntryOffset = 0;
        pOpenIfJPEa->Flags = 0;
        pOpenIfJPEa->EaNameLength = strlen(EA_NAME_OPENIFJP);
        pOpenIfJPEa->EaValueLength = 0;
        strcpy(pOpenIfJPEa->EaName, EA_NAME_OPENIFJP);

        //
        // Must enforce exclusivity before the service starts.
        //

        InitializeCriticalSection(&globalCritSec);

#if (DBG == 1) || (_CT_TEST_HOOK == 1)
        gRecoveryBkptInfo.BreakPt      = 0xFFFFFFFF;
        gRecoveryBkptInfo.pwszApiBreak = NULL;
#endif

        wcscpy(wszDfsRootName, pwszRootName);
        pwszDfsRootName = wszDfsRootName;

        //
        // Get computer and domain names
        //

        NameType = (ulDfsManagerType == DFS_MANAGER_FTDFS) ? DFS_NAMETYPE_DNS : DFS_NAMETYPE_EITHER;
        dwErr = GetDomAndComputerName(wszDomainName, wszComputerName, &NameType);

        if (dwErr == NERR_Success) {
            pwszDomainName = wszDomainName;
            pwszComputerName = wszComputerName;
        } else {
            pwszDomainName = NULL;
            pwszComputerName = NULL;
        }

        //
        // Figure out the root of the namespace.
        // The root name is the cluster name on clusters, if
        // this is a machine-based Dfs.
        //

        if (dwErr == NERR_Success && ulDfsManagerType == DFS_MANAGER_SERVER) {

#if DBG
            if (DfsSvcVerbose)
                DbgPrint("DfsInitGlobals: calling ResUtilEnumResources()\n");
#endif

            ResUtilEnumResources(NULL,
                            L"File Share",
                            ClusCallBackFunction,
                            NULL);

        }

        //
        // Initialize the ACLs and other global security datastructures needed
        // for Access Validation
        //

        if (dwErr == ERROR_SUCCESS) {
            if (DfsInitializeSecurity())
                dwErr = ERROR_SUCCESS;
            else
                dwErr = ERROR_UNEXP_NET_ERR;
        }

        //
        // Initialize the LDAP storage
        //

        if (dwErr == ERROR_SUCCESS && ulDfsManagerType == DFS_MANAGER_FTDFS) {

            dwErr = InitializeLdapStorage(
                        wszDfsRootName);

        }

        //
        // Initialize the CSites class/storage
        //

        if (dwErr == ERROR_SUCCESS) {

            if (ulDfsManagerType == DFS_MANAGER_FTDFS) {

                pDfsmSites = new CSites(LDAP_VOLUMES_DIR SITE_ROOT, &dwErr);

            } else {

                pDfsmSites = new CSites(VOLUMES_DIR SITE_ROOT, &dwErr);

            }

            if (pDfsmSites != NULL) {

                if (dwErr != ERROR_SUCCESS) {

                    delete pDfsmSites;

                    pDfsmSites = NULL;

                    dwErr = ERROR_OUTOFMEMORY;

                }

            } else {

                dwErr = ERROR_OUTOFMEMORY;

            }

        }

        //
        // Initialize the Dfs Manager Storage Directory
        //

        if (dwErr == ERROR_SUCCESS ) {

            pDfsmStorageDirectory = new CStorageDirectory( &dwErr );

            if (pDfsmStorageDirectory != NULL) {

                if (dwErr == ERROR_SUCCESS) {

                    fInitDone = TRUE;

                } else {

                    delete pDfsmStorageDirectory;

                    pDfsmStorageDirectory = NULL;

                    delete pDfsmSites;

                    pDfsmSites = NULL;

                    fInitDone = FALSE;
                }

            } else {

                delete pDfsmSites;

                pDfsmSites = NULL;

                fInitDone = FALSE;

                dwErr = ERROR_OUTOFMEMORY;

            }

        }

    }

    IDfsVolInlineDebOut((DEB_TRACE, "DfsInitGlobals() exit\n"));

    return dwErr;

} // DfsInitGlobals

//+----------------------------------------------------------------------------
//
//  Function:   DfsReinitGlobals
//
//  Synopsis:   ReInitialize the Dfs Manager globals.
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------

DWORD
DfsReInitGlobals(
    LPWSTR pwszRootName,
    DWORD dwType)
{
    DWORD dwErr = ERROR_SUCCESS;
    ULONG ulSize = MAX_PATH*sizeof(WCHAR);
    DFS_NAME_CONVENTION NameType;

    IDfsVolInlineDebOut((DEB_TRACE, "DfsReInitGlobals(%ws, %x)\n", pwszRootName, dwType));

#if DBG
    GetDebugSwitches();
    if (DfsSvcVerbose)
        DbgPrint("DfsReInitGlobals(%ws, %d)\n", pwszRootName, dwType);
#endif
    GetEventLogSwitches();
    GetConfigSwitches();

    //
    // Get rid of Dfs Manager storage & site info
    //

    if (pDfsmStorageDirectory != NULL) {

        delete pDfsmStorageDirectory;
        pDfsmStorageDirectory = NULL;

    }

    if (pDfsmSites != NULL) {

        delete pDfsmSites;
        pDfsmSites = NULL;

    }

    //
    // Get rid of Ldap storage
    //

    UnInitializeLdapStorage();

    ulDfsManagerType = dwType;

    wcscpy(wszDfsRootName, pwszRootName);
    pwszDfsRootName = wszDfsRootName;

    //
    // Get computer and domain names
    //

    NameType = (ulDfsManagerType == DFS_MANAGER_FTDFS) ? DFS_NAMETYPE_DNS : DFS_NAMETYPE_EITHER;
    dwErr = GetDomAndComputerName(wszDomainName, wszComputerName, &NameType);

    if (dwErr == NERR_Success) {
        pwszDomainName = wszDomainName;
        pwszComputerName = wszComputerName;
    } else {
        pwszDomainName = NULL;
        pwszComputerName = NULL;
    }

    //
    // Figure out the root of the namespace.
    // The root name is the cluster name on clusters, if
    // this is a machine-based Dfs.
    //

    if (dwErr == NERR_Success && ulDfsManagerType == DFS_MANAGER_SERVER) {

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DfsReInitGlobals: calling ResUtilEnumResources()\n");
#endif

        ResUtilEnumResources(NULL,
                        L"File Share",
                        ClusCallBackFunction,
                        NULL);

    }

    //
    // Initialize the LDAP storage
    //

    if (dwErr == ERROR_SUCCESS && ulDfsManagerType == DFS_MANAGER_FTDFS) {

        dwErr = InitializeLdapStorage(
                    wszDfsRootName);

    }

    //
    // Initialize the CSites class/storage
    //

    if (dwErr == ERROR_SUCCESS) {

        if (ulDfsManagerType == DFS_MANAGER_FTDFS) {

            pDfsmSites = new CSites(LDAP_VOLUMES_DIR SITE_ROOT, &dwErr);

        } else {

            pDfsmSites = new CSites(VOLUMES_DIR SITE_ROOT, &dwErr);

        }

        if (pDfsmSites != NULL) {

            if (dwErr != ERROR_SUCCESS) {

                delete pDfsmSites;
                pDfsmSites = NULL;
                dwErr = ERROR_OUTOFMEMORY;

            }

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    //
    // Initialize the Dfs Manager Storage Directory
    //

    if (dwErr == ERROR_SUCCESS ) {

        pDfsmStorageDirectory = new CStorageDirectory( &dwErr );

        if (pDfsmStorageDirectory != NULL) {

            if (dwErr != ERROR_SUCCESS) {

                delete pDfsmStorageDirectory;
                pDfsmStorageDirectory = NULL;
                delete pDfsmSites;
                pDfsmSites = NULL;

            }

        } else {

            delete pDfsmSites;
            pDfsmSites = NULL;
            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    if (dwType == DFS_MANAGER_FTDFS && hSyncThread == NULL) {

        //
        // Start the thread that does the DS sync
        //

        dwErr = DfsManagerStartDSSync();

        if (dwErr != ERROR_SUCCESS) {
            IDfsVolInlineDebOut((DEB_ERROR, "DfsManagerStartDSSync failed %08lx\n", dwErr));
            return(dwErr);
        }

    }

    IDfsVolInlineDebOut((DEB_TRACE, "DfsReInitGlobals() exit\n"));

    return dwErr;

} // DfsReInitGlobals

//+------------------------------------------------------------------------
//
// Function:    InitializeDfsManager
//
// Synopsis:    This method initializes the PKT with the volume objects
//
// Arguments:   None
//
// Returns:
//
// Notes:
//
//-------------------------------------------------------------------------
DWORD
InitializeDfsManager(void)
{

    DWORD       dwErr;
    HKEY        hkey;

    GetEventLogSwitches();
    GetConfigSwitches();

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        RegCloseKey( hkey );

        dwErr = InitializeVolumeObject( DOMAIN_ROOT_VOL, TRUE );

    } else {

        dwErr = ERROR_SUCCESS;

    }

    return(dwErr);
}

//+-----------------------------------------------------------------------
//
// Function:    InitializeVolumeObject
//
// Synopsis:    This function initializes a volume object and hence all
//              objects underneath that one.
//
// Arguments:   [pwszVolName] -- Volume Object's Name.
//              [bInitVol] -- If TRUE call UpdatePktEntry on this object also.
//
//------------------------------------------------------------------------
DWORD
InitializeVolumeObject(
    PWSTR       pwszVolName,
    BOOLEAN     bInitVol,
    BOOLEAN     SyncRemoteServerName)
{

    ULONG       count = 0;
    DWORD       dwErr;
    CDfsVolume  *tempCDfs;
    WCHAR       wszVolObjName[MAX_PATH];
    HANDLE      PktHandle = NULL;
    NTSTATUS    status;

    IDfsVolInlineDebOut(
            (DEB_TRACE,
            "InitializeVolumeObject(%ws,%d)\n",
            pwszVolName, bInitVol));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("InitializeVolumeObject(%ws,%s)\n",
            pwszVolName,
            bInitVol == TRUE ? "TRUE" : "FALSE");
#endif

    if (ulDfsManagerType == DFS_MANAGER_FTDFS) {
        wcscpy(wszVolObjName, LDAP_VOLUMES_DIR);
    } else {
        wcscpy(wszVolObjName, VOLUMES_DIR);
    }
    wcscat(wszVolObjName, pwszVolName);

    IDfsVolInlineDebOut(
            (DEB_TRACE,
            "wszVolObjName=%ws\n",
            wszVolObjName));

    tempCDfs = new CDfsVolume();

    if (tempCDfs == NULL) {

        dwErr = ERROR_OUTOFMEMORY;

        IDfsVolInlineDebOut((DEB_TRACE, "InitializeVolumeObject Exit\n"));

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("InitializeVolumeObject exit %d\n", dwErr);
#endif

        return dwErr;

    }

    dwErr = tempCDfs->LoadNoRegister(wszVolObjName, 0);


    if (dwErr == ERROR_SUCCESS)  {

        //
        // We'll be sync'ing the site table, so be sure it's ready
        //
        pDfsmSites->AddRef();
        pDfsmSites->MarkEntriesForMerge();

        //
        // We have to update the PKT entry first since InitializePkt
        // will not bother about that part.
        //

        if (bInitVol) {
            status = PktOpen(&PktHandle, 0, 0, NULL);
            if (!NT_SUCCESS(status))
                PktHandle = NULL;
            dwErr = tempCDfs->UpdatePktEntry(PktHandle);
        }

        if (dwErr != ERROR_SUCCESS) {

            //
            // We log an EVENT here since this needs admin intervention
            // but we go on however.
            //

            IDfsVolInlineDebOut((DEB_ERROR, "Could not UpdatePkt on %ws %08lx\n",
                            pwszVolName, dwErr));

        } else
#if DBG
            if (DfsSvcVerbose)
                DbgPrint("InitializevolumeObject:Calling InitializePkt\n");
#endif
            if (PktHandle == NULL) {
                status = PktOpen(&PktHandle, 0, 0, NULL);
                if (!NT_SUCCESS(status))
                    PktHandle = NULL;
            }
            dwErr = tempCDfs->InitializePkt(PktHandle);
            if (PktHandle != NULL)
                PktClose(PktHandle);
#if DBG
            if (DfsSvcVerbose)
                DbgPrint("InitializevolumeObject:InitializePkt returned %d\n", dwErr);
#endif

        //
        // The site table should now be in sync
        //
        pDfsmSites->SyncPktSiteTable();
        pDfsmSites->Release();

    } else {

        IDfsVolInlineDebOut((DEB_ERROR, "Unable to get to %ws %08lx\n",
                                pwszVolName, dwErr));
    }

    tempCDfs->Release();

    IDfsVolInlineDebOut((DEB_TRACE, "InitializeVolumeObject Exit\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("InitializeVolumeObject exit %d\n", dwErr);
#endif
    return( dwErr );
}


//+----------------------------------------------------------------------------
//
//  Function:   InitializeNetDfsInterface
//
//  Synopsis:   Initializes the NetDfs RPC interface, so this Dfs Manager can
//              start servicing the NetDfsXXX APIs.
//
//  Arguments:  None
//
//  Returns:    DWORD_FROM_WIN32 of the RPC status from registering the
//              RPC interface.
//
//-----------------------------------------------------------------------------

DWORD
InitializeNetDfsInterface()
{
    RPC_STATUS status;
    LPWSTR wszProtocolSeq = L"ncacn_np";
    LPWSTR wszEndPoint = L"\\pipe\\netdfs";

    if (NetDfsInitDone == TRUE)
        return ERROR_SUCCESS;

    status = RpcServerUseProtseqEpW(
                    (USHORT *)wszProtocolSeq,    // Named Pipe protocol
                    20,                          // Max # of calls
                    (USHORT *)wszEndPoint,       // Name of named pipe
                    NULL);                       // Security Descriptor

    DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, InitializeNetDfsInterface_Error_RpcServerUseProtseqEpW,
                            LOGSTATUS(status));

    if (status) {
        IDfsVolInlineDebOut((DEB_ERROR, "RpcServerUseProtseqEpW failed %08lx\n", status));
        return(status);
    }

    //
    //  Register the DfsAdministration interface with the RPC runtime library
    //
    status = RpcServerRegisterIf(netdfs_ServerIfHandle, 0, 0);
    DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, InitializeNetDfsInterface_Error_RpcServerRegisterIf,
                            LOGSTATUS(status));

    if (status) {
        IDfsVolInlineDebOut((DEB_ERROR, "RpcServerRegisterIf failed %08lx\n", status));
        return(status);
    }

    //
    //  Wait for client calls...
    //

    status = RpcServerListen(
                1,                               // Minimum # of calls
                RPC_C_LISTEN_MAX_CALLS_DEFAULT,  // Max calls
                1);                              // Don't wait...

    DFSM_TRACE_ERROR_HIGH(status, ALL_ERROR, InitializeNetDfsInterface_Error_RpcServerListen,
                            LOGSTATUS(status));
    if (status) {
        IDfsVolInlineDebOut((DEB_ERROR, "RpcServerListen failed %08lx\n", status));
    }

    if (status == ERROR_SUCCESS) {
        NetDfsInitDone = TRUE;
    }

    return( status );

}


//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerHandleKnowledgeInconsistency
//
//  Synopsis:   Routine to handle knowledge inconsistencies being reported by
//              Dfs clients.
//
//  Arguments:  [Buffer] -- Pointer to marshalled Volume Verify Arg
//              [cbMessage] -- size in bytes of pBuffer
//
//  Returns:    [STATUS_SUCCESS] -- Knowledge inconsistency fixed.
//
//              [STATUS_UNSUCCESSFUL] -- Unable to fix Knowledge inconsistency.
//                      Problem has been logged to event log.
//
//-----------------------------------------------------------------------------

extern "C" NTSTATUS
DfsManagerHandleKnowledgeInconsistency(
    PBYTE       Buffer,
    ULONG       cbMessage)
{

    DWORD               dwErr = ERROR_SUCCESS;
    NTSTATUS            Status;

    MARSHAL_BUFFER      MarshalBuffer;
    DFS_VOLUME_VERIFY_ARG arg;

    PWSTR               pwszVolName;
    CDfsVolume          *pcdfsvol;

    pcdfsvol = new CDfsVolume();

    if (pcdfsvol != NULL) {

        MarshalBufferInitialize(&MarshalBuffer, cbMessage, Buffer);

        Status = DfsRtlGet(&MarshalBuffer, &MiVolumeVerifyArg, &arg);

        if (NT_SUCCESS(Status)) {

            IDfsVolInlineDebOut((DEB_TRACE, "GotParameters: %ws\n", arg.ServiceName.Buffer));

            dwErr = GetVolObjForPath(arg.Id.Prefix.Buffer, TRUE, &pwszVolName);

            if (dwErr == ERROR_SUCCESS) {

                IDfsVolInlineDebOut((DEB_TRACE, "GotVolObjName: %ws\n", pwszVolName));

                dwErr = pcdfsvol->LoadNoRegister(pwszVolName, 0);

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // Remember that the ID actually has the serviceName.
                    //

                    dwErr = pcdfsvol->FixServiceKnowledge(arg.ServiceName.Buffer);

                } else {

                    IDfsVolInlineDebOut((
                        DEB_TRACE, "Could not bind to Vol object\n"));

                }

                delete [] pwszVolName;

            } else {

                IDfsVolInlineDebOut((
                    DEB_TRACE, "Could not get volume objectName\n"));

            }

            if (arg.Id.Prefix.Buffer != NULL) {

                MarshalBufferFree(arg.Id.Prefix.Buffer);

            }

            if (arg.ServiceName.Buffer != NULL) {

                MarshalBufferFree(arg.ServiceName.Buffer);

            }

            if (dwErr != ERROR_SUCCESS)
                Status = STATUS_UNSUCCESSFUL;

        } else {

            IDfsVolInlineDebOut((
                DEB_TRACE,
                "Error (NTSTATUS) unmarshalling Knowledge Sync Params %08lx\n",
                Status));

        }

        pcdfsvol->Release();

    } else {

        Status = STATUS_UNSUCCESSFUL;

    }

    return(Status);
}

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerStartDSSync
//
//  Synopsis:   Starts a thread that will periodically sync up with the PKT
//              in the DS. Used on FT-Dfs root servers.
//
//  Arguments:  None
//
//  Returns:    Win32 error from result of allocating necessary resources to
//              do DS sync
//
//-----------------------------------------------------------------------------

DWORD
DfsManagerStartDSSync()
{

    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES obja;

    ASSERT( ulDfsManagerType == DFS_MANAGER_FTDFS );

    InitializeObjectAttributes(&obja, NULL, OBJ_OPENIF, NULL, NULL);
    Status = NtCreateEvent(
                    &hSyncEvent,
                    SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                    &obja,
                    SynchronizationEvent,
                    FALSE);

    if (Status == STATUS_SUCCESS) {
      Status = NtCreateEvent(
                    &hFrsSyncEvent,
                    SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                    &obja,
                    SynchronizationEvent,
                    FALSE);
    }

    DFSM_TRACE_ERROR_HIGH(Status, ALL_ERROR, DfsManagerStartDSSync_Error_NtCreateEvent,
                            LOGSTATUS(Status));

    if (Status == STATUS_SUCCESS) {

        hSyncThread = CreateThread(
                        NULL,
                        0,
                        DfsManagerDSSyncThread,
                        NULL,
                        0,
                        &dwSyncThreadId);

        if (hSyncThread == NULL)
            dwErr = GetLastError();

    } else {

        dwErr = GetLastError();
        hSyncEvent = NULL;

    }

    return( dwErr );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfsManagerDSSyncThread
//
//  Synopsis:   Periodically syncs the local metadata with the DS
//
//  Arguments:  [Context] -- Ignored
//
//  Returns:    Nothing
//
//-----------------------------------------------------------------------------


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
DWORD
DfsManagerDSSyncThread(
    PVOID Context)
{
    DWORD dwErr;
    HKEY hkey;

    while (1) {

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("DfsManagerDSSyncThread()\n");
#endif

        dwSyncIntervalInMs = GetSyncInterval();

        dwErr = WaitForSingleObject(hSyncEvent, dwSyncIntervalInMs);

	if (dwErr != WAIT_TIMEOUT) {
          WaitForSingleObject(hFrsSyncEvent, dwFrsSyncIntervalInMs);
	}

        IDfsVolInlineDebOut((DEB_TRACE, "DfsManagerDSSyncThread()\n"));

        if (ulDfsManagerType == DFS_MANAGER_FTDFS) {

            ENTER_DFSM_OPERATION;

            dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );
            if (dwErr == ERROR_SUCCESS) {
                RegCloseKey( hkey );
                LdapIncrementBlob(TRUE);
                dwErr = LdapDecrementBlob();
            }

            EXIT_DFSM_OPERATION;
        }

    }

    return( 0 );

}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


//+----------------------------------------------------------------------------
//
//  Function:   DfspGetPdc
//
//  Synopsis:   Sets the global pwszDSMachineName to the PDC
//
//  Arguments:  None
//
//  Returns:    ERROR_SUCCESS or failure
//
//-----------------------------------------------------------------------------
DWORD
DfspGetPdc(void)
{
    DWORD dwErr;
    PDOMAIN_CONTROLLER_INFO pDCInfo;

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspGetPdc()\n");
#endif

    dwErr = DsGetDcName(
                NULL,                            // Computer to remote to
                NULL,                            // Domain - use local domain
                NULL,                            // Domain Guid
                NULL,                            // Site Guid
                DS_PDC_REQUIRED | DS_FORCE_REDISCOVERY,
                &pDCInfo);

    DFSM_TRACE_ERROR_HIGH(dwErr, ALL_ERROR, DfspGetPdc_Error_DsGetDcName,
			 LOGULONG(dwErr)
			 );

    if (dwErr == ERROR_SUCCESS) {

        if (pwszDSMachineName == NULL)
            pwszDSMachineName = wszDSMachineName;
        wcscpy(pwszDSMachineName, &pDCInfo->DomainControllerName[2]);
        NetApiBufferFree( pDCInfo );

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfspGetPdc() returning %d\n", dwErr);
#endif

    return( dwErr );
}

//+----------------------------------------------------------------------------
//
//  Function:   GetSyncInterval
//
//  Synopsis:   Returns the interval at which to sync with the DS
//
//  Arguments:  None
//
//  Returns:    Returns the interval at which to sync with the DS
//
//-----------------------------------------------------------------------------

DWORD
GetSyncInterval()
{
    DWORD dwErr;
    DWORD dwType;
    DWORD dwIntervalInSeconds = 60 * 60;
    DWORD cbData;
    HKEY hkey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REG_KEY_DFSSVC, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbData = sizeof(dwIntervalInSeconds);

        dwErr = RegQueryValueEx(
                    hkey,
                    SYNC_INTERVAL_NAME,
                    NULL,
                    &dwType,
                    (PBYTE) &dwIntervalInSeconds,
                    &cbData);

        if (!(dwErr == ERROR_SUCCESS && dwType == REG_DWORD)) {

            dwIntervalInSeconds = 60 * 60;

        }

        RegCloseKey(hkey);

    }

    return( dwIntervalInSeconds * 1000 );

}

//+----------------------------------------------------------------------------
//
//  Function:   GetDcLockInterval
//
//  Synopsis:   Returns the interval to lock onto a DC
//
//  Arguments:  None
//
//  Returns:    Returns the interval to lock onto a DC
//
//-----------------------------------------------------------------------------

ULONG
GetDcLockInterval()
{
    DWORD dwErr;
    DWORD dwType;
    DWORD dwIntervalInSeconds = 60 * 60 * 2;
    DWORD cbData;
    HKEY hkey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REG_KEY_DFSSVC, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbData = sizeof(dwIntervalInSeconds);

        dwErr = RegQueryValueEx(
                    hkey,
                    DCLOCK_INTERVAL_NAME,
                    NULL,
                    &dwType,
                    (PBYTE) &dwIntervalInSeconds,
                    &cbData);

        if (!(dwErr == ERROR_SUCCESS && dwType == REG_DWORD)) {

            dwIntervalInSeconds = 60 * 60 * 2;

        }

        RegCloseKey(hkey);

    }

    return( dwIntervalInSeconds * 1000 );

}

//+----------------------------------------------------------------------------
//
//  Function:   GetEntryTimeout
//
//  Synopsis:   Returns the timeout (in seconds) for jp's
//
//  Arguments:  None
//
//-----------------------------------------------------------------------------

DWORD
GetEntryTimeout()
{
    DWORD dwErr;
    DWORD dwType;
    DWORD dwTimeoutInSeconds = DEFAULT_PKT_ENTRY_TIMEOUT;
    DWORD cbData;
    HKEY hkey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbData = sizeof(dwTimeoutInSeconds);

        dwErr = RegQueryValueEx(
                    hkey,
                    REG_VALUE_TIMETOLIVE,
                    NULL,
                    &dwType,
                    (PBYTE) &dwTimeoutInSeconds,
                    &cbData);

        if (!(dwErr == ERROR_SUCCESS && dwType == REG_DWORD)) {

            dwTimeoutInSeconds = DEFAULT_PKT_ENTRY_TIMEOUT;

        }

        RegCloseKey(hkey);

    }

    return( dwTimeoutInSeconds );

}

//+----------------------------------------------------------------------------
//
//  Function:   DfspGetFtDfsName
//
//  Synopsis:   Gets the FtDfs name from the registry
//
//  Arguments:  None
//
//-----------------------------------------------------------------------------

DWORD
DfspGetFtDfsName()
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cbName;
    HKEY hkey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, VOLUMES_DIR, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbName = sizeof(wszFtDfsName);

        dwErr = RegQueryValueEx(
                    hkey,
                    FTDFS_VALUE_NAME,
                    NULL,
                    &dwType,
                    (PBYTE) wszFtDfsName,
                    &cbName);

        if (dwErr == ERROR_SUCCESS && dwType != REG_SZ) {

            dwErr = ERROR_FILE_NOT_FOUND;

        }

        RegCloseKey( hkey );

        if (dwErr == ERROR_SUCCESS) {

            pwszFtDfsName = wszFtDfsName;

        } else {

            pwszFtDfsName = NULL;

        }

    }

    return dwErr;

}

//+----------------------------------------------------------------------------
//
//  Function:   GetConfigSwitches
//
//  Synopsis:   Get configuration switches from the registry
//
//  Arguments:  None
//
//-----------------------------------------------------------------------------

VOID
GetConfigSwitches()
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cbData;
    HKEY hkey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REG_KEY_DFSSVC, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbData = sizeof(DfsDnsConfig);
        dwErr = RegQueryValueEx(
                    hkey,
                    REG_VALUE_DFSDNSCONFIG,
                    NULL,
                    &dwType,
                    (PBYTE) &DfsDnsConfig,
                    &cbData);

        if (!(dwErr == ERROR_SUCCESS && dwType == REG_DWORD))
            DfsDnsConfig = 0;

        cbData = sizeof(DfsSvcLdap);
        dwErr = RegQueryValueEx(
                    hkey,
                    REG_VALUE_LDAP,
                    NULL,
                    &dwType,
                    (PBYTE) &DfsSvcLdap,
                    &cbData);

        if (!(dwErr == ERROR_SUCCESS && dwType == REG_DWORD))
            DfsSvcLdap = 0;


        RegCloseKey(hkey);

    }

}

//+----------------------------------------------------------------------------
//
//  Function:   GetEventLogSwitches
//
//  Synopsis:   Gets the event log switch values
//
//  Arguments:  None
//
//-----------------------------------------------------------------------------

VOID
GetEventLogSwitches()
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cbData;
    HKEY hkey = NULL;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REG_KEY_EVENTLOG, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbData = sizeof(DfsEventLog);

        dwErr = RegQueryValueEx(
                    hkey,
                    REG_VALUE_EVENTLOG_GLOBAL,
                    NULL,
                    &dwType,
                    (PBYTE) &DfsEventLog,
                    &cbData);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD)
            goto Cleanup;

        DfsEventLog = 0;

        cbData = sizeof(DfsEventLog);

        dwErr = RegQueryValueEx(
                    hkey,
                    REG_VALUE_EVENTLOG_DFS,
                    NULL,
                    &dwType,
                    (PBYTE) &DfsEventLog,
                    &cbData);

        if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD)
            goto Cleanup;

        //
        // Could not find either the global nor the dfs event log setting
        //

        DfsEventLog = 0;

    }

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("Dfssvc:DfsEventLog = 0x%x\n", DfsEventLog);
#endif

Cleanup:

    if (hkey != NULL)
        RegCloseKey(hkey);

}

#if DBG
//+----------------------------------------------------------------------------
//
//  Function:   GetDebugSwitches
//
//  Synopsis:   Gets the debug switch values
//
//  Arguments:  None
//
//-----------------------------------------------------------------------------

VOID
GetDebugSwitches()
{
    DWORD dwErr;
    DWORD dwType;
    DWORD cbData;
    HKEY hkey;

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, REG_KEY_DFSSVC, &hkey );

    if (dwErr == ERROR_SUCCESS) {

        cbData = sizeof(DfsSvcVerbose);

        dwErr = RegQueryValueEx(
                    hkey,
                    REG_VALUE_VERBOSE,
                    NULL,
                    &dwType,
                    (PBYTE) &DfsSvcVerbose,
                    &cbData);

        if (!(dwErr == ERROR_SUCCESS && dwType == REG_DWORD)) {

            DfsSvcVerbose = 0;

        }

        cbData = sizeof(IDfsVolInfoLevel);

        dwErr = RegQueryValueEx(
                    hkey,
                    REG_VALUE_IDFSVOL,
                    NULL,
                    &dwType,
                    (PBYTE) &IDfsVolInfoLevel,
                    &cbData);

        if (!(dwErr == ERROR_SUCCESS && dwType == REG_DWORD)) {

            IDfsVolInfoLevel = DEF_INFOLEVEL;

        }

        RegCloseKey(hkey);

    }

}
#endif



//+------------------------------------------------------------------------
//
// Function:    LogMessage()
//
// Synopsis:    This method takes an error code and a list of strings and
//              displays the right message for now. Later on this will have
//              to raise an event and do the appropriate stuff actually.
//
// Arguments:   [ErrNum] -- Error Number (SCODE). This identifies message to
//                          pick up.
//              [pwcstrs] -- The strings that are to be displayed.
//              [count]  --  Number of strings in above array.
//              [Severity] -- The severity of the error so that we can turn
//                              off debuggin selectively.
//
// Returns:     Nothing.
//
// Notes:
//
// History:     10-Feb-1993     SudK    Created.
//
//-------------------------------------------------------------------------
VOID
LogMessageFull(
   DWORD Severity,
   PWCHAR pwcstrs[],
   DWORD  count,
   DWORD  ErrNum)
{
    IDfsVolInlineDebOut(( Severity, " [%ws] \n", DfsErrString[ErrNum] ));

    for (ULONG _i=0; _i<count; _i++)    {
        IDfsVolInlineDebOut(( Severity,  "Str%d : [%ws] \n", _i, pwcstrs[_i] ));
    }
    IDfsVolInlineDebOut((Severity, "***%s @ %d *****\n", __FILE__, __LINE__));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\custring.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	custring.cxx
//
//  Contents:	This has the code for the UNICODE_STRING class.
//
//  Classes:
//
//  Functions:
//
//  History:    26-Jan-93	SudK	Created
//
//--------------------------------------------------------------------------
#include <headers.hxx>
#pragma hdrstop

// C Runtime Headers
#include <malloc.h>
#include <memory.h>
#include <string.h>
#include <wchar.h>
#include <stdlib.h>

// NT Headers
#include <nt.h>
#include <ntrtl.h>

#include <windef.h>

//
//  String manipulation routines
//

//+-------------------------------------------------------------------------
//
//  Function:   SRtlDuplicateString
//
//  Synopsis:   Makes a copy of the string referenced by pSrc
//
//  Effects:    Memory is allocated from the process heap.
//              An exact copy is made, except that:
//                  Buffer is zero'ed
//                  Length bytes are copied
//
//  Arguments:	[pDest] --	The destination unicode string.
//		[pSrc]  --	The source unicode string.
//
//  Returns:	Nothing
//
//  Notes:	The string is terminated with a NULL but this need not be 
//		a part of the Length of the UNICODE_STRING.
//		This func will throw an exception if a memory failure occurs.
//
//--------------------------------------------------------------------------
void
SRtlDuplicateString(PUNICODE_STRING    pDest,
                    PUNICODE_STRING    pSrc)
{
    pDest->Buffer = new WCHAR[pSrc->MaximumLength/sizeof(WCHAR) + 1];
    if (pDest->Buffer != NULL) {
        memset(pDest->Buffer, 0, pSrc->MaximumLength);
        memmove(pDest->Buffer, pSrc->Buffer, pSrc->Length);
        pDest->Buffer[pSrc->Length/sizeof(WCHAR)] = UNICODE_NULL;

        pDest->MaximumLength = pSrc->MaximumLength;
        pDest->Length = pSrc->Length;
    } else {
        pDest->MaximumLength = 0;
        pDest->Length = 0;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SRtlNewString
//
//  Synopsis:   Creates a COPY of the wide character string pointer pSrc
//              and sets up a UNICODE_STRING appropriately
//
//
//  Effects:    Memory is allocated off of the process heap
//              The string remains null terminated.
//
//
//  Arguments:	[pDest] --	Destination UNICODE_STRING.
//		[pSrc]  --	The WCHAR string that needs to be copied.
//
//  Returns:	Nothing
//
//  Note:	This func will throw an exception if a memory failure occurs.
//		The String is terminated with a NULL but this need not be a
//		part of the Length of the UNICODE_STRING. If the input string
//		is NULL then this function will create a NULL UNICODE_STRING.
//
//--------------------------------------------------------------------------
void
SRtlNewString(  PUNICODE_STRING    pDest,
                PWCHAR       pSrc)
{
    UNICODE_STRING Source;

    if (pSrc!=NULL)	{
    	Source.Length = wcslen((WCHAR *) pSrc) * sizeof(WCHAR);
    	Source.MaximumLength = Source.Length + sizeof(WCHAR);
    	Source.Buffer = pSrc;
    	SRtlDuplicateString(pDest, &Source);
    }
    else	{
	pDest->Length = pDest->MaximumLength = 0;
	pDest->Buffer = NULL;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SRtlFreeString
//
//  Synopsis:   Takes a UNICODE_STRING and frees the memory associated with it.
//		This method also sets the Buffer Pointer to NULL and zeroes
//		out both the Length fields in the UNICODE_STRING.
//
//  Arguments:	[pString] --	The UNICODE string that needs to be deallocated.
//
//  Returns:	Nothing
//
//--------------------------------------------------------------------------
void
SRtlFreeString( PUNICODE_STRING    pString)
{
	delete [] pString->Buffer;
	pString->Length = pString->MaximumLength = 0;
	pString->Buffer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\dfsmsgs.cxx ===
//-------------------------------------------------------------------------
//
// File:        dfsmsgs.hxx
//
// Contents:    This has the array which has all the messages that Klass code
//              ever uses.
//
// History:     02-20-93        SudK    Created.
//
//-------------------------------------------------------------------------
#include "headers.hxx"
#pragma hdrstop

PWCHAR  *nullPtr = NULL;

PWCHAR  DfsErrString[] =
    {
        L"ServiceObject seems to be Bad : ",
        L"Volume Object seems to be Bad : ",
        L"Recovery on this Volume object failed : ",
        L"Invalid Argument was passed in. Call Rejected. ",
        L"Failed to update Pkt. This should not have happened at all.",
        L"Service Does not exist in Service List. ",
        L"Cant get to the Parent volume object. ",
        L"Cant create child volume object. ",
        L"Cant create any exit point at any of the services. ",
        L"Unable to get to one of the children of: ",
        L"Attempting recovery on this volume: ",
        L"Unable to create subordinate entry: ",
        L"Unable to set this service property: ",
        L"Unable to delete this service property: ",
        L"Unable to delete the local volume: ",
        L"Recovered From Creation of this volume: ",
        L"Recovered From AddService to this volume: ",
        L"Recovered From RemoveService to this volume: ",
        L"Recovered From Deletion of this volume: ",
        L"Recovered From Move of this volume: ",
        L"Unable to recover from a RemoveService operation :",
        L"Unknown recovery state message on this volume: ",
        L"Unable to delete PKT Entry: ",
        L"Caught an exception. Operation and VolumeIdentity below:",
        L"Following Service Already exists and adding was attempted: ",
        L"Cannot Create Subordinate Entry for this volume: ",
        L"Cannot Delete Exit Point at this Service: ",
        L"Failed to Do CreateLocalVolume on this Service: ",
        L"Random Recovery Code was found on this Object: ",
        L"Inconsistent recovery args found on this object: ",
        L"ModifyPrefix to on service failed. Args Follow: ",
        L"Unable to verify server's knowledge for: ",
        L"Unable to force-sync server: ",
        L"Volume name simultaneously modified! Unable to reconcile ",
        L"Volume state simultaneously modified! Unable to reconcile ",
        L"Volume comment simultaneously modified! Unable to reconcile ",
        L"Error reconciling volume prefix change for volume: ",
        L"Error reconciling volume prefix change - invalid parent: ",
        L"Unable to save reconciliation changes for volume: ",
        L"Unable to change volume state at: "
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\dfsmwml.c ===
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <windows.h>

#include "wmlum.h"
#include "wmlmacro.h"
#include "dfsmwml.h"

WMILIB_REG_STRUCT   DfsRtlWmiReg;
GUID DfsmRtlTraceGuid = { // b9b7bc53-16c8-46e6-b486-6d6172b1ae78 
    0xb9b7bc53,0x16c8,0x46e6,
    {0xb4,0x86,0x6d,0x61,0x72,0xb1,0xae,0x78}
};


WML_DATA wml;

void print(UINT level, PCHAR str) {
   //DbgPrint(str);
    return;
}

void DfsInitWml()
{
    NTSTATUS status;
    LOADWML(status, wml);
    status = wml.Initialize(L"DFS Service", print, &wml.WmiRegHandle, 
                   L"DFS Service", &DfsRtlWmiReg,
                   0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\dfs\dfsm\server\idfsvol.cxx ===
//+-------------------------------------------------------------------------
//
//  File:       idfsvol.cxx
//
//  Contents:   Implementation of IDfsVolume interface. This interface
//              supports the administrative functions on DFS.
//
//--------------------------------------------------------------------------
//#include <ntos.h>
//#include <ntrtl.h>
//#include <nturtl.h>
//#include <dfsfsctl.h>
//#include <windows.h>

#include "headers.hxx"
#pragma hdrstop

#include "dfsmsrv.h"
#include "dfsm.hxx"
#include "cdfsvol.hxx"
#include "jnpt.hxx"
#include "dfsmwml.h"

VOID
ComputeNewEntryPath(
    PWCHAR      oldPath,
    PWCHAR      newPath,
    PWCHAR      childPath,
    PWCHAR      *childNewPath
);

NTSTATUS
MoveFileOrJP(
    IN PCWSTR pwszSrcName,
    IN PCWSTR pwszTgtName
);



//+-------------------------------------------------------------------------
//
// Method:      AddReplicaToObj, private
//
// Synopsis:    This method adds a replica info structure to the volume
//              object and returns after that.
//
// Arguments:   [pReplicaInfo] -- The ReplicaInfo structure.
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::AddReplicaToObj(
    PDFS_REPLICA_INFO   pReplicaInfo
)
{
    DWORD               dwErr = ERROR_SUCCESS;
    CDfsService         *pService = NULL;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::AddReplicaToObj()\n"));

    //
    // First before we even set recoveryProperties we want to make sure
    // that this service does not already exist in the ServiceList.
    //
    if ((dwErr == ERROR_SUCCESS) &&
        (_DfsSvcList.GetService(pReplicaInfo, &pService) == ERROR_SUCCESS)) {
        dwErr = NERR_DfsDuplicateService;
    }


    if (dwErr == ERROR_SUCCESS)      {
        //
        // Argument validation also takes place right in this constructor.
        // Also the ServiceName etc. gets converted to an ORG based name in
        // the constructor. So we dont need to worry about that at all.
        //
        pService = new CDfsService(pReplicaInfo, TRUE, &dwErr);

        if (pService == NULL)
            dwErr = ERROR_OUTOFMEMORY;

    }

    if (dwErr == ERROR_SUCCESS) {

        //
        // Set the new service properties on the volume object. This method
        // will return an error code if the service already exists on the
        // volume object. No explicit checking need be done here.
        //

        if (dwErr == ERROR_SUCCESS) {

            pService->SetCreateTime();

            dwErr = _DfsSvcList.SetNewService(pService);

            if (dwErr != ERROR_SUCCESS) {
                IDfsVolInlineDebOut((
                    DEB_ERROR, "Failed to Set new replica %08lx\n",dwErr));
            }

        }

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::AddReplicaToObj() exit\n"));

    return(dwErr);
}



//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::AddReplica, public
//
// Synopsis:    This function associates a new service with an existing
//              Volume Object. A new service is defined by the ServiceName,
//              StorageId, Type of Service, and sometimes an AddressQualifier.
//              For this operation to succeed the service being added should
//              be available. Unavailability of the service will result in
//              failure of this method. This operation will be atomic as far
//              as all information on the DC is concerned. Either the operation
//              will succeed or no irrelevant information will be left on the
//              DC. However, there are no guarantees made regarding the state
//              of the service involved in the face of Network Failures and
//              remote service crashes etc. If you attempt to add the same
//              service name again it will return an error.
//
// Arguments:   [pReplicaInfo] -- The ServiceInfo here. Look at docs for details
//
// Returns:     ERROR_SUCCESS -- If the operation succeeded.
//
//              ERROR_OUTOFMEMORY -- Unable to allocate memory for operation.
//
//              NERR_DfsVolumeIsOffline -- The volume is offline, can't do
//                      AddReplica operation on it.
//
//              NERR_DfsDuplicateService --
//                              If the service already exists on this volume.
//
//              NERR_DfsVolumeDataCorrupt --
//                              If the volume object to which this
//                              service is being added is corrupt.
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::AddReplica(
    PDFS_REPLICA_INFO   pReplicaInfo,
    ULONG               fCreateOptions
)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PWCHAR              ErrorStrs[3];
    CDfsService         *pService = NULL;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::AddReplica()\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsVolume::AddReplica(%ws,%ws,0x%x)\n",
            pReplicaInfo->pwszServerName,
            pReplicaInfo->pwszShareName);
#endif

    if (_State == DFS_VOLUME_STATE_OFFLINE) {

#if DBG
        if (DfsSvcVerbose)
            DbgPrint("CDfsVolume::AddReplica exit NERR_DfsVolumeIsOffline\n");
#endif
        return( NERR_DfsVolumeIsOffline );
    }

    //
    // First before we even set recoveryProperties we want to make sure
    // that this service does not already exist in the ServiceList.
    //
    if (_DfsSvcList.GetService(pReplicaInfo, &pService) == ERROR_SUCCESS) {
#if DBG
        if (DfsSvcVerbose)
            DbgPrint("CDfsVolume::AddReplica: returning NERR_DfsDuplicateService\n");
#endif
        pService = NULL;                         // So we don't try to delete
        dwErr = NERR_DfsDuplicateService;        // it later...
    }


    if (dwErr == ERROR_SUCCESS)      {
        //
        // Argument validation also takes place right in this constructor.
        // Also the ServiceName etc. gets converted to an ORG based name in
        // the constructor. So we dont need to worry about that at all.
        //
        pService = new CDfsService(pReplicaInfo, TRUE, &dwErr);

        if (pService == NULL)
            dwErr = ERROR_OUTOFMEMORY;

   }

   if (dwErr == ERROR_SUCCESS) {

        pService->SetCreateTime();

        RECOVERY_TEST_POINT(L"AddReplica", 1);

        //
        // This is where we want to do some STATE changes. Register the
        // intent of doing an AddReplicaoperation and mention the service
        // name and record that we are in the Start State.      RECOVERY
        // If we cant set recovery props then something is really wrong.
        // The following constructor will throw an exception and we will
        // deal with it appropriately.
        //

        dwErr = _Recover.SetOperationStart(
                     DFS_RECOVERY_STATE_ADD_SERVICE,
                     pService);

        RECOVERY_TEST_POINT(L"AddReplica", 2);

        //
        // Set the new service properties on the volume object. This method
        // will return an error code if the service already exists on the
        // volume object. No explicit checking need be done here.
        //

        if (dwErr == ERROR_SUCCESS)      {
            dwErr = _DfsSvcList.SetNewService(pService);
	}

        if (dwErr != ERROR_SUCCESS)      {
            //
            // 433532, SetNewService already deletes pservice in case of
            // failure. Dont use pservice, and set it to NULL so it does
            // not get freed twice!

            pService = NULL;

            //LogMessage( DEB_TRACE,
            //      &(pService->GetServiceName()),
            //         1,
            //         DFS_CANNOT_SET_SERVICE_PROPERTY_MSG);
        }

    }

    if (dwErr == ERROR_SUCCESS)   {
        //
        // Now we need to change the state to UpdatedSvcList        RECOVERY
        //
        RECOVERY_TEST_POINT(L"AddReplica", 3);

        _Recover.SetOperStage(DFS_OPER_STAGE_SVCLIST_UPDATED);

        RECOVERY_TEST_POINT(L"AddReplica", 4);

        //
        // Let us now ask the remote machine to create a local volume.
        // If we fail to do this for ANY reason, we fail the operation.
        //

        dwErr = pService->CreateLocalVolume(&_peid, _EntryType);

        //
        // If we failed, it might be because the server's state is not
        // consistent with our state. See if this is the case, and
        //

        //
        // If we failed we need to delete the entry from the serviceList.
        // We have to use the servicename from the DfsSvc class since that
        // is the ORG based name. If we get an error here as well then
        // we will return that error (dwErr2) since it becomes more relevant
        // suddenly. Else we will return the error we got above from
        // CreateLocalVolume which will be returning a proper error to us.
        //

        if (dwErr != ERROR_SUCCESS) {

            DWORD dwErr2 = _DfsSvcList.DeleteService(pService, FALSE);
	    PWCHAR              ErrorStrs[1];

	    ErrorStrs[0] = (pService->GetServiceName());
            if (dwErr2 != ERROR_SUCCESS)     {
                LogMessage( DEB_ERROR,
                            ErrorStrs,
                            1,
                            DFS_CANNOT_DELETE_SERVICE_PROPERTY_MSG);

                dwErr = NERR_DfsVolumeDataCorrupt;

            } else {

                //
                // DeleteService() deleted this instance for us, so set the
                // pointer to NULL
                //

                pService = NULL;

            }
        }
    }       //CreateLocalVolumeDone OR FAILED.

    //
    // Now we set state to DONE on vol object. It is of no concern whether
    // the operation succeeded or failed.
    //
    RECOVERY_TEST_POINT(L"AddReplica", 5);

    _Recover.SetOperationDone();

    if (dwErr == ERROR_SUCCESS)   {
        //
        // Now we update the PKT with the new service. We get an
        // appropriate Error Code from UpdatePktEntry.
        //

        dwErr = UpdatePktEntry(NULL);
        if (dwErr != ERROR_SUCCESS)  {
            //
            // Why should this fail at all.
            // An EVENT here too maybe.
            //
            LogMessage(     DEB_ERROR,
                    &(_peid.Prefix.Buffer),
                    1,
                    DFS_FAILED_UPDATE_PKT_MSG);
            IDfsVolInlineDebOut((DEB_ERROR, "UpdPktEntFailed %08lx\n", dwErr));
            ASSERT(L"UpdatePktEntry Failed in AddService - WHY?");
        }

    } //UpdatePktEntry Block.

    if (dwErr != ERROR_SUCCESS) {
        _Recover.SetOperationDone();
        if (pService != NULL)
            delete pService;
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::AddReplica() exit\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsVolume::AddReplica exit %d\n", dwErr);
#endif

    return(dwErr);

}

//+----------------------------------------------------------------------------
//
//  Member:     CDfsVolume::RemoveReplicaFromObj, public
//
//  Synopsis:   This operation removes a replica from a volume object and
//              returns after that.
//
//  Arguments:  [pwszServiceName] -- Name of server to remove
//
//  Returns:    
//
//-----------------------------------------------------------------------------

DWORD
CDfsVolume::RemoveReplicaFromObj(
    IN LPWSTR pwszServiceName)
{
    DWORD dwErr;
    CDfsService *pSvc;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RemoveReplicaFromObj(%ws)\n", pwszServiceName));

    dwErr = _DfsSvcList.GetServiceFromPrincipalName( pwszServiceName, &pSvc );

    if (dwErr == ERROR_SUCCESS) {

        //
        // See if this is the last service. In that case, we cannot
        // permit anyone to delete it.
        //

        if (_DfsSvcList.GetServiceCount() == 1) {
            dwErr = NERR_DfsCantRemoveLastServerShare;
        }

        //
        // Now delete the service from the service list
        //
        dwErr = _DfsSvcList.DeleteService(pSvc);

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RemoveReplicaFromObj() exit\n"));

    return( dwErr );

}

//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::RemoveReplica, public
//
// Synopsis:    This operation dissociates a service from a volume in the DFS
//              namespace. On the DC this merely involves modifying the service
//              List on the Volume object. At the same time the service involved
//              has to be notified of this change. This operation will fail if
//              for some reason the service refuses to delete its knowledge
//              regarding this volume or if there are network failures
//              during this operation. Of course if we fail the operation due
//              to Network failures note the fact that the operation at the
//              remote service might have succeeded and network failed after
//              that - in which case we may have an INCONSISTENCY (very easy to
//              detect this one).
//
// Arguments:   [pwszServiceName] --    The name of the service to be deleted
//                                      from the volume object.
//
// Returns:     DFS_S_SUCCESS -- If the operation succeeded.
//
//              NERR_DfsNoSuchShare -- If the specified server\share is not
//                      a service for this volume.
//
//              NERR_DfsCantRemoveLastServerShare -- If the specified
//                      server\share is the only service for this volume.
//
//              NERR_DfsVolumeDataCorrupt -- If the volume object could not
//                      be read.
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::RemoveReplica(
    PDFS_REPLICA_INFO           pReplicaInfo,
    ULONG                       fDeleteOptions
)
{
    DWORD               dwErr = ERROR_SUCCESS;
    DWORD               dwErr2 = ERROR_SUCCESS;
    PWCHAR              orgServiceName = NULL;
    CDfsService         *pDfsSvc;
    PWCHAR              ErrorStrs[3];

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RemoveReplica()\n"));

    dwErr = _DfsSvcList.GetService(pReplicaInfo, &pDfsSvc);

    if (dwErr != ERROR_SUCCESS)  {

            LogMessage(     DEB_TRACE,
                            nullPtr,
                            0,
                            DFS_SERVICE_DOES_NOT_EXIST_MSG);
    }

    if (dwErr == ERROR_SUCCESS &&
            _EntryType & DFS_VOL_TYPE_REFERRAL_SVC &&
                !(_EntryType & DFS_VOL_TYPE_INTER_DFS)) {
        dwErr = NERR_DfsCantRemoveDfsRoot;
    }

    if (dwErr == ERROR_SUCCESS) {

        //
        // See if this is the last service. In that case, we cannot
        // permit anyone to delete it.
        //

        if (_DfsSvcList.GetServiceCount() == 1) {
            dwErr = NERR_DfsCantRemoveLastServerShare;
        }

    }

    if (dwErr != ERROR_SUCCESS) {

        return(dwErr);
    }

    if (dwErr == ERROR_SUCCESS)   {

        //
        // Next we register the intent to delete a specific service by
        // marking the ServiceName on the object.           RECOVERY.
        //
        RECOVERY_TEST_POINT(L"RemoveReplica", 1);

        dwErr = _Recover.SetOperationStart(DFS_RECOVERY_STATE_REMOVE_SERVICE,
                                           pDfsSvc);

        RECOVERY_TEST_POINT(L"RemoveReplica", 2);

        //
        // Now that we know that such a service is actually registered.
        // Let us request the remote service to delete LVOL knowledge.
        //

        if (dwErr == ERROR_SUCCESS)  {
            dwErr = pDfsSvc->DeleteLocalVolume(&_peid);
	}

        if (dwErr != ERROR_SUCCESS)  {
            //
            // We assume that if we got an error here we are in big trouble
            // and we back out the operation infact. The DeleteLocalVolume
            // method would have already taken care of filtering out the
            // relevant errors for us.
            //
            LogMessage(     DEB_TRACE,
                    &(_peid.Prefix.Buffer),
                    1,
                    DFS_DELETE_VOLUME_FAILED_MSG);

            //
            // Since we got this error we assume that we could not find
            // the service. However, that need not be the reason at all.
            // Raid: 455283. Need to resolve this later on.
            //
            dwErr = NERR_DfsNoSuchShare;
        }
    }

    if ((dwErr == ERROR_SUCCESS) || (fDeleteOptions & DFS_OVERRIDE_FORCE))   {

        //
        // Now we write out RecoveryState to DFS_OPER_STAGE_INFORMED_SERVICE
        //
        RECOVERY_TEST_POINT(L"RemoveReplica", 3);

        _Recover.SetOperStage(DFS_OPER_STAGE_INFORMED_SERVICE);

        RECOVERY_TEST_POINT(L"RemoveReplica", 4);

        //
        // Now write out the new service list
        //
        dwErr2 = _DfsSvcList.DeleteService(pDfsSvc);

        if (dwErr2 != ERROR_SUCCESS) {
            //
            // This should never happen. We probably had some security
            // problems. Do we now go and back out the Previous Step. Raid 455283
            //
            ErrorStrs[1] = pDfsSvc->GetServiceName();
            ErrorStrs[0] = _peid.Prefix.Buffer;
            LogMessage(     DEB_ERROR,
                            ErrorStrs,
                            2,
                            DFS_CANNOT_DELETE_SERVICE_PROPERTY_MSG);
            ASSERT(L"Deleting and existing service FAILED in RemRepl");
        }
    }

    //
    // Done. The operation is committed if the last stage of deleting
    // service succeeded, else we dont want to remove the recovery property.
    // If we never got to the last stage of DeleteService dwErr2 will be
    // ERROR_SUCCESS.
    //
    RECOVERY_TEST_POINT(L"RemoveReplica", 5);

    if (dwErr2 == ERROR_SUCCESS)
            _Recover.SetOperationDone();

    if ((dwErr == ERROR_SUCCESS) || (fDeleteOptions & DFS_OVERRIDE_FORCE))   {
        //
        // Now update the PKT as well.
        //
        dwErr = UpdatePktEntry(NULL);
        if (dwErr != ERROR_SUCCESS)  {
            //
            // Something is really messed up if we got here.
            //
            LogMessage(DEB_ERROR, nullPtr, 0, DFS_FAILED_UPDATE_PKT_MSG);
            IDfsVolInlineDebOut((DEB_ERROR,
                            "UpdPktEntry in RemRepl failed %08lx\n", dwErr));
            ASSERT(L"UpdatePktEntry in RemoveRepl failed\n");
        }
    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::RemoveReplica() exit\n"));

    return(dwErr);
}


//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::Delete, public
//
// Synopsis:    This method deletes the volume object and deletes all knowledge
//              of this volume at all the services that were supporting this
//              volume in the namespace. At the same time the exit point at the
//              parent volume is deleted. All of the services that support this
//              volume are also advised to delete all information regarding this
//              volume. There is an additional restriction that there should
//              be only one service associated with a volume to be able to call
//              method. This operation has problems due to its distributed
//              nature. The moment the service supporting this volume has been
//              informed to delete its local volume knowledge this operation is
//              committed. In the case of Network failures while talking to one
//              of the services involved, this operation continues to go on. If
//              any such errors are encountered they are reported to the caller
//              though the operation is declared to be a success. Note that this
//              operation does not delete the storage and has nothing to do with
//              that aspect. By not confirming the deletion of all ExitPoint
//              info anywhere this operation can directly introduce an
//              inconsistency of TOO MANY EXIT Points. This inconsistency is
//              well understood and easy to deal with.
//
// Arguments:   None
//
// Returns:     DFS_S_SUCCESS --        If all went well.
//
//              NERR_DfsNotALeafVolume --
//                              An attempt was made to delete a volume which
//                              has child volumes and hence the operation failed
//
//              NERR_DfsVolumeDataCorrupt --
//                              The volume object seems to be corrupt due to
//                              which this operation cannot proceed at all.
//
//              NERR_DfsVolumeHasMultipleServers --
//                              This operation will not succeed if there is
//                              more than one service assoicated with the vol.
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::Delete(
    ULONG               fDeleteOptions)
{
    DWORD     dwErr = ERROR_SUCCESS;
    CDfsVolume  *parent = NULL;
    BOOLEAN     InconsistencyPossible = FALSE;
    BOOLEAN     ParentInconsistency = FALSE;
    CDfsService *pDfsSvc;
    ULONG       rState = 0;
    ULONG       count = 0;
    PWCHAR      ErrorStrs[3];

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::Delete()\n"));

    if (NotLeafVolume())
        dwErr = NERR_DfsNotALeafVolume;

    //
    // We want to make sure that this is not the root volume
    //

    if (dwErr == ERROR_SUCCESS &&
            _EntryType & DFS_VOL_TYPE_REFERRAL_SVC &&
                !(_EntryType & DFS_VOL_TYPE_INTER_DFS)) {
        dwErr = NERR_DfsCantRemoveDfsRoot;
    }

    //
    // We next want to make sure that there is only one service associated
    // with this volume else we will fail this operation right now.
    //
    if (dwErr == ERROR_SUCCESS)
        if (_DfsSvcList.GetServiceCount()>1)
            dwErr = NERR_DfsVolumeHasMultipleServers;

    if (dwErr != ERROR_SUCCESS) {

        return(dwErr);
    }

    if(dwErr == ERROR_SUCCESS) {

        //
        // we are going to need to talk with the parent once the
        // child is gone, so we get a handle to it now.
        // If we fail to bind to parent. Then it probably means that
        // this is a top level volume object and hence cannot be deleted.
        // We return the error to the caller.
        //

        dwErr = GetParent(&parent);

        if (dwErr != ERROR_SUCCESS)  {
            LogMessage(DEB_TRACE, nullPtr, 0, DFS_CANT_GET_PARENT_MSG);
            dwErr = NERR_DfsVolumeDataCorrupt;
        }
    }

    if (dwErr != ERROR_SUCCESS) {

        return(dwErr);
    }

    if (dwErr == ERROR_SUCCESS)   {

        //
        // Before we take off on our operation. We should setup the
        // State variable on the Volume object indicating that we are
        // deleting this volume from the namespace.
        //

        RECOVERY_TEST_POINT(L"DeleteVolume", 1);

        dwErr = _Recover.SetOperationStart(DFS_RECOVERY_STATE_DELETE, NULL);

        RECOVERY_TEST_POINT(L"DeleteVolume", 2);

        //
        // Now we inform the service to delete its LocalVolume knowledge.
        //
        if (dwErr == ERROR_SUCCESS) {
            pDfsSvc = _DfsSvcList.GetFirstService();

            if (pDfsSvc != NULL)        {
                dwErr = pDfsSvc->DeleteLocalVolume(&_peid);
                //
                // If we got an error here, we dont really want to go on??
                //
                // When we move to DWORDs we might want to return exactly
                // which service did not get updated etc.
                //
            }
	}
    }

    if ((dwErr == ERROR_SUCCESS) || (fDeleteOptions & DFS_OVERRIDE_FORCE))   {

        //
        // Now we set Recovery State to new value if we have informed
        // all related services.
        //
        RECOVERY_TEST_POINT(L"DeleteVolume", 3);

        _Recover.SetOperStage(DFS_OPER_STAGE_INFORMED_SERVICE);

        RECOVERY_TEST_POINT(L"DeleteVolume", 4);

        //
        // We need to tell each service of the parent volume to delete the
        // exit point. I think at this point we have to force the operation
        // through. Even if we are not able to delete some exit points it
        // is OK. We will return a success error code but will indicate
        // that there could potentially be a possible inconsistency in the
        // parent volume's knowledge.
        //

        pDfsSvc = parent->_DfsSvcList.GetFirstService();
        while (pDfsSvc != NULL) {

            //
            // Ignore error codes from this. We dont care if we cant
            // make some machine to delete the exit point.
            // The possible things that could happen here are that the
            // remote machine will say that it cannot delete the exit
            // point since the GUIDs dont match OR the exit point does
            // not exist (It got deleted due to reconciliation) or
            // Network failures themselves. In all cases we dont care.
            // We will return a status code which indicates that one
            // of the parent services misbehaved and admin needs to
            // make sure that nothing is wrong.
            //

            dwErr = pDfsSvc->DeleteExitPoint(&_peid, _EntryType);

            if (dwErr != ERROR_SUCCESS)      {
	      PWCHAR              ErrorStrs[1];
                ParentInconsistency = TRUE;
		ErrorStrs[0] = pDfsSvc->GetServiceName();
                LogMessage(DEB_ERROR,
                        ErrorStrs,
                        1,
                        DFS_CANT_DELETE_EXIT_POINT_MSG);
                IDfsVolInlineDebOut((DEB_ERROR,
                        "ErrorCode from DeleteExitPoint %08lx\n",
                        dwErr));
            }
            dwErr = ERROR_SUCCESS;
            pDfsSvc = parent->_DfsSvcList.GetNextService(pDfsSvc);

        }

    }

    //
    // We want to get rid of the parent pointer if we no longer need it.
    //
    if (parent != NULL)     {
        parent->Release();
        parent = NULL;
    }

    //
    // If the operation failed we want to set the properties to done else
    // we are anyway going to go in and delete this object itself.
    //
    RECOVERY_TEST_POINT(L"DeleteVolume", 5);

    if (dwErr != ERROR_SUCCESS)      {
        _Recover.SetOperationDone();
    }

    //
    // If we successfully managed to do the deletion then we go ahead
    // and delete the volume object from disk. Note that even if
    // Network failures occur while talking to each of the services
    // above we will go on. Once this deletion happens the operation is
    // commited. Updating the PKT is not a part of the commit point.
    //

    if ((dwErr == ERROR_SUCCESS) || (fDeleteOptions & DFS_OVERRIDE_FORCE))   {
            DeleteObject();
            //
            // We need to make this instance of the VolumeObject invalid or
            // so that no one can do any more operations on this volume.
            //
            _Deleted = TRUE;
    }

    //
    // Now we go and update the PKT with the deletion information.
    // Once again we ignore errors here except to return an
    // INCONSISTENCY status code.
    //
    if ((dwErr == ERROR_SUCCESS) || (fDeleteOptions & DFS_OVERRIDE_FORCE))   {

        dwErr = DeletePktEntry(&_peid);

        if (dwErr != ERROR_SUCCESS)  {

            LogMessage(
                DEB_ERROR, &(_peid.Prefix.Buffer), 1,
                DFS_CANT_DELETE_ENTRY_MSG);

            IDfsVolInlineDebOut((
                DEB_ERROR, "DelPktEnt Failed%08lx\n", dwErr));

            ASSERT(L"DeletePktEntry Failed in Deletion of Volume");

            dwErr = ERROR_SUCCESS;

        }

    }



    if (parent != NULL)
        parent->Release();

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::Delete() exit\n"));

    return( dwErr );
}


//+-------------------------------------------------------------------------
//
// Method:      CDfsVolume::CreateChildX, public
//
// Synopsis:    This is one way of creating new volume objects.
//              This operation involves the creation of the volume object,
//              Updating the parent's knowledge regarding the new exit point
//              and creating the exit point. The parent volume could have
//              multiple replicas. In this case all the replicas are informed
//              of the changes and are advised to create the relevant knowledge.
//              This operation will roll back in the event of a failure during
//              the operation before it is complete. If all of the parent's
//              cannot create the exit point information then this operation
//              will not proceed. Every attempt will be made to delete all
//              information that was created on other replicas but no guarantees
//              are made about this. However, all local knowledge will be
//              deleted and knowledge synchronisation is supposed to eliminate
//              any problems that might have arised because of inconsistencies
//              created by this operation.
//
// Arguments:   [pwszChildName] -- The last component of child Vol object Name.
//
//              [pwszEntryPath] -- The entry path for the new volume in the namespace
//
//              [ulVolType] -- The type of the volume.
//                              Values in the IDL file for this interface.
//
//              [pChild] --     This is where the IDfsVolume reference is
//                              returned to caller.
//
//              [pComment] --   Comment for this volume.
//
// Returns:     ERROR_SUCCESS -- If the operation succeeded with NO problems.
//
//              ERROR_INVALID_PARAMETER -- The child volume's prefix is not
//                      hierarchically subordinate to this volume's prefix.
//
//              NERR_DfsVolumeIsInterDfs -- The volume is an inter-dfs one;
//                      can't create a child volume.
//
//              NERR_DfsNotSupportedInServerDfs -- Can't have more than one
//                      level of hierarchy in Server Dfs.
//
//              NERR_DfsLeafVolume -- This is a downlevel or leaf volume,
//                      can't create a child here.
//
//              NERR_DfsCantCreateJunctionPoint -- Unable to create a
//                      junction point on any of the server-shares
//
//--------------------------------------------------------------------------
DWORD
CDfsVolume::CreateChildX(
    WCHAR *             childName,
    WCHAR *             pwszPrefix,
    ULONG               ulVolType,
    LPWSTR              pwszComment,
    CDfsVolume          **ppChild)
{
    DWORD               dwErr = ERROR_SUCCESS;
    CDfsVolume          *pChild = NULL;
    CDfsService         *pDfsSvc = NULL;
    BOOLEAN             CreatedExitPt = FALSE;
    BOOLEAN             InconsistencyPossible = FALSE;
    PWCHAR              pwszSuffix = NULL;
    PWCHAR              ErrorStrs[3];
    ULONG               ulen = 0;
    LPWSTR              wszChildShortName;
    BOOLEAN             GotShortName = FALSE;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::CreateChildX(%ws,%ws,0x%x,%s)\n",
            childName, pwszPrefix, ulVolType, pwszComment));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("DfsVolume::CreateChildX(%ws,%ws,0x%x,%ws)\n",
            childName,
            pwszPrefix,
            ulVolType,
            pwszComment);
#endif

    //
    // Check for validity of Type field and for LEAF volume etc. Only the
    // allowed TypeBits should be set and also one of the Three required Types
    // bits should be set.
    //

    //
    // We check to make sure that the prefix of the child volume meets
    // our heirarchy requirements. It must be strictly a child of this
    // volume's prefix, and must not cross inter-dfs boundaries.
    //

    if (dwErr == ERROR_SUCCESS) {

        if (_EntryType & DFS_VOL_TYPE_INTER_DFS) {

            dwErr = NERR_DfsVolumeIsInterDfs;

        } else if (ulDfsManagerType == DFS_MANAGER_SERVER &&
                    ((_EntryType & DFS_VOL_TYPE_REFERRAL_SVC) == 0)) {

            dwErr = NERR_DfsVolumeAlreadyExists;
#if DBG
            if (DfsSvcVerbose)
                DbgPrint("CDfsVolume::CreateChildX: dwErr = NERR_DfsVolumeAlreadyExists\n");
#endif

        } else if (_wcsnicmp(_peid.Prefix.Buffer, pwszPrefix,
                        wcslen(_peid.Prefix.Buffer)) != 0) {

            dwErr = ERROR_INVALID_PARAMETER;
#if DBG
            if (DfsSvcVerbose) {
                DbgPrint("CDfsVolume::CreateChildX(1): [%ws]!=[%ws] (1st %d chars)\n",
                            _peid.Prefix.Buffer,
                            pwszPrefix,
                            wcslen(_peid.Prefix.Buffer));
                DbgPrint("CDfsVolume::CreateChildX(1): dwErr = ERROR_INVALID_PARAMETER\n");
            }
#endif

        } else {

            //
            // In this case we want to make sure that the new EntryPath
            // is also greater than the entrypath for this volume, and that
            // it is a valid Win32 Path name
            //

            LPWSTR wszExitPath = &pwszPrefix[_peid.Prefix.Length/sizeof(WCHAR)];

            if (wcslen(pwszPrefix) <= wcslen(_peid.Prefix.Buffer)) {

                if (_wcsicmp(pwszPrefix,_peid.Prefix.Buffer) == 0) {
                    dwErr = NERR_DfsVolumeAlreadyExists;
                } else {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
#if DBG
                if (DfsSvcVerbose) {
                    DbgPrint("CDfsVolume::CreateChildX(2): dwErr = %d\n");
                    DbgPrint("      pwszPrefix=[%ws],_peid.Prefix.Buffer=[%ws]\n",
                                        pwszPrefix,
                                        _peid.Prefix.Buffer);
                }
#endif

            } else if (!IsValidWin32Path( wszExitPath )) {

                dwErr = ERROR_BAD_PATHNAME;
#if DBG
                if (DfsSvcVerbose)
                    DbgPrint("CDfsVolume::CreateChildX: dwErr = ERROR_BAD_PATHNAME\n");
#endif

            }

        }

    }

    if (dwErr == ERROR_SUCCESS)   {

        //
        // We first try to create the volume object. So that we can use
        // it to go about our state management stuff for recovery purposes.
        // It automatically sets recoveryState to being OPER_START etc.
        // It will also set a NULL service list for now. This method will
        // also pick a GUID for us. We dont need to pass it one.
        //

        dwErr = CreateChildPartition(
                childName,
                ulVolType,
                pwszPrefix,
                pwszComment,
                NULL,
                NULL,
                &pChild);

        if (dwErr != ERROR_SUCCESS)  {

            IDfsVolInlineDebOut((
                DEB_ERROR, "Unable to create child %ws\n under : %ws\n",
                    pwszPrefix, _peid.Prefix.Buffer));

        }

    }

    if (dwErr == ERROR_SUCCESS)   {

        RECOVERY_TEST_POINT(L"CreateChildX", 1);

        //
        // We next try to create exit points on each of the services for
        // the parent volume. However, we need to create an exit point on
        // only one of the services for the parent volume. We rely on
        // Replication to reconcile everything to other machines.
        //

        pDfsSvc = _DfsSvcList.GetFirstService();

        while (pDfsSvc!=NULL)       {

                dwErr = pDfsSvc->CreateExitPoint(
                        &(pChild->_peid),
                        ulVolType);

                if (dwErr == ERROR_SUCCESS) {

                    //
                    // This would have updated the short name. Save it...
                    //

                    CreatedExitPt = TRUE;

                    if (!GotShortName) {

                        DWORD dwErrUpdatedShortName;

                        dwErrUpdatedShortName = pChild->SaveShortName();

                        if (dwErrUpdatedShortName == ERROR_SUCCESS) {

                            GotShortName = TRUE;

                            IDfsVolInlineDebOut((
                                DEB_TRACE, "Setting short name to: %ws\n",
                                pChild->_peid.ShortPrefix.Buffer));

                        } else {

                            IDfsVolInlineDebOut((
                                DEB_ERROR, "Error %08lx setting short name\n",
                                dwErrUpdatedShortName));
                        }

                    }


                } else {

                    InconsistencyPossible = TRUE;

                    IDfsVolInlineDebOut((
                        DEB_ERROR, "Failed to CreateExPt %08lx %ws\n",
                        dwErr, pChild->_peid.Prefix.Buffer));

                }

                dwErr = ERROR_SUCCESS;

                pDfsSvc = _DfsSvcList.GetNextService(pDfsSvc);

        }

        //
        // If we did create an exit point on atleast one machine we can go on.
        // Also we can set the state to DONE!!
        //

        if (CreatedExitPt == TRUE)  {

            //
            // We need to ClearUp Recovery Properties here!!
            //

            RECOVERY_TEST_POINT(L"CreateChildX", 2);

            pChild->_Recover.SetOperationDone();

        } else {

            //
            // We have to delete the object that we created. dwErr already
            // has an error code in it. Let that go by us. Remember however,
            // the exit point itself never got created as far as the DC is
            // concerned and hence makes no sense to try to undo that stuff.
            //
            LogMessage(
                DEB_ERROR,nullPtr,0,DFS_CANT_CREATE_ANY_EXIT_POINT_MSG);

            pChild->DeleteObject();

            dwErr = NERR_DfsCantCreateJunctionPoint;

        }

    }

    //
    // Now we merely need to update the PKT with the relevant information.
    //

    if (dwErr == ERROR_SUCCESS) {

        dwErr = pChild->CreateSubordinatePktEntry(NULL, &_peid, FALSE);

        if (dwErr != ERROR_SUCCESS)  {
            LogMessage(
                DEB_ERROR, &_peid.Prefix.Buffer, 1,
                DFS_CANT_CREATE_SUBORDINATE_ENTRY_MSG);

            IDfsVolInlineDebOut((
                DEB_ERROR, "Failed CreateSubordPktEntry %08lx\n", dwErr));

            ASSERT(L"CreateSubordinateEntry Failed in CreateChild");

        }

    }

    if (dwErr != ERROR_SUCCESS) {

        if (pChild != NULL)
            pChild->Release();

        *ppChild = NULL;

    } else {

        *ppChild = pChild;

    }

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::CreateChildX() exit %d\n", dwErr));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsVolume::CreateChildX exit %d\n", dwErr);
#endif

    return((dwErr));

}


//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::CreateChild, public
//
// Synopsis:    This is one way of creating new volume objects.
//              This operation involves the creation of the volume object,
//              Updating the parent's knowledge regarding the new exit point
//              and creating the exit point. The parent volume could have
//              multiple replicas. In this case all the replicas are informed
//              of the changes and are advised to create the relevant knowledge.
//              This operation will roll back in the event of a failure during
//              the operation before it is complete. Every attempt will be made
//              to delete all information that was created on other replicas
//              but no guarantees are made about this. However, all local
//              knowledge will be deleted and knowledge synchronisation is
//              supposed to eliminate any problems that might have arised
//              because of inconsistencies created by this operation. This
//              operation also associates a SERVICE with the volume that it
//              creates (unlike the CreateChild/CreateInActiveVolume) operation.
//              Hence it also needs to communicate with the relevant service.
//
// Arguments:   [pwszEntryPath] -- The entry path for the new volume in the namespace
//                            This entry path is relative to the parent's entrypath.
//
//              [ulVolType] -- The type of the volume. Look in dfsh.idl
//
//              [pReplInfo] --  The ServiceInfo for the first replica.
//
//              [pChild] --     This is where the IDfsVolume reference is
//                              returned to caller.
//
//              [pwszComment] -- Comment for this volume.
//
// Returns:     Error code from CreateChildX() or AddReplica().
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::CreateChild(
    LPWSTR              pwszPrefix,
    ULONG               ulVolType,
    PDFS_REPLICA_INFO   pReplicaInfo,
    PWCHAR              pwszComment,
    ULONG               fCreateOptions)
{
    CDfsVolume *pChild;

    DWORD dwErr = ERROR_SUCCESS;


    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::CreateChild(%ws,0x%x,%ws,0x%x)\n",
            pwszPrefix, ulVolType, pwszComment, fCreateOptions));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsVolume::CreateChild(%ws,0x%x,%ws,%ws,%ws,0x%x)\n",
            pwszPrefix,
            ulVolType,
            pReplicaInfo->pwszServerName,
            pReplicaInfo->pwszShareName,
            pwszComment,
            fCreateOptions);
#endif
            

    if (VolumeOffLine()) {

        return( NERR_DfsVolumeIsOffline );
    }

    //
    // I will cheat for now but will come back and fix this later on. Raid 455283
    // At this place I basically need to have a recovery mechanism to recover
    // in between the operations etc. The entire operation should be done or
    // undone. In the present scheme only the two suboperations below will
    // be in some sense "atomic" but not this entire operation itself.
    //

    dwErr = CreateChildX(
                        NULL,           // Dont give any child name.
                        pwszPrefix,
                        ulVolType,
                        pwszComment,
                        &pChild);

    if (dwErr != ERROR_SUCCESS)  {

        return((dwErr));
    }

    //
    // Now let us go ahead and associate a service with the volume object that
    // we just created.
    //
    dwErr = pChild->AddReplica(pReplicaInfo, fCreateOptions);

    //
    // If AddServic failed then we have to delete the object itself and
    // backout the entire operation.
    //

    if (dwErr != ERROR_SUCCESS)
        pChild->Delete(DFS_OVERRIDE_FORCE);

    pChild->Release();

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::CreateChild() exit\n"));

#if DBG
    if (DfsSvcVerbose)
        DbgPrint("CDfsVolume::CreateChild exit %d\n", dwErr);
#endif

    return((dwErr));
}


//+-------------------------------------------------------------------------
//
// Member:      CDfsVolume::Move, public
//
// Synopsis:    This operation moves a volume from one place in the namespace
//              to another point in the namespace. Here we need the
//              volume Name and the new entry Path. The old entryPath is
//              already available to us since we can get it from the properties
//              on the volume object. The volume to be moved should be a leaf
//              volume (should have no children) else this operation will
//              return an Error Code.
//
// Arguments:   [pwszNewPrefix] -- The new EntryPath for this volume. This
//                                 should be absolute path.
//
// Returns:     ERROR_SUCCESS -- The operation succeeded.
//
//              ERROR_INVALID_PARAMETER -- If pwszNewPrefix is a
//                      hierarchically below the current prefix!
//
//              NERR_DfsVolumeAlreadyExists -- A Dfs volume with the same
//                      prefix as pwszNewPrefix already exists
//
//              Error from various IDfsvol methods.
//
//--------------------------------------------------------------------------

DWORD
CDfsVolume::Move(
    LPWSTR              pwszNewPrefix
)
{
    DWORD                       dwErr = ERROR_SUCCESS;

    IDfsVolInlineDebOut((DEB_TRACE, "CDfsVolume::Move(%ws)\n", pwszNewPrefix));

    CDfsVolume                  *pNewParentVol = NULL;
    CDfsVolume                  *pChildVol = NULL;
    CDfsVolume                  *pOldParentVol = NULL;

    BOOLEAN                     CreatedExitPt = FALSE;
    CDfsService                 *pService;
    CDfsService                 *pNextService;
    DFS_PKT_ENTRY_ID            NewId;

    LPWSTR                      pwszChildName = NULL;
    LPWSTR                      pwszNewParentPrefix = NULL;
    LPWSTR                      pwszNewParentObject = NULL;
    ULONG                       volPrefixLen, prefixLen;



    if (VolumeOffLine()) {
        return(NERR_DfsVolumeIsOffline);
    }

    if (NotLeafVolume())        {
        return(NERR_DfsNotALeafVolume);
    }

    //
    // Get a hold of the new parent, and check the validity of pwszNewPrefix
    // in the process
    //

    prefixLen = wcslen( pwszNewPrefix );
    pwszNewParentPrefix = new WCHAR[prefixLen + 1];
    prefixLen *= sizeof(WCHAR);

    if (pwszNewParentPrefix == NULL) {

        dwErr = ERROR_OUTOFMEMORY;

    } else {

        wcscpy( pwszNewParentPrefix, pwszNewPrefix );

        dwErr = pDfsmStorageDirectory->GetObjectForPrefix(
                    pwszNewParentPrefix,
                    FALSE,
                    &pwszNewParentObject,
                    &volPrefixLen);

        if (dwErr == ERROR_SUCCESS) {

            pwszNewParentPrefix[ volPrefixLen/sizeof(WCHAR) ] =
                UNICODE_NULL;
            if (prefixLen == volPrefixLen) {
                dwErr = NERR_DfsVolumeAlreadyExists;
            } else {
                if (!_wcsnicmp(pwszNewParentPrefix,
                             _peid.Prefix.Buffer,
                             _peid.Prefix.Length/sizeof(WCHAR)))
                {
                    //
                    // This means that we are trying to move somewhere
                    // below where we already are in the namespace. This
                    // is total nonsense. Return right now.
                    //
                    dwErr = ERROR_INVALID_PARAMETER;

                }
            }

        } else {
            IDfsVolInlineDebOut((
                DEB_ERROR, "Failed to FindVolPrefix %08lx %ws\n",
                dwErr, pwszNewParentPrefix));
        }
    }

    //
    // Instantiate the parent and cleanup strings used to get parent...
    //

    if (dwErr == ERROR_SUCCESS) {

        pNewParentVol = new CDfsVolume();

        if (pNewParentVol != NULL) {

            dwErr = pNewParentVol->LoadNoRegister(
                        pwszNewParentObject,
                        0);

        } else {

            dwErr = ERROR_OUTOFMEMORY;

        }

    }

    delete [] pwszNewParentPrefix;

    if (pwszNewParentObject != NULL) {
        delete [] pwszNewParentObject;
    }

    if (dwErr == ERROR_SUCCESS) {

        //
        // Now that we have a handle on the appropriate volume object we
        // can go ahead and perform the move.
        //

        dwErr = pNewParentVol->CreateChildPartition(
                    NULL,
                    _EntryType,
                    pwszNewPrefix,
                    _pwszComment,
                    &_peid.Uid,
                    NULL,
                    &pChildVol);

        delete [] pwszChildName;

        RECOVERY_TEST_POINT(L"Move", 1);

    }

    //
    // If we succeeded in creating the object then we need to go and
    // set the service List appropriately. Note that we will not
    // set any recovery properties for now. We will exploit the recovery
    // props setup by CreateChildPartition.
    //

    if (dwErr == ERROR_SUCCESS)      {

        pService = _DfsSvcList.GetFirstService();
        while (pService != NULL)    {
            pNextService = _DfsSvcList.GetNextService(pService);
            _DfsSvcList.RemoveService(pService);
            dwErr = pChildVol->_DfsSvcList.SetNewService(pService);
            if (dwErr != ERROR_SUCCESS) {
                IDfsVolInlineDebOut((DEB_ERROR, "Failed to Set SvcProp %08lx\n",dwErr));
                break;
            }
            pService = pNextService;
        }

        //
        // Now we need to carefully remove the services from inmemory
        // instantiation of the new pChildVol
        //
        pService = pChildVol->_DfsSvcList.GetFirstService();
        while (pService != NULL)    {
            pNextService = pChildVol->_DfsSvcList.GetNextService(pService);
            pChildVol->_DfsSvcList.RemoveService(pService);
            _DfsSvcList.InsertNewService(pService);
            pService = pNextService;
        }

        